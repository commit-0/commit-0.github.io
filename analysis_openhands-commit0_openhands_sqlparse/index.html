
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis openhands commit0 openhands sqlparse - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#openhands-sqlparse" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis openhands commit0 openhands sqlparse
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_clipytest_parser_empty" class="md-nav__link">
    <span class="md-ellipsis">
      test_cli.py::test_parser_empty
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clipytest_valid_args" class="md-nav__link">
    <span class="md-ellipsis">
      test_cli.py::test_valid_args
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clipytest_invalid_args" class="md-nav__link">
    <span class="md-ellipsis">
      test_cli.py::test_invalid_args
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clipytest_invalid_infile" class="md-nav__link">
    <span class="md-ellipsis">
      test_cli.py::test_invalid_infile
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clipytest_invalid_outfile" class="md-nav__link">
    <span class="md-ellipsis">
      test_cli.py::test_invalid_outfile
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clipytest_encoding_stdinencoding_utf8sql-utf-8" class="md-nav__link">
    <span class="md-ellipsis">
      test_cli.py::test_encoding_stdin[encoding_utf8.sql-utf-8]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clipytest_encoding_stdinencoding_gbksql-gbk" class="md-nav__link">
    <span class="md-ellipsis">
      test_cli.py::test_encoding_stdin[encoding_gbk.sql-gbk]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformattest_keywordcase" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormat::test_keywordcase
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformattest_identifiercase" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormat::test_identifiercase
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformattest_identifiercase_invalid_option" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormat::test_identifiercase_invalid_option
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformattest_identifiercase_quotes" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormat::test_identifiercase_quotes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformattest_strip_comments_single" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormat::test_strip_comments_single
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformattest_strip_comments_invalid_option" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormat::test_strip_comments_invalid_option
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformattest_strip_comments_multi" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormat::test_strip_comments_multi
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformattest_strip_comments_preserves_linebreak" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormat::test_strip_comments_preserves_linebreak
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformattest_strip_comments_preserves_whitespace" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormat::test_strip_comments_preserves_whitespace
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformattest_strip_ws" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormat::test_strip_ws
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformattest_strip_ws_invalid_option" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormat::test_strip_ws_invalid_option
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformattest_preserve_ws" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormat::test_preserve_ws
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformattest_notransform_of_quoted_crlf" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormat::test_notransform_of_quoted_crlf
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindentalignedtest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindentAligned::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindentalignedtest_joins" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindentAligned::test_joins
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindentalignedtest_case_statement" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindentAligned::test_case_statement
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindentalignedtest_case_statement_with_between" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindentAligned::test_case_statement_with_between
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindentalignedtest_group_by" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindentAligned::test_group_by
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindentalignedtest_group_by_subquery" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindentAligned::test_group_by_subquery
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindentalignedtest_window_functions" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindentAligned::test_window_functions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestspacesaroundoperatorstest_basic" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestSpacesAroundOperators::test_basic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestspacesaroundoperatorstest_bools" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestSpacesAroundOperators::test_bools
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestspacesaroundoperatorstest_nested" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestSpacesAroundOperators::test_nested
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestspacesaroundoperatorstest_wildcard_vs_mult" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestSpacesAroundOperators::test_wildcard_vs_mult
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindenttest_option" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindent::test_option
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindenttest_stmts" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindent::test_stmts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindenttest_keywords" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindent::test_keywords
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindenttest_keywords_between" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindent::test_keywords_between
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindenttest_parenthesis" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindent::test_parenthesis
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindenttest_where" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindent::test_where
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindenttest_join" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindent::test_join
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindenttest_identifier_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindent::test_identifier_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindenttest_identifier_list_with_wrap_after" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindent::test_identifier_list_with_wrap_after
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindenttest_identifier_list_comment_first" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindent::test_identifier_list_comment_first
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindenttest_identifier_list_with_functions" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindent::test_identifier_list_with_functions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindenttest_long_identifier_list_with_functions" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindent::test_long_identifier_list_with_functions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindenttest_case" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindent::test_case
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindenttest_case2" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindent::test_case2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindenttest_nested_identifier_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindent::test_nested_identifier_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindenttest_duplicate_linebreaks" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindent::test_duplicate_linebreaks
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindenttest_keywordfunctions" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindent::test_keywordfunctions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindenttest_identifier_and_functions" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindent::test_identifier_and_functions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestformatreindenttest_insert_values" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestFormatReindent::test_insert_values
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestoutputformattest_python" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestOutputFormat::test_python
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestoutputformattest_python_multiple_statements" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestOutputFormat::test_python_multiple_statements
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestoutputformattest_python_multiple_statements_with_formatting" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestOutputFormat::test_python_multiple_statements_with_formatting
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestoutputformattest_php" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestOutputFormat::test_php
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestoutputformattest_sql" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestOutputFormat::test_sql
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytestoutputformattest_invalid_option" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::TestOutputFormat::test_invalid_option
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytest_format_column_ordering" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::test_format_column_ordering
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytest_truncate_strings" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::test_truncate_strings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytest_truncate_strings_invalid_option2bar" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::test_truncate_strings_invalid_option2[bar]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytest_truncate_strings_invalid_option2-1" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::test_truncate_strings_invalid_option2[-1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytest_truncate_strings_invalid_option20" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::test_truncate_strings_invalid_option2[0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytest_truncate_strings_doesnt_truncate_identifiersselect-verrrylongcolumn-from-foo" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::test_truncate_strings_doesnt_truncate_identifiers[select verrrylongcolumn from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytest_truncate_strings_doesnt_truncate_identifiersselect-verrrylongcolumn-from-foo_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::test_truncate_strings_doesnt_truncate_identifiers[select "verrrylongcolumn" from "foo"]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytest_having_produces_newline" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::test_having_produces_newline
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytest_format_right_margin_invalid_optionten" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::test_format_right_margin_invalid_option[ten]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytest_format_right_margin_invalid_option2" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::test_format_right_margin_invalid_option[2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytest_format_right_margin" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::test_format_right_margin
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytest_format_json_ops" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::test_format_json_ops
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytest_compactcase-when-foo-then-1-else-bar-end-casen-when-foo-then-1n-else-barnend-case-when-foo-then-1-else-bar-end" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::test_compact[case when foo then 1 else bar end-case\n when foo then 1\n else bar\nend-case when foo then 1 else bar end]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formatpytest_strip_ws_removes_trailing_ws_in_groups" class="md-nav__link">
    <span class="md-ellipsis">
      test_format.py::test_strip_ws_removes_trailing_ws_in_groups
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_parenthesis" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_parenthesis
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_assignmentfoo-1" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_assignment[foo := 1;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_assignmentfoo-1_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_assignment[foo := 1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_typed_literalx-date-2020-01-01" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_typed_literal[x &gt; DATE '2020-01-01']
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_typed_literalx-timestamp-2020-01-01-000000" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_typed_literal[x &gt; TIMESTAMP '2020-01-01 00:00:00']
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_compare_exprselect-a-from-b-where-c-d-e-identifier-identifier" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_compare_expr[select a from b where c &lt; d + e-Identifier-Identifier]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_compare_exprselect-a-from-b-where-c-d-interval-1-day-identifier-typedliteral" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_compare_expr[select a from b where c &lt; d + interval '1 day'-Identifier-TypedLiteral]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_compare_exprselect-a-from-b-where-c-d-interval-6-month-identifier-typedliteral" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_compare_expr[select a from b where c &lt; d + interval '6' month-Identifier-TypedLiteral]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_compare_exprselect-a-from-b-where-c-current_timestamp-interval-1-day-token-typedliteral" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_compare_expr[select a from b where c &lt; current_timestamp - interval '1 day'-Token-TypedLiteral]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_identifiers" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_identifiers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_simple_identifiers1-as-f" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_simple_identifiers[1 as f]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_simple_identifiersfoo-as-f" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_simple_identifiers[foo as f]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_simple_identifiersfoo-f" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_simple_identifiers[foo f]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-as-f" class="md-nav__link">
    <span class="md-ellipsis">
      2 as f]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-f" class="md-nav__link">
    <span class="md-ellipsis">
      2 f]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_simple_identifiers12-as-f" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_simple_identifiers[1&lt;2 as f]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_simple_identifiers12-f" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_simple_identifiers[1&lt;2 f]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_group_identifier_listfoo-bar" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_group_identifier_list[foo, bar]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_group_identifier_listsuma-sumb" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_group_identifier_list[sum(a), sum(b)]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_group_identifier_listsuma-as-x-b-as-y" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_group_identifier_list[sum(a) as x, b as y]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_group_identifier_listsumainteger-b" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_group_identifier_list[sum(a)::integer, b]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#countb-as-x-y" class="md-nav__link">
    <span class="md-ellipsis">
      count(b) as x, y]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_group_identifier_listsumainteger-as-x-y" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_group_identifier_list[sum(a)::integer as x, y]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#countb-as-x-y_1" class="md-nav__link">
    <span class="md-ellipsis">
      count(b) as x, y]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_identifier_wildcard" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_identifier_wildcard
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_identifier_name_wildcard" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_identifier_name_wildcard
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_identifier_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_identifier_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_identifier_invalid_in_middle" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_identifier_invalid_in_middle
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_identifer_asfoo-as-select" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_identifer_as[foo as (select *)]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_identifer_asfoo-asselect" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_identifer_as[foo as(select *)]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_identifier_as_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_identifier_as_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_identifier_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_identifier_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_operationfoo100" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_operation[foo+100]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_operationfoo-100" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_operation[foo + 100]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_operationfoo100_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_operation[foo*100]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_identifier_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_identifier_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_identifier_list_subquery" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_identifier_list_subquery
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_identifier_list_case" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_identifier_list_case
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_identifier_list_other" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_identifier_list_other
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_identifier_list_with_inline_comments" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_identifier_list_with_inline_comments
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_identifiers_with_operators" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_identifiers_with_operators
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_identifier_list_with_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_identifier_list_with_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_nested_identifier_with_order" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_nested_identifier_with_order
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_where" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_where
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_where_unionselect-1-where-1-2-union-select-2" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_where_union[select 1 where 1 = 2 union select 2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_where_unionselect-1-where-1-2-union-all-select-2" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_where_union[select 1 where 1 = 2 union all select 2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_returning_kw_ends_where_clause" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_returning_kw_ends_where_clause
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_into_kw_ends_where_clause" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_into_kw_ends_where_clause
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_typecastselect-foointeger-from-bar-integer" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_typecast[select foo::integer from bar-integer]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_typecastselect-current_databaseinformation_schemasql_identifier-information_schemasql_identifier" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_typecast[select (current_database())::information_schema.sql_identifier-information_schema.sql_identifier]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_alias" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_alias
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_alias_case" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_alias_case
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_alias_ctas" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_alias_ctas
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_subquery_no_parens" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_subquery_no_parens
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_alias_returns_nonefoobar" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_alias_returns_none[foo.bar]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_alias_returns_nonex-y" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_alias_returns_none[x, y]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_alias_returns_nonex-y_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_alias_returns_none[x &gt; y]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#y" class="md-nav__link">
    <span class="md-ellipsis">
      y]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_idlist_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_idlist_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_comparison_exclude" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_comparison_exclude
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_function_not_in" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_function_not_in
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_varchar" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_varchar
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_statement_get_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_statement_get_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_identifier_with_operators" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_identifier_with_operators
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_identifier_with_op_trailing_ws" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_identifier_with_op_trailing_ws
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_identifier_with_string_literals" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_identifier_with_string_literals
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_identifier_consumes_ordering" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_identifier_consumes_ordering
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_comparison_with_keywords" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_comparison_with_keywords
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_comparison_with_floats" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_comparison_with_floats
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_comparison_with_parenthesis" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_comparison_with_parenthesis
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_comparison_with_strings" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_comparison_with_strings[=]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_comparison_with_strings_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_comparison_with_strings[!=]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_comparison_with_strings_2" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_comparison_with_strings[&gt;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_comparison_with_strings_3" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_comparison_with_strings[&lt;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_comparison_with_strings_4" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_comparison_with_strings[&lt;=]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_comparison_with_strings_5" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_comparison_with_strings[&gt;=]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_comparison_with_strings_6" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_comparison_with_strings[~]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_comparison_with_strings_7" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_comparison_with_strings[~~]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_comparison_with_strings_8" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_comparison_with_strings[!~~]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_comparison_with_stringslike" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_comparison_with_strings[LIKE]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_comparison_with_stringsnot-like" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_comparison_with_strings[NOT LIKE]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_comparison_with_stringsilike" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_comparison_with_strings[ILIKE]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_comparison_with_stringsnot-ilike" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_comparison_with_strings[NOT ILIKE]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_like_and_ilike_comparison" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_like_and_ilike_comparison
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_comparison_with_functions" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_comparison_with_functions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_comparison_with_typed_literal" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_comparison_with_typed_literal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_forloopsfor" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_forloops[FOR]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_forloopsforeach" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_forloops[FOREACH]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_nested_for" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_nested_for
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_begin" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_begin
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_keyword_followed_by_parenthesis" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_keyword_followed_by_parenthesis
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_nested_begin" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_nested_begin
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_aliased_column_without_as" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_aliased_column_without_as
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_qualified_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_qualified_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_aliased_function_without_as" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_aliased_function_without_as
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_aliased_literal_without_as" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_aliased_literal_without_as
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_as_cte" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_as_cte
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_groupingpytest_grouping_create_table" class="md-nav__link">
    <span class="md-ellipsis">
      test_grouping.py::test_grouping_create_table
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_keywordspytestsqlregextest_float_numbers10" class="md-nav__link">
    <span class="md-ellipsis">
      test_keywords.py::TestSQLREGEX::test_float_numbers[1.0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_keywordspytestsqlregextest_float_numbers-10" class="md-nav__link">
    <span class="md-ellipsis">
      test_keywords.py::TestSQLREGEX::test_float_numbers[-1.0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_keywordspytestsqlregextest_float_numbers1" class="md-nav__link">
    <span class="md-ellipsis">
      test_keywords.py::TestSQLREGEX::test_float_numbers[1.]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_keywordspytestsqlregextest_float_numbers-1" class="md-nav__link">
    <span class="md-ellipsis">
      test_keywords.py::TestSQLREGEX::test_float_numbers[-1.]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_keywordspytestsqlregextest_float_numbers1_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_keywords.py::TestSQLREGEX::test_float_numbers[.1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_keywordspytestsqlregextest_float_numbers-1_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_keywords.py::TestSQLREGEX::test_float_numbers[-.1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_tokenize" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_tokenize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_multistatement" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_multistatement
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_newlinesselectnfrom-foo" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_newlines[select\n*from foo;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_newlinesselectrnfrom-foo" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_newlines[select\r\n*from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_newlinesselectrfrom-foo" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_newlines[select\r*from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_newlinesselectrnfrom-foon" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_newlines[select\r\n*from foo\n]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_within" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_within
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_child_of" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_child_of
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_has_ancestor" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_has_ancestor
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_float5" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_float[.5]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_float51" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_float[.51]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_float15" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_float[1.5]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_float125" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_float[12.5]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_placeholderselect-from-foo-where-user-" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_placeholder[select * from foo where user = ?-?]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_placeholderselect-from-foo-where-user-1-1" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_placeholder[select * from foo where user = :1-:1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_placeholderselect-from-foo-where-user-name-name" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_placeholder[select * from foo where user = :name-:name]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_placeholderselect-from-foo-where-user-s-s" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_placeholder[select * from foo where user = %s-%s]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_placeholderselect-from-foo-where-user-a-a" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_placeholder[select * from foo where user = $a-$a]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_access_symbol" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_access_symbol
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_square_brackets_notation_isnt_too_greedy" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_square_brackets_notation_isnt_too_greedy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_square_brackets_notation_isnt_too_greedy2" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_square_brackets_notation_isnt_too_greedy2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_keyword_like_identifier" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_keyword_like_identifier
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_function_parameter" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_function_parameter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_function_param_single_literal" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_function_param_single_literal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_nested_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_nested_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_casted_params" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_casted_params
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_div_operator" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_div_operator
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_quoted_identifier" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_quoted_identifier
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_valid_identifier_namesfoo" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_valid_identifier_names[foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_valid_identifier_names_foo" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_valid_identifier_names[_foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_valid_identifier_names1_data" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_valid_identifier_names[1_data]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_valid_identifier_namesu696du8005u540du7a31" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_valid_identifier_names[\u696d\u8005\u540d\u7a31]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_psql_quotation_marks" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_psql_quotation_marks
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_double_precision_is_builtin" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_double_precision_is_builtin
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_placeholder" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_placeholder[?]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_placeholder1" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_placeholder[:1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_placeholderfoo" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_placeholder[:foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_placeholders" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_placeholder[%s]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_placeholderfoos" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_placeholder[%(foo)s]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_scientific_numbers667428e-8-expected0" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_scientific_numbers[6.67428E-8-expected0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_scientific_numbers1988e33-expected1" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_scientific_numbers[1.988e33-expected1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_scientific_numbers1e-12-expected2" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_scientific_numbers[1e-12-expected2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_scientific_numberse1-none" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_scientific_numbers[e1-None]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_single_quotes_are_strings" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_single_quotes_are_strings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_double_quotes_are_identifiers" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_double_quotes_are_identifiers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_single_quotes_with_linebreaks" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_single_quotes_with_linebreaks
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_sqlite_identifiers" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_sqlite_identifiers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_simple_1d_array_index" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_simple_1d_array_index
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_2d_array_index" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_2d_array_index
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_array_index_function_result" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_array_index_function_result
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_schema_qualified_array_index" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_schema_qualified_array_index
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_aliased_array_index" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_aliased_array_index
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_array_literal" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_array_literal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_typed_array_definition" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_typed_array_definition
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_single_line_commentsselect-1-foo" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_single_line_comments[select 1 -- foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_single_line_commentsselect-1-foo_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_single_line_comments[select 1 # foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_names_and_special_namesfoo" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_names_and_special_names[foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_names_and_special_namesfoo_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_names_and_special_names[@foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_names_and_special_namesfoo_2" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_names_and_special_names[#foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_names_and_special_namesfoo_3" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_names_and_special_names[##foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_get_token_at_offset" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_get_token_at_offset
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_pprint" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_pprint
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_wildcard_multiplication" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_wildcard_multiplication
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_stmt_tokens_parents" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_stmt_tokens_parents
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_dbldollar_as_literalfoo-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_dbldollar_as_literal[$$foo$$-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_dbldollar_as_literalfoo-true_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_dbldollar_as_literal[$$foo$$-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_dbldollar_as_literaltoken-foo-token-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_dbldollar_as_literal[$token$ foo $token$-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_dbldollar_as_literal-foo-tokenbartoken-baz-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_dbldollar_as_literal[$$ foo $token$bar$token$ baz$$-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_dbldollar_as_literala-foo-b-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_dbldollar_as_literal[$A$ foo $B$-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_non_ascii" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_non_ascii
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_get_real_name" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_get_real_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_from_subquery" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_from_subquery
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parenthesis" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parenthesis
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_configurable_keywords" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_configurable_keywords
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_configurable_regex" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_configurable_regex
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_json_operators-" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_json_operators[-&gt;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_json_operators-_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_json_operators[-&gt;&gt;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_json_operators" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_json_operators[#&gt;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_json_operators_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_json_operators[#&gt;&gt;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_json_operators_2" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_json_operators[@&gt;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_json_operators_3" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_json_operators[&lt;@]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_json_operators_4" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_json_operators[||]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_json_operators-_2" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_json_operators[-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_json_operators-_3" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_json_operators[#-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue9" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue9
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue13" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue13
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue26-hello" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue26[--hello]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue26-hello_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue26[-- hello]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue26-hellon" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue26[--hello\n]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue26-" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue26[--]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue26-n" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue26[--\n]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue34create" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue34[create]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue34create_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue34[CREATE]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue35" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue35
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue38" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue38
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue39" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue39
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue40" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue40
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_name-z-select-xytext-as-z-from-foo" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_name-z-select x.y::text as z from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_name-z-select-xytext-as-z-from-foo_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_name-z-select x.y::text as "z" from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_name-z-select-xytext-as-z-from-foo_2" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_name-z-select x."y"::text as z from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_name-z-select-xytext-as-z-from-foo_3" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_name-z-select x."y"::text as "z" from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_name-z-select-xytext-as-z-from-foo_4" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_name-z-select "x".y::text as z from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_name-z-select-xytext-as-z-from-foo_5" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_name-z-select "x".y::text as "z" from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_name-z-select-xytext-as-z-from-foo_6" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_name-z-select "x"."y"::text as z from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_name-z-select-xytext-as-z-from-foo_7" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_name-z-select "x"."y"::text as "z" from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_real_name-y-select-xytext-as-z-from-foo" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_real_name-y-select x.y::text as z from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_real_name-y-select-xytext-as-z-from-foo_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_real_name-y-select x.y::text as "z" from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_real_name-y-select-xytext-as-z-from-foo_2" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_real_name-y-select x."y"::text as z from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_real_name-y-select-xytext-as-z-from-foo_3" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_real_name-y-select x."y"::text as "z" from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_real_name-y-select-xytext-as-z-from-foo_4" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_real_name-y-select "x".y::text as z from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_real_name-y-select-xytext-as-z-from-foo_5" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_real_name-y-select "x".y::text as "z" from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_real_name-y-select-xytext-as-z-from-foo_6" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_real_name-y-select "x"."y"::text as z from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_real_name-y-select-xytext-as-z-from-foo_7" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_real_name-y-select "x"."y"::text as "z" from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_parent_name-x-select-xytext-as-z-from-foo" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_parent_name-x-select x.y::text as z from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_parent_name-x-select-xytext-as-z-from-foo_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_parent_name-x-select x.y::text as "z" from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_parent_name-x-select-xytext-as-z-from-foo_2" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_parent_name-x-select x."y"::text as z from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_parent_name-x-select-xytext-as-z-from-foo_3" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_parent_name-x-select x."y"::text as "z" from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_parent_name-x-select-xytext-as-z-from-foo_4" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_parent_name-x-select "x".y::text as z from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_parent_name-x-select-xytext-as-z-from-foo_5" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_parent_name-x-select "x".y::text as "z" from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_parent_name-x-select-xytext-as-z-from-foo_6" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_parent_name-x-select "x"."y"::text as z from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_parent_name-x-select-xytext-as-z-from-foo_7" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_parent_name-x-select "x"."y"::text as "z" from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_alias-z-select-xytext-as-z-from-foo" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_alias-z-select x.y::text as z from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_alias-z-select-xytext-as-z-from-foo_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_alias-z-select x.y::text as "z" from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_alias-z-select-xytext-as-z-from-foo_2" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_alias-z-select x."y"::text as z from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_alias-z-select-xytext-as-z-from-foo_3" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_alias-z-select x."y"::text as "z" from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_alias-z-select-xytext-as-z-from-foo_4" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_alias-z-select "x".y::text as z from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_alias-z-select-xytext-as-z-from-foo_5" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_alias-z-select "x".y::text as "z" from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_alias-z-select-xytext-as-z-from-foo_6" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_alias-z-select "x"."y"::text as z from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_alias-z-select-xytext-as-z-from-foo_7" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_alias-z-select "x"."y"::text as "z" from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_typecast-text-select-xytext-as-z-from-foo" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_typecast-text-select x.y::text as z from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_typecast-text-select-xytext-as-z-from-foo_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_typecast-text-select x.y::text as "z" from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_typecast-text-select-xytext-as-z-from-foo_2" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_typecast-text-select x."y"::text as z from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_typecast-text-select-xytext-as-z-from-foo_3" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_typecast-text-select x."y"::text as "z" from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_typecast-text-select-xytext-as-z-from-foo_4" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_typecast-text-select "x".y::text as z from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_typecast-text-select-xytext-as-z-from-foo_5" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_typecast-text-select "x".y::text as "z" from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_typecast-text-select-xytext-as-z-from-foo_6" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_typecast-text-select "x"."y"::text as z from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue78get_typecast-text-select-xytext-as-z-from-foo_7" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue78[get_typecast-text-select "x"."y"::text as "z" from foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue83" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue83
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_comment_encoding_when_reindent" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_comment_encoding_when_reindent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_parse_sql_with_binary" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_parse_sql_with_binary
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_dont_alias_keywords" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_dont_alias_keywords
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_format_accepts_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_format_accepts_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_stream" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_stream
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue90" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue90
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_except_formatting" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_except_formatting
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_null_with_as" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_null_with_as
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue190_open_file" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue190_open_file
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue193_splitting_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue193_splitting_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue194_splitting_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue194_splitting_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue186_get_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue186_get_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue213_leadingws" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue213_leadingws
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue227_gettype_cte" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue227_gettype_cte
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue207_runaway_format" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue207_runaway_format
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_token_next_doesnt_ignore_skip_cm" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_token_next_doesnt_ignore_skip_cm
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue284_as_groupingselect-x-as" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue284_as_grouping[SELECT x AS]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue284_as_groupingas" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue284_as_grouping[AS]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue315_utf8_by_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue315_utf8_by_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue322_concurrently_is_keyword" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue322_concurrently_is_keyword
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue359_index_error_assignmentsselect-min_priceminprice-max_pricemaxprice-from-shop" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue359_index_error_assignments[SELECT @min_price:=MIN(price), @max_price:=MAX(price) FROM shop;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue359_index_error_assignmentsselect-min_priceminprice-max_pricemaxprice-from-shop_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue359_index_error_assignments[SELECT @min_price:=MIN(price), @max_price:=MAX(price) FROM shop]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue469_copy_as_psql_command" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue469_copy_as_psql_command
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue484_comments_and_newlines" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue484_comments_and_newlines
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue485_split_multi" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue485_split_multi
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue489_tzcasts" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue489_tzcasts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_issue562_tzcasts" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_issue562_tzcasts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_as_in_parentheses_indents" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_as_in_parentheses_indents
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_format_invalid_where_clause" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_format_invalid_where_clause
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_splitting_at_and_backticks_issue588" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_splitting_at_and_backticks_issue588
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_comment_between_cte_clauses_issue632" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_comment_between_cte_clauses_issue632
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_copy_issue672" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_copy_issue672
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_primary_key_issue740" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_primary_key_issue740
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_regressionspytest_max_recursion" class="md-nav__link">
    <span class="md-ellipsis">
      test_regressions.py::test_max_recursion
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_semicolon" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_semicolon
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_backslash" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_backslash
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_create_functionfunctionsql" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_create_function[function.sql]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_create_functionfunction_psqlsql" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_create_function[function_psql.sql]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_create_functionfunction_psql2sql" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_create_function[function_psql2.sql]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_create_functionfunction_psql3sql" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_create_function[function_psql3.sql]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_create_functionfunction_psql4sql" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_create_function[function_psql4.sql]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_dashcomments" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_dashcomments
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_dashcomments_eolselect-foo-commentn" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_dashcomments_eol[select foo; -- comment\n]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_dashcomments_eolselect-foo-commentr" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_dashcomments_eol[select foo; -- comment\r]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_dashcomments_eolselect-foo-commentrn" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_dashcomments_eol[select foo; -- comment\r\n]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_dashcomments_eolselect-foo-comment" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_dashcomments_eol[select foo; -- comment]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_begintag" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_begintag
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_begintag_2" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_begintag_2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_dropif" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_dropif
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_comment_with_umlaut" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_comment_with_umlaut
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_comment_end_of_line" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_comment_end_of_line
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_casewhen" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_casewhen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_casewhen_procedure" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_casewhen_procedure
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_cursor_declare" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_cursor_declare
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_if_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_if_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_stream" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_stream
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_encoding_parsestream" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_encoding_parsestream
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_unicode_parsestream" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_unicode_parsestream
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_simple" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_simple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_ignores_empty_newlines" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_ignores_empty_newlines
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_quotes_with_new_line" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_quotes_with_new_line
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_mysql_handler_for" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_mysql_handler_for
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_strip_semicolonselect-from-foo-expected0" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_strip_semicolon[select * from foo;-expected0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_strip_semicolonselect-from-foo-expected1" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_strip_semicolon[select * from foo-expected1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_strip_semicolonselect-from-foo-select-from-bar-expected2" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_strip_semicolon[select * from foo; select * from bar;-expected2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_strip_semicolon-select-from-foonnselect-from-barnnnn-expected3" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_strip_semicolon[ select * from foo;\n\nselect * from bar;\n\n\n\n-expected3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_strip_semicolonselect-from-foonn-bar-expected4" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_strip_semicolon[select * from foo\n\n; bar-expected4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_strip_semicolon_procedure" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_strip_semicolon_procedure
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_gouse-foongonselect-1ngo-4" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_go[USE foo;\nGO\nSELECT 1;\nGO-4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_goselect-from-foongo-2" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_go[SELECT * FROM foo;\nGO-2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_gouse-foongo-2nselect-1-3" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_go[USE foo;\nGO 2\nSELECT 1;-3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_splitpytest_split_multiple_case_in_begin" class="md-nav__link">
    <span class="md-ellipsis">
      test_split.py::test_split_multiple_case_in_begin
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_tokenize_backticks" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_tokenize_backticks
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_tokenize_negative_numbers" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_tokenize_negative_numbers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_token_repr" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_token_repr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_tokenlist_repr" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_tokenlist_repr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_single_quotes" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_single_quotes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_tokenlist_first" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_tokenlist_first
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_tokenlist_token_matching" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_tokenlist_token_matching
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_stream_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_stream_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_joinjoin" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_join[JOIN]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_joinleft-join" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_join[LEFT JOIN]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_joinleft-outer-join" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_join[LEFT OUTER JOIN]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_joinfull-outer-join" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_join[FULL OUTER JOIN]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_joinnatural-join" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_join[NATURAL JOIN]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_joincross-join" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_join[CROSS JOIN]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_joinstraight-join" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_join[STRAIGHT JOIN]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_joininner-join" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_join[INNER JOIN]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_joinleft-inner-join" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_join[LEFT INNER JOIN]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_union" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_union
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_endifloopend-if" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_endifloop[END IF]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_endifloopend-if_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_endifloop[END IF]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_endifloopendtnif" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_endifloop[END\t\nIF]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_endifloopend-loop" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_endifloop[END LOOP]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_endifloopend-loop_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_endifloop[END LOOP]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_endifloopendtnloop" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_endifloop[END\t\nLOOP]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_orderasc" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_order[ASC]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_orderdesc" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_order[DESC]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_ordernulls-first" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_order[NULLS FIRST]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_ordernulls-last" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_order[NULLS LAST]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_orderasc-nulls-first" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_order[ASC NULLS FIRST]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_orderasc-nulls-last" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_order[ASC NULLS LAST]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_orderdesc-nulls-first" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_order[DESC NULLS FIRST]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_orderdesc-nulls-last" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_order[DESC NULLS LAST]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_identifiersfoo" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_identifiers[foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_identifiersfoo_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_identifiers[Foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_identifiersfoo_2" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_identifiers[FOO]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_identifiersvname" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_identifiers[v$name]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_group_by" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_group_by
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_order_by" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_order_by
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_window_as" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_window_as
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_like_and_ilike_parsed_as_comparisonslike" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_like_and_ilike_parsed_as_comparisons[LIKE]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_like_and_ilike_parsed_as_comparisonsilike" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_like_and_ilike_parsed_as_comparisons[ILIKE]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_like_and_ilike_parsed_as_comparisonsnot-like" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_like_and_ilike_parsed_as_comparisons[NOT LIKE]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_like_and_ilike_parsed_as_comparisonsnot-ilike" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_like_and_ilike_parsed_as_comparisons[NOT ILIKE]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_like_and_ilike_parsed_as_comparisonsnot-like_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_like_and_ilike_parsed_as_comparisons[NOT LIKE]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_like_and_ilike_parsed_as_comparisonsnot-ilike_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_like_and_ilike_parsed_as_comparisons[NOT ILIKE]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_near_like_and_ilike_parsed_appropriatelylikeaaa" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_near_like_and_ilike_parsed_appropriately[LIKEaaa]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_near_like_and_ilike_parsed_appropriatelybilike" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_near_like_and_ilike_parsed_appropriately[bILIKE]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_near_like_and_ilike_parsed_appropriatelyaailikebb" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_near_like_and_ilike_parsed_appropriately[aaILIKEbb]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_near_like_and_ilike_parsed_appropriatelynotlike" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_near_like_and_ilike_parsed_appropriately[NOTLIKE]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_near_like_and_ilike_parsed_appropriatelynotilike" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_near_like_and_ilike_parsed_appropriately[NOTILIKE]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_parse_tzcastat-time-zone-utc" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_parse_tzcast[AT TIME ZONE 'UTC']
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_tokenizepytest_cli_commands" class="md-nav__link">
    <span class="md-ellipsis">
      test_tokenize.py::test_cli_commands
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_openhands-commit0_openhands">back to OpenHands summary</a></p>
<h1 id="openhands-sqlparse"><strong>OpenHands</strong>: sqlparse</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">26</td>
</tr>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">434</td>
</tr>
<tr>
<td style="text-align: left;">xfailed</td>
<td style="text-align: center;">3</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">463</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">463</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_clipytest_parser_empty">test_cli.py::test_parser_empty</h3>
<details><summary> <pre>test_cli.py::test_parser_empty</pre></summary><pre>
def test_parser_empty():
>       with pytest.raises(SystemExit):
E       Failed: DID NOT RAISE <class 'SystemExit'>

tests/test_cli.py:15: Failed
</pre>
</details>
<h3 id="test_clipytest_valid_args">test_cli.py::test_valid_args</h3>
<details><summary> <pre>test_cli.py::test_valid_args</pre></summary><pre>
filepath = <function filepath.<locals>.make_filepath at 0x7ef7adc3a290>

    def test_valid_args(filepath):
        # test doesn't abort
        path = filepath('function.sql')
>       assert sqlparse.cli.main([path, '-r']) is not None

tests/test_cli.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/cli.py:65: in main
    data = sqlparse.format(data, reindent=True,
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_clipytest_invalid_args">test_cli.py::test_invalid_args</h3>
<details><summary> <pre>test_cli.py::test_invalid_args</pre></summary><pre>
filepath = <function filepath.<locals>.make_filepath at 0x7ef7adb481f0>
capsys = <_pytest.capture.CaptureFixture object at 0x7ef7aed1a440>

    def test_invalid_args(filepath, capsys):
        path = filepath('function.sql')
>       sqlparse.cli.main([path, '-r', '--indent_width', '0'])

tests/test_cli.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/cli.py:45: in main
    args = parser.parse_args(args)
/usr/lib/python3.10/argparse.py:1848: in parse_args
    self.error(msg % ' '.join(argv))
/usr/lib/python3.10/argparse.py:2606: in error
    self.exit(2, _('%(prog)s: error: %(message)s\n') % args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = ArgumentParser(prog='pytest', usage='%(prog)s  [OPTIONS] FILE, ...', description='Format SQL files.', formatter_class=<class 'argparse.HelpFormatter'>, conflict_handler='error', add_help=True)
status = 2
message = 'pytest: error: unrecognized arguments: --indent_width 0\n'

    def exit(self, status=0, message=None):
        if message:
            self._print_message(message, _sys.stderr)
>       _sys.exit(status)
E       SystemExit: 2

/usr/lib/python3.10/argparse.py:2593: SystemExit
</pre>
</details>
<h3 id="test_clipytest_invalid_infile">test_cli.py::test_invalid_infile</h3>
<details><summary> <pre>test_cli.py::test_invalid_infile</pre></summary><pre>
args = Namespace(files=['/testbed/tests/files/missing.sql'], outfile=None, reindent=True, language=None, encoding='utf-8', indent_width=2)

    def main(args=None):
        """Main entry point."""
        parser = create_parser()
        args = parser.parse_args(args)

        if not args.files:
            parser.print_help()
            sys.exit(1)

        encoding = args.encoding
        if encoding == 'utf-8':
            # Python 3 reads files as utf-8 by default
            encoding = None

        for file_ in args.files:
            try:
>               with open(file_, 'r', encoding=encoding) as f:
E               FileNotFoundError: [Errno 2] No such file or directory: '/testbed/tests/files/missing.sql'

sqlparse/cli.py:58: FileNotFoundError

During handling of the above exception, another exception occurred:

filepath = <function filepath.<locals>.make_filepath at 0x7ef7adc3a320>
capsys = <_pytest.capture.CaptureFixture object at 0x7ef7ad403d00>

    def test_invalid_infile(filepath, capsys):
        path = filepath('missing.sql')
>       sqlparse.cli.main([path, '-r'])

tests/test_cli.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/cli.py:61: in main
    _error('Failed to read {}: {}'.format(file_, e))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

msg = "Failed to read /testbed/tests/files/missing.sql: [Errno 2] No such file or directory: '/testbed/tests/files/missing.sql'"

    def _error(msg):
        """Print msg and optionally exit with return code exit_."""
        sys.stderr.write(msg + '\n')
>       sys.exit(1)
E       SystemExit: 1

sqlparse/cli.py:22: SystemExit
</pre>
</details>
<h3 id="test_clipytest_invalid_outfile">test_cli.py::test_invalid_outfile</h3>
<details><summary> <pre>test_cli.py::test_invalid_outfile</pre></summary><pre>
filepath = <function filepath.<locals>.make_filepath at 0x7ef7adb48040>
capsys = <_pytest.capture.CaptureFixture object at 0x7ef7ae297550>

    def test_invalid_outfile(filepath, capsys):
        path = filepath('function.sql')
        outpath = filepath('/missing/function.sql')
>       sqlparse.cli.main([path, '-r', '-o', outpath])

tests/test_cli.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/cli.py:65: in main
    data = sqlparse.format(data, reindent=True,
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_clipytest_encoding_stdinencoding_utf8sql-utf-8">test_cli.py::test_encoding_stdin[encoding_utf8.sql-utf-8]</h3>
<details><summary> <pre>test_cli.py::test_encoding_stdin[encoding_utf8.sql-utf-8]</pre></summary><pre>
args = Namespace(files=['-'], outfile=None, reindent=False, language=None, encoding='utf-8', indent_width=2)

    def main(args=None):
        """Main entry point."""
        parser = create_parser()
        args = parser.parse_args(args)

        if not args.files:
            parser.print_help()
            sys.exit(1)

        encoding = args.encoding
        if encoding == 'utf-8':
            # Python 3 reads files as utf-8 by default
            encoding = None

        for file_ in args.files:
            try:
>               with open(file_, 'r', encoding=encoding) as f:
E               FileNotFoundError: [Errno 2] No such file or directory: '-'

sqlparse/cli.py:58: FileNotFoundError

During handling of the above exception, another exception occurred:

fpath = 'encoding_utf8.sql', encoding = 'utf-8'
filepath = <function filepath.<locals>.make_filepath at 0x7ef7adb48820>
load_file = <function load_file.<locals>.make_load_file at 0x7ef7adb49360>
capfd = <_pytest.capture.CaptureFixture object at 0x7ef7aeabd210>

    @pytest.mark.parametrize('fpath, encoding', (
        ('encoding_utf8.sql', 'utf-8'),
        ('encoding_gbk.sql', 'gbk'),
    ))
    def test_encoding_stdin(fpath, encoding, filepath, load_file, capfd):
        path = filepath(fpath)
        expected = load_file(fpath, encoding)
        old_stdin = sys.stdin
        with open(path) as f:
            sys.stdin = f
>           sqlparse.cli.main(['-', '--encoding', encoding])

tests/test_cli.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/cli.py:61: in main
    _error('Failed to read {}: {}'.format(file_, e))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

msg = "Failed to read -: [Errno 2] No such file or directory: '-'"

    def _error(msg):
        """Print msg and optionally exit with return code exit_."""
        sys.stderr.write(msg + '\n')
>       sys.exit(1)
E       SystemExit: 1

sqlparse/cli.py:22: SystemExit
</pre>
</details>
<h3 id="test_clipytest_encoding_stdinencoding_gbksql-gbk">test_cli.py::test_encoding_stdin[encoding_gbk.sql-gbk]</h3>
<details><summary> <pre>test_cli.py::test_encoding_stdin[encoding_gbk.sql-gbk]</pre></summary><pre>
args = Namespace(files=['-'], outfile=None, reindent=False, language=None, encoding='gbk', indent_width=2)

    def main(args=None):
        """Main entry point."""
        parser = create_parser()
        args = parser.parse_args(args)

        if not args.files:
            parser.print_help()
            sys.exit(1)

        encoding = args.encoding
        if encoding == 'utf-8':
            # Python 3 reads files as utf-8 by default
            encoding = None

        for file_ in args.files:
            try:
>               with open(file_, 'r', encoding=encoding) as f:
E               FileNotFoundError: [Errno 2] No such file or directory: '-'

sqlparse/cli.py:58: FileNotFoundError

During handling of the above exception, another exception occurred:

fpath = 'encoding_gbk.sql', encoding = 'gbk'
filepath = <function filepath.<locals>.make_filepath at 0x7ef7adc3a320>
load_file = <function load_file.<locals>.make_load_file at 0x7ef7adb49240>
capfd = <_pytest.capture.CaptureFixture object at 0x7ef7ae2a5c00>

    @pytest.mark.parametrize('fpath, encoding', (
        ('encoding_utf8.sql', 'utf-8'),
        ('encoding_gbk.sql', 'gbk'),
    ))
    def test_encoding_stdin(fpath, encoding, filepath, load_file, capfd):
        path = filepath(fpath)
        expected = load_file(fpath, encoding)
        old_stdin = sys.stdin
        with open(path) as f:
            sys.stdin = f
>           sqlparse.cli.main(['-', '--encoding', encoding])

tests/test_cli.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/cli.py:61: in main
    _error('Failed to read {}: {}'.format(file_, e))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

msg = "Failed to read -: [Errno 2] No such file or directory: '-'"

    def _error(msg):
        """Print msg and optionally exit with return code exit_."""
        sys.stderr.write(msg + '\n')
>       sys.exit(1)
E       SystemExit: 1

sqlparse/cli.py:22: SystemExit
</pre>
</details>
<h3 id="test_formatpytestformattest_keywordcase">test_format.py::TestFormat::test_keywordcase</h3>
<details><summary> <pre>test_format.py::TestFormat::test_keywordcase</pre></summary><pre>
self = <tests.test_format.TestFormat object at 0x7ef7ad81a5f0>

    def test_keywordcase(self):
        sql = 'select * from bar; -- select foo\n'
>       res = sqlparse.format(sql, keyword_case='upper')

tests/test_format.py:10: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7aee71f60>
sql = 'select * from bar; -- select foo\n', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
>           stream = filter_.process(stream)
E           AttributeError: 'KeywordCaseFilter' object has no attribute 'process'

sqlparse/engine/filter_stack.py:24: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformattest_identifiercase">test_format.py::TestFormat::test_identifiercase</h3>
<details><summary> <pre>test_format.py::TestFormat::test_identifiercase</pre></summary><pre>
self = <tests.test_format.TestFormat object at 0x7ef7ad81a8c0>

    def test_identifiercase(self):
        sql = 'select * from bar; -- select foo\n'
>       res = sqlparse.format(sql, identifier_case='upper')

tests/test_format.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformattest_identifiercase_invalid_option">test_format.py::TestFormat::test_identifiercase_invalid_option</h3>
<details><summary> <pre>test_format.py::TestFormat::test_identifiercase_invalid_option</pre></summary><pre>
self = <tests.test_format.TestFormat object at 0x7ef7ad81aaa0>

    def test_identifiercase_invalid_option(self):
        sql = 'select * from bar; -- select foo\n'
        with pytest.raises(SQLParseError):
>           sqlparse.format(sql, identifier_case='foo')

tests/test_format.py:34: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformattest_identifiercase_quotes">test_format.py::TestFormat::test_identifiercase_quotes</h3>
<details><summary> <pre>test_format.py::TestFormat::test_identifiercase_quotes</pre></summary><pre>
self = <tests.test_format.TestFormat object at 0x7ef7ad81a8f0>

    def test_identifiercase_quotes(self):
        sql = 'select * from "foo"."bar"'
>       res = sqlparse.format(sql, identifier_case="upper")

tests/test_format.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformattest_strip_comments_single">test_format.py::TestFormat::test_strip_comments_single</h3>
<details><summary> <pre>test_format.py::TestFormat::test_strip_comments_single</pre></summary><pre>
self = <tests.test_format.TestFormat object at 0x7ef7ad81a770>

    def test_strip_comments_single(self):
        sql = 'select *-- statement starts here\nfrom foo'
>       res = sqlparse.format(sql, strip_comments=True)

tests/test_format.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad41bac0>
sql = 'select *-- statement starts here\nfrom foo', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
>           stream = filter_.process(stream)
E           AttributeError: 'StripCommentsFilter' object has no attribute 'process'

sqlparse/engine/filter_stack.py:24: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformattest_strip_comments_invalid_option">test_format.py::TestFormat::test_strip_comments_invalid_option</h3>
<details><summary> <pre>test_format.py::TestFormat::test_strip_comments_invalid_option</pre></summary><pre>
self = <tests.test_format.TestFormat object at 0x7ef7ad819ab0>

    def test_strip_comments_invalid_option(self):
        sql = 'select-- foo\nfrom -- bar\nwhere'
        with pytest.raises(SQLParseError):
>           sqlparse.format(sql, strip_comments=None)

tests/test_format.py:68: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformattest_strip_comments_multi">test_format.py::TestFormat::test_strip_comments_multi</h3>
<details><summary> <pre>test_format.py::TestFormat::test_strip_comments_multi</pre></summary><pre>
self = <tests.test_format.TestFormat object at 0x7ef7ad8198d0>

    def test_strip_comments_multi(self):
        sql = '/* sql starts here */\nselect'
>       res = sqlparse.format(sql, strip_comments=True)

tests/test_format.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ae7d9ea0>
sql = '/* sql starts here */\nselect', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
>           stream = filter_.process(stream)
E           AttributeError: 'StripCommentsFilter' object has no attribute 'process'

sqlparse/engine/filter_stack.py:24: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformattest_strip_comments_preserves_linebreak">test_format.py::TestFormat::test_strip_comments_preserves_linebreak</h3>
<details><summary> <pre>test_format.py::TestFormat::test_strip_comments_preserves_linebreak</pre></summary><pre>
self = <tests.test_format.TestFormat object at 0x7ef7ad819150>

    def test_strip_comments_preserves_linebreak(self):
        sql = 'select * -- a comment\r\nfrom foo'
>       res = sqlparse.format(sql, strip_comments=True)

tests/test_format.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad3bb0a0>
sql = 'select * -- a comment\r\nfrom foo', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
>           stream = filter_.process(stream)
E           AttributeError: 'StripCommentsFilter' object has no attribute 'process'

sqlparse/engine/filter_stack.py:24: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformattest_strip_comments_preserves_whitespace">test_format.py::TestFormat::test_strip_comments_preserves_whitespace</h3>
<details><summary> <pre>test_format.py::TestFormat::test_strip_comments_preserves_whitespace</pre></summary><pre>
self = <tests.test_format.TestFormat object at 0x7ef7ad81afe0>

    def test_strip_comments_preserves_whitespace(self):
        sql = 'SELECT 1/*bar*/ AS foo'  # see issue772
>       res = sqlparse.format(sql, strip_comments=True)

tests/test_format.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7aecbad10>
sql = 'SELECT 1/*bar*/ AS foo', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
>           stream = filter_.process(stream)
E           AttributeError: 'StripCommentsFilter' object has no attribute 'process'

sqlparse/engine/filter_stack.py:24: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformattest_strip_ws">test_format.py::TestFormat::test_strip_ws</h3>
<details><summary> <pre>test_format.py::TestFormat::test_strip_ws</pre></summary><pre>
self = <tests.test_format.TestFormat object at 0x7ef7ad81b760>

    def test_strip_ws(self):
        f = lambda sql: sqlparse.format(sql, strip_whitespace=True)
        s = 'select\n* from      foo\n\twhere  ( 1 = 2 )\n'
>       assert f(s) == 'select * from foo where (1 = 2)'

tests/test_format.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:110: in <lambda>
    f = lambda sql: sqlparse.format(sql, strip_whitespace=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad479990>
sql = 'select\n* from      foo\n\twhere  ( 1 = 2 )\n', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
>           stream = filter_.process(stream)
E           AttributeError: 'StripWhitespaceFilter' object has no attribute 'process'

sqlparse/engine/filter_stack.py:24: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformattest_strip_ws_invalid_option">test_format.py::TestFormat::test_strip_ws_invalid_option</h3>
<details><summary> <pre>test_format.py::TestFormat::test_strip_ws_invalid_option</pre></summary><pre>
self = <tests.test_format.TestFormat object at 0x7ef7ad81ae90>

    def test_strip_ws_invalid_option(self):
        s = 'select -- foo\nfrom    bar\n'
        with pytest.raises(SQLParseError):
>           sqlparse.format(s, strip_whitespace=None)

tests/test_format.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformattest_preserve_ws">test_format.py::TestFormat::test_preserve_ws</h3>
<details><summary> <pre>test_format.py::TestFormat::test_preserve_ws</pre></summary><pre>
self = <tests.test_format.TestFormat object at 0x7ef7ad81ab90>

    def test_preserve_ws(self):
        # preserve at least one whitespace after subgroups
        f = lambda sql: sqlparse.format(sql, strip_whitespace=True)
        s = 'select\n* /* foo */  from bar '
>       assert f(s) == 'select * /* foo */ from bar'

tests/test_format.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:123: in <lambda>
    f = lambda sql: sqlparse.format(sql, strip_whitespace=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ae2bda50>
sql = 'select\n* /* foo */  from bar ', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
>           stream = filter_.process(stream)
E           AttributeError: 'StripWhitespaceFilter' object has no attribute 'process'

sqlparse/engine/filter_stack.py:24: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformattest_notransform_of_quoted_crlf">test_format.py::TestFormat::test_notransform_of_quoted_crlf</h3>
<details><summary> <pre>test_format.py::TestFormat::test_notransform_of_quoted_crlf</pre></summary><pre>
self = <tests.test_format.TestFormat object at 0x7ef7ad81ae00>

    def test_notransform_of_quoted_crlf(self):
        # Make sure that CR/CR+LF characters inside string literals don't get
        # affected by the formatter.

        s1 = "SELECT some_column LIKE 'value\r'"
        s2 = "SELECT some_column LIKE 'value\r'\r\nWHERE id = 1\n"
        s3 = "SELECT some_column LIKE 'value\\'\r' WHERE id = 1\r"
        s4 = "SELECT some_column LIKE 'value\\\\\\'\r' WHERE id = 1\r\n"

        f = lambda x: sqlparse.format(x)

        # Because of the use of
>       assert f(s1) == "SELECT some_column LIKE 'value\r'"

tests/test_format.py:139: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:136: in <lambda>
    f = lambda x: sqlparse.format(x)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindentalignedtest_basic">test_format.py::TestFormatReindentAligned::test_basic</h3>
<details><summary> <pre>test_format.py::TestFormatReindentAligned::test_basic</pre></summary><pre>
self = <tests.test_format.TestFormatReindentAligned object at 0x7ef7ad81b3a0>

    def test_basic(self):
        sql = """
            select a, b as bb,c from table
            join (select a * 2 as a from new_table) other
            on table.a = other.a
            where c is true
            and b between 3 and 4
            or d is 'blue'
            limit 10
            """

>       assert self.formatter(sql) == '\n'.join([
            'select a,',
            '       b as bb,',
            '       c',
            '  from table',
            '  join (',
            '        select a * 2 as a',
            '          from new_table',
            '       ) other',
            '    on table.a = other.a',
            ' where c is true',
            '   and b between 3 and 4',
            "    or d is 'blue'",
            ' limit 10'])

tests/test_format.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:149: in formatter
    return sqlparse.format(sql, reindent_aligned=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindentalignedtest_joins">test_format.py::TestFormatReindentAligned::test_joins</h3>
<details><summary> <pre>test_format.py::TestFormatReindentAligned::test_joins</pre></summary><pre>
self = <tests.test_format.TestFormatReindentAligned object at 0x7ef7ad81b310>

    def test_joins(self):
        sql = """
            select * from a
            join b on a.one = b.one
            left join c on c.two = a.two and c.three = a.three
            full outer join d on d.three = a.three
            cross join e on e.four = a.four
            join f using (one, two, three)
            """
>       assert self.formatter(sql) == '\n'.join([
            'select *',
            '  from a',
            '  join b',
            '    on a.one = b.one',
            '  left join c',
            '    on c.two = a.two',
            '   and c.three = a.three',
            '  full outer join d',
            '    on d.three = a.three',
            ' cross join e',
            '    on e.four = a.four',
            '  join f using (one, two, three)'])

tests/test_format.py:186: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:149: in formatter
    return sqlparse.format(sql, reindent_aligned=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindentalignedtest_case_statement">test_format.py::TestFormatReindentAligned::test_case_statement</h3>
<details><summary> <pre>test_format.py::TestFormatReindentAligned::test_case_statement</pre></summary><pre>
self = <tests.test_format.TestFormatReindentAligned object at 0x7ef7ad81b700>

    def test_case_statement(self):
        sql = """
            select a,
            case when a = 0
            then 1
            when bb = 1 then 1
            when c = 2 then 2
            else 0 end as d,
            extra_col
            from table
            where c is true
            and b between 3 and 4
            """
>       assert self.formatter(sql) == '\n'.join([
            'select a,',
            '       case when a = 0  then 1',
            '            when bb = 1 then 1',
            '            when c = 2  then 2',
            '            else 0',
            '             end as d,',
            '       extra_col',
            '  from table',
            ' where c is true',
            '   and b between 3 and 4'])

tests/test_format.py:213: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:149: in formatter
    return sqlparse.format(sql, reindent_aligned=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindentalignedtest_case_statement_with_between">test_format.py::TestFormatReindentAligned::test_case_statement_with_between</h3>
<details><summary> <pre>test_format.py::TestFormatReindentAligned::test_case_statement_with_between</pre></summary><pre>
self = <tests.test_format.TestFormatReindentAligned object at 0x7ef7ad81b850>

    def test_case_statement_with_between(self):
        sql = """
            select a,
            case when a = 0
            then 1
            when bb = 1 then 1
            when c = 2 then 2
            when d between 3 and 5 then 3
            else 0 end as d,
            extra_col
            from table
            where c is true
            and b between 3 and 4
            """
>       assert self.formatter(sql) == '\n'.join([
            'select a,',
            '       case when a = 0             then 1',
            '            when bb = 1            then 1',
            '            when c = 2             then 2',
            '            when d between 3 and 5 then 3',
            '            else 0',
            '             end as d,',
            '       extra_col',
            '  from table',
            ' where c is true',
            '   and b between 3 and 4'])

tests/test_format.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:149: in formatter
    return sqlparse.format(sql, reindent_aligned=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindentalignedtest_group_by">test_format.py::TestFormatReindentAligned::test_group_by</h3>
<details><summary> <pre>test_format.py::TestFormatReindentAligned::test_group_by</pre></summary><pre>
self = <tests.test_format.TestFormatReindentAligned object at 0x7ef7ad81baf0>

    def test_group_by(self):
        sql = """
            select a, b, c, sum(x) as sum_x, count(y) as cnt_y
            from table
            group by a,b,c
            having sum(x) > 1
            and count(y) > 5
            order by 3,2,1
            """
>       assert self.formatter(sql) == '\n'.join([
            'select a,',
            '       b,',
            '       c,',
            '       sum(x) as sum_x,',
            '       count(y) as cnt_y',
            '  from table',
            ' group by a,',
            '          b,',
            '          c',
            'having sum(x) > 1',
            '   and count(y) > 5',
            ' order by 3,',
            '          2,',
            '          1'])

tests/test_format.py:261: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:149: in formatter
    return sqlparse.format(sql, reindent_aligned=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindentalignedtest_group_by_subquery">test_format.py::TestFormatReindentAligned::test_group_by_subquery</h3>
<details><summary> <pre>test_format.py::TestFormatReindentAligned::test_group_by_subquery</pre></summary><pre>
self = <tests.test_format.TestFormatReindentAligned object at 0x7ef7ad81bb20>

    def test_group_by_subquery(self):
        # TODO: add subquery alias when test_identifier_list_subquery fixed
        sql = """
            select *, sum_b + 2 as mod_sum
            from (
              select a, sum(b) as sum_b
              from table
              group by a,z)
            order by 1,2
            """
>       assert self.formatter(sql) == '\n'.join([
            'select *,',
            '       sum_b + 2 as mod_sum',
            '  from (',
            '        select a,',
            '               sum(b) as sum_b',
            '          from table',
            '         group by a,',
            '                  z',
            '       )',
            ' order by 1,',
            '          2'])

tests/test_format.py:287: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:149: in formatter
    return sqlparse.format(sql, reindent_aligned=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindentalignedtest_window_functions">test_format.py::TestFormatReindentAligned::test_window_functions</h3>
<details><summary> <pre>test_format.py::TestFormatReindentAligned::test_window_functions</pre></summary><pre>
self = <tests.test_format.TestFormatReindentAligned object at 0x7ef7ad81bc70>

    def test_window_functions(self):
        sql = """
            select a,
            SUM(a) OVER (PARTITION BY b ORDER BY c ROWS
            BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as sum_a,
            ROW_NUMBER() OVER
            (PARTITION BY b, c ORDER BY d DESC) as row_num
            from table"""
>       assert self.formatter(sql) == '\n'.join([
            'select a,',
            '       SUM(a) OVER (PARTITION BY b ORDER BY c ROWS '
            'BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) as sum_a,',
            '       ROW_NUMBER() OVER '
            '(PARTITION BY b, c ORDER BY d DESC) as row_num',
            '  from table'])

tests/test_format.py:308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:149: in formatter
    return sqlparse.format(sql, reindent_aligned=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestspacesaroundoperatorstest_basic">test_format.py::TestSpacesAroundOperators::test_basic</h3>
<details><summary> <pre>test_format.py::TestSpacesAroundOperators::test_basic</pre></summary><pre>
self = <tests.test_format.TestSpacesAroundOperators object at 0x7ef7ad8180a0>

    def test_basic(self):
        sql = ('select a+b as d from table '
               'where (c-d)%2= 1 and e> 3.0/4 and z^2 <100')
>       assert self.formatter(sql) == (
            'select a + b as d from table '
            'where (c - d) % 2 = 1 and e > 3.0 / 4 and z ^ 2 < 100')

tests/test_format.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:320: in formatter
    return sqlparse.format(sql, use_space_around_operators=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestspacesaroundoperatorstest_bools">test_format.py::TestSpacesAroundOperators::test_bools</h3>
<details><summary> <pre>test_format.py::TestSpacesAroundOperators::test_bools</pre></summary><pre>
self = <tests.test_format.TestSpacesAroundOperators object at 0x7ef7ad818340>

    def test_bools(self):
        sql = 'select * from table where a &&b or c||d'
>       assert self.formatter(
            sql) == 'select * from table where a && b or c || d'

tests/test_format.py:331: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:320: in formatter
    return sqlparse.format(sql, use_space_around_operators=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestspacesaroundoperatorstest_nested">test_format.py::TestSpacesAroundOperators::test_nested</h3>
<details><summary> <pre>test_format.py::TestSpacesAroundOperators::test_nested</pre></summary><pre>
self = <tests.test_format.TestSpacesAroundOperators object at 0x7ef7ad818490>

    def test_nested(self):
        sql = 'select *, case when a-b then c end from table'
>       assert self.formatter(
            sql) == 'select *, case when a - b then c end from table'

tests/test_format.py:336: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:320: in formatter
    return sqlparse.format(sql, use_space_around_operators=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestspacesaroundoperatorstest_wildcard_vs_mult">test_format.py::TestSpacesAroundOperators::test_wildcard_vs_mult</h3>
<details><summary> <pre>test_format.py::TestSpacesAroundOperators::test_wildcard_vs_mult</pre></summary><pre>
self = <tests.test_format.TestSpacesAroundOperators object at 0x7ef7ad818640>

    def test_wildcard_vs_mult(self):
        sql = 'select a*b-c from table'
>       assert self.formatter(sql) == 'select a * b - c from table'

tests/test_format.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:320: in formatter
    return sqlparse.format(sql, use_space_around_operators=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindenttest_option">test_format.py::TestFormatReindent::test_option</h3>
<details><summary> <pre>test_format.py::TestFormatReindent::test_option</pre></summary><pre>
self = <tests.test_format.TestFormatReindent object at 0x7ef7ad81bca0>

    def test_option(self):
        with pytest.raises(SQLParseError):
            sqlparse.format('foo', reindent=2)
        with pytest.raises(SQLParseError):
>           sqlparse.format('foo', indent_tabs=2)

tests/test_format.py:349: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindenttest_stmts">test_format.py::TestFormatReindent::test_stmts</h3>
<details><summary> <pre>test_format.py::TestFormatReindent::test_stmts</pre></summary><pre>
self = <tests.test_format.TestFormatReindent object at 0x7ef7ad81b940>

    def test_stmts(self):
        f = lambda sql: sqlparse.format(sql, reindent=True)
        s = 'select foo; select bar'
>       assert f(s) == 'select foo;\n\nselect bar'

tests/test_format.py:364: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:362: in <lambda>
    f = lambda sql: sqlparse.format(sql, reindent=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindenttest_keywords">test_format.py::TestFormatReindent::test_keywords</h3>
<details><summary> <pre>test_format.py::TestFormatReindent::test_keywords</pre></summary><pre>
self = <tests.test_format.TestFormatReindent object at 0x7ef7ad81b2e0>

    def test_keywords(self):
        f = lambda sql: sqlparse.format(sql, reindent=True)
        s = 'select * from foo union select * from bar;'
>       assert f(s) == '\n'.join([
            'select *',
            'from foo',
            'union',
            'select *',
            'from bar;'])

tests/test_format.py:373: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:371: in <lambda>
    f = lambda sql: sqlparse.format(sql, reindent=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindenttest_keywords_between">test_format.py::TestFormatReindent::test_keywords_between</h3>
<details><summary> <pre>test_format.py::TestFormatReindent::test_keywords_between</pre></summary><pre>
self = <tests.test_format.TestFormatReindent object at 0x7ef7ad81abc0>

    def test_keywords_between(self):
        # issue 14
        # don't break AND after BETWEEN
        f = lambda sql: sqlparse.format(sql, reindent=True)
        s = 'and foo between 1 and 2 and bar = 3'
>       assert f(s) == '\n'.join([
            '',
            'and foo between 1 and 2',
            'and bar = 3'])

tests/test_format.py:385: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:383: in <lambda>
    f = lambda sql: sqlparse.format(sql, reindent=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindenttest_parenthesis">test_format.py::TestFormatReindent::test_parenthesis</h3>
<details><summary> <pre>test_format.py::TestFormatReindent::test_parenthesis</pre></summary><pre>
self = <tests.test_format.TestFormatReindent object at 0x7ef7ad81b070>

    def test_parenthesis(self):
        f = lambda sql: sqlparse.format(sql, reindent=True)
        s = 'select count(*) from (select * from foo);'
>       assert f(s) == '\n'.join([
            'select count(*)',
            'from',
            '  (select *',
            '   from foo);'])

tests/test_format.py:393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:391: in <lambda>
    f = lambda sql: sqlparse.format(sql, reindent=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindenttest_where">test_format.py::TestFormatReindent::test_where</h3>
<details><summary> <pre>test_format.py::TestFormatReindent::test_where</pre></summary><pre>
self = <tests.test_format.TestFormatReindent object at 0x7ef7ad819a20>

    def test_where(self):
        f = lambda sql: sqlparse.format(sql, reindent=True)
        s = 'select * from foo where bar = 1 and baz = 2 or bzz = 3;'
>       assert f(s) == '\n'.join([
            'select *',
            'from foo',
            'where bar = 1',
            '  and baz = 2',
            '  or bzz = 3;'])

tests/test_format.py:407: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:405: in <lambda>
    f = lambda sql: sqlparse.format(sql, reindent=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindenttest_join">test_format.py::TestFormatReindent::test_join</h3>
<details><summary> <pre>test_format.py::TestFormatReindent::test_join</pre></summary><pre>
self = <tests.test_format.TestFormatReindent object at 0x7ef7ad818700>

    def test_join(self):
        f = lambda sql: sqlparse.format(sql, reindent=True)
        s = 'select * from foo join bar on 1 = 2'
>       assert f(s) == '\n'.join([
            'select *',
            'from foo',
            'join bar on 1 = 2'])

tests/test_format.py:425: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:423: in <lambda>
    f = lambda sql: sqlparse.format(sql, reindent=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindenttest_identifier_list">test_format.py::TestFormatReindent::test_identifier_list</h3>
<details><summary> <pre>test_format.py::TestFormatReindent::test_identifier_list</pre></summary><pre>
self = <tests.test_format.TestFormatReindent object at 0x7ef7ad818880>

    def test_identifier_list(self):
        f = lambda sql: sqlparse.format(sql, reindent=True)
        s = 'select foo, bar, baz from table1, table2 where 1 = 2'
>       assert f(s) == '\n'.join([
            'select foo,',
            '       bar,',
            '       baz',
            'from table1,',
            '     table2',
            'where 1 = 2'])

tests/test_format.py:448: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:446: in <lambda>
    f = lambda sql: sqlparse.format(sql, reindent=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindenttest_identifier_list_with_wrap_after">test_format.py::TestFormatReindent::test_identifier_list_with_wrap_after</h3>
<details><summary> <pre>test_format.py::TestFormatReindent::test_identifier_list_with_wrap_after</pre></summary><pre>
self = <tests.test_format.TestFormatReindent object at 0x7ef7aeaa7cd0>

    def test_identifier_list_with_wrap_after(self):
        f = lambda sql: sqlparse.format(sql, reindent=True, wrap_after=14)
        s = 'select foo, bar, baz from table1, table2 where 1 = 2'
>       assert f(s) == '\n'.join([
            'select foo, bar,',
            '       baz',
            'from table1, table2',
            'where 1 = 2'])

tests/test_format.py:465: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:463: in <lambda>
    f = lambda sql: sqlparse.format(sql, reindent=True, wrap_after=14)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindenttest_identifier_list_comment_first">test_format.py::TestFormatReindent::test_identifier_list_comment_first</h3>
<details><summary> <pre>test_format.py::TestFormatReindent::test_identifier_list_comment_first</pre></summary><pre>
self = <tests.test_format.TestFormatReindent object at 0x7ef7aeaa7c40>

    def test_identifier_list_comment_first(self):
        f = lambda sql: sqlparse.format(sql, reindent=True, comma_first=True)
        # not the 3: It cleans up whitespace too!
        s = 'select foo, bar, baz from table where foo in (1, 2,3)'
>       assert f(s) == '\n'.join([
            'select foo',
            '     , bar',
            '     , baz',
            'from table',
            'where foo in (1',
            '            , 2',
            '            , 3)'])

tests/test_format.py:475: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:472: in <lambda>
    f = lambda sql: sqlparse.format(sql, reindent=True, comma_first=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindenttest_identifier_list_with_functions">test_format.py::TestFormatReindent::test_identifier_list_with_functions</h3>
<details><summary> <pre>test_format.py::TestFormatReindent::test_identifier_list_with_functions</pre></summary><pre>
self = <tests.test_format.TestFormatReindent object at 0x7ef7aeaa7700>

    def test_identifier_list_with_functions(self):
        f = lambda sql: sqlparse.format(sql, reindent=True)
        s = ("select 'abc' as foo, coalesce(col1, col2)||col3 as bar,"
             "col3 from my_table")
>       assert f(s) == '\n'.join([
            "select 'abc' as foo,",
            "       coalesce(col1, col2)||col3 as bar,",
            "       col3",
            "from my_table"])

tests/test_format.py:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:485: in <lambda>
    f = lambda sql: sqlparse.format(sql, reindent=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindenttest_long_identifier_list_with_functions">test_format.py::TestFormatReindent::test_long_identifier_list_with_functions</h3>
<details><summary> <pre>test_format.py::TestFormatReindent::test_long_identifier_list_with_functions</pre></summary><pre>
self = <tests.test_format.TestFormatReindent object at 0x7ef7aeaa40d0>

    def test_long_identifier_list_with_functions(self):
        f = lambda sql: sqlparse.format(sql, reindent=True, wrap_after=30)
        s = ("select 'abc' as foo, json_build_object('a',  a,"
             "'b', b, 'c', c, 'd', d, 'e', e) as col2"
             "col3 from my_table")
>       assert f(s) == '\n'.join([
            "select 'abc' as foo,",
            "       json_build_object('a',",
            "         a, 'b', b, 'c', c, 'd', d,",
            "         'e', e) as col2col3",
            "from my_table"])

tests/test_format.py:499: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:495: in <lambda>
    f = lambda sql: sqlparse.format(sql, reindent=True, wrap_after=30)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindenttest_case">test_format.py::TestFormatReindent::test_case</h3>
<details><summary> <pre>test_format.py::TestFormatReindent::test_case</pre></summary><pre>
self = <tests.test_format.TestFormatReindent object at 0x7ef7aeaa4430>

    def test_case(self):
        f = lambda sql: sqlparse.format(sql, reindent=True)
        s = 'case when foo = 1 then 2 when foo = 3 then 4 else 5 end'
>       assert f(s) == '\n'.join([
            'case',
            '    when foo = 1 then 2',
            '    when foo = 3 then 4',
            '    else 5',
            'end'])

tests/test_format.py:509: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:507: in <lambda>
    f = lambda sql: sqlparse.format(sql, reindent=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindenttest_case2">test_format.py::TestFormatReindent::test_case2</h3>
<details><summary> <pre>test_format.py::TestFormatReindent::test_case2</pre></summary><pre>
self = <tests.test_format.TestFormatReindent object at 0x7ef7aeaa7820>

    def test_case2(self):
        f = lambda sql: sqlparse.format(sql, reindent=True)
        s = 'case(foo) when bar = 1 then 2 else 3 end'
>       assert f(s) == '\n'.join([
            'case(foo)',
            '    when bar = 1 then 2',
            '    else 3',
            'end'])

tests/test_format.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:517: in <lambda>
    f = lambda sql: sqlparse.format(sql, reindent=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindenttest_nested_identifier_list">test_format.py::TestFormatReindent::test_nested_identifier_list</h3>
<details><summary> <pre>test_format.py::TestFormatReindent::test_nested_identifier_list</pre></summary><pre>
self = <tests.test_format.TestFormatReindent object at 0x7ef7aeaa7be0>

    def test_nested_identifier_list(self):
        # issue4
        f = lambda sql: sqlparse.format(sql, reindent=True)
        s = '(foo as bar, bar1, bar2 as bar3, b4 as b5)'
>       assert f(s) == '\n'.join([
            '(foo as bar,',
            ' bar1,',
            ' bar2 as bar3,',
            ' b4 as b5)'])

tests/test_format.py:529: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:527: in <lambda>
    f = lambda sql: sqlparse.format(sql, reindent=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindenttest_duplicate_linebreaks">test_format.py::TestFormatReindent::test_duplicate_linebreaks</h3>
<details><summary> <pre>test_format.py::TestFormatReindent::test_duplicate_linebreaks</pre></summary><pre>
self = <tests.test_format.TestFormatReindent object at 0x7ef7aeaa5090>

    def test_duplicate_linebreaks(self):
        # issue3
        f = lambda sql: sqlparse.format(sql, reindent=True)
        s = 'select c1 -- column1\nfrom foo'
>       assert f(s) == '\n'.join([
            'select c1 -- column1',
            'from foo'])

tests/test_format.py:539: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:537: in <lambda>
    f = lambda sql: sqlparse.format(sql, reindent=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindenttest_keywordfunctions">test_format.py::TestFormatReindent::test_keywordfunctions</h3>
<details><summary> <pre>test_format.py::TestFormatReindent::test_keywordfunctions</pre></summary><pre>
self = <tests.test_format.TestFormatReindent object at 0x7ef7aeaa7550>

    def test_keywordfunctions(self):
        # issue36
        f = lambda sql: sqlparse.format(sql, reindent=True)
        s = 'select max(a) b, foo, bar'
>       assert f(s) == '\n'.join([
            'select max(a) b,',
            '       foo,',
            '       bar'])

tests/test_format.py:563: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:561: in <lambda>
    f = lambda sql: sqlparse.format(sql, reindent=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindenttest_identifier_and_functions">test_format.py::TestFormatReindent::test_identifier_and_functions</h3>
<details><summary> <pre>test_format.py::TestFormatReindent::test_identifier_and_functions</pre></summary><pre>
self = <tests.test_format.TestFormatReindent object at 0x7ef7aeaa4b50>

    def test_identifier_and_functions(self):
        # issue45
        f = lambda sql: sqlparse.format(sql, reindent=True)
        s = 'select foo.bar, nvl(1) from dual'
>       assert f(s) == '\n'.join([
            'select foo.bar,',
            '       nvl(1)',
            'from dual'])

tests/test_format.py:572: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:570: in <lambda>
    f = lambda sql: sqlparse.format(sql, reindent=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestformatreindenttest_insert_values">test_format.py::TestFormatReindent::test_insert_values</h3>
<details><summary> <pre>test_format.py::TestFormatReindent::test_insert_values</pre></summary><pre>
self = <tests.test_format.TestFormatReindent object at 0x7ef7aeaa5d50>

    def test_insert_values(self):
        # issue 329
        f = lambda sql: sqlparse.format(sql, reindent=True)
        s = 'insert into foo values (1, 2)'
>       assert f(s) == '\n'.join([
            'insert into foo',
            'values (1, 2)'])

tests/test_format.py:581: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:579: in <lambda>
    f = lambda sql: sqlparse.format(sql, reindent=True)
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestoutputformattest_python">test_format.py::TestOutputFormat::test_python</h3>
<details><summary> <pre>test_format.py::TestOutputFormat::test_python</pre></summary><pre>
self = <tests.test_format.TestOutputFormat object at 0x7ef7ad818820>

    def test_python(self):
        sql = 'select * from foo;'
        f = lambda sql: sqlparse.format(sql, output_format='python')
>       assert f(sql) == "sql = 'select * from foo;'"

tests/test_format.py:625: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:624: in <lambda>
    f = lambda sql: sqlparse.format(sql, output_format='python')
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestoutputformattest_python_multiple_statements">test_format.py::TestOutputFormat::test_python_multiple_statements</h3>
<details><summary> <pre>test_format.py::TestOutputFormat::test_python_multiple_statements</pre></summary><pre>
self = <tests.test_format.TestOutputFormat object at 0x7ef7ad81af20>

    def test_python_multiple_statements(self):
        sql = 'select * from foo; select 1 from dual'
        f = lambda sql: sqlparse.format(sql, output_format='python')
>       assert f(sql) == '\n'.join([
            "sql = 'select * from foo; '",
            "sql2 = 'select 1 from dual'"])

tests/test_format.py:635: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:634: in <lambda>
    f = lambda sql: sqlparse.format(sql, output_format='python')
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestoutputformattest_python_multiple_statements_with_formatting">test_format.py::TestOutputFormat::test_python_multiple_statements_with_formatting</h3>
<details><summary> <pre>test_format.py::TestOutputFormat::test_python_multiple_statements_with_formatting</pre></summary><pre>
self = <tests.test_format.TestOutputFormat object at 0x7ef7ad81b0a0>

    @pytest.mark.xfail(reason="Needs fixing")
    def test_python_multiple_statements_with_formatting(self):
        sql = 'select * from foo; select 1 from dual'
        f = lambda sql: sqlparse.format(sql, output_format='python',
                                        reindent=True)
>       assert f(sql) == '\n'.join([
            "sql = ('select * '",
            "       'from foo;')",
            "sql2 = ('select 1 '",
            "        'from dual')"])

tests/test_format.py:644: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:642: in <lambda>
    f = lambda sql: sqlparse.format(sql, output_format='python',
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestoutputformattest_php">test_format.py::TestOutputFormat::test_php</h3>
<details><summary> <pre>test_format.py::TestOutputFormat::test_php</pre></summary><pre>
self = <tests.test_format.TestOutputFormat object at 0x7ef7aeaa7f40>

    def test_php(self):
        sql = 'select * from foo;'
        f = lambda sql: sqlparse.format(sql, output_format='php')
>       assert f(sql) == '$sql = "select * from foo;";'

tests/test_format.py:653: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:652: in <lambda>
    f = lambda sql: sqlparse.format(sql, output_format='php')
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestoutputformattest_sql">test_format.py::TestOutputFormat::test_sql</h3>
<details><summary> <pre>test_format.py::TestOutputFormat::test_sql</pre></summary><pre>
self = <tests.test_format.TestOutputFormat object at 0x7ef7aeaa76a0>

    def test_sql(self):
        # "sql" is an allowed option but has no effect
        sql = 'select * from foo;'
        f = lambda sql: sqlparse.format(sql, output_format='sql')
>       assert f(sql) == 'select * from foo;'

tests/test_format.py:664: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_format.py:663: in <lambda>
    f = lambda sql: sqlparse.format(sql, output_format='sql')
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytestoutputformattest_invalid_option">test_format.py::TestOutputFormat::test_invalid_option</h3>
<details><summary> <pre>test_format.py::TestOutputFormat::test_invalid_option</pre></summary><pre>
self = <tests.test_format.TestOutputFormat object at 0x7ef7aeaa55a0>

    def test_invalid_option(self):
        sql = 'select * from foo;'
        with pytest.raises(SQLParseError):
>           sqlparse.format(sql, output_format='foo')

tests/test_format.py:669: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytest_format_column_ordering">test_format.py::test_format_column_ordering</h3>
<details><summary> <pre>test_format.py::test_format_column_ordering</pre></summary><pre>
def test_format_column_ordering():
        # issue89
        sql = 'select * from foo order by c1 desc, c2, c3;'
>       formatted = sqlparse.format(sql, reindent=True)

tests/test_format.py:675: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytest_truncate_strings">test_format.py::test_truncate_strings</h3>
<details><summary> <pre>test_format.py::test_truncate_strings</pre></summary><pre>
def test_truncate_strings():
        sql = "update foo set value = '{}';".format('x' * 1000)
>       formatted = sqlparse.format(sql, truncate_strings=10)

tests/test_format.py:687: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytest_truncate_strings_invalid_option2bar">test_format.py::test_truncate_strings_invalid_option2[bar]</h3>
<details><summary> <pre>test_format.py::test_truncate_strings_invalid_option2[bar]</pre></summary><pre>
option = 'bar'

    @pytest.mark.parametrize('option', ['bar', -1, 0])
    def test_truncate_strings_invalid_option2(option):
        with pytest.raises(SQLParseError):
>           sqlparse.format('foo', truncate_strings=option)

tests/test_format.py:696: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytest_truncate_strings_invalid_option2-1">test_format.py::test_truncate_strings_invalid_option2[-1]</h3>
<details><summary> <pre>test_format.py::test_truncate_strings_invalid_option2[-1]</pre></summary><pre>
option = -1

    @pytest.mark.parametrize('option', ['bar', -1, 0])
    def test_truncate_strings_invalid_option2(option):
        with pytest.raises(SQLParseError):
>           sqlparse.format('foo', truncate_strings=option)

tests/test_format.py:696: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytest_truncate_strings_invalid_option20">test_format.py::test_truncate_strings_invalid_option2[0]</h3>
<details><summary> <pre>test_format.py::test_truncate_strings_invalid_option2[0]</pre></summary><pre>
option = 0

    @pytest.mark.parametrize('option', ['bar', -1, 0])
    def test_truncate_strings_invalid_option2(option):
        with pytest.raises(SQLParseError):
>           sqlparse.format('foo', truncate_strings=option)

tests/test_format.py:696: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytest_truncate_strings_doesnt_truncate_identifiersselect-verrrylongcolumn-from-foo">test_format.py::test_truncate_strings_doesnt_truncate_identifiers[select verrrylongcolumn from foo]</h3>
<details><summary> <pre>test_format.py::test_truncate_strings_doesnt_truncate_identifiers[select verrrylongcolumn from foo]</pre></summary><pre>
sql = 'select verrrylongcolumn from foo'

    @pytest.mark.parametrize('sql', [
        'select verrrylongcolumn from foo',
        'select "verrrylongcolumn" from "foo"'])
    def test_truncate_strings_doesnt_truncate_identifiers(sql):
>       formatted = sqlparse.format(sql, truncate_strings=2)

tests/test_format.py:703: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytest_truncate_strings_doesnt_truncate_identifiersselect-verrrylongcolumn-from-foo_1">test_format.py::test_truncate_strings_doesnt_truncate_identifiers[select "verrrylongcolumn" from "foo"]</h3>
<details><summary> <pre>test_format.py::test_truncate_strings_doesnt_truncate_identifiers[select "verrrylongcolumn" from "foo"]</pre></summary><pre>
sql = 'select "verrrylongcolumn" from "foo"'

    @pytest.mark.parametrize('sql', [
        'select verrrylongcolumn from foo',
        'select "verrrylongcolumn" from "foo"'])
    def test_truncate_strings_doesnt_truncate_identifiers(sql):
>       formatted = sqlparse.format(sql, truncate_strings=2)

tests/test_format.py:703: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytest_having_produces_newline">test_format.py::test_having_produces_newline</h3>
<details><summary> <pre>test_format.py::test_having_produces_newline</pre></summary><pre>
def test_having_produces_newline():
        sql = ('select * from foo, bar where bar.id = foo.bar_id '
               'having sum(bar.value) > 100')
>       formatted = sqlparse.format(sql, reindent=True)

tests/test_format.py:710: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytest_format_right_margin_invalid_optionten">test_format.py::test_format_right_margin_invalid_option[ten]</h3>
<details><summary> <pre>test_format.py::test_format_right_margin_invalid_option[ten]</pre></summary><pre>
right_margin = 'ten'

    @pytest.mark.parametrize('right_margin', ['ten', 2])
    def test_format_right_margin_invalid_option(right_margin):
        with pytest.raises(SQLParseError):
>           sqlparse.format('foo', right_margin=right_margin)

tests/test_format.py:723: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7adb7f940>
sql = 'foo', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
>           stream = filter_.process(stream)
E           AttributeError: 'RightMarginFilter' object has no attribute 'process'

sqlparse/engine/filter_stack.py:24: AttributeError
</pre>
</details>
<h3 id="test_formatpytest_format_right_margin_invalid_option2">test_format.py::test_format_right_margin_invalid_option[2]</h3>
<details><summary> <pre>test_format.py::test_format_right_margin_invalid_option[2]</pre></summary><pre>
right_margin = 2

    @pytest.mark.parametrize('right_margin', ['ten', 2])
    def test_format_right_margin_invalid_option(right_margin):
        with pytest.raises(SQLParseError):
>           sqlparse.format('foo', right_margin=right_margin)

tests/test_format.py:723: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ae7d9ea0>
sql = 'foo', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
>           stream = filter_.process(stream)
E           AttributeError: 'RightMarginFilter' object has no attribute 'process'

sqlparse/engine/filter_stack.py:24: AttributeError
</pre>
</details>
<h3 id="test_formatpytest_format_right_margin">test_format.py::test_format_right_margin</h3>
<details><summary> <pre>test_format.py::test_format_right_margin</pre></summary><pre>
@pytest.mark.xfail(reason="Needs fixing")
    def test_format_right_margin():
        # TODO: Needs better test, only raises exception right now
>       sqlparse.format('foo', right_margin="79")

tests/test_format.py:729: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad3bb700>
sql = 'foo', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
>           stream = filter_.process(stream)
E           AttributeError: 'RightMarginFilter' object has no attribute 'process'

sqlparse/engine/filter_stack.py:24: AttributeError
</pre>
</details>
<h3 id="test_formatpytest_format_json_ops">test_format.py::test_format_json_ops</h3>
<details><summary> <pre>test_format.py::test_format_json_ops</pre></summary><pre>
def test_format_json_ops():  # issue542
>       formatted = sqlparse.format(
            "select foo->'bar', foo->'bar';", reindent=True)

tests/test_format.py:733: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytest_compactcase-when-foo-then-1-else-bar-end-casen-when-foo-then-1n-else-barnend-case-when-foo-then-1-else-bar-end">test_format.py::test_compact[case when foo then 1 else bar end-case\n    when foo then 1\n    else bar\nend-case when foo then 1 else bar end]</h3>
<details><summary> <pre>test_format.py::test_compact[case when foo then 1 else bar end-case\n    when foo then 1\n    else bar\nend-case when foo then 1 else bar end]</pre></summary><pre>
sql = 'case when foo then 1 else bar end'
expected_normal = 'case\n    when foo then 1\n    else bar\nend'
expected_compact = 'case when foo then 1 else bar end'

    @pytest.mark.parametrize('sql, expected_normal, expected_compact', [
        ('case when foo then 1 else bar end',
         'case\n    when foo then 1\n    else bar\nend',
         'case when foo then 1 else bar end')])
    def test_compact(sql, expected_normal, expected_compact):  # issue783
>       formatted_normal = sqlparse.format(sql, reindent=True)

tests/test_format.py:744: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_formatpytest_strip_ws_removes_trailing_ws_in_groups">test_format.py::test_strip_ws_removes_trailing_ws_in_groups</h3>
<details><summary> <pre>test_format.py::test_strip_ws_removes_trailing_ws_in_groups</pre></summary><pre>
def test_strip_ws_removes_trailing_ws_in_groups():  # issue782
>       formatted = sqlparse.format('( where foo = bar  ) from',
                                    strip_whitespace=True)

tests/test_format.py:751: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ae2c92a0>
sql = '( where foo = bar  ) from', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
>           stream = filter_.process(stream)
E           AttributeError: 'StripWhitespaceFilter' object has no attribute 'process'

sqlparse/engine/filter_stack.py:24: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_parenthesis">test_grouping.py::test_grouping_parenthesis</h3>
<details><summary> <pre>test_grouping.py::test_grouping_parenthesis</pre></summary><pre>
def test_grouping_parenthesis():
        s = 'select (select (x3) x2) and (y2) bar'
>       parsed = sqlparse.parse(s)[0]

tests/test_grouping.py:9: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_assignmentfoo-1">test_grouping.py::test_grouping_assignment[foo := 1;]</h3>
<details><summary> <pre>test_grouping.py::test_grouping_assignment[foo := 1;]</pre></summary><pre>
s = 'foo := 1;'

    @pytest.mark.parametrize('s', ['foo := 1;', 'foo := 1'])
    def test_grouping_assignment(s):
>       parsed = sqlparse.parse(s)[0]

tests/test_grouping.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_assignmentfoo-1_1">test_grouping.py::test_grouping_assignment[foo := 1]</h3>
<details><summary> <pre>test_grouping.py::test_grouping_assignment[foo := 1]</pre></summary><pre>
s = 'foo := 1'

    @pytest.mark.parametrize('s', ['foo := 1;', 'foo := 1'])
    def test_grouping_assignment(s):
>       parsed = sqlparse.parse(s)[0]

tests/test_grouping.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_typed_literalx-date-2020-01-01">test_grouping.py::test_grouping_typed_literal[x &gt; DATE '2020-01-01']</h3>
<details><summary> <pre>test_grouping.py::test_grouping_typed_literal[x > DATE '2020-01-01']</pre></summary><pre>
s = "x > DATE '2020-01-01'"

    @pytest.mark.parametrize('s', ["x > DATE '2020-01-01'", "x > TIMESTAMP '2020-01-01 00:00:00'"])
    def test_grouping_typed_literal(s):
>       parsed = sqlparse.parse(s)[0]

tests/test_grouping.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_typed_literalx-timestamp-2020-01-01-000000">test_grouping.py::test_grouping_typed_literal[x &gt; TIMESTAMP '2020-01-01 00:00:00']</h3>
<details><summary> <pre>test_grouping.py::test_grouping_typed_literal[x > TIMESTAMP '2020-01-01 00:00:00']</pre></summary><pre>
s = "x > TIMESTAMP '2020-01-01 00:00:00'"

    @pytest.mark.parametrize('s', ["x > DATE '2020-01-01'", "x > TIMESTAMP '2020-01-01 00:00:00'"])
    def test_grouping_typed_literal(s):
>       parsed = sqlparse.parse(s)[0]

tests/test_grouping.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_compare_exprselect-a-from-b-where-c-d-e-identifier-identifier">test_grouping.py::test_compare_expr[select a from b where c &lt; d + e-Identifier-Identifier]</h3>
<details><summary> <pre>test_grouping.py::test_compare_expr[select a from b where c < d + e-Identifier-Identifier]</pre></summary><pre>
s = 'select a from b where c < d + e', a = <class 'sqlparse.sql.Identifier'>
b = <class 'sqlparse.sql.Identifier'>

    @pytest.mark.parametrize('s, a, b', [
        ('select a from b where c < d + e', sql.Identifier, sql.Identifier),
        ('select a from b where c < d + interval \'1 day\'', sql.Identifier, sql.TypedLiteral),
        ('select a from b where c < d + interval \'6\' month', sql.Identifier, sql.TypedLiteral),
        ('select a from b where c < current_timestamp - interval \'1 day\'', sql.Token, sql.TypedLiteral),
    ])
    def test_compare_expr(s, a, b):
>       parsed = sqlparse.parse(s)[0]

tests/test_grouping.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_compare_exprselect-a-from-b-where-c-d-interval-1-day-identifier-typedliteral">test_grouping.py::test_compare_expr[select a from b where c &lt; d + interval '1 day'-Identifier-TypedLiteral]</h3>
<details><summary> <pre>test_grouping.py::test_compare_expr[select a from b where c < d + interval '1 day'-Identifier-TypedLiteral]</pre></summary><pre>
s = "select a from b where c < d + interval '1 day'"
a = <class 'sqlparse.sql.Identifier'>, b = <class 'sqlparse.sql.TypedLiteral'>

    @pytest.mark.parametrize('s, a, b', [
        ('select a from b where c < d + e', sql.Identifier, sql.Identifier),
        ('select a from b where c < d + interval \'1 day\'', sql.Identifier, sql.TypedLiteral),
        ('select a from b where c < d + interval \'6\' month', sql.Identifier, sql.TypedLiteral),
        ('select a from b where c < current_timestamp - interval \'1 day\'', sql.Token, sql.TypedLiteral),
    ])
    def test_compare_expr(s, a, b):
>       parsed = sqlparse.parse(s)[0]

tests/test_grouping.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_compare_exprselect-a-from-b-where-c-d-interval-6-month-identifier-typedliteral">test_grouping.py::test_compare_expr[select a from b where c &lt; d + interval '6' month-Identifier-TypedLiteral]</h3>
<details><summary> <pre>test_grouping.py::test_compare_expr[select a from b where c < d + interval '6' month-Identifier-TypedLiteral]</pre></summary><pre>
s = "select a from b where c < d + interval '6' month"
a = <class 'sqlparse.sql.Identifier'>, b = <class 'sqlparse.sql.TypedLiteral'>

    @pytest.mark.parametrize('s, a, b', [
        ('select a from b where c < d + e', sql.Identifier, sql.Identifier),
        ('select a from b where c < d + interval \'1 day\'', sql.Identifier, sql.TypedLiteral),
        ('select a from b where c < d + interval \'6\' month', sql.Identifier, sql.TypedLiteral),
        ('select a from b where c < current_timestamp - interval \'1 day\'', sql.Token, sql.TypedLiteral),
    ])
    def test_compare_expr(s, a, b):
>       parsed = sqlparse.parse(s)[0]

tests/test_grouping.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_compare_exprselect-a-from-b-where-c-current_timestamp-interval-1-day-token-typedliteral">test_grouping.py::test_compare_expr[select a from b where c &lt; current_timestamp - interval '1 day'-Token-TypedLiteral]</h3>
<details><summary> <pre>test_grouping.py::test_compare_expr[select a from b where c < current_timestamp - interval '1 day'-Token-TypedLiteral]</pre></summary><pre>
s = "select a from b where c < current_timestamp - interval '1 day'"
a = <class 'sqlparse.sql.Token'>, b = <class 'sqlparse.sql.TypedLiteral'>

    @pytest.mark.parametrize('s, a, b', [
        ('select a from b where c < d + e', sql.Identifier, sql.Identifier),
        ('select a from b where c < d + interval \'1 day\'', sql.Identifier, sql.TypedLiteral),
        ('select a from b where c < d + interval \'6\' month', sql.Identifier, sql.TypedLiteral),
        ('select a from b where c < current_timestamp - interval \'1 day\'', sql.Token, sql.TypedLiteral),
    ])
    def test_compare_expr(s, a, b):
>       parsed = sqlparse.parse(s)[0]

tests/test_grouping.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_identifiers">test_grouping.py::test_grouping_identifiers</h3>
<details><summary> <pre>test_grouping.py::test_grouping_identifiers</pre></summary><pre>
def test_grouping_identifiers():
        s = 'select foo.bar from "myscheme"."table" where fail. order'
>       parsed = sqlparse.parse(s)[0]

tests/test_grouping.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_simple_identifiers1-as-f">test_grouping.py::test_simple_identifiers[1 as f]</h3>
<details><summary> <pre>test_grouping.py::test_simple_identifiers[1 as f]</pre></summary><pre>
s = '1 as f'

    @pytest.mark.parametrize('s', [
        '1 as f',
        'foo as f',
        'foo f',
        '1/2 as f',
        '1/2 f',
        '1<2 as f',  # issue327
        '1<2 f',
    ])
    def test_simple_identifiers(s):
>       parsed = sqlparse.parse(s)[0]

tests/test_grouping.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_simple_identifiersfoo-as-f">test_grouping.py::test_simple_identifiers[foo as f]</h3>
<details><summary> <pre>test_grouping.py::test_simple_identifiers[foo as f]</pre></summary><pre>
s = 'foo as f'

    @pytest.mark.parametrize('s', [
        '1 as f',
        'foo as f',
        'foo f',
        '1/2 as f',
        '1/2 f',
        '1<2 as f',  # issue327
        '1<2 f',
    ])
    def test_simple_identifiers(s):
>       parsed = sqlparse.parse(s)[0]

tests/test_grouping.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_simple_identifiersfoo-f">test_grouping.py::test_simple_identifiers[foo f]</h3>
<details><summary> <pre>test_grouping.py::test_simple_identifiers[foo f]</pre></summary><pre>
s = 'foo f'

    @pytest.mark.parametrize('s', [
        '1 as f',
        'foo as f',
        'foo f',
        '1/2 as f',
        '1/2 f',
        '1<2 as f',  # issue327
        '1<2 f',
    ])
    def test_simple_identifiers(s):
>       parsed = sqlparse.parse(s)[0]

tests/test_grouping.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="2-as-f">2 as f]</h3>
<details><summary> <pre>2 as f]</pre></summary><pre>
s = '1/2 as f'

    @pytest.mark.parametrize('s', [
        '1 as f',
        'foo as f',
        'foo f',
        '1/2 as f',
        '1/2 f',
        '1<2 as f',  # issue327
        '1<2 f',
    ])
    def test_simple_identifiers(s):
>       parsed = sqlparse.parse(s)[0]

tests/test_grouping.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="2-f">2 f]</h3>
<details><summary> <pre>2 f]</pre></summary><pre>
s = '1/2 f'

    @pytest.mark.parametrize('s', [
        '1 as f',
        'foo as f',
        'foo f',
        '1/2 as f',
        '1/2 f',
        '1<2 as f',  # issue327
        '1<2 f',
    ])
    def test_simple_identifiers(s):
>       parsed = sqlparse.parse(s)[0]

tests/test_grouping.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_simple_identifiers12-as-f">test_grouping.py::test_simple_identifiers[1&lt;2 as f]</h3>
<details><summary> <pre>test_grouping.py::test_simple_identifiers[1<2 as f]</pre></summary><pre>
s = '1<2 as f'

    @pytest.mark.parametrize('s', [
        '1 as f',
        'foo as f',
        'foo f',
        '1/2 as f',
        '1/2 f',
        '1<2 as f',  # issue327
        '1<2 f',
    ])
    def test_simple_identifiers(s):
>       parsed = sqlparse.parse(s)[0]

tests/test_grouping.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_simple_identifiers12-f">test_grouping.py::test_simple_identifiers[1&lt;2 f]</h3>
<details><summary> <pre>test_grouping.py::test_simple_identifiers[1<2 f]</pre></summary><pre>
s = '1<2 f'

    @pytest.mark.parametrize('s', [
        '1 as f',
        'foo as f',
        'foo f',
        '1/2 as f',
        '1/2 f',
        '1<2 as f',  # issue327
        '1<2 f',
    ])
    def test_simple_identifiers(s):
>       parsed = sqlparse.parse(s)[0]

tests/test_grouping.py:105: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_group_identifier_listfoo-bar">test_grouping.py::test_group_identifier_list[foo, bar]</h3>
<details><summary> <pre>test_grouping.py::test_group_identifier_list[foo, bar]</pre></summary><pre>
s = 'foo, bar'

    @pytest.mark.parametrize('s', [
        'foo, bar',
        'sum(a), sum(b)',
        'sum(a) as x, b as y',
        'sum(a)::integer, b',
        'sum(a)/count(b) as x, y',
        'sum(a)::integer as x, y',
        'sum(a)::integer/count(b) as x, y',  # issue297
    ])
    def test_group_identifier_list(s):
>       parsed = sqlparse.parse(s)[0]

tests/test_grouping.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_group_identifier_listsuma-sumb">test_grouping.py::test_group_identifier_list[sum(a), sum(b)]</h3>
<details><summary> <pre>test_grouping.py::test_group_identifier_list[sum(a), sum(b)]</pre></summary><pre>
s = 'sum(a), sum(b)'

    @pytest.mark.parametrize('s', [
        'foo, bar',
        'sum(a), sum(b)',
        'sum(a) as x, b as y',
        'sum(a)::integer, b',
        'sum(a)/count(b) as x, y',
        'sum(a)::integer as x, y',
        'sum(a)::integer/count(b) as x, y',  # issue297
    ])
    def test_group_identifier_list(s):
>       parsed = sqlparse.parse(s)[0]

tests/test_grouping.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_group_identifier_listsuma-as-x-b-as-y">test_grouping.py::test_group_identifier_list[sum(a) as x, b as y]</h3>
<details><summary> <pre>test_grouping.py::test_group_identifier_list[sum(a) as x, b as y]</pre></summary><pre>
s = 'sum(a) as x, b as y'

    @pytest.mark.parametrize('s', [
        'foo, bar',
        'sum(a), sum(b)',
        'sum(a) as x, b as y',
        'sum(a)::integer, b',
        'sum(a)/count(b) as x, y',
        'sum(a)::integer as x, y',
        'sum(a)::integer/count(b) as x, y',  # issue297
    ])
    def test_group_identifier_list(s):
>       parsed = sqlparse.parse(s)[0]

tests/test_grouping.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_group_identifier_listsumainteger-b">test_grouping.py::test_group_identifier_list[sum(a)::integer, b]</h3>
<details><summary> <pre>test_grouping.py::test_group_identifier_list[sum(a)::integer, b]</pre></summary><pre>
s = 'sum(a)::integer, b'

    @pytest.mark.parametrize('s', [
        'foo, bar',
        'sum(a), sum(b)',
        'sum(a) as x, b as y',
        'sum(a)::integer, b',
        'sum(a)/count(b) as x, y',
        'sum(a)::integer as x, y',
        'sum(a)::integer/count(b) as x, y',  # issue297
    ])
    def test_group_identifier_list(s):
>       parsed = sqlparse.parse(s)[0]

tests/test_grouping.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="countb-as-x-y">count(b) as x, y]</h3>
<details><summary> <pre>count(b) as x, y]</pre></summary><pre>
s = 'sum(a)/count(b) as x, y'

    @pytest.mark.parametrize('s', [
        'foo, bar',
        'sum(a), sum(b)',
        'sum(a) as x, b as y',
        'sum(a)::integer, b',
        'sum(a)/count(b) as x, y',
        'sum(a)::integer as x, y',
        'sum(a)::integer/count(b) as x, y',  # issue297
    ])
    def test_group_identifier_list(s):
>       parsed = sqlparse.parse(s)[0]

tests/test_grouping.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_group_identifier_listsumainteger-as-x-y">test_grouping.py::test_group_identifier_list[sum(a)::integer as x, y]</h3>
<details><summary> <pre>test_grouping.py::test_group_identifier_list[sum(a)::integer as x, y]</pre></summary><pre>
s = 'sum(a)::integer as x, y'

    @pytest.mark.parametrize('s', [
        'foo, bar',
        'sum(a), sum(b)',
        'sum(a) as x, b as y',
        'sum(a)::integer, b',
        'sum(a)/count(b) as x, y',
        'sum(a)::integer as x, y',
        'sum(a)::integer/count(b) as x, y',  # issue297
    ])
    def test_group_identifier_list(s):
>       parsed = sqlparse.parse(s)[0]

tests/test_grouping.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="countb-as-x-y_1">count(b) as x, y]</h3>
<details><summary> <pre>count(b) as x, y]</pre></summary><pre>
s = 'sum(a)::integer/count(b) as x, y'

    @pytest.mark.parametrize('s', [
        'foo, bar',
        'sum(a), sum(b)',
        'sum(a) as x, b as y',
        'sum(a)::integer, b',
        'sum(a)/count(b) as x, y',
        'sum(a)::integer as x, y',
        'sum(a)::integer/count(b) as x, y',  # issue297
    ])
    def test_group_identifier_list(s):
>       parsed = sqlparse.parse(s)[0]

tests/test_grouping.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_identifier_wildcard">test_grouping.py::test_grouping_identifier_wildcard</h3>
<details><summary> <pre>test_grouping.py::test_grouping_identifier_wildcard</pre></summary><pre>
def test_grouping_identifier_wildcard():
>       p = sqlparse.parse('a.*, b.id')[0]

tests/test_grouping.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_identifier_name_wildcard">test_grouping.py::test_grouping_identifier_name_wildcard</h3>
<details><summary> <pre>test_grouping.py::test_grouping_identifier_name_wildcard</pre></summary><pre>
def test_grouping_identifier_name_wildcard():
>       p = sqlparse.parse('a.*')[0]

tests/test_grouping.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_identifier_invalid">test_grouping.py::test_grouping_identifier_invalid</h3>
<details><summary> <pre>test_grouping.py::test_grouping_identifier_invalid</pre></summary><pre>
def test_grouping_identifier_invalid():
>       p = sqlparse.parse('a.')[0]

tests/test_grouping.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_identifier_invalid_in_middle">test_grouping.py::test_grouping_identifier_invalid_in_middle</h3>
<details><summary> <pre>test_grouping.py::test_grouping_identifier_invalid_in_middle</pre></summary><pre>
def test_grouping_identifier_invalid_in_middle():
        # issue261
        s = 'SELECT foo. FROM foo'
>       p = sqlparse.parse(s)[0]

tests/test_grouping.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_identifer_asfoo-as-select">test_grouping.py::test_grouping_identifer_as[foo as (select *)]</h3>
<details><summary> <pre>test_grouping.py::test_grouping_identifer_as[foo as (select *)]</pre></summary><pre>
s = 'foo as (select *)'

    @pytest.mark.parametrize('s', ['foo as (select *)', 'foo as(select *)'])
    def test_grouping_identifer_as(s):
        # issue507
>       p = sqlparse.parse(s)[0]

tests/test_grouping.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_identifer_asfoo-asselect">test_grouping.py::test_grouping_identifer_as[foo as(select *)]</h3>
<details><summary> <pre>test_grouping.py::test_grouping_identifer_as[foo as(select *)]</pre></summary><pre>
s = 'foo as(select *)'

    @pytest.mark.parametrize('s', ['foo as (select *)', 'foo as(select *)'])
    def test_grouping_identifer_as(s):
        # issue507
>       p = sqlparse.parse(s)[0]

tests/test_grouping.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_identifier_as_invalid">test_grouping.py::test_grouping_identifier_as_invalid</h3>
<details><summary> <pre>test_grouping.py::test_grouping_identifier_as_invalid</pre></summary><pre>
def test_grouping_identifier_as_invalid():
        # issue8
>       p = sqlparse.parse('foo as select *')[0]

tests/test_grouping.py:166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_identifier_function">test_grouping.py::test_grouping_identifier_function</h3>
<details><summary> <pre>test_grouping.py::test_grouping_identifier_function</pre></summary><pre>
def test_grouping_identifier_function():
>       p = sqlparse.parse('foo() as bar')[0]

tests/test_grouping.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_operationfoo100">test_grouping.py::test_grouping_operation[foo+100]</h3>
<details><summary> <pre>test_grouping.py::test_grouping_operation[foo+100]</pre></summary><pre>
s = 'foo+100'

    @pytest.mark.parametrize('s', ['foo+100', 'foo + 100', 'foo*100'])
    def test_grouping_operation(s):
>       p = sqlparse.parse(s)[0]

tests/test_grouping.py:199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_operationfoo-100">test_grouping.py::test_grouping_operation[foo + 100]</h3>
<details><summary> <pre>test_grouping.py::test_grouping_operation[foo + 100]</pre></summary><pre>
s = 'foo + 100'

    @pytest.mark.parametrize('s', ['foo+100', 'foo + 100', 'foo*100'])
    def test_grouping_operation(s):
>       p = sqlparse.parse(s)[0]

tests/test_grouping.py:199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_operationfoo100_1">test_grouping.py::test_grouping_operation[foo*100]</h3>
<details><summary> <pre>test_grouping.py::test_grouping_operation[foo*100]</pre></summary><pre>
s = 'foo*100'

    @pytest.mark.parametrize('s', ['foo+100', 'foo + 100', 'foo*100'])
    def test_grouping_operation(s):
>       p = sqlparse.parse(s)[0]

tests/test_grouping.py:199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_identifier_list">test_grouping.py::test_grouping_identifier_list</h3>
<details><summary> <pre>test_grouping.py::test_grouping_identifier_list</pre></summary><pre>
def test_grouping_identifier_list():
>       p = sqlparse.parse('a, b, c')[0]

tests/test_grouping.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_identifier_list_subquery">test_grouping.py::test_grouping_identifier_list_subquery</h3>
<details><summary> <pre>test_grouping.py::test_grouping_identifier_list_subquery</pre></summary><pre>
def test_grouping_identifier_list_subquery():
        """identifier lists should still work in subqueries with aliases"""
>       p = sqlparse.parse("select * from ("
                           "select a, b + c as d from table) sub")[0]

tests/test_grouping.py:212: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_identifier_list_case">test_grouping.py::test_grouping_identifier_list_case</h3>
<details><summary> <pre>test_grouping.py::test_grouping_identifier_list_case</pre></summary><pre>
def test_grouping_identifier_list_case():
>       p = sqlparse.parse('a, case when 1 then 2 else 3 end as b, c')[0]

tests/test_grouping.py:223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_identifier_list_other">test_grouping.py::test_grouping_identifier_list_other</h3>
<details><summary> <pre>test_grouping.py::test_grouping_identifier_list_other</pre></summary><pre>
def test_grouping_identifier_list_other():
        # issue2
>       p = sqlparse.parse("select *, null, 1, 'foo', bar from mytable, x")[0]

tests/test_grouping.py:231: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_identifier_list_with_inline_comments">test_grouping.py::test_grouping_identifier_list_with_inline_comments</h3>
<details><summary> <pre>test_grouping.py::test_grouping_identifier_list_with_inline_comments</pre></summary><pre>
def test_grouping_identifier_list_with_inline_comments():
        # issue163
>       p = sqlparse.parse('foo /* a comment */, bar')[0]

tests/test_grouping.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_identifiers_with_operators">test_grouping.py::test_grouping_identifiers_with_operators</h3>
<details><summary> <pre>test_grouping.py::test_grouping_identifiers_with_operators</pre></summary><pre>
def test_grouping_identifiers_with_operators():
>       p = sqlparse.parse('a+b as c from table where (d-e)%2= 1')[0]

tests/test_grouping.py:245: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_identifier_list_with_order">test_grouping.py::test_grouping_identifier_list_with_order</h3>
<details><summary> <pre>test_grouping.py::test_grouping_identifier_list_with_order</pre></summary><pre>
def test_grouping_identifier_list_with_order():
        # issue101
>       p = sqlparse.parse('1, 2 desc, 3')[0]

tests/test_grouping.py:251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_nested_identifier_with_order">test_grouping.py::test_grouping_nested_identifier_with_order</h3>
<details><summary> <pre>test_grouping.py::test_grouping_nested_identifier_with_order</pre></summary><pre>
def test_grouping_nested_identifier_with_order():
        # issue745
>       p = sqlparse.parse('(a desc)')[0]

tests/test_grouping.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_where">test_grouping.py::test_grouping_where</h3>
<details><summary> <pre>test_grouping.py::test_grouping_where</pre></summary><pre>
def test_grouping_where():
        s = 'select * from foo where bar = 1 order by id desc'
>       p = sqlparse.parse(s)[0]

tests/test_grouping.py:267: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_where_unionselect-1-where-1-2-union-select-2">test_grouping.py::test_grouping_where_union[select 1 where 1 = 2 union select 2]</h3>
<details><summary> <pre>test_grouping.py::test_grouping_where_union[select 1 where 1 = 2 union select 2]</pre></summary><pre>
s = 'select 1 where 1 = 2 union select 2'

    @pytest.mark.parametrize('s', (
        'select 1 where 1 = 2 union select 2',
        'select 1 where 1 = 2 union all select 2',
    ))
    def test_grouping_where_union(s):
>       p = sqlparse.parse(s)[0]

tests/test_grouping.py:282: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_where_unionselect-1-where-1-2-union-all-select-2">test_grouping.py::test_grouping_where_union[select 1 where 1 = 2 union all select 2]</h3>
<details><summary> <pre>test_grouping.py::test_grouping_where_union[select 1 where 1 = 2 union all select 2]</pre></summary><pre>
s = 'select 1 where 1 = 2 union all select 2'

    @pytest.mark.parametrize('s', (
        'select 1 where 1 = 2 union select 2',
        'select 1 where 1 = 2 union all select 2',
    ))
    def test_grouping_where_union(s):
>       p = sqlparse.parse(s)[0]

tests/test_grouping.py:282: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_returning_kw_ends_where_clause">test_grouping.py::test_returning_kw_ends_where_clause</h3>
<details><summary> <pre>test_grouping.py::test_returning_kw_ends_where_clause</pre></summary><pre>
def test_returning_kw_ends_where_clause():
        s = 'delete from foo where x > y returning z'
>       p = sqlparse.parse(s)[0]

tests/test_grouping.py:288: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_into_kw_ends_where_clause">test_grouping.py::test_into_kw_ends_where_clause</h3>
<details><summary> <pre>test_grouping.py::test_into_kw_ends_where_clause</pre></summary><pre>
def test_into_kw_ends_where_clause():  # issue324
        s = 'select * from foo where a = 1 into baz'
>       p = sqlparse.parse(s)[0]

tests/test_grouping.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_typecastselect-foointeger-from-bar-integer">test_grouping.py::test_grouping_typecast[select foo::integer from bar-integer]</h3>
<details><summary> <pre>test_grouping.py::test_grouping_typecast[select foo::integer from bar-integer]</pre></summary><pre>
sql = 'select foo::integer from bar', expected = 'integer'

    @pytest.mark.parametrize('sql, expected', [
        # note: typecast needs to be 2nd token for this test
        ('select foo::integer from bar', 'integer'),
        ('select (current_database())::information_schema.sql_identifier',
         'information_schema.sql_identifier'),
    ])
    def test_grouping_typecast(sql, expected):
>       p = sqlparse.parse(sql)[0]

tests/test_grouping.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_typecastselect-current_databaseinformation_schemasql_identifier-information_schemasql_identifier">test_grouping.py::test_grouping_typecast[select (current_database())::information_schema.sql_identifier-information_schema.sql_identifier]</h3>
<details><summary> <pre>test_grouping.py::test_grouping_typecast[select (current_database())::information_schema.sql_identifier-information_schema.sql_identifier]</pre></summary><pre>
sql = 'select (current_database())::information_schema.sql_identifier'
expected = 'information_schema.sql_identifier'

    @pytest.mark.parametrize('sql, expected', [
        # note: typecast needs to be 2nd token for this test
        ('select foo::integer from bar', 'integer'),
        ('select (current_database())::information_schema.sql_identifier',
         'information_schema.sql_identifier'),
    ])
    def test_grouping_typecast(sql, expected):
>       p = sqlparse.parse(sql)[0]

tests/test_grouping.py:309: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_alias">test_grouping.py::test_grouping_alias</h3>
<details><summary> <pre>test_grouping.py::test_grouping_alias</pre></summary><pre>
def test_grouping_alias():
        s = 'select foo as bar from mytable'
>       p = sqlparse.parse(s)[0]

tests/test_grouping.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_alias_case">test_grouping.py::test_grouping_alias_case</h3>
<details><summary> <pre>test_grouping.py::test_grouping_alias_case</pre></summary><pre>
def test_grouping_alias_case():
        # see issue46
>       p = sqlparse.parse('CASE WHEN 1 THEN 2 ELSE 3 END foo')[0]

tests/test_grouping.py:337: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_alias_ctas">test_grouping.py::test_grouping_alias_ctas</h3>
<details><summary> <pre>test_grouping.py::test_grouping_alias_ctas</pre></summary><pre>
def test_grouping_alias_ctas():
>       p = sqlparse.parse('CREATE TABLE tbl1 AS SELECT coalesce(t1.col1, 0) AS col1 FROM t1')[0]

tests/test_grouping.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_subquery_no_parens">test_grouping.py::test_grouping_subquery_no_parens</h3>
<details><summary> <pre>test_grouping.py::test_grouping_subquery_no_parens</pre></summary><pre>
def test_grouping_subquery_no_parens():
        # Not totally sure if this is the right approach...
        # When a THEN clause contains a subquery w/o parenthesis around it *and*
        # a WHERE condition, the WHERE grouper consumes END too.
        # This takes makes sure that it doesn't fail.
>       p = sqlparse.parse('CASE WHEN 1 THEN select 2 where foo = 1 end')[0]

tests/test_grouping.py:352: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_alias_returns_nonefoobar">test_grouping.py::test_grouping_alias_returns_none[foo.bar]</h3>
<details><summary> <pre>test_grouping.py::test_grouping_alias_returns_none[foo.bar]</pre></summary><pre>
s = 'foo.bar'

    @pytest.mark.parametrize('s', ['foo.bar', 'x, y', 'x > y', 'x / y'])
    def test_grouping_alias_returns_none(s):
        # see issue185 and issue445
>       p = sqlparse.parse(s)[0]

tests/test_grouping.py:360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_alias_returns_nonex-y">test_grouping.py::test_grouping_alias_returns_none[x, y]</h3>
<details><summary> <pre>test_grouping.py::test_grouping_alias_returns_none[x, y]</pre></summary><pre>
s = 'x, y'

    @pytest.mark.parametrize('s', ['foo.bar', 'x, y', 'x > y', 'x / y'])
    def test_grouping_alias_returns_none(s):
        # see issue185 and issue445
>       p = sqlparse.parse(s)[0]

tests/test_grouping.py:360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_alias_returns_nonex-y_1">test_grouping.py::test_grouping_alias_returns_none[x &gt; y]</h3>
<details><summary> <pre>test_grouping.py::test_grouping_alias_returns_none[x > y]</pre></summary><pre>
s = 'x > y'

    @pytest.mark.parametrize('s', ['foo.bar', 'x, y', 'x > y', 'x / y'])
    def test_grouping_alias_returns_none(s):
        # see issue185 and issue445
>       p = sqlparse.parse(s)[0]

tests/test_grouping.py:360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="y">y]</h3>
<details><summary> <pre> y]</pre></summary><pre>
s = 'x / y'

    @pytest.mark.parametrize('s', ['foo.bar', 'x, y', 'x > y', 'x / y'])
    def test_grouping_alias_returns_none(s):
        # see issue185 and issue445
>       p = sqlparse.parse(s)[0]

tests/test_grouping.py:360: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_idlist_function">test_grouping.py::test_grouping_idlist_function</h3>
<details><summary> <pre>test_grouping.py::test_grouping_idlist_function</pre></summary><pre>
def test_grouping_idlist_function():
        # see issue10 too
>       p = sqlparse.parse('foo(1) x, bar')[0]

tests/test_grouping.py:367: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_comparison_exclude">test_grouping.py::test_grouping_comparison_exclude</h3>
<details><summary> <pre>test_grouping.py::test_grouping_comparison_exclude</pre></summary><pre>
def test_grouping_comparison_exclude():
        # make sure operators are not handled too lazy
>       p = sqlparse.parse('(=)')[0]

tests/test_grouping.py:373: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_function">test_grouping.py::test_grouping_function</h3>
<details><summary> <pre>test_grouping.py::test_grouping_function</pre></summary><pre>
def test_grouping_function():
>       p = sqlparse.parse('foo()')[0]

tests/test_grouping.py:383: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_function_not_in">test_grouping.py::test_grouping_function_not_in</h3>
<details><summary> <pre>test_grouping.py::test_grouping_function_not_in</pre></summary><pre>
def test_grouping_function_not_in():
        # issue183
>       p = sqlparse.parse('in(1, 2)')[0]

tests/test_grouping.py:400: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_varchar">test_grouping.py::test_grouping_varchar</h3>
<details><summary> <pre>test_grouping.py::test_grouping_varchar</pre></summary><pre>
def test_grouping_varchar():
>       p = sqlparse.parse('"text" Varchar(50) NOT NULL')[0]

tests/test_grouping.py:407: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_statement_get_type">test_grouping.py::test_statement_get_type</h3>
<details><summary> <pre>test_grouping.py::test_statement_get_type</pre></summary><pre>
def test_statement_get_type():
        def f(sql):
            return sqlparse.parse(sql)[0]

>       assert f('select * from foo').get_type() == 'SELECT'

tests/test_grouping.py:415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_grouping.py:413: in f
    return sqlparse.parse(sql)[0]
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_identifier_with_operators">test_grouping.py::test_identifier_with_operators</h3>
<details><summary> <pre>test_grouping.py::test_identifier_with_operators</pre></summary><pre>
def test_identifier_with_operators():
        # issue 53
>       p = sqlparse.parse('foo||bar')[0]

tests/test_grouping.py:424: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_identifier_with_op_trailing_ws">test_grouping.py::test_identifier_with_op_trailing_ws</h3>
<details><summary> <pre>test_grouping.py::test_identifier_with_op_trailing_ws</pre></summary><pre>
def test_identifier_with_op_trailing_ws():
        # make sure trailing whitespace isn't grouped with identifier
>       p = sqlparse.parse('foo || bar ')[0]

tests/test_grouping.py:435: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_identifier_with_string_literals">test_grouping.py::test_identifier_with_string_literals</h3>
<details><summary> <pre>test_grouping.py::test_identifier_with_string_literals</pre></summary><pre>
def test_identifier_with_string_literals():
>       p = sqlparse.parse("foo + 'bar'")[0]

tests/test_grouping.py:442: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_identifier_consumes_ordering">test_grouping.py::test_identifier_consumes_ordering</h3>
<details><summary> <pre>test_grouping.py::test_identifier_consumes_ordering</pre></summary><pre>
def test_identifier_consumes_ordering():
        # issue89
>       p = sqlparse.parse('select * from foo order by c1 desc, c2, c3')[0]

tests/test_grouping.py:458: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_comparison_with_keywords">test_grouping.py::test_comparison_with_keywords</h3>
<details><summary> <pre>test_grouping.py::test_comparison_with_keywords</pre></summary><pre>
def test_comparison_with_keywords():
        # issue90
        # in fact these are assignments, but for now we don't distinguish them
>       p = sqlparse.parse('foo = NULL')[0]

tests/test_grouping.py:471: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_comparison_with_floats">test_grouping.py::test_comparison_with_floats</h3>
<details><summary> <pre>test_grouping.py::test_comparison_with_floats</pre></summary><pre>
def test_comparison_with_floats():
        # issue145
>       p = sqlparse.parse('foo = 25.5')[0]

tests/test_grouping.py:485: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_comparison_with_parenthesis">test_grouping.py::test_comparison_with_parenthesis</h3>
<details><summary> <pre>test_grouping.py::test_comparison_with_parenthesis</pre></summary><pre>
def test_comparison_with_parenthesis():
        # issue23
>       p = sqlparse.parse('(3 + 4) = 7')[0]

tests/test_grouping.py:495: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_comparison_with_strings">test_grouping.py::test_comparison_with_strings[=]</h3>
<details><summary> <pre>test_grouping.py::test_comparison_with_strings[=]</pre></summary><pre>
operator = '='

    @pytest.mark.parametrize('operator', (
        '=', '!=', '>', '<', '<=', '>=', '~', '~~', '!~~',
        'LIKE', 'NOT LIKE', 'ILIKE', 'NOT ILIKE',
    ))
    def test_comparison_with_strings(operator):
        # issue148
>       p = sqlparse.parse("foo {} 'bar'".format(operator))[0]

tests/test_grouping.py:509: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_comparison_with_strings_1">test_grouping.py::test_comparison_with_strings[!=]</h3>
<details><summary> <pre>test_grouping.py::test_comparison_with_strings[!=]</pre></summary><pre>
operator = '!='

    @pytest.mark.parametrize('operator', (
        '=', '!=', '>', '<', '<=', '>=', '~', '~~', '!~~',
        'LIKE', 'NOT LIKE', 'ILIKE', 'NOT ILIKE',
    ))
    def test_comparison_with_strings(operator):
        # issue148
>       p = sqlparse.parse("foo {} 'bar'".format(operator))[0]

tests/test_grouping.py:509: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_comparison_with_strings_2">test_grouping.py::test_comparison_with_strings[&gt;]</h3>
<details><summary> <pre>test_grouping.py::test_comparison_with_strings[>]</pre></summary><pre>
operator = '>'

    @pytest.mark.parametrize('operator', (
        '=', '!=', '>', '<', '<=', '>=', '~', '~~', '!~~',
        'LIKE', 'NOT LIKE', 'ILIKE', 'NOT ILIKE',
    ))
    def test_comparison_with_strings(operator):
        # issue148
>       p = sqlparse.parse("foo {} 'bar'".format(operator))[0]

tests/test_grouping.py:509: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_comparison_with_strings_3">test_grouping.py::test_comparison_with_strings[&lt;]</h3>
<details><summary> <pre>test_grouping.py::test_comparison_with_strings[<]</pre></summary><pre>
operator = '<'

    @pytest.mark.parametrize('operator', (
        '=', '!=', '>', '<', '<=', '>=', '~', '~~', '!~~',
        'LIKE', 'NOT LIKE', 'ILIKE', 'NOT ILIKE',
    ))
    def test_comparison_with_strings(operator):
        # issue148
>       p = sqlparse.parse("foo {} 'bar'".format(operator))[0]

tests/test_grouping.py:509: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_comparison_with_strings_4">test_grouping.py::test_comparison_with_strings[&lt;=]</h3>
<details><summary> <pre>test_grouping.py::test_comparison_with_strings[<=]</pre></summary><pre>
operator = '<='

    @pytest.mark.parametrize('operator', (
        '=', '!=', '>', '<', '<=', '>=', '~', '~~', '!~~',
        'LIKE', 'NOT LIKE', 'ILIKE', 'NOT ILIKE',
    ))
    def test_comparison_with_strings(operator):
        # issue148
>       p = sqlparse.parse("foo {} 'bar'".format(operator))[0]

tests/test_grouping.py:509: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_comparison_with_strings_5">test_grouping.py::test_comparison_with_strings[&gt;=]</h3>
<details><summary> <pre>test_grouping.py::test_comparison_with_strings[>=]</pre></summary><pre>
operator = '>='

    @pytest.mark.parametrize('operator', (
        '=', '!=', '>', '<', '<=', '>=', '~', '~~', '!~~',
        'LIKE', 'NOT LIKE', 'ILIKE', 'NOT ILIKE',
    ))
    def test_comparison_with_strings(operator):
        # issue148
>       p = sqlparse.parse("foo {} 'bar'".format(operator))[0]

tests/test_grouping.py:509: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_comparison_with_strings_6">test_grouping.py::test_comparison_with_strings[~]</h3>
<details><summary> <pre>test_grouping.py::test_comparison_with_strings[~]</pre></summary><pre>
operator = '~'

    @pytest.mark.parametrize('operator', (
        '=', '!=', '>', '<', '<=', '>=', '~', '~~', '!~~',
        'LIKE', 'NOT LIKE', 'ILIKE', 'NOT ILIKE',
    ))
    def test_comparison_with_strings(operator):
        # issue148
>       p = sqlparse.parse("foo {} 'bar'".format(operator))[0]

tests/test_grouping.py:509: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_comparison_with_strings_7">test_grouping.py::test_comparison_with_strings[~~]</h3>
<details><summary> <pre>test_grouping.py::test_comparison_with_strings[~~]</pre></summary><pre>
operator = '~~'

    @pytest.mark.parametrize('operator', (
        '=', '!=', '>', '<', '<=', '>=', '~', '~~', '!~~',
        'LIKE', 'NOT LIKE', 'ILIKE', 'NOT ILIKE',
    ))
    def test_comparison_with_strings(operator):
        # issue148
>       p = sqlparse.parse("foo {} 'bar'".format(operator))[0]

tests/test_grouping.py:509: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_comparison_with_strings_8">test_grouping.py::test_comparison_with_strings[!~~]</h3>
<details><summary> <pre>test_grouping.py::test_comparison_with_strings[!~~]</pre></summary><pre>
operator = '!~~'

    @pytest.mark.parametrize('operator', (
        '=', '!=', '>', '<', '<=', '>=', '~', '~~', '!~~',
        'LIKE', 'NOT LIKE', 'ILIKE', 'NOT ILIKE',
    ))
    def test_comparison_with_strings(operator):
        # issue148
>       p = sqlparse.parse("foo {} 'bar'".format(operator))[0]

tests/test_grouping.py:509: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_comparison_with_stringslike">test_grouping.py::test_comparison_with_strings[LIKE]</h3>
<details><summary> <pre>test_grouping.py::test_comparison_with_strings[LIKE]</pre></summary><pre>
operator = 'LIKE'

    @pytest.mark.parametrize('operator', (
        '=', '!=', '>', '<', '<=', '>=', '~', '~~', '!~~',
        'LIKE', 'NOT LIKE', 'ILIKE', 'NOT ILIKE',
    ))
    def test_comparison_with_strings(operator):
        # issue148
>       p = sqlparse.parse("foo {} 'bar'".format(operator))[0]

tests/test_grouping.py:509: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_comparison_with_stringsnot-like">test_grouping.py::test_comparison_with_strings[NOT LIKE]</h3>
<details><summary> <pre>test_grouping.py::test_comparison_with_strings[NOT LIKE]</pre></summary><pre>
operator = 'NOT LIKE'

    @pytest.mark.parametrize('operator', (
        '=', '!=', '>', '<', '<=', '>=', '~', '~~', '!~~',
        'LIKE', 'NOT LIKE', 'ILIKE', 'NOT ILIKE',
    ))
    def test_comparison_with_strings(operator):
        # issue148
>       p = sqlparse.parse("foo {} 'bar'".format(operator))[0]

tests/test_grouping.py:509: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_comparison_with_stringsilike">test_grouping.py::test_comparison_with_strings[ILIKE]</h3>
<details><summary> <pre>test_grouping.py::test_comparison_with_strings[ILIKE]</pre></summary><pre>
operator = 'ILIKE'

    @pytest.mark.parametrize('operator', (
        '=', '!=', '>', '<', '<=', '>=', '~', '~~', '!~~',
        'LIKE', 'NOT LIKE', 'ILIKE', 'NOT ILIKE',
    ))
    def test_comparison_with_strings(operator):
        # issue148
>       p = sqlparse.parse("foo {} 'bar'".format(operator))[0]

tests/test_grouping.py:509: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_comparison_with_stringsnot-ilike">test_grouping.py::test_comparison_with_strings[NOT ILIKE]</h3>
<details><summary> <pre>test_grouping.py::test_comparison_with_strings[NOT ILIKE]</pre></summary><pre>
operator = 'NOT ILIKE'

    @pytest.mark.parametrize('operator', (
        '=', '!=', '>', '<', '<=', '>=', '~', '~~', '!~~',
        'LIKE', 'NOT LIKE', 'ILIKE', 'NOT ILIKE',
    ))
    def test_comparison_with_strings(operator):
        # issue148
>       p = sqlparse.parse("foo {} 'bar'".format(operator))[0]

tests/test_grouping.py:509: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_like_and_ilike_comparison">test_grouping.py::test_like_and_ilike_comparison</h3>
<details><summary> <pre>test_grouping.py::test_like_and_ilike_comparison</pre></summary><pre>
def test_like_and_ilike_comparison():
        def validate_where_clause(where_clause, expected_tokens):
            assert len(where_clause.tokens) == len(expected_tokens)
            for where_token, expected_token in zip(where_clause, expected_tokens):
                expected_ttype, expected_value = expected_token
                if where_token.ttype is not None:
                    assert where_token.match(expected_ttype, expected_value, regex=True)
                else:
                    # Certain tokens, such as comparison tokens, do not define a ttype that can be
                    # matched against. For these tokens, we ensure that the token instance is of
                    # the expected type and has a value conforming to specified regular expression
                    import re
                    assert (isinstance(where_token, expected_ttype)
                            and re.match(expected_value, where_token.value))

>       [p1] = sqlparse.parse("select * from mytable where mytable.mycolumn LIKE 'expr%' limit 5;")

tests/test_grouping.py:531: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_comparison_with_functions">test_grouping.py::test_comparison_with_functions</h3>
<details><summary> <pre>test_grouping.py::test_comparison_with_functions</pre></summary><pre>
def test_comparison_with_functions():
        # issue230
>       p = sqlparse.parse('foo = DATE(bar.baz)')[0]

tests/test_grouping.py:553: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_comparison_with_typed_literal">test_grouping.py::test_comparison_with_typed_literal</h3>
<details><summary> <pre>test_grouping.py::test_comparison_with_typed_literal</pre></summary><pre>
def test_comparison_with_typed_literal():
>       p = sqlparse.parse("foo = DATE 'bar.baz'")[0]

tests/test_grouping.py:576: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_forloopsfor">test_grouping.py::test_forloops[FOR]</h3>
<details><summary> <pre>test_grouping.py::test_forloops[FOR]</pre></summary><pre>
start = 'FOR'

    @pytest.mark.parametrize('start', ['FOR', 'FOREACH'])
    def test_forloops(start):
>       p = sqlparse.parse('{} foo in bar LOOP foobar END LOOP'.format(start))[0]

tests/test_grouping.py:588: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_forloopsforeach">test_grouping.py::test_forloops[FOREACH]</h3>
<details><summary> <pre>test_grouping.py::test_forloops[FOREACH]</pre></summary><pre>
start = 'FOREACH'

    @pytest.mark.parametrize('start', ['FOR', 'FOREACH'])
    def test_forloops(start):
>       p = sqlparse.parse('{} foo in bar LOOP foobar END LOOP'.format(start))[0]

tests/test_grouping.py:588: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_nested_for">test_grouping.py::test_nested_for</h3>
<details><summary> <pre>test_grouping.py::test_nested_for</pre></summary><pre>
def test_nested_for():
>       p = sqlparse.parse('FOR foo LOOP FOR bar LOOP END LOOP END LOOP')[0]

tests/test_grouping.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_begin">test_grouping.py::test_begin</h3>
<details><summary> <pre>test_grouping.py::test_begin</pre></summary><pre>
def test_begin():
>       p = sqlparse.parse('BEGIN foo END')[0]

tests/test_grouping.py:606: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_keyword_followed_by_parenthesis">test_grouping.py::test_keyword_followed_by_parenthesis</h3>
<details><summary> <pre>test_grouping.py::test_keyword_followed_by_parenthesis</pre></summary><pre>
def test_keyword_followed_by_parenthesis():
>       p = sqlparse.parse('USING(somecol')[0]

tests/test_grouping.py:612: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_nested_begin">test_grouping.py::test_nested_begin</h3>
<details><summary> <pre>test_grouping.py::test_nested_begin</pre></summary><pre>
def test_nested_begin():
>       p = sqlparse.parse('BEGIN foo BEGIN bar END END')[0]

tests/test_grouping.py:619: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_aliased_column_without_as">test_grouping.py::test_aliased_column_without_as</h3>
<details><summary> <pre>test_grouping.py::test_aliased_column_without_as</pre></summary><pre>
def test_aliased_column_without_as():
>       p = sqlparse.parse('foo bar')[0].tokens

tests/test_grouping.py:631: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_qualified_function">test_grouping.py::test_qualified_function</h3>
<details><summary> <pre>test_grouping.py::test_qualified_function</pre></summary><pre>
def test_qualified_function():
>       p = sqlparse.parse('foo()')[0].tokens[0]

tests/test_grouping.py:643: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_aliased_function_without_as">test_grouping.py::test_aliased_function_without_as</h3>
<details><summary> <pre>test_grouping.py::test_aliased_function_without_as</pre></summary><pre>
def test_aliased_function_without_as():
>       p = sqlparse.parse('foo() bar')[0].tokens[0]

tests/test_grouping.py:653: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_aliased_literal_without_as">test_grouping.py::test_aliased_literal_without_as</h3>
<details><summary> <pre>test_grouping.py::test_aliased_literal_without_as</pre></summary><pre>
def test_aliased_literal_without_as():
>       p = sqlparse.parse('1 foo')[0].tokens

tests/test_grouping.py:665: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_as_cte">test_grouping.py::test_grouping_as_cte</h3>
<details><summary> <pre>test_grouping.py::test_grouping_as_cte</pre></summary><pre>
def test_grouping_as_cte():
>       p = sqlparse.parse('foo AS WITH apple AS 1, banana AS 2')[0].tokens

tests/test_grouping.py:671: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_groupingpytest_grouping_create_table">test_grouping.py::test_grouping_create_table</h3>
<details><summary> <pre>test_grouping.py::test_grouping_create_table</pre></summary><pre>
def test_grouping_create_table():
>       p = sqlparse.parse("create table db.tbl (a string)")[0].tokens

tests/test_grouping.py:678: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_keywordspytestsqlregextest_float_numbers10">test_keywords.py::TestSQLREGEX::test_float_numbers[1.0]</h3>
<details><summary> <pre>test_keywords.py::TestSQLREGEX::test_float_numbers[1.0]</pre></summary><pre>
self = <tests.test_keywords.TestSQLREGEX object at 0x7ef7ae2bf220>
number = '1.0'

    @pytest.mark.parametrize('number', ['1.0', '-1.0',
                                        '1.', '-1.',
                                        '.1', '-.1'])
    def test_float_numbers(self, number):
>       ttype = next(tt for action, tt in Lexer.get_default_instance()._SQL_REGEX if action(number))
E       StopIteration

tests/test_keywords.py:12: StopIteration

The above exception was the direct cause of the following exception:

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x7ef7adb7ab90>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: TResult | None = func()

.venv/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.10/site-packages/_pytest/runner.py:242: in <lambda>
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
.venv/lib/python3.10/site-packages/pluggy/_hooks.py:513: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
.venv/lib/python3.10/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
.venv/lib/python3.10/site-packages/_pytest/threadexception.py:92: in pytest_runtest_call
    yield from thread_exception_runtest_hook()
.venv/lib/python3.10/site-packages/_pytest/threadexception.py:68: in thread_exception_runtest_hook
    yield
.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:95: in pytest_runtest_call
    yield from unraisable_exception_runtest_hook()
.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:70: in unraisable_exception_runtest_hook
    yield
.venv/lib/python3.10/site-packages/_pytest/logging.py:846: in pytest_runtest_call
    yield from self._runtest_for(item, "call")
.venv/lib/python3.10/site-packages/_pytest/logging.py:829: in _runtest_for
    yield
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io....xtIOWrapper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>
item = <Function test_float_numbers[1.0]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
E           RuntimeError: generator raised StopIteration

.venv/lib/python3.10/site-packages/_pytest/capture.py:880: RuntimeError
</pre>
</details>
<h3 id="test_keywordspytestsqlregextest_float_numbers-10">test_keywords.py::TestSQLREGEX::test_float_numbers[-1.0]</h3>
<details><summary> <pre>test_keywords.py::TestSQLREGEX::test_float_numbers[-1.0]</pre></summary><pre>
self = <tests.test_keywords.TestSQLREGEX object at 0x7ef7ae2be650>
number = '-1.0'

    @pytest.mark.parametrize('number', ['1.0', '-1.0',
                                        '1.', '-1.',
                                        '.1', '-.1'])
    def test_float_numbers(self, number):
>       ttype = next(tt for action, tt in Lexer.get_default_instance()._SQL_REGEX if action(number))
E       StopIteration

tests/test_keywords.py:12: StopIteration

The above exception was the direct cause of the following exception:

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x7ef7ad4bd630>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: TResult | None = func()

.venv/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.10/site-packages/_pytest/runner.py:242: in <lambda>
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
.venv/lib/python3.10/site-packages/pluggy/_hooks.py:513: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
.venv/lib/python3.10/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
.venv/lib/python3.10/site-packages/_pytest/threadexception.py:92: in pytest_runtest_call
    yield from thread_exception_runtest_hook()
.venv/lib/python3.10/site-packages/_pytest/threadexception.py:68: in thread_exception_runtest_hook
    yield
.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:95: in pytest_runtest_call
    yield from unraisable_exception_runtest_hook()
.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:70: in unraisable_exception_runtest_hook
    yield
.venv/lib/python3.10/site-packages/_pytest/logging.py:846: in pytest_runtest_call
    yield from self._runtest_for(item, "call")
.venv/lib/python3.10/site-packages/_pytest/logging.py:829: in _runtest_for
    yield
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io....xtIOWrapper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>
item = <Function test_float_numbers[-1.0]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
E           RuntimeError: generator raised StopIteration

.venv/lib/python3.10/site-packages/_pytest/capture.py:880: RuntimeError
</pre>
</details>
<h3 id="test_keywordspytestsqlregextest_float_numbers1">test_keywords.py::TestSQLREGEX::test_float_numbers[1.]</h3>
<details><summary> <pre>test_keywords.py::TestSQLREGEX::test_float_numbers[1.]</pre></summary><pre>
self = <tests.test_keywords.TestSQLREGEX object at 0x7ef7ae2be2c0>
number = '1.'

    @pytest.mark.parametrize('number', ['1.0', '-1.0',
                                        '1.', '-1.',
                                        '.1', '-.1'])
    def test_float_numbers(self, number):
>       ttype = next(tt for action, tt in Lexer.get_default_instance()._SQL_REGEX if action(number))
E       StopIteration

tests/test_keywords.py:12: StopIteration

The above exception was the direct cause of the following exception:

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x7ef7ad8f93f0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: TResult | None = func()

.venv/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.10/site-packages/_pytest/runner.py:242: in <lambda>
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
.venv/lib/python3.10/site-packages/pluggy/_hooks.py:513: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
.venv/lib/python3.10/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
.venv/lib/python3.10/site-packages/_pytest/threadexception.py:92: in pytest_runtest_call
    yield from thread_exception_runtest_hook()
.venv/lib/python3.10/site-packages/_pytest/threadexception.py:68: in thread_exception_runtest_hook
    yield
.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:95: in pytest_runtest_call
    yield from unraisable_exception_runtest_hook()
.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:70: in unraisable_exception_runtest_hook
    yield
.venv/lib/python3.10/site-packages/_pytest/logging.py:846: in pytest_runtest_call
    yield from self._runtest_for(item, "call")
.venv/lib/python3.10/site-packages/_pytest/logging.py:829: in _runtest_for
    yield
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io....xtIOWrapper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>
item = <Function test_float_numbers[1.]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
E           RuntimeError: generator raised StopIteration

.venv/lib/python3.10/site-packages/_pytest/capture.py:880: RuntimeError
</pre>
</details>
<h3 id="test_keywordspytestsqlregextest_float_numbers-1">test_keywords.py::TestSQLREGEX::test_float_numbers[-1.]</h3>
<details><summary> <pre>test_keywords.py::TestSQLREGEX::test_float_numbers[-1.]</pre></summary><pre>
self = <tests.test_keywords.TestSQLREGEX object at 0x7ef7ae2be590>
number = '-1.'

    @pytest.mark.parametrize('number', ['1.0', '-1.0',
                                        '1.', '-1.',
                                        '.1', '-.1'])
    def test_float_numbers(self, number):
>       ttype = next(tt for action, tt in Lexer.get_default_instance()._SQL_REGEX if action(number))
E       StopIteration

tests/test_keywords.py:12: StopIteration

The above exception was the direct cause of the following exception:

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x7ef7adb7bac0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: TResult | None = func()

.venv/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.10/site-packages/_pytest/runner.py:242: in <lambda>
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
.venv/lib/python3.10/site-packages/pluggy/_hooks.py:513: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
.venv/lib/python3.10/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
.venv/lib/python3.10/site-packages/_pytest/threadexception.py:92: in pytest_runtest_call
    yield from thread_exception_runtest_hook()
.venv/lib/python3.10/site-packages/_pytest/threadexception.py:68: in thread_exception_runtest_hook
    yield
.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:95: in pytest_runtest_call
    yield from unraisable_exception_runtest_hook()
.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:70: in unraisable_exception_runtest_hook
    yield
.venv/lib/python3.10/site-packages/_pytest/logging.py:846: in pytest_runtest_call
    yield from self._runtest_for(item, "call")
.venv/lib/python3.10/site-packages/_pytest/logging.py:829: in _runtest_for
    yield
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io....xtIOWrapper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>
item = <Function test_float_numbers[-1.]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
E           RuntimeError: generator raised StopIteration

.venv/lib/python3.10/site-packages/_pytest/capture.py:880: RuntimeError
</pre>
</details>
<h3 id="test_keywordspytestsqlregextest_float_numbers1_1">test_keywords.py::TestSQLREGEX::test_float_numbers[.1]</h3>
<details><summary> <pre>test_keywords.py::TestSQLREGEX::test_float_numbers[.1]</pre></summary><pre>
self = <tests.test_keywords.TestSQLREGEX object at 0x7ef7ae2bee90>
number = '.1'

    @pytest.mark.parametrize('number', ['1.0', '-1.0',
                                        '1.', '-1.',
                                        '.1', '-.1'])
    def test_float_numbers(self, number):
>       ttype = next(tt for action, tt in Lexer.get_default_instance()._SQL_REGEX if action(number))
E       StopIteration

tests/test_keywords.py:12: StopIteration

The above exception was the direct cause of the following exception:

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x7ef7ad8f93f0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: TResult | None = func()

.venv/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.10/site-packages/_pytest/runner.py:242: in <lambda>
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
.venv/lib/python3.10/site-packages/pluggy/_hooks.py:513: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
.venv/lib/python3.10/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
.venv/lib/python3.10/site-packages/_pytest/threadexception.py:92: in pytest_runtest_call
    yield from thread_exception_runtest_hook()
.venv/lib/python3.10/site-packages/_pytest/threadexception.py:68: in thread_exception_runtest_hook
    yield
.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:95: in pytest_runtest_call
    yield from unraisable_exception_runtest_hook()
.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:70: in unraisable_exception_runtest_hook
    yield
.venv/lib/python3.10/site-packages/_pytest/logging.py:846: in pytest_runtest_call
    yield from self._runtest_for(item, "call")
.venv/lib/python3.10/site-packages/_pytest/logging.py:829: in _runtest_for
    yield
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io....xtIOWrapper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>
item = <Function test_float_numbers[.1]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
E           RuntimeError: generator raised StopIteration

.venv/lib/python3.10/site-packages/_pytest/capture.py:880: RuntimeError
</pre>
</details>
<h3 id="test_keywordspytestsqlregextest_float_numbers-1_1">test_keywords.py::TestSQLREGEX::test_float_numbers[-.1]</h3>
<details><summary> <pre>test_keywords.py::TestSQLREGEX::test_float_numbers[-.1]</pre></summary><pre>
self = <tests.test_keywords.TestSQLREGEX object at 0x7ef7ae2be380>
number = '-.1'

    @pytest.mark.parametrize('number', ['1.0', '-1.0',
                                        '1.', '-1.',
                                        '.1', '-.1'])
    def test_float_numbers(self, number):
>       ttype = next(tt for action, tt in Lexer.get_default_instance()._SQL_REGEX if action(number))
E       StopIteration

tests/test_keywords.py:12: StopIteration

The above exception was the direct cause of the following exception:

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x7ef7ad501b40>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: TResult | None = func()

.venv/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.10/site-packages/_pytest/runner.py:242: in <lambda>
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
.venv/lib/python3.10/site-packages/pluggy/_hooks.py:513: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
.venv/lib/python3.10/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
.venv/lib/python3.10/site-packages/_pytest/threadexception.py:92: in pytest_runtest_call
    yield from thread_exception_runtest_hook()
.venv/lib/python3.10/site-packages/_pytest/threadexception.py:68: in thread_exception_runtest_hook
    yield
.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:95: in pytest_runtest_call
    yield from unraisable_exception_runtest_hook()
.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:70: in unraisable_exception_runtest_hook
    yield
.venv/lib/python3.10/site-packages/_pytest/logging.py:846: in pytest_runtest_call
    yield from self._runtest_for(item, "call")
.venv/lib/python3.10/site-packages/_pytest/logging.py:829: in _runtest_for
    yield
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io....xtIOWrapper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>
item = <Function test_float_numbers[-.1]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
E           RuntimeError: generator raised StopIteration

.venv/lib/python3.10/site-packages/_pytest/capture.py:880: RuntimeError
</pre>
</details>
<h3 id="test_parsepytest_parse_tokenize">test_parse.py::test_parse_tokenize</h3>
<details><summary> <pre>test_parse.py::test_parse_tokenize</pre></summary><pre>
def test_parse_tokenize():
        s = 'select * from foo;'
>       stmts = sqlparse.parse(s)

tests/test_parse.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_multistatement">test_parse.py::test_parse_multistatement</h3>
<details><summary> <pre>test_parse.py::test_parse_multistatement</pre></summary><pre>
def test_parse_multistatement():
        sql1 = 'select * from foo;'
        sql2 = 'select * from bar;'
>       stmts = sqlparse.parse(sql1 + sql2)

tests/test_parse.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_newlinesselectnfrom-foo">test_parse.py::test_parse_newlines[select\n*from foo;]</h3>
<details><summary> <pre>test_parse.py::test_parse_newlines[select\n*from foo;]</pre></summary><pre>
s = 'select\n*from foo;'

    @pytest.mark.parametrize('s', ['select\n*from foo;',
                                   'select\r\n*from foo',
                                   'select\r*from foo',
                                   'select\r\n*from foo\n'])
    def test_parse_newlines(s):
>       p = sqlparse.parse(s)[0]

tests/test_parse.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_newlinesselectrnfrom-foo">test_parse.py::test_parse_newlines[select\r\n*from foo]</h3>
<details><summary> <pre>test_parse.py::test_parse_newlines[select\r\n*from foo]</pre></summary><pre>
s = 'select\r\n*from foo'

    @pytest.mark.parametrize('s', ['select\n*from foo;',
                                   'select\r\n*from foo',
                                   'select\r*from foo',
                                   'select\r\n*from foo\n'])
    def test_parse_newlines(s):
>       p = sqlparse.parse(s)[0]

tests/test_parse.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_newlinesselectrfrom-foo">test_parse.py::test_parse_newlines[select\r*from foo]</h3>
<details><summary> <pre>test_parse.py::test_parse_newlines[select\r*from foo]</pre></summary><pre>
s = 'select\r*from foo'

    @pytest.mark.parametrize('s', ['select\n*from foo;',
                                   'select\r\n*from foo',
                                   'select\r*from foo',
                                   'select\r\n*from foo\n'])
    def test_parse_newlines(s):
>       p = sqlparse.parse(s)[0]

tests/test_parse.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_newlinesselectrnfrom-foon">test_parse.py::test_parse_newlines[select\r\n*from foo\n]</h3>
<details><summary> <pre>test_parse.py::test_parse_newlines[select\r\n*from foo\n]</pre></summary><pre>
s = 'select\r\n*from foo\n'

    @pytest.mark.parametrize('s', ['select\n*from foo;',
                                   'select\r\n*from foo',
                                   'select\r*from foo',
                                   'select\r\n*from foo\n'])
    def test_parse_newlines(s):
>       p = sqlparse.parse(s)[0]

tests/test_parse.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_within">test_parse.py::test_parse_within</h3>
<details><summary> <pre>test_parse.py::test_parse_within</pre></summary><pre>
def test_parse_within():
        s = 'foo(col1, col2)'
>       p = sqlparse.parse(s)[0]

tests/test_parse.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_child_of">test_parse.py::test_parse_child_of</h3>
<details><summary> <pre>test_parse.py::test_parse_child_of</pre></summary><pre>
def test_parse_child_of():
        s = '(col1, col2)'
>       p = sqlparse.parse(s)[0]

tests/test_parse.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_has_ancestor">test_parse.py::test_parse_has_ancestor</h3>
<details><summary> <pre>test_parse.py::test_parse_has_ancestor</pre></summary><pre>
def test_parse_has_ancestor():
        s = 'foo or (bar, baz)'
>       p = sqlparse.parse(s)[0]

tests/test_parse.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_float5">test_parse.py::test_parse_float[.5]</h3>
<details><summary> <pre>test_parse.py::test_parse_float[.5]</pre></summary><pre>
s = '.5'

    @pytest.mark.parametrize('s', ['.5', '.51', '1.5', '12.5'])
    def test_parse_float(s):
>       t = sqlparse.parse(s)[0].tokens

tests/test_parse.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_float51">test_parse.py::test_parse_float[.51]</h3>
<details><summary> <pre>test_parse.py::test_parse_float[.51]</pre></summary><pre>
s = '.51'

    @pytest.mark.parametrize('s', ['.5', '.51', '1.5', '12.5'])
    def test_parse_float(s):
>       t = sqlparse.parse(s)[0].tokens

tests/test_parse.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_float15">test_parse.py::test_parse_float[1.5]</h3>
<details><summary> <pre>test_parse.py::test_parse_float[1.5]</pre></summary><pre>
s = '1.5'

    @pytest.mark.parametrize('s', ['.5', '.51', '1.5', '12.5'])
    def test_parse_float(s):
>       t = sqlparse.parse(s)[0].tokens

tests/test_parse.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_float125">test_parse.py::test_parse_float[12.5]</h3>
<details><summary> <pre>test_parse.py::test_parse_float[12.5]</pre></summary><pre>
s = '12.5'

    @pytest.mark.parametrize('s', ['.5', '.51', '1.5', '12.5'])
    def test_parse_float(s):
>       t = sqlparse.parse(s)[0].tokens

tests/test_parse.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_placeholderselect-from-foo-where-user-">test_parse.py::test_parse_placeholder[select * from foo where user = ?-?]</h3>
<details><summary> <pre>test_parse.py::test_parse_placeholder[select * from foo where user = ?-?]</pre></summary><pre>
s = 'select * from foo where user = ?', holder = '?'

    @pytest.mark.parametrize('s, holder', [
        ('select * from foo where user = ?', '?'),
        ('select * from foo where user = :1', ':1'),
        ('select * from foo where user = :name', ':name'),
        ('select * from foo where user = %s', '%s'),
        ('select * from foo where user = $a', '$a')])
    def test_parse_placeholder(s, holder):
>       t = sqlparse.parse(s)[0].tokens[-1].tokens

tests/test_parse.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_placeholderselect-from-foo-where-user-1-1">test_parse.py::test_parse_placeholder[select * from foo where user = :1-:1]</h3>
<details><summary> <pre>test_parse.py::test_parse_placeholder[select * from foo where user = :1-:1]</pre></summary><pre>
s = 'select * from foo where user = :1', holder = ':1'

    @pytest.mark.parametrize('s, holder', [
        ('select * from foo where user = ?', '?'),
        ('select * from foo where user = :1', ':1'),
        ('select * from foo where user = :name', ':name'),
        ('select * from foo where user = %s', '%s'),
        ('select * from foo where user = $a', '$a')])
    def test_parse_placeholder(s, holder):
>       t = sqlparse.parse(s)[0].tokens[-1].tokens

tests/test_parse.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_placeholderselect-from-foo-where-user-name-name">test_parse.py::test_parse_placeholder[select * from foo where user = :name-:name]</h3>
<details><summary> <pre>test_parse.py::test_parse_placeholder[select * from foo where user = :name-:name]</pre></summary><pre>
s = 'select * from foo where user = :name', holder = ':name'

    @pytest.mark.parametrize('s, holder', [
        ('select * from foo where user = ?', '?'),
        ('select * from foo where user = :1', ':1'),
        ('select * from foo where user = :name', ':name'),
        ('select * from foo where user = %s', '%s'),
        ('select * from foo where user = $a', '$a')])
    def test_parse_placeholder(s, holder):
>       t = sqlparse.parse(s)[0].tokens[-1].tokens

tests/test_parse.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_placeholderselect-from-foo-where-user-s-s">test_parse.py::test_parse_placeholder[select * from foo where user = %s-%s]</h3>
<details><summary> <pre>test_parse.py::test_parse_placeholder[select * from foo where user = %s-%s]</pre></summary><pre>
s = 'select * from foo where user = %s', holder = '%s'

    @pytest.mark.parametrize('s, holder', [
        ('select * from foo where user = ?', '?'),
        ('select * from foo where user = :1', ':1'),
        ('select * from foo where user = :name', ':name'),
        ('select * from foo where user = %s', '%s'),
        ('select * from foo where user = $a', '$a')])
    def test_parse_placeholder(s, holder):
>       t = sqlparse.parse(s)[0].tokens[-1].tokens

tests/test_parse.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_placeholderselect-from-foo-where-user-a-a">test_parse.py::test_parse_placeholder[select * from foo where user = $a-$a]</h3>
<details><summary> <pre>test_parse.py::test_parse_placeholder[select * from foo where user = $a-$a]</pre></summary><pre>
s = 'select * from foo where user = $a', holder = '$a'

    @pytest.mark.parametrize('s, holder', [
        ('select * from foo where user = ?', '?'),
        ('select * from foo where user = :1', ':1'),
        ('select * from foo where user = :name', ':name'),
        ('select * from foo where user = %s', '%s'),
        ('select * from foo where user = $a', '$a')])
    def test_parse_placeholder(s, holder):
>       t = sqlparse.parse(s)[0].tokens[-1].tokens

tests/test_parse.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_access_symbol">test_parse.py::test_parse_access_symbol</h3>
<details><summary> <pre>test_parse.py::test_parse_access_symbol</pre></summary><pre>
def test_parse_access_symbol():
        # see issue27
>       t = sqlparse.parse('select a.[foo bar] as foo')[0].tokens

tests/test_parse.py:88: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_square_brackets_notation_isnt_too_greedy">test_parse.py::test_parse_square_brackets_notation_isnt_too_greedy</h3>
<details><summary> <pre>test_parse.py::test_parse_square_brackets_notation_isnt_too_greedy</pre></summary><pre>
def test_parse_square_brackets_notation_isnt_too_greedy():
        # see issue153
>       t = sqlparse.parse('[foo], [bar]')[0].tokens

tests/test_parse.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_square_brackets_notation_isnt_too_greedy2">test_parse.py::test_parse_square_brackets_notation_isnt_too_greedy2</h3>
<details><summary> <pre>test_parse.py::test_parse_square_brackets_notation_isnt_too_greedy2</pre></summary><pre>
def test_parse_square_brackets_notation_isnt_too_greedy2():
        # see issue583
>       t = sqlparse.parse('[(foo[i])]')[0].tokens

tests/test_parse.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_keyword_like_identifier">test_parse.py::test_parse_keyword_like_identifier</h3>
<details><summary> <pre>test_parse.py::test_parse_keyword_like_identifier</pre></summary><pre>
def test_parse_keyword_like_identifier():
        # see issue47
>       t = sqlparse.parse('foo.key')[0].tokens

tests/test_parse.py:112: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_function_parameter">test_parse.py::test_parse_function_parameter</h3>
<details><summary> <pre>test_parse.py::test_parse_function_parameter</pre></summary><pre>
def test_parse_function_parameter():
        # see issue94
>       t = sqlparse.parse('abs(some_col)')[0].tokens[0].get_parameters()

tests/test_parse.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_function_param_single_literal">test_parse.py::test_parse_function_param_single_literal</h3>
<details><summary> <pre>test_parse.py::test_parse_function_param_single_literal</pre></summary><pre>
def test_parse_function_param_single_literal():
>       t = sqlparse.parse('foo(5)')[0].tokens[0].get_parameters()

tests/test_parse.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_nested_function">test_parse.py::test_parse_nested_function</h3>
<details><summary> <pre>test_parse.py::test_parse_nested_function</pre></summary><pre>
def test_parse_nested_function():
>       t = sqlparse.parse('foo(bar(5))')[0].tokens[0].get_parameters()

tests/test_parse.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_casted_params">test_parse.py::test_parse_casted_params</h3>
<details><summary> <pre>test_parse.py::test_parse_casted_params</pre></summary><pre>
def test_parse_casted_params():
>       t = sqlparse.parse("foo(DATE '2023-11-14', TIMESTAMP '2023-11-15')")[0].tokens[0].get_parameters()

tests/test_parse.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_div_operator">test_parse.py::test_parse_div_operator</h3>
<details><summary> <pre>test_parse.py::test_parse_div_operator</pre></summary><pre>
def test_parse_div_operator():
>       p = sqlparse.parse('col1 DIV 5 AS div_col1')[0].tokens

tests/test_parse.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_quoted_identifier">test_parse.py::test_quoted_identifier</h3>
<details><summary> <pre>test_parse.py::test_quoted_identifier</pre></summary><pre>
def test_quoted_identifier():
>       t = sqlparse.parse('select x.y as "z" from foo')[0].tokens

tests/test_parse.py:148: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_valid_identifier_namesfoo">test_parse.py::test_valid_identifier_names[foo]</h3>
<details><summary> <pre>test_parse.py::test_valid_identifier_names[foo]</pre></summary><pre>
name = 'foo'

    @pytest.mark.parametrize('name', [
        'foo', '_foo',  # issue175
        '1_data',  # valid MySQL table name, see issue337
        '業者名稱',  # valid at least for SQLite3, see issue641
    ])
    def test_valid_identifier_names(name):
>       t = sqlparse.parse(name)[0].tokens

tests/test_parse.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_valid_identifier_names_foo">test_parse.py::test_valid_identifier_names[_foo]</h3>
<details><summary> <pre>test_parse.py::test_valid_identifier_names[_foo]</pre></summary><pre>
name = '_foo'

    @pytest.mark.parametrize('name', [
        'foo', '_foo',  # issue175
        '1_data',  # valid MySQL table name, see issue337
        '業者名稱',  # valid at least for SQLite3, see issue641
    ])
    def test_valid_identifier_names(name):
>       t = sqlparse.parse(name)[0].tokens

tests/test_parse.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_valid_identifier_names1_data">test_parse.py::test_valid_identifier_names[1_data]</h3>
<details><summary> <pre>test_parse.py::test_valid_identifier_names[1_data]</pre></summary><pre>
name = '1_data'

    @pytest.mark.parametrize('name', [
        'foo', '_foo',  # issue175
        '1_data',  # valid MySQL table name, see issue337
        '業者名稱',  # valid at least for SQLite3, see issue641
    ])
    def test_valid_identifier_names(name):
>       t = sqlparse.parse(name)[0].tokens

tests/test_parse.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_valid_identifier_namesu696du8005u540du7a31">test_parse.py::test_valid_identifier_names[\u696d\u8005\u540d\u7a31]</h3>
<details><summary> <pre>test_parse.py::test_valid_identifier_names[\u696d\u8005\u540d\u7a31]</pre></summary><pre>
name = '業者名稱'

    @pytest.mark.parametrize('name', [
        'foo', '_foo',  # issue175
        '1_data',  # valid MySQL table name, see issue337
        '業者名稱',  # valid at least for SQLite3, see issue641
    ])
    def test_valid_identifier_names(name):
>       t = sqlparse.parse(name)[0].tokens

tests/test_parse.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_psql_quotation_marks">test_parse.py::test_psql_quotation_marks</h3>
<details><summary> <pre>test_parse.py::test_psql_quotation_marks</pre></summary><pre>
def test_psql_quotation_marks():
        # issue83

        # regression: make sure plain $$ work
>       t = sqlparse.split("""
        CREATE OR REPLACE FUNCTION testfunc1(integer) RETURNS integer AS $$
              ....
        $$ LANGUAGE plpgsql;
        CREATE OR REPLACE FUNCTION testfunc2(integer) RETURNS integer AS $$
              ....
        $$ LANGUAGE plpgsql;""")

tests/test_parse.py:169: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:72: in split
    return [str(stmt).strip() for stmt in stack.run(sql, encoding)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad3c00d0>
sql = '\n    CREATE OR REPLACE FUNCTION testfunc1(integer) RETURNS integer AS $$\n          ....\n    $$ LANGUAGE plpgsql;\n    CREATE OR REPLACE FUNCTION testfunc2(integer) RETURNS integer AS $$\n          ....\n    $$ LANGUAGE plpgsql;'
encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
            stream = filter_.process(stream)

        stream = StatementSplitter().process(stream)

        # Group and ungroup tokens
        if self._grouping:
            stream = grouping.group(stream)

        # Process statements
        ret = []
>       for stmt in stream:
E       TypeError: 'NoneType' object is not iterable

sqlparse/engine/filter_stack.py:34: TypeError
</pre>
</details>
<h3 id="test_parsepytest_double_precision_is_builtin">test_parse.py::test_double_precision_is_builtin</h3>
<details><summary> <pre>test_parse.py::test_double_precision_is_builtin</pre></summary><pre>
def test_double_precision_is_builtin():
        s = 'DOUBLE PRECISION'
>       t = sqlparse.parse(s)[0].tokens

tests/test_parse.py:199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_placeholder">test_parse.py::test_placeholder[?]</h3>
<details><summary> <pre>test_parse.py::test_placeholder[?]</pre></summary><pre>
ph = '?'

    @pytest.mark.parametrize('ph', ['?', ':1', ':foo', '%s', '%(foo)s'])
    def test_placeholder(ph):
>       p = sqlparse.parse(ph)[0].tokens

tests/test_parse.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_placeholder1">test_parse.py::test_placeholder[:1]</h3>
<details><summary> <pre>test_parse.py::test_placeholder[:1]</pre></summary><pre>
ph = ':1'

    @pytest.mark.parametrize('ph', ['?', ':1', ':foo', '%s', '%(foo)s'])
    def test_placeholder(ph):
>       p = sqlparse.parse(ph)[0].tokens

tests/test_parse.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_placeholderfoo">test_parse.py::test_placeholder[:foo]</h3>
<details><summary> <pre>test_parse.py::test_placeholder[:foo]</pre></summary><pre>
ph = ':foo'

    @pytest.mark.parametrize('ph', ['?', ':1', ':foo', '%s', '%(foo)s'])
    def test_placeholder(ph):
>       p = sqlparse.parse(ph)[0].tokens

tests/test_parse.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_placeholders">test_parse.py::test_placeholder[%s]</h3>
<details><summary> <pre>test_parse.py::test_placeholder[%s]</pre></summary><pre>
ph = '%s'

    @pytest.mark.parametrize('ph', ['?', ':1', ':foo', '%s', '%(foo)s'])
    def test_placeholder(ph):
>       p = sqlparse.parse(ph)[0].tokens

tests/test_parse.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_placeholderfoos">test_parse.py::test_placeholder[%(foo)s]</h3>
<details><summary> <pre>test_parse.py::test_placeholder[%(foo)s]</pre></summary><pre>
ph = '%(foo)s'

    @pytest.mark.parametrize('ph', ['?', ':1', ':foo', '%s', '%(foo)s'])
    def test_placeholder(ph):
>       p = sqlparse.parse(ph)[0].tokens

tests/test_parse.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_scientific_numbers667428e-8-expected0">test_parse.py::test_scientific_numbers[6.67428E-8-expected0]</h3>
<details><summary> <pre>test_parse.py::test_scientific_numbers[6.67428E-8-expected0]</pre></summary><pre>
num = '6.67428E-8', expected = Token.Literal.Number.Float

    @pytest.mark.parametrize('num, expected', [
        ('6.67428E-8', T.Number.Float),
        ('1.988e33', T.Number.Float),
        ('1e-12', T.Number.Float),
        ('e1', None),
    ])
    def test_scientific_numbers(num, expected):
>       p = sqlparse.parse(num)[0].tokens

tests/test_parse.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_scientific_numbers1988e33-expected1">test_parse.py::test_scientific_numbers[1.988e33-expected1]</h3>
<details><summary> <pre>test_parse.py::test_scientific_numbers[1.988e33-expected1]</pre></summary><pre>
num = '1.988e33', expected = Token.Literal.Number.Float

    @pytest.mark.parametrize('num, expected', [
        ('6.67428E-8', T.Number.Float),
        ('1.988e33', T.Number.Float),
        ('1e-12', T.Number.Float),
        ('e1', None),
    ])
    def test_scientific_numbers(num, expected):
>       p = sqlparse.parse(num)[0].tokens

tests/test_parse.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_scientific_numbers1e-12-expected2">test_parse.py::test_scientific_numbers[1e-12-expected2]</h3>
<details><summary> <pre>test_parse.py::test_scientific_numbers[1e-12-expected2]</pre></summary><pre>
num = '1e-12', expected = Token.Literal.Number.Float

    @pytest.mark.parametrize('num, expected', [
        ('6.67428E-8', T.Number.Float),
        ('1.988e33', T.Number.Float),
        ('1e-12', T.Number.Float),
        ('e1', None),
    ])
    def test_scientific_numbers(num, expected):
>       p = sqlparse.parse(num)[0].tokens

tests/test_parse.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_scientific_numberse1-none">test_parse.py::test_scientific_numbers[e1-None]</h3>
<details><summary> <pre>test_parse.py::test_scientific_numbers[e1-None]</pre></summary><pre>
num = 'e1', expected = None

    @pytest.mark.parametrize('num, expected', [
        ('6.67428E-8', T.Number.Float),
        ('1.988e33', T.Number.Float),
        ('1e-12', T.Number.Float),
        ('e1', None),
    ])
    def test_scientific_numbers(num, expected):
>       p = sqlparse.parse(num)[0].tokens

tests/test_parse.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_single_quotes_are_strings">test_parse.py::test_single_quotes_are_strings</h3>
<details><summary> <pre>test_parse.py::test_single_quotes_are_strings</pre></summary><pre>
def test_single_quotes_are_strings():
>       p = sqlparse.parse("'foo'")[0].tokens

tests/test_parse.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_double_quotes_are_identifiers">test_parse.py::test_double_quotes_are_identifiers</h3>
<details><summary> <pre>test_parse.py::test_double_quotes_are_identifiers</pre></summary><pre>
def test_double_quotes_are_identifiers():
>       p = sqlparse.parse('"foo"')[0].tokens

tests/test_parse.py:231: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_single_quotes_with_linebreaks">test_parse.py::test_single_quotes_with_linebreaks</h3>
<details><summary> <pre>test_parse.py::test_single_quotes_with_linebreaks</pre></summary><pre>
def test_single_quotes_with_linebreaks():
        # issue118
>       p = sqlparse.parse("'f\nf'")[0].tokens

tests/test_parse.py:238: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_sqlite_identifiers">test_parse.py::test_sqlite_identifiers</h3>
<details><summary> <pre>test_parse.py::test_sqlite_identifiers</pre></summary><pre>
def test_sqlite_identifiers():
        # Make sure we still parse sqlite style escapes
>       p = sqlparse.parse('[col1],[col2]')[0].tokens

tests/test_parse.py:245: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_simple_1d_array_index">test_parse.py::test_simple_1d_array_index</h3>
<details><summary> <pre>test_parse.py::test_simple_1d_array_index</pre></summary><pre>
def test_simple_1d_array_index():
>       p = sqlparse.parse('col[1]')[0].tokens

tests/test_parse.py:257: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_2d_array_index">test_parse.py::test_2d_array_index</h3>
<details><summary> <pre>test_parse.py::test_2d_array_index</pre></summary><pre>
def test_2d_array_index():
>       p = sqlparse.parse('col[x][(y+1)*2]')[0].tokens

tests/test_parse.py:267: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_array_index_function_result">test_parse.py::test_array_index_function_result</h3>
<details><summary> <pre>test_parse.py::test_array_index_function_result</pre></summary><pre>
def test_array_index_function_result():
>       p = sqlparse.parse('somefunc()[1]')[0].tokens

tests/test_parse.py:274: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_schema_qualified_array_index">test_parse.py::test_schema_qualified_array_index</h3>
<details><summary> <pre>test_parse.py::test_schema_qualified_array_index</pre></summary><pre>
def test_schema_qualified_array_index():
>       p = sqlparse.parse('schem.col[1]')[0].tokens

tests/test_parse.py:280: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_aliased_array_index">test_parse.py::test_aliased_array_index</h3>
<details><summary> <pre>test_parse.py::test_aliased_array_index</pre></summary><pre>
def test_aliased_array_index():
>       p = sqlparse.parse('col[1] x')[0].tokens

tests/test_parse.py:288: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_array_literal">test_parse.py::test_array_literal</h3>
<details><summary> <pre>test_parse.py::test_array_literal</pre></summary><pre>
def test_array_literal():
        # See issue #176
>       p = sqlparse.parse('ARRAY[%s, %s]')[0]

tests/test_parse.py:297: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_typed_array_definition">test_parse.py::test_typed_array_definition</h3>
<details><summary> <pre>test_parse.py::test_typed_array_definition</pre></summary><pre>
def test_typed_array_definition():
        # array indices aren't grouped with built-ins, but make sure we can extract
        # identifier names
>       p = sqlparse.parse('x int, y int[], z int')[0]

tests/test_parse.py:305: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_single_line_commentsselect-1-foo">test_parse.py::test_single_line_comments[select 1 -- foo]</h3>
<details><summary> <pre>test_parse.py::test_single_line_comments[select 1 -- foo]</pre></summary><pre>
s = 'select 1 -- foo'

    @pytest.mark.parametrize('s', ['select 1 -- foo', 'select 1 # foo'])
    def test_single_line_comments(s):
        # see issue178
>       p = sqlparse.parse(s)[0]

tests/test_parse.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_single_line_commentsselect-1-foo_1">test_parse.py::test_single_line_comments[select 1 # foo]</h3>
<details><summary> <pre>test_parse.py::test_single_line_comments[select 1 # foo]</pre></summary><pre>
s = 'select 1 # foo'

    @pytest.mark.parametrize('s', ['select 1 -- foo', 'select 1 # foo'])
    def test_single_line_comments(s):
        # see issue178
>       p = sqlparse.parse(s)[0]

tests/test_parse.py:314: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_names_and_special_namesfoo">test_parse.py::test_names_and_special_names[foo]</h3>
<details><summary> <pre>test_parse.py::test_names_and_special_names[foo]</pre></summary><pre>
s = 'foo'

    @pytest.mark.parametrize('s', ['foo', '@foo', '#foo', '##foo'])
    def test_names_and_special_names(s):
        # see issue192
>       p = sqlparse.parse(s)[0]

tests/test_parse.py:322: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_names_and_special_namesfoo_1">test_parse.py::test_names_and_special_names[@foo]</h3>
<details><summary> <pre>test_parse.py::test_names_and_special_names[@foo]</pre></summary><pre>
s = '@foo'

    @pytest.mark.parametrize('s', ['foo', '@foo', '#foo', '##foo'])
    def test_names_and_special_names(s):
        # see issue192
>       p = sqlparse.parse(s)[0]

tests/test_parse.py:322: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_names_and_special_namesfoo_2">test_parse.py::test_names_and_special_names[#foo]</h3>
<details><summary> <pre>test_parse.py::test_names_and_special_names[#foo]</pre></summary><pre>
s = '#foo'

    @pytest.mark.parametrize('s', ['foo', '@foo', '#foo', '##foo'])
    def test_names_and_special_names(s):
        # see issue192
>       p = sqlparse.parse(s)[0]

tests/test_parse.py:322: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_names_and_special_namesfoo_3">test_parse.py::test_names_and_special_names[##foo]</h3>
<details><summary> <pre>test_parse.py::test_names_and_special_names[##foo]</pre></summary><pre>
s = '##foo'

    @pytest.mark.parametrize('s', ['foo', '@foo', '#foo', '##foo'])
    def test_names_and_special_names(s):
        # see issue192
>       p = sqlparse.parse(s)[0]

tests/test_parse.py:322: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_get_token_at_offset">test_parse.py::test_get_token_at_offset</h3>
<details><summary> <pre>test_parse.py::test_get_token_at_offset</pre></summary><pre>
def test_get_token_at_offset():
>       p = sqlparse.parse('select * from dual')[0]

tests/test_parse.py:328: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_pprint">test_parse.py::test_pprint</h3>
<details><summary> <pre>test_parse.py::test_pprint</pre></summary><pre>
def test_pprint():
>       p = sqlparse.parse('select a0, b0, c0, d0, e0 from '
                           '(select * from dual) q0 where 1=1 and 2=2')[0]

tests/test_parse.py:340: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_wildcard_multiplication">test_parse.py::test_wildcard_multiplication</h3>
<details><summary> <pre>test_parse.py::test_wildcard_multiplication</pre></summary><pre>
def test_wildcard_multiplication():
>       p = sqlparse.parse('select * from dual')[0]

tests/test_parse.py:405: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_stmt_tokens_parents">test_parse.py::test_stmt_tokens_parents</h3>
<details><summary> <pre>test_parse.py::test_stmt_tokens_parents</pre></summary><pre>
def test_stmt_tokens_parents():
        # see issue 226
        s = "CREATE TABLE test();"
>       stmt = sqlparse.parse(s)[0]

tests/test_parse.py:418: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_dbldollar_as_literalfoo-true">test_parse.py::test_dbldollar_as_literal[$$foo$$-True]</h3>
<details><summary> <pre>test_parse.py::test_dbldollar_as_literal[$$foo$$-True]</pre></summary><pre>
sql = '$$foo$$', is_literal = True

    @pytest.mark.parametrize('sql, is_literal', [
        ('$$foo$$', True),
        ('$_$foo$_$', True),
        ('$token$ foo $token$', True),
        # don't parse inner tokens
        ('$_$ foo $token$bar$token$ baz$_$', True),
        ('$A$ foo $B$', False)  # tokens don't match
    ])
    def test_dbldollar_as_literal(sql, is_literal):
        # see issue 277
>       p = sqlparse.parse(sql)[0]

tests/test_parse.py:433: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_dbldollar_as_literalfoo-true_1">test_parse.py::test_dbldollar_as_literal[$<em>$foo$</em>$-True]</h3>
<details><summary> <pre>test_parse.py::test_dbldollar_as_literal[$_$foo$_$-True]</pre></summary><pre>
sql = '$_$foo$_$', is_literal = True

    @pytest.mark.parametrize('sql, is_literal', [
        ('$$foo$$', True),
        ('$_$foo$_$', True),
        ('$token$ foo $token$', True),
        # don't parse inner tokens
        ('$_$ foo $token$bar$token$ baz$_$', True),
        ('$A$ foo $B$', False)  # tokens don't match
    ])
    def test_dbldollar_as_literal(sql, is_literal):
        # see issue 277
>       p = sqlparse.parse(sql)[0]

tests/test_parse.py:433: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_dbldollar_as_literaltoken-foo-token-true">test_parse.py::test_dbldollar_as_literal[$token$ foo $token$-True]</h3>
<details><summary> <pre>test_parse.py::test_dbldollar_as_literal[$token$ foo $token$-True]</pre></summary><pre>
sql = '$token$ foo $token$', is_literal = True

    @pytest.mark.parametrize('sql, is_literal', [
        ('$$foo$$', True),
        ('$_$foo$_$', True),
        ('$token$ foo $token$', True),
        # don't parse inner tokens
        ('$_$ foo $token$bar$token$ baz$_$', True),
        ('$A$ foo $B$', False)  # tokens don't match
    ])
    def test_dbldollar_as_literal(sql, is_literal):
        # see issue 277
>       p = sqlparse.parse(sql)[0]

tests/test_parse.py:433: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_dbldollar_as_literal-foo-tokenbartoken-baz-true">test_parse.py::test_dbldollar_as_literal[$<em>$ foo $token$bar$token$ baz$</em>$-True]</h3>
<details><summary> <pre>test_parse.py::test_dbldollar_as_literal[$_$ foo $token$bar$token$ baz$_$-True]</pre></summary><pre>
sql = '$_$ foo $token$bar$token$ baz$_$', is_literal = True

    @pytest.mark.parametrize('sql, is_literal', [
        ('$$foo$$', True),
        ('$_$foo$_$', True),
        ('$token$ foo $token$', True),
        # don't parse inner tokens
        ('$_$ foo $token$bar$token$ baz$_$', True),
        ('$A$ foo $B$', False)  # tokens don't match
    ])
    def test_dbldollar_as_literal(sql, is_literal):
        # see issue 277
>       p = sqlparse.parse(sql)[0]

tests/test_parse.py:433: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_dbldollar_as_literala-foo-b-false">test_parse.py::test_dbldollar_as_literal[$A$ foo $B$-False]</h3>
<details><summary> <pre>test_parse.py::test_dbldollar_as_literal[$A$ foo $B$-False]</pre></summary><pre>
sql = '$A$ foo $B$', is_literal = False

    @pytest.mark.parametrize('sql, is_literal', [
        ('$$foo$$', True),
        ('$_$foo$_$', True),
        ('$token$ foo $token$', True),
        # don't parse inner tokens
        ('$_$ foo $token$bar$token$ baz$_$', True),
        ('$A$ foo $B$', False)  # tokens don't match
    ])
    def test_dbldollar_as_literal(sql, is_literal):
        # see issue 277
>       p = sqlparse.parse(sql)[0]

tests/test_parse.py:433: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_non_ascii">test_parse.py::test_non_ascii</h3>
<details><summary> <pre>test_parse.py::test_non_ascii</pre></summary><pre>
def test_non_ascii():
        _test_non_ascii = "insert into test (id, name) values (1, 'тест');"

        s = _test_non_ascii
>       stmts = sqlparse.parse(s)

tests/test_parse.py:446: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_get_real_name">test_parse.py::test_get_real_name</h3>
<details><summary> <pre>test_parse.py::test_get_real_name</pre></summary><pre>
def test_get_real_name():
        # issue 369
        s = "update a t set t.b=1"
>       stmts = sqlparse.parse(s)

tests/test_parse.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_from_subquery">test_parse.py::test_from_subquery</h3>
<details><summary> <pre>test_parse.py::test_from_subquery</pre></summary><pre>
def test_from_subquery():
        # issue 446
        s = 'from(select 1)'
>       stmts = sqlparse.parse(s)

tests/test_parse.py:472: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parenthesis">test_parse.py::test_parenthesis</h3>
<details><summary> <pre>test_parse.py::test_parenthesis</pre></summary><pre>
def test_parenthesis():
>       tokens = sqlparse.parse("(\n\n1\n\n)")[0].tokens[0].tokens

tests/test_parse.py:488: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_configurable_keywords">test_parse.py::test_configurable_keywords</h3>
<details><summary> <pre>test_parse.py::test_configurable_keywords</pre></summary><pre>
def test_configurable_keywords():
        sql = """select * from foo BACON SPAM EGGS;"""
>       tokens = sqlparse.parse(sql)[0]

tests/test_parse.py:510: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_configurable_regex">test_parse.py::test_configurable_regex</h3>
<details><summary> <pre>test_parse.py::test_configurable_regex</pre></summary><pre>
def test_configurable_regex():
        lex = Lexer.get_default_instance()
        lex.clear()

        my_regex = (r"ZORDER\s+BY\b", sqlparse.tokens.Keyword)

        lex.set_SQL_REGEX(
            keywords.SQL_REGEX[:38]
            + [my_regex]
            + keywords.SQL_REGEX[38:]
        )
        lex.add_keywords(keywords.KEYWORDS_COMMON)
        lex.add_keywords(keywords.KEYWORDS_ORACLE)
        lex.add_keywords(keywords.KEYWORDS_PLPGSQL)
        lex.add_keywords(keywords.KEYWORDS_HQL)
        lex.add_keywords(keywords.KEYWORDS_MSACCESS)
        lex.add_keywords(keywords.KEYWORDS)

>       tokens = sqlparse.parse("select * from foo zorder by bar;")[0]

tests/test_parse.py:572: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_json_operators-">test_parse.py::test_json_operators[-&gt;]</h3>
<details><summary> <pre>test_parse.py::test_json_operators[->]</pre></summary><pre>
sql = '->'

    @pytest.mark.parametrize('sql', [
        '->', '->>', '#>', '#>>',
        '@>', '<@',
        # leaving ? out for now, they're somehow ambiguous as placeholders
        # '?', '?|', '?&',
        '||', '-', '#-'
    ])
    def test_json_operators(sql):
>       p = sqlparse.parse(sql)

tests/test_parse.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_json_operators-_1">test_parse.py::test_json_operators[-&gt;&gt;]</h3>
<details><summary> <pre>test_parse.py::test_json_operators[->>]</pre></summary><pre>
sql = '->>'

    @pytest.mark.parametrize('sql', [
        '->', '->>', '#>', '#>>',
        '@>', '<@',
        # leaving ? out for now, they're somehow ambiguous as placeholders
        # '?', '?|', '?&',
        '||', '-', '#-'
    ])
    def test_json_operators(sql):
>       p = sqlparse.parse(sql)

tests/test_parse.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_json_operators">test_parse.py::test_json_operators[#&gt;]</h3>
<details><summary> <pre>test_parse.py::test_json_operators[#>]</pre></summary><pre>
sql = '#>'

    @pytest.mark.parametrize('sql', [
        '->', '->>', '#>', '#>>',
        '@>', '<@',
        # leaving ? out for now, they're somehow ambiguous as placeholders
        # '?', '?|', '?&',
        '||', '-', '#-'
    ])
    def test_json_operators(sql):
>       p = sqlparse.parse(sql)

tests/test_parse.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_json_operators_1">test_parse.py::test_json_operators[#&gt;&gt;]</h3>
<details><summary> <pre>test_parse.py::test_json_operators[#>>]</pre></summary><pre>
sql = '#>>'

    @pytest.mark.parametrize('sql', [
        '->', '->>', '#>', '#>>',
        '@>', '<@',
        # leaving ? out for now, they're somehow ambiguous as placeholders
        # '?', '?|', '?&',
        '||', '-', '#-'
    ])
    def test_json_operators(sql):
>       p = sqlparse.parse(sql)

tests/test_parse.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_json_operators_2">test_parse.py::test_json_operators[@&gt;]</h3>
<details><summary> <pre>test_parse.py::test_json_operators[@>]</pre></summary><pre>
sql = '@>'

    @pytest.mark.parametrize('sql', [
        '->', '->>', '#>', '#>>',
        '@>', '<@',
        # leaving ? out for now, they're somehow ambiguous as placeholders
        # '?', '?|', '?&',
        '||', '-', '#-'
    ])
    def test_json_operators(sql):
>       p = sqlparse.parse(sql)

tests/test_parse.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_json_operators_3">test_parse.py::test_json_operators[&lt;@]</h3>
<details><summary> <pre>test_parse.py::test_json_operators[<@]</pre></summary><pre>
sql = '<@'

    @pytest.mark.parametrize('sql', [
        '->', '->>', '#>', '#>>',
        '@>', '<@',
        # leaving ? out for now, they're somehow ambiguous as placeholders
        # '?', '?|', '?&',
        '||', '-', '#-'
    ])
    def test_json_operators(sql):
>       p = sqlparse.parse(sql)

tests/test_parse.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_json_operators_4">test_parse.py::test_json_operators[||]</h3>
<details><summary> <pre>test_parse.py::test_json_operators[||]</pre></summary><pre>
sql = '||'

    @pytest.mark.parametrize('sql', [
        '->', '->>', '#>', '#>>',
        '@>', '<@',
        # leaving ? out for now, they're somehow ambiguous as placeholders
        # '?', '?|', '?&',
        '||', '-', '#-'
    ])
    def test_json_operators(sql):
>       p = sqlparse.parse(sql)

tests/test_parse.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_json_operators-_2">test_parse.py::test_json_operators[-]</h3>
<details><summary> <pre>test_parse.py::test_json_operators[-]</pre></summary><pre>
sql = '-'

    @pytest.mark.parametrize('sql', [
        '->', '->>', '#>', '#>>',
        '@>', '<@',
        # leaving ? out for now, they're somehow ambiguous as placeholders
        # '?', '?|', '?&',
        '||', '-', '#-'
    ])
    def test_json_operators(sql):
>       p = sqlparse.parse(sql)

tests/test_parse.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_json_operators-_3">test_parse.py::test_json_operators[#-]</h3>
<details><summary> <pre>test_parse.py::test_json_operators[#-]</pre></summary><pre>
sql = '#-'

    @pytest.mark.parametrize('sql', [
        '->', '->>', '#>', '#>>',
        '@>', '<@',
        # leaving ? out for now, they're somehow ambiguous as placeholders
        # '?', '?|', '?&',
        '||', '-', '#-'
    ])
    def test_json_operators(sql):
>       p = sqlparse.parse(sql)

tests/test_parse.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue9">test_regressions.py::test_issue9</h3>
<details><summary> <pre>test_regressions.py::test_issue9</pre></summary><pre>
def test_issue9():
        # make sure where doesn't consume parenthesis
>       p = sqlparse.parse('(where 1)')[0]

tests/test_regressions.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue13">test_regressions.py::test_issue13</h3>
<details><summary> <pre>test_regressions.py::test_issue13</pre></summary><pre>
def test_issue13():
>       parsed = sqlparse.parse("select 'one';\n"
                                "select 'two\\'';\n"
                                "select 'three';")

tests/test_regressions.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue26-hello">test_regressions.py::test_issue26[--hello]</h3>
<details><summary> <pre>test_regressions.py::test_issue26[--hello]</pre></summary><pre>
s = '--hello'

    @pytest.mark.parametrize('s', ['--hello', '-- hello', '--hello\n',
                                   '--', '--\n'])
    def test_issue26(s):
        # parse stand-alone comments
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:35: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue26-hello_1">test_regressions.py::test_issue26[-- hello]</h3>
<details><summary> <pre>test_regressions.py::test_issue26[-- hello]</pre></summary><pre>
s = '-- hello'

    @pytest.mark.parametrize('s', ['--hello', '-- hello', '--hello\n',
                                   '--', '--\n'])
    def test_issue26(s):
        # parse stand-alone comments
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:35: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue26-hellon">test_regressions.py::test_issue26[--hello\n]</h3>
<details><summary> <pre>test_regressions.py::test_issue26[--hello\n]</pre></summary><pre>
s = '--hello\n'

    @pytest.mark.parametrize('s', ['--hello', '-- hello', '--hello\n',
                                   '--', '--\n'])
    def test_issue26(s):
        # parse stand-alone comments
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:35: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue26-">test_regressions.py::test_issue26[--]</h3>
<details><summary> <pre>test_regressions.py::test_issue26[--]</pre></summary><pre>
s = '--'

    @pytest.mark.parametrize('s', ['--hello', '-- hello', '--hello\n',
                                   '--', '--\n'])
    def test_issue26(s):
        # parse stand-alone comments
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:35: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue26-n">test_regressions.py::test_issue26[--\n]</h3>
<details><summary> <pre>test_regressions.py::test_issue26[--\n]</pre></summary><pre>
s = '--\n'

    @pytest.mark.parametrize('s', ['--hello', '-- hello', '--hello\n',
                                   '--', '--\n'])
    def test_issue26(s):
        # parse stand-alone comments
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:35: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue34create">test_regressions.py::test_issue34[create]</h3>
<details><summary> <pre>test_regressions.py::test_issue34[create]</pre></summary><pre>
value = 'create'

    @pytest.mark.parametrize('value', ['create', 'CREATE'])
    def test_issue34(value):
>       t = sqlparse.parse("create")[0].token_first()

tests/test_regressions.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue34create_1">test_regressions.py::test_issue34[CREATE]</h3>
<details><summary> <pre>test_regressions.py::test_issue34[CREATE]</pre></summary><pre>
value = 'CREATE'

    @pytest.mark.parametrize('value', ['create', 'CREATE'])
    def test_issue34(value):
>       t = sqlparse.parse("create")[0].token_first()

tests/test_regressions.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue35">test_regressions.py::test_issue35</h3>
<details><summary> <pre>test_regressions.py::test_issue35</pre></summary><pre>
def test_issue35():
        # missing space before LIMIT. Updated for #321
>       sql = sqlparse.format("select * from foo where bar = 1 limit 1",
                              reindent=True)

tests/test_regressions.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue38">test_regressions.py::test_issue38</h3>
<details><summary> <pre>test_regressions.py::test_issue38</pre></summary><pre>
def test_issue38():
>       sql = sqlparse.format("SELECT foo; -- comment", strip_comments=True)

tests/test_regressions.py:58: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad50cd60>
sql = 'SELECT foo; -- comment', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
>           stream = filter_.process(stream)
E           AttributeError: 'StripCommentsFilter' object has no attribute 'process'

sqlparse/engine/filter_stack.py:24: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue39">test_regressions.py::test_issue39</h3>
<details><summary> <pre>test_regressions.py::test_issue39</pre></summary><pre>
def test_issue39():
>       p = sqlparse.parse('select user.id from user')[0]

tests/test_regressions.py:65: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue40">test_regressions.py::test_issue40</h3>
<details><summary> <pre>test_regressions.py::test_issue40</pre></summary><pre>
def test_issue40():
        # make sure identifier lists in subselects are grouped
>       p = sqlparse.parse('SELECT id, name FROM '
                           '(SELECT id, name FROM bar) as foo')[0]

tests/test_regressions.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_name-z-select-xytext-as-z-from-foo">test_regressions.py::test_issue78[get_name-z-select x.y::text as z from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_name-z-select x.y::text as z from foo]</pre></summary><pre>
s = 'select x.y::text as z from foo', func_name = 'get_name', result = 'z'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_name-z-select-xytext-as-z-from-foo_1">test_regressions.py::test_issue78[get_name-z-select x.y::text as "z" from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_name-z-select x.y::text as "z" from foo]</pre></summary><pre>
s = 'select x.y::text as "z" from foo', func_name = 'get_name', result = 'z'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_name-z-select-xytext-as-z-from-foo_2">test_regressions.py::test_issue78[get_name-z-select x."y"::text as z from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_name-z-select x."y"::text as z from foo]</pre></summary><pre>
s = 'select x."y"::text as z from foo', func_name = 'get_name', result = 'z'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_name-z-select-xytext-as-z-from-foo_3">test_regressions.py::test_issue78[get_name-z-select x."y"::text as "z" from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_name-z-select x."y"::text as "z" from foo]</pre></summary><pre>
s = 'select x."y"::text as "z" from foo', func_name = 'get_name', result = 'z'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_name-z-select-xytext-as-z-from-foo_4">test_regressions.py::test_issue78[get_name-z-select "x".y::text as z from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_name-z-select "x".y::text as z from foo]</pre></summary><pre>
s = 'select "x".y::text as z from foo', func_name = 'get_name', result = 'z'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_name-z-select-xytext-as-z-from-foo_5">test_regressions.py::test_issue78[get_name-z-select "x".y::text as "z" from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_name-z-select "x".y::text as "z" from foo]</pre></summary><pre>
s = 'select "x".y::text as "z" from foo', func_name = 'get_name', result = 'z'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_name-z-select-xytext-as-z-from-foo_6">test_regressions.py::test_issue78[get_name-z-select "x"."y"::text as z from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_name-z-select "x"."y"::text as z from foo]</pre></summary><pre>
s = 'select "x"."y"::text as z from foo', func_name = 'get_name', result = 'z'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_name-z-select-xytext-as-z-from-foo_7">test_regressions.py::test_issue78[get_name-z-select "x"."y"::text as "z" from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_name-z-select "x"."y"::text as "z" from foo]</pre></summary><pre>
s = 'select "x"."y"::text as "z" from foo', func_name = 'get_name', result = 'z'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_real_name-y-select-xytext-as-z-from-foo">test_regressions.py::test_issue78[get_real_name-y-select x.y::text as z from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_real_name-y-select x.y::text as z from foo]</pre></summary><pre>
s = 'select x.y::text as z from foo', func_name = 'get_real_name', result = 'y'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_real_name-y-select-xytext-as-z-from-foo_1">test_regressions.py::test_issue78[get_real_name-y-select x.y::text as "z" from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_real_name-y-select x.y::text as "z" from foo]</pre></summary><pre>
s = 'select x.y::text as "z" from foo', func_name = 'get_real_name'
result = 'y'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_real_name-y-select-xytext-as-z-from-foo_2">test_regressions.py::test_issue78[get_real_name-y-select x."y"::text as z from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_real_name-y-select x."y"::text as z from foo]</pre></summary><pre>
s = 'select x."y"::text as z from foo', func_name = 'get_real_name'
result = 'y'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_real_name-y-select-xytext-as-z-from-foo_3">test_regressions.py::test_issue78[get_real_name-y-select x."y"::text as "z" from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_real_name-y-select x."y"::text as "z" from foo]</pre></summary><pre>
s = 'select x."y"::text as "z" from foo', func_name = 'get_real_name'
result = 'y'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_real_name-y-select-xytext-as-z-from-foo_4">test_regressions.py::test_issue78[get_real_name-y-select "x".y::text as z from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_real_name-y-select "x".y::text as z from foo]</pre></summary><pre>
s = 'select "x".y::text as z from foo', func_name = 'get_real_name'
result = 'y'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_real_name-y-select-xytext-as-z-from-foo_5">test_regressions.py::test_issue78[get_real_name-y-select "x".y::text as "z" from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_real_name-y-select "x".y::text as "z" from foo]</pre></summary><pre>
s = 'select "x".y::text as "z" from foo', func_name = 'get_real_name'
result = 'y'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_real_name-y-select-xytext-as-z-from-foo_6">test_regressions.py::test_issue78[get_real_name-y-select "x"."y"::text as z from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_real_name-y-select "x"."y"::text as z from foo]</pre></summary><pre>
s = 'select "x"."y"::text as z from foo', func_name = 'get_real_name'
result = 'y'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_real_name-y-select-xytext-as-z-from-foo_7">test_regressions.py::test_issue78[get_real_name-y-select "x"."y"::text as "z" from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_real_name-y-select "x"."y"::text as "z" from foo]</pre></summary><pre>
s = 'select "x"."y"::text as "z" from foo', func_name = 'get_real_name'
result = 'y'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_parent_name-x-select-xytext-as-z-from-foo">test_regressions.py::test_issue78[get_parent_name-x-select x.y::text as z from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_parent_name-x-select x.y::text as z from foo]</pre></summary><pre>
s = 'select x.y::text as z from foo', func_name = 'get_parent_name'
result = 'x'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_parent_name-x-select-xytext-as-z-from-foo_1">test_regressions.py::test_issue78[get_parent_name-x-select x.y::text as "z" from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_parent_name-x-select x.y::text as "z" from foo]</pre></summary><pre>
s = 'select x.y::text as "z" from foo', func_name = 'get_parent_name'
result = 'x'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_parent_name-x-select-xytext-as-z-from-foo_2">test_regressions.py::test_issue78[get_parent_name-x-select x."y"::text as z from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_parent_name-x-select x."y"::text as z from foo]</pre></summary><pre>
s = 'select x."y"::text as z from foo', func_name = 'get_parent_name'
result = 'x'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_parent_name-x-select-xytext-as-z-from-foo_3">test_regressions.py::test_issue78[get_parent_name-x-select x."y"::text as "z" from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_parent_name-x-select x."y"::text as "z" from foo]</pre></summary><pre>
s = 'select x."y"::text as "z" from foo', func_name = 'get_parent_name'
result = 'x'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_parent_name-x-select-xytext-as-z-from-foo_4">test_regressions.py::test_issue78[get_parent_name-x-select "x".y::text as z from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_parent_name-x-select "x".y::text as z from foo]</pre></summary><pre>
s = 'select "x".y::text as z from foo', func_name = 'get_parent_name'
result = 'x'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_parent_name-x-select-xytext-as-z-from-foo_5">test_regressions.py::test_issue78[get_parent_name-x-select "x".y::text as "z" from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_parent_name-x-select "x".y::text as "z" from foo]</pre></summary><pre>
s = 'select "x".y::text as "z" from foo', func_name = 'get_parent_name'
result = 'x'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_parent_name-x-select-xytext-as-z-from-foo_6">test_regressions.py::test_issue78[get_parent_name-x-select "x"."y"::text as z from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_parent_name-x-select "x"."y"::text as z from foo]</pre></summary><pre>
s = 'select "x"."y"::text as z from foo', func_name = 'get_parent_name'
result = 'x'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_parent_name-x-select-xytext-as-z-from-foo_7">test_regressions.py::test_issue78[get_parent_name-x-select "x"."y"::text as "z" from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_parent_name-x-select "x"."y"::text as "z" from foo]</pre></summary><pre>
s = 'select "x"."y"::text as "z" from foo', func_name = 'get_parent_name'
result = 'x'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_alias-z-select-xytext-as-z-from-foo">test_regressions.py::test_issue78[get_alias-z-select x.y::text as z from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_alias-z-select x.y::text as z from foo]</pre></summary><pre>
s = 'select x.y::text as z from foo', func_name = 'get_alias', result = 'z'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_alias-z-select-xytext-as-z-from-foo_1">test_regressions.py::test_issue78[get_alias-z-select x.y::text as "z" from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_alias-z-select x.y::text as "z" from foo]</pre></summary><pre>
s = 'select x.y::text as "z" from foo', func_name = 'get_alias', result = 'z'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_alias-z-select-xytext-as-z-from-foo_2">test_regressions.py::test_issue78[get_alias-z-select x."y"::text as z from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_alias-z-select x."y"::text as z from foo]</pre></summary><pre>
s = 'select x."y"::text as z from foo', func_name = 'get_alias', result = 'z'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_alias-z-select-xytext-as-z-from-foo_3">test_regressions.py::test_issue78[get_alias-z-select x."y"::text as "z" from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_alias-z-select x."y"::text as "z" from foo]</pre></summary><pre>
s = 'select x."y"::text as "z" from foo', func_name = 'get_alias', result = 'z'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_alias-z-select-xytext-as-z-from-foo_4">test_regressions.py::test_issue78[get_alias-z-select "x".y::text as z from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_alias-z-select "x".y::text as z from foo]</pre></summary><pre>
s = 'select "x".y::text as z from foo', func_name = 'get_alias', result = 'z'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_alias-z-select-xytext-as-z-from-foo_5">test_regressions.py::test_issue78[get_alias-z-select "x".y::text as "z" from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_alias-z-select "x".y::text as "z" from foo]</pre></summary><pre>
s = 'select "x".y::text as "z" from foo', func_name = 'get_alias', result = 'z'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_alias-z-select-xytext-as-z-from-foo_6">test_regressions.py::test_issue78[get_alias-z-select "x"."y"::text as z from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_alias-z-select "x"."y"::text as z from foo]</pre></summary><pre>
s = 'select "x"."y"::text as z from foo', func_name = 'get_alias', result = 'z'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_alias-z-select-xytext-as-z-from-foo_7">test_regressions.py::test_issue78[get_alias-z-select "x"."y"::text as "z" from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_alias-z-select "x"."y"::text as "z" from foo]</pre></summary><pre>
s = 'select "x"."y"::text as "z" from foo', func_name = 'get_alias'
result = 'z'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_typecast-text-select-xytext-as-z-from-foo">test_regressions.py::test_issue78[get_typecast-text-select x.y::text as z from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_typecast-text-select x.y::text as z from foo]</pre></summary><pre>
s = 'select x.y::text as z from foo', func_name = 'get_typecast'
result = 'text'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_typecast-text-select-xytext-as-z-from-foo_1">test_regressions.py::test_issue78[get_typecast-text-select x.y::text as "z" from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_typecast-text-select x.y::text as "z" from foo]</pre></summary><pre>
s = 'select x.y::text as "z" from foo', func_name = 'get_typecast'
result = 'text'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_typecast-text-select-xytext-as-z-from-foo_2">test_regressions.py::test_issue78[get_typecast-text-select x."y"::text as z from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_typecast-text-select x."y"::text as z from foo]</pre></summary><pre>
s = 'select x."y"::text as z from foo', func_name = 'get_typecast'
result = 'text'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_typecast-text-select-xytext-as-z-from-foo_3">test_regressions.py::test_issue78[get_typecast-text-select x."y"::text as "z" from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_typecast-text-select x."y"::text as "z" from foo]</pre></summary><pre>
s = 'select x."y"::text as "z" from foo', func_name = 'get_typecast'
result = 'text'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_typecast-text-select-xytext-as-z-from-foo_4">test_regressions.py::test_issue78[get_typecast-text-select "x".y::text as z from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_typecast-text-select "x".y::text as z from foo]</pre></summary><pre>
s = 'select "x".y::text as z from foo', func_name = 'get_typecast'
result = 'text'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_typecast-text-select-xytext-as-z-from-foo_5">test_regressions.py::test_issue78[get_typecast-text-select "x".y::text as "z" from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_typecast-text-select "x".y::text as "z" from foo]</pre></summary><pre>
s = 'select "x".y::text as "z" from foo', func_name = 'get_typecast'
result = 'text'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_typecast-text-select-xytext-as-z-from-foo_6">test_regressions.py::test_issue78[get_typecast-text-select "x"."y"::text as z from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_typecast-text-select "x"."y"::text as z from foo]</pre></summary><pre>
s = 'select "x"."y"::text as z from foo', func_name = 'get_typecast'
result = 'text'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue78get_typecast-text-select-xytext-as-z-from-foo_7">test_regressions.py::test_issue78[get_typecast-text-select "x"."y"::text as "z" from foo]</h3>
<details><summary> <pre>test_regressions.py::test_issue78[get_typecast-text-select "x"."y"::text as "z" from foo]</pre></summary><pre>
s = 'select "x"."y"::text as "z" from foo', func_name = 'get_typecast'
result = 'text'

    @pytest.mark.parametrize('s', ['select x.y::text as z from foo',
                                   'select x.y::text as "z" from foo',
                                   'select x."y"::text as z from foo',
                                   'select x."y"::text as "z" from foo',
                                   'select "x".y::text as z from foo',
                                   'select "x".y::text as "z" from foo',
                                   'select "x"."y"::text as z from foo',
                                   'select "x"."y"::text as "z" from foo'])
    @pytest.mark.parametrize('func_name, result', [('get_name', 'z'),
                                                   ('get_real_name', 'y'),
                                                   ('get_parent_name', 'x'),
                                                   ('get_alias', 'z'),
                                                   ('get_typecast', 'text')])
    def test_issue78(s, func_name, result):
        # the bug author provided this nice examples, let's use them!
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:120: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue83">test_regressions.py::test_issue83</h3>
<details><summary> <pre>test_regressions.py::test_issue83</pre></summary><pre>
def test_issue83():
        sql = """   CREATE OR REPLACE FUNCTION func_a(text)
                      RETURNS boolean  LANGUAGE plpgsql STRICT IMMUTABLE AS
                    $_$
                    BEGIN
                     ...
                    END;
                    $_$;

                    CREATE OR REPLACE FUNCTION func_b(text)
                      RETURNS boolean  LANGUAGE plpgsql STRICT IMMUTABLE AS
                    $_$
                    BEGIN
                     ...
                    END;
                    $_$;

                    ALTER TABLE..... ;"""
>       t = sqlparse.split(sql)

tests/test_regressions.py:146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:72: in split
    return [str(stmt).strip() for stmt in stack.run(sql, encoding)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad657d00>
sql = '   CREATE OR REPLACE FUNCTION func_a(text)\n                  RETURNS boolean  LANGUAGE plpgsql STRICT IMMUTABLE AS\n...         BEGIN\n                 ...\n                END;\n                $_$;\n\n                ALTER TABLE..... ;'
encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
            stream = filter_.process(stream)

        stream = StatementSplitter().process(stream)

        # Group and ungroup tokens
        if self._grouping:
            stream = grouping.group(stream)

        # Process statements
        ret = []
>       for stmt in stream:
E       TypeError: 'NoneType' object is not iterable

sqlparse/engine/filter_stack.py:34: TypeError
</pre>
</details>
<h3 id="test_regressionspytest_comment_encoding_when_reindent">test_regressions.py::test_comment_encoding_when_reindent</h3>
<details><summary> <pre>test_regressions.py::test_comment_encoding_when_reindent</pre></summary><pre>
def test_comment_encoding_when_reindent():
        # There was an UnicodeEncodeError in the reindent filter that
        # casted every comment followed by a keyword to str.
        sql = 'select foo -- Comment containing Ümläuts\nfrom bar'
>       formatted = sqlparse.format(sql, reindent=True)

tests/test_regressions.py:154: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_parse_sql_with_binary">test_regressions.py::test_parse_sql_with_binary</h3>
<details><summary> <pre>test_regressions.py::test_parse_sql_with_binary</pre></summary><pre>
def test_parse_sql_with_binary():
        # See https://github.com/andialbrecht/sqlparse/pull/88
        # digest = '|ËêplL4¡høN{'
        digest = '\x82|\xcb\x0e\xea\x8aplL4\xa1h\x91\xf8N{'
        sql = "select * from foo where bar = '{}'".format(digest)
>       formatted = sqlparse.format(sql, reindent=True)

tests/test_regressions.py:163: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_dont_alias_keywords">test_regressions.py::test_dont_alias_keywords</h3>
<details><summary> <pre>test_regressions.py::test_dont_alias_keywords</pre></summary><pre>
def test_dont_alias_keywords():
        # The _group_left_right function had a bug where the check for the
        # left side wasn't handled correctly. In one case this resulted in
        # a keyword turning into an identifier.
>       p = sqlparse.parse('FROM AS foo')[0]

tests/test_regressions.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_format_accepts_encoding">test_regressions.py::test_format_accepts_encoding</h3>
<details><summary> <pre>test_regressions.py::test_format_accepts_encoding</pre></summary><pre>
load_file = <function load_file.<locals>.make_load_file at 0x7ef7ad232680>

    def test_format_accepts_encoding(load_file):
        # issue20
        sql = load_file('test_cp1251.sql', 'cp1251')
>       formatted = sqlparse.format(sql, reindent=True, encoding='cp1251')

tests/test_regressions.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_stream">test_regressions.py::test_stream</h3>
<details><summary> <pre>test_regressions.py::test_stream</pre></summary><pre>
get_stream = <function get_stream.<locals>.make_stream at 0x7ef7ad230f70>

    def test_stream(get_stream):
        with get_stream("stream.sql") as stream:
>           p = sqlparse.parse(stream)[0]

tests/test_regressions.py:189: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue90">test_regressions.py::test_issue90</h3>
<details><summary> <pre>test_regressions.py::test_issue90</pre></summary><pre>
def test_issue90():
        sql = ('UPDATE "gallery_photo" SET "owner_id" = 4018, "deleted_at" = NULL,'
               ' "width" = NULL, "height" = NULL, "rating_votes" = 0,'
               ' "rating_score" = 0, "thumbnail_width" = NULL,'
               ' "thumbnail_height" = NULL, "price" = 1, "description" = NULL')
>       formatted = sqlparse.format(sql, reindent=True)

tests/test_regressions.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_except_formatting">test_regressions.py::test_except_formatting</h3>
<details><summary> <pre>test_regressions.py::test_except_formatting</pre></summary><pre>
def test_except_formatting():
        sql = 'SELECT 1 FROM foo WHERE 2 = 3 EXCEPT SELECT 2 FROM bar WHERE 1 = 2'
>       formatted = sqlparse.format(sql, reindent=True)

tests/test_regressions.py:216: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_null_with_as">test_regressions.py::test_null_with_as</h3>
<details><summary> <pre>test_regressions.py::test_null_with_as</pre></summary><pre>
def test_null_with_as():
        sql = 'SELECT NULL AS c1, NULL AS c2 FROM t1'
>       formatted = sqlparse.format(sql, reindent=True)

tests/test_regressions.py:230: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue190_open_file">test_regressions.py::test_issue190_open_file</h3>
<details><summary> <pre>test_regressions.py::test_issue190_open_file</pre></summary><pre>
filepath = <function filepath.<locals>.make_filepath at 0x7ef7ad8f9360>

    def test_issue190_open_file(filepath):
        path = filepath('stream.sql')
        with open(path) as stream:
>           p = sqlparse.parse(stream)[0]

tests/test_regressions.py:241: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue193_splitting_function">test_regressions.py::test_issue193_splitting_function</h3>
<details><summary> <pre>test_regressions.py::test_issue193_splitting_function</pre></summary><pre>
def test_issue193_splitting_function():
        sql = """   CREATE FUNCTION a(x VARCHAR(20)) RETURNS VARCHAR(20)
                    BEGIN
                     DECLARE y VARCHAR(20);
                     RETURN x;
                    END;
                    SELECT * FROM a.b;"""
>       statements = sqlparse.split(sql)

tests/test_regressions.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:72: in split
    return [str(stmt).strip() for stmt in stack.run(sql, encoding)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad695570>
sql = '   CREATE FUNCTION a(x VARCHAR(20)) RETURNS VARCHAR(20)\n                BEGIN\n                 DECLARE y VARCHAR(20);\n                 RETURN x;\n                END;\n                SELECT * FROM a.b;'
encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
            stream = filter_.process(stream)

        stream = StatementSplitter().process(stream)

        # Group and ungroup tokens
        if self._grouping:
            stream = grouping.group(stream)

        # Process statements
        ret = []
>       for stmt in stream:
E       TypeError: 'NoneType' object is not iterable

sqlparse/engine/filter_stack.py:34: TypeError
</pre>
</details>
<h3 id="test_regressionspytest_issue194_splitting_function">test_regressions.py::test_issue194_splitting_function</h3>
<details><summary> <pre>test_regressions.py::test_issue194_splitting_function</pre></summary><pre>
def test_issue194_splitting_function():
        sql = """   CREATE FUNCTION a(x VARCHAR(20)) RETURNS VARCHAR(20)
                    BEGIN
                     DECLARE y VARCHAR(20);
                     IF (1 = 1) THEN
                     SET x = y;
                     END IF;
                     RETURN x;
                    END;
                    SELECT * FROM a.b;"""
>       statements = sqlparse.split(sql)

tests/test_regressions.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:72: in split
    return [str(stmt).strip() for stmt in stack.run(sql, encoding)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad4ca7a0>
sql = '   CREATE FUNCTION a(x VARCHAR(20)) RETURNS VARCHAR(20)\n                BEGIN\n                 DECLARE y VARCHAR(20...x = y;\n                 END IF;\n                 RETURN x;\n                END;\n                SELECT * FROM a.b;'
encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
            stream = filter_.process(stream)

        stream = StatementSplitter().process(stream)

        # Group and ungroup tokens
        if self._grouping:
            stream = grouping.group(stream)

        # Process statements
        ret = []
>       for stmt in stream:
E       TypeError: 'NoneType' object is not iterable

sqlparse/engine/filter_stack.py:34: TypeError
</pre>
</details>
<h3 id="test_regressionspytest_issue186_get_type">test_regressions.py::test_issue186_get_type</h3>
<details><summary> <pre>test_regressions.py::test_issue186_get_type</pre></summary><pre>
def test_issue186_get_type():
        sql = "-- comment\ninsert into foo"
>       p = sqlparse.parse(sql)[0]

tests/test_regressions.py:272: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue213_leadingws">test_regressions.py::test_issue213_leadingws</h3>
<details><summary> <pre>test_regressions.py::test_issue213_leadingws</pre></summary><pre>
def test_issue213_leadingws():
        sql = " select * from foo"
>       assert sqlparse.format(sql, strip_whitespace=True) == "select * from foo"

tests/test_regressions.py:285: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad624d60>
sql = ' select * from foo', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
>           stream = filter_.process(stream)
E           AttributeError: 'StripWhitespaceFilter' object has no attribute 'process'

sqlparse/engine/filter_stack.py:24: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue227_gettype_cte">test_regressions.py::test_issue227_gettype_cte</h3>
<details><summary> <pre>test_regressions.py::test_issue227_gettype_cte</pre></summary><pre>
def test_issue227_gettype_cte():
>       select_stmt = sqlparse.parse('SELECT 1, 2, 3 FROM foo;')

tests/test_regressions.py:289: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue207_runaway_format">test_regressions.py::test_issue207_runaway_format</h3>
<details><summary> <pre>test_regressions.py::test_issue207_runaway_format</pre></summary><pre>
def test_issue207_runaway_format():
        sql = 'select 1 from (select 1 as one, 2 as two, 3 from dual) t0'
>       p = sqlparse.format(sql, reindent=True)

tests/test_regressions.py:303: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_token_next_doesnt_ignore_skip_cm">test_regressions.py::test_token_next_doesnt_ignore_skip_cm</h3>
<details><summary> <pre>test_regressions.py::test_token_next_doesnt_ignore_skip_cm</pre></summary><pre>
def test_token_next_doesnt_ignore_skip_cm():
        sql = '--comment\nselect 1'
>       tok = sqlparse.parse(sql)[0].token_next(-1, skip_cm=True)[1]

tests/test_regressions.py:315: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue284_as_groupingselect-x-as">test_regressions.py::test_issue284_as_grouping[SELECT x AS]</h3>
<details><summary> <pre>test_regressions.py::test_issue284_as_grouping[SELECT x AS]</pre></summary><pre>
s = 'SELECT x AS'

    @pytest.mark.parametrize('s', [
        'SELECT x AS',
        'AS'
    ])
    def test_issue284_as_grouping(s):
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:324: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue284_as_groupingas">test_regressions.py::test_issue284_as_grouping[AS]</h3>
<details><summary> <pre>test_regressions.py::test_issue284_as_grouping[AS]</pre></summary><pre>
s = 'AS'

    @pytest.mark.parametrize('s', [
        'SELECT x AS',
        'AS'
    ])
    def test_issue284_as_grouping(s):
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:324: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue315_utf8_by_default">test_regressions.py::test_issue315_utf8_by_default</h3>
<details><summary> <pre>test_regressions.py::test_issue315_utf8_by_default</pre></summary><pre>
def test_issue315_utf8_by_default():
        # Make sure the lexer can handle utf-8 string by default correctly
        # digest = '齐天大圣.カラフルな雲.사랑해요'
        # The digest contains Chinese, Japanese and Korean characters
        # All in 'utf-8' encoding.
        digest = (
            '\xe9\xbd\x90\xe5\xa4\xa9\xe5\xa4\xa7\xe5\x9c\xa3.'
            '\xe3\x82\xab\xe3\x83\xa9\xe3\x83\x95\xe3\x83\xab\xe3\x81\xaa\xe9'
            '\x9b\xb2.'
            '\xec\x82\xac\xeb\x9e\x91\xed\x95\xb4\xec\x9a\x94'
        )
        sql = "select * from foo where bar = '{}'".format(digest)
>       formatted = sqlparse.format(sql, reindent=True)

tests/test_regressions.py:340: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue322_concurrently_is_keyword">test_regressions.py::test_issue322_concurrently_is_keyword</h3>
<details><summary> <pre>test_regressions.py::test_issue322_concurrently_is_keyword</pre></summary><pre>
def test_issue322_concurrently_is_keyword():
        s = 'CREATE INDEX CONCURRENTLY myindex ON mytable(col1);'
>       p = sqlparse.parse(s)[0]

tests/test_regressions.py:347: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue359_index_error_assignmentsselect-min_priceminprice-max_pricemaxprice-from-shop">test_regressions.py::test_issue359_index_error_assignments[SELECT @min_price:=MIN(price), @max_price:=MAX(price) FROM shop;]</h3>
<details><summary> <pre>test_regressions.py::test_issue359_index_error_assignments[SELECT @min_price:=MIN(price), @max_price:=MAX(price) FROM shop;]</pre></summary><pre>
s = 'SELECT @min_price:=MIN(price), @max_price:=MAX(price) FROM shop;'

    @pytest.mark.parametrize('s', [
        'SELECT @min_price:=MIN(price), @max_price:=MAX(price) FROM shop;',
        'SELECT @min_price:=MIN(price), @max_price:=MAX(price) FROM shop',

    ])
    def test_issue359_index_error_assignments(s):
>       sqlparse.parse(s)

tests/test_regressions.py:364: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue359_index_error_assignmentsselect-min_priceminprice-max_pricemaxprice-from-shop_1">test_regressions.py::test_issue359_index_error_assignments[SELECT @min_price:=MIN(price), @max_price:=MAX(price) FROM shop]</h3>
<details><summary> <pre>test_regressions.py::test_issue359_index_error_assignments[SELECT @min_price:=MIN(price), @max_price:=MAX(price) FROM shop]</pre></summary><pre>
s = 'SELECT @min_price:=MIN(price), @max_price:=MAX(price) FROM shop'

    @pytest.mark.parametrize('s', [
        'SELECT @min_price:=MIN(price), @max_price:=MAX(price) FROM shop;',
        'SELECT @min_price:=MIN(price), @max_price:=MAX(price) FROM shop',

    ])
    def test_issue359_index_error_assignments(s):
>       sqlparse.parse(s)

tests/test_regressions.py:364: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue469_copy_as_psql_command">test_regressions.py::test_issue469_copy_as_psql_command</h3>
<details><summary> <pre>test_regressions.py::test_issue469_copy_as_psql_command</pre></summary><pre>
def test_issue469_copy_as_psql_command():
>       formatted = sqlparse.format(
            '\\copy select * from foo',
            keyword_case='upper', identifier_case='capitalize')

tests/test_regressions.py:369: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad5e42b0>
sql = '\\copy select * from foo', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
>           stream = filter_.process(stream)
E           AttributeError: 'KeywordCaseFilter' object has no attribute 'process'

sqlparse/engine/filter_stack.py:24: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue484_comments_and_newlines">test_regressions.py::test_issue484_comments_and_newlines</h3>
<details><summary> <pre>test_regressions.py::test_issue484_comments_and_newlines</pre></summary><pre>
@pytest.mark.xfail(reason='Needs to be fixed')
    def test_issue484_comments_and_newlines():
>       formatted = sqlparse.format('\n'.join([
            'Create table myTable',
            '(',
            '  myId TINYINT NOT NULL, --my special comment',
            '  myName VARCHAR2(100) NOT NULL',
            ')']),
            strip_comments=True)

tests/test_regressions.py:377: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad5da440>
sql = 'Create table myTable\n(\n  myId TINYINT NOT NULL, --my special comment\n  myName VARCHAR2(100) NOT NULL\n)'
encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
>           stream = filter_.process(stream)
E           AttributeError: 'StripCommentsFilter' object has no attribute 'process'

sqlparse/engine/filter_stack.py:24: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue485_split_multi">test_regressions.py::test_issue485_split_multi</h3>
<details><summary> <pre>test_regressions.py::test_issue485_split_multi</pre></summary><pre>
def test_issue485_split_multi():
        p_sql = '''CREATE OR REPLACE RULE ruled_tab_2rules AS ON INSERT
    TO public.ruled_tab
    DO instead (
    select 1;
    select 2;
    );'''
>       assert len(sqlparse.split(p_sql)) == 1

tests/test_regressions.py:399: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:72: in split
    return [str(stmt).strip() for stmt in stack.run(sql, encoding)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad6a7a30>
sql = 'CREATE OR REPLACE RULE ruled_tab_2rules AS ON INSERT\nTO public.ruled_tab\nDO instead (\nselect 1;\nselect 2;\n);'
encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
            stream = filter_.process(stream)

        stream = StatementSplitter().process(stream)

        # Group and ungroup tokens
        if self._grouping:
            stream = grouping.group(stream)

        # Process statements
        ret = []
>       for stmt in stream:
E       TypeError: 'NoneType' object is not iterable

sqlparse/engine/filter_stack.py:34: TypeError
</pre>
</details>
<h3 id="test_regressionspytest_issue489_tzcasts">test_regressions.py::test_issue489_tzcasts</h3>
<details><summary> <pre>test_regressions.py::test_issue489_tzcasts</pre></summary><pre>
def test_issue489_tzcasts():
>       p = sqlparse.parse('select bar at time zone \'UTC\' as foo')[0]

tests/test_regressions.py:403: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_issue562_tzcasts">test_regressions.py::test_issue562_tzcasts</h3>
<details><summary> <pre>test_regressions.py::test_issue562_tzcasts</pre></summary><pre>
def test_issue562_tzcasts():
        # Test that whitespace between 'from' and 'bar' is retained
>       formatted = sqlparse.format(
            'SELECT f(HOUR from bar AT TIME ZONE \'UTC\') from foo', reindent=True
        )

tests/test_regressions.py:410: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_as_in_parentheses_indents">test_regressions.py::test_as_in_parentheses_indents</h3>
<details><summary> <pre>test_regressions.py::test_as_in_parentheses_indents</pre></summary><pre>
def test_as_in_parentheses_indents():
        # did raise NoneType has no attribute is_group in _process_parentheses
>       formatted = sqlparse.format('(as foo)', reindent=True)

tests/test_regressions.py:419: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_format_invalid_where_clause">test_regressions.py::test_format_invalid_where_clause</h3>
<details><summary> <pre>test_regressions.py::test_format_invalid_where_clause</pre></summary><pre>
def test_format_invalid_where_clause():
        # did raise ValueError
>       formatted = sqlparse.format('where, foo', reindent=True)

tests/test_regressions.py:425: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:59: in format
    return ''.join(stack.run(sql, encoding))
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_splitting_at_and_backticks_issue588">test_regressions.py::test_splitting_at_and_backticks_issue588</h3>
<details><summary> <pre>test_regressions.py::test_splitting_at_and_backticks_issue588</pre></summary><pre>
def test_splitting_at_and_backticks_issue588():
>       splitted = sqlparse.split(
            'grant foo to user1@`myhost`; grant bar to user1@`myhost`;')

tests/test_regressions.py:430: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:72: in split
    return [str(stmt).strip() for stmt in stack.run(sql, encoding)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad50d390>
sql = 'grant foo to user1@`myhost`; grant bar to user1@`myhost`;'
encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
            stream = filter_.process(stream)

        stream = StatementSplitter().process(stream)

        # Group and ungroup tokens
        if self._grouping:
            stream = grouping.group(stream)

        # Process statements
        ret = []
>       for stmt in stream:
E       TypeError: 'NoneType' object is not iterable

sqlparse/engine/filter_stack.py:34: TypeError
</pre>
</details>
<h3 id="test_regressionspytest_comment_between_cte_clauses_issue632">test_regressions.py::test_comment_between_cte_clauses_issue632</h3>
<details><summary> <pre>test_regressions.py::test_comment_between_cte_clauses_issue632</pre></summary><pre>
def test_comment_between_cte_clauses_issue632():
>       p, = sqlparse.parse("""
            WITH foo AS (),
                 -- A comment before baz subquery
                 baz AS ()
            SELECT * FROM baz;""")

tests/test_regressions.py:437: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_copy_issue672">test_regressions.py::test_copy_issue672</h3>
<details><summary> <pre>test_regressions.py::test_copy_issue672</pre></summary><pre>
def test_copy_issue672():
>       p = sqlparse.parse('select * from foo')[0]

tests/test_regressions.py:446: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_primary_key_issue740">test_regressions.py::test_primary_key_issue740</h3>
<details><summary> <pre>test_regressions.py::test_primary_key_issue740</pre></summary><pre>
def test_primary_key_issue740():
>       p = sqlparse.parse('PRIMARY KEY')[0]

tests/test_regressions.py:452: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_regressionspytest_max_recursion">test_regressions.py::test_max_recursion</h3>
<details><summary> <pre>test_regressions.py::test_max_recursion</pre></summary><pre>
limit_recursion = None

    def test_max_recursion(limit_recursion):
        with pytest.raises(SQLParseError):
>           sqlparse.parse('[' * 1000 + ']' * 1000)

tests/test_regressions.py:467: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_splitpytest_split_semicolon">test_split.py::test_split_semicolon</h3>
<details><summary> <pre>test_split.py::test_split_semicolon</pre></summary><pre>
def test_split_semicolon():
        sql1 = 'select * from foo;'
        sql2 = "select * from foo where bar = 'foo;bar';"
>       stmts = sqlparse.parse(''.join([sql1, sql2]))

tests/test_split.py:14: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_splitpytest_split_backslash">test_split.py::test_split_backslash</h3>
<details><summary> <pre>test_split.py::test_split_backslash</pre></summary><pre>
def test_split_backslash():
>       stmts = sqlparse.parse("select '\'; select '\'';")

tests/test_split.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_splitpytest_split_create_functionfunctionsql">test_split.py::test_split_create_function[function.sql]</h3>
<details><summary> <pre>test_split.py::test_split_create_function[function.sql]</pre></summary><pre>
load_file = <function load_file.<locals>.make_load_file at 0x7ef7ad2325f0>
fn = 'function.sql'

    @pytest.mark.parametrize('fn', ['function.sql',
                                    'function_psql.sql',
                                    'function_psql2.sql',
                                    'function_psql3.sql',
                                    'function_psql4.sql'])
    def test_split_create_function(load_file, fn):
        sql = load_file(fn)
>       stmts = sqlparse.parse(sql)

tests/test_split.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_splitpytest_split_create_functionfunction_psqlsql">test_split.py::test_split_create_function[function_psql.sql]</h3>
<details><summary> <pre>test_split.py::test_split_create_function[function_psql.sql]</pre></summary><pre>
load_file = <function load_file.<locals>.make_load_file at 0x7ef7ad231b40>
fn = 'function_psql.sql'

    @pytest.mark.parametrize('fn', ['function.sql',
                                    'function_psql.sql',
                                    'function_psql2.sql',
                                    'function_psql3.sql',
                                    'function_psql4.sql'])
    def test_split_create_function(load_file, fn):
        sql = load_file(fn)
>       stmts = sqlparse.parse(sql)

tests/test_split.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_splitpytest_split_create_functionfunction_psql2sql">test_split.py::test_split_create_function[function_psql2.sql]</h3>
<details><summary> <pre>test_split.py::test_split_create_function[function_psql2.sql]</pre></summary><pre>
load_file = <function load_file.<locals>.make_load_file at 0x7ef7ad232680>
fn = 'function_psql2.sql'

    @pytest.mark.parametrize('fn', ['function.sql',
                                    'function_psql.sql',
                                    'function_psql2.sql',
                                    'function_psql3.sql',
                                    'function_psql4.sql'])
    def test_split_create_function(load_file, fn):
        sql = load_file(fn)
>       stmts = sqlparse.parse(sql)

tests/test_split.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_splitpytest_split_create_functionfunction_psql3sql">test_split.py::test_split_create_function[function_psql3.sql]</h3>
<details><summary> <pre>test_split.py::test_split_create_function[function_psql3.sql]</pre></summary><pre>
load_file = <function load_file.<locals>.make_load_file at 0x7ef7ad232050>
fn = 'function_psql3.sql'

    @pytest.mark.parametrize('fn', ['function.sql',
                                    'function_psql.sql',
                                    'function_psql2.sql',
                                    'function_psql3.sql',
                                    'function_psql4.sql'])
    def test_split_create_function(load_file, fn):
        sql = load_file(fn)
>       stmts = sqlparse.parse(sql)

tests/test_split.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_splitpytest_split_create_functionfunction_psql4sql">test_split.py::test_split_create_function[function_psql4.sql]</h3>
<details><summary> <pre>test_split.py::test_split_create_function[function_psql4.sql]</pre></summary><pre>
load_file = <function load_file.<locals>.make_load_file at 0x7ef7ad231240>
fn = 'function_psql4.sql'

    @pytest.mark.parametrize('fn', ['function.sql',
                                    'function_psql.sql',
                                    'function_psql2.sql',
                                    'function_psql3.sql',
                                    'function_psql4.sql'])
    def test_split_create_function(load_file, fn):
        sql = load_file(fn)
>       stmts = sqlparse.parse(sql)

tests/test_split.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_splitpytest_split_dashcomments">test_split.py::test_split_dashcomments</h3>
<details><summary> <pre>test_split.py::test_split_dashcomments</pre></summary><pre>
load_file = <function load_file.<locals>.make_load_file at 0x7ef7ad2323b0>

    def test_split_dashcomments(load_file):
        sql = load_file('dashcomment.sql')
>       stmts = sqlparse.parse(sql)

tests/test_split.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_splitpytest_split_dashcomments_eolselect-foo-commentn">test_split.py::test_split_dashcomments_eol[select foo; -- comment\n]</h3>
<details><summary> <pre>test_split.py::test_split_dashcomments_eol[select foo; -- comment\n]</pre></summary><pre>
s = 'select foo; -- comment\n'

    @pytest.mark.parametrize('s', ['select foo; -- comment\n',
                                   'select foo; -- comment\r',
                                   'select foo; -- comment\r\n',
                                   'select foo; -- comment'])
    def test_split_dashcomments_eol(s):
>       stmts = sqlparse.parse(s)

tests/test_split.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_splitpytest_split_dashcomments_eolselect-foo-commentr">test_split.py::test_split_dashcomments_eol[select foo; -- comment\r]</h3>
<details><summary> <pre>test_split.py::test_split_dashcomments_eol[select foo; -- comment\r]</pre></summary><pre>
s = 'select foo; -- comment\r'

    @pytest.mark.parametrize('s', ['select foo; -- comment\n',
                                   'select foo; -- comment\r',
                                   'select foo; -- comment\r\n',
                                   'select foo; -- comment'])
    def test_split_dashcomments_eol(s):
>       stmts = sqlparse.parse(s)

tests/test_split.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_splitpytest_split_dashcomments_eolselect-foo-commentrn">test_split.py::test_split_dashcomments_eol[select foo; -- comment\r\n]</h3>
<details><summary> <pre>test_split.py::test_split_dashcomments_eol[select foo; -- comment\r\n]</pre></summary><pre>
s = 'select foo; -- comment\r\n'

    @pytest.mark.parametrize('s', ['select foo; -- comment\n',
                                   'select foo; -- comment\r',
                                   'select foo; -- comment\r\n',
                                   'select foo; -- comment'])
    def test_split_dashcomments_eol(s):
>       stmts = sqlparse.parse(s)

tests/test_split.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_splitpytest_split_dashcomments_eolselect-foo-comment">test_split.py::test_split_dashcomments_eol[select foo; -- comment]</h3>
<details><summary> <pre>test_split.py::test_split_dashcomments_eol[select foo; -- comment]</pre></summary><pre>
s = 'select foo; -- comment'

    @pytest.mark.parametrize('s', ['select foo; -- comment\n',
                                   'select foo; -- comment\r',
                                   'select foo; -- comment\r\n',
                                   'select foo; -- comment'])
    def test_split_dashcomments_eol(s):
>       stmts = sqlparse.parse(s)

tests/test_split.py:49: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_splitpytest_split_begintag">test_split.py::test_split_begintag</h3>
<details><summary> <pre>test_split.py::test_split_begintag</pre></summary><pre>
load_file = <function load_file.<locals>.make_load_file at 0x7ef7ad230ee0>

    def test_split_begintag(load_file):
        sql = load_file('begintag.sql')
>       stmts = sqlparse.parse(sql)

tests/test_split.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_splitpytest_split_begintag_2">test_split.py::test_split_begintag_2</h3>
<details><summary> <pre>test_split.py::test_split_begintag_2</pre></summary><pre>
load_file = <function load_file.<locals>.make_load_file at 0x7ef7ad231750>

    def test_split_begintag_2(load_file):
        sql = load_file('begintag_2.sql')
>       stmts = sqlparse.parse(sql)

tests/test_split.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_splitpytest_split_dropif">test_split.py::test_split_dropif</h3>
<details><summary> <pre>test_split.py::test_split_dropif</pre></summary><pre>
def test_split_dropif():
        sql = 'DROP TABLE IF EXISTS FOO;\n\nSELECT * FROM BAR;'
>       stmts = sqlparse.parse(sql)

tests/test_split.py:69: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_splitpytest_split_comment_with_umlaut">test_split.py::test_split_comment_with_umlaut</h3>
<details><summary> <pre>test_split.py::test_split_comment_with_umlaut</pre></summary><pre>
def test_split_comment_with_umlaut():
        sql = ('select * from foo;\n'
               '-- Testing an umlaut: ä\n'
               'select * from bar;')
>       stmts = sqlparse.parse(sql)

tests/test_split.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_splitpytest_split_comment_end_of_line">test_split.py::test_split_comment_end_of_line</h3>
<details><summary> <pre>test_split.py::test_split_comment_end_of_line</pre></summary><pre>
def test_split_comment_end_of_line():
        sql = ('select * from foo; -- foo\n'
               'select * from bar;')
>       stmts = sqlparse.parse(sql)

tests/test_split.py:86: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_splitpytest_split_casewhen">test_split.py::test_split_casewhen</h3>
<details><summary> <pre>test_split.py::test_split_casewhen</pre></summary><pre>
def test_split_casewhen():
        sql = ("SELECT case when val = 1 then 2 else null end as foo;\n"
               "comment on table actor is 'The actor table.';")
>       stmts = sqlparse.split(sql)

tests/test_split.py:96: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:72: in split
    return [str(stmt).strip() for stmt in stack.run(sql, encoding)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad593550>
sql = "SELECT case when val = 1 then 2 else null end as foo;\ncomment on table actor is 'The actor table.';"
encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
            stream = filter_.process(stream)

        stream = StatementSplitter().process(stream)

        # Group and ungroup tokens
        if self._grouping:
            stream = grouping.group(stream)

        # Process statements
        ret = []
>       for stmt in stream:
E       TypeError: 'NoneType' object is not iterable

sqlparse/engine/filter_stack.py:34: TypeError
</pre>
</details>
<h3 id="test_splitpytest_split_casewhen_procedure">test_split.py::test_split_casewhen_procedure</h3>
<details><summary> <pre>test_split.py::test_split_casewhen_procedure</pre></summary><pre>
load_file = <function load_file.<locals>.make_load_file at 0x7ef7adb7ac20>

    def test_split_casewhen_procedure(load_file):
        # see issue580
>       stmts = sqlparse.split(load_file('casewhen_procedure.sql'))

tests/test_split.py:102: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:72: in split
    return [str(stmt).strip() for stmt in stack.run(sql, encoding)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad50d3f0>
sql = "create procedure procName()\nbegin\n  select case when column = 'value' then column else 0 end;\nend;\ncreate procedure procName()\nbegin\n  select 1;\nend;"
encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
            stream = filter_.process(stream)

        stream = StatementSplitter().process(stream)

        # Group and ungroup tokens
        if self._grouping:
            stream = grouping.group(stream)

        # Process statements
        ret = []
>       for stmt in stream:
E       TypeError: 'NoneType' object is not iterable

sqlparse/engine/filter_stack.py:34: TypeError
</pre>
</details>
<h3 id="test_splitpytest_split_cursor_declare">test_split.py::test_split_cursor_declare</h3>
<details><summary> <pre>test_split.py::test_split_cursor_declare</pre></summary><pre>
def test_split_cursor_declare():
        sql = ('DECLARE CURSOR "foo" AS SELECT 1;\n'
               'SELECT 2;')
>       stmts = sqlparse.split(sql)

tests/test_split.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:72: in split
    return [str(stmt).strip() for stmt in stack.run(sql, encoding)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad61dd80>
sql = 'DECLARE CURSOR "foo" AS SELECT 1;\nSELECT 2;', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
            stream = filter_.process(stream)

        stream = StatementSplitter().process(stream)

        # Group and ungroup tokens
        if self._grouping:
            stream = grouping.group(stream)

        # Process statements
        ret = []
>       for stmt in stream:
E       TypeError: 'NoneType' object is not iterable

sqlparse/engine/filter_stack.py:34: TypeError
</pre>
</details>
<h3 id="test_splitpytest_split_if_function">test_split.py::test_split_if_function</h3>
<details><summary> <pre>test_split.py::test_split_if_function</pre></summary><pre>
def test_split_if_function():  # see issue 33
        # don't let IF as a function confuse the splitter
        sql = ('CREATE TEMPORARY TABLE tmp '
               'SELECT IF(a=1, a, b) AS o FROM one; '
               'SELECT t FROM two')
>       stmts = sqlparse.split(sql)

tests/test_split.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:72: in split
    return [str(stmt).strip() for stmt in stack.run(sql, encoding)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad43e890>
sql = 'CREATE TEMPORARY TABLE tmp SELECT IF(a=1, a, b) AS o FROM one; SELECT t FROM two'
encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
            stream = filter_.process(stream)

        stream = StatementSplitter().process(stream)

        # Group and ungroup tokens
        if self._grouping:
            stream = grouping.group(stream)

        # Process statements
        ret = []
>       for stmt in stream:
E       TypeError: 'NoneType' object is not iterable

sqlparse/engine/filter_stack.py:34: TypeError
</pre>
</details>
<h3 id="test_splitpytest_split_stream">test_split.py::test_split_stream</h3>
<details><summary> <pre>test_split.py::test_split_stream</pre></summary><pre>
def test_split_stream():
        stream = StringIO("SELECT 1; SELECT 2;")
>       stmts = sqlparse.parsestream(stream)

tests/test_split.py:124: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_splitpytest_split_encoding_parsestream">test_split.py::test_split_encoding_parsestream</h3>
<details><summary> <pre>test_split.py::test_split_encoding_parsestream</pre></summary><pre>
def test_split_encoding_parsestream():
        stream = StringIO("SELECT 1; SELECT 2;")
>       stmts = list(sqlparse.parsestream(stream))

tests/test_split.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_splitpytest_split_unicode_parsestream">test_split.py::test_split_unicode_parsestream</h3>
<details><summary> <pre>test_split.py::test_split_unicode_parsestream</pre></summary><pre>
def test_split_unicode_parsestream():
        stream = StringIO('SELECT ö')
>       stmts = list(sqlparse.parsestream(stream))

tests/test_split.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_splitpytest_split_simple">test_split.py::test_split_simple</h3>
<details><summary> <pre>test_split.py::test_split_simple</pre></summary><pre>
def test_split_simple():
>       stmts = sqlparse.split('select * from foo; select * from bar;')

tests/test_split.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:72: in split
    return [str(stmt).strip() for stmt in stack.run(sql, encoding)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad6a6aa0>
sql = 'select * from foo; select * from bar;', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
            stream = filter_.process(stream)

        stream = StatementSplitter().process(stream)

        # Group and ungroup tokens
        if self._grouping:
            stream = grouping.group(stream)

        # Process statements
        ret = []
>       for stmt in stream:
E       TypeError: 'NoneType' object is not iterable

sqlparse/engine/filter_stack.py:34: TypeError
</pre>
</details>
<h3 id="test_splitpytest_split_ignores_empty_newlines">test_split.py::test_split_ignores_empty_newlines</h3>
<details><summary> <pre>test_split.py::test_split_ignores_empty_newlines</pre></summary><pre>
def test_split_ignores_empty_newlines():
>       stmts = sqlparse.split('select foo;\nselect bar;\n')

tests/test_split.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:72: in split
    return [str(stmt).strip() for stmt in stack.run(sql, encoding)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad6e6dd0>
sql = 'select foo;\nselect bar;\n', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
            stream = filter_.process(stream)

        stream = StatementSplitter().process(stream)

        # Group and ungroup tokens
        if self._grouping:
            stream = grouping.group(stream)

        # Process statements
        ret = []
>       for stmt in stream:
E       TypeError: 'NoneType' object is not iterable

sqlparse/engine/filter_stack.py:34: TypeError
</pre>
</details>
<h3 id="test_splitpytest_split_quotes_with_new_line">test_split.py::test_split_quotes_with_new_line</h3>
<details><summary> <pre>test_split.py::test_split_quotes_with_new_line</pre></summary><pre>
def test_split_quotes_with_new_line():
>       stmts = sqlparse.split('select "foo\nbar"')

tests/test_split.py:156: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:72: in split
    return [str(stmt).strip() for stmt in stack.run(sql, encoding)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad5d8790>
sql = 'select "foo\nbar"', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
            stream = filter_.process(stream)

        stream = StatementSplitter().process(stream)

        # Group and ungroup tokens
        if self._grouping:
            stream = grouping.group(stream)

        # Process statements
        ret = []
>       for stmt in stream:
E       TypeError: 'NoneType' object is not iterable

sqlparse/engine/filter_stack.py:34: TypeError
</pre>
</details>
<h3 id="test_splitpytest_split_mysql_handler_for">test_split.py::test_split_mysql_handler_for</h3>
<details><summary> <pre>test_split.py::test_split_mysql_handler_for</pre></summary><pre>
load_file = <function load_file.<locals>.make_load_file at 0x7ef7ad2313f0>

    def test_split_mysql_handler_for(load_file):
        # see issue581
>       stmts = sqlparse.split(load_file('mysql_handler.sql'))

tests/test_split.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:72: in split
    return [str(stmt).strip() for stmt in stack.run(sql, encoding)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad513700>
sql = 'create procedure proc1()\nbegin\n  declare handler for foo begin end;\n  select 1;\nend;\n\ncreate procedure proc2()\nbegin\n  select 1;\nend;'
encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
            stream = filter_.process(stream)

        stream = StatementSplitter().process(stream)

        # Group and ungroup tokens
        if self._grouping:
            stream = grouping.group(stream)

        # Process statements
        ret = []
>       for stmt in stream:
E       TypeError: 'NoneType' object is not iterable

sqlparse/engine/filter_stack.py:34: TypeError
</pre>
</details>
<h3 id="test_splitpytest_split_strip_semicolonselect-from-foo-expected0">test_split.py::test_split_strip_semicolon[select * from foo;-expected0]</h3>
<details><summary> <pre>test_split.py::test_split_strip_semicolon[select * from foo;-expected0]</pre></summary><pre>
sql = 'select * from foo;', expected = ['select * from foo']

    @pytest.mark.parametrize('sql, expected', [
        ('select * from foo;', ['select * from foo']),
        ('select * from foo', ['select * from foo']),
        ('select * from foo; select * from bar;', [
            'select * from foo',
            'select * from bar',
        ]),
        ('  select * from foo;\n\nselect * from bar;\n\n\n\n', [
            'select * from foo',
            'select * from bar',
        ]),
        ('select * from foo\n\n;  bar', ['select * from foo', 'bar']),
    ])
    def test_split_strip_semicolon(sql, expected):
>       stmts = sqlparse.split(sql, strip_semicolon=True)

tests/test_split.py:185: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:72: in split
    return [str(stmt).strip() for stmt in stack.run(sql, encoding)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad5da980>
sql = 'select * from foo;', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
            stream = filter_.process(stream)

        stream = StatementSplitter().process(stream)

        # Group and ungroup tokens
        if self._grouping:
            stream = grouping.group(stream)

        # Process statements
        ret = []
>       for stmt in stream:
E       TypeError: 'NoneType' object is not iterable

sqlparse/engine/filter_stack.py:34: TypeError
</pre>
</details>
<h3 id="test_splitpytest_split_strip_semicolonselect-from-foo-expected1">test_split.py::test_split_strip_semicolon[select * from foo-expected1]</h3>
<details><summary> <pre>test_split.py::test_split_strip_semicolon[select * from foo-expected1]</pre></summary><pre>
sql = 'select * from foo', expected = ['select * from foo']

    @pytest.mark.parametrize('sql, expected', [
        ('select * from foo;', ['select * from foo']),
        ('select * from foo', ['select * from foo']),
        ('select * from foo; select * from bar;', [
            'select * from foo',
            'select * from bar',
        ]),
        ('  select * from foo;\n\nselect * from bar;\n\n\n\n', [
            'select * from foo',
            'select * from bar',
        ]),
        ('select * from foo\n\n;  bar', ['select * from foo', 'bar']),
    ])
    def test_split_strip_semicolon(sql, expected):
>       stmts = sqlparse.split(sql, strip_semicolon=True)

tests/test_split.py:185: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:72: in split
    return [str(stmt).strip() for stmt in stack.run(sql, encoding)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad7a0340>
sql = 'select * from foo', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
            stream = filter_.process(stream)

        stream = StatementSplitter().process(stream)

        # Group and ungroup tokens
        if self._grouping:
            stream = grouping.group(stream)

        # Process statements
        ret = []
>       for stmt in stream:
E       TypeError: 'NoneType' object is not iterable

sqlparse/engine/filter_stack.py:34: TypeError
</pre>
</details>
<h3 id="test_splitpytest_split_strip_semicolonselect-from-foo-select-from-bar-expected2">test_split.py::test_split_strip_semicolon[select * from foo; select * from bar;-expected2]</h3>
<details><summary> <pre>test_split.py::test_split_strip_semicolon[select * from foo; select * from bar;-expected2]</pre></summary><pre>
sql = 'select * from foo; select * from bar;'
expected = ['select * from foo', 'select * from bar']

    @pytest.mark.parametrize('sql, expected', [
        ('select * from foo;', ['select * from foo']),
        ('select * from foo', ['select * from foo']),
        ('select * from foo; select * from bar;', [
            'select * from foo',
            'select * from bar',
        ]),
        ('  select * from foo;\n\nselect * from bar;\n\n\n\n', [
            'select * from foo',
            'select * from bar',
        ]),
        ('select * from foo\n\n;  bar', ['select * from foo', 'bar']),
    ])
    def test_split_strip_semicolon(sql, expected):
>       stmts = sqlparse.split(sql, strip_semicolon=True)

tests/test_split.py:185: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:72: in split
    return [str(stmt).strip() for stmt in stack.run(sql, encoding)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad46c9d0>
sql = 'select * from foo; select * from bar;', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
            stream = filter_.process(stream)

        stream = StatementSplitter().process(stream)

        # Group and ungroup tokens
        if self._grouping:
            stream = grouping.group(stream)

        # Process statements
        ret = []
>       for stmt in stream:
E       TypeError: 'NoneType' object is not iterable

sqlparse/engine/filter_stack.py:34: TypeError
</pre>
</details>
<h3 id="test_splitpytest_split_strip_semicolon-select-from-foonnselect-from-barnnnn-expected3">test_split.py::test_split_strip_semicolon[  select * from foo;\n\nselect * from bar;\n\n\n\n-expected3]</h3>
<details><summary> <pre>test_split.py::test_split_strip_semicolon[  select * from foo;\n\nselect * from bar;\n\n\n\n-expected3]</pre></summary><pre>
sql = '  select * from foo;\n\nselect * from bar;\n\n\n\n'
expected = ['select * from foo', 'select * from bar']

    @pytest.mark.parametrize('sql, expected', [
        ('select * from foo;', ['select * from foo']),
        ('select * from foo', ['select * from foo']),
        ('select * from foo; select * from bar;', [
            'select * from foo',
            'select * from bar',
        ]),
        ('  select * from foo;\n\nselect * from bar;\n\n\n\n', [
            'select * from foo',
            'select * from bar',
        ]),
        ('select * from foo\n\n;  bar', ['select * from foo', 'bar']),
    ])
    def test_split_strip_semicolon(sql, expected):
>       stmts = sqlparse.split(sql, strip_semicolon=True)

tests/test_split.py:185: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:72: in split
    return [str(stmt).strip() for stmt in stack.run(sql, encoding)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad7a1870>
sql = '  select * from foo;\n\nselect * from bar;\n\n\n\n', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
            stream = filter_.process(stream)

        stream = StatementSplitter().process(stream)

        # Group and ungroup tokens
        if self._grouping:
            stream = grouping.group(stream)

        # Process statements
        ret = []
>       for stmt in stream:
E       TypeError: 'NoneType' object is not iterable

sqlparse/engine/filter_stack.py:34: TypeError
</pre>
</details>
<h3 id="test_splitpytest_split_strip_semicolonselect-from-foonn-bar-expected4">test_split.py::test_split_strip_semicolon[select * from foo\n\n;  bar-expected4]</h3>
<details><summary> <pre>test_split.py::test_split_strip_semicolon[select * from foo\n\n;  bar-expected4]</pre></summary><pre>
sql = 'select * from foo\n\n;  bar', expected = ['select * from foo', 'bar']

    @pytest.mark.parametrize('sql, expected', [
        ('select * from foo;', ['select * from foo']),
        ('select * from foo', ['select * from foo']),
        ('select * from foo; select * from bar;', [
            'select * from foo',
            'select * from bar',
        ]),
        ('  select * from foo;\n\nselect * from bar;\n\n\n\n', [
            'select * from foo',
            'select * from bar',
        ]),
        ('select * from foo\n\n;  bar', ['select * from foo', 'bar']),
    ])
    def test_split_strip_semicolon(sql, expected):
>       stmts = sqlparse.split(sql, strip_semicolon=True)

tests/test_split.py:185: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:72: in split
    return [str(stmt).strip() for stmt in stack.run(sql, encoding)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad67d150>
sql = 'select * from foo\n\n;  bar', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
            stream = filter_.process(stream)

        stream = StatementSplitter().process(stream)

        # Group and ungroup tokens
        if self._grouping:
            stream = grouping.group(stream)

        # Process statements
        ret = []
>       for stmt in stream:
E       TypeError: 'NoneType' object is not iterable

sqlparse/engine/filter_stack.py:34: TypeError
</pre>
</details>
<h3 id="test_splitpytest_split_strip_semicolon_procedure">test_split.py::test_split_strip_semicolon_procedure</h3>
<details><summary> <pre>test_split.py::test_split_strip_semicolon_procedure</pre></summary><pre>
load_file = <function load_file.<locals>.make_load_file at 0x7ef7ad2323b0>

    def test_split_strip_semicolon_procedure(load_file):
>       stmts = sqlparse.split(load_file('mysql_handler.sql'),
                               strip_semicolon=True)

tests/test_split.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:72: in split
    return [str(stmt).strip() for stmt in stack.run(sql, encoding)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad7a3d90>
sql = 'create procedure proc1()\nbegin\n  declare handler for foo begin end;\n  select 1;\nend;\n\ncreate procedure proc2()\nbegin\n  select 1;\nend;'
encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
            stream = filter_.process(stream)

        stream = StatementSplitter().process(stream)

        # Group and ungroup tokens
        if self._grouping:
            stream = grouping.group(stream)

        # Process statements
        ret = []
>       for stmt in stream:
E       TypeError: 'NoneType' object is not iterable

sqlparse/engine/filter_stack.py:34: TypeError
</pre>
</details>
<h3 id="test_splitpytest_split_gouse-foongonselect-1ngo-4">test_split.py::test_split_go[USE foo;\nGO\nSELECT 1;\nGO-4]</h3>
<details><summary> <pre>test_split.py::test_split_go[USE foo;\nGO\nSELECT 1;\nGO-4]</pre></summary><pre>
sql = 'USE foo;\nGO\nSELECT 1;\nGO', num = 4

    @pytest.mark.parametrize('sql, num', [
        ('USE foo;\nGO\nSELECT 1;\nGO', 4),
        ('SELECT * FROM foo;\nGO', 2),
        ('USE foo;\nGO 2\nSELECT 1;', 3)
    ])
    def test_split_go(sql, num):  # issue762
>       stmts = sqlparse.split(sql)

tests/test_split.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:72: in split
    return [str(stmt).strip() for stmt in stack.run(sql, encoding)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad591ea0>
sql = 'USE foo;\nGO\nSELECT 1;\nGO', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
            stream = filter_.process(stream)

        stream = StatementSplitter().process(stream)

        # Group and ungroup tokens
        if self._grouping:
            stream = grouping.group(stream)

        # Process statements
        ret = []
>       for stmt in stream:
E       TypeError: 'NoneType' object is not iterable

sqlparse/engine/filter_stack.py:34: TypeError
</pre>
</details>
<h3 id="test_splitpytest_split_goselect-from-foongo-2">test_split.py::test_split_go[SELECT * FROM foo;\nGO-2]</h3>
<details><summary> <pre>test_split.py::test_split_go[SELECT * FROM foo;\nGO-2]</pre></summary><pre>
sql = 'SELECT * FROM foo;\nGO', num = 2

    @pytest.mark.parametrize('sql, num', [
        ('USE foo;\nGO\nSELECT 1;\nGO', 4),
        ('SELECT * FROM foo;\nGO', 2),
        ('USE foo;\nGO 2\nSELECT 1;', 3)
    ])
    def test_split_go(sql, num):  # issue762
>       stmts = sqlparse.split(sql)

tests/test_split.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:72: in split
    return [str(stmt).strip() for stmt in stack.run(sql, encoding)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad7a0cd0>
sql = 'SELECT * FROM foo;\nGO', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
            stream = filter_.process(stream)

        stream = StatementSplitter().process(stream)

        # Group and ungroup tokens
        if self._grouping:
            stream = grouping.group(stream)

        # Process statements
        ret = []
>       for stmt in stream:
E       TypeError: 'NoneType' object is not iterable

sqlparse/engine/filter_stack.py:34: TypeError
</pre>
</details>
<h3 id="test_splitpytest_split_gouse-foongo-2nselect-1-3">test_split.py::test_split_go[USE foo;\nGO 2\nSELECT 1;-3]</h3>
<details><summary> <pre>test_split.py::test_split_go[USE foo;\nGO 2\nSELECT 1;-3]</pre></summary><pre>
sql = 'USE foo;\nGO 2\nSELECT 1;', num = 3

    @pytest.mark.parametrize('sql, num', [
        ('USE foo;\nGO\nSELECT 1;\nGO', 4),
        ('SELECT * FROM foo;\nGO', 2),
        ('USE foo;\nGO 2\nSELECT 1;', 3)
    ])
    def test_split_go(sql, num):  # issue762
>       stmts = sqlparse.split(sql)

tests/test_split.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:72: in split
    return [str(stmt).strip() for stmt in stack.run(sql, encoding)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad7a3cd0>
sql = 'USE foo;\nGO 2\nSELECT 1;', encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
            stream = filter_.process(stream)

        stream = StatementSplitter().process(stream)

        # Group and ungroup tokens
        if self._grouping:
            stream = grouping.group(stream)

        # Process statements
        ret = []
>       for stmt in stream:
E       TypeError: 'NoneType' object is not iterable

sqlparse/engine/filter_stack.py:34: TypeError
</pre>
</details>
<h3 id="test_splitpytest_split_multiple_case_in_begin">test_split.py::test_split_multiple_case_in_begin</h3>
<details><summary> <pre>test_split.py::test_split_multiple_case_in_begin</pre></summary><pre>
load_file = <function load_file.<locals>.make_load_file at 0x7ef7ad2317e0>

    def test_split_multiple_case_in_begin(load_file):  # issue784
>       stmts = sqlparse.split(load_file('multiple_case_in_begin.sql'))

tests/test_split.py:209: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:72: in split
    return [str(stmt).strip() for stmt in stack.run(sql, encoding)]
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <sqlparse.engine.filter_stack.FilterStack object at 0x7ef7ad9459f0>
sql = 'CREATE TRIGGER mytrig\nAFTER UPDATE OF vvv ON mytable\nBEGIN\n    UPDATE aa\n        SET mycola = (CASE WHEN (A=1) THEN 2 END);\n    UPDATE bb\n        SET mycolb = (CASE WHEN (B=1) THEN 5 END);\nEND;'
encoding = None

    def run(self, sql, encoding=None):
        stream = lexer.tokenize(sql, encoding)
        # Process token stream
        for filter_ in self.preprocess:
            stream = filter_.process(stream)

        stream = StatementSplitter().process(stream)

        # Group and ungroup tokens
        if self._grouping:
            stream = grouping.group(stream)

        # Process statements
        ret = []
>       for stmt in stream:
E       TypeError: 'NoneType' object is not iterable

sqlparse/engine/filter_stack.py:34: TypeError
</pre>
</details>
<h3 id="test_tokenizepytest_tokenize_backticks">test_tokenize.py::test_tokenize_backticks</h3>
<details><summary> <pre>test_tokenize.py::test_tokenize_backticks</pre></summary><pre>
def test_tokenize_backticks():
        s = '`foo`.`bar`'
        tokens = list(lexer.tokenize(s))
>       assert len(tokens) == 3
E       AssertionError: assert 7 == 3
E        +  where 7 = len([(Token.Error, '`'), (Token.Name, 'foo'), (Token.Error, '`'), (Token.Punctuation, '.'), (Token.Error, '`'), (Token.Name, 'bar'), ...])

tests/test_tokenize.py:25: AssertionError
</pre>
</details>
<h3 id="test_tokenizepytest_tokenize_negative_numbers">test_tokenize.py::test_tokenize_negative_numbers</h3>
<details><summary> <pre>test_tokenize.py::test_tokenize_negative_numbers</pre></summary><pre>
def test_tokenize_negative_numbers():
        s = "values(-1)"
        tokens = list(lexer.tokenize(s))
>       assert len(tokens) == 4
E       AssertionError: assert 5 == 4
E        +  where 5 = len([(Token.Keyword, 'values'), (Token.Punctuation, '('), (Token.Operator, '-'), (Token.Literal.Number, '1'), (Token.Punctuation, ')')])

tests/test_tokenize.py:63: AssertionError
</pre>
</details>
<h3 id="test_tokenizepytest_token_repr">test_tokenize.py::test_token_repr</h3>
<details><summary> <pre>test_tokenize.py::test_token_repr</pre></summary><pre>
def test_token_repr():
        token = sql.Token(T.Keyword, 'foo')
        tst = "<Keyword 'foo' at 0x"
>       assert repr(token)[:len(tst)] == tst
E       assert "<Token 'foo' at 0x7E" == "<Keyword 'foo' at 0x"
E         
E         - <Keyword 'foo' at 0x
E         + <Token 'foo' at 0x7E

tests/test_tokenize.py:76: AssertionError
</pre>
</details>
<h3 id="test_tokenizepytest_tokenlist_repr">test_tokenize.py::test_tokenlist_repr</h3>
<details><summary> <pre>test_tokenize.py::test_tokenlist_repr</pre></summary><pre>
def test_tokenlist_repr():
>       p = sqlparse.parse('foo, bar, baz')[0]

tests/test_tokenize.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_single_quotes">test_tokenize.py::test_single_quotes</h3>
<details><summary> <pre>test_tokenize.py::test_single_quotes</pre></summary><pre>
def test_single_quotes():
>       p = sqlparse.parse("'test'")[0]

tests/test_tokenize.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_tokenlist_first">test_tokenize.py::test_tokenlist_first</h3>
<details><summary> <pre>test_tokenize.py::test_tokenlist_first</pre></summary><pre>
def test_tokenlist_first():
>       p = sqlparse.parse(' select foo')[0]

tests/test_tokenize.py:103: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_tokenlist_token_matching">test_tokenize.py::test_tokenlist_token_matching</h3>
<details><summary> <pre>test_tokenize.py::test_tokenlist_token_matching</pre></summary><pre>
def test_tokenlist_token_matching():
        t1 = sql.Token(T.Keyword, 'foo')
        t2 = sql.Token(T.Punctuation, ',')
        x = sql.TokenList([t1, t2])
>       assert x.token_matching([lambda t: t.ttype is T.Keyword], 0) == t1

tests/test_tokenize.py:114: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <TokenList 'foo,' at 0x7EF7AD1B43C0>
token = [<function test_tokenlist_token_matching.<locals>.<lambda> at 0x7ef7ad231b40>]
idx = 0

    def token_matching(self, token, idx):
        """Returns the matching token for a token at given index."""
>       if not token.is_group:
E       AttributeError: 'list' object has no attribute 'is_group'

sqlparse/sql.py:245: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_stream_error">test_tokenize.py::test_stream_error</h3>
<details><summary> <pre>test_tokenize.py::test_stream_error</pre></summary><pre>
def test_stream_error():
        stream = StringIO("FOOBAR{")

        tokens = list(lexer.tokenize(stream))
        assert len(tokens) == 2
>       assert tokens[1][0] == T.Error
E       assert Token.Punctuation == Token.Error
E         
E         (pytest_assertion plugin: representation of details failed: /usr/lib/python3.10/pprint.py:554: RecursionError: maximum recursion depth exceeded while getting the repr of an object.
E          Probably an object has a faulty __repr__.)

tests/test_tokenize.py:139: AssertionError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_joinjoin">test_tokenize.py::test_parse_join[JOIN]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_join[JOIN]</pre></summary><pre>
expr = 'JOIN'

    @pytest.mark.parametrize('expr', [
        'JOIN',
        'LEFT JOIN',
        'LEFT OUTER JOIN',
        'FULL OUTER JOIN',
        'NATURAL JOIN',
        'CROSS JOIN',
        'STRAIGHT JOIN',
        'INNER JOIN',
        'LEFT INNER JOIN'])
    def test_parse_join(expr):
>       p = sqlparse.parse('{} foo'.format(expr))[0]

tests/test_tokenize.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_joinleft-join">test_tokenize.py::test_parse_join[LEFT JOIN]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_join[LEFT JOIN]</pre></summary><pre>
expr = 'LEFT JOIN'

    @pytest.mark.parametrize('expr', [
        'JOIN',
        'LEFT JOIN',
        'LEFT OUTER JOIN',
        'FULL OUTER JOIN',
        'NATURAL JOIN',
        'CROSS JOIN',
        'STRAIGHT JOIN',
        'INNER JOIN',
        'LEFT INNER JOIN'])
    def test_parse_join(expr):
>       p = sqlparse.parse('{} foo'.format(expr))[0]

tests/test_tokenize.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_joinleft-outer-join">test_tokenize.py::test_parse_join[LEFT OUTER JOIN]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_join[LEFT OUTER JOIN]</pre></summary><pre>
expr = 'LEFT OUTER JOIN'

    @pytest.mark.parametrize('expr', [
        'JOIN',
        'LEFT JOIN',
        'LEFT OUTER JOIN',
        'FULL OUTER JOIN',
        'NATURAL JOIN',
        'CROSS JOIN',
        'STRAIGHT JOIN',
        'INNER JOIN',
        'LEFT INNER JOIN'])
    def test_parse_join(expr):
>       p = sqlparse.parse('{} foo'.format(expr))[0]

tests/test_tokenize.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_joinfull-outer-join">test_tokenize.py::test_parse_join[FULL OUTER JOIN]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_join[FULL OUTER JOIN]</pre></summary><pre>
expr = 'FULL OUTER JOIN'

    @pytest.mark.parametrize('expr', [
        'JOIN',
        'LEFT JOIN',
        'LEFT OUTER JOIN',
        'FULL OUTER JOIN',
        'NATURAL JOIN',
        'CROSS JOIN',
        'STRAIGHT JOIN',
        'INNER JOIN',
        'LEFT INNER JOIN'])
    def test_parse_join(expr):
>       p = sqlparse.parse('{} foo'.format(expr))[0]

tests/test_tokenize.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_joinnatural-join">test_tokenize.py::test_parse_join[NATURAL JOIN]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_join[NATURAL JOIN]</pre></summary><pre>
expr = 'NATURAL JOIN'

    @pytest.mark.parametrize('expr', [
        'JOIN',
        'LEFT JOIN',
        'LEFT OUTER JOIN',
        'FULL OUTER JOIN',
        'NATURAL JOIN',
        'CROSS JOIN',
        'STRAIGHT JOIN',
        'INNER JOIN',
        'LEFT INNER JOIN'])
    def test_parse_join(expr):
>       p = sqlparse.parse('{} foo'.format(expr))[0]

tests/test_tokenize.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_joincross-join">test_tokenize.py::test_parse_join[CROSS JOIN]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_join[CROSS JOIN]</pre></summary><pre>
expr = 'CROSS JOIN'

    @pytest.mark.parametrize('expr', [
        'JOIN',
        'LEFT JOIN',
        'LEFT OUTER JOIN',
        'FULL OUTER JOIN',
        'NATURAL JOIN',
        'CROSS JOIN',
        'STRAIGHT JOIN',
        'INNER JOIN',
        'LEFT INNER JOIN'])
    def test_parse_join(expr):
>       p = sqlparse.parse('{} foo'.format(expr))[0]

tests/test_tokenize.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_joinstraight-join">test_tokenize.py::test_parse_join[STRAIGHT JOIN]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_join[STRAIGHT JOIN]</pre></summary><pre>
expr = 'STRAIGHT JOIN'

    @pytest.mark.parametrize('expr', [
        'JOIN',
        'LEFT JOIN',
        'LEFT OUTER JOIN',
        'FULL OUTER JOIN',
        'NATURAL JOIN',
        'CROSS JOIN',
        'STRAIGHT JOIN',
        'INNER JOIN',
        'LEFT INNER JOIN'])
    def test_parse_join(expr):
>       p = sqlparse.parse('{} foo'.format(expr))[0]

tests/test_tokenize.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_joininner-join">test_tokenize.py::test_parse_join[INNER JOIN]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_join[INNER JOIN]</pre></summary><pre>
expr = 'INNER JOIN'

    @pytest.mark.parametrize('expr', [
        'JOIN',
        'LEFT JOIN',
        'LEFT OUTER JOIN',
        'FULL OUTER JOIN',
        'NATURAL JOIN',
        'CROSS JOIN',
        'STRAIGHT JOIN',
        'INNER JOIN',
        'LEFT INNER JOIN'])
    def test_parse_join(expr):
>       p = sqlparse.parse('{} foo'.format(expr))[0]

tests/test_tokenize.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_joinleft-inner-join">test_tokenize.py::test_parse_join[LEFT INNER JOIN]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_join[LEFT INNER JOIN]</pre></summary><pre>
expr = 'LEFT INNER JOIN'

    @pytest.mark.parametrize('expr', [
        'JOIN',
        'LEFT JOIN',
        'LEFT OUTER JOIN',
        'FULL OUTER JOIN',
        'NATURAL JOIN',
        'CROSS JOIN',
        'STRAIGHT JOIN',
        'INNER JOIN',
        'LEFT INNER JOIN'])
    def test_parse_join(expr):
>       p = sqlparse.parse('{} foo'.format(expr))[0]

tests/test_tokenize.py:153: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_union">test_tokenize.py::test_parse_union</h3>
<details><summary> <pre>test_tokenize.py::test_parse_union</pre></summary><pre>
def test_parse_union():  # issue294
>       p = sqlparse.parse('UNION ALL')[0]

tests/test_tokenize.py:159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_endifloopend-if">test_tokenize.py::test_parse_endifloop[END IF]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_endifloop[END IF]</pre></summary><pre>
s = 'END IF'

    @pytest.mark.parametrize('s', ['END IF', 'END   IF', 'END\t\nIF',
                                   'END LOOP', 'END   LOOP', 'END\t\nLOOP'])
    def test_parse_endifloop(s):
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_endifloopend-if_1">test_tokenize.py::test_parse_endifloop[END   IF]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_endifloop[END   IF]</pre></summary><pre>
s = 'END   IF'

    @pytest.mark.parametrize('s', ['END IF', 'END   IF', 'END\t\nIF',
                                   'END LOOP', 'END   LOOP', 'END\t\nLOOP'])
    def test_parse_endifloop(s):
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_endifloopendtnif">test_tokenize.py::test_parse_endifloop[END\t\nIF]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_endifloop[END\t\nIF]</pre></summary><pre>
s = 'END\t\nIF'

    @pytest.mark.parametrize('s', ['END IF', 'END   IF', 'END\t\nIF',
                                   'END LOOP', 'END   LOOP', 'END\t\nLOOP'])
    def test_parse_endifloop(s):
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_endifloopend-loop">test_tokenize.py::test_parse_endifloop[END LOOP]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_endifloop[END LOOP]</pre></summary><pre>
s = 'END LOOP'

    @pytest.mark.parametrize('s', ['END IF', 'END   IF', 'END\t\nIF',
                                   'END LOOP', 'END   LOOP', 'END\t\nLOOP'])
    def test_parse_endifloop(s):
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_endifloopend-loop_1">test_tokenize.py::test_parse_endifloop[END   LOOP]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_endifloop[END   LOOP]</pre></summary><pre>
s = 'END   LOOP'

    @pytest.mark.parametrize('s', ['END IF', 'END   IF', 'END\t\nIF',
                                   'END LOOP', 'END   LOOP', 'END\t\nLOOP'])
    def test_parse_endifloop(s):
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_endifloopendtnloop">test_tokenize.py::test_parse_endifloop[END\t\nLOOP]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_endifloop[END\t\nLOOP]</pre></summary><pre>
s = 'END\t\nLOOP'

    @pytest.mark.parametrize('s', ['END IF', 'END   IF', 'END\t\nIF',
                                   'END LOOP', 'END   LOOP', 'END\t\nLOOP'])
    def test_parse_endifloop(s):
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:167: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_orderasc">test_tokenize.py::test_parse_order[ASC]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_order[ASC]</pre></summary><pre>
s = 'ASC'

    @pytest.mark.parametrize('s', [
        'ASC', 'DESC',
        'NULLS FIRST', 'NULLS LAST',
        'ASC NULLS FIRST', 'ASC NULLS LAST',
        'DESC NULLS FIRST', 'DESC NULLS LAST',
    ])
    def test_parse_order(s):  # issue487
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_orderdesc">test_tokenize.py::test_parse_order[DESC]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_order[DESC]</pre></summary><pre>
s = 'DESC'

    @pytest.mark.parametrize('s', [
        'ASC', 'DESC',
        'NULLS FIRST', 'NULLS LAST',
        'ASC NULLS FIRST', 'ASC NULLS LAST',
        'DESC NULLS FIRST', 'DESC NULLS LAST',
    ])
    def test_parse_order(s):  # issue487
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_ordernulls-first">test_tokenize.py::test_parse_order[NULLS FIRST]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_order[NULLS FIRST]</pre></summary><pre>
s = 'NULLS FIRST'

    @pytest.mark.parametrize('s', [
        'ASC', 'DESC',
        'NULLS FIRST', 'NULLS LAST',
        'ASC NULLS FIRST', 'ASC NULLS LAST',
        'DESC NULLS FIRST', 'DESC NULLS LAST',
    ])
    def test_parse_order(s):  # issue487
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_ordernulls-last">test_tokenize.py::test_parse_order[NULLS LAST]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_order[NULLS LAST]</pre></summary><pre>
s = 'NULLS LAST'

    @pytest.mark.parametrize('s', [
        'ASC', 'DESC',
        'NULLS FIRST', 'NULLS LAST',
        'ASC NULLS FIRST', 'ASC NULLS LAST',
        'DESC NULLS FIRST', 'DESC NULLS LAST',
    ])
    def test_parse_order(s):  # issue487
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_orderasc-nulls-first">test_tokenize.py::test_parse_order[ASC NULLS FIRST]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_order[ASC NULLS FIRST]</pre></summary><pre>
s = 'ASC NULLS FIRST'

    @pytest.mark.parametrize('s', [
        'ASC', 'DESC',
        'NULLS FIRST', 'NULLS LAST',
        'ASC NULLS FIRST', 'ASC NULLS LAST',
        'DESC NULLS FIRST', 'DESC NULLS LAST',
    ])
    def test_parse_order(s):  # issue487
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_orderasc-nulls-last">test_tokenize.py::test_parse_order[ASC NULLS LAST]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_order[ASC NULLS LAST]</pre></summary><pre>
s = 'ASC NULLS LAST'

    @pytest.mark.parametrize('s', [
        'ASC', 'DESC',
        'NULLS FIRST', 'NULLS LAST',
        'ASC NULLS FIRST', 'ASC NULLS LAST',
        'DESC NULLS FIRST', 'DESC NULLS LAST',
    ])
    def test_parse_order(s):  # issue487
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_orderdesc-nulls-first">test_tokenize.py::test_parse_order[DESC NULLS FIRST]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_order[DESC NULLS FIRST]</pre></summary><pre>
s = 'DESC NULLS FIRST'

    @pytest.mark.parametrize('s', [
        'ASC', 'DESC',
        'NULLS FIRST', 'NULLS LAST',
        'ASC NULLS FIRST', 'ASC NULLS LAST',
        'DESC NULLS FIRST', 'DESC NULLS LAST',
    ])
    def test_parse_order(s):  # issue487
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_orderdesc-nulls-last">test_tokenize.py::test_parse_order[DESC NULLS LAST]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_order[DESC NULLS LAST]</pre></summary><pre>
s = 'DESC NULLS LAST'

    @pytest.mark.parametrize('s', [
        'ASC', 'DESC',
        'NULLS FIRST', 'NULLS LAST',
        'ASC NULLS FIRST', 'ASC NULLS LAST',
        'DESC NULLS FIRST', 'DESC NULLS LAST',
    ])
    def test_parse_order(s):  # issue487
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:179: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_identifiersfoo">test_tokenize.py::test_parse_identifiers[foo]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_identifiers[foo]</pre></summary><pre>
s = 'foo'

    @pytest.mark.parametrize('s', [
        'foo',
        'Foo',
        'FOO',
        'v$name',  # issue291
    ])
    def test_parse_identifiers(s):
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:191: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_identifiersfoo_1">test_tokenize.py::test_parse_identifiers[Foo]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_identifiers[Foo]</pre></summary><pre>
s = 'Foo'

    @pytest.mark.parametrize('s', [
        'foo',
        'Foo',
        'FOO',
        'v$name',  # issue291
    ])
    def test_parse_identifiers(s):
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:191: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_identifiersfoo_2">test_tokenize.py::test_parse_identifiers[FOO]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_identifiers[FOO]</pre></summary><pre>
s = 'FOO'

    @pytest.mark.parametrize('s', [
        'foo',
        'Foo',
        'FOO',
        'v$name',  # issue291
    ])
    def test_parse_identifiers(s):
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:191: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_identifiersvname">test_tokenize.py::test_parse_identifiers[v$name]</h3>
<details><summary> <pre>test_tokenize.py::test_parse_identifiers[v$name]</pre></summary><pre>
s = 'v$name'

    @pytest.mark.parametrize('s', [
        'foo',
        'Foo',
        'FOO',
        'v$name',  # issue291
    ])
    def test_parse_identifiers(s):
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:191: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_group_by">test_tokenize.py::test_parse_group_by</h3>
<details><summary> <pre>test_tokenize.py::test_parse_group_by</pre></summary><pre>
def test_parse_group_by():
>       p = sqlparse.parse('GROUP BY')[0]

tests/test_tokenize.py:199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_order_by">test_tokenize.py::test_parse_order_by</h3>
<details><summary> <pre>test_tokenize.py::test_parse_order_by</pre></summary><pre>
def test_parse_order_by():
>       p = sqlparse.parse('ORDER BY')[0]

tests/test_tokenize.py:205: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_window_as">test_tokenize.py::test_parse_window_as</h3>
<details><summary> <pre>test_tokenize.py::test_parse_window_as</pre></summary><pre>
def test_parse_window_as():
>       p = sqlparse.parse('WINDOW w AS')[0]

tests/test_tokenize.py:211: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_like_and_ilike_parsed_as_comparisonslike">test_tokenize.py::test_like_and_ilike_parsed_as_comparisons[LIKE]</h3>
<details><summary> <pre>test_tokenize.py::test_like_and_ilike_parsed_as_comparisons[LIKE]</pre></summary><pre>
s = 'LIKE'

    @pytest.mark.parametrize('s', (
        "LIKE", "ILIKE", "NOT LIKE", "NOT ILIKE",
        "NOT   LIKE", "NOT    ILIKE",
    ))
    def test_like_and_ilike_parsed_as_comparisons(s):
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_like_and_ilike_parsed_as_comparisonsilike">test_tokenize.py::test_like_and_ilike_parsed_as_comparisons[ILIKE]</h3>
<details><summary> <pre>test_tokenize.py::test_like_and_ilike_parsed_as_comparisons[ILIKE]</pre></summary><pre>
s = 'ILIKE'

    @pytest.mark.parametrize('s', (
        "LIKE", "ILIKE", "NOT LIKE", "NOT ILIKE",
        "NOT   LIKE", "NOT    ILIKE",
    ))
    def test_like_and_ilike_parsed_as_comparisons(s):
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_like_and_ilike_parsed_as_comparisonsnot-like">test_tokenize.py::test_like_and_ilike_parsed_as_comparisons[NOT LIKE]</h3>
<details><summary> <pre>test_tokenize.py::test_like_and_ilike_parsed_as_comparisons[NOT LIKE]</pre></summary><pre>
s = 'NOT LIKE'

    @pytest.mark.parametrize('s', (
        "LIKE", "ILIKE", "NOT LIKE", "NOT ILIKE",
        "NOT   LIKE", "NOT    ILIKE",
    ))
    def test_like_and_ilike_parsed_as_comparisons(s):
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_like_and_ilike_parsed_as_comparisonsnot-ilike">test_tokenize.py::test_like_and_ilike_parsed_as_comparisons[NOT ILIKE]</h3>
<details><summary> <pre>test_tokenize.py::test_like_and_ilike_parsed_as_comparisons[NOT ILIKE]</pre></summary><pre>
s = 'NOT ILIKE'

    @pytest.mark.parametrize('s', (
        "LIKE", "ILIKE", "NOT LIKE", "NOT ILIKE",
        "NOT   LIKE", "NOT    ILIKE",
    ))
    def test_like_and_ilike_parsed_as_comparisons(s):
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_like_and_ilike_parsed_as_comparisonsnot-like_1">test_tokenize.py::test_like_and_ilike_parsed_as_comparisons[NOT   LIKE]</h3>
<details><summary> <pre>test_tokenize.py::test_like_and_ilike_parsed_as_comparisons[NOT   LIKE]</pre></summary><pre>
s = 'NOT   LIKE'

    @pytest.mark.parametrize('s', (
        "LIKE", "ILIKE", "NOT LIKE", "NOT ILIKE",
        "NOT   LIKE", "NOT    ILIKE",
    ))
    def test_like_and_ilike_parsed_as_comparisons(s):
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_like_and_ilike_parsed_as_comparisonsnot-ilike_1">test_tokenize.py::test_like_and_ilike_parsed_as_comparisons[NOT    ILIKE]</h3>
<details><summary> <pre>test_tokenize.py::test_like_and_ilike_parsed_as_comparisons[NOT    ILIKE]</pre></summary><pre>
s = 'NOT    ILIKE'

    @pytest.mark.parametrize('s', (
        "LIKE", "ILIKE", "NOT LIKE", "NOT ILIKE",
        "NOT   LIKE", "NOT    ILIKE",
    ))
    def test_like_and_ilike_parsed_as_comparisons(s):
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_near_like_and_ilike_parsed_appropriatelylikeaaa">test_tokenize.py::test_near_like_and_ilike_parsed_appropriately[LIKEaaa]</h3>
<details><summary> <pre>test_tokenize.py::test_near_like_and_ilike_parsed_appropriately[LIKEaaa]</pre></summary><pre>
s = 'LIKEaaa'

    @pytest.mark.parametrize('s', (
        "LIKEaaa", "bILIKE", "aaILIKEbb", "NOTLIKE", "NOTILIKE",
    ))
    def test_near_like_and_ilike_parsed_appropriately(s):
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:230: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_near_like_and_ilike_parsed_appropriatelybilike">test_tokenize.py::test_near_like_and_ilike_parsed_appropriately[bILIKE]</h3>
<details><summary> <pre>test_tokenize.py::test_near_like_and_ilike_parsed_appropriately[bILIKE]</pre></summary><pre>
s = 'bILIKE'

    @pytest.mark.parametrize('s', (
        "LIKEaaa", "bILIKE", "aaILIKEbb", "NOTLIKE", "NOTILIKE",
    ))
    def test_near_like_and_ilike_parsed_appropriately(s):
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:230: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_near_like_and_ilike_parsed_appropriatelyaailikebb">test_tokenize.py::test_near_like_and_ilike_parsed_appropriately[aaILIKEbb]</h3>
<details><summary> <pre>test_tokenize.py::test_near_like_and_ilike_parsed_appropriately[aaILIKEbb]</pre></summary><pre>
s = 'aaILIKEbb'

    @pytest.mark.parametrize('s', (
        "LIKEaaa", "bILIKE", "aaILIKEbb", "NOTLIKE", "NOTILIKE",
    ))
    def test_near_like_and_ilike_parsed_appropriately(s):
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:230: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_near_like_and_ilike_parsed_appropriatelynotlike">test_tokenize.py::test_near_like_and_ilike_parsed_appropriately[NOTLIKE]</h3>
<details><summary> <pre>test_tokenize.py::test_near_like_and_ilike_parsed_appropriately[NOTLIKE]</pre></summary><pre>
s = 'NOTLIKE'

    @pytest.mark.parametrize('s', (
        "LIKEaaa", "bILIKE", "aaILIKEbb", "NOTLIKE", "NOTILIKE",
    ))
    def test_near_like_and_ilike_parsed_appropriately(s):
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:230: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_near_like_and_ilike_parsed_appropriatelynotilike">test_tokenize.py::test_near_like_and_ilike_parsed_appropriately[NOTILIKE]</h3>
<details><summary> <pre>test_tokenize.py::test_near_like_and_ilike_parsed_appropriately[NOTILIKE]</pre></summary><pre>
s = 'NOTILIKE'

    @pytest.mark.parametrize('s', (
        "LIKEaaa", "bILIKE", "aaILIKEbb", "NOTLIKE", "NOTILIKE",
    ))
    def test_near_like_and_ilike_parsed_appropriately(s):
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:230: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_parse_tzcastat-time-zone-utc">test_tokenize.py::test_parse_tzcast[AT TIME ZONE 'UTC']</h3>
<details><summary> <pre>test_tokenize.py::test_parse_tzcast[AT TIME ZONE 'UTC']</pre></summary><pre>
s = "AT TIME ZONE 'UTC'"

    @pytest.mark.parametrize('s', (
        'AT TIME ZONE \'UTC\'',
    ))
    def test_parse_tzcast(s):
>       p = sqlparse.parse(s)[0]

tests/test_tokenize.py:239: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>
<h3 id="test_tokenizepytest_cli_commands">test_tokenize.py::test_cli_commands</h3>
<details><summary> <pre>test_tokenize.py::test_cli_commands</pre></summary><pre>
def test_cli_commands():
>       p = sqlparse.parse('\\copy')[0]

tests/test_tokenize.py:245: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sqlparse/__init__.py:30: in parse
    return tuple(parsestream(sql, encoding))
sqlparse/__init__.py:42: in parsestream
    return stack.run(stream, encoding)
sqlparse/engine/filter_stack.py:30: in run
    stream = grouping.group(stream)
sqlparse/engine/grouping.py:61: in group
    _group_matching(stream, cls)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

tlist = None, cls = <class 'sqlparse.sql.Parenthesis'>

    def _group_matching(tlist, cls):
        """Groups Tokens that have beginning and end."""
        idx = 0
>       while idx < len(tlist.tokens):
E       AttributeError: 'NoneType' object has no attribute 'tokens'

sqlparse/engine/grouping.py:16: AttributeError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/sqlparse/cli.py b/sqlparse/cli.py</span>
<span class="gh">index 36590f9..ae3025c 100755</span>
<span class="gd">--- a/sqlparse/cli.py</span>
<span class="gi">+++ b/sqlparse/cli.py</span>
<span class="gu">@@ -18,4 +18,60 @@ from sqlparse.exceptions import SQLParseError</span>

<span class="w"> </span>def _error(msg):
<span class="w"> </span>    &quot;&quot;&quot;Print msg and optionally exit with return code exit_.&quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    sys.stderr.write(msg + &#39;\n&#39;)</span>
<span class="gi">+    sys.exit(1)</span>
<span class="gi">+</span>
<span class="gi">+def create_parser():</span>
<span class="gi">+    &quot;&quot;&quot;Create and return command line parser.&quot;&quot;&quot;</span>
<span class="gi">+    parser = argparse.ArgumentParser(</span>
<span class="gi">+        description=&#39;Format SQL files.&#39;,</span>
<span class="gi">+        usage=&#39;%(prog)s  [OPTIONS] FILE, ...&#39;,</span>
<span class="gi">+        add_help=True)</span>
<span class="gi">+    parser.add_argument(&#39;files&#39;, nargs=&#39;*&#39;, help=&#39;Files to be processed&#39;)</span>
<span class="gi">+    parser.add_argument(&#39;-o&#39;, &#39;--outfile&#39;, help=&#39;Write output to FILE&#39;)</span>
<span class="gi">+    parser.add_argument(&#39;-r&#39;, &#39;--reindent&#39;, action=&#39;store_true&#39;,</span>
<span class="gi">+                      help=&#39;Reindent statements&#39;)</span>
<span class="gi">+    parser.add_argument(&#39;-l&#39;, &#39;--language&#39;, choices=[&#39;English&#39;],</span>
<span class="gi">+                      help=&#39;Programming language (default: English)&#39;)</span>
<span class="gi">+    parser.add_argument(&#39;--encoding&#39;, default=&#39;utf-8&#39;,</span>
<span class="gi">+                      help=&#39;Specify the input encoding (default: utf-8)&#39;)</span>
<span class="gi">+    parser.add_argument(&#39;--indent-width&#39;, type=int, default=2,</span>
<span class="gi">+                      help=&#39;Number of spaces for indentation (default: 2)&#39;)</span>
<span class="gi">+    return parser</span>
<span class="gi">+</span>
<span class="gi">+def main(args=None):</span>
<span class="gi">+    &quot;&quot;&quot;Main entry point.&quot;&quot;&quot;</span>
<span class="gi">+    parser = create_parser()</span>
<span class="gi">+    args = parser.parse_args(args)</span>
<span class="gi">+</span>
<span class="gi">+    if not args.files:</span>
<span class="gi">+        parser.print_help()</span>
<span class="gi">+        sys.exit(1)</span>
<span class="gi">+</span>
<span class="gi">+    encoding = args.encoding</span>
<span class="gi">+    if encoding == &#39;utf-8&#39;:</span>
<span class="gi">+        # Python 3 reads files as utf-8 by default</span>
<span class="gi">+        encoding = None</span>
<span class="gi">+</span>
<span class="gi">+    for file_ in args.files:</span>
<span class="gi">+        try:</span>
<span class="gi">+            with open(file_, &#39;r&#39;, encoding=encoding) as f:</span>
<span class="gi">+                data = f.read()</span>
<span class="gi">+        except OSError as e:</span>
<span class="gi">+            _error(&#39;Failed to read {}: {}&#39;.format(file_, e))</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if args.reindent:</span>
<span class="gi">+            data = sqlparse.format(data, reindent=True,</span>
<span class="gi">+                                 indent_width=args.indent_width)</span>
<span class="gi">+</span>
<span class="gi">+        if args.outfile:</span>
<span class="gi">+            try:</span>
<span class="gi">+                with open(args.outfile, &#39;w&#39;, encoding=encoding) as f:</span>
<span class="gi">+                    f.write(data)</span>
<span class="gi">+            except OSError as e:</span>
<span class="gi">+                _error(&#39;Failed to write to {}: {}&#39;.format(args.outfile, e))</span>
<span class="gi">+        else:</span>
<span class="gi">+            sys.stdout.write(data)</span>
<span class="gi">+</span>
<span class="gi">+    return 0</span>
\ No newline at end of file
<span class="gh">diff --git a/sqlparse/engine/filter_stack.py b/sqlparse/engine/filter_stack.py</span>
<span class="gh">index 0b2f20c..451e0ca 100644</span>
<span class="gd">--- a/sqlparse/engine/filter_stack.py</span>
<span class="gi">+++ b/sqlparse/engine/filter_stack.py</span>
<span class="gu">@@ -12,4 +12,34 @@ class FilterStack:</span>
<span class="w"> </span>        self.postprocess = []
<span class="w"> </span>        self._grouping = False
<span class="w"> </span>        if strip_semicolon:
<span class="gd">-            self.stmtprocess.append(StripTrailingSemicolonFilter())</span>
\ No newline at end of file
<span class="gi">+            self.stmtprocess.append(StripTrailingSemicolonFilter())</span>
<span class="gi">+</span>
<span class="gi">+    def enable_grouping(self):</span>
<span class="gi">+        self._grouping = True</span>
<span class="gi">+</span>
<span class="gi">+    def run(self, sql, encoding=None):</span>
<span class="gi">+        stream = lexer.tokenize(sql, encoding)</span>
<span class="gi">+        # Process token stream</span>
<span class="gi">+        for filter_ in self.preprocess:</span>
<span class="gi">+            stream = filter_.process(stream)</span>
<span class="gi">+</span>
<span class="gi">+        stream = StatementSplitter().process(stream)</span>
<span class="gi">+</span>
<span class="gi">+        # Group and ungroup tokens</span>
<span class="gi">+        if self._grouping:</span>
<span class="gi">+            stream = grouping.group(stream)</span>
<span class="gi">+</span>
<span class="gi">+        # Process statements</span>
<span class="gi">+        ret = []</span>
<span class="gi">+        for stmt in stream:</span>
<span class="gi">+            if stmt.is_whitespace:</span>
<span class="gi">+                continue</span>
<span class="gi">+            for filter_ in self.stmtprocess:</span>
<span class="gi">+                filter_.process(stmt)</span>
<span class="gi">+            ret.append(stmt)</span>
<span class="gi">+</span>
<span class="gi">+        # Process again after grouping</span>
<span class="gi">+        for filter_ in self.postprocess:</span>
<span class="gi">+            ret = filter_.process(ret)</span>
<span class="gi">+</span>
<span class="gi">+        return ret</span>
\ No newline at end of file
<span class="gh">diff --git a/sqlparse/engine/grouping.py b/sqlparse/engine/grouping.py</span>
<span class="gh">index 7d36088..9992d0a 100644</span>
<span class="gd">--- a/sqlparse/engine/grouping.py</span>
<span class="gi">+++ b/sqlparse/engine/grouping.py</span>
<span class="gu">@@ -1,19 +1,110 @@</span>
<span class="w"> </span>from sqlparse import sql
<span class="w"> </span>from sqlparse import tokens as T
<span class="w"> </span>from sqlparse.utils import recurse, imt
<span class="gi">+from sqlparse.sql import (</span>
<span class="gi">+    Parenthesis, SquareBrackets, Case, If, For, Begin,</span>
<span class="gi">+    TypedLiteral, Identifier, IdentifierList, Operation,</span>
<span class="gi">+    Values, Command, Comparison, Assignment, Where, Having, Over</span>
<span class="gi">+)</span>
<span class="w"> </span>T_NUMERICAL = (T.Number, T.Number.Integer, T.Number.Float)
<span class="w"> </span>T_STRING = (T.String, T.String.Single, T.String.Symbol)
<span class="w"> </span>T_NAME = (T.Name, T.Name.Placeholder)

<span class="w"> </span>def _group_matching(tlist, cls):
<span class="w"> </span>    &quot;&quot;&quot;Groups Tokens that have beginning and end.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    idx = 0</span>
<span class="gi">+    while idx &lt; len(tlist.tokens):</span>
<span class="gi">+        token = tlist.tokens[idx]</span>
<span class="gi">+        if token.is_whitespace:</span>
<span class="gi">+            idx += 1</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if token.match(*cls.M_OPEN):</span>
<span class="gi">+            end_idx = tlist.token_matching(token, idx)</span>
<span class="gi">+            if end_idx is None:</span>
<span class="gi">+                idx += 1</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            group = tlist.group_tokens(cls, tlist.tokens[idx:end_idx + 1])</span>
<span class="gi">+            idx = tlist.token_index(group) + 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            idx += 1</span>

<span class="w"> </span>@recurse(sql.Identifier)
<span class="w"> </span>def group_order(tlist):
<span class="w"> </span>    &quot;&quot;&quot;Group together Identifier and Asc/Desc token&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    idx = 0</span>
<span class="gi">+    while idx &lt; len(tlist.tokens) - 1:</span>
<span class="gi">+        token = tlist.tokens[idx]</span>
<span class="gi">+        next_token = tlist.tokens[idx + 1]</span>
<span class="gi">+        </span>
<span class="gi">+        if token.is_whitespace or token.is_group:</span>
<span class="gi">+            idx += 1</span>
<span class="gi">+            continue</span>
<span class="gi">+            </span>
<span class="gi">+        if next_token.is_whitespace:</span>
<span class="gi">+            idx += 1</span>
<span class="gi">+            continue</span>
<span class="gi">+            </span>
<span class="gi">+        if token.ttype in (T.Name, T.String.Symbol, T.Number) and \</span>
<span class="gi">+           next_token.match(T.Keyword, (&#39;ASC&#39;, &#39;DESC&#39;), True):</span>
<span class="gi">+            grp = tlist.group_tokens(sql.Identifier, tlist.tokens[idx:idx + 2])</span>
<span class="gi">+            idx = tlist.token_index(grp) + 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            idx += 1</span>
<span class="gi">+</span>
<span class="gi">+def group(stream):</span>
<span class="gi">+    &quot;&quot;&quot;Group together tokens that form SQL statements.&quot;&quot;&quot;</span>
<span class="gi">+    for cls in (Parenthesis, SquareBrackets, Case, If, For, Begin,</span>
<span class="gi">+               TypedLiteral, Identifier, IdentifierList, Operation,</span>
<span class="gi">+               Values, Command):</span>
<span class="gi">+        _group_matching(stream, cls)</span>
<span class="gi">+</span>
<span class="gi">+    _group(stream, Comparison, (T.Operator.Comparison,))</span>
<span class="gi">+    _group(stream, Assignment, (T.Assignment,))</span>
<span class="gi">+    _group(stream, Where, (T.Keyword, &#39;WHERE&#39;))</span>
<span class="gi">+    _group(stream, Having, (T.Keyword, &#39;HAVING&#39;))</span>
<span class="gi">+    _group(stream, Over, (T.Keyword, &#39;OVER&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    group_order(stream)</span>
<span class="gi">+    return stream</span>

<span class="w"> </span>def _group(tlist, cls, match, valid_prev=lambda t: True, valid_next=lambda t: True, post=None, extend=True, recurse=True):
<span class="w"> </span>    &quot;&quot;&quot;Groups together tokens that are joined by a middle token. i.e. x &lt; y&quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    idx = 1</span>
<span class="gi">+    while idx &lt; len(tlist.tokens) - 1:</span>
<span class="gi">+        token = tlist.tokens[idx]</span>
<span class="gi">+        if token.is_whitespace:</span>
<span class="gi">+            idx += 1</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        before = tlist.tokens[idx - 1]</span>
<span class="gi">+        after = tlist.tokens[idx + 1]</span>
<span class="gi">+</span>
<span class="gi">+        if token.match(*match) and valid_prev(before) and valid_next(after):</span>
<span class="gi">+            if extend:</span>
<span class="gi">+                # Look ahead to handle x &gt; y &gt; z</span>
<span class="gi">+                end = idx + 1</span>
<span class="gi">+                while end &lt; len(tlist.tokens) - 1:</span>
<span class="gi">+                    next_token = tlist.tokens[end + 1]</span>
<span class="gi">+                    if next_token.is_whitespace:</span>
<span class="gi">+                        end += 1</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    if next_token.match(*match) and valid_next(tlist.tokens[end + 2]):</span>
<span class="gi">+                        end += 2</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        break</span>
<span class="gi">+                tokens = tlist.tokens[idx - 1:end + 1]</span>
<span class="gi">+            else:</span>
<span class="gi">+                tokens = tlist.tokens[idx - 1:idx + 2]</span>
<span class="gi">+</span>
<span class="gi">+            group = tlist.group_tokens(cls, tokens)</span>
<span class="gi">+            if post:</span>
<span class="gi">+                post(group)</span>
<span class="gi">+</span>
<span class="gi">+            if recurse:</span>
<span class="gi">+                _group(group, cls, match, valid_prev, valid_next, post, extend)</span>
<span class="gi">+</span>
<span class="gi">+            idx = tlist.token_index(group) + 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            idx += 1</span>
\ No newline at end of file
<span class="gh">diff --git a/sqlparse/filters/reindent.py b/sqlparse/filters/reindent.py</span>
<span class="gh">index 9a5150e..8e1bd8c 100644</span>
<span class="gd">--- a/sqlparse/filters/reindent.py</span>
<span class="gi">+++ b/sqlparse/filters/reindent.py</span>
<span class="gu">@@ -19,4 +19,44 @@ class ReindentFilter:</span>

<span class="w"> </span>    def _flatten_up_to_token(self, token):
<span class="w"> </span>        &quot;&quot;&quot;Yields all tokens up to token but excluding current.&quot;&quot;&quot;
<span class="gd">-        pass</span>
\ No newline at end of file
<span class="gi">+        if token is None:</span>
<span class="gi">+            return</span>
<span class="gi">+        parent = token.parent</span>
<span class="gi">+        if parent is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        for t in parent.tokens:</span>
<span class="gi">+            if t == token:</span>
<span class="gi">+                break</span>
<span class="gi">+            yield t</span>
<span class="gi">+</span>
<span class="gi">+    def _get_offset(self, token):</span>
<span class="gi">+        raw = str(token)</span>
<span class="gi">+        line = raw.splitlines()[0]</span>
<span class="gi">+        initial_whitespace = len(line) - len(line.lstrip())</span>
<span class="gi">+        return initial_whitespace</span>
<span class="gi">+</span>
<span class="gi">+    def _get_offset_at_depth(self, token, depth):</span>
<span class="gi">+        offset = 0</span>
<span class="gi">+        for t in self._flatten_up_to_token(token):</span>
<span class="gi">+            if t.is_whitespace:</span>
<span class="gi">+                continue</span>
<span class="gi">+            offset += self._get_offset(t)</span>
<span class="gi">+        return offset + (depth * self.width)</span>
<span class="gi">+</span>
<span class="gi">+    def process(self, stream):</span>
<span class="gi">+        &quot;&quot;&quot;Process the stream.&quot;&quot;&quot;</span>
<span class="gi">+        for token in stream:</span>
<span class="gi">+            if token.is_whitespace:</span>
<span class="gi">+                token.value = self.n</span>
<span class="gi">+                yield token</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if token.is_group:</span>
<span class="gi">+                depth = len(list(self._flatten_up_to_token(token)))</span>
<span class="gi">+                offset = self._get_offset_at_depth(token, depth)</span>
<span class="gi">+                token.value = self.char * offset + str(token)</span>
<span class="gi">+                yield token</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            yield token</span>
\ No newline at end of file
<span class="gh">diff --git a/sqlparse/formatter.py b/sqlparse/formatter.py</span>
<span class="gh">index f839b0c..8213340 100644</span>
<span class="gd">--- a/sqlparse/formatter.py</span>
<span class="gi">+++ b/sqlparse/formatter.py</span>
<span class="gu">@@ -4,7 +4,26 @@ from sqlparse.exceptions import SQLParseError</span>

<span class="w"> </span>def validate_options(options):
<span class="w"> </span>    &quot;&quot;&quot;Validates options.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if options is None:</span>
<span class="gi">+        options = {}</span>
<span class="gi">+</span>
<span class="gi">+    # Validate reindent option</span>
<span class="gi">+    if &#39;reindent&#39; in options and not isinstance(options.get(&#39;reindent&#39;), bool):</span>
<span class="gi">+        raise SQLParseError(&#39;Invalid value for reindent&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # Validate indent_width option</span>
<span class="gi">+    if &#39;indent_width&#39; in options:</span>
<span class="gi">+        indent_width = options.get(&#39;indent_width&#39;)</span>
<span class="gi">+        if not isinstance(indent_width, int) or indent_width &lt; 0:</span>
<span class="gi">+            raise SQLParseError(&#39;indent_width must be a positive integer&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # Validate keyword_case option</span>
<span class="gi">+    if &#39;keyword_case&#39; in options:</span>
<span class="gi">+        keyword_case = options.get(&#39;keyword_case&#39;)</span>
<span class="gi">+        if keyword_case not in (&#39;upper&#39;, &#39;lower&#39;, &#39;capitalize&#39;, None):</span>
<span class="gi">+            raise SQLParseError(&#39;Invalid value for keyword_case&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    return options</span>

<span class="w"> </span>def build_filter_stack(stack, options):
<span class="w"> </span>    &quot;&quot;&quot;Setup and return a filter stack.
<span class="gu">@@ -13,4 +32,42 @@ def build_filter_stack(stack, options):</span>
<span class="w"> </span>      stack: :class:`~sqlparse.filters.FilterStack` instance
<span class="w"> </span>      options: Dictionary with options validated by validate_options.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    # Process options</span>
<span class="gi">+    strip_comments = options.get(&#39;strip_comments&#39;, False)</span>
<span class="gi">+    strip_whitespace = options.get(&#39;strip_whitespace&#39;, False)</span>
<span class="gi">+    reindent = options.get(&#39;reindent&#39;, False)</span>
<span class="gi">+    indent_width = options.get(&#39;indent_width&#39;, 2)</span>
<span class="gi">+    keyword_case = options.get(&#39;keyword_case&#39;, None)</span>
<span class="gi">+    wrap_after = options.get(&#39;wrap_after&#39;, 0)</span>
<span class="gi">+    comma_first = options.get(&#39;comma_first&#39;, False)</span>
<span class="gi">+    right_margin = options.get(&#39;right_margin&#39;, None)</span>
<span class="gi">+    indent_after_first = options.get(&#39;indent_after_first&#39;, False)</span>
<span class="gi">+    indent_columns = options.get(&#39;indent_columns&#39;, False)</span>
<span class="gi">+    compact = options.get(&#39;compact&#39;, False)</span>
<span class="gi">+</span>
<span class="gi">+    # Enable grouping</span>
<span class="gi">+    stack.enable_grouping()</span>
<span class="gi">+</span>
<span class="gi">+    # Add filters</span>
<span class="gi">+    if strip_comments:</span>
<span class="gi">+        stack.preprocess.append(filters.StripCommentsFilter())</span>
<span class="gi">+</span>
<span class="gi">+    if strip_whitespace:</span>
<span class="gi">+        stack.preprocess.append(filters.StripWhitespaceFilter())</span>
<span class="gi">+</span>
<span class="gi">+    if reindent:</span>
<span class="gi">+        stack.preprocess.append(filters.ReindentFilter(</span>
<span class="gi">+            width=indent_width,</span>
<span class="gi">+            wrap_after=wrap_after,</span>
<span class="gi">+            comma_first=comma_first,</span>
<span class="gi">+            indent_after_first=indent_after_first,</span>
<span class="gi">+            indent_columns=indent_columns,</span>
<span class="gi">+            compact=compact))</span>
<span class="gi">+</span>
<span class="gi">+    if right_margin and not reindent:</span>
<span class="gi">+        stack.preprocess.append(filters.RightMarginFilter(right_margin))</span>
<span class="gi">+</span>
<span class="gi">+    if keyword_case:</span>
<span class="gi">+        stack.preprocess.append(filters.KeywordCaseFilter(keyword_case))</span>
<span class="gi">+</span>
<span class="gi">+    return stack</span>
\ No newline at end of file
<span class="gh">diff --git a/sqlparse/lexer.py b/sqlparse/lexer.py</span>
<span class="gh">index 28233c7..6e58633 100644</span>
<span class="gd">--- a/sqlparse/lexer.py</span>
<span class="gi">+++ b/sqlparse/lexer.py</span>
<span class="gu">@@ -15,28 +15,39 @@ class Lexer:</span>
<span class="w"> </span>    def get_default_instance(cls):
<span class="w"> </span>        &quot;&quot;&quot;Returns the lexer instance used internally
<span class="w"> </span>        by the sqlparse core functions.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with cls._lock:</span>
<span class="gi">+            if cls._default_instance is None:</span>
<span class="gi">+                cls._default_instance = cls()</span>
<span class="gi">+                cls._default_instance.default_initialization()</span>
<span class="gi">+            return cls._default_instance</span>

<span class="w"> </span>    def default_initialization(self):
<span class="w"> </span>        &quot;&quot;&quot;Initialize the lexer with default dictionaries.
<span class="w"> </span>        Useful if you need to revert custom syntax settings.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.clear()</span>
<span class="gi">+        self.add_keywords(keywords.KEYWORDS)</span>
<span class="gi">+        self.add_keywords(keywords.KEYWORDS_COMMON)</span>
<span class="gi">+        self.add_keywords(keywords.KEYWORDS_ORACLE)</span>
<span class="gi">+        self.add_keywords(keywords.KEYWORDS_PLPGSQL)</span>
<span class="gi">+        self.add_keywords(keywords.KEYWORDS_HQL)</span>
<span class="gi">+        self.add_keywords(keywords.KEYWORDS_MSACCESS)</span>

<span class="w"> </span>    def clear(self):
<span class="w"> </span>        &quot;&quot;&quot;Clear all syntax configurations.
<span class="w"> </span>        Useful if you want to load a reduced set of syntax configurations.
<span class="w"> </span>        After this call, regexps and keyword dictionaries need to be loaded
<span class="w"> </span>        to make the lexer functional again.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._keywords = []</span>
<span class="gi">+        self._SQL_REGEX = []</span>

<span class="w"> </span>    def set_SQL_REGEX(self, SQL_REGEX):
<span class="w"> </span>        &quot;&quot;&quot;Set the list of regex that will parse the SQL.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._SQL_REGEX = SQL_REGEX</span>

<span class="w"> </span>    def add_keywords(self, keywords):
<span class="w"> </span>        &quot;&quot;&quot;Add keyword dictionaries. Keywords are looked up in the same order
<span class="w"> </span>        that dictionaries were added.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._keywords.append(keywords)</span>

<span class="w"> </span>    def is_keyword(self, value):
<span class="w"> </span>        &quot;&quot;&quot;Checks for a keyword.
<span class="gu">@@ -44,7 +55,11 @@ class Lexer:</span>
<span class="w"> </span>        If the given value is in one of the KEYWORDS_* dictionary
<span class="w"> </span>        it&#39;s considered a keyword. Otherwise, tokens.Name is returned.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        val = value.upper()</span>
<span class="gi">+        for kwdict in self._keywords:</span>
<span class="gi">+            if val in kwdict:</span>
<span class="gi">+                return kwdict[val]</span>
<span class="gi">+        return tokens.Name</span>

<span class="w"> </span>    def get_tokens(self, text, encoding=None):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -59,7 +74,90 @@ class Lexer:</span>

<span class="w"> </span>        ``stack`` is the initial stack (default: ``[&#39;root&#39;]``)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(text, TextIOBase):</span>
<span class="gi">+            text = text.read()</span>
<span class="gi">+</span>
<span class="gi">+        if encoding is not None:</span>
<span class="gi">+            if isinstance(text, str):</span>
<span class="gi">+                text = text.encode(encoding)</span>
<span class="gi">+            text = text.decode(encoding)</span>
<span class="gi">+</span>
<span class="gi">+        iterable = enumerate(text)</span>
<span class="gi">+        for pos, char in iterable:</span>
<span class="gi">+            # Handle whitespace</span>
<span class="gi">+            if char.isspace():</span>
<span class="gi">+                end = pos + 1</span>
<span class="gi">+                while end &lt; len(text) and text[end].isspace():</span>
<span class="gi">+                    end += 1</span>
<span class="gi">+                consume(iterable, end - pos - 1)</span>
<span class="gi">+                yield tokens.Whitespace, text[pos:end]</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Handle comments</span>
<span class="gi">+            if char == &#39;-&#39; and text[pos + 1] == &#39;-&#39;:</span>
<span class="gi">+                end = text.find(&#39;\n&#39;, pos)</span>
<span class="gi">+                if end == -1:</span>
<span class="gi">+                    end = len(text)</span>
<span class="gi">+                consume(iterable, end - pos - 1)</span>
<span class="gi">+                yield tokens.Comment.Single, text[pos:end]</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Handle string literals</span>
<span class="gi">+            if char in (&#39;&quot;&#39;, &quot;&#39;&quot;):</span>
<span class="gi">+                end = pos + 1</span>
<span class="gi">+                escaped = False</span>
<span class="gi">+                while end &lt; len(text):</span>
<span class="gi">+                    if text[end] == char and not escaped:</span>
<span class="gi">+                        break</span>
<span class="gi">+                    if text[end] == &#39;\\&#39;:</span>
<span class="gi">+                        escaped = not escaped</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        escaped = False</span>
<span class="gi">+                    end += 1</span>
<span class="gi">+                if end &lt; len(text):</span>
<span class="gi">+                    end += 1</span>
<span class="gi">+                consume(iterable, end - pos - 1)</span>
<span class="gi">+                yield tokens.String, text[pos:end]</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Handle numbers</span>
<span class="gi">+            if char.isdigit():</span>
<span class="gi">+                end = pos + 1</span>
<span class="gi">+                while end &lt; len(text) and (text[end].isdigit() or text[end] == &#39;.&#39;):</span>
<span class="gi">+                    end += 1</span>
<span class="gi">+                consume(iterable, end - pos - 1)</span>
<span class="gi">+                yield tokens.Number, text[pos:end]</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Handle identifiers and keywords</span>
<span class="gi">+            if char.isalpha() or char == &#39;_&#39; or char == &#39;$&#39;:</span>
<span class="gi">+                end = pos + 1</span>
<span class="gi">+                while end &lt; len(text) and (text[end].isalnum() or text[end] in &#39;_$&#39;):</span>
<span class="gi">+                    end += 1</span>
<span class="gi">+                word = text[pos:end]</span>
<span class="gi">+                consume(iterable, end - pos - 1)</span>
<span class="gi">+                if word.upper() in (&#39;ASC&#39;, &#39;DESC&#39;):</span>
<span class="gi">+                    yield tokens.Keyword.Order, word</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield self.is_keyword(word), word</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Handle operators and punctuation</span>
<span class="gi">+            if char in &#39;+-*/%&lt;&gt;=!|&amp;~^&#39;:</span>
<span class="gi">+                end = pos + 1</span>
<span class="gi">+                while end &lt; len(text) and text[end] in &#39;+-*/%&lt;&gt;=!|&amp;~^&#39;:</span>
<span class="gi">+                    end += 1</span>
<span class="gi">+                consume(iterable, end - pos - 1)</span>
<span class="gi">+                yield tokens.Operator, text[pos:end]</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Handle punctuation</span>
<span class="gi">+            if char in &#39;()[]{},;.&#39;:</span>
<span class="gi">+                yield tokens.Punctuation, char</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Handle unknown characters</span>
<span class="gi">+            yield tokens.Error, char</span>

<span class="w"> </span>def tokenize(sql, encoding=None):
<span class="w"> </span>    &quot;&quot;&quot;Tokenize sql.
<span class="gu">@@ -67,4 +165,5 @@ def tokenize(sql, encoding=None):</span>
<span class="w"> </span>    Tokenize *sql* using the :class:`Lexer` and return a 2-tuple stream
<span class="w"> </span>    of ``(token type, value)`` items.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    lexer = Lexer.get_default_instance()</span>
<span class="gi">+    return lexer.get_tokens(sql, encoding)</span>
\ No newline at end of file
<span class="gh">diff --git a/sqlparse/sql.py b/sqlparse/sql.py</span>
<span class="gh">index 03b5e9f..74519d3 100644</span>
<span class="gd">--- a/sqlparse/sql.py</span>
<span class="gi">+++ b/sqlparse/sql.py</span>
<span class="gu">@@ -9,11 +9,11 @@ class NameAliasMixin:</span>

<span class="w"> </span>    def get_real_name(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns the real name (object name) of this identifier.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.get_name()</span>

<span class="w"> </span>    def get_alias(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns the alias for this identifier or ``None``.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return None</span>

<span class="w"> </span>class Token:
<span class="w"> </span>    &quot;&quot;&quot;Base class for all other classes in this module.
<span class="gu">@@ -38,6 +38,15 @@ class Token:</span>
<span class="w"> </span>    def __str__(self):
<span class="w"> </span>        return self.value

<span class="gi">+    def _get_repr_name(self):</span>
<span class="gi">+        return self.__class__.__name__</span>
<span class="gi">+</span>
<span class="gi">+    def _get_repr_value(self):</span>
<span class="gi">+        raw = str(self)</span>
<span class="gi">+        if len(raw) &gt; 7:</span>
<span class="gi">+            raw = raw[:7] + &#39;...&#39;</span>
<span class="gi">+        return raw</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        cls = self._get_repr_name()
<span class="w"> </span>        value = self._get_repr_value()
<span class="gu">@@ -46,7 +55,7 @@ class Token:</span>

<span class="w"> </span>    def flatten(self):
<span class="w"> </span>        &quot;&quot;&quot;Resolve subgroups.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        yield self</span>

<span class="w"> </span>    def match(self, ttype, values, regex=False):
<span class="w"> </span>        &quot;&quot;&quot;Checks whether the token matches the given arguments.
<span class="gu">@@ -60,7 +69,22 @@ class Token:</span>
<span class="w"> </span>        If *regex* is ``True`` (default is ``False``) the given values are
<span class="w"> </span>        treated as regular expressions.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if ttype is not None and not imt(self, t=ttype):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        if values is None:</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(values, str):</span>
<span class="gi">+            values = (values,)</span>
<span class="gi">+</span>
<span class="gi">+        if regex:</span>
<span class="gi">+            pattern = &#39;|&#39;.join(&#39;(?:{0})&#39;.format(v) for v in values)</span>
<span class="gi">+            return bool(re.search(pattern, self.normalized if self.is_keyword else self.value, re.IGNORECASE if self.is_keyword else 0))</span>
<span class="gi">+</span>
<span class="gi">+        if self.is_keyword:</span>
<span class="gi">+            return self.normalized in [v.upper() for v in values]</span>
<span class="gi">+        return self.value in values</span>

<span class="w"> </span>    def within(self, group_cls):
<span class="w"> </span>        &quot;&quot;&quot;Returns ``True`` if this token is within *group_cls*.
<span class="gu">@@ -68,15 +92,25 @@ class Token:</span>
<span class="w"> </span>        Use this method for example to check if an identifier is within
<span class="w"> </span>        a function: ``t.within(sql.Function)``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parent = self.parent</span>
<span class="gi">+        while parent:</span>
<span class="gi">+            if isinstance(parent, group_cls):</span>
<span class="gi">+                return True</span>
<span class="gi">+            parent = parent.parent</span>
<span class="gi">+        return False</span>

<span class="w"> </span>    def is_child_of(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Returns ``True`` if this token is a direct child of *other*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.parent == other</span>

<span class="w"> </span>    def has_ancestor(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Returns ``True`` if *other* is in this tokens ancestry.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parent = self.parent</span>
<span class="gi">+        while parent:</span>
<span class="gi">+            if parent == other:</span>
<span class="gi">+                return True</span>
<span class="gi">+            parent = parent.parent</span>
<span class="gi">+        return False</span>

<span class="w"> </span>class TokenList(Token):
<span class="w"> </span>    &quot;&quot;&quot;A group of tokens.
<span class="gu">@@ -103,22 +137,57 @@ class TokenList(Token):</span>

<span class="w"> </span>    def _pprint_tree(self, max_depth=None, depth=0, f=None, _pre=&#39;&#39;):
<span class="w"> </span>        &quot;&quot;&quot;Pretty-print the object tree.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if max_depth and depth &gt; max_depth:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        indent = &#39; &#39; * (depth * 2)</span>
<span class="gi">+        for token in self.tokens:</span>
<span class="gi">+            cls = token._get_repr_name()</span>
<span class="gi">+            value = token._get_repr_value()</span>
<span class="gi">+            if token.is_group:</span>
<span class="gi">+                token._pprint_tree(max_depth, depth + 1, f, _pre)</span>
<span class="gi">+            else:</span>
<span class="gi">+                f.write(&#39;{}{}{} {}\n&#39;.format(_pre, indent, cls, value))</span>

<span class="w"> </span>    def get_token_at_offset(self, offset):
<span class="w"> </span>        &quot;&quot;&quot;Returns the token that is on position offset.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        idx = 0</span>
<span class="gi">+        for token in self.flatten():</span>
<span class="gi">+            end = idx + len(token.value)</span>
<span class="gi">+            if idx &lt;= offset &lt; end:</span>
<span class="gi">+                return token</span>
<span class="gi">+            idx = end</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def flatten(self):
<span class="w"> </span>        &quot;&quot;&quot;Generator yielding ungrouped tokens.

<span class="w"> </span>        This method is recursively called for all child tokens.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for token in self.tokens:</span>
<span class="gi">+            if token.is_group:</span>
<span class="gi">+                for t in token.flatten():</span>
<span class="gi">+                    yield t</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield token</span>

<span class="w"> </span>    def _token_matching(self, funcs, start=0, end=None, reverse=False):
<span class="w"> </span>        &quot;&quot;&quot;next token that match functions&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(funcs, (list, tuple)):</span>
<span class="gi">+            funcs = (funcs,)</span>
<span class="gi">+</span>
<span class="gi">+        if end is None:</span>
<span class="gi">+            end = len(self.tokens)</span>
<span class="gi">+</span>
<span class="gi">+        tokens = self.tokens[start:end]</span>
<span class="gi">+        if reverse:</span>
<span class="gi">+            tokens = reversed(tokens)</span>
<span class="gi">+</span>
<span class="gi">+        for token in tokens:</span>
<span class="gi">+            for func in funcs:</span>
<span class="gi">+                if func(token):</span>
<span class="gi">+                    return token</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def token_first(self, skip_ws=True, skip_cm=False):
<span class="w"> </span>        &quot;&quot;&quot;Returns the first child token.
<span class="gu">@@ -129,7 +198,12 @@ class TokenList(Token):</span>
<span class="w"> </span>        if *skip_cm* is ``True`` (default: ``False``), comments are
<span class="w"> </span>        ignored too.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        funcs = []</span>
<span class="gi">+        if skip_ws:</span>
<span class="gi">+            funcs.append(lambda t: not t.is_whitespace)</span>
<span class="gi">+        if skip_cm:</span>
<span class="gi">+            funcs.append(lambda t: not isinstance(t, Comment))</span>
<span class="gi">+        return self._token_matching(funcs)</span>

<span class="w"> </span>    def token_prev(self, idx, skip_ws=True, skip_cm=False):
<span class="w"> </span>        &quot;&quot;&quot;Returns the previous token relative to *idx*.
<span class="gu">@@ -138,7 +212,12 @@ class TokenList(Token):</span>
<span class="w"> </span>        If *skip_cm* is ``True`` comments are ignored.
<span class="w"> </span>        ``None`` is returned if there&#39;s no previous token.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        funcs = []</span>
<span class="gi">+        if skip_ws:</span>
<span class="gi">+            funcs.append(lambda t: not t.is_whitespace)</span>
<span class="gi">+        if skip_cm:</span>
<span class="gi">+            funcs.append(lambda t: not isinstance(t, Comment))</span>
<span class="gi">+        return self._token_matching(funcs, 0, idx, reverse=True)</span>

<span class="w"> </span>    def token_next(self, idx, skip_ws=True, skip_cm=False, _reverse=False):
<span class="w"> </span>        &quot;&quot;&quot;Returns the next token relative to *idx*.
<span class="gu">@@ -147,27 +226,86 @@ class TokenList(Token):</span>
<span class="w"> </span>        If *skip_cm* is ``True`` comments are ignored.
<span class="w"> </span>        ``None`` is returned if there&#39;s no next token.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        funcs = []</span>
<span class="gi">+        if skip_ws:</span>
<span class="gi">+            funcs.append(lambda t: not t.is_whitespace)</span>
<span class="gi">+        if skip_cm:</span>
<span class="gi">+            funcs.append(lambda t: not isinstance(t, Comment))</span>
<span class="gi">+        return self._token_matching(funcs, idx + 1)</span>

<span class="w"> </span>    def token_index(self, token, start=0):
<span class="w"> </span>        &quot;&quot;&quot;Return list index of token.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for idx, t in enumerate(self.tokens[start:], start=start):</span>
<span class="gi">+            if token is t:</span>
<span class="gi">+                return idx</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def token_matching(self, token, idx):</span>
<span class="gi">+        &quot;&quot;&quot;Returns the matching token for a token at given index.&quot;&quot;&quot;</span>
<span class="gi">+        if not token.is_group:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        if not hasattr(token, &#39;M_OPEN&#39;) or not hasattr(token, &#39;M_CLOSE&#39;):</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        open_token = token.match(*token.M_OPEN)</span>
<span class="gi">+        close_token = token.match(*token.M_CLOSE)</span>
<span class="gi">+</span>
<span class="gi">+        if not open_token or not close_token:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        depth = 1</span>
<span class="gi">+        for t_idx, t in enumerate(self.tokens[idx + 1:], start=idx + 1):</span>
<span class="gi">+            if t.match(*token.M_OPEN):</span>
<span class="gi">+                depth += 1</span>
<span class="gi">+            elif t.match(*token.M_CLOSE):</span>
<span class="gi">+                depth -= 1</span>
<span class="gi">+                if depth == 0:</span>
<span class="gi">+                    return t_idx</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def group_tokens(self, grp_cls, start, end, include_end=True, extend=False):
<span class="w"> </span>        &quot;&quot;&quot;Replace tokens by an instance of *grp_cls*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(start, int):</span>
<span class="gi">+            start = self.token_index(start)</span>
<span class="gi">+        if not isinstance(end, int):</span>
<span class="gi">+            end = self.token_index(end)</span>
<span class="gi">+</span>
<span class="gi">+        if extend:</span>
<span class="gi">+            while end &lt; len(self.tokens) - 1:</span>
<span class="gi">+                if isinstance(self.tokens[end + 1], (Comment, None)):</span>
<span class="gi">+                    end += 1</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+        if include_end:</span>
<span class="gi">+            end += 1</span>
<span class="gi">+</span>
<span class="gi">+        grp = grp_cls(self.tokens[start:end])</span>
<span class="gi">+        self.tokens[start:end] = [grp]</span>
<span class="gi">+        return grp</span>

<span class="w"> </span>    def insert_before(self, where, token):
<span class="w"> </span>        &quot;&quot;&quot;Inserts *token* before *where*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(where, int):</span>
<span class="gi">+            where = self.token_index(where)</span>
<span class="gi">+        token.parent = self</span>
<span class="gi">+        self.tokens.insert(where, token)</span>

<span class="w"> </span>    def insert_after(self, where, token, skip_ws=True):
<span class="w"> </span>        &quot;&quot;&quot;Inserts *token* after *where*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(where, int):</span>
<span class="gi">+            where = self.token_index(where)</span>
<span class="gi">+        if skip_ws:</span>
<span class="gi">+            next_token = self.token_next(where)</span>
<span class="gi">+            if next_token is not None:</span>
<span class="gi">+                where = self.token_index(next_token) - 1</span>
<span class="gi">+        token.parent = self</span>
<span class="gi">+        self.tokens.insert(where + 1, token)</span>

<span class="w"> </span>    def has_alias(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns ``True`` if an alias is present.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.get_alias() is not None</span>

<span class="w"> </span>    def get_alias(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns the alias for this identifier or ``None``.&quot;&quot;&quot;
<span class="gu">@@ -180,22 +318,46 @@ class TokenList(Token):</span>
<span class="w"> </span>        be considered as the name under which the object corresponding to
<span class="w"> </span>        this identifier is known within the current statement.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        alias = self.get_alias()</span>
<span class="gi">+        if alias:</span>
<span class="gi">+            return alias</span>
<span class="gi">+        return self.get_real_name()</span>

<span class="w"> </span>    def get_real_name(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns the real name (object name) of this identifier.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Return the first token&#39;s value as real name</span>
<span class="gi">+        token = self.token_next(0)</span>
<span class="gi">+        if token is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return token.value</span>

<span class="w"> </span>    def get_parent_name(self):
<span class="w"> </span>        &quot;&quot;&quot;Return name of the parent object if any.

<span class="w"> </span>        A parent object is identified by the first occurring dot.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        dot = self.token_next_by(m=(T.Punctuation, &#39;.&#39;))</span>
<span class="gi">+        if dot is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        prev_ = self.token_prev(self.token_index(dot))</span>
<span class="gi">+        if prev_ is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return prev_.value</span>

<span class="w"> </span>    def _get_first_name(self, idx=None, reverse=False, keywords=False, real_name=False):
<span class="w"> </span>        &quot;&quot;&quot;Returns the name of the first token with a name&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        tokens = self.tokens[idx:] if idx else self.tokens</span>
<span class="gi">+        if reverse:</span>
<span class="gi">+            tokens = reversed(tokens)</span>
<span class="gi">+</span>
<span class="gi">+        for token in tokens:</span>
<span class="gi">+            if token.ttype in T.Name or (keywords and token.is_keyword):</span>
<span class="gi">+                return token.get_real_name() if real_name else token.get_name()</span>
<span class="gi">+            if token.is_group:</span>
<span class="gi">+                name = token._get_first_name(reverse=reverse, keywords=keywords, real_name=real_name)</span>
<span class="gi">+                if name is not None:</span>
<span class="gi">+                    return name</span>
<span class="gi">+        return None</span>

<span class="w"> </span>class Statement(TokenList):
<span class="w"> </span>    &quot;&quot;&quot;Represents a SQL statement.&quot;&quot;&quot;
<span class="gu">@@ -210,7 +372,13 @@ class Statement(TokenList):</span>
<span class="w"> </span>        Whitespaces and comments at the beginning of the statement
<span class="w"> </span>        are ignored.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        first_token = self.token_first()</span>
<span class="gi">+        if first_token is None:</span>
<span class="gi">+            return &#39;UNKNOWN&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if first_token.ttype in (T.Keyword.DML, T.Keyword.DDL):</span>
<span class="gi">+            return first_token.normalized</span>
<span class="gi">+        return &#39;UNKNOWN&#39;</span>

<span class="w"> </span>class Identifier(NameAliasMixin, TokenList):
<span class="w"> </span>    &quot;&quot;&quot;Represents an identifier.
<span class="gu">@@ -220,19 +388,31 @@ class Identifier(NameAliasMixin, TokenList):</span>

<span class="w"> </span>    def is_wildcard(self):
<span class="w"> </span>        &quot;&quot;&quot;Return ``True`` if this identifier contains a wildcard.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        token = self.token_next_by(t=T.Wildcard)</span>
<span class="gi">+        return token is not None</span>

<span class="w"> </span>    def get_typecast(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns the typecast or ``None`` of this object as a string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        marker = self.token_next_by(m=(T.Punctuation, &#39;::&#39;))</span>
<span class="gi">+        if marker is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        next_ = self.token_next(self.token_index(marker))</span>
<span class="gi">+        if next_ is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return next_.value</span>

<span class="w"> </span>    def get_ordering(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns the ordering or ``None`` as uppercase string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ordering = self.token_next_by(t=T.Keyword.Order)</span>
<span class="gi">+        if ordering is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return ordering.normalized</span>

<span class="w"> </span>    def get_array_indices(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns an iterator of index token lists&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for token in self.tokens:</span>
<span class="gi">+            if isinstance(token, SquareBrackets):</span>
<span class="gi">+                yield token</span>

<span class="w"> </span>class IdentifierList(TokenList):
<span class="w"> </span>    &quot;&quot;&quot;A list of :class:`~sqlparse.sql.Identifier`&#39;s.&quot;&quot;&quot;
<span class="gu">@@ -242,7 +422,9 @@ class IdentifierList(TokenList):</span>

<span class="w"> </span>        Whitespaces and punctuations are not included in this generator.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for token in self.tokens:</span>
<span class="gi">+            if isinstance(token, (Identifier, Function)):</span>
<span class="gi">+                yield token</span>

<span class="w"> </span>class TypedLiteral(TokenList):
<span class="w"> </span>    &quot;&quot;&quot;A typed literal, such as &quot;date &#39;2001-09-28&#39;&quot; or &quot;interval &#39;2 hours&#39;&quot;.&quot;&quot;&quot;
<span class="gu">@@ -303,18 +485,60 @@ class Case(TokenList):</span>

<span class="w"> </span>        If an ELSE exists condition is None.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ELSE = T.Keyword, &#39;ELSE&#39;</span>
<span class="gi">+        WHEN = T.Keyword, &#39;WHEN&#39;</span>
<span class="gi">+        THEN = T.Keyword, &#39;THEN&#39;</span>
<span class="gi">+</span>
<span class="gi">+        results = []</span>
<span class="gi">+        condition = None</span>
<span class="gi">+        value = None</span>
<span class="gi">+        for token in self.tokens:</span>
<span class="gi">+            if token.match(*WHEN):</span>
<span class="gi">+                condition = []</span>
<span class="gi">+            elif token.match(*THEN):</span>
<span class="gi">+                value = []</span>
<span class="gi">+            elif token.match(*ELSE):</span>
<span class="gi">+                condition = None</span>
<span class="gi">+                value = []</span>
<span class="gi">+            elif condition is not None and value is None:</span>
<span class="gi">+                condition.append(token)</span>
<span class="gi">+            elif value is not None:</span>
<span class="gi">+                value.append(token)</span>
<span class="gi">+                if token.is_group and token.tokens[-1].match(T.Keyword, &#39;END&#39;):</span>
<span class="gi">+                    results.append((condition, value))</span>
<span class="gi">+                    condition = None</span>
<span class="gi">+                    value = None</span>
<span class="gi">+</span>
<span class="gi">+        if value is not None:</span>
<span class="gi">+            results.append((condition, value))</span>
<span class="gi">+</span>
<span class="gi">+        return results</span>

<span class="w"> </span>class Function(NameAliasMixin, TokenList):
<span class="w"> </span>    &quot;&quot;&quot;A function or procedure call.&quot;&quot;&quot;

<span class="w"> </span>    def get_parameters(self):
<span class="w"> </span>        &quot;&quot;&quot;Return a list of parameters.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parenthesis = self.token_next_by(i=Parenthesis)</span>
<span class="gi">+        if parenthesis is None:</span>
<span class="gi">+            return []</span>
<span class="gi">+        return [token for token in parenthesis.tokens[1:-1]</span>
<span class="gi">+                if not token.is_whitespace]</span>

<span class="w"> </span>    def get_window(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the window if it exists.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        over = self.token_next_by(m=(T.Keyword, &#39;OVER&#39;))</span>
<span class="gi">+        if over is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        over_idx = self.token_index(over)</span>
<span class="gi">+        window = self.token_next(over_idx)</span>
<span class="gi">+        if window is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(window, Parenthesis):</span>
<span class="gi">+            return window</span>
<span class="gi">+        return None</span>

<span class="w"> </span>class Begin(TokenList):
<span class="w"> </span>    &quot;&quot;&quot;A BEGIN/END block.&quot;&quot;&quot;
<span class="gh">diff --git a/sqlparse/utils.py b/sqlparse/utils.py</span>
<span class="gh">index cf2e1ab..7758206 100644</span>
<span class="gd">--- a/sqlparse/utils.py</span>
<span class="gi">+++ b/sqlparse/utils.py</span>
<span class="gu">@@ -10,11 +10,37 @@ def split_unquoted_newlines(stmt):</span>

<span class="w"> </span>    Unlike str.splitlines(), this will ignore CR/LF/CR+LF if the requisite
<span class="w"> </span>    character is inside of a string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    matches = SPLIT_REGEX.finditer(stmt)</span>
<span class="gi">+    matches = list(matches)</span>
<span class="gi">+    if not matches:</span>
<span class="gi">+        return [stmt]</span>
<span class="gi">+</span>
<span class="gi">+    # If there are no matches, return the string as is</span>
<span class="gi">+    if not matches:</span>
<span class="gi">+        return [stmt]</span>
<span class="gi">+</span>
<span class="gi">+    pieces = []</span>
<span class="gi">+    last_end = 0</span>
<span class="gi">+    for match in matches:</span>
<span class="gi">+        start, end = match.span()</span>
<span class="gi">+        if start &gt; last_end:</span>
<span class="gi">+            pieces.append(stmt[last_end:start])</span>
<span class="gi">+        pieces.append(stmt[start:end])</span>
<span class="gi">+        last_end = end</span>
<span class="gi">+</span>
<span class="gi">+    if last_end &lt; len(stmt):</span>
<span class="gi">+        pieces.append(stmt[last_end:])</span>
<span class="gi">+</span>
<span class="gi">+    return pieces</span>

<span class="w"> </span>def remove_quotes(val):
<span class="w"> </span>    &quot;&quot;&quot;Helper that removes surrounding quotes from strings.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not val:</span>
<span class="gi">+        return val</span>
<span class="gi">+</span>
<span class="gi">+    if val[0] in (&#39;&quot;&#39;, &quot;&#39;&quot;, &#39;`&#39;) and val[-1] == val[0]:</span>
<span class="gi">+        return val[1:-1]</span>
<span class="gi">+    return val</span>

<span class="w"> </span>def recurse(*cls):
<span class="w"> </span>    &quot;&quot;&quot;Function decorator to help with recursion
<span class="gu">@@ -22,7 +48,16 @@ def recurse(*cls):</span>
<span class="w"> </span>    :param cls: Classes to not recurse over
<span class="w"> </span>    :return: function
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def wrap(f):</span>
<span class="gi">+        def wrapped(tlist):</span>
<span class="gi">+            for token in tlist.tokens:</span>
<span class="gi">+                if not isinstance(token, cls):</span>
<span class="gi">+                    for t in token.flatten():</span>
<span class="gi">+                        if isinstance(t, cls):</span>
<span class="gi">+                            f(t)</span>
<span class="gi">+            f(tlist)</span>
<span class="gi">+        return wrapped</span>
<span class="gi">+    return wrap</span>

<span class="w"> </span>def imt(token, i=None, m=None, t=None):
<span class="w"> </span>    &quot;&quot;&quot;Helper function to simplify comparisons Instance, Match and TokenType
<span class="gu">@@ -32,8 +67,48 @@ def imt(token, i=None, m=None, t=None):</span>
<span class="w"> </span>    :param t: TokenType or Tuple/List of TokenTypes
<span class="w"> </span>    :return:  bool
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if i is not None and isinstance(i, (list, tuple)):</span>
<span class="gi">+        for cls in i:</span>
<span class="gi">+            if isinstance(token, cls):</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if i is not None:</span>
<span class="gi">+        return isinstance(token, i)</span>
<span class="gi">+</span>
<span class="gi">+    if m is not None and isinstance(m, (list, tuple)) and not isinstance(m[0], tuple):</span>
<span class="gi">+        m = [m]</span>
<span class="gi">+</span>
<span class="gi">+    if m is not None:</span>
<span class="gi">+        for m_ttype, m_value in m:</span>
<span class="gi">+            if token.match(m_ttype, m_value):</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if t is not None and isinstance(t, (list, tuple)):</span>
<span class="gi">+        for ttype in t:</span>
<span class="gi">+            if token.ttype is ttype:</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if t is not None:</span>
<span class="gi">+        return token.ttype is t</span>
<span class="gi">+</span>
<span class="gi">+    return True</span>

<span class="w"> </span>def consume(iterator, n):
<span class="w"> </span>    &quot;&quot;&quot;Advance the iterator n-steps ahead. If n is none, consume entirely.&quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    deque(itertools.islice(iterator, n), maxlen=0) if n is not None else deque(iterator, maxlen=0)</span>
<span class="gi">+</span>
<span class="gi">+def offset(token):</span>
<span class="gi">+    &quot;&quot;&quot;Returns the indentation offset of a token.&quot;&quot;&quot;</span>
<span class="gi">+    line = token.value.splitlines()[0]</span>
<span class="gi">+    initial_whitespace = len(line) - len(line.lstrip())</span>
<span class="gi">+    return initial_whitespace</span>
<span class="gi">+</span>
<span class="gi">+def indent(stream, n=2, char=&#39; &#39;):</span>
<span class="gi">+    &quot;&quot;&quot;Returns a stream of tokens with each token indented by n characters.&quot;&quot;&quot;</span>
<span class="gi">+    for token in stream:</span>
<span class="gi">+        token.value = &#39;\n&#39;.join(char * n + line if line else &#39;&#39;</span>
<span class="gi">+                               for line in token.value.splitlines())</span>
<span class="gi">+        yield token</span>
\ No newline at end of file
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>