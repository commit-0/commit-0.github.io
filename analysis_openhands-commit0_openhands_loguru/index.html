
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis openhands commit0 openhands loguru - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#openhands-loguru" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis openhands commit0 openhands loguru
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_activationpytest_disabletest-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_activation.py::test_disable[test-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_activationpytest_disabletestss-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_activation.py::test_disable[testss-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_activationpytest_disabletests-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_activation.py::test_disable[tests.-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_activationpytest_disableteststest_activation-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_activation.py::test_disable[tests.test_activation.-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_activationpytest_disabletest_activation-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_activation.py::test_disable[test_activation-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_activationpytest_disable-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_activation.py::test_disable[.-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_activationpytest_enable-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_activation.py::test_enable[-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_activationpytest_enabletests-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_activation.py::test_enable[tests-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_activationpytest_enableteststest_activation-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_activation.py::test_enable[tests.test_activation-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_activationpytest_log_before_enable" class="md-nav__link">
    <span class="md-ellipsis">
      test_activation.py::test_log_before_enable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_activationpytest_log_before_disable" class="md-nav__link">
    <span class="md-ellipsis">
      test_activation.py::test_log_before_disable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_activationpytest_multiple_activations" class="md-nav__link">
    <span class="md-ellipsis">
      test_activation.py::test_multiple_activations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_activationpytest_log_before_enable_f_globals_name_absent" class="md-nav__link">
    <span class="md-ellipsis">
      test_activation.py::test_log_before_enable_f_globals_name_absent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_activationpytest_log_before_disable_f_globals_name_absent" class="md-nav__link">
    <span class="md-ellipsis">
      test_activation.py::test_log_before_disable_f_globals_name_absent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_activationpytest_f_globals_name_absent_with_others" class="md-nav__link">
    <span class="md-ellipsis">
      test_activation.py::test_f_globals_name_absent_with_others
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_activationpytest_invalid_enable_name42" class="md-nav__link">
    <span class="md-ellipsis">
      test_activation.py::test_invalid_enable_name[42]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_activationpytest_invalid_enable_namename1" class="md-nav__link">
    <span class="md-ellipsis">
      test_activation.py::test_invalid_enable_name[name1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_activationpytest_invalid_enable_namename2" class="md-nav__link">
    <span class="md-ellipsis">
      test_activation.py::test_invalid_enable_name[name2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_activationpytest_invalid_disable_name42" class="md-nav__link">
    <span class="md-ellipsis">
      test_activation.py::test_invalid_disable_name[42]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_activationpytest_invalid_disable_namename1" class="md-nav__link">
    <span class="md-ellipsis">
      test_activation.py::test_invalid_disable_name[name1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_activationpytest_invalid_disable_namename2" class="md-nav__link">
    <span class="md-ellipsis">
      test_activation.py::test_invalid_disable_name[name2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_backtracepytest_backtrace" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_backtrace.py::test_backtrace
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_catchpytest_catch_is_true" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_catch.py::test_catch_is_true
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_catchpytest_catch_is_false" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_catch.py::test_catch_is_false
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_catchpytest_encoding_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_catch.py::test_encoding_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_catchpytest_unprintable_record" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_catch.py::test_unprintable_record
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_catchpytest_broken_sink_messagefalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_catch.py::test_broken_sink_message[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_catchpytest_broken_sink_messagetrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_catch.py::test_broken_sink_message[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_catchpytest_broken_sink_caught_keep_workingfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_catch.py::test_broken_sink_caught_keep_working[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_catchpytest_broken_sink_caught_keep_workingtrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_catch.py::test_broken_sink_caught_keep_working[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_catchpytest_broken_sink_not_caught_enqueue" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_catch.py::test_broken_sink_not_caught_enqueue
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_contextpytest_using_multiprocessing_directly_if_context_is_none" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_context.py::test_using_multiprocessing_directly_if_context_is_none
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_contextpytest_fork_context_as_stringfork" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_context.py::test_fork_context_as_string[fork]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_contextpytest_fork_context_as_stringforkserver" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_context.py::test_fork_context_as_string[forkserver]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_contextpytest_spawn_context_as_string" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_context.py::test_spawn_context_as_string
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_contextpytest_fork_context_as_objectfork" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_context.py::test_fork_context_as_object[fork]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_contextpytest_fork_context_as_objectforkserver" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_context.py::test_fork_context_as_object[forkserver]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_contextpytest_spawn_context_as_object" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_context.py::test_spawn_context_as_object
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_contextpytest_invalid_context_name" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_context.py::test_invalid_context_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_contextpytest_invalid_context_object42" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_context.py::test_invalid_context_object[42]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_contextpytest_invalid_context_objectcontext1" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_context.py::test_invalid_context_object[context1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_diagnosepytest_diagnose" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_diagnose.py::test_diagnose
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_enqueuepytest_enqueue" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_enqueue.py::test_enqueue
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_enqueuepytest_enqueue_with_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_enqueue.py::test_enqueue_with_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_enqueuepytest_caught_exception_queue_put" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_enqueue.py::test_caught_exception_queue_put
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_enqueuepytest_caught_exception_queue_get" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_enqueue.py::test_caught_exception_queue_get
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_enqueuepytest_caught_exception_sink_write" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_enqueue.py::test_caught_exception_sink_write
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_enqueuepytest_not_caught_exception_queue_put" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_enqueue.py::test_not_caught_exception_queue_put
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_enqueuepytest_not_caught_exception_queue_get" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_enqueue.py::test_not_caught_exception_queue_get
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_enqueuepytest_not_caught_exception_sink_write" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_enqueue.py::test_not_caught_exception_sink_write
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_enqueuepytest_not_caught_exception_sink_write_then_complete" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_enqueue.py::test_not_caught_exception_sink_write_then_complete
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_enqueuepytest_not_caught_exception_queue_get_then_complete" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_enqueue.py::test_not_caught_exception_queue_get_then_complete
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_enqueuepytest_wait_for_all_messages_enqueued" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_enqueue.py::test_wait_for_all_messages_enqueued
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_enqueuepytest_logging_not_picklable_exceptionexception_value0" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_enqueue.py::test_logging_not_picklable_exception[exception_value0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_enqueuepytest_logging_not_picklable_exceptionexception_value1" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_enqueue.py::test_logging_not_picklable_exception[exception_value1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_enqueuepytest_logging_not_unpicklable_exceptionexception_value0" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_enqueue.py::test_logging_not_unpicklable_exception[exception_value0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_enqueuepytest_logging_not_unpicklable_exceptionexception_value1" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_enqueue.py::test_logging_not_unpicklable_exception[exception_value1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_filterd_innone" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_filterd_in[None]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_filterd_in" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_filterd_in[]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_filterd_intests" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_filterd_in[tests]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_filterd_inteststest_add_option_filter" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_filterd_in[tests.test_add_option_filter]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_filterd_in0" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_filterd_in[0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_filterd_in1" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_filterd_in[1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_filterd_infilter6" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_filterd_in[filter6]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_filterd_infilter7" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_filterd_in[filter7]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_filterd_infilter8" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_filterd_in[filter8]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_filterd_infilter9" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_filterd_in[filter9]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_filterd_infilter10" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_filterd_in[filter10]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_filterd_infilter11" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_filterd_in[filter11]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_filterd_infilter12" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_filterd_in[filter12]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_filterd_infilter13" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_filterd_in[filter13]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_filterd_infilter14" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_filterd_in[filter14]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_filtered_in_f_globals_name_absentnone" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_filtered_in_f_globals_name_absent[None]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_filtered_in_f_globals_name_absent" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_filtered_in_f_globals_name_absent[]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_filtered_in_f_globals_name_absentfilter2" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_filtered_in_f_globals_name_absent[filter2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_filtered_in_f_globals_name_absentfilter3" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_filtered_in_f_globals_name_absent[filter3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_filtered_in_f_globals_name_absentfilter4" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_filtered_in_f_globals_name_absent[filter4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_filtered_in_f_globals_name_absentfilter5" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_filtered_in_f_globals_name_absent[filter5]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_filtered_in_f_globals_name_absentfilter6" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_filtered_in_f_globals_name_absent[filter6]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_filtered_in_f_globals_name_absentfilter7" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_filtered_in_f_globals_name_absent[filter7]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_invalid_filter-1" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_invalid_filter[-1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_invalid_filter34" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_invalid_filter[3.4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_invalid_filterfilter2" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_invalid_filter[filter2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_invalid_filter_dict_typesfilter0" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_invalid_filter_dict_types[filter0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_invalid_filter_dict_typesfilter1" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_invalid_filter_dict_types[filter1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_invalid_filter_dict_typesfilter2" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_invalid_filter_dict_types[filter2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_invalid_filter_dict_typesfilter3" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_invalid_filter_dict_types[filter3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_invalid_filter_dict_typesfilter4" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_invalid_filter_dict_types[filter4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_invalid_filter_dict_valuesfilter0" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_invalid_filter_dict_values[filter0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_invalid_filter_dict_valuesfilter1" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_invalid_filter_dict_values[filter1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_invalid_filter_dict_valuesfilter2" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_invalid_filter_dict_values[filter2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_filter_dict_with_custom_level" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_filter_dict_with_custom_level
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_filterpytest_invalid_filter_builtin" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_filter.py::test_invalid_filter_builtin
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_formatpytest_formata-message-message-message-an" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_format.py::test_format[a-Message: {message}-Message: a\n]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_formatpytest_formatb-nope-nopen" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_format.py::test_format[b-Nope-Nope\n]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_formatpytest_formatc-level-message-level-debug-c-debugn" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_format.py::test_format[c-{level} {message} {level}-DEBUG c DEBUG\n]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_formatpytest_formatd-message-level-levelno-levelname-d-debug-10-debugn" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_format.py::test_format[d-{message} {level} {level.no} {level.name}-d DEBUG 10 DEBUG\n]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_formatpytest_formate-e" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_format.py::test_format[e--e]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_formatpytest_formatf-f-debug" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_format.py::test_format[f--f DEBUG]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_formatpytest_progressive_format" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_format.py::test_progressive_format
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_formatpytest_function_format_without_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_format.py::test_function_format_without_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_formatpytest_function_format_with_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_format.py::test_function_format_with_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_formatpytest_invalid_format-1" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_format.py::test_invalid_format[-1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_formatpytest_invalid_format34" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_format.py::test_invalid_format[3.4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_formatpytest_invalid_formatformat2" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_format.py::test_invalid_format[format2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_formatpytest_invalid_markups" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_format.py::test_invalid_markups[]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#red" class="md-nav__link">
    <span class="md-ellipsis">
      red&gt;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#level" class="md-nav__link">
    <span class="md-ellipsis">
      level&gt;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      &gt;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_formatpytest_invalid_markups_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_format.py::test_invalid_markups[]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_formatpytest_markup_in_fieldtrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_format.py::test_markup_in_field[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_formatpytest_markup_in_fieldfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_format.py::test_markup_in_field[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_formatpytest_invalid_format_builtin" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_format.py::test_invalid_format_builtin
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_kwargspytest_file_mode_a" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_kwargs.py::test_file_mode_a
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_kwargspytest_file_mode_w" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_kwargs.py::test_file_mode_w
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_kwargspytest_file_auto_buffering" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_kwargs.py::test_file_auto_buffering
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_kwargspytest_file_line_buffering" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_kwargs.py::test_file_line_buffering
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_kwargspytest_invalid_function_kwargs" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_kwargs.py::test_invalid_function_kwargs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_kwargspytest_invalid_file_object_kwargs" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_kwargs.py::test_invalid_file_object_kwargs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_kwargspytest_invalid_file_kwargs" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_kwargs.py::test_invalid_file_kwargs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_kwargspytest_invalid_coroutine_kwargs" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_kwargs.py::test_invalid_coroutine_kwargs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_levelpytest_level_low_enough0" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_level.py::test_level_low_enough[0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_levelpytest_level_low_enoughtrace" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_level.py::test_level_low_enough[TRACE]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_levelpytest_level_low_enoughinfo" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_level.py::test_level_low_enough[INFO]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_levelpytest_level_low_enough20" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_level.py::test_level_low_enough[20]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_levelpytest_invalid_level34" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_level.py::test_invalid_level[3.4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_levelpytest_invalid_levellevel1" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_level.py::test_invalid_level[level1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_levelpytest_unknown_levelfoo" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_level.py::test_unknown_level[foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_levelpytest_unknown_level-1" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_level.py::test_unknown_level[-1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_serializepytest_serialize" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_serialize.py::test_serialize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_serializepytest_serialize_non_ascii_characters" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_serialize.py::test_serialize_non_ascii_characters
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_serializepytest_serialize_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_serialize.py::test_serialize_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_serializepytest_serialize_exception_without_context" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_serialize.py::test_serialize_exception_without_context
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_serializepytest_serialize_exception_none_tuple" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_serialize.py::test_serialize_exception_none_tuple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_serializepytest_serialize_exception_instance" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_serialize.py::test_serialize_exception_instance
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_serializepytest_serialize_with_catch_decorator" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_serialize.py::test_serialize_with_catch_decorator
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_serializepytest_serialize_with_record_option" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_serialize.py::test_serialize_with_record_option
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_option_serializepytest_serialize_not_serializable" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_option_serialize.py::test_serialize_not_serializable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_stdout_sink1" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_stdout_sink[1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_stdout_sink2" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_stdout_sink[2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_stderr_sink1" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_stderr_sink[1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_stderr_sink2" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_stderr_sink[2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_file_sinkstr-0" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_file_sink[str-0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_file_sinkstr-1" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_file_sink[str-1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_file_sinkstr-2" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_file_sink[str-2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_file_sinkpath-0" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_file_sink[Path-0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_file_sinkpath-1" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_file_sink[Path-1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_file_sinkpath-2" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_file_sink[Path-2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_file_sink0-1" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_file_sink[0-1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_file_sink0-2" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_file_sink[0-2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_file_sink1-1" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_file_sink[1-1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_file_sink1-2" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_file_sink[1-2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_file_sink_folder_creation0" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_file_sink_folder_creation[0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_file_sink_folder_creation1" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_file_sink_folder_creation[1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_file_sink_folder_creation2" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_file_sink_folder_creation[2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_function_sink1" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_function_sink[1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_function_sink2" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_function_sink[2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_coroutine_sink0" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_coroutine_sink[0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_coroutine_sink1" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_coroutine_sink[1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_coroutine_sink2" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_coroutine_sink[2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_file_object_sink1" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_file_object_sink[1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_file_object_sink2" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_file_object_sink[2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_standard_handler_sink1" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_standard_handler_sink[1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_standard_handler_sink2" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_standard_handler_sink[2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_flush1" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_flush[1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_flush2" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_flush[2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_file_sink_ascii_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_file_sink_ascii_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_file_sink_utf8_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_file_sink_utf8_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_file_sink_default_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_file_sink_default_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_disabled_logger_in_sink" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_disabled_logger_in_sink
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_custom_sink_invalid_flush123" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_custom_sink_invalid_flush[123]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_custom_sink_invalid_flushnone" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_custom_sink_invalid_flush[None]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_custom_sink_invalid_stop123" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_custom_sink_invalid_stop[123]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_custom_sink_invalid_stopnone" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_custom_sink_invalid_stop[None]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_custom_sink_invalid_complete123" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_custom_sink_invalid_complete[123]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_custom_sink_invalid_completenone" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_custom_sink_invalid_complete[None]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_custom_sink_invalid_complete" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_custom_sink_invalid_complete[]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_add_sinkspytest_deprecated_start_and_stop" class="md-nav__link">
    <span class="md-ellipsis">
      test_add_sinks.py::test_deprecated_start_and_stop
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bold-x1b1m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      bold&gt;-\x1b[1m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dim-x1b2m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      dim&gt;-\x1b[2m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#normal-x1b22m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      normal&gt;-\x1b[22m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b-x1b1m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      b&gt;-\x1b[1m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#d-x1b2m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      d&gt;-\x1b[2m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#n-x1b22m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      n&gt;-\x1b[22m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#red-x1b41m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      RED&gt;-\x1b[41m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r-x1b41m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      R&gt;-\x1b[41m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#light-green-x1b102m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      LIGHT-GREEN&gt;-\x1b[102m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lg-x1b102m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      LG&gt;-\x1b[102m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#yellow-x1b33m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      yellow&gt;-\x1b[33m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#y-x1b33m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      y&gt;-\x1b[33m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#light-white-x1b97m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      light-white&gt;-\x1b[97m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lw-x1b97m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      lw&gt;-\x1b[97m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#d-x1b1m1x1b0mx1b2m2x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      d&gt;-\x1b[1m1\x1b[0m\x1b[2m2\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#d-x1b1m1x1b0m2x1b2m3x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      d&gt;-\x1b[1m1\x1b[0m2\x1b[2m3\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b4-0x1b1m1x1b2m2x1b0mx1b1m3x1b0m4" class="md-nav__link">
    <span class="md-ellipsis">
      b&gt;4-0\x1b[1m1\x1b[2m2\x1b[0m\x1b[1m3\x1b[0m4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#d-x1b2m0x1b1m1x1b2m2x1b0mx1b2mx1b1m3x1b0mx1b2m4x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      d&gt;-\x1b[2m0\x1b[1m1\x1b[2m2\x1b[0m\x1b[2m\x1b[1m3\x1b[0m\x1b[2m4\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_ansimarkup_basicpytest_permissive_parsing-x1b1m" class="md-nav__link">
    <span class="md-ellipsis">
      test_ansimarkup_basic.py::test_permissive_parsing[-\x1b[1m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b-x1b43mx1b1mx1b0mx1b43m" class="md-nav__link">
    <span class="md-ellipsis">
      b&gt;-\x1b[43m\x1b[1m\x1b[0m\x1b[43m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b-x1b1mx1b1mx1b0mx1b1m" class="md-nav__link">
    <span class="md-ellipsis">
      b&gt;-\x1b[1m\x1b[1m\x1b[0m\x1b[1m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-x1b31mfoox1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      &gt;-\x1b[31mfoo\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#green-x1b32mx1b1mbarx1b0mx1b32mx1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      green&gt;-\x1b[32m\x1b[1mbar\x1b[0m\x1b[32m\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#e-ax1b33mbx1b1mcx1b0mx1b33mdx1b0me" class="md-nav__link">
    <span class="md-ellipsis">
      &gt;e-a\x1b[33mb\x1b[1mc\x1b[0m\x1b[33md\x1b[0me]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#redbarx1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      red&gt;bar\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#red-x1b31mfoobarx1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      red&gt;-\x1b[31mfoobar\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#red-foo" class="md-nav__link">
    <span class="md-ellipsis">
      red&gt;-foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#black-bar" class="md-nav__link">
    <span class="md-ellipsis">
      BLACK&gt;-bar]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b-baz" class="md-nav__link">
    <span class="md-ellipsis">
      b&gt;-baz]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#d-123" class="md-nav__link">
    <span class="md-ellipsis">
      d&gt;-123]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-foo" class="md-nav__link">
    <span class="md-ellipsis">
      &gt;-foo]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bg-red-x1b41m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      bg red&gt;-\x1b[41m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bg-black-x1b40m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      bg BLACK&gt;-\x1b[40m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bg-light-green-x1b102m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      bg light-green&gt;-\x1b[102m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bg-light-magenta-x1b105m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      bg LIGHT-MAGENTA&gt;-\x1b[105m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fg-yellow-x1b33m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      fg yellow&gt;-\x1b[33m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fg-blue-x1b34m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      fg BLUE&gt;-\x1b[34m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fg-light-white-x1b97m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      fg light-white&gt;-\x1b[97m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fg-light-cyan-x1b96m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      fg LIGHT-CYAN&gt;-\x1b[96m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fg-ff0000-x1b38225500m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      fg #ff0000&gt;-\x1b[38;2;255;0;0m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bg-00a000-x1b48201600m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      bg #00A000&gt;-\x1b[48;2;0;160;0m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fg-f12-x1b3822414718m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      fg #F12&gt;-\x1b[38;2;241;47;18m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fg-ff0000-x1b38225500m1x1b0m_1" class="md-nav__link">
    <span class="md-ellipsis">
      fg #ff0000&gt;-\x1b[38;2;255;0;0m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bg-00a000-x1b48201600m1x1b0m_1" class="md-nav__link">
    <span class="md-ellipsis">
      bg #00A000&gt;-\x1b[48;2;0;160;0m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fg-f12-x1b3822414718m1x1b0m_1" class="md-nav__link">
    <span class="md-ellipsis">
      fg #F12&gt;-\x1b[38;2;241;47;18m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bg-bee-x1b482190235238m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      bg #BEE&gt;-\x1b[48;2;190;235;238m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fg-200-x1b385200m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      fg 200&gt;-\x1b[38;5;200m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bg-49-x1b48549m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      bg 49&gt;-\x1b[48;5;49m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#red-x1b31mx1b1mx1b48201600m1x1b0mx1b31mx1b1mx1b0mx1b31mx1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      red&gt;-\x1b[31m\x1b[1m\x1b[48;2;0;160;0m1\x1b[0m\x1b[31m\x1b[1m\x1b[0m\x1b[31m\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bg-100-x1b485100mx1b385200m1x1b0mx1b485100mx1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      bg 100&gt;-\x1b[48;5;100m\x1b[38;5;200m1\x1b[0m\x1b[48;5;100m\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bg-00a000-x1b48201600mx1b38225500m1x1b0mx1b48201600mx1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      bg #00a000&gt;-\x1b[48;2;0;160;0m\x1b[38;2;255;0;0m1\x1b[0m\x1b[48;2;0;160;0m\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bg-01600-x1b48201600mx1b38225500m1x1b0mx1b48201600mx1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      bg 0,160,0&gt;-\x1b[48;2;0;160;0m\x1b[38;2;255;0;0m1\x1b[0m\x1b[48;2;0;160;0m\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r-x1b31m2-1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      r&gt;-\x1b[31m2 &gt; 1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r-x1b31m1-2x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      r&gt;-\x1b[31m1 &lt; 2\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      2\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r-10x1b31m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      r&gt;-{: &lt;10}\x1b[31m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#10x1b31m1x1b0m" class="md-nav__link">
    <span class="md-ellipsis">
      10}\x1b[31m1\x1b[0m]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r-10-x1b31m1x1b0m-10" class="md-nav__link">
    <span class="md-ellipsis">
      r&gt;{: &gt;10}-\x1b[31m1\x1b[0m{: &gt;10}]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r3-1x1b31m2x1b0m3" class="md-nav__link">
    <span class="md-ellipsis">
      r&gt;3&gt;-&lt;1\x1b[31m2\x1b[0m3&gt;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#1x1b31m2x1b0m3" class="md-nav__link">
    <span class="md-ellipsis">
      1\x1b[31m2\x1b[0m3&gt;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r4-1x1b31m2-3x1b0m4" class="md-nav__link">
    <span class="md-ellipsis">
      r&gt;4&gt;-&lt;1\x1b[31m2 &lt; 3\x1b[0m4&gt;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3x1b0m4" class="md-nav__link">
    <span class="md-ellipsis">
      3\x1b[0m4&gt;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r4-1x1b31m3-2x1b0m4" class="md-nav__link">
    <span class="md-ellipsis">
      r&gt;4&gt;-&lt;1\x1b[31m3 &gt; 2\x1b[0m4&gt;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fg-ff0000-foobar" class="md-nav__link">
    <span class="md-ellipsis">
      fg #ff0000&gt;-foobar]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fg-55-baz" class="md-nav__link">
    <span class="md-ellipsis">
      fg 55&gt;-baz]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bg-231212-bar" class="md-nav__link">
    <span class="md-ellipsis">
      bg 23,12,12&gt;-bar]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r-2-1" class="md-nav__link">
    <span class="md-ellipsis">
      r&gt;-2 &gt; 1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r-1-2" class="md-nav__link">
    <span class="md-ellipsis">
      r&gt;-1 &lt; 2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2" class="md-nav__link">
    <span class="md-ellipsis">
      2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r-101" class="md-nav__link">
    <span class="md-ellipsis">
      r&gt;-{: &lt;10}1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#101" class="md-nav__link">
    <span class="md-ellipsis">
      10}1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r-10-1-10" class="md-nav__link">
    <span class="md-ellipsis">
      r&gt;{: &gt;10}-1{: &gt;10}]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r3-123" class="md-nav__link">
    <span class="md-ellipsis">
      r&gt;3&gt;-&lt;123&gt;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#123" class="md-nav__link">
    <span class="md-ellipsis">
      123&gt;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r4-12-34" class="md-nav__link">
    <span class="md-ellipsis">
      r&gt;4&gt;-&lt;12 &lt; 34&gt;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#34" class="md-nav__link">
    <span class="md-ellipsis">
      34&gt;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#r4-13-24" class="md-nav__link">
    <span class="md-ellipsis">
      r&gt;4&gt;-&lt;13 &gt; 24&gt;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_bindpytest_bind_after_add" class="md-nav__link">
    <span class="md-ellipsis">
      test_bind.py::test_bind_after_add
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_bindpytest_bind_before_add" class="md-nav__link">
    <span class="md-ellipsis">
      test_bind.py::test_bind_before_add
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_bindpytest_add_using_bound" class="md-nav__link">
    <span class="md-ellipsis">
      test_bind.py::test_add_using_bound
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_bindpytest_not_override_parent_logger" class="md-nav__link">
    <span class="md-ellipsis">
      test_bind.py::test_not_override_parent_logger
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_bindpytest_override_previous_bound" class="md-nav__link">
    <span class="md-ellipsis">
      test_bind.py::test_override_previous_bound
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_bindpytest_no_conflict" class="md-nav__link">
    <span class="md-ellipsis">
      test_bind.py::test_no_conflict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_bindpytest_bind_and_add_leveltrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_bind.py::test_bind_and_add_level[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_bindpytest_bind_and_add_levelfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_bind.py::test_bind_and_add_level[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_bindpytest_override_configured" class="md-nav__link">
    <span class="md-ellipsis">
      test_bind.py::test_override_configured
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coloramapytest_pycharm_fixedstdout-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_colorama.py::test_pycharm_fixed[stdout-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coloramapytest_pycharm_fixedstderr-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_colorama.py::test_pycharm_fixed[stderr-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coloramapytest_github_actions_fixedstdout-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_colorama.py::test_github_actions_fixed[stdout-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coloramapytest_github_actions_fixedstderr-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_colorama.py::test_github_actions_fixed[stderr-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coloramapytest_jupyter_fixedstdout-streamisattyfalse-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_colorama.py::test_jupyter_fixed[stdout-StreamIsattyFalse-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coloramapytest_jupyter_fixedstderr-streamisattyfalse-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_colorama.py::test_jupyter_fixed[stderr-StreamIsattyFalse-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coloramapytest_dont_wrap_on_linuxstdout" class="md-nav__link">
    <span class="md-ellipsis">
      test_colorama.py::test_dont_wrap_on_linux[stdout]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coloramapytest_dont_wrap_on_linuxstderr" class="md-nav__link">
    <span class="md-ellipsis">
      test_colorama.py::test_dont_wrap_on_linux[stderr]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configurepytest_handlers" class="md-nav__link">
    <span class="md-ellipsis">
      test_configure.py::test_handlers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configurepytest_levels" class="md-nav__link">
    <span class="md-ellipsis">
      test_configure.py::test_levels
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configurepytest_extra" class="md-nav__link">
    <span class="md-ellipsis">
      test_configure.py::test_extra
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configurepytest_patcher" class="md-nav__link">
    <span class="md-ellipsis">
      test_configure.py::test_patcher
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configurepytest_activation" class="md-nav__link">
    <span class="md-ellipsis">
      test_configure.py::test_activation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configurepytest_dict_unpacking" class="md-nav__link">
    <span class="md-ellipsis">
      test_configure.py::test_dict_unpacking
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configurepytest_returned_ids" class="md-nav__link">
    <span class="md-ellipsis">
      test_configure.py::test_returned_ids
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configurepytest_dont_reset_by_default" class="md-nav__link">
    <span class="md-ellipsis">
      test_configure.py::test_dont_reset_by_default
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configurepytest_reset_previous_extra" class="md-nav__link">
    <span class="md-ellipsis">
      test_configure.py::test_reset_previous_extra
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configurepytest_reset_previous_patcher" class="md-nav__link">
    <span class="md-ellipsis">
      test_configure.py::test_reset_previous_patcher
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configurepytest_dont_reset_previous_levels" class="md-nav__link">
    <span class="md-ellipsis">
      test_configure.py::test_dont_reset_previous_levels
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configurepytest_configure_handler_using_new_level" class="md-nav__link">
    <span class="md-ellipsis">
      test_configure.py::test_configure_handler_using_new_level
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configurepytest_configure_filter_using_new_level" class="md-nav__link">
    <span class="md-ellipsis">
      test_configure.py::test_configure_filter_using_new_level
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configurepytest_configure_before_bind" class="md-nav__link">
    <span class="md-ellipsis">
      test_configure.py::test_configure_before_bind
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_configurepytest_configure_after_bind" class="md-nav__link">
    <span class="md-ellipsis">
      test_configure.py::test_configure_after_bind
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_contextualizepytest_contextualize" class="md-nav__link">
    <span class="md-ellipsis">
      test_contextualize.py::test_contextualize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_contextualizepytest_contextualize_as_decorator" class="md-nav__link">
    <span class="md-ellipsis">
      test_contextualize.py::test_contextualize_as_decorator
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_contextualizepytest_contextualize_in_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_contextualize.py::test_contextualize_in_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_contextualizepytest_contextualize_reset" class="md-nav__link">
    <span class="md-ellipsis">
      test_contextualize.py::test_contextualize_reset
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_contextualizepytest_contextualize_async" class="md-nav__link">
    <span class="md-ellipsis">
      test_contextualize.py::test_contextualize_async
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_contextualizepytest_contextualize_thread" class="md-nav__link">
    <span class="md-ellipsis">
      test_contextualize.py::test_contextualize_thread
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_contextualizepytest_contextualize_before_bind" class="md-nav__link">
    <span class="md-ellipsis">
      test_contextualize.py::test_contextualize_before_bind
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_contextualizepytest_contextualize_after_bind" class="md-nav__link">
    <span class="md-ellipsis">
      test_contextualize.py::test_contextualize_after_bind
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_contextualizepytest_contextualize_using_bound" class="md-nav__link">
    <span class="md-ellipsis">
      test_contextualize.py::test_contextualize_using_bound
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_contextualizepytest_contextualize_before_configure" class="md-nav__link">
    <span class="md-ellipsis">
      test_contextualize.py::test_contextualize_before_configure
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_contextualizepytest_contextualize_after_configure" class="md-nav__link">
    <span class="md-ellipsis">
      test_contextualize.py::test_contextualize_after_configure
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_contextualizepytest_nested_contextualize" class="md-nav__link">
    <span class="md-ellipsis">
      test_contextualize.py::test_nested_contextualize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_contextualizepytest_context_reset_despite_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_contextualize.py::test_context_reset_despite_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_contextualizepytest_contextvars_fallback_352" class="md-nav__link">
    <span class="md-ellipsis">
      test_contextualize.py::test_contextvars_fallback_352
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_coroutine_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_coroutine_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_async_callable_sink" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_async_callable_sink
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_concurrent_execution" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_concurrent_execution
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_recursive_coroutine" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_recursive_coroutine
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_using_another_event_loop" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_using_another_event_loop
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_run_mutiple_different_loops" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_run_mutiple_different_loops
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_run_multiple_same_loop" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_run_multiple_same_loop
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_using_sink_without_running_loop_not_none" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_using_sink_without_running_loop_not_none
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_using_sink_without_running_loop_none" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_using_sink_without_running_loop_none
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_global_loop_not_used" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_global_loop_not_used
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_complete_in_another_run" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_complete_in_another_run
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_tasks_cancelled_on_remove" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_tasks_cancelled_on_remove
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_remove_without_tasks" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_remove_without_tasks
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_complete_without_tasks" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_complete_without_tasks
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_complete_stream_noop" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_complete_stream_noop
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_complete_file_noop" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_complete_file_noop
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_complete_function_noop" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_complete_function_noop
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_complete_standard_noop" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_complete_standard_noop
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_exception_in_coroutine_caught" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_exception_in_coroutine_caught
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_exception_in_coroutine_not_caught" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_exception_in_coroutine_not_caught
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_exception_in_coroutine_during_complete_caught" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_exception_in_coroutine_during_complete_caught
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_exception_in_coroutine_during_complete_not_caught" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_exception_in_coroutine_during_complete_not_caught
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_enqueue_coroutine_loop" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_enqueue_coroutine_loop
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_enqueue_coroutine_from_inside_coroutine_without_loop" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_enqueue_coroutine_from_inside_coroutine_without_loop
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_custom_complete_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_custom_complete_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_complete_from_another_looptrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_complete_from_another_loop[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_complete_from_another_loopfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_complete_from_another_loop[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_complete_from_multiple_threads_loop_is_none" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_complete_from_multiple_threads_loop_is_none
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_complete_from_multiple_threads_loop_is_not_none" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_complete_from_multiple_threads_loop_is_not_none
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_complete_and_sink_write_concurrency" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_complete_and_sink_write_concurrency
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_complete_and_contextualize_concurrency" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_complete_and_contextualize_concurrency
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_complete_with_sub_processes" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_complete_with_sub_processes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_coroutine_sinkpytest_invalid_coroutine_sink_if_no_loop_with_enqueue" class="md-nav__link">
    <span class="md-ellipsis">
      test_coroutine_sink.py::test_invalid_coroutine_sink_if_no_loop_with_enqueue
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattingy-m-d-h-m-s-f-z-z-2018-06-09-010203000045-timezone0-2018-06-09-01-02-03-000045-utc-0000" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[%Y-%m-%d %H-%M-%S %f %Z %z-2018-06-09 01:02:03.000045-timezone0-2018-06-09 01-02-03 000045 UTC +0000]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattingyyyy-mm-dd-hh-mm-ss-ssssss-zz-zz-2018-06-09-010203000045-timezone1-2018-06-09-01-02-03-000045-utc-0000" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ-2018-06-09 01:02:03.000045-timezone1-2018-06-09 01-02-03 000045 UTC +0000]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattingy-m-d-h-m-s-f-z-z-2018-06-09-010203000045-timezone2-2018-06-09-01-02-03-000045-est-0500" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[%Y-%m-%d %H-%M-%S %f %Z %z-2018-06-09 01:02:03.000045-timezone2-2018-06-09 01-02-03 000045 EST -0500]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattingyyyy-mm-dd-hh-mm-ss-ssssss-zz-zz-2018-06-09-010203000045-timezone3-2018-06-09-01-02-03-000045-est-0500" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ-2018-06-09 01:02:03.000045-timezone3-2018-06-09 01-02-03 000045 EST -0500]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattingy-m-d-h-m-s-f-zutc-2018-06-09-010203000045-timezone4-2018-06-09-01-02-03-000045-utc" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[%Y-%m-%d %H-%M-%S %f %Z!UTC-2018-06-09 01:02:03.000045-timezone4-2018-06-09 01-02-03 000045 UTC]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattingyyyy-mm-dd-hh-mm-ss-ssssss-zzutc-2018-06-09-010203000045-timezone5-2018-06-09-01-02-03-000045-utc" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC-2018-06-09 01:02:03.000045-timezone5-2018-06-09 01-02-03 000045 UTC]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattingy-m-d-h-m-s-f-z-zutc-2018-06-09-010203000045-timezone6-2018-06-09-06-02-03-000045-utc-0000" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[%Y-%m-%d %H-%M-%S %f %Z %z!UTC-2018-06-09 01:02:03.000045-timezone6-2018-06-09 06-02-03 000045 UTC +0000]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattingyyyy-mm-dd-hh-mm-ss-ssssss-zz-zzutc-2018-06-09-010203000045-timezone7-2018-06-09-06-02-03-000045-utc-0000" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC-2018-06-09 01:02:03.000045-timezone7-2018-06-09 06-02-03 000045 UTC +0000]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattingyy-m-d-h-m-s-sss-z-2005-04-07-090308002320-timezone8-05-4-7-9-3-8-002-0100" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[YY-M-D H-m-s SSS Z-2005-04-07 09:03:08.002320-timezone8-05-4-7 9-3-8 002 +01:00]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattingq_dddd_ddd-d_e-h_hh-a-ss-zz-2000-01-01-1400009-timezone9-1_001_1-5_6-2_02-pm-90-0030" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[Q_DDDD_DDD d_E h_hh A SS ZZ-2000-01-01 14:00:00.9-timezone9-1_001_1 5_6 2_02 PM 90 -0030]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattinghh-a-2018-01-01-000102000003-timezone10-12-am" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[hh A-2018-01-01 00:01:02.000003-timezone10-12 AM]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattinghh-a-2018-01-01-1200000-timezone11-12-pm" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[hh A-2018-01-01 12:00:00.0-timezone11-12 PM]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattinghh-a-2018-01-01-2300000-timezone12-11-pm" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[hh A-2018-01-01 23:00:00.0-timezone12-11 PM]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattingyyyy-mm-dd-2018-02-03-110900000002-timezone13-yyyy-02-dd" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[[YYYY] MM [DD]-2018-02-03 11:09:00.000002-timezone13-YYYY 02 DD]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattingyyyy-mm-dd-2018-01-03-110304000002-timezone14-2018-01-03" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[[YYYY MM DD]-2018-01-03 11:03:04.000002-timezone14-[2018 01 03]]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattingyy-2018-01-03-110304000002-timezone15-yy" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[[[YY]]-2018-01-03 11:03:04.000002-timezone15-[YY]]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formatting-2018-01-03-110304000002-timezone16-" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[[]-2018-01-03 11:03:04.000002-timezone16-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formatting-2018-01-03-110304000002-timezone17-" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[[[]]-2018-01-03 11:03:04.000002-timezone17-[]]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattingsssssssssssssss-2018-01-03-110304100002-timezone18-100002100100002" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[SSSSSS[]SSS[]SSSSSS-2018-01-03 11:03:04.100002-timezone18-100002100100002]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattinghhmmss-2018-01-03-110304000002-timezone19-110304" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[[HHmmss-2018-01-03 11:03:04.000002-timezone19-[110304]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattinghhmmss-2018-01-03-110304000002-timezone20-110304" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[HHmmss]-2018-01-03 11:03:04.000002-timezone20-110304]]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattinghhmmssutc-2018-01-01-1130000-timezone21-093000" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[HH:mm:ss!UTC-2018-01-01 11:30:00.0-timezone21-09:30:00]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattingutc-hhmmss-2018-01-01-1130000-timezone22-utc-113000" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[UTC! HH:mm:ss-2018-01-01 11:30:00.0-timezone22-UTC! 11:30:00]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattingutc-hhmmss-2018-01-01-1130000-timezone23-utc-113000" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[!UTC HH:mm:ss-2018-01-01 11:30:00.0-timezone23-!UTC 11:30:00]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattinghhmmss-a-z-zz-utc-2018-01-01-1230000-timezone24-110000-am-0000-0000" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[hh:mm:ss A - Z ZZ !UTC-2018-01-01 12:30:00.0-timezone24-11:00:00 AM - +00:00 +0000 ]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattingyyyy-mm-dd-hhmmsszutc-2018-01-03-1103042-timezone25-2018-01-03-130304z" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[YYYY-MM-DD HH:mm:ss[Z]!UTC-2018-01-03 11:03:04.2-timezone25-2018-01-03 13:03:04Z]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattinghhmmssutc-2018-01-01-1130000-timezone26-113000utc" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[HH:mm:ss[!UTC]-2018-01-01 11:30:00.0-timezone26-11:30:00!UTC]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formatting-2018-02-03-110900000002-timezone27-2018-02-03t1109000000020030" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[-2018-02-03 11:09:00.000002-timezone27-2018-02-03T11:09:00.000002+0030]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formattingutc-2018-02-03-110900000002-timezone28-2018-02-03t1039000000020000" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting[!UTC-2018-02-03 11:09:00.000002-timezone28-2018-02-03T10:39:00.000002+0000]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formatting_timezone_offset_down_to_the_secondy-m-d-h-m-s-f-z-z-7230099-2018-06-09-01-02-03-000000-abc-020030099000" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting_timezone_offset_down_to_the_second[%Y-%m-%d %H-%M-%S %f %Z %z-7230.099-2018-06-09 01-02-03 000000 ABC +020030.099000]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formatting_timezone_offset_down_to_the_secondyyyy-mm-dd-hh-mm-ss-zz-z-zz-6543-2018-06-09-01-02-03-abc-014903-014903" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting_timezone_offset_down_to_the_second[YYYY-MM-DD HH-mm-ss zz Z ZZ-6543-2018-06-09 01-02-03 ABC +01:49:03 +014903]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_formatting_timezone_offset_down_to_the_secondhh-mm-ss-zz-z-zz-1234506702-01-02-03-abc-032645067020-032645067020" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_formatting_timezone_offset_down_to_the_second[HH-mm-ss zz Z ZZ--12345.06702-01-02-03 ABC -03:26:45.067020 -032645.067020]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_locale_formatting" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_locale_formatting
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_stdout_formatting" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_stdout_formatting
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_file_formatting" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_file_formatting
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_missing_struct_time_fields" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_missing_struct_time_fields
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_freezegun_mocking" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_freezegun_mocking
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_invalid_time_formatsssssssss" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_invalid_time_format[ss.SSSSSSS]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_invalid_time_formatssssssssssss" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_invalid_time_format[SS.SSSSSSSS.SS]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_invalid_time_formathhmmsssssssssss" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_invalid_time_format[HH:mm:ss.SSSSSSSSS]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_datetimepytest_invalid_time_formatssssssssss" class="md-nav__link">
    <span class="md-ellipsis">
      test_datetime.py::test_invalid_time_format[SSSSSSSSSS]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deepcopypytest_add_sink_after_deepcopy" class="md-nav__link">
    <span class="md-ellipsis">
      test_deepcopy.py::test_add_sink_after_deepcopy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deepcopypytest_add_sink_before_deepcopy" class="md-nav__link">
    <span class="md-ellipsis">
      test_deepcopy.py::test_add_sink_before_deepcopy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deepcopypytest_remove_from_original" class="md-nav__link">
    <span class="md-ellipsis">
      test_deepcopy.py::test_remove_from_original
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_deepcopypytest_remove_from_copy" class="md-nav__link">
    <span class="md-ellipsis">
      test_deepcopy.py::test_remove_from_copy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_defaultspytest_stringtest" class="md-nav__link">
    <span class="md-ellipsis">
      test_defaults.py::test_string[test]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_defaultspytest_string" class="md-nav__link">
    <span class="md-ellipsis">
      test_defaults.py::test_string[]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_defaultspytest_bool_positivey" class="md-nav__link">
    <span class="md-ellipsis">
      test_defaults.py::test_bool_positive[y]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_defaultspytest_bool_positive1" class="md-nav__link">
    <span class="md-ellipsis">
      test_defaults.py::test_bool_positive[1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_defaultspytest_bool_positivetrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_defaults.py::test_bool_positive[TRUE]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_defaultspytest_bool_negativeno" class="md-nav__link">
    <span class="md-ellipsis">
      test_defaults.py::test_bool_negative[NO]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_defaultspytest_bool_negative0" class="md-nav__link">
    <span class="md-ellipsis">
      test_defaults.py::test_bool_negative[0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_defaultspytest_bool_negativefalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_defaults.py::test_bool_negative[false]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_defaultspytest_int" class="md-nav__link">
    <span class="md-ellipsis">
      test_defaults.py::test_int
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_defaultspytest_invalid_int" class="md-nav__link">
    <span class="md-ellipsis">
      test_defaults.py::test_invalid_int[]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_defaultspytest_invalid_inta" class="md-nav__link">
    <span class="md-ellipsis">
      test_defaults.py::test_invalid_int[a]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_defaultspytest_invalid_bool" class="md-nav__link">
    <span class="md-ellipsis">
      test_defaults.py::test_invalid_bool[]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_defaultspytest_invalid_boola" class="md-nav__link">
    <span class="md-ellipsis">
      test_defaults.py::test_invalid_bool[a]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_caret_not_maskedfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_caret_not_masked[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_caret_not_maskedtrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_caret_not_masked[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_no_caret_if_no_backtracefalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_no_caret_if_no_backtrace[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_no_caret_if_no_backtracetrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_no_caret_if_no_backtrace[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_sink_encodingascii" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_sink_encoding[ascii]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_sink_encodingutf8" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_sink_encoding[UTF8]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_sink_encodingnone" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_sink_encoding[None]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_sink_encodingunknown-encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_sink_encoding[unknown-encoding]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_sink_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_sink_encoding[]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_sink_encodingencoding5" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_sink_encoding[encoding5]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_file_sink_ascii_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_file_sink_ascii_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_file_sink_utf8_encoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_file_sink_utf8_encoding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_has_sys_real_prefix" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_has_sys_real_prefix
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_no_sys_real_prefix" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_no_sys_real_prefix
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_has_site_getsitepackages" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_has_site_getsitepackages
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_no_site_getsitepackages" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_no_site_getsitepackages
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_user_site_is_path" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_user_site_is_path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_user_site_is_none" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_user_site_is_none
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_sysconfig_get_path_return_path" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_sysconfig_get_path_return_path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_sysconfig_get_path_return_none" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_sysconfig_get_path_return_none
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_no_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_no_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_exception_is_none" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_exception_is_none
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_exception_is_tuple" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_exception_is_tuple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_exception_not_raisingzerodivisionerror" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_exception_not_raising[ZeroDivisionError]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_exception_not_raisingarithmeticerror" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_exception_not_raising[ArithmeticError]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_exception_not_raisingexception2" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_exception_not_raising[exception2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_exception_raisingvalueerror" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_exception_raising[ValueError]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_exception_raisingexception1" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_exception_raising[exception1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_exclude_exception_raisingbaseexception-zerodivisionerror" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_exclude_exception_raising[BaseException-ZeroDivisionError]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_exclude_exception_raisingbaseexception-arithmeticerror" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_exclude_exception_raising[BaseException-ArithmeticError]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_exclude_exception_raisingbaseexception-exclude2" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_exclude_exception_raising[BaseException-exclude2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_exclude_exception_raisingzerodivisionerror-zerodivisionerror" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_exclude_exception_raising[ZeroDivisionError-ZeroDivisionError]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_exclude_exception_raisingzerodivisionerror-arithmeticerror" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_exclude_exception_raising[ZeroDivisionError-ArithmeticError]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_exclude_exception_raisingzerodivisionerror-exclude2" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_exclude_exception_raising[ZeroDivisionError-exclude2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_exclude_exception_not_raisingbaseexception-valueerror" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_exclude_exception_not_raising[BaseException-ValueError]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_exclude_exception_not_raisingbaseexception-exclude1" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_exclude_exception_not_raising[BaseException-exclude1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_exclude_exception_not_raisingzerodivisionerror-valueerror" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_exclude_exception_not_raising[ZeroDivisionError-ValueError]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_exclude_exception_not_raisingzerodivisionerror-exclude1" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_exclude_exception_not_raising[ZeroDivisionError-exclude1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_reraise" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_reraise
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_onerror" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_onerror
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_onerror_with_reraise" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_onerror_with_reraise
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_decorate_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_decorate_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_decorate_coroutine" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_decorate_coroutine
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_decorate_generator" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_decorate_generator
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_decorate_generator_with_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_decorate_generator_with_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_default_with_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_default_with_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_default_with_generator" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_default_with_generator
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_default_with_coroutine" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_default_with_coroutine
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_catchpytest_error_when_decorating_class_without_parentheses" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_catch.py::test_error_when_decorating_class_without_parentheses
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_backtracechained_expression_direct" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_backtrace[chained_expression_direct]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_backtracechained_expression_indirect" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_backtrace[chained_expression_indirect]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_backtracechaining_first" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_backtrace[chaining_first]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_backtracechaining_second" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_backtrace[chaining_second]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_backtracechaining_third" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_backtrace[chaining_third]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_backtraceenqueue" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_backtrace[enqueue]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_backtraceenqueue_with_others_handlers" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_backtrace[enqueue_with_others_handlers]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_backtraceframe_values_backward" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_backtrace[frame_values_backward]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_backtraceframe_values_forward" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_backtrace[frame_values_forward]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_backtracefunction" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_backtrace[function]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_backtracehead_recursion" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_backtrace[head_recursion]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_backtracemissing_attributes_traceback_objects" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_backtrace[missing_attributes_traceback_objects]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_backtracenested" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_backtrace[nested]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_backtracenested_chained_catch_up" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_backtrace[nested_chained_catch_up]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_backtracenested_decorator_catch_up" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_backtrace[nested_decorator_catch_up]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_backtracenested_explicit_catch_up" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_backtrace[nested_explicit_catch_up]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_backtracenested_wrapping" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_backtrace[nested_wrapping]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_backtraceno_tb" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_backtrace[no_tb]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_backtracenot_enough_arguments" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_backtrace[not_enough_arguments]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_backtraceraising_recursion" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_backtrace[raising_recursion]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_backtracesuppressed_expression_direct" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_backtrace[suppressed_expression_direct]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_backtracesuppressed_expression_indirect" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_backtrace[suppressed_expression_indirect]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_backtracetail_recursion" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_backtrace[tail_recursion]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_backtracetoo_many_arguments" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_backtrace[too_many_arguments]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_diagnoseassertion_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_diagnose[assertion_error]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_diagnoseassertion_error_custom" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_diagnose[assertion_error_custom]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_diagnoseassertion_error_in_string" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_diagnose[assertion_error_in_string]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_diagnoseattributes" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_diagnose[attributes]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_diagnosechained_both" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_diagnose[chained_both]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_diagnoseencoding" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_diagnose[encoding]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_diagnoseglobal_variable" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_diagnose[global_variable]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_diagnoseindentation_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_diagnose[indentation_error]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_diagnosekeyword_argument" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_diagnose[keyword_argument]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_diagnosemultilines_repr" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_diagnose[multilines_repr]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_diagnoseno_error_message" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_diagnose[no_error_message]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_diagnoseparenthesis" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_diagnose[parenthesis]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_diagnosesource_multilines" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_diagnose[source_multilines]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_diagnosesource_strings" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_diagnose[source_strings]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_diagnosesyntax_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_diagnose[syntax_error]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_diagnosesyntax_highlighting" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_diagnose[syntax_highlighting]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_diagnosetruncating" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_diagnose[truncating]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_diagnoseunprintable_object" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_diagnose[unprintable_object]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_ownershipassertion_from_lib" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_ownership[assertion_from_lib]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_ownershipassertion_from_local" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_ownership[assertion_from_local]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_ownershipcallback" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_ownership[callback]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_ownershipcatch_decorator" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_ownership[catch_decorator]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_ownershipcatch_decorator_from_lib" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_ownership[catch_decorator_from_lib]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_ownershipdecorated_callback" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_ownership[decorated_callback]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_ownershipdirect" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_ownership[direct]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_ownershipindirect" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_ownership[indirect]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_ownershipstring_lib" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_ownership[string_lib]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_ownershipstring_source" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_ownership[string_source]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_ownershipsyntaxerror" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_ownership[syntaxerror]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_othersassertionerror_without_traceback" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_others[assertionerror_without_traceback]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_otherscatch_as_context_manager" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_others[catch_as_context_manager]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_otherscatch_as_decorator_with_parentheses" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_others[catch_as_decorator_with_parentheses]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_otherscatch_as_decorator_without_parentheses" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_others[catch_as_decorator_without_parentheses]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_otherscatch_as_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_others[catch_as_function]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_otherscatch_message" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_others[catch_message]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_othersexception_formatting_coroutine" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_others[exception_formatting_coroutine]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_othersexception_formatting_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_others[exception_formatting_function]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_othersexception_formatting_generator" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_others[exception_formatting_generator]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_othersexception_in_property" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_others[exception_in_property]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_othershandler_formatting_with_context_manager" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_others[handler_formatting_with_context_manager]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_othershandler_formatting_with_decorator" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_others[handler_formatting_with_decorator]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_otherslevel_name" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_others[level_name]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_otherslevel_number" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_others[level_number]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_othersmessage_formatting_with_context_manager" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_others[message_formatting_with_context_manager]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_othersmessage_formatting_with_decorator" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_others[message_formatting_with_decorator]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_othersnested_with_reraise" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_others[nested_with_reraise]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_otherssyntaxerror_without_traceback" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_others[syntaxerror_without_traceback]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_otherssys_tracebacklimit" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_others[sys_tracebacklimit]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_otherssys_tracebacklimit_negative" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_others[sys_tracebacklimit_negative]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_otherssys_tracebacklimit_none" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_others[sys_tracebacklimit_none]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_otherssys_tracebacklimit_unset" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_others[sys_tracebacklimit_unset]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_otherszerodivisionerror_without_traceback" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_others[zerodivisionerror_without_traceback]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_moderntype_hints-minimum_python_version0" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_modern[type_hints-minimum_python_version0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_modernpositional_only_argument-minimum_python_version1" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_modern[positional_only_argument-minimum_python_version1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_modernwalrus_operator-minimum_python_version2" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_modern[walrus_operator-minimum_python_version2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_exception_modernmatch_statement-minimum_python_version3" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_exception_modern[match_statement-minimum_python_version3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_exceptions_formattingpytest_group_exception_using_backport" class="md-nav__link">
    <span class="md-ellipsis">
      test_exceptions_formatting.py::test_group_exception_using_backport
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_compression_extgz" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_compression_ext[gz]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_compression_extbz2" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_compression_ext[bz2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_compression_extzip" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_compression_ext[zip]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_compression_extxz" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_compression_ext[xz]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_compression_extlzma" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_compression_ext[lzma]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_compression_exttar" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_compression_ext[tar]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_compression_exttargz" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_compression_ext[tar.gz]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_compression_exttarbz2" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_compression_ext[tar.bz2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_compression_exttarxz" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_compression_ext[tar.xz]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_compression_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_compression_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_compression_at_rotationa" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_compression_at_rotation[a]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_compression_at_rotationa_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_compression_at_rotation[a+]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_compression_at_rotationw" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_compression_at_rotation[w]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_compression_at_rotationx" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_compression_at_rotation[x]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_compression_at_remove_without_rotationa" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_compression_at_remove_without_rotation[a]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_compression_at_remove_without_rotationa_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_compression_at_remove_without_rotation[a+]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_compression_at_remove_without_rotationw" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_compression_at_remove_without_rotation[w]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_compression_at_remove_without_rotationx" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_compression_at_remove_without_rotation[x]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_no_compression_at_remove_with_rotationa" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_no_compression_at_remove_with_rotation[a]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_no_compression_at_remove_with_rotationa_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_no_compression_at_remove_with_rotation[a+]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_no_compression_at_remove_with_rotationw" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_no_compression_at_remove_with_rotation[w]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_no_compression_at_remove_with_rotationx" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_no_compression_at_remove_with_rotation[x]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_rename_existing_with_creation_time" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_rename_existing_with_creation_time
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_renaming_compression_dest_exists" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_renaming_compression_dest_exists
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_renaming_compression_dest_exists_with_time" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_renaming_compression_dest_exists_with_time
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_compression_use_renamed_file_after_rotation" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_compression_use_renamed_file_after_rotation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_threaded_compression_after_rotation" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_threaded_compression_after_rotation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_exception_during_compression_at_rotationtrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_exception_during_compression_at_rotation[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_exception_during_compression_at_rotationfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_exception_during_compression_at_rotation[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_exception_during_compression_at_rotation_not_caughttrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_exception_during_compression_at_rotation_not_caught[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_exception_during_compression_at_rotation_not_caughtfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_exception_during_compression_at_rotation_not_caught[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_exception_during_compression_at_removetrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_exception_during_compression_at_remove[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_exception_during_compression_at_removefalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_exception_during_compression_at_remove[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_invalid_compression0" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_invalid_compression[0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_invalid_compressiontrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_invalid_compression[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_invalid_compressionos" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_invalid_compression[os]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_invalid_compressioncompression3" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_invalid_compression[compression3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_invalid_compressioncompression4" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_invalid_compression[compression4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_unknown_compressionrar" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_unknown_compression[rar]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_unknown_compression7z" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_unknown_compression[.7z]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_unknown_compressiontarzip" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_unknown_compression[tar.zip]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_unknown_compressiondict" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_unknown_compression[dict]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_gzip_module_unavailablegz" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_gzip_module_unavailable[gz]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_gzip_module_unavailabletargz" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_gzip_module_unavailable[tar.gz]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_bz2_module_unavailablebz2" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_bz2_module_unavailable[bz2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_bz2_module_unavailabletarbz2" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_bz2_module_unavailable[tar.bz2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_lzma_module_unavailablexz" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_lzma_module_unavailable[xz]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_lzma_module_unavailablelzma" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_lzma_module_unavailable[lzma]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_lzma_module_unavailabletarxz" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_lzma_module_unavailable[tar.xz]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_tarfile_module_unavailabletar" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_tarfile_module_unavailable[tar]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_tarfile_module_unavailabletargz" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_tarfile_module_unavailable[tar.gz]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_tarfile_module_unavailabletarbz2" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_tarfile_module_unavailable[tar.bz2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_tarfile_module_unavailabletarxz" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_tarfile_module_unavailable[tar.xz]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_compressionpytest_zipfile_module_unavailablezip" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_compression.py::test_zipfile_module_unavailable[zip]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_delaypytest_file_not_delayed" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_delay.py::test_file_not_delayed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_delaypytest_file_delayed" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_delay.py::test_file_delayed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_delaypytest_compression" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_delay.py::test_compression
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_delaypytest_retention" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_delay.py::test_retention
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_delaypytest_retention_early_remove" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_delay.py::test_retention_early_remove
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_delaypytest_rotation" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_delay.py::test_rotation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_delaypytest_rotation_and_retention" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_delay.py::test_rotation_and_retention
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_delaypytest_rotation_and_retention_timed_file" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_delay.py::test_rotation_and_retention_timed_file
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_permissionspytest_log_file_permissions511" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_permissions.py::test_log_file_permissions[511]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_permissionspytest_log_file_permissions502" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_permissions.py::test_log_file_permissions[502]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_permissionspytest_log_file_permissions484" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_permissions.py::test_log_file_permissions[484]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_permissionspytest_log_file_permissions448" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_permissions.py::test_log_file_permissions[448]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_permissionspytest_log_file_permissions393" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_permissions.py::test_log_file_permissions[393]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_permissionspytest_rotation_permissions511" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_permissions.py::test_rotation_permissions[511]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_permissionspytest_rotation_permissions502" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_permissions.py::test_rotation_permissions[502]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_permissionspytest_rotation_permissions484" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_permissions.py::test_rotation_permissions[484]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_permissionspytest_rotation_permissions448" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_permissions.py::test_rotation_permissions[448]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_permissionspytest_rotation_permissions393" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_permissions.py::test_rotation_permissions[393]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_retention_time1-hour" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_retention_time[1 hour]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_retention_time1h" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_retention_time[1H]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_retention_time-1-h" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_retention_time[ 1 h ]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_retention_timeretention3" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_retention_time[retention3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_retention_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_retention_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_managed_files" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_managed_files
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_no_duplicates_in_listed_filestest" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_no_duplicates_in_listed_files[test]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_no_duplicates_in_listed_filestestlog" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_no_duplicates_in_listed_files[test.log]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_manage_formatted_files" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_manage_formatted_files
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_manage_file_without_extension" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_manage_file_without_extension
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_manage_formatted_files_without_extension" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_manage_formatted_files_without_extension
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_retention_at_rotationa" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_retention_at_rotation[a]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_retention_at_rotationa_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_retention_at_rotation[a+]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_retention_at_rotationw" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_retention_at_rotation[w]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_retention_at_rotationx" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_retention_at_rotation[x]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_retention_at_remove_without_rotationa" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_retention_at_remove_without_rotation[a]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_retention_at_remove_without_rotationa_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_retention_at_remove_without_rotation[a+]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_retention_at_remove_without_rotationw" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_retention_at_remove_without_rotation[w]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_retention_at_remove_without_rotationx" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_retention_at_remove_without_rotation[x]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_no_retention_at_remove_with_rotationw" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_no_retention_at_remove_with_rotation[w]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_no_retention_at_remove_with_rotationx" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_no_retention_at_remove_with_rotation[x]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_no_retention_at_remove_with_rotationa" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_no_retention_at_remove_with_rotation[a]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_no_retention_at_remove_with_rotationa_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_no_retention_at_remove_with_rotation[a+]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_no_renaming" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_no_renaming
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_exception_during_retention_at_rotationtrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_exception_during_retention_at_rotation[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_exception_during_retention_at_rotationfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_exception_during_retention_at_rotation[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_exception_during_retention_at_rotation_not_caughttrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_exception_during_retention_at_rotation_not_caught[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_exception_during_retention_at_rotation_not_caughtfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_exception_during_retention_at_rotation_not_caught[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_exception_during_retention_at_removetrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_exception_during_retention_at_remove[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_exception_during_retention_at_removefalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_exception_during_retention_at_remove[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_invalid_retentionretention0" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_invalid_retention[retention0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_invalid_retentionos" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_invalid_retention[os]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_invalid_retentionretention2" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_invalid_retention[retention2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_unkown_retentionw5" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_unkown_retention[W5]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_unkown_retentionmonday-at-1400" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_unkown_retention[monday at 14:00]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_unkown_retentionsunday" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_unkown_retention[sunday]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_unkown_retentionnope" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_unkown_retention[nope]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_unkown_retention5-mb" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_unkown_retention[5 MB]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_unkown_retention3-hours-2-dayz" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_unkown_retention[3 hours 2 dayz]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_unkown_retentiond" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_unkown_retention[d]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_unkown_retentionh" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_unkown_retention[H]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_retentionpytest_unkown_retentiondict" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_retention.py::test_unkown_retention[dict]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_renaming" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_renaming
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_no_renaming" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_no_renaming
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_size_rotation8" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_size_rotation[8]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_size_rotation80" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_size_rotation[8.0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_size_rotation799" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_size_rotation[7.99]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_size_rotation8-b" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_size_rotation[8 B]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_size_rotation8e-6mb" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_size_rotation[8e-6MB]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_size_rotation0008-kib" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_size_rotation[0.008 kiB]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_size_rotation64b" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_size_rotation[64b]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation13-hours0" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[13-hours0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation1300-hours1" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[13:00-hours1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation130000-hours2" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[13:00:00-hours2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation130000123456-hours3" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[13:00:00.123456-hours3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation1100-hours4" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[11:00-hours4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotationw0-hours5" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[w0-hours5]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotationw0-at-0000-hours6" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[W0 at 00:00-hours6]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotationw6-hours7" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[W6-hours7]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotationsaturday-hours8" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[saturday-hours8]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotationw6-at-00-hours9" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[w6 at 00-hours9]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation-w6-at-13-hours10" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[ W6 at 13 -hours10]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotationw2-at-110000-am-hours11" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[w2 at 11:00:00 AM-hours11]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotationmonday-at-110030123-hours12" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[MoNdAy at 11:00:30.123-hours12]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotationsunday-hours13" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[sunday-hours13]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotationsunday-at-1100-hours14" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[SUNDAY at 11:00-hours14]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotationsunday-at-1000-pm-hours15" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[sunDAY at 1:0:0.0 pm-hours15]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotationwhen16-hours16" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[when16-hours16]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotationwhen17-hours17" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[when17-hours17]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation2-h-hours18" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[2 h-hours18]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation1-hour-hours19" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[1 hour-hours19]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation7-days-hours20" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[7 days-hours20]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation1h-30-minutes-hours21" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[1h 30 minutes-hours21]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation1-w-2d-hours22" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[1 w, 2D-hours22]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation15d-hours23" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[1.5d-hours23]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation1222-hours-344s-hours24" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[1.222 hours, 3.44s-hours24]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotationwhen25-hours25" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[when25-hours25]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotationwhen26-hours26" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[when26-hours26]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotationhourly-hours27" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[hourly-hours27]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotationdaily-hours28" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[daily-hours28]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotationweekly-hours29" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[WEEKLY-hours29]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotationmonthly-hours30" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[mOnthLY-hours30]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotationmonthly-hours31" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[monthly-hours31]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotationyearly-hours32" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation[Yearly -hours32]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_dst" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_dst
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_with_tzinfo_diff_bigger" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_with_tzinfo_diff_bigger
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_with_tzinfo_diff_lower" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_with_tzinfo_diff_lower
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_with_tzinfo_utc" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_with_tzinfo_utc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_multiple_days_at_midnight_utc" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_multiple_days_at_midnight_utc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_daily_rotation_with_different_timezone-3600" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_daily_rotation_with_different_timezone[-3600]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_daily_rotation_with_different_timezone0" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_daily_rotation_with_different_timezone[0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_daily_rotation_with_different_timezone3600" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_daily_rotation_with_different_timezone[3600]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_after_positive_timezone_changes_forwardrotation0" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_forward[rotation0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_after_positive_timezone_changes_forwardrotation1" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_forward[rotation1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_after_positive_timezone_changes_forwardrotation2" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_forward[rotation2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_after_positive_timezone_changes_forwardrotation3" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_forward[rotation3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_after_positive_timezone_changes_forward033000" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_forward[03:30:00]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_when_positive_timezone_changes_forwardrotation0" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_when_positive_timezone_changes_forward[rotation0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_when_positive_timezone_changes_forward023000" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_when_positive_timezone_changes_forward[02:30:00]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_after_negative_timezone_changes_forwardrotation0" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_forward[rotation0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_after_negative_timezone_changes_forwardrotation1" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_forward[rotation1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_after_negative_timezone_changes_forwardrotation2" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_forward[rotation2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_after_negative_timezone_changes_forwardrotation3" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_forward[rotation3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_after_negative_timezone_changes_forward033000" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_forward[03:30:00]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_when_negative_timezone_changes_forwardrotation0" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_when_negative_timezone_changes_forward[rotation0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_when_negative_timezone_changes_forward023000" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_when_negative_timezone_changes_forward[02:30:00]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_after_positive_timezone_changes_backward_awarerotation0" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_backward_aware[rotation0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_after_positive_timezone_changes_backward_awarerotation1" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_backward_aware[rotation1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_after_positive_timezone_changes_backward_awarerotation2" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_backward_aware[rotation2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_after_positive_timezone_changes_backward_naiverotation0" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_backward_naive[rotation0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_after_positive_timezone_changes_backward_naive023000" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_backward_naive[02:30:00]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_after_negative_timezone_changes_backward_awarerotation0" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_backward_aware[rotation0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_after_negative_timezone_changes_backward_awarerotation1" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_backward_aware[rotation1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_after_negative_timezone_changes_backward_awarerotation2" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_backward_aware[rotation2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_after_negative_timezone_changes_backward_naiverotation0" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_backward_naive[rotation0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_after_negative_timezone_changes_backward_naive023000" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_backward_naive[02:30:00]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_when_timezone_changes_backward_rename_file" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_when_timezone_changes_backward_rename_file
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_dont_rotate_earlier_when_utc_is_one_day_before0015" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_dont_rotate_earlier_when_utc_is_one_day_before[00:15]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_dont_rotate_earlier_when_utc_is_one_day_beforerotation1" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_dont_rotate_earlier_when_utc_is_one_day_before[rotation1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_dont_rotate_earlier_when_utc_is_one_day_beforerotation2" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_dont_rotate_earlier_when_utc_is_one_day_before[rotation2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_dont_rotate_earlier_when_utc_is_one_day_beforerotation3" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_dont_rotate_earlier_when_utc_is_one_day_before[rotation3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_dont_rotate_earlier_when_utc_is_one_day_beforerotation4" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_dont_rotate_earlier_when_utc_is_one_day_before[rotation4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_dont_rotate_later_when_utc_is_one_day_after2345" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_dont_rotate_later_when_utc_is_one_day_after[23:45]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_dont_rotate_later_when_utc_is_one_day_afterrotation1" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_dont_rotate_later_when_utc_is_one_day_after[rotation1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_dont_rotate_later_when_utc_is_one_day_afterrotation2" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_dont_rotate_later_when_utc_is_one_day_after[rotation2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_dont_rotate_later_when_utc_is_one_day_afterrotation3" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_dont_rotate_later_when_utc_is_one_day_after[rotation3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_dont_rotate_later_when_utc_is_one_day_afterrotation4" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_dont_rotate_later_when_utc_is_one_day_after[rotation4]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_rotation_at_midnight_with_date_in_filenametimezone0" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_rotation_at_midnight_with_date_in_filename[timezone0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_rotation_at_midnight_with_date_in_filenametimezone1" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_rotation_at_midnight_with_date_in_filename[timezone1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_rotation_at_midnight_with_date_in_filenametimezone2" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_rotation_at_midnight_with_date_in_filename[timezone2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_reopening_xattr_attributeerrorfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_reopening_xattr_attributeerror[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_reopening_xattr_attributeerrortrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_reopening_xattr_attributeerror[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_reopening_xattr_oserrorfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_reopening_xattr_oserror[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_time_rotation_reopening_xattr_oserrortrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_time_rotation_reopening_xattr_oserror[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_function_rotation" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_function_rotation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_rotation_at_removew" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_rotation_at_remove[w]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_rotation_at_removex" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_rotation_at_remove[x]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_no_rotation_at_removea" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_no_rotation_at_remove[a]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_no_rotation_at_removea_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_no_rotation_at_remove[a+]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_rename_existing_with_creation_time" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_rename_existing_with_creation_time
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_renaming_rotation_dest_exists" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_renaming_rotation_dest_exists
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_renaming_rotation_dest_exists_with_time" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_renaming_rotation_dest_exists_with_time
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_exception_during_rotation" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_exception_during_rotation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_exception_during_rotation_not_caught" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_exception_during_rotation_not_caught
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_recipe_rotation_both_size_and_time" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_recipe_rotation_both_size_and_time
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_invalid_rotationrotation0" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_invalid_rotation[rotation0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_invalid_rotationos" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_invalid_rotation[os]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_invalid_rotationrotation2" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_invalid_rotation[rotation2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_invalid_rotationrotation3" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_invalid_rotation[rotation3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_invalid_rotation1j" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_invalid_rotation[1j]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_unknown_rotationw7" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_unknown_rotation[w7]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_unknown_rotationw10" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_unknown_rotation[w10]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_unknown_rotationw-1" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_unknown_rotation[w-1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_unknown_rotationh" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_unknown_rotation[h]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_unknown_rotationm" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_unknown_rotation[M]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_unknown_rotationw1at13" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_unknown_rotation[w1at13]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_unknown_rotationwww" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_unknown_rotation[www]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_unknown_rotation13-at-w2" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_unknown_rotation[13 at w2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_unknown_rotationw" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_unknown_rotation[w]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_unknown_rotationk" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_unknown_rotation[K]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_unknown_rotationtufy-mb" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_unknown_rotation[tufy MB]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_unknown_rotation111111111-kb" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_unknown_rotation[111.111.111 kb]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_unknown_rotation3-ki" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_unknown_rotation[3 Ki]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_unknown_rotation20171112" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_unknown_rotation[2017.11.12]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_unknown_rotation1199" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_unknown_rotation[11:99]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_unknown_rotation010000utc" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_unknown_rotation[01:00:00!UTC]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_unknown_rotationmonday-at-2017" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_unknown_rotation[monday at 2017]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_unknown_rotatione-days" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_unknown_rotation[e days]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_unknown_rotation2-days-8-pouooi" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_unknown_rotation[2 days 8 pouooi]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_unknown_rotationfoobar" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_unknown_rotation[foobar]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_unknown_rotationw5-at-notatime" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_unknown_rotation[w5 at [not|a|time]]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_unknown_rotationnotaday-at-1200" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_unknown_rotation[[not|a|day] at 12:00]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_rotationpytest_unknown_rotationdict" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_rotation.py::test_unknown_rotation[dict]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_watchpytest_file_deleted_before_write_without_delay" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_watch.py::test_file_deleted_before_write_without_delay
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_watchpytest_file_deleted_before_write_with_delay" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_watch.py::test_file_deleted_before_write_with_delay
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_watchpytest_file_path_containing_placeholder" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_watch.py::test_file_path_containing_placeholder
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_watchpytest_file_reopened_with_arguments" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_watch.py::test_file_reopened_with_arguments
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_watchpytest_file_manually_changed" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_watch.py::test_file_manually_changed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_watchpytest_file_folder_deleted" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_watch.py::test_file_folder_deleted
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_watchpytest_file_deleted_before_rotation" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_watch.py::test_file_deleted_before_rotation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_watchpytest_file_deleted_before_compression" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_watch.py::test_file_deleted_before_compression
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_watchpytest_file_deleted_before_retention" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_watch.py::test_file_deleted_before_retention
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_watchpytest_file_correctly_reused_after_rotation" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_watch.py::test_file_correctly_reused_after_rotation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_watchpytest_file_closed_without_being_loggednone-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_watch.py::test_file_closed_without_being_logged[None-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_filesink_watchpytest_file_closed_without_being_logged-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_filesink_watch.py::test_file_closed_without_being_logged[-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattersfalse-name-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[False-{name}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattersfalse-time-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[False-{time}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattersfalse-elapsed-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[False-{elapsed}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattersfalse-elapsedseconds-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[False-{elapsed.seconds}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattersfalse-line-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[False-{line}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattersfalse-level-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[False-{level}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattersfalse-levelname-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[False-{level.name}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattersfalse-levelno-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[False-{level.no}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattersfalse-levelicon-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[False-{level.icon}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattersfalse-file-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[False-{file}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattersfalse-filename-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[False-{file.name}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattersfalse-filepath-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[False-{file.path}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattersfalse-function-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[False-{function}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattersfalse-module-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[False-{module}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattersfalse-thread-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[False-{thread}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattersfalse-threadid-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[False-{thread.id}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattersfalse-threadname-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[False-{thread.name}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattersfalse-process-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[False-{process}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattersfalse-processid-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[False-{process.id}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattersfalse-processname-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[False-{process.name}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattersfalse-message-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[False-{message}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattersfalse-s-a-u5929-1-d-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[False-%s {{a}} \u5929 {{1}} %d-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formatterstrue-name-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[True-{name}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formatterstrue-time-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[True-{time}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formatterstrue-elapsed-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[True-{elapsed}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formatterstrue-elapsedseconds-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[True-{elapsed.seconds}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formatterstrue-line-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[True-{line}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formatterstrue-level-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[True-{level}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formatterstrue-levelname-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[True-{level.name}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formatterstrue-levelno-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[True-{level.no}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formatterstrue-levelicon-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[True-{level.icon}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formatterstrue-file-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[True-{file}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formatterstrue-filename-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[True-{file.name}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formatterstrue-filepath-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[True-{file.path}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formatterstrue-function-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[True-{function}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formatterstrue-module-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[True-{module}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formatterstrue-thread-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[True-{thread}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formatterstrue-threadid-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[True-{thread.id}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formatterstrue-threadname-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[True-{thread.name}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formatterstrue-process-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[True-{process}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formatterstrue-processid-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[True-{process.id}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formatterstrue-processname-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[True-{process.name}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formatterstrue-message-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[True-{message}-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formatterstrue-s-a-u5929-1-d-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatters[True-%s {{a}} \u5929 {{1}} %d-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_file_formattersfile-timelog-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_file_formatters[file-{time}.log-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_file_formattersfile-s_au59291_d-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_file_formatters[file-%s_{{a}}\u5929{{1}}_%d-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_file_formattersdir-timelog-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_file_formatters[dir-{time}.log-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_file_formattersdir-s_au59291_d-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_file_formatters[dir-%s_{{a}}\u5929{{1}}_%d-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_file_formattersboth-timelog-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_file_formatters[both-{time}.log-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_file_formattersboth-s_au59291_d-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_file_formatters[both-%s_{{a}}\u5929{{1}}_%d-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattingfalse-1-2-3-0-args0-kwargs0-1-2-3-0-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatting[False-{1, 2, 3} - {0} - {-args0-kwargs0-{1, 2, 3} - {0} - {]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattingfalse-args1-kwargs1-1-2-3" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatting[False-{} + {} = {}-args1-kwargs1-1 + 2 = 3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattingfalse-a-b-c-args2-kwargs2-1-2-3" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatting[False-{a} + {b} = {c}-args2-kwargs2-1 + 2 = 3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattingfalse-0-two-1-args3-kwargs3-1-2-3" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatting[False-{0} + {two} = {1}-args3-kwargs3-1 + 2 = 3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattingfalse-self-or-message-or-level-args4-kwargs4-a-or-b-or-c" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatting[False-{self} or {message} or {level}-args4-kwargs4-a or b or c]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattingfalse-2f-args5-kwargs5-100" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatting[False-{:.2f}-args5-kwargs5-1.00]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattingfalse-00threed-args6-kwargs6-005" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatting[False-{0:0{three}d}-args6-kwargs6-005]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattingfalse-nope-my_dict-args7-kwargs7-nope-a-1" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatting[False-{{nope}} {my_dict} {}-args7-kwargs7-{nope} {'a': 1} {{!}}]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattingtrue-1-2-3-0-args0-kwargs0-1-2-3-0-" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatting[True-{1, 2, 3} - {0} - {-args0-kwargs0-{1, 2, 3} - {0} - {]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattingtrue-args1-kwargs1-1-2-3" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatting[True-{} + {} = {}-args1-kwargs1-1 + 2 = 3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattingtrue-a-b-c-args2-kwargs2-1-2-3" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatting[True-{a} + {b} = {c}-args2-kwargs2-1 + 2 = 3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattingtrue-0-two-1-args3-kwargs3-1-2-3" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatting[True-{0} + {two} = {1}-args3-kwargs3-1 + 2 = 3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattingtrue-self-or-message-or-level-args4-kwargs4-a-or-b-or-c" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatting[True-{self} or {message} or {level}-args4-kwargs4-a or b or c]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattingtrue-2f-args5-kwargs5-100" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatting[True-{:.2f}-args5-kwargs5-1.00]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattingtrue-00threed-args6-kwargs6-005" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatting[True-{0:0{three}d}-args6-kwargs6-005]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_log_formattingtrue-nope-my_dict-args7-kwargs7-nope-a-1" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_log_formatting[True-{{nope}} {my_dict} {}-args7-kwargs7-{nope} {'a': 1} {{!}}]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_f_globals_name_absent" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_f_globals_name_absent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_extra_formatting" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_extra_formatting
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_kwargs_in_extra_dict" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_kwargs_in_extra_dict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_non_string_message" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_non_string_message
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_non_string_message_is_str_in_recordtrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_non_string_message_is_str_in_record[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_non_string_message_is_str_in_recordfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_non_string_message_is_str_in_record[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_missing_positional_field_during_formattingtrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_missing_positional_field_during_formatting[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_missing_positional_field_during_formattingfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_missing_positional_field_during_formatting[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_missing_named_field_during_formattingtrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_missing_named_field_during_formatting[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_missing_named_field_during_formattingfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_missing_named_field_during_formatting[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_not_formattable_message" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_not_formattable_message
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_not_formattable_message_with_colors" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_not_formattable_message_with_colors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_formattingpytest_invalid_color_markup" class="md-nav__link">
    <span class="md-ellipsis">
      test_formatting.py::test_invalid_color_markup
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_get_framepytest_with_sys_getframe" class="md-nav__link">
    <span class="md-ellipsis">
      test_get_frame.py::test_with_sys_getframe
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_get_framepytest_without_sys_getframe" class="md-nav__link">
    <span class="md-ellipsis">
      test_get_frame.py::test_without_sys_getframe
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_get_framepytest_get_frame_fallback" class="md-nav__link">
    <span class="md-ellipsis">
      test_get_frame.py::test_get_frame_fallback
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interceptionpytest_formatting" class="md-nav__link">
    <span class="md-ellipsis">
      test_interception.py::test_formatting
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interceptionpytest_intercept" class="md-nav__link">
    <span class="md-ellipsis">
      test_interception.py::test_intercept
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interceptionpytest_add_before_intercept" class="md-nav__link">
    <span class="md-ellipsis">
      test_interception.py::test_add_before_intercept
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interceptionpytest_remove_interception" class="md-nav__link">
    <span class="md-ellipsis">
      test_interception.py::test_remove_interception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interceptionpytest_multiple_intercept" class="md-nav__link">
    <span class="md-ellipsis">
      test_interception.py::test_multiple_intercept
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interceptionpytest_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_interception.py::test_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interceptionpytest_level_is_no" class="md-nav__link">
    <span class="md-ellipsis">
      test_interception.py::test_level_is_no
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interceptionpytest_level_does_not_exist" class="md-nav__link">
    <span class="md-ellipsis">
      test_interception.py::test_level_does_not_exist
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interceptionpytest_level_exist_builtin" class="md-nav__link">
    <span class="md-ellipsis">
      test_interception.py::test_level_exist_builtin
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interceptionpytest_level_exists_custom" class="md-nav__link">
    <span class="md-ellipsis">
      test_interception.py::test_level_exists_custom
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_interceptionpytest_using_logging_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_interception.py::test_using_logging_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lockspytest_no_deadlock_if_logger_used_inside_sink_with_catch" class="md-nav__link">
    <span class="md-ellipsis">
      test_locks.py::test_no_deadlock_if_logger_used_inside_sink_with_catch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lockspytest_no_deadlock_if_logger_used_inside_sink_without_catch" class="md-nav__link">
    <span class="md-ellipsis">
      test_locks.py::test_no_deadlock_if_logger_used_inside_sink_without_catch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lockspytest_no_error_if_multithreading" class="md-nav__link">
    <span class="md-ellipsis">
      test_locks.py::test_no_error_if_multithreading
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_lockspytest_pickled_logger_does_not_inherit_acquired_local" class="md-nav__link">
    <span class="md-ellipsis">
      test_locks.py::test_pickled_logger_does_not_inherit_acquired_local
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_apply_spawn" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_apply_spawn
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_apply_fork" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_apply_fork
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_apply_inheritance" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_apply_inheritance
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_apply_async_spawn" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_apply_async_spawn
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_apply_async_fork" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_apply_async_fork
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_apply_async_inheritance" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_apply_async_inheritance
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_process_spawn" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_process_spawn
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_process_fork" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_process_fork
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_process_inheritance" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_process_inheritance
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_remove_in_child_process_spawn" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_remove_in_child_process_spawn
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_remove_in_child_process_fork" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_remove_in_child_process_fork
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_remove_in_child_process_inheritance" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_remove_in_child_process_inheritance
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_remove_in_main_process_spawn" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_remove_in_main_process_spawn
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_remove_in_main_process_fork" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_remove_in_main_process_fork
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_remove_in_main_process_inheritance" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_remove_in_main_process_inheritance
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_await_complete_spawn" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_await_complete_spawn
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_await_complete_fork" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_await_complete_fork
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_await_complete_inheritance" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_await_complete_inheritance
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_not_picklable_sinks_spawn" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_not_picklable_sinks_spawn
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_not_picklable_sinks_fork" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_not_picklable_sinks_fork
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_not_picklable_sinks_inheritance" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_not_picklable_sinks_inheritance
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_no_deadlock_if_internal_lock_in_usetrue-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_no_deadlock_if_internal_lock_in_use[True-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_no_deadlock_if_internal_lock_in_usetrue-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_no_deadlock_if_internal_lock_in_use[True-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_no_deadlock_if_internal_lock_in_usefalse-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_no_deadlock_if_internal_lock_in_use[False-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_no_deadlock_if_internal_lock_in_usefalse-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_no_deadlock_if_internal_lock_in_use[False-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_no_deadlock_if_external_lock_in_usetrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_no_deadlock_if_external_lock_in_use[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_multiprocessingpytest_no_deadlock_if_external_lock_in_usefalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_multiprocessing.py::test_no_deadlock_if_external_lock_in_use[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_record" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_record
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_record_in_kwargs_too" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_record_in_kwargs_too
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_record_not_in_extra" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_record_not_in_extra
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_kwargs_in_extra_of_record" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_kwargs_in_extra_of_record
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_exception_boolean" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_exception_boolean
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_exception_exc_info" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_exception_exc_info
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_exception_class" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_exception_class
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_exception_log_funcion" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_exception_log_funcion
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_lazy" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_lazy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_logging_within_lazy_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_logging_within_lazy_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_depth" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_depth
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_capture" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_capture
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_not_colorize" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_not_colorize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_doesnt_color_unrelated" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_doesnt_color_unrelated
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_doesnt_strip_unrelated" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_doesnt_strip_unrelated
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_doesnt_raise_unrelated_colorize" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_doesnt_raise_unrelated_colorize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_doesnt_raise_unrelated_not_colorize" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_doesnt_raise_unrelated_not_colorize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_doesnt_raise_unrelated_colorize_dynamic" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_doesnt_raise_unrelated_colorize_dynamic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_doesnt_raise_unrelated_not_colorize_dynamic" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_doesnt_raise_unrelated_not_colorize_dynamic
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_within_recordtrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_within_record[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_within_recordfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_within_record[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_nestedtrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_nested[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_nestedfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_nested[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_stripped_in_message_recordtrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_stripped_in_message_record[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_stripped_in_message_recordfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_stripped_in_message_record[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_invalid_markup_in_messagetrue-" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_invalid_markup_in_message[True-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#red_1" class="md-nav__link">
    <span class="md-ellipsis">
      red&gt;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#red-y" class="md-nav__link">
    <span class="md-ellipsis">
      red&gt; Y]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_invalid_markup_in_messagefalse-" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_invalid_markup_in_message[False-]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#red_2" class="md-nav__link">
    <span class="md-ellipsis">
      red&gt;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#red-y_1" class="md-nav__link">
    <span class="md-ellipsis">
      red&gt; Y]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_with_argstrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_with_args[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_with_argsfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_with_args[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_with_leveltrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_with_level[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_with_levelfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_with_level[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_double_messagetrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_double_message[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_double_messagefalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_double_message[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_multiple_callstrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_multiple_calls[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_multiple_callsfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_multiple_calls[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_multiple_calls_level_color_changedtrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_multiple_calls_level_color_changed[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_multiple_calls_level_color_changedfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_multiple_calls_level_color_changed[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_with_dynamic_formattertrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_with_dynamic_formatter[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_with_dynamic_formatterfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_with_dynamic_formatter[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_with_format_specstrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_with_format_specs[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_with_format_specsfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_with_format_specs[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_with_message_specstrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_with_message_specs[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_with_message_specsfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_with_message_specs[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colored_string_used_as_spectrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colored_string_used_as_spec[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colored_string_used_as_specfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colored_string_used_as_spec[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colored_string_getitemtrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colored_string_getitem[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colored_string_getitemfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colored_string_getitem[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_without_formatting_argstrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_without_formatting_args[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_without_formatting_argsfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_without_formatting_args[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_with_recursion_depth_exceeded_in_formattrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_with_recursion_depth_exceeded_in_format[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_with_recursion_depth_exceeded_in_formatfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_with_recursion_depth_exceeded_in_format[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_with_recursion_depth_exceeded_in_messagetrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_with_recursion_depth_exceeded_in_message[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_with_recursion_depth_exceeded_in_messagefalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_with_recursion_depth_exceeded_in_message[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_with_auto_indexingtrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_with_auto_indexing[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_with_auto_indexingfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_with_auto_indexing[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_with_manual_indexingtrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_with_manual_indexing[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_with_manual_indexingfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_with_manual_indexing[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_with_invalid_indexing-0-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_with_invalid_indexing[{} {0}-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_with_invalid_indexing-0-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_with_invalid_indexing[{} {0}-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_with_invalid_indexing1-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_with_invalid_indexing[{1} {}-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_colors_with_invalid_indexing1-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_colors_with_invalid_indexing[{1} {}-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_raw" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_raw
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_raw_with_format_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_raw_with_format_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_raw_with_colorstrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_raw_with_colors[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_raw_with_colorsfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_raw_with_colors[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_args_with_colors_not_formatted_twice" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_args_with_colors_not_formatted_twice
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_level_tag_wrapping_with_colorstrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_level_tag_wrapping_with_colors[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_level_tag_wrapping_with_colorsfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_level_tag_wrapping_with_colors[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-true-true-true-true-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-True-True-True-True-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-true-true-true-true-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-True-True-True-True-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-true-true-true-false-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-True-True-True-False-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-true-true-true-false-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-True-True-True-False-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-true-true-false-true-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-True-True-False-True-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-true-true-false-true-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-True-True-False-True-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-true-true-false-false-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-True-True-False-False-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-true-true-false-false-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-True-True-False-False-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-true-false-true-true-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-True-False-True-True-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-true-false-true-true-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-True-False-True-True-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-true-false-true-false-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-True-False-True-False-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-true-false-true-false-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-True-False-True-False-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-true-false-false-true-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-True-False-False-True-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-true-false-false-true-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-True-False-False-True-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-true-false-false-false-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-True-False-False-False-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-true-false-false-false-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-True-False-False-False-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-false-true-true-true-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-False-True-True-True-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-false-true-true-true-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-False-True-True-True-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-false-true-true-false-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-False-True-True-False-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-false-true-true-false-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-False-True-True-False-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-false-true-false-true-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-False-True-False-True-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-false-true-false-true-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-False-True-False-True-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-false-true-false-false-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-False-True-False-False-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-false-true-false-false-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-False-True-False-False-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-false-false-true-true-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-False-False-True-True-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-false-false-true-true-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-False-False-True-True-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-false-false-true-false-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-False-False-True-False-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-false-false-true-false-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-False-False-True-False-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-false-false-false-true-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-False-False-False-True-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-false-false-false-true-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-False-False-False-True-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-false-false-false-false-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-False-False-False-False-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationstrue-false-false-false-false-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[True-False-False-False-False-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-true-true-true-true-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-True-True-True-True-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-true-true-true-true-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-True-True-True-True-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-true-true-true-false-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-True-True-True-False-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-true-true-true-false-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-True-True-True-False-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-true-true-false-true-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-True-True-False-True-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-true-true-false-true-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-True-True-False-True-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-true-true-false-false-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-True-True-False-False-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-true-true-false-false-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-True-True-False-False-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-true-false-true-true-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-True-False-True-True-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-true-false-true-true-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-True-False-True-True-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-true-false-true-false-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-True-False-True-False-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-true-false-true-false-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-True-False-True-False-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-true-false-false-true-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-True-False-False-True-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-true-false-false-true-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-True-False-False-True-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-true-false-false-false-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-True-False-False-False-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-true-false-false-false-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-True-False-False-False-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-false-true-true-true-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-False-True-True-True-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-false-true-true-true-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-False-True-True-True-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-false-true-true-false-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-False-True-True-False-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-false-true-true-false-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-False-True-True-False-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-false-true-false-true-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-False-True-False-True-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-false-true-false-true-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-False-True-False-True-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-false-true-false-false-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-False-True-False-False-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-false-true-false-false-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-False-True-False-False-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-false-false-true-true-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-False-False-True-True-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-false-false-true-true-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-False-False-True-True-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-false-false-true-false-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-False-False-True-False-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-false-false-true-false-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-False-False-True-False-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-false-false-false-true-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-False-False-False-True-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-false-false-false-true-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-False-False-False-True-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-false-false-false-false-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-False-False-False-False-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_all_colors_combinationsfalse-false-false-false-false-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_all_colors_combinations[False-False-False-False-False-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_raw_with_record" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_raw_with_record
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_keep_extra" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_keep_extra
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_before_bind" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_before_bind
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_deprecated_ansi_argument" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_deprecated_ansi_argument
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_message_update_not_overridden_by_patchtrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_message_update_not_overridden_by_patch[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_message_update_not_overridden_by_patchfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_message_update_not_overridden_by_patch[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_message_update_not_overridden_by_formattrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_message_update_not_overridden_by_format[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_message_update_not_overridden_by_formatfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_message_update_not_overridden_by_format[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_message_update_not_overridden_by_filtertrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_message_update_not_overridden_by_filter[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_message_update_not_overridden_by_filterfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_message_update_not_overridden_by_filter[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_message_update_not_overridden_by_rawtrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_message_update_not_overridden_by_raw[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_message_update_not_overridden_by_rawfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_message_update_not_overridden_by_raw[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_optpytest_overridden_message_ignore_colors" class="md-nav__link">
    <span class="md-ellipsis">
      test_opt.py::test_overridden_message_ignore_colors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_file" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_file
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_fileobj" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_fileobj
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_pathlib" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_pathlib
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_string_pattern" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_string_pattern
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_regex_pattern" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_regex_pattern
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_multiline_pattern" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_multiline_pattern
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_without_group" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_without_group
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_parse_bytes" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_parse_bytes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_chunk-1" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_chunk[-1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_chunk1" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_chunk[1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_chunk65536" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_chunk[65536]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_positive_lookbehind_pattern" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_positive_lookbehind_pattern
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_greedy_pattern" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_greedy_pattern
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_cast_dict" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_cast_dict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_cast_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_cast_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_cast_with_irrelevant_arg" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_cast_with_irrelevant_arg
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parsepytest_cast_with_irrelevant_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_parse.py::test_cast_with_irrelevant_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpytest_patch_after_add" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::test_patch_after_add
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpytest_patch_before_add" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::test_patch_before_add
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpytest_add_using_patched" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::test_add_using_patched
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpytest_not_override_parent_logger" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::test_not_override_parent_logger
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpytest_override_previous_patched" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::test_override_previous_patched
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpytest_no_conflict" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::test_no_conflict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpytest_override_configured" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::test_override_configured
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_patchpytest_multiple_patches" class="md-nav__link">
    <span class="md-ellipsis">
      test_patch.py::test_multiple_patches
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_function_handler" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_function_handler
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_coroutine_function_handler" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_coroutine_function_handler
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_stream_handlertrue-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_stream_handler[True-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_stream_handlertrue-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_stream_handler[True-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_stream_handlerfalse-true" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_stream_handler[False-True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_stream_handlerfalse-false" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_stream_handler[False-False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_standard_handler" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_standard_handler
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_standard_handler_root_logger_not_picklable" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_standard_handler_root_logger_not_picklable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_file_handler" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_file_handler
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_file_handler_rotation1000" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_file_handler_rotation[1000]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_file_handler_rotationdaily" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_file_handler_rotation[daily]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_file_handler_rotationrotation2" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_file_handler_rotation[rotation2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_file_handler_rotationrotation3" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_file_handler_rotation[rotation3]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_file_handler_rotation200-mb" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_file_handler_rotation[200 MB]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_file_handler_rotation1000_1" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_file_handler_rotation[10:00]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_file_handler_rotation5-hours" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_file_handler_rotation[5 hours]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_file_handler_rotationrotation_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_file_handler_rotation[rotation_function]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_file_handler_retention1000" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_file_handler_retention[1000]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_file_handler_retentionretention1" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_file_handler_retention[retention1]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_file_handler_retention10-days" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_file_handler_retention[10 days]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_file_handler_retentionretention_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_file_handler_retention[retention_function]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_file_handler_compressionzip" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_file_handler_compression[zip]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_file_handler_compressiongz" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_file_handler_compression[gz]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_file_handler_compressiontar" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_file_handler_compression[tar]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_file_handler_compressioncompression_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_file_handler_compression[compression_function]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_no_handler" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_no_handler
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_handler_not_serializable" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_handler_not_serializable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_filter_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_filter_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_filter_name" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_filter_name[]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_filter_nametests" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_filter_name[tests]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_format_stringtrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_format_string[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_format_stringfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_format_string[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_format_functiontrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_format_function[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_format_functionfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_format_function[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_filter_function_not_serializable" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_filter_function_not_serializable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_format_function_not_serializable" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_format_function_not_serializable
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_bound_logger" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_bound_logger
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_patched_logger" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_patched_logger
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_remove_after_pickling" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_remove_after_pickling
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_logging_method" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_logging_method
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_picklingpytest_pickling_log_method" class="md-nav__link">
    <span class="md-ellipsis">
      test_pickling.py::test_pickling_log_method
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propagationpytest_formatting" class="md-nav__link">
    <span class="md-ellipsis">
      test_propagation.py::test_formatting
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propagationpytest_propagate" class="md-nav__link">
    <span class="md-ellipsis">
      test_propagation.py::test_propagate
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propagationpytest_remove_propagation" class="md-nav__link">
    <span class="md-ellipsis">
      test_propagation.py::test_remove_propagation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propagationpytest_exceptionfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_propagation.py::test_exception[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_propagationpytest_exceptiontrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_propagation.py::test_exception[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recattrpytest_patch_record_file" class="md-nav__link">
    <span class="md-ellipsis">
      test_recattr.py::test_patch_record_file
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recattrpytest_patch_record_thread" class="md-nav__link">
    <span class="md-ellipsis">
      test_recattr.py::test_patch_record_thread
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recattrpytest_patch_record_process" class="md-nav__link">
    <span class="md-ellipsis">
      test_recattr.py::test_patch_record_process
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_recattrpytest_patch_record_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_recattr.py::test_patch_record_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_removepytest_remove_all" class="md-nav__link">
    <span class="md-ellipsis">
      test_remove.py::test_remove_all
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_removepytest_remove_simple" class="md-nav__link">
    <span class="md-ellipsis">
      test_remove.py::test_remove_simple
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_removepytest_remove_enqueue" class="md-nav__link">
    <span class="md-ellipsis">
      test_remove.py::test_remove_enqueue
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_removepytest_remove_enqueue_filesink" class="md-nav__link">
    <span class="md-ellipsis">
      test_remove.py::test_remove_enqueue_filesink
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_removepytest_exception_in_stop_during_remove_one" class="md-nav__link">
    <span class="md-ellipsis">
      test_remove.py::test_exception_in_stop_during_remove_one
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_removepytest_exception_in_stop_not_caught_during_remove_all" class="md-nav__link">
    <span class="md-ellipsis">
      test_remove.py::test_exception_in_stop_not_caught_during_remove_all
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_removepytest_invalid_handler_id_value" class="md-nav__link">
    <span class="md-ellipsis">
      test_remove.py::test_invalid_handler_id_value
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_removepytest_invalid_handler_id_typehandler_id0" class="md-nav__link">
    <span class="md-ellipsis">
      test_remove.py::test_invalid_handler_id_type[handler_id0]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_removepytest_invalid_handler_id_typesys" class="md-nav__link">
    <span class="md-ellipsis">
      test_remove.py::test_invalid_handler_id_type[sys]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_removepytest_invalid_handler_id_typehandler_id2" class="md-nav__link">
    <span class="md-ellipsis">
      test_remove.py::test_invalid_handler_id_type[handler_id2]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_removepytest_invalid_handler_id_typeint" class="md-nav__link">
    <span class="md-ellipsis">
      test_remove.py::test_invalid_handler_id_type[int]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_reprpytest_stderr" class="md-nav__link">
    <span class="md-ellipsis">
      test_repr.py::test_stderr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_reprpytest_stdout" class="md-nav__link">
    <span class="md-ellipsis">
      test_repr.py::test_stdout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_reprpytest_file_object" class="md-nav__link">
    <span class="md-ellipsis">
      test_repr.py::test_file_object
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_reprpytest_file_str" class="md-nav__link">
    <span class="md-ellipsis">
      test_repr.py::test_file_str
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_reprpytest_file_pathlib" class="md-nav__link">
    <span class="md-ellipsis">
      test_repr.py::test_file_pathlib
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_reprpytest_stream_object" class="md-nav__link">
    <span class="md-ellipsis">
      test_repr.py::test_stream_object
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_reprpytest_stream_object_without_name_attr" class="md-nav__link">
    <span class="md-ellipsis">
      test_repr.py::test_stream_object_without_name_attr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_reprpytest_stream_object_with_empty_name" class="md-nav__link">
    <span class="md-ellipsis">
      test_repr.py::test_stream_object_with_empty_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_reprpytest_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_repr.py::test_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_reprpytest_callable_without_name" class="md-nav__link">
    <span class="md-ellipsis">
      test_repr.py::test_callable_without_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_reprpytest_callable_with_empty_name" class="md-nav__link">
    <span class="md-ellipsis">
      test_repr.py::test_callable_with_empty_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_reprpytest_coroutine_function" class="md-nav__link">
    <span class="md-ellipsis">
      test_repr.py::test_coroutine_function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_reprpytest_coroutine_callable_without_name" class="md-nav__link">
    <span class="md-ellipsis">
      test_repr.py::test_coroutine_callable_without_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_reprpytest_coroutine_function_with_empty_name" class="md-nav__link">
    <span class="md-ellipsis">
      test_repr.py::test_coroutine_function_with_empty_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_reprpytest_standard_handler" class="md-nav__link">
    <span class="md-ellipsis">
      test_repr.py::test_standard_handler
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_reprpytest_multiple_handlers" class="md-nav__link">
    <span class="md-ellipsis">
      test_repr.py::test_multiple_handlers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_reprpytest_handler_removed" class="md-nav__link">
    <span class="md-ellipsis">
      test_repr.py::test_handler_removed
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_reprpytest_handler_level_name" class="md-nav__link">
    <span class="md-ellipsis">
      test_repr.py::test_handler_level_name
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_reprpytest_handler_level_num" class="md-nav__link">
    <span class="md-ellipsis">
      test_repr.py::test_handler_level_num
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_standard_handlerpytest_stream_handler" class="md-nav__link">
    <span class="md-ellipsis">
      test_standard_handler.py::test_stream_handler
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_standard_handlerpytest_file_handler" class="md-nav__link">
    <span class="md-ellipsis">
      test_standard_handler.py::test_file_handler
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_standard_handlerpytest_extra_dict" class="md-nav__link">
    <span class="md-ellipsis">
      test_standard_handler.py::test_extra_dict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_standard_handlerpytest_no_conflict_with_extra_dict" class="md-nav__link">
    <span class="md-ellipsis">
      test_standard_handler.py::test_no_conflict_with_extra_dict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_standard_handlerpytest_no_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_standard_handler.py::test_no_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_standard_handlerpytest_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_standard_handler.py::test_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_standard_handlerpytest_exception_formatting" class="md-nav__link">
    <span class="md-ellipsis">
      test_standard_handler.py::test_exception_formatting
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_standard_handlerpytest_standard_formatterfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_standard_handler.py::test_standard_formatter[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_standard_handlerpytest_standard_formattertrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_standard_handler.py::test_standard_formatter[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_standard_handlerpytest_standard_formatter_with_new_linefalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_standard_handler.py::test_standard_formatter_with_new_line[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_standard_handlerpytest_standard_formatter_with_new_linetrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_standard_handler.py::test_standard_formatter_with_new_line[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_standard_handlerpytest_raw_standard_formatterfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_standard_handler.py::test_raw_standard_formatter[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_standard_handlerpytest_raw_standard_formattertrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_standard_handler.py::test_raw_standard_formatter[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_standard_handlerpytest_raw_standard_formatter_with_new_linefalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_standard_handler.py::test_raw_standard_formatter_with_new_line[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_standard_handlerpytest_raw_standard_formatter_with_new_linetrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_standard_handler.py::test_raw_standard_formatter_with_new_line[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_threadingpytest_safe_logging" class="md-nav__link">
    <span class="md-ellipsis">
      test_threading.py::test_safe_logging
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_threadingpytest_safe_adding_while_logging" class="md-nav__link">
    <span class="md-ellipsis">
      test_threading.py::test_safe_adding_while_logging
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_threadingpytest_safe_removing_while_logging" class="md-nav__link">
    <span class="md-ellipsis">
      test_threading.py::test_safe_removing_while_logging
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlbasic_logger_usagemethodtrace" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::basic_logger_usage[method=trace]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlbasic_logger_usagemethoddebug" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::basic_logger_usage[method=debug]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlbasic_logger_usagemethodinfo" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::basic_logger_usage[method=info]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlbasic_logger_usagemethodsuccess" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::basic_logger_usage[method=success]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlbasic_logger_usagemethodwarning" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::basic_logger_usage[method=warning]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlbasic_logger_usagemethoderror" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::basic_logger_usage[method=error]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlbasic_logger_usagemethodexception" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::basic_logger_usage[method=exception]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlbasic_logger_usagemethodcritical" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::basic_logger_usage[method=critical]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlusing_log_functionlevelinfo" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::using_log_function[level='INFO']
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlusing_log_functionlevel30" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::using_log_function[level=30]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlusing_logging_arguments" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::using_logging_arguments
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymllogging_non_stringmessage123" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::logging_non_string[message=123]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymllogging_non_stringmessagedictfoo456" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::logging_non_string[message=dict(foo=456)]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymllogging_non_stringmessageobject" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::logging_non_string[message=object()]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymladd_sinksinksysstderr" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::add_sink[sink=sys.stderr]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymladd_sinksinktesttxt" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::add_sink[sink='test.txt']
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymladd_sinksinkpathfilelog" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::add_sink[sink=Path('file.log')]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymladd_sinksinklambda-m-none" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::add_sink[sink=lambda m: None]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymladd_sinksinkstreamhandler" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::add_sink[sink=StreamHandler()]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlbasic_sink_optionsformatmessagefiltermodulecontextfork" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::basic_sink_options[format='{message}',filter='module',context='fork']
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlbasic_sink_optionsformatlambda-r-messagenfilterlambda-r-truecontextget_contextfork" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::basic_sink_options[format=lambda r: '{message}\n',filter=lambda r: True,context=get_context('fork')]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlfile_sink_options" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::file_sink_options
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlasync_sink_options" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::async_sink_options
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlremove_sink" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::remove_sink
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlawait_completion" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::await_completion
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlcatch_as_decorator_with_parentheses" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::catch_as_decorator_with_parentheses
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlcatch_as_decorator_without_parentheses" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::catch_as_decorator_without_parentheses
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlcatch_as_context_manager" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::catch_as_context_manager
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlopt" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::opt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlbind" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::bind
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlpatch" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::patch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlcontextualize" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::contextualize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymllevel_get" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::level_get
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymllevel_set" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::level_set
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymllevel_update" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::level_update
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlenable_and_disable_logger" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::enable_and_disable_logger
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlconfigure" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::configure
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlparse" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::parse
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlinvalid_add_argument" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::invalid_add_argument
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlinvalid_logged_object_formatting" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::invalid_logged_object_formatting
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlinvalid_configuration" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::invalid_configuration
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_openhands-commit0_openhands">back to OpenHands summary</a></p>
<h1 id="openhands-loguru"><strong>OpenHands</strong>: loguru</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">218</td>
</tr>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">1217</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">38</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">1473</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">1473</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_activationpytest_disabletest-true">test_activation.py::test_disable[test-True]</h3>
<details><summary> <pre>test_activation.py::test_disable[test-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b7520e0>, name = 'test'
should_log = True

    @pytest.mark.parametrize(
        "name, should_log",
        [
            ("", False),
            ("tests", False),
            ("test", True),
            ("testss", True),
            ("tests.", True),
            ("tests.test_activation", False),
            ("tests.test_activation.", True),
            ("test_activation", True),
            (".", True),
        ],
    )
    def test_disable(writer, name, should_log):
        logger.add(writer, format="{message}")
        logger.disable(name)
        logger.debug("message")
        result = writer.read()

        if should_log:
>           assert result == "message\n"
E           AssertionError: assert '' == 'message\n'
E             
E             - message

name       = 'test'
result     = ''
should_log = True
writer     = <function writer.<locals>.w at 0x7fac0b7520e0>

tests/test_activation.py:27: AssertionError
</pre>
</details>
<h3 id="test_activationpytest_disabletestss-true">test_activation.py::test_disable[testss-True]</h3>
<details><summary> <pre>test_activation.py::test_disable[testss-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b753b50>, name = 'testss'
should_log = True

    @pytest.mark.parametrize(
        "name, should_log",
        [
            ("", False),
            ("tests", False),
            ("test", True),
            ("testss", True),
            ("tests.", True),
            ("tests.test_activation", False),
            ("tests.test_activation.", True),
            ("test_activation", True),
            (".", True),
        ],
    )
    def test_disable(writer, name, should_log):
        logger.add(writer, format="{message}")
        logger.disable(name)
        logger.debug("message")
        result = writer.read()

        if should_log:
>           assert result == "message\n"
E           AssertionError: assert '' == 'message\n'
E             
E             - message

name       = 'testss'
result     = ''
should_log = True
writer     = <function writer.<locals>.w at 0x7fac0b753b50>

tests/test_activation.py:27: AssertionError
</pre>
</details>
<h3 id="test_activationpytest_disabletests-true">test_activation.py::test_disable[tests.-True]</h3>
<details><summary> <pre>test_activation.py::test_disable[tests.-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b753ac0>, name = 'tests.'
should_log = True

    @pytest.mark.parametrize(
        "name, should_log",
        [
            ("", False),
            ("tests", False),
            ("test", True),
            ("testss", True),
            ("tests.", True),
            ("tests.test_activation", False),
            ("tests.test_activation.", True),
            ("test_activation", True),
            (".", True),
        ],
    )
    def test_disable(writer, name, should_log):
        logger.add(writer, format="{message}")
        logger.disable(name)
        logger.debug("message")
        result = writer.read()

        if should_log:
>           assert result == "message\n"
E           AssertionError: assert '' == 'message\n'
E             
E             - message

name       = 'tests.'
result     = ''
should_log = True
writer     = <function writer.<locals>.w at 0x7fac0b753ac0>

tests/test_activation.py:27: AssertionError
</pre>
</details>
<h3 id="test_activationpytest_disableteststest_activation-true">test_activation.py::test_disable[tests.test_activation.-True]</h3>
<details><summary> <pre>test_activation.py::test_disable[tests.test_activation.-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b753c70>
name = 'tests.test_activation.', should_log = True

    @pytest.mark.parametrize(
        "name, should_log",
        [
            ("", False),
            ("tests", False),
            ("test", True),
            ("testss", True),
            ("tests.", True),
            ("tests.test_activation", False),
            ("tests.test_activation.", True),
            ("test_activation", True),
            (".", True),
        ],
    )
    def test_disable(writer, name, should_log):
        logger.add(writer, format="{message}")
        logger.disable(name)
        logger.debug("message")
        result = writer.read()

        if should_log:
>           assert result == "message\n"
E           AssertionError: assert '' == 'message\n'
E             
E             - message

name       = 'tests.test_activation.'
result     = ''
should_log = True
writer     = <function writer.<locals>.w at 0x7fac0b753c70>

tests/test_activation.py:27: AssertionError
</pre>
</details>
<h3 id="test_activationpytest_disabletest_activation-true">test_activation.py::test_disable[test_activation-True]</h3>
<details><summary> <pre>test_activation.py::test_disable[test_activation-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b753e20>
name = 'test_activation', should_log = True

    @pytest.mark.parametrize(
        "name, should_log",
        [
            ("", False),
            ("tests", False),
            ("test", True),
            ("testss", True),
            ("tests.", True),
            ("tests.test_activation", False),
            ("tests.test_activation.", True),
            ("test_activation", True),
            (".", True),
        ],
    )
    def test_disable(writer, name, should_log):
        logger.add(writer, format="{message}")
        logger.disable(name)
        logger.debug("message")
        result = writer.read()

        if should_log:
>           assert result == "message\n"
E           AssertionError: assert '' == 'message\n'
E             
E             - message

name       = 'test_activation'
result     = ''
should_log = True
writer     = <function writer.<locals>.w at 0x7fac0b753e20>

tests/test_activation.py:27: AssertionError
</pre>
</details>
<h3 id="test_activationpytest_disable-true">test_activation.py::test_disable[.-True]</h3>
<details><summary> <pre>test_activation.py::test_disable[.-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b753490>, name = '.'
should_log = True

    @pytest.mark.parametrize(
        "name, should_log",
        [
            ("", False),
            ("tests", False),
            ("test", True),
            ("testss", True),
            ("tests.", True),
            ("tests.test_activation", False),
            ("tests.test_activation.", True),
            ("test_activation", True),
            (".", True),
        ],
    )
    def test_disable(writer, name, should_log):
        logger.add(writer, format="{message}")
        logger.disable(name)
        logger.debug("message")
        result = writer.read()

        if should_log:
>           assert result == "message\n"
E           AssertionError: assert '' == 'message\n'
E             
E             - message

name       = '.'
result     = ''
should_log = True
writer     = <function writer.<locals>.w at 0x7fac0b753490>

tests/test_activation.py:27: AssertionError
</pre>
</details>
<h3 id="test_activationpytest_enable-true">test_activation.py::test_enable[-True]</h3>
<details><summary> <pre>test_activation.py::test_enable[-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b7536d0>, name = ''
should_log = True

    @pytest.mark.parametrize(
        "name, should_log",
        [
            ("", True),
            ("tests", True),
            ("test", False),
            ("testss", False),
            ("tests.", False),
            ("tests.test_activation", True),
            ("tests.test_activation.", False),
            ("test_activation", False),
            (".", False),
        ],
    )
    def test_enable(writer, name, should_log):
        logger.add(writer, format="{message}")
        logger.disable("")
        logger.enable(name)
        logger.debug("message")
        result = writer.read()

        if should_log:
>           assert result == "message\n"
E           AssertionError: assert '' == 'message\n'
E             
E             - message

name       = ''
result     = ''
should_log = True
writer     = <function writer.<locals>.w at 0x7fac0b7536d0>

tests/test_activation.py:54: AssertionError
</pre>
</details>
<h3 id="test_activationpytest_enabletests-true">test_activation.py::test_enable[tests-True]</h3>
<details><summary> <pre>test_activation.py::test_enable[tests-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b753760>, name = 'tests'
should_log = True

    @pytest.mark.parametrize(
        "name, should_log",
        [
            ("", True),
            ("tests", True),
            ("test", False),
            ("testss", False),
            ("tests.", False),
            ("tests.test_activation", True),
            ("tests.test_activation.", False),
            ("test_activation", False),
            (".", False),
        ],
    )
    def test_enable(writer, name, should_log):
        logger.add(writer, format="{message}")
        logger.disable("")
        logger.enable(name)
        logger.debug("message")
        result = writer.read()

        if should_log:
>           assert result == "message\n"
E           AssertionError: assert '' == 'message\n'
E             
E             - message

name       = 'tests'
result     = ''
should_log = True
writer     = <function writer.<locals>.w at 0x7fac0b753760>

tests/test_activation.py:54: AssertionError
</pre>
</details>
<h3 id="test_activationpytest_enableteststest_activation-true">test_activation.py::test_enable[tests.test_activation-True]</h3>
<details><summary> <pre>test_activation.py::test_enable[tests.test_activation-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b752b90>
name = 'tests.test_activation', should_log = True

    @pytest.mark.parametrize(
        "name, should_log",
        [
            ("", True),
            ("tests", True),
            ("test", False),
            ("testss", False),
            ("tests.", False),
            ("tests.test_activation", True),
            ("tests.test_activation.", False),
            ("test_activation", False),
            (".", False),
        ],
    )
    def test_enable(writer, name, should_log):
        logger.add(writer, format="{message}")
        logger.disable("")
        logger.enable(name)
        logger.debug("message")
        result = writer.read()

        if should_log:
>           assert result == "message\n"
E           AssertionError: assert '' == 'message\n'
E             
E             - message

name       = 'tests.test_activation'
result     = ''
should_log = True
writer     = <function writer.<locals>.w at 0x7fac0b752b90>

tests/test_activation.py:54: AssertionError
</pre>
</details>
<h3 id="test_activationpytest_log_before_enable">test_activation.py::test_log_before_enable</h3>
<details><summary> <pre>test_activation.py::test_log_before_enable</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b752320>

    def test_log_before_enable(writer):
        logger.add(writer, format="{message}")
        logger.disable("")
        logger.debug("nope")
        logger.enable("tests")
        logger.debug("yes")
        result = writer.read()
>       assert result == "yes\n"
E       AssertionError: assert '' == 'yes\n'
E         
E         - yes

result     = ''
writer     = <function writer.<locals>.w at 0x7fac0b752320>

tests/test_activation.py:66: AssertionError
</pre>
</details>
<h3 id="test_activationpytest_log_before_disable">test_activation.py::test_log_before_disable</h3>
<details><summary> <pre>test_activation.py::test_log_before_disable</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b72eef0>

    def test_log_before_disable(writer):
        logger.add(writer, format="{message}")
        logger.enable("")
        logger.debug("yes")
        logger.disable("tests")
        logger.debug("nope")
        result = writer.read()
>       assert result == "yes\n"
E       AssertionError: assert '' == 'yes\n'
E         
E         - yes

result     = ''
writer     = <function writer.<locals>.w at 0x7fac0b72eef0>

tests/test_activation.py:76: AssertionError
</pre>
</details>
<h3 id="test_activationpytest_multiple_activations">test_activation.py::test_multiple_activations</h3>
<details><summary> <pre>test_activation.py::test_multiple_activations</pre></summary><pre>
def test_multiple_activations():
        def n():
            return len(logger._core.activation_list)

        assert n() == 0
        logger.enable("")
        assert n() == 0
        logger.disable("")
>       assert n() == 1
E       assert 0 == 1
E        +  where 0 = <function test_multiple_activations.<locals>.n at 0x7fac0b72f010>()

n          = <function test_multiple_activations.<locals>.n at 0x7fac0b72f010>

tests/test_activation.py:87: AssertionError
</pre>
</details>
<h3 id="test_activationpytest_log_before_enable_f_globals_name_absent">test_activation.py::test_log_before_enable_f_globals_name_absent</h3>
<details><summary> <pre>test_activation.py::test_log_before_enable_f_globals_name_absent</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b752710>
f_globals_name_absent = None

    def test_log_before_enable_f_globals_name_absent(writer, f_globals_name_absent):
        logger.add(writer, format="{message}")
        logger.disable(None)
        logger.debug("nope")
        logger.enable(None)
        logger.debug("yes")
        result = writer.read()
>       assert result == "yes\n"
E       AssertionError: assert '' == 'yes\n'
E         
E         - yes

f_globals_name_absent = None
result     = ''
writer     = <function writer.<locals>.w at 0x7fac0b752710>

tests/test_activation.py:117: AssertionError
</pre>
</details>
<h3 id="test_activationpytest_log_before_disable_f_globals_name_absent">test_activation.py::test_log_before_disable_f_globals_name_absent</h3>
<details><summary> <pre>test_activation.py::test_log_before_disable_f_globals_name_absent</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b753520>
f_globals_name_absent = None

    def test_log_before_disable_f_globals_name_absent(writer, f_globals_name_absent):
        logger.add(writer, format="{message}")
        logger.enable(None)
        logger.debug("yes")
        logger.disable(None)
        logger.debug("nope")
        result = writer.read()
>       assert result == "yes\n"
E       AssertionError: assert '' == 'yes\n'
E         
E         - yes

f_globals_name_absent = None
result     = ''
writer     = <function writer.<locals>.w at 0x7fac0b753520>

tests/test_activation.py:127: AssertionError
</pre>
</details>
<h3 id="test_activationpytest_f_globals_name_absent_with_others">test_activation.py::test_f_globals_name_absent_with_others</h3>
<details><summary> <pre>test_activation.py::test_f_globals_name_absent_with_others</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b7529e0>
f_globals_name_absent = None

    def test_f_globals_name_absent_with_others(writer, f_globals_name_absent):
        logger.add(writer, format="{message}")
        logger.info("1")
        logger.enable(None)
        logger.disable("foobar")
        logger.enable("foo.bar")
        logger.disable(None)
        logger.info("2")
        logger.enable("foobar")
        logger.enable(None)
        logger.info("3")
>       assert writer.read() == "1\n3\n"
E       AssertionError: assert '' == '1\n3\n'
E         
E         - 1
E         - 3

f_globals_name_absent = None
writer     = <function writer.<locals>.w at 0x7fac0b7529e0>

tests/test_activation.py:141: AssertionError
</pre>
</details>
<h3 id="test_activationpytest_invalid_enable_name42">test_activation.py::test_invalid_enable_name[42]</h3>
<details><summary> <pre>test_activation.py::test_invalid_enable_name[42]</pre></summary><pre>
name = 42

    @pytest.mark.parametrize("name", [42, [], object()])
    def test_invalid_enable_name(name):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

name       = 42

tests/test_activation.py:146: Failed
</pre>
</details>
<h3 id="test_activationpytest_invalid_enable_namename1">test_activation.py::test_invalid_enable_name[name1]</h3>
<details><summary> <pre>test_activation.py::test_invalid_enable_name[name1]</pre></summary><pre>
name = []

    @pytest.mark.parametrize("name", [42, [], object()])
    def test_invalid_enable_name(name):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

name       = []

tests/test_activation.py:146: Failed
</pre>
</details>
<h3 id="test_activationpytest_invalid_enable_namename2">test_activation.py::test_invalid_enable_name[name2]</h3>
<details><summary> <pre>test_activation.py::test_invalid_enable_name[name2]</pre></summary><pre>
name = <object object at 0x7fac0db8ac60>

    @pytest.mark.parametrize("name", [42, [], object()])
    def test_invalid_enable_name(name):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

name       = <object object at 0x7fac0db8ac60>

tests/test_activation.py:146: Failed
</pre>
</details>
<h3 id="test_activationpytest_invalid_disable_name42">test_activation.py::test_invalid_disable_name[42]</h3>
<details><summary> <pre>test_activation.py::test_invalid_disable_name[42]</pre></summary><pre>
name = 42

    @pytest.mark.parametrize("name", [42, [], object()])
    def test_invalid_disable_name(name):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

name       = 42

tests/test_activation.py:152: Failed
</pre>
</details>
<h3 id="test_activationpytest_invalid_disable_namename1">test_activation.py::test_invalid_disable_name[name1]</h3>
<details><summary> <pre>test_activation.py::test_invalid_disable_name[name1]</pre></summary><pre>
name = []

    @pytest.mark.parametrize("name", [42, [], object()])
    def test_invalid_disable_name(name):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

name       = []

tests/test_activation.py:152: Failed
</pre>
</details>
<h3 id="test_activationpytest_invalid_disable_namename2">test_activation.py::test_invalid_disable_name[name2]</h3>
<details><summary> <pre>test_activation.py::test_invalid_disable_name[name2]</pre></summary><pre>
name = <object object at 0x7fac0db8aa00>

    @pytest.mark.parametrize("name", [42, [], object()])
    def test_invalid_disable_name(name):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

name       = <object object at 0x7fac0db8aa00>

tests/test_activation.py:152: Failed
</pre>
</details>
<h3 id="test_add_option_backtracepytest_backtrace">test_add_option_backtrace.py::test_backtrace</h3>
<details><summary> <pre>test_add_option_backtrace.py::test_backtrace</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b72f010>

    def test_backtrace(writer):
        logger.add(writer, format="{message}", backtrace=True)
        try:
            1 / 0  # noqa: B018
        except Exception:
            logger.exception("")
        result_with = writer.read().strip()

        logger.remove()
        writer.clear()

        logger.add(writer, format="{message}", backtrace=False)
        try:
            1 / 0  # noqa: B018
        except Exception:
            logger.exception("")
        result_without = writer.read().strip()

>       assert len(result_with.splitlines()) > len(result_without.splitlines())
E       AssertionError: assert 0 > 0
E        +  where 0 = len([])
E        +    where [] = <built-in method splitlines of str object at 0x7fac0db08030>()
E        +      where <built-in method splitlines of str object at 0x7fac0db08030> = ''.splitlines
E        +  and   0 = len([])
E        +    where [] = <built-in method splitlines of str object at 0x7fac0db08030>()
E        +      where <built-in method splitlines of str object at 0x7fac0db08030> = ''.splitlines

result_with = ''
result_without = ''
writer     = <function writer.<locals>.w at 0x7fac0b72f010>

tests/test_add_option_backtrace.py:24: AssertionError
</pre>
</details>
<h3 id="test_add_option_catchpytest_catch_is_true">test_add_option_catch.py::test_catch_is_true</h3>
<details><summary> <pre>test_add_option_catch.py::test_catch_is_true</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b97a590>

    def test_catch_is_true(capsys):
        logger.add(broken_sink, catch=True)
        logger.debug("Fail")
        out, err = capsys.readouterr()
        assert out == ""
>       assert err != ""
E       AssertionError: assert '' != ''

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b97a590>
err        = ''
out        = ''

tests/test_add_option_catch.py:21: AssertionError
</pre>
</details>
<h3 id="test_add_option_catchpytest_catch_is_false">test_add_option_catch.py::test_catch_is_false</h3>
<details><summary> <pre>test_add_option_catch.py::test_catch_is_false</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b5533d0>

    def test_catch_is_false(capsys):
        logger.add(broken_sink, catch=False)
>       with pytest.raises(ValueError, match="Error!"):
E       Failed: DID NOT RAISE <class 'ValueError'>

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b5533d0>

tests/test_add_option_catch.py:26: Failed
</pre>
</details>
<h3 id="test_add_option_catchpytest_encoding_error">test_add_option_catch.py::test_encoding_error</h3>
<details><summary> <pre>test_add_option_catch.py::test_encoding_error</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0c463d60>

    def test_encoding_error(capsys):
        def sink(m):
            raise UnicodeEncodeError("utf8", "", 10, 11, "too bad")

        logger.add(sink, catch=True)
        logger.debug("test")

        out, err = capsys.readouterr()
        lines = err.strip().splitlines()

        assert out == ""
>       assert lines[0] == "--- Logging error in Loguru Handler #0 ---"
E       IndexError: list index out of range

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0c463d60>
err        = ''
lines      = []
out        = ''
sink       = <function test_encoding_error.<locals>.sink at 0x7fac0b72f010>

tests/test_add_option_catch.py:64: IndexError
</pre>
</details>
<h3 id="test_add_option_catchpytest_unprintable_record">test_add_option_catch.py::test_unprintable_record</h3>
<details><summary> <pre>test_add_option_catch.py::test_unprintable_record</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b7536d0>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b52b130>

    def test_unprintable_record(writer, capsys):
        class Unprintable:
            def __repr__(self):
                raise ValueError("Failed")

        logger.add(writer, format="{message} {extra[unprintable]}", catch=True)
>       logger.bind(unprintable=1).debug("a")
E       AttributeError: 'NoneType' object has no attribute 'debug'

Unprintable = <class 'tests.test_add_option_catch.test_unprintable_record.<locals>.Unprintable'>
capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b52b130>
writer     = <function writer.<locals>.w at 0x7fac0b7536d0>

tests/test_add_option_catch.py:77: AttributeError
</pre>
</details>
<h3 id="test_add_option_catchpytest_broken_sink_messagefalse">test_add_option_catch.py::test_broken_sink_message[False]</h3>
<details><summary> <pre>test_add_option_catch.py::test_broken_sink_message[False]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0ba1b130>
enqueue = False

    @pytest.mark.parametrize("enqueue", [False, True])
    def test_broken_sink_message(capsys, enqueue):
        logger.add(broken_sink, catch=True, enqueue=enqueue)
        logger.debug("Oops")
        time.sleep(0.1)

        out, err = capsys.readouterr()
        lines = err.strip().splitlines()

        assert out == ""
>       assert lines[0] == "--- Logging error in Loguru Handler #0 ---"
E       IndexError: list index out of range

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0ba1b130>
enqueue    = False
err        = ''
lines      = []
out        = ''

tests/test_add_option_catch.py:102: IndexError
</pre>
</details>
<h3 id="test_add_option_catchpytest_broken_sink_messagetrue">test_add_option_catch.py::test_broken_sink_message[True]</h3>
<details><summary> <pre>test_add_option_catch.py::test_broken_sink_message[True]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b52ab90>
enqueue = True

    @pytest.mark.parametrize("enqueue", [False, True])
    def test_broken_sink_message(capsys, enqueue):
        logger.add(broken_sink, catch=True, enqueue=enqueue)
        logger.debug("Oops")
        time.sleep(0.1)

        out, err = capsys.readouterr()
        lines = err.strip().splitlines()

        assert out == ""
>       assert lines[0] == "--- Logging error in Loguru Handler #0 ---"
E       IndexError: list index out of range

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b52ab90>
enqueue    = True
err        = ''
lines      = []
out        = ''

tests/test_add_option_catch.py:102: IndexError
</pre>
</details>
<h3 id="test_add_option_catchpytest_broken_sink_caught_keep_workingfalse">test_add_option_catch.py::test_broken_sink_caught_keep_working[False]</h3>
<details><summary> <pre>test_add_option_catch.py::test_broken_sink_caught_keep_working[False]</pre></summary><pre>
enqueue = False

    @pytest.mark.parametrize("enqueue", [False, True])
    def test_broken_sink_caught_keep_working(enqueue):
        output = ""

        def half_broken_sink(m):
            nonlocal output
            if m.startswith("NOK"):
                raise ValueError("Broken!")
            else:
                output += m

        logger.add(half_broken_sink, format="{message}", enqueue=enqueue, catch=True)
        logger.info("A")
        logger.info("NOK")
        logger.info("B")

        time.sleep(0.1)
>       assert output == "A\nB\n"
E       AssertionError: assert '' == 'A\nB\n'
E         
E         - A
E         - B

enqueue    = False
half_broken_sink = <function test_broken_sink_caught_keep_working.<locals>.half_broken_sink at 0x7fac0bff3370>
output     = ''

tests/test_add_option_catch.py:125: AssertionError
</pre>
</details>
<h3 id="test_add_option_catchpytest_broken_sink_caught_keep_workingtrue">test_add_option_catch.py::test_broken_sink_caught_keep_working[True]</h3>
<details><summary> <pre>test_add_option_catch.py::test_broken_sink_caught_keep_working[True]</pre></summary><pre>
enqueue = True

    @pytest.mark.parametrize("enqueue", [False, True])
    def test_broken_sink_caught_keep_working(enqueue):
        output = ""

        def half_broken_sink(m):
            nonlocal output
            if m.startswith("NOK"):
                raise ValueError("Broken!")
            else:
                output += m

        logger.add(half_broken_sink, format="{message}", enqueue=enqueue, catch=True)
        logger.info("A")
        logger.info("NOK")
        logger.info("B")

        time.sleep(0.1)
>       assert output == "A\nB\n"
E       AssertionError: assert '' == 'A\nB\n'
E         
E         - A
E         - B

enqueue    = True
half_broken_sink = <function test_broken_sink_caught_keep_working.<locals>.half_broken_sink at 0x7fac0b72ef80>
output     = ''

tests/test_add_option_catch.py:125: AssertionError
</pre>
</details>
<h3 id="test_add_option_catchpytest_broken_sink_not_caught_enqueue">test_add_option_catch.py::test_broken_sink_not_caught_enqueue</h3>
<details><summary> <pre>test_add_option_catch.py::test_broken_sink_not_caught_enqueue</pre></summary><pre>
def test_broken_sink_not_caught_enqueue():
        called = 0

        def broken_sink(m):
            nonlocal called
            called += 1
            raise ValueError("Nop")

        logger.add(broken_sink, format="{message}", enqueue=True, catch=False)

        with default_threading_excepthook():
            logger.info("A")
            logger.info("B")
            time.sleep(0.1)

>       assert called == 2
E       assert 0 == 2

broken_sink = <function test_broken_sink_not_caught_enqueue.<locals>.broken_sink at 0x7fac0b7536d0>
called     = 0

tests/test_add_option_catch.py:143: AssertionError
</pre>
</details>
<h3 id="test_add_option_contextpytest_using_multiprocessing_directly_if_context_is_none">test_add_option_context.py::test_using_multiprocessing_directly_if_context_is_none</h3>
<details><summary> <pre>test_add_option_context.py::test_using_multiprocessing_directly_if_context_is_none</pre></summary><pre>
@pytest.mark.usefixtures("reset_start_method")
    def test_using_multiprocessing_directly_if_context_is_none():
        logger.add(lambda _: None, enqueue=True, context=None)
>       assert multiprocessing.get_start_method(allow_none=True) is not None
E       assert None is not None
E        +  where None = get_start_method(allow_none=True)
E        +    where get_start_method = multiprocessing.get_start_method


tests/test_add_option_context.py:19: AssertionError
</pre>
</details>
<h3 id="test_add_option_contextpytest_fork_context_as_stringfork">test_add_option_context.py::test_fork_context_as_string[fork]</h3>
<details><summary> <pre>test_add_option_context.py::test_fork_context_as_string[fork]</pre></summary><pre>
context_name = 'fork'

    @pytest.mark.skipif(os.name == "nt", reason="Windows does not support forking")
    @pytest.mark.parametrize("context_name", ["fork", "forkserver"])
    def test_fork_context_as_string(context_name):
        context = multiprocessing.get_context(context_name)
        with patch.object(type(context), "Lock", wraps=context.Lock) as mock:
            logger.add(lambda _: None, context=context_name, enqueue=True)
>           assert mock.called
E           AssertionError: assert False
E            +  where False = <MagicMock name='Lock' id='140376906241248'>.called

context    = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>
context_name = 'fork'
mock       = <MagicMock name='Lock' id='140376906241248'>

tests/test_add_option_context.py:28: AssertionError
</pre>
</details>
<h3 id="test_add_option_contextpytest_fork_context_as_stringforkserver">test_add_option_context.py::test_fork_context_as_string[forkserver]</h3>
<details><summary> <pre>test_add_option_context.py::test_fork_context_as_string[forkserver]</pre></summary><pre>
context_name = 'forkserver'

    @pytest.mark.skipif(os.name == "nt", reason="Windows does not support forking")
    @pytest.mark.parametrize("context_name", ["fork", "forkserver"])
    def test_fork_context_as_string(context_name):
        context = multiprocessing.get_context(context_name)
        with patch.object(type(context), "Lock", wraps=context.Lock) as mock:
            logger.add(lambda _: None, context=context_name, enqueue=True)
>           assert mock.called
E           AssertionError: assert False
E            +  where False = <MagicMock name='Lock' id='140376901240192'>.called

context    = <multiprocessing.context.ForkServerContext object at 0x7fac0d349030>
context_name = 'forkserver'
mock       = <MagicMock name='Lock' id='140376901240192'>

tests/test_add_option_context.py:28: AssertionError
</pre>
</details>
<h3 id="test_add_option_contextpytest_spawn_context_as_string">test_add_option_context.py::test_spawn_context_as_string</h3>
<details><summary> <pre>test_add_option_context.py::test_spawn_context_as_string</pre></summary><pre>
def test_spawn_context_as_string():
        context = multiprocessing.get_context("spawn")
        with patch.object(type(context), "Lock", wraps=context.Lock) as mock:
            logger.add(lambda _: None, context="spawn", enqueue=True)
>           assert mock.called
E           AssertionError: assert False
E            +  where False = <MagicMock name='Lock' id='140376901644448'>.called

context    = <multiprocessing.context.SpawnContext object at 0x7fac0d34afb0>
mock       = <MagicMock name='Lock' id='140376901644448'>

tests/test_add_option_context.py:36: AssertionError
</pre>
</details>
<h3 id="test_add_option_contextpytest_fork_context_as_objectfork">test_add_option_context.py::test_fork_context_as_object[fork]</h3>
<details><summary> <pre>test_add_option_context.py::test_fork_context_as_object[fork]</pre></summary><pre>
context_name = 'fork'

    @pytest.mark.skipif(os.name == "nt", reason="Windows does not support forking")
    @pytest.mark.parametrize("context_name", ["fork", "forkserver"])
    def test_fork_context_as_object(context_name):
        context = multiprocessing.get_context(context_name)
        with patch.object(type(context), "Lock", wraps=context.Lock) as mock:
            logger.add(lambda _: None, context=context, enqueue=True)
>           assert mock.called
E           AssertionError: assert False
E            +  where False = <MagicMock name='Lock' id='140376901128720'>.called

context    = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>
context_name = 'fork'
mock       = <MagicMock name='Lock' id='140376901128720'>

tests/test_add_option_context.py:46: AssertionError
</pre>
</details>
<h3 id="test_add_option_contextpytest_fork_context_as_objectforkserver">test_add_option_context.py::test_fork_context_as_object[forkserver]</h3>
<details><summary> <pre>test_add_option_context.py::test_fork_context_as_object[forkserver]</pre></summary><pre>
context_name = 'forkserver'

    @pytest.mark.skipif(os.name == "nt", reason="Windows does not support forking")
    @pytest.mark.parametrize("context_name", ["fork", "forkserver"])
    def test_fork_context_as_object(context_name):
        context = multiprocessing.get_context(context_name)
        with patch.object(type(context), "Lock", wraps=context.Lock) as mock:
            logger.add(lambda _: None, context=context, enqueue=True)
>           assert mock.called
E           AssertionError: assert False
E            +  where False = <MagicMock name='Lock' id='140376901061552'>.called

context    = <multiprocessing.context.ForkServerContext object at 0x7fac0d349030>
context_name = 'forkserver'
mock       = <MagicMock name='Lock' id='140376901061552'>

tests/test_add_option_context.py:46: AssertionError
</pre>
</details>
<h3 id="test_add_option_contextpytest_spawn_context_as_object">test_add_option_context.py::test_spawn_context_as_object</h3>
<details><summary> <pre>test_add_option_context.py::test_spawn_context_as_object</pre></summary><pre>
def test_spawn_context_as_object():
        context = multiprocessing.get_context("spawn")
        with patch.object(type(context), "Lock", wraps=context.Lock) as mock:
            logger.add(lambda _: None, context=context, enqueue=True)
>           assert mock.called
E           AssertionError: assert False
E            +  where False = <MagicMock name='Lock' id='140376901239568'>.called

context    = <multiprocessing.context.SpawnContext object at 0x7fac0d34afb0>
mock       = <MagicMock name='Lock' id='140376901239568'>

tests/test_add_option_context.py:54: AssertionError
</pre>
</details>
<h3 id="test_add_option_contextpytest_invalid_context_name">test_add_option_context.py::test_invalid_context_name</h3>
<details><summary> <pre>test_add_option_context.py::test_invalid_context_name</pre></summary><pre>
def test_invalid_context_name():
>       with pytest.raises(ValueError, match=r"cannot find context for"):
E       Failed: DID NOT RAISE <class 'ValueError'>


tests/test_add_option_context.py:64: Failed
</pre>
</details>
<h3 id="test_add_option_contextpytest_invalid_context_object42">test_add_option_context.py::test_invalid_context_object[42]</h3>
<details><summary> <pre>test_add_option_context.py::test_invalid_context_object[42]</pre></summary><pre>
context = 42

    @pytest.mark.parametrize("context", [42, object()])
    def test_invalid_context_object(context):
>       with pytest.raises(
            TypeError,
            match=r"Invalid context, it should be a string or a multiprocessing context",
        ):
E       Failed: DID NOT RAISE <class 'TypeError'>

context    = 42

tests/test_add_option_context.py:70: Failed
</pre>
</details>
<h3 id="test_add_option_contextpytest_invalid_context_objectcontext1">test_add_option_context.py::test_invalid_context_object[context1]</h3>
<details><summary> <pre>test_add_option_context.py::test_invalid_context_object[context1]</pre></summary><pre>
context = <object object at 0x7fac0db8a910>

    @pytest.mark.parametrize("context", [42, object()])
    def test_invalid_context_object(context):
>       with pytest.raises(
            TypeError,
            match=r"Invalid context, it should be a string or a multiprocessing context",
        ):
E       Failed: DID NOT RAISE <class 'TypeError'>

context    = <object object at 0x7fac0db8a910>

tests/test_add_option_context.py:70: Failed
</pre>
</details>
<h3 id="test_add_option_diagnosepytest_diagnose">test_add_option_diagnose.py::test_diagnose</h3>
<details><summary> <pre>test_add_option_diagnose.py::test_diagnose</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b72eb90>

    def test_diagnose(writer):
        logger.add(writer, format="{message}", diagnose=True)
        try:
            1 / 0  # noqa: B018
        except Exception:
            logger.exception("")
        result_with = writer.read().strip()

        logger.remove()
        writer.clear()

        logger.add(writer, format="{message}", diagnose=False)
        try:
            1 / 0  # noqa: B018
        except Exception:
            logger.exception("")
        result_without = writer.read().strip()

>       assert len(result_with.splitlines()) > len(result_without.splitlines())
E       AssertionError: assert 0 > 0
E        +  where 0 = len([])
E        +    where [] = <built-in method splitlines of str object at 0x7fac0db08030>()
E        +      where <built-in method splitlines of str object at 0x7fac0db08030> = ''.splitlines
E        +  and   0 = len([])
E        +    where [] = <built-in method splitlines of str object at 0x7fac0db08030>()
E        +      where <built-in method splitlines of str object at 0x7fac0db08030> = ''.splitlines

result_with = ''
result_without = ''
writer     = <function writer.<locals>.w at 0x7fac0b72eb90>

tests/test_add_option_diagnose.py:24: AssertionError
</pre>
</details>
<h3 id="test_add_option_enqueuepytest_enqueue">test_add_option_enqueue.py::test_enqueue</h3>
<details><summary> <pre>test_add_option_enqueue.py::test_enqueue</pre></summary><pre>
def test_enqueue():
        x = []

        def sink(message):
            time.sleep(0.1)
            x.append(message)

        logger.add(sink, format="{message}", enqueue=True)
        logger.debug("Test")
        assert len(x) == 0
        logger.complete()
>       assert len(x) == 1
E       assert 0 == 1
E        +  where 0 = len([])

sink       = <function test_enqueue.<locals>.sink at 0x7fac0b7520e0>
x          = []

tests/test_add_option_enqueue.py:63: AssertionError
</pre>
</details>
<h3 id="test_add_option_enqueuepytest_enqueue_with_exception">test_add_option_enqueue.py::test_enqueue_with_exception</h3>
<details><summary> <pre>test_add_option_enqueue.py::test_enqueue_with_exception</pre></summary><pre>
def test_enqueue_with_exception():
        x = []

        def sink(message):
            time.sleep(0.1)
            x.append(message)

        logger.add(sink, format="{message}", enqueue=True)

        try:
            1 / 0  # noqa: B018
        except ZeroDivisionError:
            logger.exception("Error")

        assert len(x) == 0
        logger.complete()
>       assert len(x) == 1
E       assert 0 == 1
E        +  where 0 = len([])

sink       = <function test_enqueue_with_exception.<locals>.sink at 0x7fac0bff32e0>
x          = []

tests/test_add_option_enqueue.py:83: AssertionError
</pre>
</details>
<h3 id="test_add_option_enqueuepytest_caught_exception_queue_put">test_add_option_enqueue.py::test_caught_exception_queue_put</h3>
<details><summary> <pre>test_add_option_enqueue.py::test_caught_exception_queue_put</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b753490>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0ba4dff0>

    def test_caught_exception_queue_put(writer, capsys):
        logger.add(writer, enqueue=True, catch=True, format="{message}")

        logger.info("It's fine")
>       logger.bind(broken=NotPicklable()).info("Bye bye...")
E       AttributeError: 'NoneType' object has no attribute 'info'

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0ba4dff0>
writer     = <function writer.<locals>.w at 0x7fac0b753490>

tests/test_add_option_enqueue.py:94: AttributeError
</pre>
</details>
<h3 id="test_add_option_enqueuepytest_caught_exception_queue_get">test_add_option_enqueue.py::test_caught_exception_queue_get</h3>
<details><summary> <pre>test_add_option_enqueue.py::test_caught_exception_queue_get</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b753010>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b550400>

    def test_caught_exception_queue_get(writer, capsys):
        logger.add(writer, enqueue=True, catch=True, format="{message}")

        logger.info("It's fine")
>       logger.bind(broken=NotUnpicklable()).info("Bye bye...")
E       AttributeError: 'NoneType' object has no attribute 'info'

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b550400>
writer     = <function writer.<locals>.w at 0x7fac0b753010>

tests/test_add_option_enqueue.py:112: AttributeError
</pre>
</details>
<h3 id="test_add_option_enqueuepytest_caught_exception_sink_write">test_add_option_enqueue.py::test_caught_exception_sink_write</h3>
<details><summary> <pre>test_add_option_enqueue.py::test_caught_exception_sink_write</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b744040>

    def test_caught_exception_sink_write(capsys):
        logger.add(NotWritable(), enqueue=True, catch=True, format="{message}")

        logger.info("It's fine")
>       logger.bind(fail=True).info("Bye bye...")
E       AttributeError: 'NoneType' object has no attribute 'info'

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b744040>

tests/test_add_option_enqueue.py:130: AttributeError
</pre>
</details>
<h3 id="test_add_option_enqueuepytest_not_caught_exception_queue_put">test_add_option_enqueue.py::test_not_caught_exception_queue_put</h3>
<details><summary> <pre>test_add_option_enqueue.py::test_not_caught_exception_queue_put</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b753490>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b74c100>

    def test_not_caught_exception_queue_put(writer, capsys):
        logger.add(writer, enqueue=True, catch=False, format="{message}")

        logger.info("It's fine")

        with pytest.raises(pickle.PicklingError, match=r"You shall not serialize me!"):
>           logger.bind(broken=NotPicklable()).info("Bye bye...")
E           AttributeError: 'NoneType' object has no attribute 'info'

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b74c100>
writer     = <function writer.<locals>.w at 0x7fac0b753490>

tests/test_add_option_enqueue.py:149: AttributeError
</pre>
</details>
<h3 id="test_add_option_enqueuepytest_not_caught_exception_queue_get">test_add_option_enqueue.py::test_not_caught_exception_queue_get</h3>
<details><summary> <pre>test_add_option_enqueue.py::test_not_caught_exception_queue_get</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b753e20>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b746b00>

    def test_not_caught_exception_queue_get(writer, capsys):
        logger.add(writer, enqueue=True, catch=False, format="{message}")

        with default_threading_excepthook():
            logger.info("It's fine")
>           logger.bind(broken=NotUnpicklable()).info("Bye bye...")
E           AttributeError: 'NoneType' object has no attribute 'info'

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b746b00>
writer     = <function writer.<locals>.w at 0x7fac0b753e20>

tests/test_add_option_enqueue.py:164: AttributeError
</pre>
</details>
<h3 id="test_add_option_enqueuepytest_not_caught_exception_sink_write">test_add_option_enqueue.py::test_not_caught_exception_sink_write</h3>
<details><summary> <pre>test_add_option_enqueue.py::test_not_caught_exception_sink_write</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b74caf0>

    def test_not_caught_exception_sink_write(capsys):
        logger.add(NotWritable(), enqueue=True, catch=False, format="{message}")

        with default_threading_excepthook():
            logger.info("It's fine")
>           logger.bind(fail=True).info("Bye bye...")
E           AttributeError: 'NoneType' object has no attribute 'info'

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b74caf0>

tests/test_add_option_enqueue.py:183: AttributeError
</pre>
</details>
<h3 id="test_add_option_enqueuepytest_not_caught_exception_sink_write_then_complete">test_add_option_enqueue.py::test_not_caught_exception_sink_write_then_complete</h3>
<details><summary> <pre>test_add_option_enqueue.py::test_not_caught_exception_sink_write_then_complete</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0ba1ba60>

    def test_not_caught_exception_sink_write_then_complete(capsys):
        logger.add(NotWritable(), enqueue=True, catch=False, format="{message}")

        with default_threading_excepthook():
>           logger.bind(fail=True).info("Bye bye...")
E           AttributeError: 'NoneType' object has no attribute 'info'

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0ba1ba60>

tests/test_add_option_enqueue.py:200: AttributeError
</pre>
</details>
<h3 id="test_add_option_enqueuepytest_not_caught_exception_queue_get_then_complete">test_add_option_enqueue.py::test_not_caught_exception_queue_get_then_complete</h3>
<details><summary> <pre>test_add_option_enqueue.py::test_not_caught_exception_queue_get_then_complete</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b7524d0>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b74dff0>

    def test_not_caught_exception_queue_get_then_complete(writer, capsys):
        logger.add(writer, enqueue=True, catch=False, format="{message}")

        with default_threading_excepthook():
>           logger.bind(broken=NotUnpicklable()).info("Bye bye...")
E           AttributeError: 'NoneType' object has no attribute 'info'

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b74dff0>
writer     = <function writer.<locals>.w at 0x7fac0b7524d0>

tests/test_add_option_enqueue.py:218: AttributeError
</pre>
</details>
<h3 id="test_add_option_enqueuepytest_wait_for_all_messages_enqueued">test_add_option_enqueue.py::test_wait_for_all_messages_enqueued</h3>
<details><summary> <pre>test_add_option_enqueue.py::test_wait_for_all_messages_enqueued</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b97b490>

    def test_wait_for_all_messages_enqueued(capsys):
        def slow_sink(message):
            time.sleep(0.01)
            sys.stderr.write(message)

        logger.add(slow_sink, enqueue=True, catch=False, format="{message}")

        for i in range(10):
            logger.info(i)

        logger.complete()

        out, err = capsys.readouterr()

        assert out == ""
>       assert err == "".join("%d\n" % i for i in range(10))
E       AssertionError: assert '' == '0\n1\n2\n3\n...n6\n7\n8\n9\n'
E         
E         - 0
E         - 1
E         - 2
E         - 3
E         - 4
E         - 5...
E         
E         ...Full output truncated (4 lines hidden), use '-vv' to show

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b97b490>
err        = ''
i          = 9
out        = ''
slow_sink  = <function test_wait_for_all_messages_enqueued.<locals>.slow_sink at 0x7fac0b753490>

tests/test_add_option_enqueue.py:248: AssertionError
</pre>
</details>
<h3 id="test_add_option_enqueuepytest_logging_not_picklable_exceptionexception_value0">test_add_option_enqueue.py::test_logging_not_picklable_exception[exception_value0]</h3>
<details><summary> <pre>test_add_option_enqueue.py::test_logging_not_picklable_exception[exception_value0]</pre></summary><pre>
exception_value = <tests.test_add_option_enqueue.NotPicklable object at 0x7fac0be00c10>

    @pytest.mark.parametrize("exception_value", [NotPicklable(), NotPicklableTypeError()])
    def test_logging_not_picklable_exception(exception_value):
        exception = None

        def sink(message):
            nonlocal exception
            exception = message.record["exception"]

        logger.add(sink, enqueue=True, catch=False)

        try:
            raise ValueError(exception_value)
        except Exception:
            logger.exception("Oups")

        logger.remove()

>       type_, value, traceback_ = exception
E       TypeError: cannot unpack non-iterable NoneType object

exception  = None
exception_value = <tests.test_add_option_enqueue.NotPicklable object at 0x7fac0be00c10>
sink       = <function test_logging_not_picklable_exception.<locals>.sink at 0x7fac0b753010>

tests/test_add_option_enqueue.py:268: TypeError
</pre>
</details>
<h3 id="test_add_option_enqueuepytest_logging_not_picklable_exceptionexception_value1">test_add_option_enqueue.py::test_logging_not_picklable_exception[exception_value1]</h3>
<details><summary> <pre>test_add_option_enqueue.py::test_logging_not_picklable_exception[exception_value1]</pre></summary><pre>
exception_value = <tests.test_add_option_enqueue.NotPicklableTypeError object at 0x7fac0be00be0>

    @pytest.mark.parametrize("exception_value", [NotPicklable(), NotPicklableTypeError()])
    def test_logging_not_picklable_exception(exception_value):
        exception = None

        def sink(message):
            nonlocal exception
            exception = message.record["exception"]

        logger.add(sink, enqueue=True, catch=False)

        try:
            raise ValueError(exception_value)
        except Exception:
            logger.exception("Oups")

        logger.remove()

>       type_, value, traceback_ = exception
E       TypeError: cannot unpack non-iterable NoneType object

exception  = None
exception_value = <tests.test_add_option_enqueue.NotPicklableTypeError object at 0x7fac0be00be0>
sink       = <function test_logging_not_picklable_exception.<locals>.sink at 0x7fac0b53cc10>

tests/test_add_option_enqueue.py:268: TypeError
</pre>
</details>
<h3 id="test_add_option_enqueuepytest_logging_not_unpicklable_exceptionexception_value0">test_add_option_enqueue.py::test_logging_not_unpicklable_exception[exception_value0]</h3>
<details><summary> <pre>test_add_option_enqueue.py::test_logging_not_unpicklable_exception[exception_value0]</pre></summary><pre>
exception_value = <tests.test_add_option_enqueue.NotUnpicklable object at 0x7fac0be008e0>

    @pytest.mark.parametrize("exception_value", [NotUnpicklable(), NotUnpicklableTypeError()])
    def test_logging_not_unpicklable_exception(exception_value):
        exception = None

        def sink(message):
            nonlocal exception
            exception = message.record["exception"]

        logger.add(sink, enqueue=True, catch=False)

        try:
            raise ValueError(exception_value)
        except Exception:
            logger.exception("Oups")

        logger.remove()

>       type_, value, traceback_ = exception
E       TypeError: cannot unpack non-iterable NoneType object

exception  = None
exception_value = <tests.test_add_option_enqueue.NotUnpicklable object at 0x7fac0be008e0>
sink       = <function test_logging_not_unpicklable_exception.<locals>.sink at 0x7fac0b53cca0>

tests/test_add_option_enqueue.py:291: TypeError
</pre>
</details>
<h3 id="test_add_option_enqueuepytest_logging_not_unpicklable_exceptionexception_value1">test_add_option_enqueue.py::test_logging_not_unpicklable_exception[exception_value1]</h3>
<details><summary> <pre>test_add_option_enqueue.py::test_logging_not_unpicklable_exception[exception_value1]</pre></summary><pre>
exception_value = <tests.test_add_option_enqueue.NotUnpicklableTypeError object at 0x7fac0be008b0>

    @pytest.mark.parametrize("exception_value", [NotUnpicklable(), NotUnpicklableTypeError()])
    def test_logging_not_unpicklable_exception(exception_value):
        exception = None

        def sink(message):
            nonlocal exception
            exception = message.record["exception"]

        logger.add(sink, enqueue=True, catch=False)

        try:
            raise ValueError(exception_value)
        except Exception:
            logger.exception("Oups")

        logger.remove()

>       type_, value, traceback_ = exception
E       TypeError: cannot unpack non-iterable NoneType object

exception  = None
exception_value = <tests.test_add_option_enqueue.NotUnpicklableTypeError object at 0x7fac0be008b0>
sink       = <function test_logging_not_unpicklable_exception.<locals>.sink at 0x7fac0b53c700>

tests/test_add_option_enqueue.py:291: TypeError
</pre>
</details>
<h3 id="test_add_option_filterpytest_filterd_innone">test_add_option_filter.py::test_filterd_in[None]</h3>
<details><summary> <pre>test_add_option_filter.py::test_filterd_in[None]</pre></summary><pre>
filter = None, writer = <function writer.<locals>.w at 0x7fac0b53caf0>

    @pytest.mark.parametrize(
        "filter",
        [
            None,
            "",
            "tests",
            "tests.test_add_option_filter",
            (lambda r: True),
            (lambda r: r["level"].name == "DEBUG"),
            {},
            {"": "DEBUG"},
            {"tests": True},
            {"tests.test_add_option_filter": 10},
            {"": "WARNING", "tests": 0},
            {"tests.test_add_option_filter": 5, "tests": False},
            {"tests.test_add_option_filter.foobar": False},
            {"tests.": False},
            {"tests.test_add_option_filter.": False},
        ],
    )
    def test_filterd_in(filter, writer):
        logger.add(writer, filter=filter, format="{message}")
        logger.debug("Test Filter")
>       assert writer.read() == "Test Filter\n"
E       AssertionError: assert '' == 'Test Filter\n'
E         
E         - Test Filter

filter     = None
writer     = <function writer.<locals>.w at 0x7fac0b53caf0>

tests/test_add_option_filter.py:29: AssertionError
</pre>
</details>
<h3 id="test_add_option_filterpytest_filterd_in">test_add_option_filter.py::test_filterd_in[]</h3>
<details><summary> <pre>test_add_option_filter.py::test_filterd_in[]</pre></summary><pre>
filter = '', writer = <function writer.<locals>.w at 0x7fac0b53c940>

    @pytest.mark.parametrize(
        "filter",
        [
            None,
            "",
            "tests",
            "tests.test_add_option_filter",
            (lambda r: True),
            (lambda r: r["level"].name == "DEBUG"),
            {},
            {"": "DEBUG"},
            {"tests": True},
            {"tests.test_add_option_filter": 10},
            {"": "WARNING", "tests": 0},
            {"tests.test_add_option_filter": 5, "tests": False},
            {"tests.test_add_option_filter.foobar": False},
            {"tests.": False},
            {"tests.test_add_option_filter.": False},
        ],
    )
    def test_filterd_in(filter, writer):
        logger.add(writer, filter=filter, format="{message}")
        logger.debug("Test Filter")
>       assert writer.read() == "Test Filter\n"
E       AssertionError: assert '' == 'Test Filter\n'
E         
E         - Test Filter

filter     = ''
writer     = <function writer.<locals>.w at 0x7fac0b53c940>

tests/test_add_option_filter.py:29: AssertionError
</pre>
</details>
<h3 id="test_add_option_filterpytest_filterd_intests">test_add_option_filter.py::test_filterd_in[tests]</h3>
<details><summary> <pre>test_add_option_filter.py::test_filterd_in[tests]</pre></summary><pre>
filter = 'tests', writer = <function writer.<locals>.w at 0x7fac0b53c4c0>

    @pytest.mark.parametrize(
        "filter",
        [
            None,
            "",
            "tests",
            "tests.test_add_option_filter",
            (lambda r: True),
            (lambda r: r["level"].name == "DEBUG"),
            {},
            {"": "DEBUG"},
            {"tests": True},
            {"tests.test_add_option_filter": 10},
            {"": "WARNING", "tests": 0},
            {"tests.test_add_option_filter": 5, "tests": False},
            {"tests.test_add_option_filter.foobar": False},
            {"tests.": False},
            {"tests.test_add_option_filter.": False},
        ],
    )
    def test_filterd_in(filter, writer):
        logger.add(writer, filter=filter, format="{message}")
        logger.debug("Test Filter")
>       assert writer.read() == "Test Filter\n"
E       AssertionError: assert '' == 'Test Filter\n'
E         
E         - Test Filter

filter     = 'tests'
writer     = <function writer.<locals>.w at 0x7fac0b53c4c0>

tests/test_add_option_filter.py:29: AssertionError
</pre>
</details>
<h3 id="test_add_option_filterpytest_filterd_inteststest_add_option_filter">test_add_option_filter.py::test_filterd_in[tests.test_add_option_filter]</h3>
<details><summary> <pre>test_add_option_filter.py::test_filterd_in[tests.test_add_option_filter]</pre></summary><pre>
filter = 'tests.test_add_option_filter'
writer = <function writer.<locals>.w at 0x7fac0b53d000>

    @pytest.mark.parametrize(
        "filter",
        [
            None,
            "",
            "tests",
            "tests.test_add_option_filter",
            (lambda r: True),
            (lambda r: r["level"].name == "DEBUG"),
            {},
            {"": "DEBUG"},
            {"tests": True},
            {"tests.test_add_option_filter": 10},
            {"": "WARNING", "tests": 0},
            {"tests.test_add_option_filter": 5, "tests": False},
            {"tests.test_add_option_filter.foobar": False},
            {"tests.": False},
            {"tests.test_add_option_filter.": False},
        ],
    )
    def test_filterd_in(filter, writer):
        logger.add(writer, filter=filter, format="{message}")
        logger.debug("Test Filter")
>       assert writer.read() == "Test Filter\n"
E       AssertionError: assert '' == 'Test Filter\n'
E         
E         - Test Filter

filter     = 'tests.test_add_option_filter'
writer     = <function writer.<locals>.w at 0x7fac0b53d000>

tests/test_add_option_filter.py:29: AssertionError
</pre>
</details>
<h3 id="test_add_option_filterpytest_filterd_in0">test_add_option_filter.py::test_filterd_in[<lambda>0]</h3>
<details><summary> <pre>test_add_option_filter.py::test_filterd_in[<lambda>0]</pre></summary><pre>
filter = <function <lambda> at 0x7fac0befa5f0>
writer = <function writer.<locals>.w at 0x7fac0b53d5a0>

    @pytest.mark.parametrize(
        "filter",
        [
            None,
            "",
            "tests",
            "tests.test_add_option_filter",
            (lambda r: True),
            (lambda r: r["level"].name == "DEBUG"),
            {},
            {"": "DEBUG"},
            {"tests": True},
            {"tests.test_add_option_filter": 10},
            {"": "WARNING", "tests": 0},
            {"tests.test_add_option_filter": 5, "tests": False},
            {"tests.test_add_option_filter.foobar": False},
            {"tests.": False},
            {"tests.test_add_option_filter.": False},
        ],
    )
    def test_filterd_in(filter, writer):
        logger.add(writer, filter=filter, format="{message}")
        logger.debug("Test Filter")
>       assert writer.read() == "Test Filter\n"
E       AssertionError: assert '' == 'Test Filter\n'
E         
E         - Test Filter

filter     = <function <lambda> at 0x7fac0befa5f0>
writer     = <function writer.<locals>.w at 0x7fac0b53d5a0>

tests/test_add_option_filter.py:29: AssertionError
</pre>
</details>
<h3 id="test_add_option_filterpytest_filterd_in1">test_add_option_filter.py::test_filterd_in[<lambda>1]</h3>
<details><summary> <pre>test_add_option_filter.py::test_filterd_in[<lambda>1]</pre></summary><pre>
filter = <function <lambda> at 0x7fac0befa680>
writer = <function writer.<locals>.w at 0x7fac0b53d7e0>

    @pytest.mark.parametrize(
        "filter",
        [
            None,
            "",
            "tests",
            "tests.test_add_option_filter",
            (lambda r: True),
            (lambda r: r["level"].name == "DEBUG"),
            {},
            {"": "DEBUG"},
            {"tests": True},
            {"tests.test_add_option_filter": 10},
            {"": "WARNING", "tests": 0},
            {"tests.test_add_option_filter": 5, "tests": False},
            {"tests.test_add_option_filter.foobar": False},
            {"tests.": False},
            {"tests.test_add_option_filter.": False},
        ],
    )
    def test_filterd_in(filter, writer):
        logger.add(writer, filter=filter, format="{message}")
        logger.debug("Test Filter")
>       assert writer.read() == "Test Filter\n"
E       AssertionError: assert '' == 'Test Filter\n'
E         
E         - Test Filter

filter     = <function <lambda> at 0x7fac0befa680>
writer     = <function writer.<locals>.w at 0x7fac0b53d7e0>

tests/test_add_option_filter.py:29: AssertionError
</pre>
</details>
<h3 id="test_add_option_filterpytest_filterd_infilter6">test_add_option_filter.py::test_filterd_in[filter6]</h3>
<details><summary> <pre>test_add_option_filter.py::test_filterd_in[filter6]</pre></summary><pre>
filter = {}, writer = <function writer.<locals>.w at 0x7fac0b53da20>

    @pytest.mark.parametrize(
        "filter",
        [
            None,
            "",
            "tests",
            "tests.test_add_option_filter",
            (lambda r: True),
            (lambda r: r["level"].name == "DEBUG"),
            {},
            {"": "DEBUG"},
            {"tests": True},
            {"tests.test_add_option_filter": 10},
            {"": "WARNING", "tests": 0},
            {"tests.test_add_option_filter": 5, "tests": False},
            {"tests.test_add_option_filter.foobar": False},
            {"tests.": False},
            {"tests.test_add_option_filter.": False},
        ],
    )
    def test_filterd_in(filter, writer):
        logger.add(writer, filter=filter, format="{message}")
        logger.debug("Test Filter")
>       assert writer.read() == "Test Filter\n"
E       AssertionError: assert '' == 'Test Filter\n'
E         
E         - Test Filter

filter     = {}
writer     = <function writer.<locals>.w at 0x7fac0b53da20>

tests/test_add_option_filter.py:29: AssertionError
</pre>
</details>
<h3 id="test_add_option_filterpytest_filterd_infilter7">test_add_option_filter.py::test_filterd_in[filter7]</h3>
<details><summary> <pre>test_add_option_filter.py::test_filterd_in[filter7]</pre></summary><pre>
filter = {'': 'DEBUG'}, writer = <function writer.<locals>.w at 0x7fac0b53dc60>

    @pytest.mark.parametrize(
        "filter",
        [
            None,
            "",
            "tests",
            "tests.test_add_option_filter",
            (lambda r: True),
            (lambda r: r["level"].name == "DEBUG"),
            {},
            {"": "DEBUG"},
            {"tests": True},
            {"tests.test_add_option_filter": 10},
            {"": "WARNING", "tests": 0},
            {"tests.test_add_option_filter": 5, "tests": False},
            {"tests.test_add_option_filter.foobar": False},
            {"tests.": False},
            {"tests.test_add_option_filter.": False},
        ],
    )
    def test_filterd_in(filter, writer):
        logger.add(writer, filter=filter, format="{message}")
        logger.debug("Test Filter")
>       assert writer.read() == "Test Filter\n"
E       AssertionError: assert '' == 'Test Filter\n'
E         
E         - Test Filter

filter     = {'': 'DEBUG'}
writer     = <function writer.<locals>.w at 0x7fac0b53dc60>

tests/test_add_option_filter.py:29: AssertionError
</pre>
</details>
<h3 id="test_add_option_filterpytest_filterd_infilter8">test_add_option_filter.py::test_filterd_in[filter8]</h3>
<details><summary> <pre>test_add_option_filter.py::test_filterd_in[filter8]</pre></summary><pre>
filter = {'tests': True}
writer = <function writer.<locals>.w at 0x7fac0b53d900>

    @pytest.mark.parametrize(
        "filter",
        [
            None,
            "",
            "tests",
            "tests.test_add_option_filter",
            (lambda r: True),
            (lambda r: r["level"].name == "DEBUG"),
            {},
            {"": "DEBUG"},
            {"tests": True},
            {"tests.test_add_option_filter": 10},
            {"": "WARNING", "tests": 0},
            {"tests.test_add_option_filter": 5, "tests": False},
            {"tests.test_add_option_filter.foobar": False},
            {"tests.": False},
            {"tests.test_add_option_filter.": False},
        ],
    )
    def test_filterd_in(filter, writer):
        logger.add(writer, filter=filter, format="{message}")
        logger.debug("Test Filter")
>       assert writer.read() == "Test Filter\n"
E       AssertionError: assert '' == 'Test Filter\n'
E         
E         - Test Filter

filter     = {'tests': True}
writer     = <function writer.<locals>.w at 0x7fac0b53d900>

tests/test_add_option_filter.py:29: AssertionError
</pre>
</details>
<h3 id="test_add_option_filterpytest_filterd_infilter9">test_add_option_filter.py::test_filterd_in[filter9]</h3>
<details><summary> <pre>test_add_option_filter.py::test_filterd_in[filter9]</pre></summary><pre>
filter = {'tests.test_add_option_filter': 10}
writer = <function writer.<locals>.w at 0x7fac0b53d3f0>

    @pytest.mark.parametrize(
        "filter",
        [
            None,
            "",
            "tests",
            "tests.test_add_option_filter",
            (lambda r: True),
            (lambda r: r["level"].name == "DEBUG"),
            {},
            {"": "DEBUG"},
            {"tests": True},
            {"tests.test_add_option_filter": 10},
            {"": "WARNING", "tests": 0},
            {"tests.test_add_option_filter": 5, "tests": False},
            {"tests.test_add_option_filter.foobar": False},
            {"tests.": False},
            {"tests.test_add_option_filter.": False},
        ],
    )
    def test_filterd_in(filter, writer):
        logger.add(writer, filter=filter, format="{message}")
        logger.debug("Test Filter")
>       assert writer.read() == "Test Filter\n"
E       AssertionError: assert '' == 'Test Filter\n'
E         
E         - Test Filter

filter     = {'tests.test_add_option_filter': 10}
writer     = <function writer.<locals>.w at 0x7fac0b53d3f0>

tests/test_add_option_filter.py:29: AssertionError
</pre>
</details>
<h3 id="test_add_option_filterpytest_filterd_infilter10">test_add_option_filter.py::test_filterd_in[filter10]</h3>
<details><summary> <pre>test_add_option_filter.py::test_filterd_in[filter10]</pre></summary><pre>
filter = {'': 'WARNING', 'tests': 0}
writer = <function writer.<locals>.w at 0x7fac0b53cc10>

    @pytest.mark.parametrize(
        "filter",
        [
            None,
            "",
            "tests",
            "tests.test_add_option_filter",
            (lambda r: True),
            (lambda r: r["level"].name == "DEBUG"),
            {},
            {"": "DEBUG"},
            {"tests": True},
            {"tests.test_add_option_filter": 10},
            {"": "WARNING", "tests": 0},
            {"tests.test_add_option_filter": 5, "tests": False},
            {"tests.test_add_option_filter.foobar": False},
            {"tests.": False},
            {"tests.test_add_option_filter.": False},
        ],
    )
    def test_filterd_in(filter, writer):
        logger.add(writer, filter=filter, format="{message}")
        logger.debug("Test Filter")
>       assert writer.read() == "Test Filter\n"
E       AssertionError: assert '' == 'Test Filter\n'
E         
E         - Test Filter

filter     = {'': 'WARNING', 'tests': 0}
writer     = <function writer.<locals>.w at 0x7fac0b53cc10>

tests/test_add_option_filter.py:29: AssertionError
</pre>
</details>
<h3 id="test_add_option_filterpytest_filterd_infilter11">test_add_option_filter.py::test_filterd_in[filter11]</h3>
<details><summary> <pre>test_add_option_filter.py::test_filterd_in[filter11]</pre></summary><pre>
filter = {'tests': False, 'tests.test_add_option_filter': 5}
writer = <function writer.<locals>.w at 0x7fac0b53cee0>

    @pytest.mark.parametrize(
        "filter",
        [
            None,
            "",
            "tests",
            "tests.test_add_option_filter",
            (lambda r: True),
            (lambda r: r["level"].name == "DEBUG"),
            {},
            {"": "DEBUG"},
            {"tests": True},
            {"tests.test_add_option_filter": 10},
            {"": "WARNING", "tests": 0},
            {"tests.test_add_option_filter": 5, "tests": False},
            {"tests.test_add_option_filter.foobar": False},
            {"tests.": False},
            {"tests.test_add_option_filter.": False},
        ],
    )
    def test_filterd_in(filter, writer):
        logger.add(writer, filter=filter, format="{message}")
        logger.debug("Test Filter")
>       assert writer.read() == "Test Filter\n"
E       AssertionError: assert '' == 'Test Filter\n'
E         
E         - Test Filter

filter     = {'tests': False, 'tests.test_add_option_filter': 5}
writer     = <function writer.<locals>.w at 0x7fac0b53cee0>

tests/test_add_option_filter.py:29: AssertionError
</pre>
</details>
<h3 id="test_add_option_filterpytest_filterd_infilter12">test_add_option_filter.py::test_filterd_in[filter12]</h3>
<details><summary> <pre>test_add_option_filter.py::test_filterd_in[filter12]</pre></summary><pre>
filter = {'tests.test_add_option_filter.foobar': False}
writer = <function writer.<locals>.w at 0x7fac0b53de10>

    @pytest.mark.parametrize(
        "filter",
        [
            None,
            "",
            "tests",
            "tests.test_add_option_filter",
            (lambda r: True),
            (lambda r: r["level"].name == "DEBUG"),
            {},
            {"": "DEBUG"},
            {"tests": True},
            {"tests.test_add_option_filter": 10},
            {"": "WARNING", "tests": 0},
            {"tests.test_add_option_filter": 5, "tests": False},
            {"tests.test_add_option_filter.foobar": False},
            {"tests.": False},
            {"tests.test_add_option_filter.": False},
        ],
    )
    def test_filterd_in(filter, writer):
        logger.add(writer, filter=filter, format="{message}")
        logger.debug("Test Filter")
>       assert writer.read() == "Test Filter\n"
E       AssertionError: assert '' == 'Test Filter\n'
E         
E         - Test Filter

filter     = {'tests.test_add_option_filter.foobar': False}
writer     = <function writer.<locals>.w at 0x7fac0b53de10>

tests/test_add_option_filter.py:29: AssertionError
</pre>
</details>
<h3 id="test_add_option_filterpytest_filterd_infilter13">test_add_option_filter.py::test_filterd_in[filter13]</h3>
<details><summary> <pre>test_add_option_filter.py::test_filterd_in[filter13]</pre></summary><pre>
filter = {'tests.': False}
writer = <function writer.<locals>.w at 0x7fac0b53dfc0>

    @pytest.mark.parametrize(
        "filter",
        [
            None,
            "",
            "tests",
            "tests.test_add_option_filter",
            (lambda r: True),
            (lambda r: r["level"].name == "DEBUG"),
            {},
            {"": "DEBUG"},
            {"tests": True},
            {"tests.test_add_option_filter": 10},
            {"": "WARNING", "tests": 0},
            {"tests.test_add_option_filter": 5, "tests": False},
            {"tests.test_add_option_filter.foobar": False},
            {"tests.": False},
            {"tests.test_add_option_filter.": False},
        ],
    )
    def test_filterd_in(filter, writer):
        logger.add(writer, filter=filter, format="{message}")
        logger.debug("Test Filter")
>       assert writer.read() == "Test Filter\n"
E       AssertionError: assert '' == 'Test Filter\n'
E         
E         - Test Filter

filter     = {'tests.': False}
writer     = <function writer.<locals>.w at 0x7fac0b53dfc0>

tests/test_add_option_filter.py:29: AssertionError
</pre>
</details>
<h3 id="test_add_option_filterpytest_filterd_infilter14">test_add_option_filter.py::test_filterd_in[filter14]</h3>
<details><summary> <pre>test_add_option_filter.py::test_filterd_in[filter14]</pre></summary><pre>
filter = {'tests.test_add_option_filter.': False}
writer = <function writer.<locals>.w at 0x7fac0b53e200>

    @pytest.mark.parametrize(
        "filter",
        [
            None,
            "",
            "tests",
            "tests.test_add_option_filter",
            (lambda r: True),
            (lambda r: r["level"].name == "DEBUG"),
            {},
            {"": "DEBUG"},
            {"tests": True},
            {"tests.test_add_option_filter": 10},
            {"": "WARNING", "tests": 0},
            {"tests.test_add_option_filter": 5, "tests": False},
            {"tests.test_add_option_filter.foobar": False},
            {"tests.": False},
            {"tests.test_add_option_filter.": False},
        ],
    )
    def test_filterd_in(filter, writer):
        logger.add(writer, filter=filter, format="{message}")
        logger.debug("Test Filter")
>       assert writer.read() == "Test Filter\n"
E       AssertionError: assert '' == 'Test Filter\n'
E         
E         - Test Filter

filter     = {'tests.test_add_option_filter.': False}
writer     = <function writer.<locals>.w at 0x7fac0b53e200>

tests/test_add_option_filter.py:29: AssertionError
</pre>
</details>
<h3 id="test_add_option_filterpytest_filtered_in_f_globals_name_absentnone">test_add_option_filter.py::test_filtered_in_f_globals_name_absent[None]</h3>
<details><summary> <pre>test_add_option_filter.py::test_filtered_in_f_globals_name_absent[None]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53cc10>, filter = None
f_globals_name_absent = None

    @pytest.mark.parametrize(
        "filter",
        [
            None,
            lambda _: True,
            {},
            {None: 0},
            {"": False},
            {"tests": False, None: True},
            {"unrelated": 100},
            {None: "INFO", "": "WARNING"},
        ],
    )
    def test_filtered_in_f_globals_name_absent(writer, filter, f_globals_name_absent):
        logger.add(writer, filter=filter, format="{message}", catch=False)
        logger.info("It's ok")
>       assert writer.read() == "It's ok\n"
E       assert '' == "It's ok\n"
E         
E         - It's ok

f_globals_name_absent = None
filter     = None
writer     = <function writer.<locals>.w at 0x7fac0b53cc10>

tests/test_add_option_filter.py:72: AssertionError
</pre>
</details>
<h3 id="test_add_option_filterpytest_filtered_in_f_globals_name_absent">test_add_option_filter.py::test_filtered_in_f_globals_name_absent[<lambda>]</h3>
<details><summary> <pre>test_add_option_filter.py::test_filtered_in_f_globals_name_absent[<lambda>]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b752c20>
filter = <function <lambda> at 0x7fac0befa950>, f_globals_name_absent = None

    @pytest.mark.parametrize(
        "filter",
        [
            None,
            lambda _: True,
            {},
            {None: 0},
            {"": False},
            {"tests": False, None: True},
            {"unrelated": 100},
            {None: "INFO", "": "WARNING"},
        ],
    )
    def test_filtered_in_f_globals_name_absent(writer, filter, f_globals_name_absent):
        logger.add(writer, filter=filter, format="{message}", catch=False)
        logger.info("It's ok")
>       assert writer.read() == "It's ok\n"
E       assert '' == "It's ok\n"
E         
E         - It's ok

f_globals_name_absent = None
filter     = <function <lambda> at 0x7fac0befa950>
writer     = <function writer.<locals>.w at 0x7fac0b752c20>

tests/test_add_option_filter.py:72: AssertionError
</pre>
</details>
<h3 id="test_add_option_filterpytest_filtered_in_f_globals_name_absentfilter2">test_add_option_filter.py::test_filtered_in_f_globals_name_absent[filter2]</h3>
<details><summary> <pre>test_add_option_filter.py::test_filtered_in_f_globals_name_absent[filter2]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b752680>, filter = {}
f_globals_name_absent = None

    @pytest.mark.parametrize(
        "filter",
        [
            None,
            lambda _: True,
            {},
            {None: 0},
            {"": False},
            {"tests": False, None: True},
            {"unrelated": 100},
            {None: "INFO", "": "WARNING"},
        ],
    )
    def test_filtered_in_f_globals_name_absent(writer, filter, f_globals_name_absent):
        logger.add(writer, filter=filter, format="{message}", catch=False)
        logger.info("It's ok")
>       assert writer.read() == "It's ok\n"
E       assert '' == "It's ok\n"
E         
E         - It's ok

f_globals_name_absent = None
filter     = {}
writer     = <function writer.<locals>.w at 0x7fac0b752680>

tests/test_add_option_filter.py:72: AssertionError
</pre>
</details>
<h3 id="test_add_option_filterpytest_filtered_in_f_globals_name_absentfilter3">test_add_option_filter.py::test_filtered_in_f_globals_name_absent[filter3]</h3>
<details><summary> <pre>test_add_option_filter.py::test_filtered_in_f_globals_name_absent[filter3]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b753880>, filter = {None: 0}
f_globals_name_absent = None

    @pytest.mark.parametrize(
        "filter",
        [
            None,
            lambda _: True,
            {},
            {None: 0},
            {"": False},
            {"tests": False, None: True},
            {"unrelated": 100},
            {None: "INFO", "": "WARNING"},
        ],
    )
    def test_filtered_in_f_globals_name_absent(writer, filter, f_globals_name_absent):
        logger.add(writer, filter=filter, format="{message}", catch=False)
        logger.info("It's ok")
>       assert writer.read() == "It's ok\n"
E       assert '' == "It's ok\n"
E         
E         - It's ok

f_globals_name_absent = None
filter     = {None: 0}
writer     = <function writer.<locals>.w at 0x7fac0b753880>

tests/test_add_option_filter.py:72: AssertionError
</pre>
</details>
<h3 id="test_add_option_filterpytest_filtered_in_f_globals_name_absentfilter4">test_add_option_filter.py::test_filtered_in_f_globals_name_absent[filter4]</h3>
<details><summary> <pre>test_add_option_filter.py::test_filtered_in_f_globals_name_absent[filter4]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53c4c0>, filter = {'': False}
f_globals_name_absent = None

    @pytest.mark.parametrize(
        "filter",
        [
            None,
            lambda _: True,
            {},
            {None: 0},
            {"": False},
            {"tests": False, None: True},
            {"unrelated": 100},
            {None: "INFO", "": "WARNING"},
        ],
    )
    def test_filtered_in_f_globals_name_absent(writer, filter, f_globals_name_absent):
        logger.add(writer, filter=filter, format="{message}", catch=False)
        logger.info("It's ok")
>       assert writer.read() == "It's ok\n"
E       assert '' == "It's ok\n"
E         
E         - It's ok

f_globals_name_absent = None
filter     = {'': False}
writer     = <function writer.<locals>.w at 0x7fac0b53c4c0>

tests/test_add_option_filter.py:72: AssertionError
</pre>
</details>
<h3 id="test_add_option_filterpytest_filtered_in_f_globals_name_absentfilter5">test_add_option_filter.py::test_filtered_in_f_globals_name_absent[filter5]</h3>
<details><summary> <pre>test_add_option_filter.py::test_filtered_in_f_globals_name_absent[filter5]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53d360>
filter = {'tests': False, None: True}, f_globals_name_absent = None

    @pytest.mark.parametrize(
        "filter",
        [
            None,
            lambda _: True,
            {},
            {None: 0},
            {"": False},
            {"tests": False, None: True},
            {"unrelated": 100},
            {None: "INFO", "": "WARNING"},
        ],
    )
    def test_filtered_in_f_globals_name_absent(writer, filter, f_globals_name_absent):
        logger.add(writer, filter=filter, format="{message}", catch=False)
        logger.info("It's ok")
>       assert writer.read() == "It's ok\n"
E       assert '' == "It's ok\n"
E         
E         - It's ok

f_globals_name_absent = None
filter     = {'tests': False, None: True}
writer     = <function writer.<locals>.w at 0x7fac0b53d360>

tests/test_add_option_filter.py:72: AssertionError
</pre>
</details>
<h3 id="test_add_option_filterpytest_filtered_in_f_globals_name_absentfilter6">test_add_option_filter.py::test_filtered_in_f_globals_name_absent[filter6]</h3>
<details><summary> <pre>test_add_option_filter.py::test_filtered_in_f_globals_name_absent[filter6]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53e0e0>
filter = {'unrelated': 100}, f_globals_name_absent = None

    @pytest.mark.parametrize(
        "filter",
        [
            None,
            lambda _: True,
            {},
            {None: 0},
            {"": False},
            {"tests": False, None: True},
            {"unrelated": 100},
            {None: "INFO", "": "WARNING"},
        ],
    )
    def test_filtered_in_f_globals_name_absent(writer, filter, f_globals_name_absent):
        logger.add(writer, filter=filter, format="{message}", catch=False)
        logger.info("It's ok")
>       assert writer.read() == "It's ok\n"
E       assert '' == "It's ok\n"
E         
E         - It's ok

f_globals_name_absent = None
filter     = {'unrelated': 100}
writer     = <function writer.<locals>.w at 0x7fac0b53e0e0>

tests/test_add_option_filter.py:72: AssertionError
</pre>
</details>
<h3 id="test_add_option_filterpytest_filtered_in_f_globals_name_absentfilter7">test_add_option_filter.py::test_filtered_in_f_globals_name_absent[filter7]</h3>
<details><summary> <pre>test_add_option_filter.py::test_filtered_in_f_globals_name_absent[filter7]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53c670>
filter = {None: 'INFO', '': 'WARNING'}, f_globals_name_absent = None

    @pytest.mark.parametrize(
        "filter",
        [
            None,
            lambda _: True,
            {},
            {None: 0},
            {"": False},
            {"tests": False, None: True},
            {"unrelated": 100},
            {None: "INFO", "": "WARNING"},
        ],
    )
    def test_filtered_in_f_globals_name_absent(writer, filter, f_globals_name_absent):
        logger.add(writer, filter=filter, format="{message}", catch=False)
        logger.info("It's ok")
>       assert writer.read() == "It's ok\n"
E       assert '' == "It's ok\n"
E         
E         - It's ok

f_globals_name_absent = None
filter     = {None: 'INFO', '': 'WARNING'}
writer     = <function writer.<locals>.w at 0x7fac0b53c670>

tests/test_add_option_filter.py:72: AssertionError
</pre>
</details>
<h3 id="test_add_option_filterpytest_invalid_filter-1">test_add_option_filter.py::test_invalid_filter[-1]</h3>
<details><summary> <pre>test_add_option_filter.py::test_invalid_filter[-1]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53d000>, filter = -1

    @pytest.mark.parametrize("filter", [-1, 3.4, object()])
    def test_invalid_filter(writer, filter):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

filter     = -1
writer     = <function writer.<locals>.w at 0x7fac0b53d000>

tests/test_add_option_filter.py:94: Failed
</pre>
</details>
<h3 id="test_add_option_filterpytest_invalid_filter34">test_add_option_filter.py::test_invalid_filter[3.4]</h3>
<details><summary> <pre>test_add_option_filter.py::test_invalid_filter[3.4]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53d6c0>, filter = 3.4

    @pytest.mark.parametrize("filter", [-1, 3.4, object()])
    def test_invalid_filter(writer, filter):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

filter     = 3.4
writer     = <function writer.<locals>.w at 0x7fac0b53d6c0>

tests/test_add_option_filter.py:94: Failed
</pre>
</details>
<h3 id="test_add_option_filterpytest_invalid_filterfilter2">test_add_option_filter.py::test_invalid_filter[filter2]</h3>
<details><summary> <pre>test_add_option_filter.py::test_invalid_filter[filter2]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53d990>
filter = <object object at 0x7fac0db8b2c0>

    @pytest.mark.parametrize("filter", [-1, 3.4, object()])
    def test_invalid_filter(writer, filter):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

filter     = <object object at 0x7fac0db8b2c0>
writer     = <function writer.<locals>.w at 0x7fac0b53d990>

tests/test_add_option_filter.py:94: Failed
</pre>
</details>
<h3 id="test_add_option_filterpytest_invalid_filter_dict_typesfilter0">test_add_option_filter.py::test_invalid_filter_dict_types[filter0]</h3>
<details><summary> <pre>test_add_option_filter.py::test_invalid_filter_dict_types[filter0]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b753490>, filter = {1: 'DEBUG'}

    @pytest.mark.parametrize(
        "filter",
        [{1: "DEBUG"}, {object(): 10}, {"foo": None}, {"foo": 2.5}, {"a": "DEBUG", "b": object()}],
    )
    def test_invalid_filter_dict_types(writer, filter):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

filter     = {1: 'DEBUG'}
writer     = <function writer.<locals>.w at 0x7fac0b753490>

tests/test_add_option_filter.py:103: Failed
</pre>
</details>
<h3 id="test_add_option_filterpytest_invalid_filter_dict_typesfilter1">test_add_option_filter.py::test_invalid_filter_dict_types[filter1]</h3>
<details><summary> <pre>test_add_option_filter.py::test_invalid_filter_dict_types[filter1]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b752d40>
filter = {<object object at 0x7fac0db8b150>: 10}

    @pytest.mark.parametrize(
        "filter",
        [{1: "DEBUG"}, {object(): 10}, {"foo": None}, {"foo": 2.5}, {"a": "DEBUG", "b": object()}],
    )
    def test_invalid_filter_dict_types(writer, filter):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

filter     = {<object object at 0x7fac0db8b150>: 10}
writer     = <function writer.<locals>.w at 0x7fac0b752d40>

tests/test_add_option_filter.py:103: Failed
</pre>
</details>
<h3 id="test_add_option_filterpytest_invalid_filter_dict_typesfilter2">test_add_option_filter.py::test_invalid_filter_dict_types[filter2]</h3>
<details><summary> <pre>test_add_option_filter.py::test_invalid_filter_dict_types[filter2]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b752200>, filter = {'foo': None}

    @pytest.mark.parametrize(
        "filter",
        [{1: "DEBUG"}, {object(): 10}, {"foo": None}, {"foo": 2.5}, {"a": "DEBUG", "b": object()}],
    )
    def test_invalid_filter_dict_types(writer, filter):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

filter     = {'foo': None}
writer     = <function writer.<locals>.w at 0x7fac0b752200>

tests/test_add_option_filter.py:103: Failed
</pre>
</details>
<h3 id="test_add_option_filterpytest_invalid_filter_dict_typesfilter3">test_add_option_filter.py::test_invalid_filter_dict_types[filter3]</h3>
<details><summary> <pre>test_add_option_filter.py::test_invalid_filter_dict_types[filter3]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53d480>, filter = {'foo': 2.5}

    @pytest.mark.parametrize(
        "filter",
        [{1: "DEBUG"}, {object(): 10}, {"foo": None}, {"foo": 2.5}, {"a": "DEBUG", "b": object()}],
    )
    def test_invalid_filter_dict_types(writer, filter):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

filter     = {'foo': 2.5}
writer     = <function writer.<locals>.w at 0x7fac0b53d480>

tests/test_add_option_filter.py:103: Failed
</pre>
</details>
<h3 id="test_add_option_filterpytest_invalid_filter_dict_typesfilter4">test_add_option_filter.py::test_invalid_filter_dict_types[filter4]</h3>
<details><summary> <pre>test_add_option_filter.py::test_invalid_filter_dict_types[filter4]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53ec20>
filter = {'a': 'DEBUG', 'b': <object object at 0x7fac0db8b1f0>}

    @pytest.mark.parametrize(
        "filter",
        [{1: "DEBUG"}, {object(): 10}, {"foo": None}, {"foo": 2.5}, {"a": "DEBUG", "b": object()}],
    )
    def test_invalid_filter_dict_types(writer, filter):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

filter     = {'a': 'DEBUG', 'b': <object object at 0x7fac0db8b1f0>}
writer     = <function writer.<locals>.w at 0x7fac0b53ec20>

tests/test_add_option_filter.py:103: Failed
</pre>
</details>
<h3 id="test_add_option_filterpytest_invalid_filter_dict_valuesfilter0">test_add_option_filter.py::test_invalid_filter_dict_values[filter0]</h3>
<details><summary> <pre>test_add_option_filter.py::test_invalid_filter_dict_values[filter0]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53d510>
filter = {'foo': 'UNKNOWN_LEVEL'}

    @pytest.mark.parametrize(
        "filter", [{"foo": "UNKNOWN_LEVEL"}, {"tests": -1}, {"tests.test_add_option_filter": ""}]
    )
    def test_invalid_filter_dict_values(writer, filter):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

filter     = {'foo': 'UNKNOWN_LEVEL'}
writer     = <function writer.<locals>.w at 0x7fac0b53d510>

tests/test_add_option_filter.py:111: Failed
</pre>
</details>
<h3 id="test_add_option_filterpytest_invalid_filter_dict_valuesfilter1">test_add_option_filter.py::test_invalid_filter_dict_values[filter1]</h3>
<details><summary> <pre>test_add_option_filter.py::test_invalid_filter_dict_values[filter1]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53e710>, filter = {'tests': -1}

    @pytest.mark.parametrize(
        "filter", [{"foo": "UNKNOWN_LEVEL"}, {"tests": -1}, {"tests.test_add_option_filter": ""}]
    )
    def test_invalid_filter_dict_values(writer, filter):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

filter     = {'tests': -1}
writer     = <function writer.<locals>.w at 0x7fac0b53e710>

tests/test_add_option_filter.py:111: Failed
</pre>
</details>
<h3 id="test_add_option_filterpytest_invalid_filter_dict_valuesfilter2">test_add_option_filter.py::test_invalid_filter_dict_values[filter2]</h3>
<details><summary> <pre>test_add_option_filter.py::test_invalid_filter_dict_values[filter2]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53d6c0>
filter = {'tests.test_add_option_filter': ''}

    @pytest.mark.parametrize(
        "filter", [{"foo": "UNKNOWN_LEVEL"}, {"tests": -1}, {"tests.test_add_option_filter": ""}]
    )
    def test_invalid_filter_dict_values(writer, filter):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

filter     = {'tests.test_add_option_filter': ''}
writer     = <function writer.<locals>.w at 0x7fac0b53d6c0>

tests/test_add_option_filter.py:111: Failed
</pre>
</details>
<h3 id="test_add_option_filterpytest_filter_dict_with_custom_level">test_add_option_filter.py::test_filter_dict_with_custom_level</h3>
<details><summary> <pre>test_add_option_filter.py::test_filter_dict_with_custom_level</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53d000>

    def test_filter_dict_with_custom_level(writer):
        logger.level("MY_LEVEL", 6, color="", icon="")
        logger.add(writer, level=0, filter={"tests": "MY_LEVEL"}, format="{message}")
        logger.log(3, "No")
        logger.log(9, "Yes")
>       assert writer.read() == "Yes\n"
E       AssertionError: assert '' == 'Yes\n'
E         
E         - Yes

writer     = <function writer.<locals>.w at 0x7fac0b53d000>

tests/test_add_option_filter.py:120: AssertionError
</pre>
</details>
<h3 id="test_add_option_filterpytest_invalid_filter_builtin">test_add_option_filter.py::test_invalid_filter_builtin</h3>
<details><summary> <pre>test_add_option_filter.py::test_invalid_filter_builtin</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53e560>

    def test_invalid_filter_builtin(writer):
>       with pytest.raises(ValueError, match=r".* most likely a mistake"):
E       Failed: DID NOT RAISE <class 'ValueError'>

writer     = <function writer.<locals>.w at 0x7fac0b53e560>

tests/test_add_option_filter.py:124: Failed
</pre>
</details>
<h3 id="test_add_option_formatpytest_formata-message-message-message-an">test_add_option_format.py::test_format[a-Message: {message}-Message: a\n]</h3>
<details><summary> <pre>test_add_option_format.py::test_format[a-Message: {message}-Message: a\n]</pre></summary><pre>
message = 'a', format = 'Message: {message}', expected = 'Message: a\n'
writer = <function writer.<locals>.w at 0x7fac0b53d630>

    @pytest.mark.parametrize(
        "message, format, expected",
        [
            ("a", "Message: {message}", "Message: a\n"),
            ("b", "Nope", "Nope\n"),
            ("c", "{level} {message} {level}", "DEBUG c DEBUG\n"),
            ("d", "{message} {level} {level.no} {level.name}", "d DEBUG 10 DEBUG\n"),
            ("e", lambda _: "{message}", "e"),
            ("f", lambda r: "{message} " + r["level"].name, "f DEBUG"),
        ],
    )
    def test_format(message, format, expected, writer):
        logger.add(writer, format=format)
        logger.debug(message)
>       assert writer.read() == expected
E       AssertionError: assert '' == 'Message: a\n'
E         
E         - Message: a

expected   = 'Message: a\n'
format     = 'Message: {message}'
message    = 'a'
writer     = <function writer.<locals>.w at 0x7fac0b53d630>

tests/test_add_option_format.py:20: AssertionError
</pre>
</details>
<h3 id="test_add_option_formatpytest_formatb-nope-nopen">test_add_option_format.py::test_format[b-Nope-Nope\n]</h3>
<details><summary> <pre>test_add_option_format.py::test_format[b-Nope-Nope\n]</pre></summary><pre>
message = 'b', format = 'Nope', expected = 'Nope\n'
writer = <function writer.<locals>.w at 0x7fac0b53d360>

    @pytest.mark.parametrize(
        "message, format, expected",
        [
            ("a", "Message: {message}", "Message: a\n"),
            ("b", "Nope", "Nope\n"),
            ("c", "{level} {message} {level}", "DEBUG c DEBUG\n"),
            ("d", "{message} {level} {level.no} {level.name}", "d DEBUG 10 DEBUG\n"),
            ("e", lambda _: "{message}", "e"),
            ("f", lambda r: "{message} " + r["level"].name, "f DEBUG"),
        ],
    )
    def test_format(message, format, expected, writer):
        logger.add(writer, format=format)
        logger.debug(message)
>       assert writer.read() == expected
E       AssertionError: assert '' == 'Nope\n'
E         
E         - Nope

expected   = 'Nope\n'
format     = 'Nope'
message    = 'b'
writer     = <function writer.<locals>.w at 0x7fac0b53d360>

tests/test_add_option_format.py:20: AssertionError
</pre>
</details>
<h3 id="test_add_option_formatpytest_formatc-level-message-level-debug-c-debugn">test_add_option_format.py::test_format[c-{level} {message} {level}-DEBUG c DEBUG\n]</h3>
<details><summary> <pre>test_add_option_format.py::test_format[c-{level} {message} {level}-DEBUG c DEBUG\n]</pre></summary><pre>
message = 'c', format = '{level} {message} {level}'
expected = 'DEBUG c DEBUG\n'
writer = <function writer.<locals>.w at 0x7fac0b752d40>

    @pytest.mark.parametrize(
        "message, format, expected",
        [
            ("a", "Message: {message}", "Message: a\n"),
            ("b", "Nope", "Nope\n"),
            ("c", "{level} {message} {level}", "DEBUG c DEBUG\n"),
            ("d", "{message} {level} {level.no} {level.name}", "d DEBUG 10 DEBUG\n"),
            ("e", lambda _: "{message}", "e"),
            ("f", lambda r: "{message} " + r["level"].name, "f DEBUG"),
        ],
    )
    def test_format(message, format, expected, writer):
        logger.add(writer, format=format)
        logger.debug(message)
>       assert writer.read() == expected
E       AssertionError: assert '' == 'DEBUG c DEBUG\n'
E         
E         - DEBUG c DEBUG

expected   = 'DEBUG c DEBUG\n'
format     = '{level} {message} {level}'
message    = 'c'
writer     = <function writer.<locals>.w at 0x7fac0b752d40>

tests/test_add_option_format.py:20: AssertionError
</pre>
</details>
<h3 id="test_add_option_formatpytest_formatd-message-level-levelno-levelname-d-debug-10-debugn">test_add_option_format.py::test_format[d-{message} {level} {level.no} {level.name}-d DEBUG 10 DEBUG\n]</h3>
<details><summary> <pre>test_add_option_format.py::test_format[d-{message} {level} {level.no} {level.name}-d DEBUG 10 DEBUG\n]</pre></summary><pre>
message = 'd', format = '{message} {level} {level.no} {level.name}'
expected = 'd DEBUG 10 DEBUG\n'
writer = <function writer.<locals>.w at 0x7fac0b7529e0>

    @pytest.mark.parametrize(
        "message, format, expected",
        [
            ("a", "Message: {message}", "Message: a\n"),
            ("b", "Nope", "Nope\n"),
            ("c", "{level} {message} {level}", "DEBUG c DEBUG\n"),
            ("d", "{message} {level} {level.no} {level.name}", "d DEBUG 10 DEBUG\n"),
            ("e", lambda _: "{message}", "e"),
            ("f", lambda r: "{message} " + r["level"].name, "f DEBUG"),
        ],
    )
    def test_format(message, format, expected, writer):
        logger.add(writer, format=format)
        logger.debug(message)
>       assert writer.read() == expected
E       AssertionError: assert '' == 'd DEBUG 10 DEBUG\n'
E         
E         - d DEBUG 10 DEBUG

expected   = 'd DEBUG 10 DEBUG\n'
format     = '{message} {level} {level.no} {level.name}'
message    = 'd'
writer     = <function writer.<locals>.w at 0x7fac0b7529e0>

tests/test_add_option_format.py:20: AssertionError
</pre>
</details>
<h3 id="test_add_option_formatpytest_formate-e">test_add_option_format.py::test_format[e-<lambda>-e]</h3>
<details><summary> <pre>test_add_option_format.py::test_format[e-<lambda>-e]</pre></summary><pre>
message = 'e', format = <function <lambda> at 0x7fac0befb6d0>, expected = 'e'
writer = <function writer.<locals>.w at 0x7fac0b53e9e0>

    @pytest.mark.parametrize(
        "message, format, expected",
        [
            ("a", "Message: {message}", "Message: a\n"),
            ("b", "Nope", "Nope\n"),
            ("c", "{level} {message} {level}", "DEBUG c DEBUG\n"),
            ("d", "{message} {level} {level.no} {level.name}", "d DEBUG 10 DEBUG\n"),
            ("e", lambda _: "{message}", "e"),
            ("f", lambda r: "{message} " + r["level"].name, "f DEBUG"),
        ],
    )
    def test_format(message, format, expected, writer):
        logger.add(writer, format=format)
        logger.debug(message)
>       assert writer.read() == expected
E       AssertionError: assert '' == 'e'
E         
E         - e

expected   = 'e'
format     = <function <lambda> at 0x7fac0befb6d0>
message    = 'e'
writer     = <function writer.<locals>.w at 0x7fac0b53e9e0>

tests/test_add_option_format.py:20: AssertionError
</pre>
</details>
<h3 id="test_add_option_formatpytest_formatf-f-debug">test_add_option_format.py::test_format[f-<lambda>-f DEBUG]</h3>
<details><summary> <pre>test_add_option_format.py::test_format[f-<lambda>-f DEBUG]</pre></summary><pre>
message = 'f', format = <function <lambda> at 0x7fac0befb760>
expected = 'f DEBUG', writer = <function writer.<locals>.w at 0x7fac0b53e830>

    @pytest.mark.parametrize(
        "message, format, expected",
        [
            ("a", "Message: {message}", "Message: a\n"),
            ("b", "Nope", "Nope\n"),
            ("c", "{level} {message} {level}", "DEBUG c DEBUG\n"),
            ("d", "{message} {level} {level.no} {level.name}", "d DEBUG 10 DEBUG\n"),
            ("e", lambda _: "{message}", "e"),
            ("f", lambda r: "{message} " + r["level"].name, "f DEBUG"),
        ],
    )
    def test_format(message, format, expected, writer):
        logger.add(writer, format=format)
        logger.debug(message)
>       assert writer.read() == expected
E       AssertionError: assert '' == 'f DEBUG'
E         
E         - f DEBUG

expected   = 'f DEBUG'
format     = <function <lambda> at 0x7fac0befb760>
message    = 'f'
writer     = <function writer.<locals>.w at 0x7fac0b53e830>

tests/test_add_option_format.py:20: AssertionError
</pre>
</details>
<h3 id="test_add_option_formatpytest_progressive_format">test_add_option_format.py::test_progressive_format</h3>
<details><summary> <pre>test_add_option_format.py::test_progressive_format</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53d630>

    def test_progressive_format(writer):
        def formatter(record):
            fmt = "[{level.name}] {message}"
            if "noend" not in record["extra"]:
                fmt += "\n"
            return fmt

        logger.add(writer, format=formatter)
>       logger.bind(noend=True).debug("Start: ")
E       AttributeError: 'NoneType' object has no attribute 'debug'

formatter  = <function test_progressive_format.<locals>.formatter at 0x7fac0b53d870>
writer     = <function writer.<locals>.w at 0x7fac0b53d630>

tests/test_add_option_format.py:31: AttributeError
</pre>
</details>
<h3 id="test_add_option_formatpytest_function_format_without_exception">test_add_option_format.py::test_function_format_without_exception</h3>
<details><summary> <pre>test_add_option_format.py::test_function_format_without_exception</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53c4c0>

    def test_function_format_without_exception(writer):
        logger.add(writer, format=lambda _: "{message}\n")
        try:
            1 / 0  # noqa: B018
        except ZeroDivisionError:
            logger.exception("Error!")
>       assert writer.read() == "Error!\n"
E       AssertionError: assert '' == 'Error!\n'
E         
E         - Error!

writer     = <function writer.<locals>.w at 0x7fac0b53c4c0>

tests/test_add_option_format.py:45: AssertionError
</pre>
</details>
<h3 id="test_add_option_formatpytest_function_format_with_exception">test_add_option_format.py::test_function_format_with_exception</h3>
<details><summary> <pre>test_add_option_format.py::test_function_format_with_exception</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53e8c0>

    def test_function_format_with_exception(writer):
        logger.add(writer, format=lambda _: "{message}\n{exception}")
        try:
            1 / 0  # noqa: B018
        except ZeroDivisionError:
            logger.exception("Error!")
        lines = writer.read().splitlines()
>       assert lines[0] == "Error!"
E       IndexError: list index out of range

lines      = []
writer     = <function writer.<locals>.w at 0x7fac0b53e8c0>

tests/test_add_option_format.py:55: IndexError
</pre>
</details>
<h3 id="test_add_option_formatpytest_invalid_format-1">test_add_option_format.py::test_invalid_format[-1]</h3>
<details><summary> <pre>test_add_option_format.py::test_invalid_format[-1]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53d6c0>, format = -1

    @pytest.mark.parametrize("format", [-1, 3.4, object()])
    def test_invalid_format(writer, format):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

format     = -1
writer     = <function writer.<locals>.w at 0x7fac0b53d6c0>

tests/test_add_option_format.py:61: Failed
</pre>
</details>
<h3 id="test_add_option_formatpytest_invalid_format34">test_add_option_format.py::test_invalid_format[3.4]</h3>
<details><summary> <pre>test_add_option_format.py::test_invalid_format[3.4]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53c670>, format = 3.4

    @pytest.mark.parametrize("format", [-1, 3.4, object()])
    def test_invalid_format(writer, format):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

format     = 3.4
writer     = <function writer.<locals>.w at 0x7fac0b53c670>

tests/test_add_option_format.py:61: Failed
</pre>
</details>
<h3 id="test_add_option_formatpytest_invalid_formatformat2">test_add_option_format.py::test_invalid_format[format2]</h3>
<details><summary> <pre>test_add_option_format.py::test_invalid_format[format2]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53de10>
format = <object object at 0x7fac0db8b490>

    @pytest.mark.parametrize("format", [-1, 3.4, object()])
    def test_invalid_format(writer, format):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

format     = <object object at 0x7fac0db8b490>
writer     = <function writer.<locals>.w at 0x7fac0b53de10>

tests/test_add_option_format.py:61: Failed
</pre>
</details>
<h3 id="test_add_option_formatpytest_invalid_markups">test_add_option_format.py::test_invalid_markups[<red>]</h3>
<details><summary> <pre>test_add_option_format.py::test_invalid_markups[<red>]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53d480>, format = '<red>'

    @pytest.mark.parametrize("format", ["<red>", "</red>", "</level><level>", "", "<foobar>"])
    def test_invalid_markups(writer, format):
>       with pytest.raises(ValueError, match=r"Invalid format"):
E       Failed: DID NOT RAISE <class 'ValueError'>

format     = '<red>'
writer     = <function writer.<locals>.w at 0x7fac0b53d480>

tests/test_add_option_format.py:67: Failed
</pre>
</details>
<h3 id="red">red&gt;]</h3>
<details><summary> <pre>red>]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53ed40>, format = '</red>'

    @pytest.mark.parametrize("format", ["<red>", "</red>", "</level><level>", "", "<foobar>"])
    def test_invalid_markups(writer, format):
>       with pytest.raises(ValueError, match=r"Invalid format"):
E       Failed: DID NOT RAISE <class 'ValueError'>

format     = '</red>'
writer     = <function writer.<locals>.w at 0x7fac0b53ed40>

tests/test_add_option_format.py:67: Failed
</pre>
</details>
<h3 id="level">level&gt;<level>]</h3>
<details><summary> <pre>level><level>]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b7529e0>
format = '</level><level>'

    @pytest.mark.parametrize("format", ["<red>", "</red>", "</level><level>", "", "<foobar>"])
    def test_invalid_markups(writer, format):
>       with pytest.raises(ValueError, match=r"Invalid format"):
E       Failed: DID NOT RAISE <class 'ValueError'>

format     = '</level><level>'
writer     = <function writer.<locals>.w at 0x7fac0b7529e0>

tests/test_add_option_format.py:67: Failed
</pre>
</details>
<h3 id="_1">&gt;]</h3>
<details><summary> <pre>>]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b752e60>, format = ''

    @pytest.mark.parametrize("format", ["<red>", "</red>", "</level><level>", "", "<foobar>"])
    def test_invalid_markups(writer, format):
>       with pytest.raises(ValueError, match=r"Invalid format"):
E       Failed: DID NOT RAISE <class 'ValueError'>

format     = ''
writer     = <function writer.<locals>.w at 0x7fac0b752e60>

tests/test_add_option_format.py:67: Failed
</pre>
</details>
<h3 id="test_add_option_formatpytest_invalid_markups_1">test_add_option_format.py::test_invalid_markups[<foobar>]</h3>
<details><summary> <pre>test_add_option_format.py::test_invalid_markups[<foobar>]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53f400>, format = '<foobar>'

    @pytest.mark.parametrize("format", ["<red>", "</red>", "</level><level>", "", "<foobar>"])
    def test_invalid_markups(writer, format):
>       with pytest.raises(ValueError, match=r"Invalid format"):
E       Failed: DID NOT RAISE <class 'ValueError'>

format     = '<foobar>'
writer     = <function writer.<locals>.w at 0x7fac0b53f400>

tests/test_add_option_format.py:67: Failed
</pre>
</details>
<h3 id="test_add_option_formatpytest_markup_in_fieldtrue">test_add_option_format.py::test_markup_in_field[True]</h3>
<details><summary> <pre>test_add_option_format.py::test_markup_in_field[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53f1c0>, colorize = True

    @pytest.mark.parametrize("colorize", [True, False])
    def test_markup_in_field(writer, colorize):
        class F:
            def __format__(self, spec):
                return spec

        logger.add(writer, format="{extra[f]:} {extra[f]: <blue> } {message}", colorize=colorize)
>       logger.bind(f=F()).info("Test")
E       AttributeError: 'NoneType' object has no attribute 'info'

F          = <class 'tests.test_add_option_format.test_markup_in_field.<locals>.F'>
colorize   = True
writer     = <function writer.<locals>.w at 0x7fac0b53f1c0>

tests/test_add_option_format.py:78: AttributeError
</pre>
</details>
<h3 id="test_add_option_formatpytest_markup_in_fieldfalse">test_add_option_format.py::test_markup_in_field[False]</h3>
<details><summary> <pre>test_add_option_format.py::test_markup_in_field[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53f5b0>, colorize = False

    @pytest.mark.parametrize("colorize", [True, False])
    def test_markup_in_field(writer, colorize):
        class F:
            def __format__(self, spec):
                return spec

        logger.add(writer, format="{extra[f]:} {extra[f]: <blue> } {message}", colorize=colorize)
>       logger.bind(f=F()).info("Test")
E       AttributeError: 'NoneType' object has no attribute 'info'

F          = <class 'tests.test_add_option_format.test_markup_in_field.<locals>.F'>
colorize   = False
writer     = <function writer.<locals>.w at 0x7fac0b53f5b0>

tests/test_add_option_format.py:78: AttributeError
</pre>
</details>
<h3 id="test_add_option_formatpytest_invalid_format_builtin">test_add_option_format.py::test_invalid_format_builtin</h3>
<details><summary> <pre>test_add_option_format.py::test_invalid_format_builtin</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53d480>

    def test_invalid_format_builtin(writer):
>       with pytest.raises(ValueError, match=r".* most likely a mistake"):
E       Failed: DID NOT RAISE <class 'ValueError'>

writer     = <function writer.<locals>.w at 0x7fac0b53d480>

tests/test_add_option_format.py:84: Failed
</pre>
</details>
<h3 id="test_add_option_kwargspytest_file_mode_a">test_add_option_kwargs.py::test_file_mode_a</h3>
<details><summary> <pre>test_add_option_kwargs.py::test_file_mode_a</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_mode_a0')

    def test_file_mode_a(tmp_path):
        file = tmp_path / "test.log"
        file.write_text("base\n")
        logger.add(file, format="{message}", mode="a")
        logger.debug("msg")
>       assert file.read_text() == "base\nmsg\n"
E       AssertionError: assert 'base\n' == 'base\nmsg\n'
E         
E           base
E         - msg

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_mode_a0/test.log')
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_mode_a0')

tests/test_add_option_kwargs.py:11: AssertionError
</pre>
</details>
<h3 id="test_add_option_kwargspytest_file_mode_w">test_add_option_kwargs.py::test_file_mode_w</h3>
<details><summary> <pre>test_add_option_kwargs.py::test_file_mode_w</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_mode_w0')

    def test_file_mode_w(tmp_path):
        file = tmp_path / "test.log"
        file.write_text("base\n")
        logger.add(file, format="{message}", mode="w")
        logger.debug("msg")
>       assert file.read_text() == "msg\n"
E       AssertionError: assert 'base\n' == 'msg\n'
E         
E         - msg
E         + base

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_mode_w0/test.log')
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_mode_w0')

tests/test_add_option_kwargs.py:19: AssertionError
</pre>
</details>
<h3 id="test_add_option_kwargspytest_file_auto_buffering">test_add_option_kwargs.py::test_file_auto_buffering</h3>
<details><summary> <pre>test_add_option_kwargs.py::test_file_auto_buffering</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_auto_buffering0')

    def test_file_auto_buffering(tmp_path):
        # There doesn't seem to be a reliable way to known buffer size for text files.
        # We perform a preliminary test to ensure empirically that 128 <= buffer size <= 65536.
        dummy_filepath = tmp_path / "dummy.txt"
        with open(str(dummy_filepath), buffering=-1, mode="w") as dummy_file:
            dummy_file.write("." * 127)
            if dummy_filepath.read_text() != "":
                pytest.skip("Size buffer for text files is too small.")
            dummy_file.write("." * (65536 - 127))
            if dummy_filepath.read_text() == "":
                pytest.skip("Size buffer for text files is too big.")

        filepath = tmp_path / "test.log"
        logger.add(filepath, format="{message}", buffering=-1)
        logger.debug("A short message.")
>       assert filepath.read_text() == ""

dummy_file = <_io.TextIOWrapper name='/tmp/pytest-of-root/pytest-0/test_file_auto_buffering0/dummy.txt' mode='w' encoding='UTF-8'>
dummy_filepath = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_auto_buffering0/dummy.txt')
filepath   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_auto_buffering0/test.log')
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_auto_buffering0')

tests/test_add_option_kwargs.py:37: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_auto_buffering0/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_auto_buffering0/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_auto_buffering0/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_auto_buffering0/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_add_option_kwargspytest_file_line_buffering">test_add_option_kwargs.py::test_file_line_buffering</h3>
<details><summary> <pre>test_add_option_kwargs.py::test_file_line_buffering</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_line_buffering0')

    def test_file_line_buffering(tmp_path):
        filepath = tmp_path / "test.log"
        logger.add(filepath, format=lambda _: "{message}", buffering=1)
        logger.debug("Without newline")
>       assert filepath.read_text() == ""

filepath   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_line_buffering0/test.log')
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_line_buffering0')

tests/test_add_option_kwargs.py:46: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_line_buffering0/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_line_buffering0/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_line_buffering0/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_line_buffering0/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_add_option_kwargspytest_invalid_function_kwargs">test_add_option_kwargs.py::test_invalid_function_kwargs</h3>
<details><summary> <pre>test_add_option_kwargs.py::test_invalid_function_kwargs</pre></summary><pre>
def test_invalid_function_kwargs():
        def function(message):
            pass

>       with pytest.raises(TypeError, match=r"add\(\) got an unexpected keyword argument"):
E       Failed: DID NOT RAISE <class 'TypeError'>

function   = <function test_invalid_function_kwargs.<locals>.function at 0x7fac0b752200>

tests/test_add_option_kwargs.py:55: Failed
</pre>
</details>
<h3 id="test_add_option_kwargspytest_invalid_file_object_kwargs">test_add_option_kwargs.py::test_invalid_file_object_kwargs</h3>
<details><summary> <pre>test_add_option_kwargs.py::test_invalid_file_object_kwargs</pre></summary><pre>
def test_invalid_file_object_kwargs():
        class Writer:
            def __init__(self):
                self.out = ""

            def write(self, m):
                pass

        writer = Writer()

>       with pytest.raises(TypeError, match=r"add\(\) got an unexpected keyword argument"):
E       Failed: DID NOT RAISE <class 'TypeError'>

Writer     = <class 'tests.test_add_option_kwargs.test_invalid_file_object_kwargs.<locals>.Writer'>
writer     = <tests.test_add_option_kwargs.test_invalid_file_object_kwargs.<locals>.Writer object at 0x7fac0b5505e0>

tests/test_add_option_kwargs.py:69: Failed
</pre>
</details>
<h3 id="test_add_option_kwargspytest_invalid_file_kwargs">test_add_option_kwargs.py::test_invalid_file_kwargs</h3>
<details><summary> <pre>test_add_option_kwargs.py::test_invalid_file_kwargs</pre></summary><pre>
def test_invalid_file_kwargs():
>       with pytest.raises(TypeError, match=r".*keyword argument;*"):
E       Failed: DID NOT RAISE <class 'TypeError'>


tests/test_add_option_kwargs.py:74: Failed
</pre>
</details>
<h3 id="test_add_option_kwargspytest_invalid_coroutine_kwargs">test_add_option_kwargs.py::test_invalid_coroutine_kwargs</h3>
<details><summary> <pre>test_add_option_kwargs.py::test_invalid_coroutine_kwargs</pre></summary><pre>
def test_invalid_coroutine_kwargs():
        async def foo():
            pass

>       with pytest.raises(TypeError, match=r"add\(\) got an unexpected keyword argument"):
E       Failed: DID NOT RAISE <class 'TypeError'>

foo        = <function test_invalid_coroutine_kwargs.<locals>.foo at 0x7fac0b7527a0>

tests/test_add_option_kwargs.py:82: Failed
</pre>
</details>
<h3 id="test_add_option_levelpytest_level_low_enough0">test_add_option_level.py::test_level_low_enough[0]</h3>
<details><summary> <pre>test_add_option_level.py::test_level_low_enough[0]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53d750>, level = 0

    @pytest.mark.parametrize("level", [0, "TRACE", "INFO", 20])
    def test_level_low_enough(writer, level):
        logger.add(writer, level=level, format="{message}")
        logger.info("Test level")
>       assert writer.read() == "Test level\n"
E       AssertionError: assert '' == 'Test level\n'
E         
E         - Test level

level      = 0
writer     = <function writer.<locals>.w at 0x7fac0b53d750>

tests/test_add_option_level.py:10: AssertionError
</pre>
</details>
<h3 id="test_add_option_levelpytest_level_low_enoughtrace">test_add_option_level.py::test_level_low_enough[TRACE]</h3>
<details><summary> <pre>test_add_option_level.py::test_level_low_enough[TRACE]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53ee60>, level = 'TRACE'

    @pytest.mark.parametrize("level", [0, "TRACE", "INFO", 20])
    def test_level_low_enough(writer, level):
        logger.add(writer, level=level, format="{message}")
        logger.info("Test level")
>       assert writer.read() == "Test level\n"
E       AssertionError: assert '' == 'Test level\n'
E         
E         - Test level

level      = 'TRACE'
writer     = <function writer.<locals>.w at 0x7fac0b53ee60>

tests/test_add_option_level.py:10: AssertionError
</pre>
</details>
<h3 id="test_add_option_levelpytest_level_low_enoughinfo">test_add_option_level.py::test_level_low_enough[INFO]</h3>
<details><summary> <pre>test_add_option_level.py::test_level_low_enough[INFO]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b1fd2d0>, level = 'INFO'

    @pytest.mark.parametrize("level", [0, "TRACE", "INFO", 20])
    def test_level_low_enough(writer, level):
        logger.add(writer, level=level, format="{message}")
        logger.info("Test level")
>       assert writer.read() == "Test level\n"
E       AssertionError: assert '' == 'Test level\n'
E         
E         - Test level

level      = 'INFO'
writer     = <function writer.<locals>.w at 0x7fac0b1fd2d0>

tests/test_add_option_level.py:10: AssertionError
</pre>
</details>
<h3 id="test_add_option_levelpytest_level_low_enough20">test_add_option_level.py::test_level_low_enough[20]</h3>
<details><summary> <pre>test_add_option_level.py::test_level_low_enough[20]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53cca0>, level = 20

    @pytest.mark.parametrize("level", [0, "TRACE", "INFO", 20])
    def test_level_low_enough(writer, level):
        logger.add(writer, level=level, format="{message}")
        logger.info("Test level")
>       assert writer.read() == "Test level\n"
E       AssertionError: assert '' == 'Test level\n'
E         
E         - Test level

level      = 20
writer     = <function writer.<locals>.w at 0x7fac0b53cca0>

tests/test_add_option_level.py:10: AssertionError
</pre>
</details>
<h3 id="test_add_option_levelpytest_invalid_level34">test_add_option_level.py::test_invalid_level[3.4]</h3>
<details><summary> <pre>test_add_option_level.py::test_invalid_level[3.4]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b1fd3f0>, level = 3.4

    @pytest.mark.parametrize("level", [3.4, object()])
    def test_invalid_level(writer, level):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

level      = 3.4
writer     = <function writer.<locals>.w at 0x7fac0b1fd3f0>

tests/test_add_option_level.py:22: Failed
</pre>
</details>
<h3 id="test_add_option_levelpytest_invalid_levellevel1">test_add_option_level.py::test_invalid_level[level1]</h3>
<details><summary> <pre>test_add_option_level.py::test_invalid_level[level1]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b1fc8b0>
level = <object object at 0x7fac0db8ab90>

    @pytest.mark.parametrize("level", [3.4, object()])
    def test_invalid_level(writer, level):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

level      = <object object at 0x7fac0db8ab90>
writer     = <function writer.<locals>.w at 0x7fac0b1fc8b0>

tests/test_add_option_level.py:22: Failed
</pre>
</details>
<h3 id="test_add_option_levelpytest_unknown_levelfoo">test_add_option_level.py::test_unknown_level[foo]</h3>
<details><summary> <pre>test_add_option_level.py::test_unknown_level[foo]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53ecb0>, level = 'foo'

    @pytest.mark.parametrize("level", ["foo", -1])
    def test_unknown_level(writer, level):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

level      = 'foo'
writer     = <function writer.<locals>.w at 0x7fac0b53ecb0>

tests/test_add_option_level.py:28: Failed
</pre>
</details>
<h3 id="test_add_option_levelpytest_unknown_level-1">test_add_option_level.py::test_unknown_level[-1]</h3>
<details><summary> <pre>test_add_option_level.py::test_unknown_level[-1]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0b53d6c0>, level = -1

    @pytest.mark.parametrize("level", ["foo", -1])
    def test_unknown_level(writer, level):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

level      = -1
writer     = <function writer.<locals>.w at 0x7fac0b53d6c0>

tests/test_add_option_level.py:28: Failed
</pre>
</details>
<h3 id="test_add_option_serializepytest_serialize">test_add_option_serialize.py::test_serialize</h3>
<details><summary> <pre>test_add_option_serialize.py::test_serialize</pre></summary><pre>
def test_serialize():
        sink = JsonSink()
        logger.add(sink, format="{level} {message}", serialize=True)
        logger.debug("Test")
>       assert sink.json["text"] == "DEBUG Test\n"
E       TypeError: 'NoneType' object is not subscriptable

sink       = <tests.test_add_option_serialize.JsonSink object at 0x7fac0b745b10>

tests/test_add_option_serialize.py:24: TypeError
</pre>
</details>
<h3 id="test_add_option_serializepytest_serialize_non_ascii_characters">test_add_option_serialize.py::test_serialize_non_ascii_characters</h3>
<details><summary> <pre>test_add_option_serialize.py::test_serialize_non_ascii_characters</pre></summary><pre>
def test_serialize_non_ascii_characters():
        sink = JsonSink()
        logger.add(sink, format="{level.icon} {message}", serialize=True)
        logger.debug("")
>       assert re.search(r'"message": "([^\"]+)"', sink.message).group(1) == ""

sink       = <tests.test_add_option_serialize.JsonSink object at 0x7fac0b538b80>

tests/test_add_option_serialize.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

pattern = '"message": "([^\\"]+)"', string = None, flags = 0

    def search(pattern, string, flags=0):
        """Scan through string looking for a match to the pattern, returning
        a Match object, or None if no match was found."""
>       return _compile(pattern, flags).search(string)
E       TypeError: expected string or bytes-like object

flags      = 0
pattern    = '"message": "([^\\"]+)"'
string     = None

/usr/lib/python3.10/re.py:200: TypeError
</pre>
</details>
<h3 id="test_add_option_serializepytest_serialize_exception">test_add_option_serialize.py::test_serialize_exception</h3>
<details><summary> <pre>test_add_option_serialize.py::test_serialize_exception</pre></summary><pre>
def test_serialize_exception():
        sink = JsonSink()
        logger.add(sink, format="{message}", serialize=True, catch=False)

        try:
            1 / 0  # noqa: B018
        except ZeroDivisionError:
            logger.exception("Error")

>       lines = sink.json["text"].splitlines()
E       TypeError: 'NoneType' object is not subscriptable

sink       = <tests.test_add_option_serialize.JsonSink object at 0x7fac0b552a40>

tests/test_add_option_serialize.py:49: TypeError
</pre>
</details>
<h3 id="test_add_option_serializepytest_serialize_exception_without_context">test_add_option_serialize.py::test_serialize_exception_without_context</h3>
<details><summary> <pre>test_add_option_serialize.py::test_serialize_exception_without_context</pre></summary><pre>
def test_serialize_exception_without_context():
        sink = JsonSink()
        logger.add(sink, format="{message}", serialize=True, catch=False)

        logger.exception("No Error")

>       lines = sink.json["text"].splitlines()
E       TypeError: 'NoneType' object is not subscriptable

sink       = <tests.test_add_option_serialize.JsonSink object at 0x7fac0b747be0>

tests/test_add_option_serialize.py:66: TypeError
</pre>
</details>
<h3 id="test_add_option_serializepytest_serialize_exception_none_tuple">test_add_option_serialize.py::test_serialize_exception_none_tuple</h3>
<details><summary> <pre>test_add_option_serialize.py::test_serialize_exception_none_tuple</pre></summary><pre>
def test_serialize_exception_none_tuple():
        sink = JsonSink()
        logger.add(sink, format="{message}", serialize=True, catch=False)

>       logger.opt(exception=(None, None, None)).error("No Error")
E       AttributeError: 'NoneType' object has no attribute 'error'

sink       = <tests.test_add_option_serialize.JsonSink object at 0x7fac0b552b00>

tests/test_add_option_serialize.py:81: AttributeError
</pre>
</details>
<h3 id="test_add_option_serializepytest_serialize_exception_instance">test_add_option_serialize.py::test_serialize_exception_instance</h3>
<details><summary> <pre>test_add_option_serialize.py::test_serialize_exception_instance</pre></summary><pre>
def test_serialize_exception_instance():
        sink = JsonSink()
        logger.add(sink, format="{message}", serialize=True, catch=False)

>       logger.opt(exception=ZeroDivisionError("Oops")).error("Failure")
E       AttributeError: 'NoneType' object has no attribute 'error'

sink       = <tests.test_add_option_serialize.JsonSink object at 0x7fac0b5b7eb0>

tests/test_add_option_serialize.py:98: AttributeError
</pre>
</details>
<h3 id="test_add_option_serializepytest_serialize_with_catch_decorator">test_add_option_serialize.py::test_serialize_with_catch_decorator</h3>
<details><summary> <pre>test_add_option_serialize.py::test_serialize_with_catch_decorator</pre></summary><pre>
def test_serialize_with_catch_decorator():
        sink = JsonSink()
        logger.add(sink, format="{message}", serialize=True, catch=False)

        @logger.catch
        def foo():
            1 / 0  # noqa: B018

>       foo()
E       TypeError: 'NoneType' object is not callable

foo        = None
sink       = <tests.test_add_option_serialize.JsonSink object at 0x7fac0b5b50c0>

tests/test_add_option_serialize.py:119: TypeError
</pre>
</details>
<h3 id="test_add_option_serializepytest_serialize_with_record_option">test_add_option_serialize.py::test_serialize_with_record_option</h3>
<details><summary> <pre>test_add_option_serialize.py::test_serialize_with_record_option</pre></summary><pre>
def test_serialize_with_record_option():
        sink = JsonSink()
        logger.add(sink, format="{message}", serialize=True, catch=False)

>       logger.opt(record=True).info("Test", foo=123)
E       AttributeError: 'NoneType' object has no attribute 'info'

sink       = <tests.test_add_option_serialize.JsonSink object at 0x7fac0b978040>

tests/test_add_option_serialize.py:131: AttributeError
</pre>
</details>
<h3 id="test_add_option_serializepytest_serialize_not_serializable">test_add_option_serialize.py::test_serialize_not_serializable</h3>
<details><summary> <pre>test_add_option_serialize.py::test_serialize_not_serializable</pre></summary><pre>
def test_serialize_not_serializable():
        sink = JsonSink()
        logger.add(sink, format="{message}", catch=False, serialize=True)
        not_serializable = object()
>       logger.bind(not_serializable=not_serializable).debug("Test")
E       AttributeError: 'NoneType' object has no attribute 'debug'

not_serializable = <object object at 0x7fac0bb297c0>
sink       = <tests.test_add_option_serialize.JsonSink object at 0x7fac0b079ae0>

tests/test_add_option_serialize.py:141: AttributeError
</pre>
</details>
<h3 id="test_add_sinkspytest_stdout_sink1">test_add_sinks.py::test_stdout_sink[1]</h3>
<details><summary> <pre>test_add_sinks.py::test_stdout_sink[1]</pre></summary><pre>
rep = 1, capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b1062f0>

    @repetitions
    def test_stdout_sink(rep, capsys):
        log(sys.stdout, rep)
        out, err = capsys.readouterr()
>       assert out == expected * rep
E       AssertionError: assert '' == 'test message\n'
E         
E         - test message

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b1062f0>
err        = ''
out        = ''
rep        = 1

tests/test_add_sinks.py:40: AssertionError
</pre>
</details>
<h3 id="test_add_sinkspytest_stdout_sink2">test_add_sinks.py::test_stdout_sink[2]</h3>
<details><summary> <pre>test_add_sinks.py::test_stdout_sink[2]</pre></summary><pre>
rep = 2, capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b18b490>

    @repetitions
    def test_stdout_sink(rep, capsys):
        log(sys.stdout, rep)
        out, err = capsys.readouterr()
>       assert out == expected * rep
E       AssertionError: assert '' == 'test message\ntest message\n'
E         
E         - test message
E         - test message

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b18b490>
err        = ''
out        = ''
rep        = 2

tests/test_add_sinks.py:40: AssertionError
</pre>
</details>
<h3 id="test_add_sinkspytest_stderr_sink1">test_add_sinks.py::test_stderr_sink[1]</h3>
<details><summary> <pre>test_add_sinks.py::test_stderr_sink[1]</pre></summary><pre>
rep = 1, capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b744250>

    @repetitions
    def test_stderr_sink(rep, capsys):
        log(sys.stderr, rep)
        out, err = capsys.readouterr()
        assert out == ""
>       assert err == expected * rep
E       AssertionError: assert '' == 'test message\n'
E         
E         - test message

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b744250>
err        = ''
out        = ''
rep        = 1

tests/test_add_sinks.py:49: AssertionError
</pre>
</details>
<h3 id="test_add_sinkspytest_stderr_sink2">test_add_sinks.py::test_stderr_sink[2]</h3>
<details><summary> <pre>test_add_sinks.py::test_stderr_sink[2]</pre></summary><pre>
rep = 2, capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b9787f0>

    @repetitions
    def test_stderr_sink(rep, capsys):
        log(sys.stderr, rep)
        out, err = capsys.readouterr()
        assert out == ""
>       assert err == expected * rep
E       AssertionError: assert '' == 'test message\ntest message\n'
E         
E         - test message
E         - test message

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b9787f0>
err        = ''
out        = ''
rep        = 2

tests/test_add_sinks.py:49: AssertionError
</pre>
</details>
<h3 id="test_add_sinkspytest_file_sinkstr-0">test_add_sinks.py::test_file_sink[str-0]</h3>
<details><summary> <pre>test_add_sinks.py::test_file_sink[str-0]</pre></summary><pre>
rep = 0, sink_from_path = <class 'str'>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_str_0_0')

    @repetitions
    @pytest.mark.parametrize(
        "sink_from_path",
        [str, pathlib.Path, lambda path: open(path, "a"), lambda path: pathlib.Path(path).open("a")],
    )
    def test_file_sink(rep, sink_from_path, tmp_path):
        file = tmp_path / "test.log"
        sink = sink_from_path(str(file))
        log(sink, rep)
>       assert file.read_text() == expected * rep

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_str_0_0/test.log')
rep        = 0
sink       = '/tmp/pytest-of-root/pytest-0/test_file_sink_str_0_0/test.log'
sink_from_path = <class 'str'>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_str_0_0')

tests/test_add_sinks.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_str_0_0/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_str_0_0/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_sink_str_0_0/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_str_0_0/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_add_sinkspytest_file_sinkstr-1">test_add_sinks.py::test_file_sink[str-1]</h3>
<details><summary> <pre>test_add_sinks.py::test_file_sink[str-1]</pre></summary><pre>
rep = 1, sink_from_path = <class 'str'>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_str_1_0')

    @repetitions
    @pytest.mark.parametrize(
        "sink_from_path",
        [str, pathlib.Path, lambda path: open(path, "a"), lambda path: pathlib.Path(path).open("a")],
    )
    def test_file_sink(rep, sink_from_path, tmp_path):
        file = tmp_path / "test.log"
        sink = sink_from_path(str(file))
        log(sink, rep)
>       assert file.read_text() == expected * rep

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_str_1_0/test.log')
rep        = 1
sink       = '/tmp/pytest-of-root/pytest-0/test_file_sink_str_1_0/test.log'
sink_from_path = <class 'str'>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_str_1_0')

tests/test_add_sinks.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_str_1_0/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_str_1_0/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_sink_str_1_0/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_str_1_0/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_add_sinkspytest_file_sinkstr-2">test_add_sinks.py::test_file_sink[str-2]</h3>
<details><summary> <pre>test_add_sinks.py::test_file_sink[str-2]</pre></summary><pre>
rep = 2, sink_from_path = <class 'str'>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_str_2_0')

    @repetitions
    @pytest.mark.parametrize(
        "sink_from_path",
        [str, pathlib.Path, lambda path: open(path, "a"), lambda path: pathlib.Path(path).open("a")],
    )
    def test_file_sink(rep, sink_from_path, tmp_path):
        file = tmp_path / "test.log"
        sink = sink_from_path(str(file))
        log(sink, rep)
>       assert file.read_text() == expected * rep

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_str_2_0/test.log')
rep        = 2
sink       = '/tmp/pytest-of-root/pytest-0/test_file_sink_str_2_0/test.log'
sink_from_path = <class 'str'>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_str_2_0')

tests/test_add_sinks.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_str_2_0/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_str_2_0/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_sink_str_2_0/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_str_2_0/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_add_sinkspytest_file_sinkpath-0">test_add_sinks.py::test_file_sink[Path-0]</h3>
<details><summary> <pre>test_add_sinks.py::test_file_sink[Path-0]</pre></summary><pre>
rep = 0, sink_from_path = <class 'pathlib.Path'>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_Path_0_0')

    @repetitions
    @pytest.mark.parametrize(
        "sink_from_path",
        [str, pathlib.Path, lambda path: open(path, "a"), lambda path: pathlib.Path(path).open("a")],
    )
    def test_file_sink(rep, sink_from_path, tmp_path):
        file = tmp_path / "test.log"
        sink = sink_from_path(str(file))
        log(sink, rep)
>       assert file.read_text() == expected * rep

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_Path_0_0/test.log')
rep        = 0
sink       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_Path_0_0/test.log')
sink_from_path = <class 'pathlib.Path'>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_Path_0_0')

tests/test_add_sinks.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_Path_0_0/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_Path_0_0/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_sink_Path_0_0/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_Path_0_0/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_add_sinkspytest_file_sinkpath-1">test_add_sinks.py::test_file_sink[Path-1]</h3>
<details><summary> <pre>test_add_sinks.py::test_file_sink[Path-1]</pre></summary><pre>
rep = 1, sink_from_path = <class 'pathlib.Path'>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_Path_1_0')

    @repetitions
    @pytest.mark.parametrize(
        "sink_from_path",
        [str, pathlib.Path, lambda path: open(path, "a"), lambda path: pathlib.Path(path).open("a")],
    )
    def test_file_sink(rep, sink_from_path, tmp_path):
        file = tmp_path / "test.log"
        sink = sink_from_path(str(file))
        log(sink, rep)
>       assert file.read_text() == expected * rep

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_Path_1_0/test.log')
rep        = 1
sink       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_Path_1_0/test.log')
sink_from_path = <class 'pathlib.Path'>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_Path_1_0')

tests/test_add_sinks.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_Path_1_0/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_Path_1_0/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_sink_Path_1_0/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_Path_1_0/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_add_sinkspytest_file_sinkpath-2">test_add_sinks.py::test_file_sink[Path-2]</h3>
<details><summary> <pre>test_add_sinks.py::test_file_sink[Path-2]</pre></summary><pre>
rep = 2, sink_from_path = <class 'pathlib.Path'>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_Path_2_0')

    @repetitions
    @pytest.mark.parametrize(
        "sink_from_path",
        [str, pathlib.Path, lambda path: open(path, "a"), lambda path: pathlib.Path(path).open("a")],
    )
    def test_file_sink(rep, sink_from_path, tmp_path):
        file = tmp_path / "test.log"
        sink = sink_from_path(str(file))
        log(sink, rep)
>       assert file.read_text() == expected * rep

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_Path_2_0/test.log')
rep        = 2
sink       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_Path_2_0/test.log')
sink_from_path = <class 'pathlib.Path'>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_Path_2_0')

tests/test_add_sinks.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_Path_2_0/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_Path_2_0/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_sink_Path_2_0/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_Path_2_0/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_add_sinkspytest_file_sink0-1">test_add_sinks.py::test_file_sink[<lambda>0-1]</h3>
<details><summary> <pre>test_add_sinks.py::test_file_sink[<lambda>0-1]</pre></summary><pre>
rep = 1, sink_from_path = <function <lambda> at 0x7fac0bf1a050>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink__lambda_0_1_0')

    @repetitions
    @pytest.mark.parametrize(
        "sink_from_path",
        [str, pathlib.Path, lambda path: open(path, "a"), lambda path: pathlib.Path(path).open("a")],
    )
    def test_file_sink(rep, sink_from_path, tmp_path):
        file = tmp_path / "test.log"
        sink = sink_from_path(str(file))
        log(sink, rep)
>       assert file.read_text() == expected * rep
E       AssertionError: assert '' == 'test message\n'
E         
E         - test message

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink__lambda_0_1_0/test.log')
rep        = 1
sink       = <_io.TextIOWrapper name='/tmp/pytest-of-root/pytest-0/test_file_sink__lambda_0_1_0/test.log' mode='a' encoding='UTF-8'>
sink_from_path = <function <lambda> at 0x7fac0bf1a050>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink__lambda_0_1_0')

tests/test_add_sinks.py:66: AssertionError
</pre>
</details>
<h3 id="test_add_sinkspytest_file_sink0-2">test_add_sinks.py::test_file_sink[<lambda>0-2]</h3>
<details><summary> <pre>test_add_sinks.py::test_file_sink[<lambda>0-2]</pre></summary><pre>
rep = 2, sink_from_path = <function <lambda> at 0x7fac0bf1a050>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink__lambda_0_2_0')

    @repetitions
    @pytest.mark.parametrize(
        "sink_from_path",
        [str, pathlib.Path, lambda path: open(path, "a"), lambda path: pathlib.Path(path).open("a")],
    )
    def test_file_sink(rep, sink_from_path, tmp_path):
        file = tmp_path / "test.log"
        sink = sink_from_path(str(file))
        log(sink, rep)
>       assert file.read_text() == expected * rep
E       AssertionError: assert '' == 'test message\ntest message\n'
E         
E         - test message
E         - test message

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink__lambda_0_2_0/test.log')
rep        = 2
sink       = <_io.TextIOWrapper name='/tmp/pytest-of-root/pytest-0/test_file_sink__lambda_0_2_0/test.log' mode='a' encoding='UTF-8'>
sink_from_path = <function <lambda> at 0x7fac0bf1a050>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink__lambda_0_2_0')

tests/test_add_sinks.py:66: AssertionError
</pre>
</details>
<h3 id="test_add_sinkspytest_file_sink1-1">test_add_sinks.py::test_file_sink[<lambda>1-1]</h3>
<details><summary> <pre>test_add_sinks.py::test_file_sink[<lambda>1-1]</pre></summary><pre>
rep = 1, sink_from_path = <function <lambda> at 0x7fac0bf1a0e0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink__lambda_1_1_0')

    @repetitions
    @pytest.mark.parametrize(
        "sink_from_path",
        [str, pathlib.Path, lambda path: open(path, "a"), lambda path: pathlib.Path(path).open("a")],
    )
    def test_file_sink(rep, sink_from_path, tmp_path):
        file = tmp_path / "test.log"
        sink = sink_from_path(str(file))
        log(sink, rep)
>       assert file.read_text() == expected * rep
E       AssertionError: assert '' == 'test message\n'
E         
E         - test message

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink__lambda_1_1_0/test.log')
rep        = 1
sink       = <_io.TextIOWrapper name='/tmp/pytest-of-root/pytest-0/test_file_sink__lambda_1_1_0/test.log' mode='a' encoding='UTF-8'>
sink_from_path = <function <lambda> at 0x7fac0bf1a0e0>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink__lambda_1_1_0')

tests/test_add_sinks.py:66: AssertionError
</pre>
</details>
<h3 id="test_add_sinkspytest_file_sink1-2">test_add_sinks.py::test_file_sink[<lambda>1-2]</h3>
<details><summary> <pre>test_add_sinks.py::test_file_sink[<lambda>1-2]</pre></summary><pre>
rep = 2, sink_from_path = <function <lambda> at 0x7fac0bf1a0e0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink__lambda_1_2_0')

    @repetitions
    @pytest.mark.parametrize(
        "sink_from_path",
        [str, pathlib.Path, lambda path: open(path, "a"), lambda path: pathlib.Path(path).open("a")],
    )
    def test_file_sink(rep, sink_from_path, tmp_path):
        file = tmp_path / "test.log"
        sink = sink_from_path(str(file))
        log(sink, rep)
>       assert file.read_text() == expected * rep
E       AssertionError: assert '' == 'test message\ntest message\n'
E         
E         - test message
E         - test message

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink__lambda_1_2_0/test.log')
rep        = 2
sink       = <_io.TextIOWrapper name='/tmp/pytest-of-root/pytest-0/test_file_sink__lambda_1_2_0/test.log' mode='a' encoding='UTF-8'>
sink_from_path = <function <lambda> at 0x7fac0bf1a0e0>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink__lambda_1_2_0')

tests/test_add_sinks.py:66: AssertionError
</pre>
</details>
<h3 id="test_add_sinkspytest_file_sink_folder_creation0">test_add_sinks.py::test_file_sink_folder_creation[0]</h3>
<details><summary> <pre>test_add_sinks.py::test_file_sink_folder_creation[0]</pre></summary><pre>
rep = 0
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_folder_creation0')

    @repetitions
    def test_file_sink_folder_creation(rep, tmp_path):
        file = tmp_path.joinpath("some", "sub", "folder", "not", "existing", "test.log")
        log(file, rep)
>       assert file.read_text() == expected * rep

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_folder_creation0/some/sub/folder/not/existing/test.log')
rep        = 0
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_folder_creation0')

tests/test_add_sinks.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_folder_creation0/some/sub/folder/not/existing/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_folder_creation0/some/sub/folder/not/existing/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_sink_folder_creation0/some/sub/folder/not/existing/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_folder_creation0/some/sub/folder/not/existing/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_add_sinkspytest_file_sink_folder_creation1">test_add_sinks.py::test_file_sink_folder_creation[1]</h3>
<details><summary> <pre>test_add_sinks.py::test_file_sink_folder_creation[1]</pre></summary><pre>
rep = 1
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_folder_creation1')

    @repetitions
    def test_file_sink_folder_creation(rep, tmp_path):
        file = tmp_path.joinpath("some", "sub", "folder", "not", "existing", "test.log")
        log(file, rep)
>       assert file.read_text() == expected * rep

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_folder_creation1/some/sub/folder/not/existing/test.log')
rep        = 1
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_folder_creation1')

tests/test_add_sinks.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_folder_creation1/some/sub/folder/not/existing/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_folder_creation1/some/sub/folder/not/existing/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_sink_folder_creation1/some/sub/folder/not/existing/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_folder_creation1/some/sub/folder/not/existing/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_add_sinkspytest_file_sink_folder_creation2">test_add_sinks.py::test_file_sink_folder_creation[2]</h3>
<details><summary> <pre>test_add_sinks.py::test_file_sink_folder_creation[2]</pre></summary><pre>
rep = 2
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_folder_creation2')

    @repetitions
    def test_file_sink_folder_creation(rep, tmp_path):
        file = tmp_path.joinpath("some", "sub", "folder", "not", "existing", "test.log")
        log(file, rep)
>       assert file.read_text() == expected * rep

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_folder_creation2/some/sub/folder/not/existing/test.log')
rep        = 2
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_folder_creation2')

tests/test_add_sinks.py:73: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_folder_creation2/some/sub/folder/not/existing/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_folder_creation2/some/sub/folder/not/existing/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_sink_folder_creation2/some/sub/folder/not/existing/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_folder_creation2/some/sub/folder/not/existing/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_add_sinkspytest_function_sink1">test_add_sinks.py::test_function_sink[1]</h3>
<details><summary> <pre>test_add_sinks.py::test_function_sink[1]</pre></summary><pre>
rep = 1

    @repetitions
    def test_function_sink(rep):
        a = []

        def func(log_message):
            a.append(log_message)

        log(func, rep)
>       assert a == [expected] * rep
E       AssertionError: assert [] == ['test message\n']
E         
E         Right contains one more item: 'test message\n'
E         Use -v to get more diff

a          = []
func       = <function test_function_sink.<locals>.func at 0x7fac0b53e9e0>
rep        = 1

tests/test_add_sinks.py:84: AssertionError
</pre>
</details>
<h3 id="test_add_sinkspytest_function_sink2">test_add_sinks.py::test_function_sink[2]</h3>
<details><summary> <pre>test_add_sinks.py::test_function_sink[2]</pre></summary><pre>
rep = 2

    @repetitions
    def test_function_sink(rep):
        a = []

        def func(log_message):
            a.append(log_message)

        log(func, rep)
>       assert a == [expected] * rep
E       AssertionError: assert [] == ['test messag...st message\n']
E         
E         Right contains 2 more items, first extra item: 'test message\n'
E         Use -v to get more diff

a          = []
func       = <function test_function_sink.<locals>.func at 0x7fac0b1fd000>
rep        = 2

tests/test_add_sinks.py:84: AssertionError
</pre>
</details>
<h3 id="test_add_sinkspytest_coroutine_sink0">test_add_sinks.py::test_coroutine_sink[0]</h3>
<details><summary> <pre>test_add_sinks.py::test_coroutine_sink[0]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0cf721d0>, rep = 0

    @repetitions
    def test_coroutine_sink(capsys, rep):
        async def async_print(msg):
            await asyncio.sleep(0.01)
            print(msg, end="")
            await asyncio.sleep(0.01)

>       asyncio.run(async_log(async_print, rep))

async_print = <function test_coroutine_sink.<locals>.async_print at 0x7fac0b1fdea0>
capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0cf721d0>
rep        = 0

tests/test_add_sinks.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object async_log at 0x7fac0b0feb20>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-1' coro=<async_log() done, defined at /testbed/tests/test_add_sinks.py:26> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

sink = <function test_coroutine_sink.<locals>.async_print at 0x7fac0b1fdea0>
rep = 0

    async def async_log(sink, rep=1):
        logger.debug("This shouldn't be printed.")
        i = logger.add(sink, format="{message}")
        for _ in range(rep):
            logger.debug(message)
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression

i          = None
rep        = 0
sink       = <function test_coroutine_sink.<locals>.async_print at 0x7fac0b1fdea0>

tests/test_add_sinks.py:31: TypeError
</pre>
</details>
<h3 id="test_add_sinkspytest_coroutine_sink1">test_add_sinks.py::test_coroutine_sink[1]</h3>
<details><summary> <pre>test_add_sinks.py::test_coroutine_sink[1]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b123af0>, rep = 1

    @repetitions
    def test_coroutine_sink(capsys, rep):
        async def async_print(msg):
            await asyncio.sleep(0.01)
            print(msg, end="")
            await asyncio.sleep(0.01)

>       asyncio.run(async_log(async_print, rep))

async_print = <function test_coroutine_sink.<locals>.async_print at 0x7fac0b1fdc60>
capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b123af0>
rep        = 1

tests/test_add_sinks.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object async_log at 0x7fac0b074ba0>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-4' coro=<async_log() done, defined at /testbed/tests/test_add_sinks.py:26> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

sink = <function test_coroutine_sink.<locals>.async_print at 0x7fac0b1fdc60>
rep = 1

    async def async_log(sink, rep=1):
        logger.debug("This shouldn't be printed.")
        i = logger.add(sink, format="{message}")
        for _ in range(rep):
            logger.debug(message)
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression

_          = 0
i          = None
rep        = 1
sink       = <function test_coroutine_sink.<locals>.async_print at 0x7fac0b1fdc60>

tests/test_add_sinks.py:31: TypeError
</pre>
</details>
<h3 id="test_add_sinkspytest_coroutine_sink2">test_add_sinks.py::test_coroutine_sink[2]</h3>
<details><summary> <pre>test_add_sinks.py::test_coroutine_sink[2]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b1883a0>, rep = 2

    @repetitions
    def test_coroutine_sink(capsys, rep):
        async def async_print(msg):
            await asyncio.sleep(0.01)
            print(msg, end="")
            await asyncio.sleep(0.01)

>       asyncio.run(async_log(async_print, rep))

async_print = <function test_coroutine_sink.<locals>.async_print at 0x7fac0b1fe290>
capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b1883a0>
rep        = 2

tests/test_add_sinks.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object async_log at 0x7fac0b075230>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-7' coro=<async_log() done, defined at /testbed/tests/test_add_sinks.py:26> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

sink = <function test_coroutine_sink.<locals>.async_print at 0x7fac0b1fe290>
rep = 2

    async def async_log(sink, rep=1):
        logger.debug("This shouldn't be printed.")
        i = logger.add(sink, format="{message}")
        for _ in range(rep):
            logger.debug(message)
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression

_          = 1
i          = None
rep        = 2
sink       = <function test_coroutine_sink.<locals>.async_print at 0x7fac0b1fe290>

tests/test_add_sinks.py:31: TypeError
</pre>
</details>
<h3 id="test_add_sinkspytest_file_object_sink1">test_add_sinks.py::test_file_object_sink[1]</h3>
<details><summary> <pre>test_add_sinks.py::test_file_object_sink[1]</pre></summary><pre>
rep = 1

    @repetitions
    def test_file_object_sink(rep):
        class A:
            def __init__(self):
                self.out = ""

            def write(self, m):
                self.out += m

        a = A()
        log(a, rep)
>       assert a.out == expected * rep
E       AssertionError: assert '' == 'test message\n'
E         
E         - test message

A          = <class 'tests.test_add_sinks.test_file_object_sink.<locals>.A'>
a          = <tests.test_add_sinks.test_file_object_sink.<locals>.A object at 0x7fac0b538df0>
rep        = 1

tests/test_add_sinks.py:112: AssertionError
</pre>
</details>
<h3 id="test_add_sinkspytest_file_object_sink2">test_add_sinks.py::test_file_object_sink[2]</h3>
<details><summary> <pre>test_add_sinks.py::test_file_object_sink[2]</pre></summary><pre>
rep = 2

    @repetitions
    def test_file_object_sink(rep):
        class A:
            def __init__(self):
                self.out = ""

            def write(self, m):
                self.out += m

        a = A()
        log(a, rep)
>       assert a.out == expected * rep
E       AssertionError: assert '' == 'test message\ntest message\n'
E         
E         - test message
E         - test message

A          = <class 'tests.test_add_sinks.test_file_object_sink.<locals>.A'>
a          = <tests.test_add_sinks.test_file_object_sink.<locals>.A object at 0x7fac0b18b310>
rep        = 2

tests/test_add_sinks.py:112: AssertionError
</pre>
</details>
<h3 id="test_add_sinkspytest_standard_handler_sink1">test_add_sinks.py::test_standard_handler_sink[1]</h3>
<details><summary> <pre>test_add_sinks.py::test_standard_handler_sink[1]</pre></summary><pre>
rep = 1

    @repetitions
    def test_standard_handler_sink(rep):
        out = []

        class H(logging.Handler):
            def emit(self, record):
                out.append(record.getMessage() + "\n")

        h = H()
        log(h, rep)
>       assert out == [expected] * rep
E       AssertionError: assert [] == ['test message\n']
E         
E         Right contains one more item: 'test message\n'
E         Use -v to get more diff

H          = <class 'tests.test_add_sinks.test_standard_handler_sink.<locals>.H'>
h          = <H (NOTSET)>
out        = []
rep        = 1

tests/test_add_sinks.py:125: AssertionError
</pre>
</details>
<h3 id="test_add_sinkspytest_standard_handler_sink2">test_add_sinks.py::test_standard_handler_sink[2]</h3>
<details><summary> <pre>test_add_sinks.py::test_standard_handler_sink[2]</pre></summary><pre>
rep = 2

    @repetitions
    def test_standard_handler_sink(rep):
        out = []

        class H(logging.Handler):
            def emit(self, record):
                out.append(record.getMessage() + "\n")

        h = H()
        log(h, rep)
>       assert out == [expected] * rep
E       AssertionError: assert [] == ['test messag...st message\n']
E         
E         Right contains 2 more items, first extra item: 'test message\n'
E         Use -v to get more diff

H          = <class 'tests.test_add_sinks.test_standard_handler_sink.<locals>.H'>
h          = <H (NOTSET)>
out        = []
rep        = 2

tests/test_add_sinks.py:125: AssertionError
</pre>
</details>
<h3 id="test_add_sinkspytest_flush1">test_add_sinks.py::test_flush[1]</h3>
<details><summary> <pre>test_add_sinks.py::test_flush[1]</pre></summary><pre>
rep = 1

    @repetitions
    def test_flush(rep):
        flushed = []
        out = []

        class A:
            def write(self, m):
                out.append(m)

            def flush(self):
                flushed.append(out[-1])

        log(A(), rep)
>       assert flushed == [expected] * rep
E       AssertionError: assert [] == ['test message\n']
E         
E         Right contains one more item: 'test message\n'
E         Use -v to get more diff

A          = <class 'tests.test_add_sinks.test_flush.<locals>.A'>
flushed    = []
out        = []
rep        = 1

tests/test_add_sinks.py:141: AssertionError
</pre>
</details>
<h3 id="test_add_sinkspytest_flush2">test_add_sinks.py::test_flush[2]</h3>
<details><summary> <pre>test_add_sinks.py::test_flush[2]</pre></summary><pre>
rep = 2

    @repetitions
    def test_flush(rep):
        flushed = []
        out = []

        class A:
            def write(self, m):
                out.append(m)

            def flush(self):
                flushed.append(out[-1])

        log(A(), rep)
>       assert flushed == [expected] * rep
E       AssertionError: assert [] == ['test messag...st message\n']
E         
E         Right contains 2 more items, first extra item: 'test message\n'
E         Use -v to get more diff

A          = <class 'tests.test_add_sinks.test_flush.<locals>.A'>
flushed    = []
out        = []
rep        = 2

tests/test_add_sinks.py:141: AssertionError
</pre>
</details>
<h3 id="test_add_sinkspytest_file_sink_ascii_encoding">test_add_sinks.py::test_file_sink_ascii_encoding</h3>
<details><summary> <pre>test_add_sinks.py::test_file_sink_ascii_encoding</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_ascii_encoding0')

    def test_file_sink_ascii_encoding(tmp_path):
        file = tmp_path / "test.log"
        logger.add(file, encoding="ascii", format="{message}", errors="backslashreplace", catch=False)
        logger.info("")
        logger.remove()
>       assert file.read_text("ascii") == "\\u5929\n"

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_ascii_encoding0/test.log')
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_ascii_encoding0')

tests/test_add_sinks.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'ascii'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_ascii_encoding0/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_ascii_encoding0/test.log')
mode = 'r', buffering = -1, encoding = 'ascii', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_sink_ascii_encoding0/test.log'

buffering  = -1
encoding   = 'ascii'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_ascii_encoding0/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_add_sinkspytest_file_sink_utf8_encoding">test_add_sinks.py::test_file_sink_utf8_encoding</h3>
<details><summary> <pre>test_add_sinks.py::test_file_sink_utf8_encoding</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_utf8_encoding0')

    def test_file_sink_utf8_encoding(tmp_path):
        file = tmp_path / "test.log"
        logger.add(file, encoding="utf8", format="{message}", errors="strict", catch=False)
        logger.info("")
        logger.remove()
>       assert file.read_text("utf8") == "\n"

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_utf8_encoding0/test.log')
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_utf8_encoding0')

tests/test_add_sinks.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'utf8'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_utf8_encoding0/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_utf8_encoding0/test.log')
mode = 'r', buffering = -1, encoding = 'utf8', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_sink_utf8_encoding0/test.log'

buffering  = -1
encoding   = 'utf8'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_utf8_encoding0/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_add_sinkspytest_file_sink_default_encoding">test_add_sinks.py::test_file_sink_default_encoding</h3>
<details><summary> <pre>test_add_sinks.py::test_file_sink_default_encoding</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_default_encodin0')

    def test_file_sink_default_encoding(tmp_path):
        file = tmp_path / "test.log"
        logger.add(file, format="{message}", errors="strict", catch=False)
        logger.info("")
        logger.remove()
>       assert file.read_text("utf8") == "\n"

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_default_encodin0/test.log')
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_default_encodin0')

tests/test_add_sinks.py:165: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'utf8'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_default_encodin0/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_default_encodin0/test.log')
mode = 'r', buffering = -1, encoding = 'utf8', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_sink_default_encodin0/test.log'

buffering  = -1
encoding   = 'utf8'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_default_encodin0/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_add_sinkspytest_disabled_logger_in_sink">test_add_sinks.py::test_disabled_logger_in_sink</h3>
<details><summary> <pre>test_add_sinks.py::test_disabled_logger_in_sink</pre></summary><pre>
sink_with_logger = <class 'tests.conftest.sink_with_logger.<locals>.SinkWithLogger'>

    def test_disabled_logger_in_sink(sink_with_logger):
        sink = sink_with_logger(logger)
        logger.disable("tests.conftest")
        logger.add(sink, format="{message}")
        logger.info("Disabled test")
>       assert sink.out == "Disabled test\n"
E       AssertionError: assert '' == 'Disabled test\n'
E         
E         - Disabled test

sink       = <tests.conftest.sink_with_logger.<locals>.SinkWithLogger object at 0x7fac0b06c940>
sink_with_logger = <class 'tests.conftest.sink_with_logger.<locals>.SinkWithLogger'>

tests/test_add_sinks.py:173: AssertionError
</pre>
</details>
<h3 id="test_add_sinkspytest_custom_sink_invalid_flush123">test_add_sinks.py::test_custom_sink_invalid_flush[123]</h3>
<details><summary> <pre>test_add_sinks.py::test_custom_sink_invalid_flush[123]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b0788b0>, flush = 123

    @pytest.mark.parametrize("flush", [123, None])
    def test_custom_sink_invalid_flush(capsys, flush):
        class Sink:
            def __init__(self):
                self.flush = flush

            def write(self, message):
                print(message, end="")

        logger.add(Sink(), format="{message}")
        logger.info("Test")

        out, err = capsys.readouterr()
>       assert out == "Test\n"
E       AssertionError: assert '' == 'Test\n'
E         
E         - Test

Sink       = <class 'tests.test_add_sinks.test_custom_sink_invalid_flush.<locals>.Sink'>
capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b0788b0>
err        = ''
flush      = 123
out        = ''

tests/test_add_sinks.py:189: AssertionError
</pre>
</details>
<h3 id="test_add_sinkspytest_custom_sink_invalid_flushnone">test_add_sinks.py::test_custom_sink_invalid_flush[None]</h3>
<details><summary> <pre>test_add_sinks.py::test_custom_sink_invalid_flush[None]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0ba4d810>, flush = None

    @pytest.mark.parametrize("flush", [123, None])
    def test_custom_sink_invalid_flush(capsys, flush):
        class Sink:
            def __init__(self):
                self.flush = flush

            def write(self, message):
                print(message, end="")

        logger.add(Sink(), format="{message}")
        logger.info("Test")

        out, err = capsys.readouterr()
>       assert out == "Test\n"
E       AssertionError: assert '' == 'Test\n'
E         
E         - Test

Sink       = <class 'tests.test_add_sinks.test_custom_sink_invalid_flush.<locals>.Sink'>
capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0ba4d810>
err        = ''
flush      = None
out        = ''

tests/test_add_sinks.py:189: AssertionError
</pre>
</details>
<h3 id="test_add_sinkspytest_custom_sink_invalid_stop123">test_add_sinks.py::test_custom_sink_invalid_stop[123]</h3>
<details><summary> <pre>test_add_sinks.py::test_custom_sink_invalid_stop[123]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b0cd0c0>, stop = 123

    @pytest.mark.parametrize("stop", [123, None])
    def test_custom_sink_invalid_stop(capsys, stop):
        class Sink:
            def __init__(self):
                self.stop = stop

            def write(self, message):
                print(message, end="")

        logger.add(Sink(), format="{message}")
        logger.info("Test")
        logger.remove()

        out, err = capsys.readouterr()
>       assert out == "Test\n"
E       AssertionError: assert '' == 'Test\n'
E         
E         - Test

Sink       = <class 'tests.test_add_sinks.test_custom_sink_invalid_stop.<locals>.Sink'>
capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b0cd0c0>
err        = ''
out        = ''
stop       = 123

tests/test_add_sinks.py:207: AssertionError
</pre>
</details>
<h3 id="test_add_sinkspytest_custom_sink_invalid_stopnone">test_add_sinks.py::test_custom_sink_invalid_stop[None]</h3>
<details><summary> <pre>test_add_sinks.py::test_custom_sink_invalid_stop[None]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b058af0>, stop = None

    @pytest.mark.parametrize("stop", [123, None])
    def test_custom_sink_invalid_stop(capsys, stop):
        class Sink:
            def __init__(self):
                self.stop = stop

            def write(self, message):
                print(message, end="")

        logger.add(Sink(), format="{message}")
        logger.info("Test")
        logger.remove()

        out, err = capsys.readouterr()
>       assert out == "Test\n"
E       AssertionError: assert '' == 'Test\n'
E         
E         - Test

Sink       = <class 'tests.test_add_sinks.test_custom_sink_invalid_stop.<locals>.Sink'>
capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b058af0>
err        = ''
out        = ''
stop       = None

tests/test_add_sinks.py:207: AssertionError
</pre>
</details>
<h3 id="test_add_sinkspytest_custom_sink_invalid_complete123">test_add_sinks.py::test_custom_sink_invalid_complete[123]</h3>
<details><summary> <pre>test_add_sinks.py::test_custom_sink_invalid_complete[123]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b5b4d00>
complete = 123

    @pytest.mark.parametrize("complete", [123, None, lambda: None])
    def test_custom_sink_invalid_complete(capsys, complete):
        class Sink:
            def __init__(self):
                self.complete = complete

            def write(self, message):
                print(message, end="")

        async def worker():
            logger.info("Test")
            await logger.complete()

        logger.add(Sink(), format="{message}")
>       asyncio.run(worker())

Sink       = <class 'tests.test_add_sinks.test_custom_sink_invalid_complete.<locals>.Sink'>
capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b5b4d00>
complete   = 123
worker     = <function test_custom_sink_invalid_complete.<locals>.worker at 0x7fac0b1fdb40>

tests/test_add_sinks.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object test_custom_sink_invalid_complete.<locals>.worker at 0x7fac0b0fe730>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-10' coro=<test_custom_sink_invalid_complete.<locals>.worker() done, defined at /testbed/tests/test_add_sinks.py:220> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def worker():
        logger.info("Test")
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression


tests/test_add_sinks.py:222: TypeError
</pre>
</details>
<h3 id="test_add_sinkspytest_custom_sink_invalid_completenone">test_add_sinks.py::test_custom_sink_invalid_complete[None]</h3>
<details><summary> <pre>test_add_sinks.py::test_custom_sink_invalid_complete[None]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b550730>
complete = None

    @pytest.mark.parametrize("complete", [123, None, lambda: None])
    def test_custom_sink_invalid_complete(capsys, complete):
        class Sink:
            def __init__(self):
                self.complete = complete

            def write(self, message):
                print(message, end="")

        async def worker():
            logger.info("Test")
            await logger.complete()

        logger.add(Sink(), format="{message}")
>       asyncio.run(worker())

Sink       = <class 'tests.test_add_sinks.test_custom_sink_invalid_complete.<locals>.Sink'>
capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b550730>
complete   = None
worker     = <function test_custom_sink_invalid_complete.<locals>.worker at 0x7fac0b1feb00>

tests/test_add_sinks.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object test_custom_sink_invalid_complete.<locals>.worker at 0x7fac0b0762d0>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-13' coro=<test_custom_sink_invalid_complete.<locals>.worker() done, defined at /testbed/tests/test_add_sinks.py:220> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def worker():
        logger.info("Test")
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression


tests/test_add_sinks.py:222: TypeError
</pre>
</details>
<h3 id="test_add_sinkspytest_custom_sink_invalid_complete">test_add_sinks.py::test_custom_sink_invalid_complete[<lambda>]</h3>
<details><summary> <pre>test_add_sinks.py::test_custom_sink_invalid_complete[<lambda>]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b106770>
complete = <function <lambda> at 0x7fac0bf1a8c0>

    @pytest.mark.parametrize("complete", [123, None, lambda: None])
    def test_custom_sink_invalid_complete(capsys, complete):
        class Sink:
            def __init__(self):
                self.complete = complete

            def write(self, message):
                print(message, end="")

        async def worker():
            logger.info("Test")
            await logger.complete()

        logger.add(Sink(), format="{message}")
>       asyncio.run(worker())

Sink       = <class 'tests.test_add_sinks.test_custom_sink_invalid_complete.<locals>.Sink'>
capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b106770>
complete   = <function <lambda> at 0x7fac0bf1a8c0>
worker     = <function test_custom_sink_invalid_complete.<locals>.worker at 0x7fac0b1fd750>

tests/test_add_sinks.py:225: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object test_custom_sink_invalid_complete.<locals>.worker at 0x7fac0b0fc580>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-16' coro=<test_custom_sink_invalid_complete.<locals>.worker() done, defined at /testbed/tests/test_add_sinks.py:220> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def worker():
        logger.info("Test")
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression


tests/test_add_sinks.py:222: TypeError
</pre>
</details>
<h3 id="test_add_sinkspytest_deprecated_start_and_stop">test_add_sinks.py::test_deprecated_start_and_stop</h3>
<details><summary> <pre>test_add_sinks.py::test_deprecated_start_and_stop</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac09420280>

    def test_deprecated_start_and_stop(writer):
>       with pytest.warns(DeprecationWarning):
E       Failed: DID NOT WARN. No warnings of type (<class 'DeprecationWarning'>,) were emitted.
E        Emitted warnings: [].

i          = None
writer     = <function writer.<locals>.w at 0x7fac09420280>

tests/test_add_sinks.py:239: Failed
</pre>
</details>
<h3 id="bold-x1b1m1x1b0m">bold&gt;-\x1b[1m1\x1b[0m]</h3>
<details><summary> <pre>bold>-\x1b[1m1\x1b[0m]</pre></summary><pre>
text = '<bold>1</bold>', expected = '\x1b[1m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<bold>1</bold>", Style.BRIGHT + "1" + Style.RESET_ALL),
            ("<dim>1</dim>", Style.DIM + "1" + Style.RESET_ALL),
            ("<normal>1</normal>", Style.NORMAL + "1" + Style.RESET_ALL),
            ("<b>1</b>", Style.BRIGHT + "1" + Style.RESET_ALL),
            ("<d>1</d>", Style.DIM + "1" + Style.RESET_ALL),
            ("<n>1</n>", Style.NORMAL + "1" + Style.RESET_ALL),
        ],
    )
    def test_styles(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[1m1\x1b[0m'
text       = '<bold>1</bold>'

tests/test_ansimarkup_basic.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b0ce5f0>
        strict     = True
        strip      = False
        text       = '<bold>1</bold>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b0ce5f0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: bold, bold

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b0ce5f0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="dim-x1b2m1x1b0m">dim&gt;-\x1b[2m1\x1b[0m]</h3>
<details><summary> <pre>dim>-\x1b[2m1\x1b[0m]</pre></summary><pre>
text = '<dim>1</dim>', expected = '\x1b[2m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<bold>1</bold>", Style.BRIGHT + "1" + Style.RESET_ALL),
            ("<dim>1</dim>", Style.DIM + "1" + Style.RESET_ALL),
            ("<normal>1</normal>", Style.NORMAL + "1" + Style.RESET_ALL),
            ("<b>1</b>", Style.BRIGHT + "1" + Style.RESET_ALL),
            ("<d>1</d>", Style.DIM + "1" + Style.RESET_ALL),
            ("<n>1</n>", Style.NORMAL + "1" + Style.RESET_ALL),
        ],
    )
    def test_styles(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[2m1\x1b[0m'
text       = '<dim>1</dim>'

tests/test_ansimarkup_basic.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b0ea4d0>
        strict     = True
        strip      = False
        text       = '<dim>1</dim>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b0ea4d0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: dim, dim

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b0ea4d0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="normal-x1b22m1x1b0m">normal&gt;-\x1b[22m1\x1b[0m]</h3>
<details><summary> <pre>normal>-\x1b[22m1\x1b[0m]</pre></summary><pre>
text = '<normal>1</normal>', expected = '\x1b[22m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<bold>1</bold>", Style.BRIGHT + "1" + Style.RESET_ALL),
            ("<dim>1</dim>", Style.DIM + "1" + Style.RESET_ALL),
            ("<normal>1</normal>", Style.NORMAL + "1" + Style.RESET_ALL),
            ("<b>1</b>", Style.BRIGHT + "1" + Style.RESET_ALL),
            ("<d>1</d>", Style.DIM + "1" + Style.RESET_ALL),
            ("<n>1</n>", Style.NORMAL + "1" + Style.RESET_ALL),
        ],
    )
    def test_styles(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[22m1\x1b[0m'
text       = '<normal>1</normal>'

tests/test_ansimarkup_basic.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b745180>
        strict     = True
        strip      = False
        text       = '<normal>1</normal>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b745180>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: normal, normal

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b745180>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="b-x1b1m1x1b0m">b&gt;-\x1b[1m1\x1b[0m]</h3>
<details><summary> <pre>b>-\x1b[1m1\x1b[0m]</pre></summary><pre>
text = '<b>1</b>', expected = '\x1b[1m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<bold>1</bold>", Style.BRIGHT + "1" + Style.RESET_ALL),
            ("<dim>1</dim>", Style.DIM + "1" + Style.RESET_ALL),
            ("<normal>1</normal>", Style.NORMAL + "1" + Style.RESET_ALL),
            ("<b>1</b>", Style.BRIGHT + "1" + Style.RESET_ALL),
            ("<d>1</d>", Style.DIM + "1" + Style.RESET_ALL),
            ("<n>1</n>", Style.NORMAL + "1" + Style.RESET_ALL),
        ],
    )
    def test_styles(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[1m1\x1b[0m'
text       = '<b>1</b>'

tests/test_ansimarkup_basic.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b07ab30>
        strict     = True
        strip      = False
        text       = '<b>1</b>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b07ab30>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: b, b

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b07ab30>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="d-x1b2m1x1b0m">d&gt;-\x1b[2m1\x1b[0m]</h3>
<details><summary> <pre>d>-\x1b[2m1\x1b[0m]</pre></summary><pre>
text = '<d>1</d>', expected = '\x1b[2m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<bold>1</bold>", Style.BRIGHT + "1" + Style.RESET_ALL),
            ("<dim>1</dim>", Style.DIM + "1" + Style.RESET_ALL),
            ("<normal>1</normal>", Style.NORMAL + "1" + Style.RESET_ALL),
            ("<b>1</b>", Style.BRIGHT + "1" + Style.RESET_ALL),
            ("<d>1</d>", Style.DIM + "1" + Style.RESET_ALL),
            ("<n>1</n>", Style.NORMAL + "1" + Style.RESET_ALL),
        ],
    )
    def test_styles(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[2m1\x1b[0m'
text       = '<d>1</d>'

tests/test_ansimarkup_basic.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b120700>
        strict     = True
        strip      = False
        text       = '<d>1</d>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b120700>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: d, d

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b120700>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="n-x1b22m1x1b0m">n&gt;-\x1b[22m1\x1b[0m]</h3>
<details><summary> <pre>n>-\x1b[22m1\x1b[0m]</pre></summary><pre>
text = '<n>1</n>', expected = '\x1b[22m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<bold>1</bold>", Style.BRIGHT + "1" + Style.RESET_ALL),
            ("<dim>1</dim>", Style.DIM + "1" + Style.RESET_ALL),
            ("<normal>1</normal>", Style.NORMAL + "1" + Style.RESET_ALL),
            ("<b>1</b>", Style.BRIGHT + "1" + Style.RESET_ALL),
            ("<d>1</d>", Style.DIM + "1" + Style.RESET_ALL),
            ("<n>1</n>", Style.NORMAL + "1" + Style.RESET_ALL),
        ],
    )
    def test_styles(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[22m1\x1b[0m'
text       = '<n>1</n>'

tests/test_ansimarkup_basic.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac09457550>
        strict     = True
        strip      = False
        text       = '<n>1</n>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac09457550>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: n, n

self       = <loguru._colorizer.AnsiParser object at 0x7fac09457550>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="red-x1b41m1x1b0m">RED&gt;-\x1b[41m1\x1b[0m]</h3>
<details><summary> <pre>RED>-\x1b[41m1\x1b[0m]</pre></summary><pre>
text = '<RED>1</RED>', expected = '\x1b[41m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<RED>1</RED>", Back.RED + "1" + Style.RESET_ALL),
            ("<R>1</R>", Back.RED + "1" + Style.RESET_ALL),
            ("<LIGHT-GREEN>1</LIGHT-GREEN>", Back.LIGHTGREEN_EX + "1" + Style.RESET_ALL),
            ("<LG>1</LG>", Back.LIGHTGREEN_EX + "1" + Style.RESET_ALL),
        ],
    )
    def test_background_colors(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[41m1\x1b[0m'
text       = '<RED>1</RED>'

tests/test_ansimarkup_basic.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b18b5b0>
        strict     = True
        strip      = False
        text       = '<RED>1</RED>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b18b5b0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: RED, RED

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b18b5b0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="r-x1b41m1x1b0m">R&gt;-\x1b[41m1\x1b[0m]</h3>
<details><summary> <pre>R>-\x1b[41m1\x1b[0m]</pre></summary><pre>
text = '<R>1</R>', expected = '\x1b[41m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<RED>1</RED>", Back.RED + "1" + Style.RESET_ALL),
            ("<R>1</R>", Back.RED + "1" + Style.RESET_ALL),
            ("<LIGHT-GREEN>1</LIGHT-GREEN>", Back.LIGHTGREEN_EX + "1" + Style.RESET_ALL),
            ("<LG>1</LG>", Back.LIGHTGREEN_EX + "1" + Style.RESET_ALL),
        ],
    )
    def test_background_colors(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[41m1\x1b[0m'
text       = '<R>1</R>'

tests/test_ansimarkup_basic.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b0158d0>
        strict     = True
        strip      = False
        text       = '<R>1</R>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b0158d0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: R, R

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b0158d0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="light-green-x1b102m1x1b0m">LIGHT-GREEN&gt;-\x1b[102m1\x1b[0m]</h3>
<details><summary> <pre>LIGHT-GREEN>-\x1b[102m1\x1b[0m]</pre></summary><pre>
text = '<LIGHT-GREEN>1</LIGHT-GREEN>', expected = '\x1b[102m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<RED>1</RED>", Back.RED + "1" + Style.RESET_ALL),
            ("<R>1</R>", Back.RED + "1" + Style.RESET_ALL),
            ("<LIGHT-GREEN>1</LIGHT-GREEN>", Back.LIGHTGREEN_EX + "1" + Style.RESET_ALL),
            ("<LG>1</LG>", Back.LIGHTGREEN_EX + "1" + Style.RESET_ALL),
        ],
    )
    def test_background_colors(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[102m1\x1b[0m'
text       = '<LIGHT-GREEN>1</LIGHT-GREEN>'

tests/test_ansimarkup_basic.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b0cf130>
        strict     = True
        strip      = False
        text       = '<LIGHT-GREEN>1</LIGHT-GREEN>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b0cf130>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: LIGHT-GREEN, LIGHT-GREEN

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b0cf130>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="lg-x1b102m1x1b0m">LG&gt;-\x1b[102m1\x1b[0m]</h3>
<details><summary> <pre>LG>-\x1b[102m1\x1b[0m]</pre></summary><pre>
text = '<LG>1</LG>', expected = '\x1b[102m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<RED>1</RED>", Back.RED + "1" + Style.RESET_ALL),
            ("<R>1</R>", Back.RED + "1" + Style.RESET_ALL),
            ("<LIGHT-GREEN>1</LIGHT-GREEN>", Back.LIGHTGREEN_EX + "1" + Style.RESET_ALL),
            ("<LG>1</LG>", Back.LIGHTGREEN_EX + "1" + Style.RESET_ALL),
        ],
    )
    def test_background_colors(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[102m1\x1b[0m'
text       = '<LG>1</LG>'

tests/test_ansimarkup_basic.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b1894e0>
        strict     = True
        strip      = False
        text       = '<LG>1</LG>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b1894e0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: LG, LG

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b1894e0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="yellow-x1b33m1x1b0m">yellow&gt;-\x1b[33m1\x1b[0m]</h3>
<details><summary> <pre>yellow>-\x1b[33m1\x1b[0m]</pre></summary><pre>
text = '<yellow>1</yellow>', expected = '\x1b[33m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<yellow>1</yellow>", Fore.YELLOW + "1" + Style.RESET_ALL),
            ("<y>1</y>", Fore.YELLOW + "1" + Style.RESET_ALL),
            ("<light-white>1</light-white>", Fore.LIGHTWHITE_EX + "1" + Style.RESET_ALL),
            ("<lw>1</lw>", Fore.LIGHTWHITE_EX + "1" + Style.RESET_ALL),
        ],
    )
    def test_foreground_colors(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[33m1\x1b[0m'
text       = '<yellow>1</yellow>'

tests/test_ansimarkup_basic.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b9798a0>
        strict     = True
        strip      = False
        text       = '<yellow>1</yellow>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b9798a0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: yellow, yellow

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b9798a0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="y-x1b33m1x1b0m">y&gt;-\x1b[33m1\x1b[0m]</h3>
<details><summary> <pre>y>-\x1b[33m1\x1b[0m]</pre></summary><pre>
text = '<y>1</y>', expected = '\x1b[33m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<yellow>1</yellow>", Fore.YELLOW + "1" + Style.RESET_ALL),
            ("<y>1</y>", Fore.YELLOW + "1" + Style.RESET_ALL),
            ("<light-white>1</light-white>", Fore.LIGHTWHITE_EX + "1" + Style.RESET_ALL),
            ("<lw>1</lw>", Fore.LIGHTWHITE_EX + "1" + Style.RESET_ALL),
        ],
    )
    def test_foreground_colors(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[33m1\x1b[0m'
text       = '<y>1</y>'

tests/test_ansimarkup_basic.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b18a9e0>
        strict     = True
        strip      = False
        text       = '<y>1</y>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b18a9e0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: y, y

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b18a9e0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="light-white-x1b97m1x1b0m">light-white&gt;-\x1b[97m1\x1b[0m]</h3>
<details><summary> <pre>light-white>-\x1b[97m1\x1b[0m]</pre></summary><pre>
text = '<light-white>1</light-white>', expected = '\x1b[97m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<yellow>1</yellow>", Fore.YELLOW + "1" + Style.RESET_ALL),
            ("<y>1</y>", Fore.YELLOW + "1" + Style.RESET_ALL),
            ("<light-white>1</light-white>", Fore.LIGHTWHITE_EX + "1" + Style.RESET_ALL),
            ("<lw>1</lw>", Fore.LIGHTWHITE_EX + "1" + Style.RESET_ALL),
        ],
    )
    def test_foreground_colors(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[97m1\x1b[0m'
text       = '<light-white>1</light-white>'

tests/test_ansimarkup_basic.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b5b6680>
        strict     = True
        strip      = False
        text       = '<light-white>1</light-white>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b5b6680>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: light-white, light-white

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b5b6680>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="lw-x1b97m1x1b0m">lw&gt;-\x1b[97m1\x1b[0m]</h3>
<details><summary> <pre>lw>-\x1b[97m1\x1b[0m]</pre></summary><pre>
text = '<lw>1</lw>', expected = '\x1b[97m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<yellow>1</yellow>", Fore.YELLOW + "1" + Style.RESET_ALL),
            ("<y>1</y>", Fore.YELLOW + "1" + Style.RESET_ALL),
            ("<light-white>1</light-white>", Fore.LIGHTWHITE_EX + "1" + Style.RESET_ALL),
            ("<lw>1</lw>", Fore.LIGHTWHITE_EX + "1" + Style.RESET_ALL),
        ],
    )
    def test_foreground_colors(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[97m1\x1b[0m'
text       = '<lw>1</lw>'

tests/test_ansimarkup_basic.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac094137f0>
        strict     = True
        strip      = False
        text       = '<lw>1</lw>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac094137f0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: lw, lw

self       = <loguru._colorizer.AnsiParser object at 0x7fac094137f0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="d-x1b1m1x1b0mx1b2m2x1b0m">d&gt;-\x1b[1m1\x1b[0m\x1b[2m2\x1b[0m]</h3>
<details><summary> <pre>d>-\x1b[1m1\x1b[0m\x1b[2m2\x1b[0m]</pre></summary><pre>
text = '<b>1</b><d>2</d>', expected = '\x1b[1m1\x1b[0m\x1b[2m2\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            (
                "<b>1</b><d>2</d>",
                Style.BRIGHT + "1" + Style.RESET_ALL + Style.DIM + "2" + Style.RESET_ALL,
            ),
            (
                "<b>1</b>2<d>3</d>",
                Style.BRIGHT + "1" + Style.RESET_ALL + "2" + Style.DIM + "3" + Style.RESET_ALL,
            ),
            (
                "0<b>1<d>2</d>3</b>4",
                "0"
                + Style.BRIGHT
                + "1"
                + Style.DIM
                + "2"
                + Style.RESET_ALL
                + Style.BRIGHT
                + "3"
                + Style.RESET_ALL
                + "4",
            ),
            (
                "<d>0<b>1<d>2</d>3</b>4</d>",
                Style.DIM
                + "0"
                + Style.BRIGHT
                + "1"
                + Style.DIM
                + "2"
                + Style.RESET_ALL
                + Style.DIM
                + Style.BRIGHT
                + "3"
                + Style.RESET_ALL
                + Style.DIM
                + "4"
                + Style.RESET_ALL,
            ),
        ],
    )
    def test_nested(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[1m1\x1b[0m\x1b[2m2\x1b[0m'
text       = '<b>1</b><d>2</d>'

tests/test_ansimarkup_basic.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b5283d0>
        strict     = True
        strip      = False
        text       = '<b>1</b><d>2</d>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b5283d0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: b, b, d, d

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b5283d0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="d-x1b1m1x1b0m2x1b2m3x1b0m">d&gt;-\x1b[1m1\x1b[0m2\x1b[2m3\x1b[0m]</h3>
<details><summary> <pre>d>-\x1b[1m1\x1b[0m2\x1b[2m3\x1b[0m]</pre></summary><pre>
text = '<b>1</b>2<d>3</d>', expected = '\x1b[1m1\x1b[0m2\x1b[2m3\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            (
                "<b>1</b><d>2</d>",
                Style.BRIGHT + "1" + Style.RESET_ALL + Style.DIM + "2" + Style.RESET_ALL,
            ),
            (
                "<b>1</b>2<d>3</d>",
                Style.BRIGHT + "1" + Style.RESET_ALL + "2" + Style.DIM + "3" + Style.RESET_ALL,
            ),
            (
                "0<b>1<d>2</d>3</b>4",
                "0"
                + Style.BRIGHT
                + "1"
                + Style.DIM
                + "2"
                + Style.RESET_ALL
                + Style.BRIGHT
                + "3"
                + Style.RESET_ALL
                + "4",
            ),
            (
                "<d>0<b>1<d>2</d>3</b>4</d>",
                Style.DIM
                + "0"
                + Style.BRIGHT
                + "1"
                + Style.DIM
                + "2"
                + Style.RESET_ALL
                + Style.DIM
                + Style.BRIGHT
                + "3"
                + Style.RESET_ALL
                + Style.DIM
                + "4"
                + Style.RESET_ALL,
            ),
        ],
    )
    def test_nested(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[1m1\x1b[0m2\x1b[2m3\x1b[0m'
text       = '<b>1</b>2<d>3</d>'

tests/test_ansimarkup_basic.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b18afe0>
        strict     = True
        strip      = False
        text       = '<b>1</b>2<d>3</d>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b18afe0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: b, b, d, d

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b18afe0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="b4-0x1b1m1x1b2m2x1b0mx1b1m3x1b0m4">b&gt;4-0\x1b[1m1\x1b[2m2\x1b[0m\x1b[1m3\x1b[0m4]</h3>
<details><summary> <pre>b>4-0\x1b[1m1\x1b[2m2\x1b[0m\x1b[1m3\x1b[0m4]</pre></summary><pre>
text = '0<b>1<d>2</d>3</b>4'
expected = '0\x1b[1m1\x1b[2m2\x1b[0m\x1b[1m3\x1b[0m4'

    @pytest.mark.parametrize(
        "text, expected",
        [
            (
                "<b>1</b><d>2</d>",
                Style.BRIGHT + "1" + Style.RESET_ALL + Style.DIM + "2" + Style.RESET_ALL,
            ),
            (
                "<b>1</b>2<d>3</d>",
                Style.BRIGHT + "1" + Style.RESET_ALL + "2" + Style.DIM + "3" + Style.RESET_ALL,
            ),
            (
                "0<b>1<d>2</d>3</b>4",
                "0"
                + Style.BRIGHT
                + "1"
                + Style.DIM
                + "2"
                + Style.RESET_ALL
                + Style.BRIGHT
                + "3"
                + Style.RESET_ALL
                + "4",
            ),
            (
                "<d>0<b>1<d>2</d>3</b>4</d>",
                Style.DIM
                + "0"
                + Style.BRIGHT
                + "1"
                + Style.DIM
                + "2"
                + Style.RESET_ALL
                + Style.DIM
                + Style.BRIGHT
                + "3"
                + Style.RESET_ALL
                + Style.DIM
                + "4"
                + Style.RESET_ALL,
            ),
        ],
    )
    def test_nested(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '0\x1b[1m1\x1b[2m2\x1b[0m\x1b[1m3\x1b[0m4'
text       = '0<b>1<d>2</d>3</b>4'

tests/test_ansimarkup_basic.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b97a350>
        strict     = True
        strip      = False
        text       = '0<b>1<d>2</d>3</b>4'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b97a350>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: b, d, d, b

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b97a350>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="d-x1b2m0x1b1m1x1b2m2x1b0mx1b2mx1b1m3x1b0mx1b2m4x1b0m">d&gt;-\x1b[2m0\x1b[1m1\x1b[2m2\x1b[0m\x1b[2m\x1b[1m3\x1b[0m\x1b[2m4\x1b[0m]</h3>
<details><summary> <pre>d>-\x1b[2m0\x1b[1m1\x1b[2m2\x1b[0m\x1b[2m\x1b[1m3\x1b[0m\x1b[2m4\x1b[0m]</pre></summary><pre>
text = '<d>0<b>1<d>2</d>3</b>4</d>'
expected = '\x1b[2m0\x1b[1m1\x1b[2m2\x1b[0m\x1b[2m\x1b[1m3\x1b[0m\x1b[2m4\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            (
                "<b>1</b><d>2</d>",
                Style.BRIGHT + "1" + Style.RESET_ALL + Style.DIM + "2" + Style.RESET_ALL,
            ),
            (
                "<b>1</b>2<d>3</d>",
                Style.BRIGHT + "1" + Style.RESET_ALL + "2" + Style.DIM + "3" + Style.RESET_ALL,
            ),
            (
                "0<b>1<d>2</d>3</b>4",
                "0"
                + Style.BRIGHT
                + "1"
                + Style.DIM
                + "2"
                + Style.RESET_ALL
                + Style.BRIGHT
                + "3"
                + Style.RESET_ALL
                + "4",
            ),
            (
                "<d>0<b>1<d>2</d>3</b>4</d>",
                Style.DIM
                + "0"
                + Style.BRIGHT
                + "1"
                + Style.DIM
                + "2"
                + Style.RESET_ALL
                + Style.DIM
                + Style.BRIGHT
                + "3"
                + Style.RESET_ALL
                + Style.DIM
                + "4"
                + Style.RESET_ALL,
            ),
        ],
    )
    def test_nested(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[2m0\x1b[1m1\x1b[2m2\x1b[0m\x1b[2m\x1b[1m3\x1b[0m\x1b[2m4\x1b[0m'
text       = '<d>0<b>1<d>2</d>3</b>4</d>'

tests/test_ansimarkup_basic.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0be1e9e0>
        strict     = True
        strip      = False
        text       = '<d>0<b>1<d>2</d>3</b>4</d>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0be1e9e0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: d, b, d, d, b, d

self       = <loguru._colorizer.AnsiParser object at 0x7fac0be1e9e0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="test_ansimarkup_basicpytest_permissive_parsing-x1b1m">test_ansimarkup_basic.py::test_permissive_parsing[<b>-\x1b[1m]</h3>
<details><summary> <pre>test_ansimarkup_basic.py::test_permissive_parsing[<b>-\x1b[1m]</pre></summary><pre>
text = '<b>', expected = '\x1b[1m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<b>", Style.BRIGHT),
            ("<Y><b></b>", Back.YELLOW + Style.BRIGHT + Style.RESET_ALL + Back.YELLOW),
            ("<b><b></b>", Style.BRIGHT + Style.BRIGHT + Style.RESET_ALL + Style.BRIGHT),
        ],
    )
    def test_permissive_parsing(text, expected):
>       assert parse(text, strip=False, strict=False) == expected
E       AssertionError: assert '' == '\x1b[1m'
E         
E         - [1m

expected   = '\x1b[1m'
text       = '<b>'

tests/test_ansimarkup_basic.py:110: AssertionError
</pre>
</details>
<h3 id="b-x1b43mx1b1mx1b0mx1b43m">b&gt;-\x1b[43m\x1b[1m\x1b[0m\x1b[43m]</h3>
<details><summary> <pre>b>-\x1b[43m\x1b[1m\x1b[0m\x1b[43m]</pre></summary><pre>
text = '<Y><b></b>', expected = '\x1b[43m\x1b[1m\x1b[0m\x1b[43m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<b>", Style.BRIGHT),
            ("<Y><b></b>", Back.YELLOW + Style.BRIGHT + Style.RESET_ALL + Back.YELLOW),
            ("<b><b></b>", Style.BRIGHT + Style.BRIGHT + Style.RESET_ALL + Style.BRIGHT),
        ],
    )
    def test_permissive_parsing(text, expected):
>       assert parse(text, strip=False, strict=False) == expected
E       AssertionError: assert '' == '\x1b[43m\x1b...1b[0m\x1b[43m'
E         
E         - [43m[1m[0m[43m

expected   = '\x1b[43m\x1b[1m\x1b[0m\x1b[43m'
text       = '<Y><b></b>'

tests/test_ansimarkup_basic.py:110: AssertionError
</pre>
</details>
<h3 id="b-x1b1mx1b1mx1b0mx1b1m">b&gt;-\x1b[1m\x1b[1m\x1b[0m\x1b[1m]</h3>
<details><summary> <pre>b>-\x1b[1m\x1b[1m\x1b[0m\x1b[1m]</pre></summary><pre>
text = '<b><b></b>', expected = '\x1b[1m\x1b[1m\x1b[0m\x1b[1m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<b>", Style.BRIGHT),
            ("<Y><b></b>", Back.YELLOW + Style.BRIGHT + Style.RESET_ALL + Back.YELLOW),
            ("<b><b></b>", Style.BRIGHT + Style.BRIGHT + Style.RESET_ALL + Style.BRIGHT),
        ],
    )
    def test_permissive_parsing(text, expected):
>       assert parse(text, strip=False, strict=False) == expected
E       AssertionError: assert '' == '\x1b[1m\x1b[1m\x1b[0m\x1b[1m'
E         
E         - [1m[1m[0m[1m

expected   = '\x1b[1m\x1b[1m\x1b[0m\x1b[1m'
text       = '<b><b></b>'

tests/test_ansimarkup_basic.py:110: AssertionError
</pre>
</details>
<h3 id="-x1b31mfoox1b0m">&gt;-\x1b[31mfoo\x1b[0m]</h3>
<details><summary> <pre>>-\x1b[31mfoo\x1b[0m]</pre></summary><pre>
text = '<red>foo', expected = '\x1b[31mfoo\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<red>foo", Fore.RED + "foo" + Style.RESET_ALL),
            (
                "<green><bold>bar</green>",
                Fore.GREEN + Style.BRIGHT + "bar" + Style.RESET_ALL + Fore.GREEN + Style.RESET_ALL,
            ),
            (
                "a<yellow>b<b>cde",
                "a"
                + Fore.YELLOW
                + "b"
                + Style.BRIGHT
                + "c"
                + Style.RESET_ALL
                + Fore.YELLOW
                + "d"
                + Style.RESET_ALL
                + "e",
            ),
        ],
    )
    def test_autoclose(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[31mfoo\x1b[0m'
text       = '<red>foo'

tests/test_ansimarkup_basic.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b07bdc0>
        strict     = True
        strip      = False
        text       = '<red>foo'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b07bdc0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: red,

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b07bdc0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="green-x1b32mx1b1mbarx1b0mx1b32mx1b0m">green&gt;-\x1b[32m\x1b[1mbar\x1b[0m\x1b[32m\x1b[0m]</h3>
<details><summary> <pre>green>-\x1b[32m\x1b[1mbar\x1b[0m\x1b[32m\x1b[0m]</pre></summary><pre>
text = '<green><bold>bar</green>'
expected = '\x1b[32m\x1b[1mbar\x1b[0m\x1b[32m\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<red>foo", Fore.RED + "foo" + Style.RESET_ALL),
            (
                "<green><bold>bar</green>",
                Fore.GREEN + Style.BRIGHT + "bar" + Style.RESET_ALL + Fore.GREEN + Style.RESET_ALL,
            ),
            (
                "a<yellow>b<b>cde",
                "a"
                + Fore.YELLOW
                + "b"
                + Style.BRIGHT
                + "c"
                + Style.RESET_ALL
                + Fore.YELLOW
                + "d"
                + Style.RESET_ALL
                + "e",
            ),
        ],
    )
    def test_autoclose(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[32m\x1b[1mbar\x1b[0m\x1b[32m\x1b[0m'
text       = '<green><bold>bar</green>'

tests/test_ansimarkup_basic.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0c4ddf30>
        strict     = True
        strip      = False
        text       = '<green><bold>bar</green>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0c4ddf30>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: green, bold, , green

self       = <loguru._colorizer.AnsiParser object at 0x7fac0c4ddf30>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="e-ax1b33mbx1b1mcx1b0mx1b33mdx1b0me">&gt;e-a\x1b[33mb\x1b[1mc\x1b[0m\x1b[33md\x1b[0me]</h3>
<details><summary> <pre>>e-a\x1b[33mb\x1b[1mc\x1b[0m\x1b[33md\x1b[0me]</pre></summary><pre>
text = 'a<yellow>b<b>cde'
expected = 'a\x1b[33mb\x1b[1mc\x1b[0m\x1b[33md\x1b[0me'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<red>foo", Fore.RED + "foo" + Style.RESET_ALL),
            (
                "<green><bold>bar</green>",
                Fore.GREEN + Style.BRIGHT + "bar" + Style.RESET_ALL + Fore.GREEN + Style.RESET_ALL,
            ),
            (
                "a<yellow>b<b>cde",
                "a"
                + Fore.YELLOW
                + "b"
                + Style.BRIGHT
                + "c"
                + Style.RESET_ALL
                + Fore.YELLOW
                + "d"
                + Style.RESET_ALL
                + "e",
            ),
        ],
    )
    def test_autoclose(text, expected):
>       assert parse(text, strip=False) == expected

expected   = 'a\x1b[33mb\x1b[1mc\x1b[0m\x1b[33md\x1b[0me'
text       = 'a<yellow>b<b>cde'

tests/test_ansimarkup_basic.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b106320>
        strict     = True
        strip      = False
        text       = 'a<yellow>b<b>cde'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b106320>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: yellow, b, ,

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b106320>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="redbarx1b0m">red&gt;bar\x1b[0m]</h3>
<details><summary> <pre>red>bar\x1b[0m]</pre></summary><pre>
text = '<red>foo\\</red>bar</red>', expected = '\x1b[31mfoo</red>bar\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            (r"<red>foo\</red>bar</red>", Fore.RED + "foo</red>bar" + Style.RESET_ALL),
            (r"<red>foo\<red>bar</red>", Fore.RED + "foo<red>bar" + Style.RESET_ALL),
            (r"\<red>\</red>", "<red></red>"),
            (r"foo\bar\baz", "foobarbaz"),
        ],
    )
    def test_escaping(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[31mfoo</red>bar\x1b[0m'
text       = '<red>foo\\</red>bar</red>'

tests/test_ansimarkup_basic.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b0eafb0>
        strict     = True
        strip      = False
        text       = '<red>foo\\</red>bar</red>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b0eafb0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: red, red

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b0eafb0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="red-x1b31mfoobarx1b0m">red&gt;-\x1b[31mfoo<red>bar\x1b[0m]</h3>
<details><summary> <pre>red>-\x1b[31mfoo<red>bar\x1b[0m]</pre></summary><pre>
text = '<red>foo\\<red>bar</red>', expected = '\x1b[31mfoo<red>bar\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            (r"<red>foo\</red>bar</red>", Fore.RED + "foo</red>bar" + Style.RESET_ALL),
            (r"<red>foo\<red>bar</red>", Fore.RED + "foo<red>bar" + Style.RESET_ALL),
            (r"\<red>\</red>", "<red></red>"),
            (r"foo\bar\baz", "foobarbaz"),
        ],
    )
    def test_escaping(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[31mfoo<red>bar\x1b[0m'
text       = '<red>foo\\<red>bar</red>'

tests/test_ansimarkup_basic.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b52a830>
        strict     = True
        strip      = False
        text       = '<red>foo\\<red>bar</red>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b52a830>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: red, red

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b52a830>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="red-foo">red&gt;-foo]</h3>
<details><summary> <pre>red>-foo]</pre></summary><pre>
text = '<red>foo</red>', expected = 'foo'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<red>foo</red>", "foo"),
            ("<BLACK>bar</BLACK>", "bar"),
            ("<b>baz</b>", "baz"),
            ("<b>1</b>2<d>3</d>", "123"),
            ("<red>foo", "foo"),
        ],
    )
    def test_strip(text, expected):
>       assert parse(text, strip=True) == expected

expected   = 'foo'
text       = '<red>foo</red>'

tests/test_ansimarkup_basic.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b0ea560>
        strict     = True
        strip      = True
        text       = '<red>foo</red>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b0ea560>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: red, red

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b0ea560>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="black-bar">BLACK&gt;-bar]</h3>
<details><summary> <pre>BLACK>-bar]</pre></summary><pre>
text = '<BLACK>bar</BLACK>', expected = 'bar'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<red>foo</red>", "foo"),
            ("<BLACK>bar</BLACK>", "bar"),
            ("<b>baz</b>", "baz"),
            ("<b>1</b>2<d>3</d>", "123"),
            ("<red>foo", "foo"),
        ],
    )
    def test_strip(text, expected):
>       assert parse(text, strip=True) == expected

expected   = 'bar'
text       = '<BLACK>bar</BLACK>'

tests/test_ansimarkup_basic.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b059a80>
        strict     = True
        strip      = True
        text       = '<BLACK>bar</BLACK>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b059a80>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: BLACK, BLACK

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b059a80>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="b-baz">b&gt;-baz]</h3>
<details><summary> <pre>b>-baz]</pre></summary><pre>
text = '<b>baz</b>', expected = 'baz'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<red>foo</red>", "foo"),
            ("<BLACK>bar</BLACK>", "bar"),
            ("<b>baz</b>", "baz"),
            ("<b>1</b>2<d>3</d>", "123"),
            ("<red>foo", "foo"),
        ],
    )
    def test_strip(text, expected):
>       assert parse(text, strip=True) == expected

expected   = 'baz'
text       = '<b>baz</b>'

tests/test_ansimarkup_basic.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac09450f70>
        strict     = True
        strip      = True
        text       = '<b>baz</b>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac09450f70>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: b, b

self       = <loguru._colorizer.AnsiParser object at 0x7fac09450f70>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="d-123">d&gt;-123]</h3>
<details><summary> <pre>d>-123]</pre></summary><pre>
text = '<b>1</b>2<d>3</d>', expected = '123'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<red>foo</red>", "foo"),
            ("<BLACK>bar</BLACK>", "bar"),
            ("<b>baz</b>", "baz"),
            ("<b>1</b>2<d>3</d>", "123"),
            ("<red>foo", "foo"),
        ],
    )
    def test_strip(text, expected):
>       assert parse(text, strip=True) == expected

expected   = '123'
text       = '<b>1</b>2<d>3</d>'

tests/test_ansimarkup_basic.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b014820>
        strict     = True
        strip      = True
        text       = '<b>1</b>2<d>3</d>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b014820>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: b, b, d, d

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b014820>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="-foo">&gt;-foo]</h3>
<details><summary> <pre>>-foo]</pre></summary><pre>
text = '<red>foo', expected = 'foo'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<red>foo</red>", "foo"),
            ("<BLACK>bar</BLACK>", "bar"),
            ("<b>baz</b>", "baz"),
            ("<b>1</b>2<d>3</d>", "123"),
            ("<red>foo", "foo"),
        ],
    )
    def test_strip(text, expected):
>       assert parse(text, strip=True) == expected

expected   = 'foo'
text       = '<red>foo'

tests/test_ansimarkup_basic.py:221: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac094fe110>
        strict     = True
        strip      = True
        text       = '<red>foo'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac094fe110>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: red,

self       = <loguru._colorizer.AnsiParser object at 0x7fac094fe110>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="bg-red-x1b41m1x1b0m">bg red&gt;-\x1b[41m1\x1b[0m]</h3>
<details><summary> <pre>bg red>-\x1b[41m1\x1b[0m]</pre></summary><pre>
text = '<bg red>1</bg red>', expected = '\x1b[41m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<bg red>1</bg red>", Back.RED + "1" + Style.RESET_ALL),
            ("<bg BLACK>1</bg BLACK>", Back.BLACK + "1" + Style.RESET_ALL),
            ("<bg light-green>1</bg light-green>", Back.LIGHTGREEN_EX + "1" + Style.RESET_ALL),
            ("<bg LIGHT-MAGENTA>1</bg LIGHT-MAGENTA>", Back.LIGHTMAGENTA_EX + "1" + Style.RESET_ALL),
        ],
    )
    def test_background_colors(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[41m1\x1b[0m'
text       = '<bg red>1</bg red>'

tests/test_ansimarkup_extended.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b97ada0>
        strict     = True
        strip      = False
        text       = '<bg red>1</bg red>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b97ada0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: bg red, bg red

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b97ada0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="bg-black-x1b40m1x1b0m">bg BLACK&gt;-\x1b[40m1\x1b[0m]</h3>
<details><summary> <pre>bg BLACK>-\x1b[40m1\x1b[0m]</pre></summary><pre>
text = '<bg BLACK>1</bg BLACK>', expected = '\x1b[40m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<bg red>1</bg red>", Back.RED + "1" + Style.RESET_ALL),
            ("<bg BLACK>1</bg BLACK>", Back.BLACK + "1" + Style.RESET_ALL),
            ("<bg light-green>1</bg light-green>", Back.LIGHTGREEN_EX + "1" + Style.RESET_ALL),
            ("<bg LIGHT-MAGENTA>1</bg LIGHT-MAGENTA>", Back.LIGHTMAGENTA_EX + "1" + Style.RESET_ALL),
        ],
    )
    def test_background_colors(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[40m1\x1b[0m'
text       = '<bg BLACK>1</bg BLACK>'

tests/test_ansimarkup_extended.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b0cd510>
        strict     = True
        strip      = False
        text       = '<bg BLACK>1</bg BLACK>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b0cd510>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: bg BLACK, bg BLACK

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b0cd510>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="bg-light-green-x1b102m1x1b0m">bg light-green&gt;-\x1b[102m1\x1b[0m]</h3>
<details><summary> <pre>bg light-green>-\x1b[102m1\x1b[0m]</pre></summary><pre>
text = '<bg light-green>1</bg light-green>', expected = '\x1b[102m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<bg red>1</bg red>", Back.RED + "1" + Style.RESET_ALL),
            ("<bg BLACK>1</bg BLACK>", Back.BLACK + "1" + Style.RESET_ALL),
            ("<bg light-green>1</bg light-green>", Back.LIGHTGREEN_EX + "1" + Style.RESET_ALL),
            ("<bg LIGHT-MAGENTA>1</bg LIGHT-MAGENTA>", Back.LIGHTMAGENTA_EX + "1" + Style.RESET_ALL),
        ],
    )
    def test_background_colors(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[102m1\x1b[0m'
text       = '<bg light-green>1</bg light-green>'

tests/test_ansimarkup_extended.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b0e94b0>
        strict     = True
        strip      = False
        text       = '<bg light-green>1</bg light-green>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b0e94b0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: bg light-green, bg light-green

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b0e94b0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="bg-light-magenta-x1b105m1x1b0m">bg LIGHT-MAGENTA&gt;-\x1b[105m1\x1b[0m]</h3>
<details><summary> <pre>bg LIGHT-MAGENTA>-\x1b[105m1\x1b[0m]</pre></summary><pre>
text = '<bg LIGHT-MAGENTA>1</bg LIGHT-MAGENTA>', expected = '\x1b[105m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<bg red>1</bg red>", Back.RED + "1" + Style.RESET_ALL),
            ("<bg BLACK>1</bg BLACK>", Back.BLACK + "1" + Style.RESET_ALL),
            ("<bg light-green>1</bg light-green>", Back.LIGHTGREEN_EX + "1" + Style.RESET_ALL),
            ("<bg LIGHT-MAGENTA>1</bg LIGHT-MAGENTA>", Back.LIGHTMAGENTA_EX + "1" + Style.RESET_ALL),
        ],
    )
    def test_background_colors(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[105m1\x1b[0m'
text       = '<bg LIGHT-MAGENTA>1</bg LIGHT-MAGENTA>'

tests/test_ansimarkup_extended.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b058d30>
        strict     = True
        strip      = False
        text       = '<bg LIGHT-MAGENTA>1</bg LIGHT-MAGENTA>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b058d30>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: bg LIGHT-MAGENTA, bg LIGHT-MAGENTA

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b058d30>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="fg-yellow-x1b33m1x1b0m">fg yellow&gt;-\x1b[33m1\x1b[0m]</h3>
<details><summary> <pre>fg yellow>-\x1b[33m1\x1b[0m]</pre></summary><pre>
text = '<fg yellow>1</fg yellow>', expected = '\x1b[33m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<fg yellow>1</fg yellow>", Fore.YELLOW + "1" + Style.RESET_ALL),
            ("<fg BLUE>1</fg BLUE>", Fore.BLUE + "1" + Style.RESET_ALL),
            ("<fg light-white>1</fg light-white>", Fore.LIGHTWHITE_EX + "1" + Style.RESET_ALL),
            ("<fg LIGHT-CYAN>1</fg LIGHT-CYAN>", Fore.LIGHTCYAN_EX + "1" + Style.RESET_ALL),
        ],
    )
    def test_foreground_colors(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[33m1\x1b[0m'
text       = '<fg yellow>1</fg yellow>'

tests/test_ansimarkup_extended.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac094c1b70>
        strict     = True
        strip      = False
        text       = '<fg yellow>1</fg yellow>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac094c1b70>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: fg yellow, fg yellow

self       = <loguru._colorizer.AnsiParser object at 0x7fac094c1b70>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="fg-blue-x1b34m1x1b0m">fg BLUE&gt;-\x1b[34m1\x1b[0m]</h3>
<details><summary> <pre>fg BLUE>-\x1b[34m1\x1b[0m]</pre></summary><pre>
text = '<fg BLUE>1</fg BLUE>', expected = '\x1b[34m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<fg yellow>1</fg yellow>", Fore.YELLOW + "1" + Style.RESET_ALL),
            ("<fg BLUE>1</fg BLUE>", Fore.BLUE + "1" + Style.RESET_ALL),
            ("<fg light-white>1</fg light-white>", Fore.LIGHTWHITE_EX + "1" + Style.RESET_ALL),
            ("<fg LIGHT-CYAN>1</fg LIGHT-CYAN>", Fore.LIGHTCYAN_EX + "1" + Style.RESET_ALL),
        ],
    )
    def test_foreground_colors(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[34m1\x1b[0m'
text       = '<fg BLUE>1</fg BLUE>'

tests/test_ansimarkup_extended.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0c4dfa60>
        strict     = True
        strip      = False
        text       = '<fg BLUE>1</fg BLUE>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0c4dfa60>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: fg BLUE, fg BLUE

self       = <loguru._colorizer.AnsiParser object at 0x7fac0c4dfa60>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="fg-light-white-x1b97m1x1b0m">fg light-white&gt;-\x1b[97m1\x1b[0m]</h3>
<details><summary> <pre>fg light-white>-\x1b[97m1\x1b[0m]</pre></summary><pre>
text = '<fg light-white>1</fg light-white>', expected = '\x1b[97m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<fg yellow>1</fg yellow>", Fore.YELLOW + "1" + Style.RESET_ALL),
            ("<fg BLUE>1</fg BLUE>", Fore.BLUE + "1" + Style.RESET_ALL),
            ("<fg light-white>1</fg light-white>", Fore.LIGHTWHITE_EX + "1" + Style.RESET_ALL),
            ("<fg LIGHT-CYAN>1</fg LIGHT-CYAN>", Fore.LIGHTCYAN_EX + "1" + Style.RESET_ALL),
        ],
    )
    def test_foreground_colors(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[97m1\x1b[0m'
text       = '<fg light-white>1</fg light-white>'

tests/test_ansimarkup_extended.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b105bd0>
        strict     = True
        strip      = False
        text       = '<fg light-white>1</fg light-white>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b105bd0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: fg light-white, fg light-white

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b105bd0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="fg-light-cyan-x1b96m1x1b0m">fg LIGHT-CYAN&gt;-\x1b[96m1\x1b[0m]</h3>
<details><summary> <pre>fg LIGHT-CYAN>-\x1b[96m1\x1b[0m]</pre></summary><pre>
text = '<fg LIGHT-CYAN>1</fg LIGHT-CYAN>', expected = '\x1b[96m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<fg yellow>1</fg yellow>", Fore.YELLOW + "1" + Style.RESET_ALL),
            ("<fg BLUE>1</fg BLUE>", Fore.BLUE + "1" + Style.RESET_ALL),
            ("<fg light-white>1</fg light-white>", Fore.LIGHTWHITE_EX + "1" + Style.RESET_ALL),
            ("<fg LIGHT-CYAN>1</fg LIGHT-CYAN>", Fore.LIGHTCYAN_EX + "1" + Style.RESET_ALL),
        ],
    )
    def test_foreground_colors(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[96m1\x1b[0m'
text       = '<fg LIGHT-CYAN>1</fg LIGHT-CYAN>'

tests/test_ansimarkup_extended.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b083910>
        strict     = True
        strip      = False
        text       = '<fg LIGHT-CYAN>1</fg LIGHT-CYAN>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b083910>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: fg LIGHT-CYAN, fg LIGHT-CYAN

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b083910>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="fg-ff0000-x1b38225500m1x1b0m">fg #ff0000&gt;-\x1b[38;2;255;0;0m1\x1b[0m]</h3>
<details><summary> <pre>fg #ff0000>-\x1b[38;2;255;0;0m1\x1b[0m]</pre></summary><pre>
text = '<fg #ff0000>1</fg #ff0000>', expected = '\x1b[38;2;255;0;0m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<fg #ff0000>1</fg #ff0000>", "\x1b[38;2;255;0;0m" "1" + Style.RESET_ALL),
            ("<bg #00A000>1</bg #00A000>", "\x1b[48;2;0;160;0m" "1" + Style.RESET_ALL),
            ("<fg #F12>1</fg #F12>", "\x1b[38;2;241;47;18m" "1" + Style.RESET_ALL),
        ],
    )
    def test_8bit_colors(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[38;2;255;0;0m1\x1b[0m'
text       = '<fg #ff0000>1</fg #ff0000>'

tests/test_ansimarkup_extended.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b058700>
        strict     = True
        strip      = False
        text       = '<fg #ff0000>1</fg #ff0000>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b058700>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: fg #ff0000, fg #ff0000

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b058700>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="bg-00a000-x1b48201600m1x1b0m">bg #00A000&gt;-\x1b[48;2;0;160;0m1\x1b[0m]</h3>
<details><summary> <pre>bg #00A000>-\x1b[48;2;0;160;0m1\x1b[0m]</pre></summary><pre>
text = '<bg #00A000>1</bg #00A000>', expected = '\x1b[48;2;0;160;0m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<fg #ff0000>1</fg #ff0000>", "\x1b[38;2;255;0;0m" "1" + Style.RESET_ALL),
            ("<bg #00A000>1</bg #00A000>", "\x1b[48;2;0;160;0m" "1" + Style.RESET_ALL),
            ("<fg #F12>1</fg #F12>", "\x1b[38;2;241;47;18m" "1" + Style.RESET_ALL),
        ],
    )
    def test_8bit_colors(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[48;2;0;160;0m1\x1b[0m'
text       = '<bg #00A000>1</bg #00A000>'

tests/test_ansimarkup_extended.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b1211e0>
        strict     = True
        strip      = False
        text       = '<bg #00A000>1</bg #00A000>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b1211e0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: bg #00A000, bg #00A000

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b1211e0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="fg-f12-x1b3822414718m1x1b0m">fg #F12&gt;-\x1b[38;2;241;47;18m1\x1b[0m]</h3>
<details><summary> <pre>fg #F12>-\x1b[38;2;241;47;18m1\x1b[0m]</pre></summary><pre>
text = '<fg #F12>1</fg #F12>', expected = '\x1b[38;2;241;47;18m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<fg #ff0000>1</fg #ff0000>", "\x1b[38;2;255;0;0m" "1" + Style.RESET_ALL),
            ("<bg #00A000>1</bg #00A000>", "\x1b[48;2;0;160;0m" "1" + Style.RESET_ALL),
            ("<fg #F12>1</fg #F12>", "\x1b[38;2;241;47;18m" "1" + Style.RESET_ALL),
        ],
    )
    def test_8bit_colors(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[38;2;241;47;18m1\x1b[0m'
text       = '<fg #F12>1</fg #F12>'

tests/test_ansimarkup_extended.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b52ad40>
        strict     = True
        strip      = False
        text       = '<fg #F12>1</fg #F12>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b52ad40>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: fg #F12, fg #F12

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b52ad40>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="fg-ff0000-x1b38225500m1x1b0m_1">fg #ff0000&gt;-\x1b[38;2;255;0;0m1\x1b[0m]</h3>
<details><summary> <pre>fg #ff0000>-\x1b[38;2;255;0;0m1\x1b[0m]</pre></summary><pre>
text = '<fg #ff0000>1</fg #ff0000>', expected = '\x1b[38;2;255;0;0m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<fg #ff0000>1</fg #ff0000>", "\x1b[38;2;255;0;0m" "1" + Style.RESET_ALL),
            ("<bg #00A000>1</bg #00A000>", "\x1b[48;2;0;160;0m" "1" + Style.RESET_ALL),
            ("<fg #F12>1</fg #F12>", "\x1b[38;2;241;47;18m" "1" + Style.RESET_ALL),
            ("<bg #BEE>1</bg #BEE>", "\x1b[48;2;190;235;238m" "1" + Style.RESET_ALL),
        ],
    )
    def test_hex_colors(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[38;2;255;0;0m1\x1b[0m'
text       = '<fg #ff0000>1</fg #ff0000>'

tests/test_ansimarkup_extended.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b0e9b40>
        strict     = True
        strip      = False
        text       = '<fg #ff0000>1</fg #ff0000>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b0e9b40>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: fg #ff0000, fg #ff0000

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b0e9b40>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="bg-00a000-x1b48201600m1x1b0m_1">bg #00A000&gt;-\x1b[48;2;0;160;0m1\x1b[0m]</h3>
<details><summary> <pre>bg #00A000>-\x1b[48;2;0;160;0m1\x1b[0m]</pre></summary><pre>
text = '<bg #00A000>1</bg #00A000>', expected = '\x1b[48;2;0;160;0m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<fg #ff0000>1</fg #ff0000>", "\x1b[38;2;255;0;0m" "1" + Style.RESET_ALL),
            ("<bg #00A000>1</bg #00A000>", "\x1b[48;2;0;160;0m" "1" + Style.RESET_ALL),
            ("<fg #F12>1</fg #F12>", "\x1b[38;2;241;47;18m" "1" + Style.RESET_ALL),
            ("<bg #BEE>1</bg #BEE>", "\x1b[48;2;190;235;238m" "1" + Style.RESET_ALL),
        ],
    )
    def test_hex_colors(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[48;2;0;160;0m1\x1b[0m'
text       = '<bg #00A000>1</bg #00A000>'

tests/test_ansimarkup_extended.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b0792d0>
        strict     = True
        strip      = False
        text       = '<bg #00A000>1</bg #00A000>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b0792d0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: bg #00A000, bg #00A000

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b0792d0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="fg-f12-x1b3822414718m1x1b0m_1">fg #F12&gt;-\x1b[38;2;241;47;18m1\x1b[0m]</h3>
<details><summary> <pre>fg #F12>-\x1b[38;2;241;47;18m1\x1b[0m]</pre></summary><pre>
text = '<fg #F12>1</fg #F12>', expected = '\x1b[38;2;241;47;18m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<fg #ff0000>1</fg #ff0000>", "\x1b[38;2;255;0;0m" "1" + Style.RESET_ALL),
            ("<bg #00A000>1</bg #00A000>", "\x1b[48;2;0;160;0m" "1" + Style.RESET_ALL),
            ("<fg #F12>1</fg #F12>", "\x1b[38;2;241;47;18m" "1" + Style.RESET_ALL),
            ("<bg #BEE>1</bg #BEE>", "\x1b[48;2;190;235;238m" "1" + Style.RESET_ALL),
        ],
    )
    def test_hex_colors(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[38;2;241;47;18m1\x1b[0m'
text       = '<fg #F12>1</fg #F12>'

tests/test_ansimarkup_extended.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac094ffac0>
        strict     = True
        strip      = False
        text       = '<fg #F12>1</fg #F12>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac094ffac0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: fg #F12, fg #F12

self       = <loguru._colorizer.AnsiParser object at 0x7fac094ffac0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="bg-bee-x1b482190235238m1x1b0m">bg #BEE&gt;-\x1b[48;2;190;235;238m1\x1b[0m]</h3>
<details><summary> <pre>bg #BEE>-\x1b[48;2;190;235;238m1\x1b[0m]</pre></summary><pre>
text = '<bg #BEE>1</bg #BEE>', expected = '\x1b[48;2;190;235;238m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<fg #ff0000>1</fg #ff0000>", "\x1b[38;2;255;0;0m" "1" + Style.RESET_ALL),
            ("<bg #00A000>1</bg #00A000>", "\x1b[48;2;0;160;0m" "1" + Style.RESET_ALL),
            ("<fg #F12>1</fg #F12>", "\x1b[38;2;241;47;18m" "1" + Style.RESET_ALL),
            ("<bg #BEE>1</bg #BEE>", "\x1b[48;2;190;235;238m" "1" + Style.RESET_ALL),
        ],
    )
    def test_hex_colors(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[48;2;190;235;238m1\x1b[0m'
text       = '<bg #BEE>1</bg #BEE>'

tests/test_ansimarkup_extended.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b0831c0>
        strict     = True
        strip      = False
        text       = '<bg #BEE>1</bg #BEE>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b0831c0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: bg #BEE, bg #BEE

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b0831c0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="fg-200-x1b385200m1x1b0m">fg 200&gt;-\x1b[38;5;200m1\x1b[0m]</h3>
<details><summary> <pre>fg 200>-\x1b[38;5;200m1\x1b[0m]</pre></summary><pre>
text = '<fg 200>1</fg 200>', expected = '\x1b[38;5;200m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<fg 200>1</fg 200>", "\x1b[38;5;200m" "1" + Style.RESET_ALL),
            ("<bg 49>1</bg 49>", "\x1b[48;5;49m" "1" + Style.RESET_ALL),
        ],
    )
    def test_rgb_colors(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[38;5;200m1\x1b[0m'
text       = '<fg 200>1</fg 200>'

tests/test_ansimarkup_extended.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b058b80>
        strict     = True
        strip      = False
        text       = '<fg 200>1</fg 200>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b058b80>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: fg 200, fg 200

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b058b80>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="bg-49-x1b48549m1x1b0m">bg 49&gt;-\x1b[48;5;49m1\x1b[0m]</h3>
<details><summary> <pre>bg 49>-\x1b[48;5;49m1\x1b[0m]</pre></summary><pre>
text = '<bg 49>1</bg 49>', expected = '\x1b[48;5;49m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<fg 200>1</fg 200>", "\x1b[38;5;200m" "1" + Style.RESET_ALL),
            ("<bg 49>1</bg 49>", "\x1b[48;5;49m" "1" + Style.RESET_ALL),
        ],
    )
    def test_rgb_colors(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[48;5;49m1\x1b[0m'
text       = '<bg 49>1</bg 49>'

tests/test_ansimarkup_extended.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b120520>
        strict     = True
        strip      = False
        text       = '<bg 49>1</bg 49>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b120520>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: bg 49, bg 49

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b120520>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="red-x1b31mx1b1mx1b48201600m1x1b0mx1b31mx1b1mx1b0mx1b31mx1b0m">red&gt;-\x1b[31m\x1b[1m\x1b[48;2;0;160;0m1\x1b[0m\x1b[31m\x1b[1m\x1b[0m\x1b[31m\x1b[0m]</h3>
<details><summary> <pre>red>-\x1b[31m\x1b[1m\x1b[48;2;0;160;0m1\x1b[0m\x1b[31m\x1b[1m\x1b[0m\x1b[31m\x1b[0m]</pre></summary><pre>
text = '<red><b><bg #00A000>1</bg #00A000></b></red>'
expected = '\x1b[31m\x1b[1m\x1b[48;2;0;160;0m1\x1b[0m\x1b[31m\x1b[1m\x1b[0m\x1b[31m\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            (
                "<red><b><bg #00A000>1</bg #00A000></b></red>",
                Fore.RED + Style.BRIGHT + "\x1b[48;2;0;160;0m"
                "1"
                + Style.RESET_ALL
                + Fore.RED
                + Style.BRIGHT
                + Style.RESET_ALL
                + Fore.RED
                + Style.RESET_ALL,
            ),
            (
                "<bg 100><fg 200>1</fg 200></bg 100>",
                "\x1b[48;5;100m" "\x1b[38;5;200m" "1" "\x1b[0m" "\x1b[48;5;100m" "\x1b[0m",
            ),
            (
                "<bg #00a000><fg #FF0000>1</fg #FF0000></bg #00a000>",
                "\x1b[48;2;0;160;0m" "\x1b[38;2;255;0;0m" "1" "\x1b[0m" "\x1b[48;2;0;160;0m" "\x1b[0m",
            ),
            (
                "<bg 0,160,0><fg 255,0,0>1</fg 255,0,0></bg 0,160,0>",
                "\x1b[48;2;0;160;0m" "\x1b[38;2;255;0;0m" "1" "\x1b[0m" "\x1b[48;2;0;160;0m" "\x1b[0m",
            ),
        ],
    )
    def test_nested(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[31m\x1b[1m\x1b[48;2;0;160;0m1\x1b[0m\x1b[31m\x1b[1m\x1b[0m\x1b[31m\x1b[0m'
text       = '<red><b><bg #00A000>1</bg #00A000></b></red>'

tests/test_ansimarkup_extended.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac09452b00>
        strict     = True
        strip      = False
        text       = '<red><b><bg #00A000>1</bg #00A000></b></red>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac09452b00>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: red, b, bg #00A000, bg #00A000, b, red

self       = <loguru._colorizer.AnsiParser object at 0x7fac09452b00>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="bg-100-x1b485100mx1b385200m1x1b0mx1b485100mx1b0m">bg 100&gt;-\x1b[48;5;100m\x1b[38;5;200m1\x1b[0m\x1b[48;5;100m\x1b[0m]</h3>
<details><summary> <pre>bg 100>-\x1b[48;5;100m\x1b[38;5;200m1\x1b[0m\x1b[48;5;100m\x1b[0m]</pre></summary><pre>
text = '<bg 100><fg 200>1</fg 200></bg 100>'
expected = '\x1b[48;5;100m\x1b[38;5;200m1\x1b[0m\x1b[48;5;100m\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            (
                "<red><b><bg #00A000>1</bg #00A000></b></red>",
                Fore.RED + Style.BRIGHT + "\x1b[48;2;0;160;0m"
                "1"
                + Style.RESET_ALL
                + Fore.RED
                + Style.BRIGHT
                + Style.RESET_ALL
                + Fore.RED
                + Style.RESET_ALL,
            ),
            (
                "<bg 100><fg 200>1</fg 200></bg 100>",
                "\x1b[48;5;100m" "\x1b[38;5;200m" "1" "\x1b[0m" "\x1b[48;5;100m" "\x1b[0m",
            ),
            (
                "<bg #00a000><fg #FF0000>1</fg #FF0000></bg #00a000>",
                "\x1b[48;2;0;160;0m" "\x1b[38;2;255;0;0m" "1" "\x1b[0m" "\x1b[48;2;0;160;0m" "\x1b[0m",
            ),
            (
                "<bg 0,160,0><fg 255,0,0>1</fg 255,0,0></bg 0,160,0>",
                "\x1b[48;2;0;160;0m" "\x1b[38;2;255;0;0m" "1" "\x1b[0m" "\x1b[48;2;0;160;0m" "\x1b[0m",
            ),
        ],
    )
    def test_nested(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[48;5;100m\x1b[38;5;200m1\x1b[0m\x1b[48;5;100m\x1b[0m'
text       = '<bg 100><fg 200>1</fg 200></bg 100>'

tests/test_ansimarkup_extended.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac094107c0>
        strict     = True
        strip      = False
        text       = '<bg 100><fg 200>1</fg 200></bg 100>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac094107c0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: bg 100, fg 200, fg 200, bg 100

self       = <loguru._colorizer.AnsiParser object at 0x7fac094107c0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="bg-00a000-x1b48201600mx1b38225500m1x1b0mx1b48201600mx1b0m">bg #00a000&gt;-\x1b[48;2;0;160;0m\x1b[38;2;255;0;0m1\x1b[0m\x1b[48;2;0;160;0m\x1b[0m]</h3>
<details><summary> <pre>bg #00a000>-\x1b[48;2;0;160;0m\x1b[38;2;255;0;0m1\x1b[0m\x1b[48;2;0;160;0m\x1b[0m]</pre></summary><pre>
text = '<bg #00a000><fg #FF0000>1</fg #FF0000></bg #00a000>'
expected = '\x1b[48;2;0;160;0m\x1b[38;2;255;0;0m1\x1b[0m\x1b[48;2;0;160;0m\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            (
                "<red><b><bg #00A000>1</bg #00A000></b></red>",
                Fore.RED + Style.BRIGHT + "\x1b[48;2;0;160;0m"
                "1"
                + Style.RESET_ALL
                + Fore.RED
                + Style.BRIGHT
                + Style.RESET_ALL
                + Fore.RED
                + Style.RESET_ALL,
            ),
            (
                "<bg 100><fg 200>1</fg 200></bg 100>",
                "\x1b[48;5;100m" "\x1b[38;5;200m" "1" "\x1b[0m" "\x1b[48;5;100m" "\x1b[0m",
            ),
            (
                "<bg #00a000><fg #FF0000>1</fg #FF0000></bg #00a000>",
                "\x1b[48;2;0;160;0m" "\x1b[38;2;255;0;0m" "1" "\x1b[0m" "\x1b[48;2;0;160;0m" "\x1b[0m",
            ),
            (
                "<bg 0,160,0><fg 255,0,0>1</fg 255,0,0></bg 0,160,0>",
                "\x1b[48;2;0;160;0m" "\x1b[38;2;255;0;0m" "1" "\x1b[0m" "\x1b[48;2;0;160;0m" "\x1b[0m",
            ),
        ],
    )
    def test_nested(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[48;2;0;160;0m\x1b[38;2;255;0;0m1\x1b[0m\x1b[48;2;0;160;0m\x1b[0m'
text       = '<bg #00a000><fg #FF0000>1</fg #FF0000></bg #00a000>'

tests/test_ansimarkup_extended.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b552b00>
        strict     = True
        strip      = False
        text       = '<bg #00a000><fg #FF0000>1</fg #FF0000></bg #00a000>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b552b00>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: bg #00a000, fg #FF0000, fg #FF0000, bg #00a000

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b552b00>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="bg-01600-x1b48201600mx1b38225500m1x1b0mx1b48201600mx1b0m">bg 0,160,0&gt;-\x1b[48;2;0;160;0m\x1b[38;2;255;0;0m1\x1b[0m\x1b[48;2;0;160;0m\x1b[0m]</h3>
<details><summary> <pre>bg 0,160,0>-\x1b[48;2;0;160;0m\x1b[38;2;255;0;0m1\x1b[0m\x1b[48;2;0;160;0m\x1b[0m]</pre></summary><pre>
text = '<bg 0,160,0><fg 255,0,0>1</fg 255,0,0></bg 0,160,0>'
expected = '\x1b[48;2;0;160;0m\x1b[38;2;255;0;0m1\x1b[0m\x1b[48;2;0;160;0m\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            (
                "<red><b><bg #00A000>1</bg #00A000></b></red>",
                Fore.RED + Style.BRIGHT + "\x1b[48;2;0;160;0m"
                "1"
                + Style.RESET_ALL
                + Fore.RED
                + Style.BRIGHT
                + Style.RESET_ALL
                + Fore.RED
                + Style.RESET_ALL,
            ),
            (
                "<bg 100><fg 200>1</fg 200></bg 100>",
                "\x1b[48;5;100m" "\x1b[38;5;200m" "1" "\x1b[0m" "\x1b[48;5;100m" "\x1b[0m",
            ),
            (
                "<bg #00a000><fg #FF0000>1</fg #FF0000></bg #00a000>",
                "\x1b[48;2;0;160;0m" "\x1b[38;2;255;0;0m" "1" "\x1b[0m" "\x1b[48;2;0;160;0m" "\x1b[0m",
            ),
            (
                "<bg 0,160,0><fg 255,0,0>1</fg 255,0,0></bg 0,160,0>",
                "\x1b[48;2;0;160;0m" "\x1b[38;2;255;0;0m" "1" "\x1b[0m" "\x1b[48;2;0;160;0m" "\x1b[0m",
            ),
        ],
    )
    def test_nested(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[48;2;0;160;0m\x1b[38;2;255;0;0m1\x1b[0m\x1b[48;2;0;160;0m\x1b[0m'
text       = '<bg 0,160,0><fg 255,0,0>1</fg 255,0,0></bg 0,160,0>'

tests/test_ansimarkup_extended.py:98: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0942d330>
        strict     = True
        strip      = False
        text       = '<bg 0,160,0><fg 255,0,0>1</fg 255,0,0></bg 0,160,0>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0942d330>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: bg 0,160,0, fg 255,0,0, fg 255,0,0, bg 0,160,0

self       = <loguru._colorizer.AnsiParser object at 0x7fac0942d330>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="r-x1b31m2-1x1b0m">r&gt;-\x1b[31m2 &gt; 1\x1b[0m]</h3>
<details><summary> <pre>r>-\x1b[31m2 > 1\x1b[0m]</pre></summary><pre>
text = '<r>2 > 1</r>', expected = '\x1b[31m2 > 1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<r>2 > 1</r>", Fore.RED + "2 > 1" + Style.RESET_ALL),
            ("<r>1 < 2</r>", Fore.RED + "1 < 2" + Style.RESET_ALL),
            ("<r>1 </ 2</r>", Fore.RED + "1 </ 2" + Style.RESET_ALL),
            ("{: <10}<r>1</r>", "{: <10}" + Fore.RED + "1" + Style.RESET_ALL),
            ("{: </10}<r>1</r>", "{: </10}" + Fore.RED + "1" + Style.RESET_ALL),
            ("<r>1</r>{: >10}", Fore.RED + "1" + Style.RESET_ALL + "{: >10}"),
            ("<1<r>2</r>3>", "<1" + Fore.RED + "2" + Style.RESET_ALL + "3>"),
            ("</1<r>2</r>3>", "</1" + Fore.RED + "2" + Style.RESET_ALL + "3>"),
            ("<1<r>2 < 3</r>4>", "<1" + Fore.RED + "2 < 3" + Style.RESET_ALL + "4>"),
            ("<1<r>2 </ 3</r>4>", "<1" + Fore.RED + "2 </ 3" + Style.RESET_ALL + "4>"),
            ("<1<r>3 > 2</r>4>", "<1" + Fore.RED + "3 > 2" + Style.RESET_ALL + "4>"),
        ],
    )
    def test_tricky_parse(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[31m2 > 1\x1b[0m'
text       = '<r>2 > 1</r>'

tests/test_ansimarkup_extended.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0cea4400>
        strict     = True
        strip      = False
        text       = '<r>2 > 1</r>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0cea4400>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: r, r

self       = <loguru._colorizer.AnsiParser object at 0x7fac0cea4400>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="r-x1b31m1-2x1b0m">r&gt;-\x1b[31m1 &lt; 2\x1b[0m]</h3>
<details><summary> <pre>r>-\x1b[31m1 < 2\x1b[0m]</pre></summary><pre>
text = '<r>1 < 2</r>', expected = '\x1b[31m1 < 2\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<r>2 > 1</r>", Fore.RED + "2 > 1" + Style.RESET_ALL),
            ("<r>1 < 2</r>", Fore.RED + "1 < 2" + Style.RESET_ALL),
            ("<r>1 </ 2</r>", Fore.RED + "1 </ 2" + Style.RESET_ALL),
            ("{: <10}<r>1</r>", "{: <10}" + Fore.RED + "1" + Style.RESET_ALL),
            ("{: </10}<r>1</r>", "{: </10}" + Fore.RED + "1" + Style.RESET_ALL),
            ("<r>1</r>{: >10}", Fore.RED + "1" + Style.RESET_ALL + "{: >10}"),
            ("<1<r>2</r>3>", "<1" + Fore.RED + "2" + Style.RESET_ALL + "3>"),
            ("</1<r>2</r>3>", "</1" + Fore.RED + "2" + Style.RESET_ALL + "3>"),
            ("<1<r>2 < 3</r>4>", "<1" + Fore.RED + "2 < 3" + Style.RESET_ALL + "4>"),
            ("<1<r>2 </ 3</r>4>", "<1" + Fore.RED + "2 </ 3" + Style.RESET_ALL + "4>"),
            ("<1<r>3 > 2</r>4>", "<1" + Fore.RED + "3 > 2" + Style.RESET_ALL + "4>"),
        ],
    )
    def test_tricky_parse(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[31m1 < 2\x1b[0m'
text       = '<r>1 < 2</r>'

tests/test_ansimarkup_extended.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b107820>
        strict     = True
        strip      = False
        text       = '<r>1 < 2</r>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b107820>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: r, r

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b107820>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="2x1b0m">2\x1b[0m]</h3>
<details><summary> <pre> 2\x1b[0m]</pre></summary><pre>
text = '<r>1 </ 2</r>', expected = '\x1b[31m1 </ 2\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<r>2 > 1</r>", Fore.RED + "2 > 1" + Style.RESET_ALL),
            ("<r>1 < 2</r>", Fore.RED + "1 < 2" + Style.RESET_ALL),
            ("<r>1 </ 2</r>", Fore.RED + "1 </ 2" + Style.RESET_ALL),
            ("{: <10}<r>1</r>", "{: <10}" + Fore.RED + "1" + Style.RESET_ALL),
            ("{: </10}<r>1</r>", "{: </10}" + Fore.RED + "1" + Style.RESET_ALL),
            ("<r>1</r>{: >10}", Fore.RED + "1" + Style.RESET_ALL + "{: >10}"),
            ("<1<r>2</r>3>", "<1" + Fore.RED + "2" + Style.RESET_ALL + "3>"),
            ("</1<r>2</r>3>", "</1" + Fore.RED + "2" + Style.RESET_ALL + "3>"),
            ("<1<r>2 < 3</r>4>", "<1" + Fore.RED + "2 < 3" + Style.RESET_ALL + "4>"),
            ("<1<r>2 </ 3</r>4>", "<1" + Fore.RED + "2 </ 3" + Style.RESET_ALL + "4>"),
            ("<1<r>3 > 2</r>4>", "<1" + Fore.RED + "3 > 2" + Style.RESET_ALL + "4>"),
        ],
    )
    def test_tricky_parse(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[31m1 </ 2\x1b[0m'
text       = '<r>1 </ 2</r>'

tests/test_ansimarkup_extended.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0942c310>
        strict     = True
        strip      = False
        text       = '<r>1 </ 2</r>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0942c310>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: r, r

self       = <loguru._colorizer.AnsiParser object at 0x7fac0942c310>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="r-10x1b31m1x1b0m">r&gt;-{: &lt;10}\x1b[31m1\x1b[0m]</h3>
<details><summary> <pre>r>-{: <10}\x1b[31m1\x1b[0m]</pre></summary><pre>
text = '{: <10}<r>1</r>', expected = '{: <10}\x1b[31m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<r>2 > 1</r>", Fore.RED + "2 > 1" + Style.RESET_ALL),
            ("<r>1 < 2</r>", Fore.RED + "1 < 2" + Style.RESET_ALL),
            ("<r>1 </ 2</r>", Fore.RED + "1 </ 2" + Style.RESET_ALL),
            ("{: <10}<r>1</r>", "{: <10}" + Fore.RED + "1" + Style.RESET_ALL),
            ("{: </10}<r>1</r>", "{: </10}" + Fore.RED + "1" + Style.RESET_ALL),
            ("<r>1</r>{: >10}", Fore.RED + "1" + Style.RESET_ALL + "{: >10}"),
            ("<1<r>2</r>3>", "<1" + Fore.RED + "2" + Style.RESET_ALL + "3>"),
            ("</1<r>2</r>3>", "</1" + Fore.RED + "2" + Style.RESET_ALL + "3>"),
            ("<1<r>2 < 3</r>4>", "<1" + Fore.RED + "2 < 3" + Style.RESET_ALL + "4>"),
            ("<1<r>2 </ 3</r>4>", "<1" + Fore.RED + "2 </ 3" + Style.RESET_ALL + "4>"),
            ("<1<r>3 > 2</r>4>", "<1" + Fore.RED + "3 > 2" + Style.RESET_ALL + "4>"),
        ],
    )
    def test_tricky_parse(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '{: <10}\x1b[31m1\x1b[0m'
text       = '{: <10}<r>1</r>'

tests/test_ansimarkup_extended.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b078be0>
        strict     = True
        strip      = False
        text       = '{: <10}<r>1</r>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b078be0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: r, r

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b078be0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="10x1b31m1x1b0m">10}\x1b[31m1\x1b[0m]</h3>
<details><summary> <pre>10}\x1b[31m1\x1b[0m]</pre></summary><pre>
text = '{: </10}<r>1</r>', expected = '{: </10}\x1b[31m1\x1b[0m'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<r>2 > 1</r>", Fore.RED + "2 > 1" + Style.RESET_ALL),
            ("<r>1 < 2</r>", Fore.RED + "1 < 2" + Style.RESET_ALL),
            ("<r>1 </ 2</r>", Fore.RED + "1 </ 2" + Style.RESET_ALL),
            ("{: <10}<r>1</r>", "{: <10}" + Fore.RED + "1" + Style.RESET_ALL),
            ("{: </10}<r>1</r>", "{: </10}" + Fore.RED + "1" + Style.RESET_ALL),
            ("<r>1</r>{: >10}", Fore.RED + "1" + Style.RESET_ALL + "{: >10}"),
            ("<1<r>2</r>3>", "<1" + Fore.RED + "2" + Style.RESET_ALL + "3>"),
            ("</1<r>2</r>3>", "</1" + Fore.RED + "2" + Style.RESET_ALL + "3>"),
            ("<1<r>2 < 3</r>4>", "<1" + Fore.RED + "2 < 3" + Style.RESET_ALL + "4>"),
            ("<1<r>2 </ 3</r>4>", "<1" + Fore.RED + "2 </ 3" + Style.RESET_ALL + "4>"),
            ("<1<r>3 > 2</r>4>", "<1" + Fore.RED + "3 > 2" + Style.RESET_ALL + "4>"),
        ],
    )
    def test_tricky_parse(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '{: </10}\x1b[31m1\x1b[0m'
text       = '{: </10}<r>1</r>'

tests/test_ansimarkup_extended.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b06c1f0>
        strict     = True
        strip      = False
        text       = '{: </10}<r>1</r>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b06c1f0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: r, r

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b06c1f0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="r-10-x1b31m1x1b0m-10">r&gt;{: &gt;10}-\x1b[31m1\x1b[0m{: &gt;10}]</h3>
<details><summary> <pre>r>{: >10}-\x1b[31m1\x1b[0m{: >10}]</pre></summary><pre>
text = '<r>1</r>{: >10}', expected = '\x1b[31m1\x1b[0m{: >10}'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<r>2 > 1</r>", Fore.RED + "2 > 1" + Style.RESET_ALL),
            ("<r>1 < 2</r>", Fore.RED + "1 < 2" + Style.RESET_ALL),
            ("<r>1 </ 2</r>", Fore.RED + "1 </ 2" + Style.RESET_ALL),
            ("{: <10}<r>1</r>", "{: <10}" + Fore.RED + "1" + Style.RESET_ALL),
            ("{: </10}<r>1</r>", "{: </10}" + Fore.RED + "1" + Style.RESET_ALL),
            ("<r>1</r>{: >10}", Fore.RED + "1" + Style.RESET_ALL + "{: >10}"),
            ("<1<r>2</r>3>", "<1" + Fore.RED + "2" + Style.RESET_ALL + "3>"),
            ("</1<r>2</r>3>", "</1" + Fore.RED + "2" + Style.RESET_ALL + "3>"),
            ("<1<r>2 < 3</r>4>", "<1" + Fore.RED + "2 < 3" + Style.RESET_ALL + "4>"),
            ("<1<r>2 </ 3</r>4>", "<1" + Fore.RED + "2 </ 3" + Style.RESET_ALL + "4>"),
            ("<1<r>3 > 2</r>4>", "<1" + Fore.RED + "3 > 2" + Style.RESET_ALL + "4>"),
        ],
    )
    def test_tricky_parse(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '\x1b[31m1\x1b[0m{: >10}'
text       = '<r>1</r>{: >10}'

tests/test_ansimarkup_extended.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b078b50>
        strict     = True
        strip      = False
        text       = '<r>1</r>{: >10}'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b078b50>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: r, r

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b078b50>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="r3-1x1b31m2x1b0m3">r&gt;3&gt;-&lt;1\x1b[31m2\x1b[0m3&gt;]</h3>
<details><summary> <pre>r>3>-<1\x1b[31m2\x1b[0m3>]</pre></summary><pre>
text = '<1<r>2</r>3>', expected = '<1\x1b[31m2\x1b[0m3>'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<r>2 > 1</r>", Fore.RED + "2 > 1" + Style.RESET_ALL),
            ("<r>1 < 2</r>", Fore.RED + "1 < 2" + Style.RESET_ALL),
            ("<r>1 </ 2</r>", Fore.RED + "1 </ 2" + Style.RESET_ALL),
            ("{: <10}<r>1</r>", "{: <10}" + Fore.RED + "1" + Style.RESET_ALL),
            ("{: </10}<r>1</r>", "{: </10}" + Fore.RED + "1" + Style.RESET_ALL),
            ("<r>1</r>{: >10}", Fore.RED + "1" + Style.RESET_ALL + "{: >10}"),
            ("<1<r>2</r>3>", "<1" + Fore.RED + "2" + Style.RESET_ALL + "3>"),
            ("</1<r>2</r>3>", "</1" + Fore.RED + "2" + Style.RESET_ALL + "3>"),
            ("<1<r>2 < 3</r>4>", "<1" + Fore.RED + "2 < 3" + Style.RESET_ALL + "4>"),
            ("<1<r>2 </ 3</r>4>", "<1" + Fore.RED + "2 </ 3" + Style.RESET_ALL + "4>"),
            ("<1<r>3 > 2</r>4>", "<1" + Fore.RED + "3 > 2" + Style.RESET_ALL + "4>"),
        ],
    )
    def test_tricky_parse(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '<1\x1b[31m2\x1b[0m3>'
text       = '<1<r>2</r>3>'

tests/test_ansimarkup_extended.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b0eb2e0>
        strict     = True
        strip      = False
        text       = '<1<r>2</r>3>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b0eb2e0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: r, r

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b0eb2e0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="1x1b31m2x1b0m3">1\x1b[31m2\x1b[0m3&gt;]</h3>
<details><summary> <pre>1\x1b[31m2\x1b[0m3>]</pre></summary><pre>
text = '</1<r>2</r>3>', expected = '</1\x1b[31m2\x1b[0m3>'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<r>2 > 1</r>", Fore.RED + "2 > 1" + Style.RESET_ALL),
            ("<r>1 < 2</r>", Fore.RED + "1 < 2" + Style.RESET_ALL),
            ("<r>1 </ 2</r>", Fore.RED + "1 </ 2" + Style.RESET_ALL),
            ("{: <10}<r>1</r>", "{: <10}" + Fore.RED + "1" + Style.RESET_ALL),
            ("{: </10}<r>1</r>", "{: </10}" + Fore.RED + "1" + Style.RESET_ALL),
            ("<r>1</r>{: >10}", Fore.RED + "1" + Style.RESET_ALL + "{: >10}"),
            ("<1<r>2</r>3>", "<1" + Fore.RED + "2" + Style.RESET_ALL + "3>"),
            ("</1<r>2</r>3>", "</1" + Fore.RED + "2" + Style.RESET_ALL + "3>"),
            ("<1<r>2 < 3</r>4>", "<1" + Fore.RED + "2 < 3" + Style.RESET_ALL + "4>"),
            ("<1<r>2 </ 3</r>4>", "<1" + Fore.RED + "2 </ 3" + Style.RESET_ALL + "4>"),
            ("<1<r>3 > 2</r>4>", "<1" + Fore.RED + "3 > 2" + Style.RESET_ALL + "4>"),
        ],
    )
    def test_tricky_parse(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '</1\x1b[31m2\x1b[0m3>'
text       = '</1<r>2</r>3>'

tests/test_ansimarkup_extended.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b05ac80>
        strict     = True
        strip      = False
        text       = '</1<r>2</r>3>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b05ac80>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: r, r

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b05ac80>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="r4-1x1b31m2-3x1b0m4">r&gt;4&gt;-&lt;1\x1b[31m2 &lt; 3\x1b[0m4&gt;]</h3>
<details><summary> <pre>r>4>-<1\x1b[31m2 < 3\x1b[0m4>]</pre></summary><pre>
text = '<1<r>2 < 3</r>4>', expected = '<1\x1b[31m2 < 3\x1b[0m4>'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<r>2 > 1</r>", Fore.RED + "2 > 1" + Style.RESET_ALL),
            ("<r>1 < 2</r>", Fore.RED + "1 < 2" + Style.RESET_ALL),
            ("<r>1 </ 2</r>", Fore.RED + "1 </ 2" + Style.RESET_ALL),
            ("{: <10}<r>1</r>", "{: <10}" + Fore.RED + "1" + Style.RESET_ALL),
            ("{: </10}<r>1</r>", "{: </10}" + Fore.RED + "1" + Style.RESET_ALL),
            ("<r>1</r>{: >10}", Fore.RED + "1" + Style.RESET_ALL + "{: >10}"),
            ("<1<r>2</r>3>", "<1" + Fore.RED + "2" + Style.RESET_ALL + "3>"),
            ("</1<r>2</r>3>", "</1" + Fore.RED + "2" + Style.RESET_ALL + "3>"),
            ("<1<r>2 < 3</r>4>", "<1" + Fore.RED + "2 < 3" + Style.RESET_ALL + "4>"),
            ("<1<r>2 </ 3</r>4>", "<1" + Fore.RED + "2 </ 3" + Style.RESET_ALL + "4>"),
            ("<1<r>3 > 2</r>4>", "<1" + Fore.RED + "3 > 2" + Style.RESET_ALL + "4>"),
        ],
    )
    def test_tricky_parse(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '<1\x1b[31m2 < 3\x1b[0m4>'
text       = '<1<r>2 < 3</r>4>'

tests/test_ansimarkup_extended.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b5299c0>
        strict     = True
        strip      = False
        text       = '<1<r>2 < 3</r>4>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b5299c0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: r, r

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b5299c0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="3x1b0m4">3\x1b[0m4&gt;]</h3>
<details><summary> <pre> 3\x1b[0m4>]</pre></summary><pre>
text = '<1<r>2 </ 3</r>4>', expected = '<1\x1b[31m2 </ 3\x1b[0m4>'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<r>2 > 1</r>", Fore.RED + "2 > 1" + Style.RESET_ALL),
            ("<r>1 < 2</r>", Fore.RED + "1 < 2" + Style.RESET_ALL),
            ("<r>1 </ 2</r>", Fore.RED + "1 </ 2" + Style.RESET_ALL),
            ("{: <10}<r>1</r>", "{: <10}" + Fore.RED + "1" + Style.RESET_ALL),
            ("{: </10}<r>1</r>", "{: </10}" + Fore.RED + "1" + Style.RESET_ALL),
            ("<r>1</r>{: >10}", Fore.RED + "1" + Style.RESET_ALL + "{: >10}"),
            ("<1<r>2</r>3>", "<1" + Fore.RED + "2" + Style.RESET_ALL + "3>"),
            ("</1<r>2</r>3>", "</1" + Fore.RED + "2" + Style.RESET_ALL + "3>"),
            ("<1<r>2 < 3</r>4>", "<1" + Fore.RED + "2 < 3" + Style.RESET_ALL + "4>"),
            ("<1<r>2 </ 3</r>4>", "<1" + Fore.RED + "2 </ 3" + Style.RESET_ALL + "4>"),
            ("<1<r>3 > 2</r>4>", "<1" + Fore.RED + "3 > 2" + Style.RESET_ALL + "4>"),
        ],
    )
    def test_tricky_parse(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '<1\x1b[31m2 </ 3\x1b[0m4>'
text       = '<1<r>2 </ 3</r>4>'

tests/test_ansimarkup_extended.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac094535e0>
        strict     = True
        strip      = False
        text       = '<1<r>2 </ 3</r>4>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac094535e0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: r, r

self       = <loguru._colorizer.AnsiParser object at 0x7fac094535e0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="r4-1x1b31m3-2x1b0m4">r&gt;4&gt;-&lt;1\x1b[31m3 &gt; 2\x1b[0m4&gt;]</h3>
<details><summary> <pre>r>4>-<1\x1b[31m3 > 2\x1b[0m4>]</pre></summary><pre>
text = '<1<r>3 > 2</r>4>', expected = '<1\x1b[31m3 > 2\x1b[0m4>'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<r>2 > 1</r>", Fore.RED + "2 > 1" + Style.RESET_ALL),
            ("<r>1 < 2</r>", Fore.RED + "1 < 2" + Style.RESET_ALL),
            ("<r>1 </ 2</r>", Fore.RED + "1 </ 2" + Style.RESET_ALL),
            ("{: <10}<r>1</r>", "{: <10}" + Fore.RED + "1" + Style.RESET_ALL),
            ("{: </10}<r>1</r>", "{: </10}" + Fore.RED + "1" + Style.RESET_ALL),
            ("<r>1</r>{: >10}", Fore.RED + "1" + Style.RESET_ALL + "{: >10}"),
            ("<1<r>2</r>3>", "<1" + Fore.RED + "2" + Style.RESET_ALL + "3>"),
            ("</1<r>2</r>3>", "</1" + Fore.RED + "2" + Style.RESET_ALL + "3>"),
            ("<1<r>2 < 3</r>4>", "<1" + Fore.RED + "2 < 3" + Style.RESET_ALL + "4>"),
            ("<1<r>2 </ 3</r>4>", "<1" + Fore.RED + "2 </ 3" + Style.RESET_ALL + "4>"),
            ("<1<r>3 > 2</r>4>", "<1" + Fore.RED + "3 > 2" + Style.RESET_ALL + "4>"),
        ],
    )
    def test_tricky_parse(text, expected):
>       assert parse(text, strip=False) == expected

expected   = '<1\x1b[31m3 > 2\x1b[0m4>'
text       = '<1<r>3 > 2</r>4>'

tests/test_ansimarkup_extended.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b0ccb20>
        strict     = True
        strip      = False
        text       = '<1<r>3 > 2</r>4>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b0ccb20>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: r, r

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b0ccb20>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="fg-ff0000-foobar">fg #ff0000&gt;-foobar]</h3>
<details><summary> <pre>fg #ff0000>-foobar]</pre></summary><pre>
text = '<fg #ff0000>foobar</fg #ff0000>', expected = 'foobar'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<fg #ff0000>foobar</fg #ff0000>", "foobar"),
            ("<fg 55>baz</fg 55>", "baz"),
            ("<bg 23,12,12>bar</bg 23,12,12>", "bar"),
        ],
    )
    def test_strip(text, expected):
>       assert parse(text, strip=True) == expected

expected   = 'foobar'
text       = '<fg #ff0000>foobar</fg #ff0000>'

tests/test_ansimarkup_extended.py:190: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac09411ea0>
        strict     = True
        strip      = True
        text       = '<fg #ff0000>foobar</fg #ff0000>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac09411ea0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: fg #ff0000, fg #ff0000

self       = <loguru._colorizer.AnsiParser object at 0x7fac09411ea0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="fg-55-baz">fg 55&gt;-baz]</h3>
<details><summary> <pre>fg 55>-baz]</pre></summary><pre>
text = '<fg 55>baz</fg 55>', expected = 'baz'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<fg #ff0000>foobar</fg #ff0000>", "foobar"),
            ("<fg 55>baz</fg 55>", "baz"),
            ("<bg 23,12,12>bar</bg 23,12,12>", "bar"),
        ],
    )
    def test_strip(text, expected):
>       assert parse(text, strip=True) == expected

expected   = 'baz'
text       = '<fg 55>baz</fg 55>'

tests/test_ansimarkup_extended.py:190: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0942c160>
        strict     = True
        strip      = True
        text       = '<fg 55>baz</fg 55>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0942c160>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: fg 55, fg 55

self       = <loguru._colorizer.AnsiParser object at 0x7fac0942c160>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="bg-231212-bar">bg 23,12,12&gt;-bar]</h3>
<details><summary> <pre>bg 23,12,12>-bar]</pre></summary><pre>
text = '<bg 23,12,12>bar</bg 23,12,12>', expected = 'bar'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<fg #ff0000>foobar</fg #ff0000>", "foobar"),
            ("<fg 55>baz</fg 55>", "baz"),
            ("<bg 23,12,12>bar</bg 23,12,12>", "bar"),
        ],
    )
    def test_strip(text, expected):
>       assert parse(text, strip=True) == expected

expected   = 'bar'
text       = '<bg 23,12,12>bar</bg 23,12,12>'

tests/test_ansimarkup_extended.py:190: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b0cd8d0>
        strict     = True
        strip      = True
        text       = '<bg 23,12,12>bar</bg 23,12,12>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b0cd8d0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: bg 23,12,12, bg 23,12,12

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b0cd8d0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="r-2-1">r&gt;-2 &gt; 1]</h3>
<details><summary> <pre>r>-2 > 1]</pre></summary><pre>
text = '<r>2 > 1</r>', expected = '2 > 1'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<r>2 > 1</r>", "2 > 1"),
            ("<r>1 < 2</r>", "1 < 2"),
            ("<r>1 </ 2</r>", "1 </ 2"),
            ("{: <10}<r>1</r>", "{: <10}1"),
            ("{: </10}<r>1</r>", "{: </10}1"),
            ("<r>1</r>{: >10}", "1{: >10}"),
            ("<1<r>2</r>3>", "<123>"),
            ("</1<r>2</r>3>", "</123>"),
            ("<1<r>2 < 3</r>4>", "<12 < 34>"),
            ("<1<r>2 </ 3</r>4>", "<12 </ 34>"),
            ("<1<r>3 > 2</r>4>", "<13 > 24>"),
        ],
    )
    def test_tricky_strip(text, expected):
>       assert parse(text, strip=True) == expected

expected   = '2 > 1'
text       = '<r>2 > 1</r>'

tests/test_ansimarkup_extended.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac094c2620>
        strict     = True
        strip      = True
        text       = '<r>2 > 1</r>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac094c2620>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: r, r

self       = <loguru._colorizer.AnsiParser object at 0x7fac094c2620>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="r-1-2">r&gt;-1 &lt; 2]</h3>
<details><summary> <pre>r>-1 < 2]</pre></summary><pre>
text = '<r>1 < 2</r>', expected = '1 < 2'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<r>2 > 1</r>", "2 > 1"),
            ("<r>1 < 2</r>", "1 < 2"),
            ("<r>1 </ 2</r>", "1 </ 2"),
            ("{: <10}<r>1</r>", "{: <10}1"),
            ("{: </10}<r>1</r>", "{: </10}1"),
            ("<r>1</r>{: >10}", "1{: >10}"),
            ("<1<r>2</r>3>", "<123>"),
            ("</1<r>2</r>3>", "</123>"),
            ("<1<r>2 < 3</r>4>", "<12 < 34>"),
            ("<1<r>2 </ 3</r>4>", "<12 </ 34>"),
            ("<1<r>3 > 2</r>4>", "<13 > 24>"),
        ],
    )
    def test_tricky_strip(text, expected):
>       assert parse(text, strip=True) == expected

expected   = '1 < 2'
text       = '<r>1 < 2</r>'

tests/test_ansimarkup_extended.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0c3766b0>
        strict     = True
        strip      = True
        text       = '<r>1 < 2</r>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0c3766b0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: r, r

self       = <loguru._colorizer.AnsiParser object at 0x7fac0c3766b0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="2">2]</h3>
<details><summary> <pre> 2]</pre></summary><pre>
text = '<r>1 </ 2</r>', expected = '1 </ 2'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<r>2 > 1</r>", "2 > 1"),
            ("<r>1 < 2</r>", "1 < 2"),
            ("<r>1 </ 2</r>", "1 </ 2"),
            ("{: <10}<r>1</r>", "{: <10}1"),
            ("{: </10}<r>1</r>", "{: </10}1"),
            ("<r>1</r>{: >10}", "1{: >10}"),
            ("<1<r>2</r>3>", "<123>"),
            ("</1<r>2</r>3>", "</123>"),
            ("<1<r>2 < 3</r>4>", "<12 < 34>"),
            ("<1<r>2 </ 3</r>4>", "<12 </ 34>"),
            ("<1<r>3 > 2</r>4>", "<13 > 24>"),
        ],
    )
    def test_tricky_strip(text, expected):
>       assert parse(text, strip=True) == expected

expected   = '1 </ 2'
text       = '<r>1 </ 2</r>'

tests/test_ansimarkup_extended.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b188dc0>
        strict     = True
        strip      = True
        text       = '<r>1 </ 2</r>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b188dc0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: r, r

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b188dc0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="r-101">r&gt;-{: &lt;10}1]</h3>
<details><summary> <pre>r>-{: <10}1]</pre></summary><pre>
text = '{: <10}<r>1</r>', expected = '{: <10}1'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<r>2 > 1</r>", "2 > 1"),
            ("<r>1 < 2</r>", "1 < 2"),
            ("<r>1 </ 2</r>", "1 </ 2"),
            ("{: <10}<r>1</r>", "{: <10}1"),
            ("{: </10}<r>1</r>", "{: </10}1"),
            ("<r>1</r>{: >10}", "1{: >10}"),
            ("<1<r>2</r>3>", "<123>"),
            ("</1<r>2</r>3>", "</123>"),
            ("<1<r>2 < 3</r>4>", "<12 < 34>"),
            ("<1<r>2 </ 3</r>4>", "<12 </ 34>"),
            ("<1<r>3 > 2</r>4>", "<13 > 24>"),
        ],
    )
    def test_tricky_strip(text, expected):
>       assert parse(text, strip=True) == expected

expected   = '{: <10}1'
text       = '{: <10}<r>1</r>'

tests/test_ansimarkup_extended.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac094114b0>
        strict     = True
        strip      = True
        text       = '{: <10}<r>1</r>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac094114b0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: r, r

self       = <loguru._colorizer.AnsiParser object at 0x7fac094114b0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="101">10}1]</h3>
<details><summary> <pre>10}1]</pre></summary><pre>
text = '{: </10}<r>1</r>', expected = '{: </10}1'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<r>2 > 1</r>", "2 > 1"),
            ("<r>1 < 2</r>", "1 < 2"),
            ("<r>1 </ 2</r>", "1 </ 2"),
            ("{: <10}<r>1</r>", "{: <10}1"),
            ("{: </10}<r>1</r>", "{: </10}1"),
            ("<r>1</r>{: >10}", "1{: >10}"),
            ("<1<r>2</r>3>", "<123>"),
            ("</1<r>2</r>3>", "</123>"),
            ("<1<r>2 < 3</r>4>", "<12 < 34>"),
            ("<1<r>2 </ 3</r>4>", "<12 </ 34>"),
            ("<1<r>3 > 2</r>4>", "<13 > 24>"),
        ],
    )
    def test_tricky_strip(text, expected):
>       assert parse(text, strip=True) == expected

expected   = '{: </10}1'
text       = '{: </10}<r>1</r>'

tests/test_ansimarkup_extended.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0cea4610>
        strict     = True
        strip      = True
        text       = '{: </10}<r>1</r>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0cea4610>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: r, r

self       = <loguru._colorizer.AnsiParser object at 0x7fac0cea4610>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="r-10-1-10">r&gt;{: &gt;10}-1{: &gt;10}]</h3>
<details><summary> <pre>r>{: >10}-1{: >10}]</pre></summary><pre>
text = '<r>1</r>{: >10}', expected = '1{: >10}'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<r>2 > 1</r>", "2 > 1"),
            ("<r>1 < 2</r>", "1 < 2"),
            ("<r>1 </ 2</r>", "1 </ 2"),
            ("{: <10}<r>1</r>", "{: <10}1"),
            ("{: </10}<r>1</r>", "{: </10}1"),
            ("<r>1</r>{: >10}", "1{: >10}"),
            ("<1<r>2</r>3>", "<123>"),
            ("</1<r>2</r>3>", "</123>"),
            ("<1<r>2 < 3</r>4>", "<12 < 34>"),
            ("<1<r>2 </ 3</r>4>", "<12 </ 34>"),
            ("<1<r>3 > 2</r>4>", "<13 > 24>"),
        ],
    )
    def test_tricky_strip(text, expected):
>       assert parse(text, strip=True) == expected

expected   = '1{: >10}'
text       = '<r>1</r>{: >10}'

tests/test_ansimarkup_extended.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b058790>
        strict     = True
        strip      = True
        text       = '<r>1</r>{: >10}'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b058790>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: r, r

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b058790>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="r3-123">r&gt;3&gt;-&lt;123&gt;]</h3>
<details><summary> <pre>r>3>-<123>]</pre></summary><pre>
text = '<1<r>2</r>3>', expected = '<123>'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<r>2 > 1</r>", "2 > 1"),
            ("<r>1 < 2</r>", "1 < 2"),
            ("<r>1 </ 2</r>", "1 </ 2"),
            ("{: <10}<r>1</r>", "{: <10}1"),
            ("{: </10}<r>1</r>", "{: </10}1"),
            ("<r>1</r>{: >10}", "1{: >10}"),
            ("<1<r>2</r>3>", "<123>"),
            ("</1<r>2</r>3>", "</123>"),
            ("<1<r>2 < 3</r>4>", "<12 < 34>"),
            ("<1<r>2 </ 3</r>4>", "<12 </ 34>"),
            ("<1<r>3 > 2</r>4>", "<13 > 24>"),
        ],
    )
    def test_tricky_strip(text, expected):
>       assert parse(text, strip=True) == expected

expected   = '<123>'
text       = '<1<r>2</r>3>'

tests/test_ansimarkup_extended.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b07bd30>
        strict     = True
        strip      = True
        text       = '<1<r>2</r>3>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b07bd30>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: r, r

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b07bd30>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="123">123&gt;]</h3>
<details><summary> <pre>123>]</pre></summary><pre>
text = '</1<r>2</r>3>', expected = '</123>'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<r>2 > 1</r>", "2 > 1"),
            ("<r>1 < 2</r>", "1 < 2"),
            ("<r>1 </ 2</r>", "1 </ 2"),
            ("{: <10}<r>1</r>", "{: <10}1"),
            ("{: </10}<r>1</r>", "{: </10}1"),
            ("<r>1</r>{: >10}", "1{: >10}"),
            ("<1<r>2</r>3>", "<123>"),
            ("</1<r>2</r>3>", "</123>"),
            ("<1<r>2 < 3</r>4>", "<12 < 34>"),
            ("<1<r>2 </ 3</r>4>", "<12 </ 34>"),
            ("<1<r>3 > 2</r>4>", "<13 > 24>"),
        ],
    )
    def test_tricky_strip(text, expected):
>       assert parse(text, strip=True) == expected

expected   = '</123>'
text       = '</1<r>2</r>3>'

tests/test_ansimarkup_extended.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0c376ce0>
        strict     = True
        strip      = True
        text       = '</1<r>2</r>3>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0c376ce0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: r, r

self       = <loguru._colorizer.AnsiParser object at 0x7fac0c376ce0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="r4-12-34">r&gt;4&gt;-&lt;12 &lt; 34&gt;]</h3>
<details><summary> <pre>r>4>-<12 < 34>]</pre></summary><pre>
text = '<1<r>2 < 3</r>4>', expected = '<12 < 34>'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<r>2 > 1</r>", "2 > 1"),
            ("<r>1 < 2</r>", "1 < 2"),
            ("<r>1 </ 2</r>", "1 </ 2"),
            ("{: <10}<r>1</r>", "{: <10}1"),
            ("{: </10}<r>1</r>", "{: </10}1"),
            ("<r>1</r>{: >10}", "1{: >10}"),
            ("<1<r>2</r>3>", "<123>"),
            ("</1<r>2</r>3>", "</123>"),
            ("<1<r>2 < 3</r>4>", "<12 < 34>"),
            ("<1<r>2 </ 3</r>4>", "<12 </ 34>"),
            ("<1<r>3 > 2</r>4>", "<13 > 24>"),
        ],
    )
    def test_tricky_strip(text, expected):
>       assert parse(text, strip=True) == expected

expected   = '<12 < 34>'
text       = '<1<r>2 < 3</r>4>'

tests/test_ansimarkup_extended.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b0169e0>
        strict     = True
        strip      = True
        text       = '<1<r>2 < 3</r>4>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b0169e0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: r, r

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b0169e0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="34">34&gt;]</h3>
<details><summary> <pre> 34>]</pre></summary><pre>
text = '<1<r>2 </ 3</r>4>', expected = '<12 </ 34>'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<r>2 > 1</r>", "2 > 1"),
            ("<r>1 < 2</r>", "1 < 2"),
            ("<r>1 </ 2</r>", "1 </ 2"),
            ("{: <10}<r>1</r>", "{: <10}1"),
            ("{: </10}<r>1</r>", "{: </10}1"),
            ("<r>1</r>{: >10}", "1{: >10}"),
            ("<1<r>2</r>3>", "<123>"),
            ("</1<r>2</r>3>", "</123>"),
            ("<1<r>2 < 3</r>4>", "<12 < 34>"),
            ("<1<r>2 </ 3</r>4>", "<12 </ 34>"),
            ("<1<r>3 > 2</r>4>", "<13 > 24>"),
        ],
    )
    def test_tricky_strip(text, expected):
>       assert parse(text, strip=True) == expected

expected   = '<12 </ 34>'
text       = '<1<r>2 </ 3</r>4>'

tests/test_ansimarkup_extended.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0942faf0>
        strict     = True
        strip      = True
        text       = '<1<r>2 </ 3</r>4>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0942faf0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: r, r

self       = <loguru._colorizer.AnsiParser object at 0x7fac0942faf0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="r4-13-24">r&gt;4&gt;-&lt;13 &gt; 24&gt;]</h3>
<details><summary> <pre>r>4>-<13 > 24>]</pre></summary><pre>
text = '<1<r>3 > 2</r>4>', expected = '<13 > 24>'

    @pytest.mark.parametrize(
        "text, expected",
        [
            ("<r>2 > 1</r>", "2 > 1"),
            ("<r>1 < 2</r>", "1 < 2"),
            ("<r>1 </ 2</r>", "1 </ 2"),
            ("{: <10}<r>1</r>", "{: <10}1"),
            ("{: </10}<r>1</r>", "{: </10}1"),
            ("<r>1</r>{: >10}", "1{: >10}"),
            ("<1<r>2</r>3>", "<123>"),
            ("</1<r>2</r>3>", "</123>"),
            ("<1<r>2 < 3</r>4>", "<12 < 34>"),
            ("<1<r>2 </ 3</r>4>", "<12 </ 34>"),
            ("<1<r>3 > 2</r>4>", "<13 > 24>"),
        ],
    )
    def test_tricky_strip(text, expected):
>       assert parse(text, strip=True) == expected

expected   = '<13 > 24>'
text       = '<1<r>3 > 2</r>4>'

tests/test_ansimarkup_extended.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0b014820>
        strict     = True
        strip      = True
        text       = '<1<r>3 > 2</r>4>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0b014820>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: r, r

self       = <loguru._colorizer.AnsiParser object at 0x7fac0b014820>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="test_bindpytest_bind_after_add">test_bind.py::test_bind_after_add</h3>
<details><summary> <pre>test_bind.py::test_bind_after_add</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac09584940>

    def test_bind_after_add(writer):
        logger.add(writer, format="{extra[a]} {message}")
        logger_bound = logger.bind(a=0)
>       logger_bound.debug("A")
E       AttributeError: 'NoneType' object has no attribute 'debug'

logger_bound = None
writer     = <function writer.<locals>.w at 0x7fac09584940>

tests/test_bind.py:9: AttributeError
</pre>
</details>
<h3 id="test_bindpytest_bind_before_add">test_bind.py::test_bind_before_add</h3>
<details><summary> <pre>test_bind.py::test_bind_before_add</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac09585ab0>

    def test_bind_before_add(writer):
        logger_bound = logger.bind(a=0)
        logger.add(writer, format="{extra[a]} {message}")
>       logger_bound.debug("A")
E       AttributeError: 'NoneType' object has no attribute 'debug'

logger_bound = None
writer     = <function writer.<locals>.w at 0x7fac09585ab0>

tests/test_bind.py:17: AttributeError
</pre>
</details>
<h3 id="test_bindpytest_add_using_bound">test_bind.py::test_add_using_bound</h3>
<details><summary> <pre>test_bind.py::test_add_using_bound</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac09585870>

    def test_add_using_bound(writer):
        logger.configure(extra={"a": -1})
        logger_bound = logger.bind(a=0)
>       logger_bound.add(writer, format="{extra[a]} {message}")
E       AttributeError: 'NoneType' object has no attribute 'add'

logger_bound = None
writer     = <function writer.<locals>.w at 0x7fac09585870>

tests/test_bind.py:25: AttributeError
</pre>
</details>
<h3 id="test_bindpytest_not_override_parent_logger">test_bind.py::test_not_override_parent_logger</h3>
<details><summary> <pre>test_bind.py::test_not_override_parent_logger</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac09585cf0>

    def test_not_override_parent_logger(writer):
        logger_1 = logger.bind(a="a")
>       logger_2 = logger_1.bind(a="A")
E       AttributeError: 'NoneType' object has no attribute 'bind'

logger_1   = None
writer     = <function writer.<locals>.w at 0x7fac09585cf0>

tests/test_bind.py:34: AttributeError
</pre>
</details>
<h3 id="test_bindpytest_override_previous_bound">test_bind.py::test_override_previous_bound</h3>
<details><summary> <pre>test_bind.py::test_override_previous_bound</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac09585e10>

    def test_override_previous_bound(writer):
        logger.add(writer, format="{extra[x]} {message}")
>       logger.bind(x=1).bind(x=2).debug("3")
E       AttributeError: 'NoneType' object has no attribute 'bind'

writer     = <function writer.<locals>.w at 0x7fac09585e10>

tests/test_bind.py:45: AttributeError
</pre>
</details>
<h3 id="test_bindpytest_no_conflict">test_bind.py::test_no_conflict</h3>
<details><summary> <pre>test_bind.py::test_no_conflict</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac09586050>

    def test_no_conflict(writer):
        logger_ = logger.bind()
>       logger_2 = logger_.bind(a=2)
E       AttributeError: 'NoneType' object has no attribute 'bind'

logger_    = None
writer     = <function writer.<locals>.w at 0x7fac09586050>

tests/test_bind.py:51: AttributeError
</pre>
</details>
<h3 id="test_bindpytest_bind_and_add_leveltrue">test_bind.py::test_bind_and_add_level[True]</h3>
<details><summary> <pre>test_bind.py::test_bind_and_add_level[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac09586290>, using_bound = True

    @pytest.mark.parametrize("using_bound", [True, False])
    def test_bind_and_add_level(writer, using_bound):
        logger_bound = logger.bind()
        logger.add(writer, format="{level.name} {message}")

        if using_bound:
>           logger_bound.level("bar", 15)
E           AttributeError: 'NoneType' object has no attribute 'level'

logger_bound = None
using_bound = True
writer     = <function writer.<locals>.w at 0x7fac09586290>

tests/test_bind.py:68: AttributeError
</pre>
</details>
<h3 id="test_bindpytest_bind_and_add_levelfalse">test_bind.py::test_bind_and_add_level[False]</h3>
<details><summary> <pre>test_bind.py::test_bind_and_add_level[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac095864d0>, using_bound = False

    @pytest.mark.parametrize("using_bound", [True, False])
    def test_bind_and_add_level(writer, using_bound):
        logger_bound = logger.bind()
        logger.add(writer, format="{level.name} {message}")

        if using_bound:
            logger_bound.level("bar", 15)
        else:
            logger.level("bar", 15)

        logger.log("bar", "root")
>       logger_bound.log("bar", "bound")
E       AttributeError: 'NoneType' object has no attribute 'log'

logger_bound = None
using_bound = False
writer     = <function writer.<locals>.w at 0x7fac095864d0>

tests/test_bind.py:73: AttributeError
</pre>
</details>
<h3 id="test_bindpytest_override_configured">test_bind.py::test_override_configured</h3>
<details><summary> <pre>test_bind.py::test_override_configured</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac09586710>

    def test_override_configured(writer):
        logger.configure(extra={"a": 1})
        logger2 = logger.bind(a=2)

>       logger2.add(writer, format="{extra[a]} {message}")
E       AttributeError: 'NoneType' object has no attribute 'add'

logger2    = None
writer     = <function writer.<locals>.w at 0x7fac09586710>

tests/test_bind.py:82: AttributeError
</pre>
</details>
<h3 id="test_coloramapytest_pycharm_fixedstdout-true">test_colorama.py::test_pycharm_fixed[<strong>stdout</strong>-True]</h3>
<details><summary> <pre>test_colorama.py::test_pycharm_fixed[__stdout__-True]</pre></summary><pre>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0dbce0e0>
patched = '__stdout__', expected = True

    @pytest.mark.parametrize(
        "patched, expected",
        [
            ("__stdout__", True),
            ("__stderr__", True),
            ("stdout", False),
            ("stderr", False),
            ("", False),
        ],
    )
    def test_pycharm_fixed(monkeypatch, patched, expected):
        stream = StreamIsattyFalse()
        monkeypatch.setattr(sys, patched, stream, raising=False)
        monkeypatch.setitem(os.environ, "PYCHARM_HOSTED", "1")
>       assert should_colorize(stream) is expected
E       assert False is True
E        +  where False = should_colorize(<tests.conftest.StreamIsattyFalse object at 0x7fac09586dd0>)

expected   = True
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0dbce0e0>
patched    = '__stdout__'
stream     = <tests.conftest.StreamIsattyFalse object at 0x7fac09586dd0>

tests/test_colorama.py:92: AssertionError
</pre>
</details>
<h3 id="test_coloramapytest_pycharm_fixedstderr-true">test_colorama.py::test_pycharm_fixed[<strong>stderr</strong>-True]</h3>
<details><summary> <pre>test_colorama.py::test_pycharm_fixed[__stderr__-True]</pre></summary><pre>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0dbcdea0>
patched = '__stderr__', expected = True

    @pytest.mark.parametrize(
        "patched, expected",
        [
            ("__stdout__", True),
            ("__stderr__", True),
            ("stdout", False),
            ("stderr", False),
            ("", False),
        ],
    )
    def test_pycharm_fixed(monkeypatch, patched, expected):
        stream = StreamIsattyFalse()
        monkeypatch.setattr(sys, patched, stream, raising=False)
        monkeypatch.setitem(os.environ, "PYCHARM_HOSTED", "1")
>       assert should_colorize(stream) is expected
E       assert False is True
E        +  where False = should_colorize(<tests.conftest.StreamIsattyFalse object at 0x7fac09585f30>)

expected   = True
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0dbcdea0>
patched    = '__stderr__'
stream     = <tests.conftest.StreamIsattyFalse object at 0x7fac09585f30>

tests/test_colorama.py:92: AssertionError
</pre>
</details>
<h3 id="test_coloramapytest_github_actions_fixedstdout-true">test_colorama.py::test_github_actions_fixed[<strong>stdout</strong>-True]</h3>
<details><summary> <pre>test_colorama.py::test_github_actions_fixed[__stdout__-True]</pre></summary><pre>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac09412c80>
patched = '__stdout__', expected = True

    @pytest.mark.parametrize(
        "patched, expected",
        [
            ("__stdout__", True),
            ("__stderr__", True),
            ("stdout", False),
            ("stderr", False),
            ("", False),
        ],
    )
    def test_github_actions_fixed(monkeypatch, patched, expected):
        stream = StreamIsattyFalse()
        monkeypatch.setitem(os.environ, "CI", "1")
        monkeypatch.setitem(os.environ, "GITHUB_ACTIONS", "1")
        monkeypatch.setattr(sys, patched, stream, raising=False)
>       assert should_colorize(stream) is expected
E       assert False is True
E        +  where False = should_colorize(<tests.conftest.StreamIsattyFalse object at 0x7fac09585750>)

expected   = True
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac09412c80>
patched    = '__stdout__'
stream     = <tests.conftest.StreamIsattyFalse object at 0x7fac09585750>

tests/test_colorama.py:110: AssertionError
</pre>
</details>
<h3 id="test_coloramapytest_github_actions_fixedstderr-true">test_colorama.py::test_github_actions_fixed[<strong>stderr</strong>-True]</h3>
<details><summary> <pre>test_colorama.py::test_github_actions_fixed[__stderr__-True]</pre></summary><pre>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0b0cc3a0>
patched = '__stderr__', expected = True

    @pytest.mark.parametrize(
        "patched, expected",
        [
            ("__stdout__", True),
            ("__stderr__", True),
            ("stdout", False),
            ("stderr", False),
            ("", False),
        ],
    )
    def test_github_actions_fixed(monkeypatch, patched, expected):
        stream = StreamIsattyFalse()
        monkeypatch.setitem(os.environ, "CI", "1")
        monkeypatch.setitem(os.environ, "GITHUB_ACTIONS", "1")
        monkeypatch.setattr(sys, patched, stream, raising=False)
>       assert should_colorize(stream) is expected
E       assert False is True
E        +  where False = should_colorize(<tests.conftest.StreamIsattyFalse object at 0x7fac095865f0>)

expected   = True
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0b0cc3a0>
patched    = '__stderr__'
stream     = <tests.conftest.StreamIsattyFalse object at 0x7fac095865f0>

tests/test_colorama.py:110: AssertionError
</pre>
</details>
<h3 id="test_coloramapytest_jupyter_fixedstdout-streamisattyfalse-true">test_colorama.py::test_jupyter_fixed[stdout-StreamIsattyFalse-True]</h3>
<details><summary> <pre>test_colorama.py::test_jupyter_fixed[stdout-StreamIsattyFalse-True]</pre></summary><pre>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0942e3e0>
patched = 'stdout', out_class = <class 'tests.conftest.StreamIsattyFalse'>
expected = True

    @pytest.mark.parametrize(
        "patched, out_class, expected",
        [
            ("stdout", StreamIsattyFalse, True),
            ("stderr", StreamIsattyFalse, True),
            ("__stdout__", StreamIsattyFalse, False),
            ("__stderr__", StreamIsattyFalse, False),
            ("stdout", StreamIsattyTrue, False),
            ("stderr", StreamIsattyTrue, False),
            ("", StreamIsattyFalse, False),
        ],
    )
    def test_jupyter_fixed(monkeypatch, patched, out_class, expected):
        stream = StreamIsattyFalse()

        class Shell:
            pass

        ipython = MagicMock()
        ipykernel = MagicMock()
        instance = MagicMock()
        instance.__class__ = Shell
        ipython.get_ipython.return_value = instance
        ipykernel.zmqshell.ZMQInteractiveShell = Shell
        ipykernel.iostream.OutStream = out_class

        monkeypatch.setitem(sys.modules, "IPython", ipython)
        monkeypatch.setitem(sys.modules, "ipykernel", ipykernel)
        monkeypatch.setattr(sys, patched, stream, raising=False)

>       assert should_colorize(stream) is expected
E       assert False is True
E        +  where False = should_colorize(<tests.conftest.StreamIsattyFalse object at 0x7fac09585870>)

Shell      = <class 'tests.test_colorama.test_jupyter_fixed.<locals>.Shell'>
expected   = True
instance   = <MagicMock name='mock.get_ipython()' spec='Shell' id='140376866647984'>
ipykernel  = <MagicMock id='140376866632848'>
ipython    = <MagicMock id='140376866486832'>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0942e3e0>
out_class  = <class 'tests.conftest.StreamIsattyFalse'>
patched    = 'stdout'
stream     = <tests.conftest.StreamIsattyFalse object at 0x7fac09585870>

tests/test_colorama.py:179: AssertionError
</pre>
</details>
<h3 id="test_coloramapytest_jupyter_fixedstderr-streamisattyfalse-true">test_colorama.py::test_jupyter_fixed[stderr-StreamIsattyFalse-True]</h3>
<details><summary> <pre>test_colorama.py::test_jupyter_fixed[stderr-StreamIsattyFalse-True]</pre></summary><pre>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0942c070>
patched = 'stderr', out_class = <class 'tests.conftest.StreamIsattyFalse'>
expected = True

    @pytest.mark.parametrize(
        "patched, out_class, expected",
        [
            ("stdout", StreamIsattyFalse, True),
            ("stderr", StreamIsattyFalse, True),
            ("__stdout__", StreamIsattyFalse, False),
            ("__stderr__", StreamIsattyFalse, False),
            ("stdout", StreamIsattyTrue, False),
            ("stderr", StreamIsattyTrue, False),
            ("", StreamIsattyFalse, False),
        ],
    )
    def test_jupyter_fixed(monkeypatch, patched, out_class, expected):
        stream = StreamIsattyFalse()

        class Shell:
            pass

        ipython = MagicMock()
        ipykernel = MagicMock()
        instance = MagicMock()
        instance.__class__ = Shell
        ipython.get_ipython.return_value = instance
        ipykernel.zmqshell.ZMQInteractiveShell = Shell
        ipykernel.iostream.OutStream = out_class

        monkeypatch.setitem(sys.modules, "IPython", ipython)
        monkeypatch.setitem(sys.modules, "ipykernel", ipykernel)
        monkeypatch.setattr(sys, patched, stream, raising=False)

>       assert should_colorize(stream) is expected
E       assert False is True
E        +  where False = should_colorize(<tests.conftest.StreamIsattyFalse object at 0x7fac09584940>)

Shell      = <class 'tests.test_colorama.test_jupyter_fixed.<locals>.Shell'>
expected   = True
instance   = <MagicMock name='mock.get_ipython()' spec='Shell' id='140376896503760'>
ipykernel  = <MagicMock id='140376896098352'>
ipython    = <MagicMock id='140376896096000'>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0942c070>
out_class  = <class 'tests.conftest.StreamIsattyFalse'>
patched    = 'stderr'
stream     = <tests.conftest.StreamIsattyFalse object at 0x7fac09584940>

tests/test_colorama.py:179: AssertionError
</pre>
</details>
<h3 id="test_coloramapytest_dont_wrap_on_linuxstdout">test_colorama.py::test_dont_wrap_on_linux[<strong>stdout</strong>]</h3>
<details><summary> <pre>test_colorama.py::test_dont_wrap_on_linux[__stdout__]</pre></summary><pre>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0b0e9c90>
patched = '__stdout__', patch_colorama = <MagicMock id='140376865296576'>

    @pytest.mark.parametrize("patched", ["__stdout__", "__stderr__"])
    @pytest.mark.skipif(os.name == "nt", reason="Colorama is required on Windows")
    def test_dont_wrap_on_linux(monkeypatch, patched, patch_colorama):
        stream = StreamIsattyTrue()
        monkeypatch.setattr(sys, patched, stream, raising=False)
>       assert not should_wrap(stream)
E       assert not True
E        +  where True = should_wrap(<tests.conftest.StreamIsattyTrue object at 0x7fac0b1fe290>)

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0b0e9c90>
patch_colorama = <MagicMock id='140376865296576'>
patched    = '__stdout__'
stream     = <tests.conftest.StreamIsattyTrue object at 0x7fac0b1fe290>

tests/test_colorama.py:187: AssertionError
</pre>
</details>
<h3 id="test_coloramapytest_dont_wrap_on_linuxstderr">test_colorama.py::test_dont_wrap_on_linux[<strong>stderr</strong>]</h3>
<details><summary> <pre>test_colorama.py::test_dont_wrap_on_linux[__stderr__]</pre></summary><pre>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0936ca00>
patched = '__stderr__', patch_colorama = <MagicMock id='140376865283792'>

    @pytest.mark.parametrize("patched", ["__stdout__", "__stderr__"])
    @pytest.mark.skipif(os.name == "nt", reason="Colorama is required on Windows")
    def test_dont_wrap_on_linux(monkeypatch, patched, patch_colorama):
        stream = StreamIsattyTrue()
        monkeypatch.setattr(sys, patched, stream, raising=False)
>       assert not should_wrap(stream)
E       assert not True
E        +  where True = should_wrap(<tests.conftest.StreamIsattyTrue object at 0x7fac09585c60>)

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0936ca00>
patch_colorama = <MagicMock id='140376865283792'>
patched    = '__stderr__'
stream     = <tests.conftest.StreamIsattyTrue object at 0x7fac09585c60>

tests/test_colorama.py:187: AssertionError
</pre>
</details>
<h3 id="test_configurepytest_handlers">test_configure.py::test_handlers</h3>
<details><summary> <pre>test_configure.py::test_handlers</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b188790>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_handlers0')

    def test_handlers(capsys, tmp_path):
        file = tmp_path / "test.log"

        handlers = [
            {"sink": file, "format": "FileSink: {message}"},
            {"sink": sys.stdout, "format": "StdoutSink: {message}"},
        ]

        logger.configure(handlers=handlers)
        logger.debug("test")

        out, err = capsys.readouterr()

>       assert file.read_text() == "FileSink: test\n"

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b188790>
err        = ''
file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_handlers0/test.log')
handlers   = [{'format': 'FileSink: {message}', 'sink': PosixPath('/tmp/pytest-of-root/pytest-0/test_handlers0/test.log')}, {'format': 'StdoutSink: {message}', 'sink': <_io.TextIOWrapper encoding='UTF-8'>}]
out        = ''
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_handlers0')

tests/test_configure.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_handlers0/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_handlers0/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_handlers0/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_handlers0/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_configurepytest_levels">test_configure.py::test_levels</h3>
<details><summary> <pre>test_configure.py::test_levels</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac09584d30>

    def test_levels(writer):
        levels = [{"name": "my_level", "icon": "X", "no": 12}, {"name": "DEBUG", "icon": "!"}]

        logger.add(writer, format="{level.no}|{level.name}|{level.icon}|{message}")
        logger.configure(levels=levels)

        logger.log("my_level", "test")
        logger.debug("no bug")

>       assert writer.read() == ("12|my_level|X|test\n" "10|DEBUG|!|no bug\n")
E       AssertionError: assert '' == '12|my_level|...UG|!|no bug\n'
E         
E         - 12|my_level|X|test
E         - 10|DEBUG|!|no bug

levels     = [{'icon': 'X', 'name': 'my_level', 'no': 12}, {'icon': '!', 'name': 'DEBUG'}]
writer     = <function writer.<locals>.w at 0x7fac09584d30>

tests/test_configure.py:35: AssertionError
</pre>
</details>
<h3 id="test_configurepytest_extra">test_configure.py::test_extra</h3>
<details><summary> <pre>test_configure.py::test_extra</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac09587490>

    def test_extra(writer):
        extra = {"a": 1, "b": 9}

        logger.add(writer, format="{extra[a]} {extra[b]}")
        logger.configure(extra=extra)

        logger.debug("")

>       assert writer.read() == "1 9\n"
E       AssertionError: assert '' == '1 9\n'
E         
E         - 1 9

extra      = {'a': 1, 'b': 9}
writer     = <function writer.<locals>.w at 0x7fac09587490>

tests/test_configure.py:46: AssertionError
</pre>
</details>
<h3 id="test_configurepytest_patcher">test_configure.py::test_patcher</h3>
<details><summary> <pre>test_configure.py::test_patcher</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac095869e0>

    def test_patcher(writer):
        logger.add(writer, format="{extra[a]} {extra[b]}")
        logger.configure(patcher=lambda record: record["extra"].update(a=1, b=2))

        logger.debug("")

>       assert writer.read() == "1 2\n"
E       AssertionError: assert '' == '1 2\n'
E         
E         - 1 2

writer     = <function writer.<locals>.w at 0x7fac095869e0>

tests/test_configure.py:55: AssertionError
</pre>
</details>
<h3 id="test_configurepytest_activation">test_configure.py::test_activation</h3>
<details><summary> <pre>test_configure.py::test_activation</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac09585870>

    def test_activation(writer):
        activation = [("tests", False), ("tests.test_configure", True)]

        logger.add(writer, format="{message}")
        logger.configure(activation=activation)

        logger.debug("Logging")

>       assert writer.read() == "Logging\n"
E       AssertionError: assert '' == 'Logging\n'
E         
E         - Logging

activation = [('tests', False), ('tests.test_configure', True)]
writer     = <function writer.<locals>.w at 0x7fac09585870>

tests/test_configure.py:66: AssertionError
</pre>
</details>
<h3 id="test_configurepytest_dict_unpacking">test_configure.py::test_dict_unpacking</h3>
<details><summary> <pre>test_configure.py::test_dict_unpacking</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac09587760>

    def test_dict_unpacking(writer):
        config = {
            "handlers": [{"sink": writer, "format": "{level.no} - {extra[x]} {extra[z]} - {message}"}],
            "levels": [{"name": "test", "no": 30}],
            "extra": {"x": 1, "y": 2, "z": 3},
        }

        logger.debug("NOPE")

        logger.configure(**config)

        logger.log("test", "Yes!")

>       assert writer.read() == "30 - 1 3 - Yes!\n"
E       AssertionError: assert '' == '30 - 1 3 - Yes!\n'
E         
E         - 30 - 1 3 - Yes!

config     = {'extra': {'x': 1, 'y': 2, 'z': 3}, 'handlers': [{'format': '{level.no} - {extra[x]} {extra[z]} - {message}', 'sink': <function writer.<locals>.w at 0x7fac09587760>}], 'levels': [{'name': 'test', 'no': 30}]}
writer     = <function writer.<locals>.w at 0x7fac09587760>

tests/test_configure.py:82: AssertionError
</pre>
</details>
<h3 id="test_configurepytest_returned_ids">test_configure.py::test_returned_ids</h3>
<details><summary> <pre>test_configure.py::test_returned_ids</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b081030>

    def test_returned_ids(capsys):
        ids = logger.configure(
            handlers=[
                {"sink": sys.stdout, "format": "{message}"},
                {"sink": sys.stderr, "format": "{message}"},
            ]
        )

>       assert len(ids) == 2
E       TypeError: object of type 'NoneType' has no len()

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b081030>
ids        = None

tests/test_configure.py:93: TypeError
</pre>
</details>
<h3 id="test_configurepytest_dont_reset_by_default">test_configure.py::test_dont_reset_by_default</h3>
<details><summary> <pre>test_configure.py::test_dont_reset_by_default</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac09587d90>

    def test_dont_reset_by_default(writer):
        logger.configure(extra={"a": 1}, patcher=lambda r: r["extra"].update(b=2))
        logger.level("b", no=30)
        logger.add(writer, format="{level} {extra[a]} {extra[b]} {message}")

        logger.configure()

        logger.log("b", "Test")

>       assert writer.read() == "b 1 2 Test\n"
E       AssertionError: assert '' == 'b 1 2 Test\n'
E         
E         - b 1 2 Test

writer     = <function writer.<locals>.w at 0x7fac09587d90>

tests/test_configure.py:122: AssertionError
</pre>
</details>
<h3 id="test_configurepytest_reset_previous_extra">test_configure.py::test_reset_previous_extra</h3>
<details><summary> <pre>test_configure.py::test_reset_previous_extra</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac09587ac0>

    def test_reset_previous_extra(writer):
        logger.configure(extra={"a": 123})
        logger.add(writer, format="{extra[a]}", catch=False)

        logger.configure(extra={})

>       with pytest.raises(KeyError):
E       Failed: DID NOT RAISE <class 'KeyError'>

writer     = <function writer.<locals>.w at 0x7fac09587ac0>

tests/test_configure.py:141: Failed
</pre>
</details>
<h3 id="test_configurepytest_reset_previous_patcher">test_configure.py::test_reset_previous_patcher</h3>
<details><summary> <pre>test_configure.py::test_reset_previous_patcher</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac095879a0>

    def test_reset_previous_patcher(writer):
        logger.configure(patcher=lambda r: r.update(a=123))
        logger.add(writer, format="{extra[a]}", catch=False)

        logger.configure(patcher=lambda r: None)

>       with pytest.raises(KeyError):
E       Failed: DID NOT RAISE <class 'KeyError'>

writer     = <function writer.<locals>.w at 0x7fac095879a0>

tests/test_configure.py:151: Failed
</pre>
</details>
<h3 id="test_configurepytest_dont_reset_previous_levels">test_configure.py::test_dont_reset_previous_levels</h3>
<details><summary> <pre>test_configure.py::test_dont_reset_previous_levels</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac09587490>

    def test_dont_reset_previous_levels(writer):
        logger.level("abc", no=30)

        logger.configure(levels=[])

        logger.add(writer, format="{level} {message}")

        logger.log("abc", "Test")

>       assert writer.read() == "abc Test\n"
E       AssertionError: assert '' == 'abc Test\n'
E         
E         - abc Test

writer     = <function writer.<locals>.w at 0x7fac09587490>

tests/test_configure.py:164: AssertionError
</pre>
</details>
<h3 id="test_configurepytest_configure_handler_using_new_level">test_configure.py::test_configure_handler_using_new_level</h3>
<details><summary> <pre>test_configure.py::test_configure_handler_using_new_level</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac093f8160>

    def test_configure_handler_using_new_level(writer):
        logger.configure(
            levels=[{"name": "CONF_LVL", "no": 33, "icon": "", "color": ""}],
            handlers=[
                {"sink": writer, "level": "CONF_LVL", "format": "{level.name} {level.no} {message}"}
            ],
        )

        logger.log("CONF_LVL", "Custom")
>       assert writer.read() == "CONF_LVL 33 Custom\n"
E       AssertionError: assert '' == 'CONF_LVL 33 Custom\n'
E         
E         - CONF_LVL 33 Custom

writer     = <function writer.<locals>.w at 0x7fac093f8160>

tests/test_configure.py:176: AssertionError
</pre>
</details>
<h3 id="test_configurepytest_configure_filter_using_new_level">test_configure.py::test_configure_filter_using_new_level</h3>
<details><summary> <pre>test_configure.py::test_configure_filter_using_new_level</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac09584d30>

    def test_configure_filter_using_new_level(writer):
        logger.configure(
            levels=[{"name": "CONF_LVL_2", "no": 33, "icon": "", "color": ""}],
            handlers=[
                {"sink": writer, "level": 0, "filter": {"tests": "CONF_LVL_2"}, "format": "{message}"}
            ],
        )

        logger.log("CONF_LVL_2", "Custom")
>       assert writer.read() == "Custom\n"
E       AssertionError: assert '' == 'Custom\n'
E         
E         - Custom

writer     = <function writer.<locals>.w at 0x7fac09584d30>

tests/test_configure.py:188: AssertionError
</pre>
</details>
<h3 id="test_configurepytest_configure_before_bind">test_configure.py::test_configure_before_bind</h3>
<details><summary> <pre>test_configure.py::test_configure_before_bind</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac09587910>

    def test_configure_before_bind(writer):
        logger.configure(extra={"a": "default_a", "b": "default_b"})
        logger.add(writer, format="{extra[a]} {extra[b]} {message}")

        logger.debug("init")

        logger_a = logger.bind(a="A")
        logger_b = logger.bind(b="B")

>       logger_a.debug("aaa")
E       AttributeError: 'NoneType' object has no attribute 'debug'

logger_a   = None
logger_b   = None
writer     = <function writer.<locals>.w at 0x7fac09587910>

tests/test_configure.py:200: AttributeError
</pre>
</details>
<h3 id="test_configurepytest_configure_after_bind">test_configure.py::test_configure_after_bind</h3>
<details><summary> <pre>test_configure.py::test_configure_after_bind</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac09587370>

    def test_configure_after_bind(writer):
        logger_a = logger.bind(a="A")
        logger_b = logger.bind(b="B")

        logger.configure(extra={"a": "default_a", "b": "default_b"})
        logger.add(writer, format="{extra[a]} {extra[b]} {message}")

        logger.debug("init")

>       logger_a.debug("aaa")
E       AttributeError: 'NoneType' object has no attribute 'debug'

logger_a   = None
logger_b   = None
writer     = <function writer.<locals>.w at 0x7fac09587370>

tests/test_configure.py:215: AttributeError
</pre>
</details>
<h3 id="test_contextualizepytest_contextualize">test_contextualize.py::test_contextualize</h3>
<details><summary> <pre>test_contextualize.py::test_contextualize</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac095877f0>

    def test_contextualize(writer):
        logger.add(writer, format="{message} {extra[foo]} {extra[baz]}")

>       with logger.contextualize(foo="bar", baz=123):

writer     = <function writer.<locals>.w at 0x7fac095877f0>

tests/test_contextualize.py:15: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <contextlib._GeneratorContextManager object at 0x7fac0bda9690>

    def __enter__(self):
        # do not keep args and kwds alive unnecessarily
        # they are only needed for recreation, which is not possible anymore
        del self.args, self.kwds, self.func
        try:
>           return next(self.gen)
E           TypeError: 'NoneType' object is not an iterator

self       = <contextlib._GeneratorContextManager object at 0x7fac0bda9690>

/usr/lib/python3.10/contextlib.py:135: TypeError
</pre>
</details>
<h3 id="test_contextualizepytest_contextualize_as_decorator">test_contextualize.py::test_contextualize_as_decorator</h3>
<details><summary> <pre>test_contextualize.py::test_contextualize_as_decorator</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac09587880>

    def test_contextualize_as_decorator(writer):
        logger.add(writer, format="{message} {extra[foo]} {extra[baz]}")

        @logger.contextualize(foo=123, baz="bar")
        def task():
            logger.info("Contextualized")

>       task()

task       = <function test_contextualize_as_decorator.<locals>.task at 0x7fac09587ac0>
writer     = <function writer.<locals>.w at 0x7fac09587880>

tests/test_contextualize.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:78: in inner
    with self._recreate_cm():
        args       = ()
        func       = <function test_contextualize_as_decorator.<locals>.task at 0x7fac09587370>
        kwds       = {}
        self       = <contextlib._GeneratorContextManager object at 0x7fac0930d120>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <contextlib._GeneratorContextManager object at 0x7fac0930f670>

    def __enter__(self):
        # do not keep args and kwds alive unnecessarily
        # they are only needed for recreation, which is not possible anymore
        del self.args, self.kwds, self.func
        try:
>           return next(self.gen)
E           TypeError: 'NoneType' object is not an iterator

self       = <contextlib._GeneratorContextManager object at 0x7fac0930f670>

/usr/lib/python3.10/contextlib.py:135: TypeError
</pre>
</details>
<h3 id="test_contextualizepytest_contextualize_in_function">test_contextualize.py::test_contextualize_in_function</h3>
<details><summary> <pre>test_contextualize.py::test_contextualize_in_function</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac09587c70>

    def test_contextualize_in_function(writer):
        logger.add(writer, format="{message} {extra}")

        def foobar():
            logger.info("Foobar!")

>       with logger.contextualize(foobar="baz"):

foobar     = <function test_contextualize_in_function.<locals>.foobar at 0x7fac09585c60>
writer     = <function writer.<locals>.w at 0x7fac09587c70>

tests/test_contextualize.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <contextlib._GeneratorContextManager object at 0x7fac0936d660>

    def __enter__(self):
        # do not keep args and kwds alive unnecessarily
        # they are only needed for recreation, which is not possible anymore
        del self.args, self.kwds, self.func
        try:
>           return next(self.gen)
E           TypeError: 'NoneType' object is not an iterator

self       = <contextlib._GeneratorContextManager object at 0x7fac0936d660>

/usr/lib/python3.10/contextlib.py:135: TypeError
</pre>
</details>
<h3 id="test_contextualizepytest_contextualize_reset">test_contextualize.py::test_contextualize_reset</h3>
<details><summary> <pre>test_contextualize.py::test_contextualize_reset</pre></summary><pre>
def test_contextualize_reset():
        contexts = []
        output = []

        def sink(message):
            contexts.append(message.record["extra"])
            output.append(str(message))

        logger.add(sink, format="{level} {message}")

        logger.info("A")

>       with logger.contextualize(abc="def"):

contexts   = []
output     = []
sink       = <function test_contextualize_reset.<locals>.sink at 0x7fac09585bd0>

tests/test_contextualize.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <contextlib._GeneratorContextManager object at 0x7fac0942ed40>

    def __enter__(self):
        # do not keep args and kwds alive unnecessarily
        # they are only needed for recreation, which is not possible anymore
        del self.args, self.kwds, self.func
        try:
>           return next(self.gen)
E           TypeError: 'NoneType' object is not an iterator

self       = <contextlib._GeneratorContextManager object at 0x7fac0942ed40>

/usr/lib/python3.10/contextlib.py:135: TypeError
</pre>
</details>
<h3 id="test_contextualizepytest_contextualize_async">test_contextualize.py::test_contextualize_async</h3>
<details><summary> <pre>test_contextualize.py::test_contextualize_async</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac093f8af0>

    @pytest.mark.xfail(sys.version_info < (3, 5, 3), reason="ContextVar backport not supported")
    def test_contextualize_async(writer):
        logger.add(writer, format="{message} {extra[i]}", catch=False)

        async def task():
            logger.info("Start")
            await asyncio.sleep(0.1)
            logger.info("End")

        async def worker(i):
            with logger.contextualize(i=i):
                await task()

        async def main():
            workers = [worker(i) for i in range(5)]
            await asyncio.gather(*workers)
            await logger.complete()

>       asyncio.run(main())

main       = <function test_contextualize_async.<locals>.main at 0x7fac093f8940>
task       = <function test_contextualize_async.<locals>.task at 0x7fac09587910>
worker     = <function test_contextualize_async.<locals>.worker at 0x7fac093f8820>
writer     = <function writer.<locals>.w at 0x7fac093f8af0>

tests/test_contextualize.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object test_contextualize_async.<locals>.main at 0x7fac09566570>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-19' coro=<test_contextualize_async.<locals>.main() done, defined at /testbed/tests/test_contextualize.py:80> exception=TypeError("'NoneType' object is not an iterator")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
tests/test_contextualize.py:82: in main
    await asyncio.gather(*workers)
        worker     = <function test_contextualize_async.<locals>.worker at 0x7fac093f8820>
        workers    = [<coroutine object test_contextualize_async.<locals>.worker at 0x7fac09566340>, <coroutine object test_contextualize_a...sync.<locals>.worker at 0x7fac09566b90>, <coroutine object test_contextualize_async.<locals>.worker at 0x7fac09567220>]
tests/test_contextualize.py:77: in worker
    with logger.contextualize(i=i):
        i          = 0
        task       = <function test_contextualize_async.<locals>.task at 0x7fac09587910>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <contextlib._GeneratorContextManager object at 0x7fac0b0cf130>

    def __enter__(self):
        # do not keep args and kwds alive unnecessarily
        # they are only needed for recreation, which is not possible anymore
        del self.args, self.kwds, self.func
        try:
>           return next(self.gen)
E           TypeError: 'NoneType' object is not an iterator

self       = <contextlib._GeneratorContextManager object at 0x7fac0b0cf130>

/usr/lib/python3.10/contextlib.py:135: TypeError
</pre>
</details>
<h3 id="test_contextualizepytest_contextualize_thread">test_contextualize.py::test_contextualize_thread</h3>
<details><summary> <pre>test_contextualize.py::test_contextualize_thread</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac093f8f70>

    def test_contextualize_thread(writer):
        logger.add(writer, format="{message} {extra[i]}")

        def task():
            logger.info("Processing")

        def worker(entry_barrier, exit_barrier, i):
            with logger.contextualize(i=i):
                entry_barrier.wait()
                task()
                exit_barrier.wait()

        entry_barrier = threading.Barrier(5)
        exit_barrier = threading.Barrier(5)

        threads = [
            threading.Thread(target=worker, args=(entry_barrier, exit_barrier, i)) for i in range(5)
        ]

        for thread in threads:
            thread.start()

        for thread in threads:
            thread.join()

>       assert sorted(writer.read().splitlines()) == ["Processing %d" % i for i in range(5)]
E       AssertionError: assert [] == ['Processing ...Processing 4']
E         
E         Right contains 5 more items, first extra item: 'Processing 0'
E         Use -v to get more diff

entry_barrier = <threading.Barrier object at 0x7fac0936e5f0>
exit_barrier = <threading.Barrier object at 0x7fac0936c970>
task       = <function test_contextualize_thread.<locals>.task at 0x7fac093f9360>
thread     = <Thread(Thread-5 (worker), stopped 140376308446784)>
threads    = [<Thread(Thread-1 (worker), stopped 140376308446784)>, <Thread(Thread-2 (worker), stopped 140376308446784)>, <Thread(T...08446784)>, <Thread(Thread-4 (worker), stopped 140376308446784)>, <Thread(Thread-5 (worker), stopped 140376308446784)>]
worker     = <function test_contextualize_thread.<locals>.worker at 0x7fac093f9000>
writer     = <function writer.<locals>.w at 0x7fac093f8f70>

tests/test_contextualize.py:117: AssertionError
</pre>
</details>
<h3 id="test_contextualizepytest_contextualize_before_bind">test_contextualize.py::test_contextualize_before_bind</h3>
<details><summary> <pre>test_contextualize.py::test_contextualize_before_bind</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac093fbac0>

    def test_contextualize_before_bind(writer):
        logger.add(writer, format="{message} {extra[foobar]}")

        logger_2 = logger.bind(foobar="baz")

>       with logger.contextualize(foobar="baz_2"):

logger_2   = None
writer     = <function writer.<locals>.w at 0x7fac093fbac0>

tests/test_contextualize.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <contextlib._GeneratorContextManager object at 0x7fac08fbad70>

    def __enter__(self):
        # do not keep args and kwds alive unnecessarily
        # they are only needed for recreation, which is not possible anymore
        del self.args, self.kwds, self.func
        try:
>           return next(self.gen)
E           TypeError: 'NoneType' object is not an iterator

self       = <contextlib._GeneratorContextManager object at 0x7fac08fbad70>

/usr/lib/python3.10/contextlib.py:135: TypeError
</pre>
</details>
<h3 id="test_contextualizepytest_contextualize_after_bind">test_contextualize.py::test_contextualize_after_bind</h3>
<details><summary> <pre>test_contextualize.py::test_contextualize_after_bind</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac09587ac0>

    def test_contextualize_after_bind(writer):
        logger.add(writer, format="{message} {extra[foobar]}")

>       with logger.contextualize(foobar="baz"):

writer     = <function writer.<locals>.w at 0x7fac09587ac0>

tests/test_contextualize.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <contextlib._GeneratorContextManager object at 0x7fac09332d10>

    def __enter__(self):
        # do not keep args and kwds alive unnecessarily
        # they are only needed for recreation, which is not possible anymore
        del self.args, self.kwds, self.func
        try:
>           return next(self.gen)
E           TypeError: 'NoneType' object is not an iterator

self       = <contextlib._GeneratorContextManager object at 0x7fac09332d10>

/usr/lib/python3.10/contextlib.py:135: TypeError
</pre>
</details>
<h3 id="test_contextualizepytest_contextualize_using_bound">test_contextualize.py::test_contextualize_using_bound</h3>
<details><summary> <pre>test_contextualize.py::test_contextualize_using_bound</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac095869e0>

    def test_contextualize_using_bound(writer):
        logger.add(writer, format="{message} {extra[foobar]}")

        logger_2 = logger.bind(foobar="baz")

>       with logger_2.contextualize(foobar="baz_2"):
E       AttributeError: 'NoneType' object has no attribute 'contextualize'

logger_2   = None
writer     = <function writer.<locals>.w at 0x7fac095869e0>

tests/test_contextualize.py:152: AttributeError
</pre>
</details>
<h3 id="test_contextualizepytest_contextualize_before_configure">test_contextualize.py::test_contextualize_before_configure</h3>
<details><summary> <pre>test_contextualize.py::test_contextualize_before_configure</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac09587c70>

    def test_contextualize_before_configure(writer):
        logger.add(writer, format="{message} {extra[foobar]}")

        logger.configure(extra={"foobar": "baz"})

>       with logger.contextualize(foobar="baz_2"):

writer     = <function writer.<locals>.w at 0x7fac09587c70>

tests/test_contextualize.py:166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <contextlib._GeneratorContextManager object at 0x7fac09323880>

    def __enter__(self):
        # do not keep args and kwds alive unnecessarily
        # they are only needed for recreation, which is not possible anymore
        del self.args, self.kwds, self.func
        try:
>           return next(self.gen)
E           TypeError: 'NoneType' object is not an iterator

self       = <contextlib._GeneratorContextManager object at 0x7fac09323880>

/usr/lib/python3.10/contextlib.py:135: TypeError
</pre>
</details>
<h3 id="test_contextualizepytest_contextualize_after_configure">test_contextualize.py::test_contextualize_after_configure</h3>
<details><summary> <pre>test_contextualize.py::test_contextualize_after_configure</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac095865f0>

    def test_contextualize_after_configure(writer):
        logger.add(writer, format="{message} {extra[foobar]}")

>       with logger.contextualize(foobar="baz"):

writer     = <function writer.<locals>.w at 0x7fac095865f0>

tests/test_contextualize.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <contextlib._GeneratorContextManager object at 0x7fac0c5cdab0>

    def __enter__(self):
        # do not keep args and kwds alive unnecessarily
        # they are only needed for recreation, which is not possible anymore
        del self.args, self.kwds, self.func
        try:
>           return next(self.gen)
E           TypeError: 'NoneType' object is not an iterator

self       = <contextlib._GeneratorContextManager object at 0x7fac0c5cdab0>

/usr/lib/python3.10/contextlib.py:135: TypeError
</pre>
</details>
<h3 id="test_contextualizepytest_nested_contextualize">test_contextualize.py::test_nested_contextualize</h3>
<details><summary> <pre>test_contextualize.py::test_nested_contextualize</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac09585c60>

    def test_nested_contextualize(writer):
        logger.add(writer, format="{message} {extra[foobar]}")

>       with logger.contextualize(foobar="a"):

writer     = <function writer.<locals>.w at 0x7fac09585c60>

tests/test_contextualize.py:189: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <contextlib._GeneratorContextManager object at 0x7fac094c0790>

    def __enter__(self):
        # do not keep args and kwds alive unnecessarily
        # they are only needed for recreation, which is not possible anymore
        del self.args, self.kwds, self.func
        try:
>           return next(self.gen)
E           TypeError: 'NoneType' object is not an iterator

self       = <contextlib._GeneratorContextManager object at 0x7fac094c0790>

/usr/lib/python3.10/contextlib.py:135: TypeError
</pre>
</details>
<h3 id="test_contextualizepytest_context_reset_despite_error">test_contextualize.py::test_context_reset_despite_error</h3>
<details><summary> <pre>test_contextualize.py::test_context_reset_despite_error</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac09587490>

    def test_context_reset_despite_error(writer):
        logger.add(writer, format="{message} {extra}")

        try:
>           with logger.contextualize(foobar=456):

writer     = <function writer.<locals>.w at 0x7fac09587490>

tests/test_contextualize.py:205: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <contextlib._GeneratorContextManager object at 0x7fac0c5cfee0>

    def __enter__(self):
        # do not keep args and kwds alive unnecessarily
        # they are only needed for recreation, which is not possible anymore
        del self.args, self.kwds, self.func
        try:
>           return next(self.gen)
E           TypeError: 'NoneType' object is not an iterator

self       = <contextlib._GeneratorContextManager object at 0x7fac0c5cfee0>

/usr/lib/python3.10/contextlib.py:135: TypeError
</pre>
</details>
<h3 id="test_contextualizepytest_contextvars_fallback_352">test_contextualize.py::test_contextvars_fallback_352</h3>
<details><summary> <pre>test_contextualize.py::test_contextvars_fallback_352</pre></summary><pre>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0931b3d0>

    def test_contextvars_fallback_352(monkeypatch):
        mock_module = MagicMock()
        monkeypatch.setattr(sys, "version_info", (3, 5, 2))
        monkeypatch.setitem(sys.modules, "contextvars", mock_module)
>       assert load_contextvar_class() == mock_module.ContextVar
E       AssertionError: assert <class 'loguru._contextvars.load_contextvar_class.<locals>.ContextVar'> == <MagicMock name='mock.ContextVar' id='140376865354512'>
E        +  where <class 'loguru._contextvars.load_contextvar_class.<locals>.ContextVar'> = load_contextvar_class()
E        +  and   <MagicMock name='mock.ContextVar' id='140376865354512'> = <MagicMock id='140376865351392'>.ContextVar

mock_module = <MagicMock id='140376865351392'>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0931b3d0>

tests/test_contextualize.py:220: AssertionError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_coroutine_function">test_coroutine_sink.py::test_coroutine_function</h3>
<details><summary> <pre>test_coroutine_sink.py::test_coroutine_function</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b06cc70>

    def test_coroutine_function(capsys):
        async def worker():
            logger.debug("A message")
            await logger.complete()

        logger.add(async_writer, format="{message}")

>       asyncio.run(worker())

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b06cc70>
worker     = <function test_coroutine_function.<locals>.worker at 0x7fac093f9120>

tests/test_coroutine_sink.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object test_coroutine_function.<locals>.worker at 0x7fac094293f0>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-27' coro=<test_coroutine_function.<locals>.worker() done, defined at /testbed/tests/test_coroutine_sink.py:25> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def worker():
        logger.debug("A message")
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression


tests/test_coroutine_sink.py:27: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_async_callable_sink">test_coroutine_sink.py::test_async_callable_sink</h3>
<details><summary> <pre>test_coroutine_sink.py::test_async_callable_sink</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b017310>

    def test_async_callable_sink(capsys):
        async def worker():
            logger.debug("A message")
            await logger.complete()

        logger.add(AsyncWriter(), format="{message}")

>       asyncio.run(worker())

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b017310>
worker     = <function test_async_callable_sink.<locals>.worker at 0x7fac095877f0>

tests/test_coroutine_sink.py:45: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object test_async_callable_sink.<locals>.worker at 0x7fac0935e9d0>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-30' coro=<test_async_callable_sink.<locals>.worker() done, defined at /testbed/tests/test_coroutine_sink.py:39> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def worker():
        logger.debug("A message")
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression


tests/test_coroutine_sink.py:41: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_concurrent_execution">test_coroutine_sink.py::test_concurrent_execution</h3>
<details><summary> <pre>test_coroutine_sink.py::test_concurrent_execution</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0942c520>

    def test_concurrent_execution(capsys):
        async def task(i):
            logger.debug("=> {}", i)

        async def main():
            tasks = [task(i) for i in range(10)]
            await asyncio.gather(*tasks)
            await logger.complete()

        logger.add(async_writer, format="{message}")

>       asyncio.run(main())

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0942c520>
main       = <function test_concurrent_execution.<locals>.main at 0x7fac093f81f0>
task       = <function test_concurrent_execution.<locals>.task at 0x7fac093f8820>

tests/test_coroutine_sink.py:63: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object test_concurrent_execution.<locals>.main at 0x7fac0935f0d0>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-33' coro=<test_concurrent_execution.<locals>.main() done, defined at /testbed/tests/test_coroutine_sink.py:56> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def main():
        tasks = [task(i) for i in range(10)]
        await asyncio.gather(*tasks)
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression

task       = <function test_concurrent_execution.<locals>.task at 0x7fac093f8820>
tasks      = [<coroutine object test_concurrent_execution.<locals>.task at 0x7fac0935f060>, <coroutine object test_concurrent_execu...on.<locals>.task at 0x7fac0935d0e0>, <coroutine object test_concurrent_execution.<locals>.task at 0x7fac0935d150>, ...]

tests/test_coroutine_sink.py:59: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_recursive_coroutine">test_coroutine_sink.py::test_recursive_coroutine</h3>
<details><summary> <pre>test_coroutine_sink.py::test_recursive_coroutine</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b079900>

    def test_recursive_coroutine(capsys):
        async def task(i):
            if i == 0:
                await logger.complete()
                return
            logger.info("{}!", i)
            await task(i - 1)

        logger.add(async_writer, format="{message}")

>       asyncio.run(task(9))

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b079900>
task       = <function test_recursive_coroutine.<locals>.task at 0x7fac09587490>

tests/test_coroutine_sink.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object test_recursive_coroutine.<locals>.task at 0x7fac09567d80>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-46' coro=<test_recursive_coroutine.<locals>.task() done, defined at /testbed/tests/test_coroutine_sink.py:71> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
tests/test_coroutine_sink.py:76: in task
    await task(i - 1)
        i          = 9
        task       = <function test_recursive_coroutine.<locals>.task at 0x7fac09587490>
tests/test_coroutine_sink.py:76: in task
    await task(i - 1)
        i          = 8
        task       = <function test_recursive_coroutine.<locals>.task at 0x7fac09587490>
tests/test_coroutine_sink.py:76: in task
    await task(i - 1)
        i          = 7
        task       = <function test_recursive_coroutine.<locals>.task at 0x7fac09587490>
tests/test_coroutine_sink.py:76: in task
    await task(i - 1)
        i          = 6
        task       = <function test_recursive_coroutine.<locals>.task at 0x7fac09587490>
tests/test_coroutine_sink.py:76: in task
    await task(i - 1)
        i          = 5
        task       = <function test_recursive_coroutine.<locals>.task at 0x7fac09587490>
tests/test_coroutine_sink.py:76: in task
    await task(i - 1)
        i          = 4
        task       = <function test_recursive_coroutine.<locals>.task at 0x7fac09587490>
tests/test_coroutine_sink.py:76: in task
    await task(i - 1)
        i          = 3
        task       = <function test_recursive_coroutine.<locals>.task at 0x7fac09587490>
tests/test_coroutine_sink.py:76: in task
    await task(i - 1)
        i          = 2
        task       = <function test_recursive_coroutine.<locals>.task at 0x7fac09587490>
tests/test_coroutine_sink.py:76: in task
    await task(i - 1)
        i          = 1
        task       = <function test_recursive_coroutine.<locals>.task at 0x7fac09587490>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

i = 0

    async def task(i):
        if i == 0:
>           await logger.complete()
E           TypeError: object NoneType can't be used in 'await' expression

i          = 0
task       = <function test_recursive_coroutine.<locals>.task at 0x7fac09587490>

tests/test_coroutine_sink.py:73: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_using_another_event_loop">test_coroutine_sink.py::test_using_another_event_loop</h3>
<details><summary> <pre>test_coroutine_sink.py::test_using_another_event_loop</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0942dae0>

    @pytest.mark.skipif(sys.version_info < (3, 5, 3), reason="Coroutine can't access running loop")
    def test_using_another_event_loop(capsys):
        async def worker():
            logger.debug("A message")
            await logger.complete()

        loop = asyncio.new_event_loop()

        logger.add(async_writer, format="{message}", loop=loop)

>       loop.run_until_complete(worker())

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0942dae0>
loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>
worker     = <function test_using_another_event_loop.<locals>.worker at 0x7fac09587d90>

tests/test_coroutine_sink.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-49' coro=<test_using_another_event_loop.<locals>.worker() done, defined at /testbed/tests/test_coroutine_sink.py:89> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=False debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def worker():
        logger.debug("A message")
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression


tests/test_coroutine_sink.py:91: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_run_mutiple_different_loops">test_coroutine_sink.py::test_run_mutiple_different_loops</h3>
<details><summary> <pre>test_coroutine_sink.py::test_run_mutiple_different_loops</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b0cf1f0>

    def test_run_mutiple_different_loops(capsys):
        async def worker(i):
            logger.debug("Message {}", i)
            await logger.complete()

        logger.add(async_writer, format="{message}", loop=None)

>       asyncio.run(worker(1))

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b0cf1f0>
worker     = <function test_run_mutiple_different_loops.<locals>.worker at 0x7fac093f93f0>

tests/test_coroutine_sink.py:111: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object test_run_mutiple_different_loops.<locals>.worker at 0x7fac094ca9d0>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-50' coro=<test_run_mutiple_different_loops.<locals>.worker() done, defined at /testbed/tests/test_coroutine_sink.py:105> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

i = 1

    async def worker(i):
        logger.debug("Message {}", i)
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression

i          = 1

tests/test_coroutine_sink.py:107: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_run_multiple_same_loop">test_coroutine_sink.py::test_run_multiple_same_loop</h3>
<details><summary> <pre>test_coroutine_sink.py::test_run_multiple_same_loop</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b082bf0>

    @pytest.mark.skipif(sys.version_info < (3, 5, 3), reason="Coroutine can't access running loop")
    def test_run_multiple_same_loop(capsys):
        async def worker(i):
            logger.debug("Message {}", i)
            await logger.complete()

        loop = asyncio.new_event_loop()

        logger.add(async_writer, format="{message}", loop=loop)

>       loop.run_until_complete(worker(1))

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b082bf0>
loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>
worker     = <function test_run_multiple_same_loop.<locals>.worker at 0x7fac093fb6d0>

tests/test_coroutine_sink.py:129: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-53' coro=<test_run_multiple_same_loop.<locals>.worker() done, defined at /testbed/tests/test_coroutine_sink.py:121> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=False debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

i = 1

    async def worker(i):
        logger.debug("Message {}", i)
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression

i          = 1

tests/test_coroutine_sink.py:123: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_using_sink_without_running_loop_not_none">test_coroutine_sink.py::test_using_sink_without_running_loop_not_none</h3>
<details><summary> <pre>test_coroutine_sink.py::test_using_sink_without_running_loop_not_none</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b0e93f0>

    def test_using_sink_without_running_loop_not_none(capsys):
        loop = asyncio.new_event_loop()

        logger.add(sys.stderr, format="=> {message}")
        logger.add(async_writer, format="{message}", loop=loop)

        logger.info("A message")

>       loop.run_until_complete(logger.complete())

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b0e93f0>
loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>

tests/test_coroutine_sink.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/base_events.py:628: in run_until_complete
    future = tasks.ensure_future(future, loop=self)
        future     = None
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=False debug=False>
/usr/lib/python3.10/asyncio/tasks.py:615: in ensure_future
    return _ensure_future(coro_or_future, loop=loop)
        coro_or_future = None
        loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

coro_or_future = None

    def _ensure_future(coro_or_future, *, loop=None):
        if futures.isfuture(coro_or_future):
            if loop is not None and loop is not futures._get_loop(coro_or_future):
                raise ValueError('The future belongs to a different loop than '
                                'the one specified as the loop argument')
            return coro_or_future
        called_wrap_awaitable = False
        if not coroutines.iscoroutine(coro_or_future):
            if inspect.isawaitable(coro_or_future):
                coro_or_future = _wrap_awaitable(coro_or_future)
                called_wrap_awaitable = True
            else:
>               raise TypeError('An asyncio.Future, a coroutine or an awaitable '
                                'is required')
E               TypeError: An asyncio.Future, a coroutine or an awaitable is required

called_wrap_awaitable = False
coro_or_future = None
loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>

/usr/lib/python3.10/asyncio/tasks.py:630: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_using_sink_without_running_loop_none">test_coroutine_sink.py::test_using_sink_without_running_loop_none</h3>
<details><summary> <pre>test_coroutine_sink.py::test_using_sink_without_running_loop_none</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac094c13f0>

    def test_using_sink_without_running_loop_none(capsys):
        loop = asyncio.new_event_loop()

        logger.add(sys.stderr, format="=> {message}")
        logger.add(async_writer, format="{message}", loop=None)

        logger.info("A message")

>       loop.run_until_complete(logger.complete())

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac094c13f0>
loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>

tests/test_coroutine_sink.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/base_events.py:628: in run_until_complete
    future = tasks.ensure_future(future, loop=self)
        future     = None
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=False debug=False>
/usr/lib/python3.10/asyncio/tasks.py:615: in ensure_future
    return _ensure_future(coro_or_future, loop=loop)
        coro_or_future = None
        loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

coro_or_future = None

    def _ensure_future(coro_or_future, *, loop=None):
        if futures.isfuture(coro_or_future):
            if loop is not None and loop is not futures._get_loop(coro_or_future):
                raise ValueError('The future belongs to a different loop than '
                                'the one specified as the loop argument')
            return coro_or_future
        called_wrap_awaitable = False
        if not coroutines.iscoroutine(coro_or_future):
            if inspect.isawaitable(coro_or_future):
                coro_or_future = _wrap_awaitable(coro_or_future)
                called_wrap_awaitable = True
            else:
>               raise TypeError('An asyncio.Future, a coroutine or an awaitable '
                                'is required')
E               TypeError: An asyncio.Future, a coroutine or an awaitable is required

called_wrap_awaitable = False
coro_or_future = None
loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>

/usr/lib/python3.10/asyncio/tasks.py:630: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_global_loop_not_used">test_coroutine_sink.py::test_global_loop_not_used</h3>
<details><summary> <pre>test_coroutine_sink.py::test_global_loop_not_used</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac095436a0>

    def test_global_loop_not_used(capsys):
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)

        logger.add(sys.stderr, format="=> {message}")
        logger.add(async_writer, format="{message}", loop=None)

        logger.info("A message")

>       loop.run_until_complete(logger.complete())

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac095436a0>
loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>

tests/test_coroutine_sink.py:176: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/base_events.py:628: in run_until_complete
    future = tasks.ensure_future(future, loop=self)
        future     = None
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=False debug=False>
/usr/lib/python3.10/asyncio/tasks.py:615: in ensure_future
    return _ensure_future(coro_or_future, loop=loop)
        coro_or_future = None
        loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

coro_or_future = None

    def _ensure_future(coro_or_future, *, loop=None):
        if futures.isfuture(coro_or_future):
            if loop is not None and loop is not futures._get_loop(coro_or_future):
                raise ValueError('The future belongs to a different loop than '
                                'the one specified as the loop argument')
            return coro_or_future
        called_wrap_awaitable = False
        if not coroutines.iscoroutine(coro_or_future):
            if inspect.isawaitable(coro_or_future):
                coro_or_future = _wrap_awaitable(coro_or_future)
                called_wrap_awaitable = True
            else:
>               raise TypeError('An asyncio.Future, a coroutine or an awaitable '
                                'is required')
E               TypeError: An asyncio.Future, a coroutine or an awaitable is required

called_wrap_awaitable = False
coro_or_future = None
loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>

/usr/lib/python3.10/asyncio/tasks.py:630: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_complete_in_another_run">test_coroutine_sink.py::test_complete_in_another_run</h3>
<details><summary> <pre>test_coroutine_sink.py::test_complete_in_another_run</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac094c3490>

    @pytest.mark.skipif(sys.version_info < (3, 5, 3), reason="Coroutine can't access running loop")
    def test_complete_in_another_run(capsys):
        async def worker_1():
            logger.debug("A")

        async def worker_2():
            logger.debug("B")
            await logger.complete()

        loop = asyncio.new_event_loop()

        logger.add(async_writer, format="{message}", loop=loop)

        loop.run_until_complete(worker_1())
>       loop.run_until_complete(worker_2())

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac094c3490>
loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>
worker_1   = <function test_complete_in_another_run.<locals>.worker_1 at 0x7fac093fbf40>
worker_2   = <function test_complete_in_another_run.<locals>.worker_2 at 0x7fac093f9120>

tests/test_coroutine_sink.py:197: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-55' coro=<test_complete_in_another_run.<locals>.worker_2() done, defined at /testbed/tests/test_coroutine_sink.py:188> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=False debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def worker_2():
        logger.debug("B")
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression


tests/test_coroutine_sink.py:190: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_tasks_cancelled_on_remove">test_coroutine_sink.py::test_tasks_cancelled_on_remove</h3>
<details><summary> <pre>test_coroutine_sink.py::test_tasks_cancelled_on_remove</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0c5cd240>

    def test_tasks_cancelled_on_remove(capsys):
        logger.add(async_writer, format="{message}", catch=False)

        async def foo():
            logger.info("A")
            logger.info("B")
            logger.info("C")
            logger.remove()
            await logger.complete()

>       asyncio.run(foo())

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0c5cd240>
foo        = <function test_tasks_cancelled_on_remove.<locals>.foo at 0x7fac09587760>

tests/test_coroutine_sink.py:214: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object test_tasks_cancelled_on_remove.<locals>.foo at 0x7fac093f0900>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-56' coro=<test_tasks_cancelled_on_remove.<locals>.foo() done, defined at /testbed/tests/test_coroutine_sink.py:207> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def foo():
        logger.info("A")
        logger.info("B")
        logger.info("C")
        logger.remove()
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression


tests/test_coroutine_sink.py:212: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_remove_without_tasks">test_coroutine_sink.py::test_remove_without_tasks</h3>
<details><summary> <pre>test_coroutine_sink.py::test_remove_without_tasks</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac094fde70>

    def test_remove_without_tasks(capsys):
        logger.add(async_writer, format="{message}", catch=False)
        logger.remove()

        async def foo():
            logger.info("!")
            await logger.complete()

>       asyncio.run(foo())

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac094fde70>
foo        = <function test_remove_without_tasks.<locals>.foo at 0x7fac093fbac0>

tests/test_coroutine_sink.py:228: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object test_remove_without_tasks.<locals>.foo at 0x7fac093f3a70>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-59' coro=<test_remove_without_tasks.<locals>.foo() done, defined at /testbed/tests/test_coroutine_sink.py:224> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def foo():
        logger.info("!")
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression


tests/test_coroutine_sink.py:226: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_complete_without_tasks">test_coroutine_sink.py::test_complete_without_tasks</h3>
<details><summary> <pre>test_coroutine_sink.py::test_complete_without_tasks</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0bda8790>

    def test_complete_without_tasks(capsys):
        logger.add(async_writer, catch=False)

        async def worker():
            await logger.complete()

>       asyncio.run(worker())

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0bda8790>
worker     = <function test_complete_without_tasks.<locals>.worker at 0x7fac093a8430>

tests/test_coroutine_sink.py:240: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object test_complete_without_tasks.<locals>.worker at 0x7fac093f2c00>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-62' coro=<test_complete_without_tasks.<locals>.worker() done, defined at /testbed/tests/test_coroutine_sink.py:237> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def worker():
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression


tests/test_coroutine_sink.py:238: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_complete_stream_noop">test_coroutine_sink.py::test_complete_stream_noop</h3>
<details><summary> <pre>test_coroutine_sink.py::test_complete_stream_noop</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0930c100>

    def test_complete_stream_noop(capsys):
        logger.add(sys.stderr, format="{message}", catch=False)
        logger.info("A")

        async def worker():
            logger.info("B")
            await logger.complete()
            logger.info("C")

>       asyncio.run(worker())

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0930c100>
worker     = <function test_complete_stream_noop.<locals>.worker at 0x7fac093a8790>

tests/test_coroutine_sink.py:255: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object test_complete_stream_noop.<locals>.worker at 0x7fac093f1930>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-65' coro=<test_complete_stream_noop.<locals>.worker() done, defined at /testbed/tests/test_coroutine_sink.py:250> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def worker():
        logger.info("B")
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression


tests/test_coroutine_sink.py:252: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_complete_file_noop">test_coroutine_sink.py::test_complete_file_noop</h3>
<details><summary> <pre>test_coroutine_sink.py::test_complete_file_noop</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_complete_file_noop0')

    def test_complete_file_noop(tmp_path):
        filepath = tmp_path / "test.log"

        logger.add(filepath, format="{message}", catch=False)
        logger.info("A")

        async def worker():
            logger.info("B")
            await logger.complete()
            logger.info("C")

>       asyncio.run(worker())

filepath   = PosixPath('/tmp/pytest-of-root/pytest-0/test_complete_file_noop0/test.log')
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_complete_file_noop0')
worker     = <function test_complete_file_noop.<locals>.worker at 0x7fac093a8af0>

tests/test_coroutine_sink.py:275: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object test_complete_file_noop.<locals>.worker at 0x7fac093f1fc0>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-68' coro=<test_complete_file_noop.<locals>.worker() done, defined at /testbed/tests/test_coroutine_sink.py:270> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def worker():
        logger.info("B")
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression


tests/test_coroutine_sink.py:272: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_complete_function_noop">test_coroutine_sink.py::test_complete_function_noop</h3>
<details><summary> <pre>test_coroutine_sink.py::test_complete_function_noop</pre></summary><pre>
def test_complete_function_noop():
        out = ""

        def write(msg):
            nonlocal out
            out += msg

        logger.add(write, format="{message}", catch=False)
        logger.info("A")

        async def worker():
            logger.info("B")
            await logger.complete()
            logger.info("C")

>       asyncio.run(worker())

out        = ''
worker     = <function test_complete_function_noop.<locals>.worker at 0x7fac093fb6d0>
write      = <function test_complete_function_noop.<locals>.write at 0x7fac093f89d0>

tests/test_coroutine_sink.py:297: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object test_complete_function_noop.<locals>.worker at 0x7fac093f0890>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-71' coro=<test_complete_function_noop.<locals>.worker() done, defined at /testbed/tests/test_coroutine_sink.py:292> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def worker():
        logger.info("B")
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression


tests/test_coroutine_sink.py:294: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_complete_standard_noop">test_coroutine_sink.py::test_complete_standard_noop</h3>
<details><summary> <pre>test_coroutine_sink.py::test_complete_standard_noop</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac094558d0>

    def test_complete_standard_noop(capsys):
        logger.add(logging.StreamHandler(sys.stderr), format="{message}", catch=False)
        logger.info("A")

        async def worker():
            logger.info("B")
            await logger.complete()
            logger.info("C")

>       asyncio.run(worker())

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac094558d0>
worker     = <function test_complete_standard_noop.<locals>.worker at 0x7fac093fbf40>

tests/test_coroutine_sink.py:313: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object test_complete_standard_noop.<locals>.worker at 0x7fac093f2b20>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-74' coro=<test_complete_standard_noop.<locals>.worker() done, defined at /testbed/tests/test_coroutine_sink.py:308> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def worker():
        logger.info("B")
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression


tests/test_coroutine_sink.py:310: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_exception_in_coroutine_caught">test_coroutine_sink.py::test_exception_in_coroutine_caught</h3>
<details><summary> <pre>test_coroutine_sink.py::test_exception_in_coroutine_caught</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac094fc2b0>

    def test_exception_in_coroutine_caught(capsys):
        async def sink(msg):
            raise Exception("Oh no")

        async def main():
            logger.add(sink, catch=True)
            logger.info("Hello world")
            await asyncio.sleep(0.1)
            await logger.complete()

>       asyncio.run(main())

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac094fc2b0>
main       = <function test_exception_in_coroutine_caught.<locals>.main at 0x7fac093a8f70>
sink       = <function test_exception_in_coroutine_caught.<locals>.sink at 0x7fac093a9240>

tests/test_coroutine_sink.py:332: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object test_exception_in_coroutine_caught.<locals>.main at 0x7fac093f3bc0>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-77' coro=<test_exception_in_coroutine_caught.<locals>.main() done, defined at /testbed/tests/test_coroutine_sink.py:326> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def main():
        logger.add(sink, catch=True)
        logger.info("Hello world")
        await asyncio.sleep(0.1)
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression

sink       = <function test_exception_in_coroutine_caught.<locals>.sink at 0x7fac093a9240>

tests/test_coroutine_sink.py:330: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_exception_in_coroutine_not_caught">test_coroutine_sink.py::test_exception_in_coroutine_not_caught</h3>
<details><summary> <pre>test_coroutine_sink.py::test_exception_in_coroutine_not_caught</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0931b130>
caplog = <_pytest.logging.LogCaptureFixture object at 0x7fac0931a440>

    def test_exception_in_coroutine_not_caught(capsys, caplog):
        async def sink(msg):
            raise ValueError("Oh no")

        async def main():
            logger.add(sink, catch=False)
            logger.info("Hello world")
            await asyncio.sleep(0.1)
            await logger.complete()

>       asyncio.run(main())

caplog     = <_pytest.logging.LogCaptureFixture object at 0x7fac0931a440>
capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0931b130>
main       = <function test_exception_in_coroutine_not_caught.<locals>.main at 0x7fac093a8670>
sink       = <function test_exception_in_coroutine_not_caught.<locals>.sink at 0x7fac093a8790>

tests/test_coroutine_sink.py:354: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object test_exception_in_coroutine_not_caught.<locals>.main at 0x7fac093f1380>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-80' coro=<test_exception_in_coroutine_not_caught.<locals>.main() done, defined at /testbed/tests/test_coroutine_sink.py:348> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def main():
        logger.add(sink, catch=False)
        logger.info("Hello world")
        await asyncio.sleep(0.1)
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression

sink       = <function test_exception_in_coroutine_not_caught.<locals>.sink at 0x7fac093a8790>

tests/test_coroutine_sink.py:352: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_exception_in_coroutine_during_complete_caught">test_coroutine_sink.py::test_exception_in_coroutine_during_complete_caught</h3>
<details><summary> <pre>test_coroutine_sink.py::test_exception_in_coroutine_during_complete_caught</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b07bfd0>

    def test_exception_in_coroutine_during_complete_caught(capsys):
        async def sink(msg):
            await asyncio.sleep(0.1)
            raise Exception("Oh no")

        async def main():
            logger.add(sink, catch=True)
            logger.info("Hello world")
            await logger.complete()

>       asyncio.run(main())

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b07bfd0>
main       = <function test_exception_in_coroutine_during_complete_caught.<locals>.main at 0x7fac093f9120>
sink       = <function test_exception_in_coroutine_during_complete_caught.<locals>.sink at 0x7fac093fb910>

tests/test_coroutine_sink.py:382: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object test_exception_in_coroutine_during_complete_caught.<locals>.main at 0x7fac0935e180>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-83' coro=<test_exception_in_coroutine_during_complete_caught.<locals>.main() done, defined at /testbed/tests/test_coroutine_sink.py:377> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def main():
        logger.add(sink, catch=True)
        logger.info("Hello world")
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression

sink       = <function test_exception_in_coroutine_during_complete_caught.<locals>.sink at 0x7fac093fb910>

tests/test_coroutine_sink.py:380: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_exception_in_coroutine_during_complete_not_caught">test_coroutine_sink.py::test_exception_in_coroutine_during_complete_not_caught</h3>
<details><summary> <pre>test_coroutine_sink.py::test_exception_in_coroutine_during_complete_not_caught</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac095cf520>
caplog = <_pytest.logging.LogCaptureFixture object at 0x7fac095cc370>

    def test_exception_in_coroutine_during_complete_not_caught(capsys, caplog):
        async def sink(msg):
            await asyncio.sleep(0.1)
            raise ValueError("Oh no")

        async def main():
            logger.add(sink, catch=False)
            logger.info("Hello world")
            await logger.complete()

>       asyncio.run(main())

caplog     = <_pytest.logging.LogCaptureFixture object at 0x7fac095cc370>
capsys     = <_pytest.capture.CaptureFixture object at 0x7fac095cf520>
main       = <function test_exception_in_coroutine_during_complete_not_caught.<locals>.main at 0x7fac093a9480>
sink       = <function test_exception_in_coroutine_during_complete_not_caught.<locals>.sink at 0x7fac093f8b80>

tests/test_coroutine_sink.py:404: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object test_exception_in_coroutine_during_complete_not_caught.<locals>.main at 0x7fac093f1bd0>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-86' coro=<test_exception_in_coroutine_during_complete_not_caught.<locals>.main() done, defin... /testbed/tests/test_coroutine_sink.py:399> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def main():
        logger.add(sink, catch=False)
        logger.info("Hello world")
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression

sink       = <function test_exception_in_coroutine_during_complete_not_caught.<locals>.sink at 0x7fac093f8b80>

tests/test_coroutine_sink.py:402: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_enqueue_coroutine_loop">test_coroutine_sink.py::test_enqueue_coroutine_loop</h3>
<details><summary> <pre>test_coroutine_sink.py::test_enqueue_coroutine_loop</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac09543280>

    @pytest.mark.skipif(sys.version_info < (3, 5, 3), reason="Coroutine can't access running loop")
    def test_enqueue_coroutine_loop(capsys):
        loop = asyncio.new_event_loop()
        logger.add(async_writer, enqueue=True, loop=loop, format="{message}", catch=False)

        async def worker():
            logger.info("A")
            await logger.complete()

>       loop.run_until_complete(worker())

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac09543280>
loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>
worker     = <function test_enqueue_coroutine_loop.<locals>.worker at 0x7fac093a8b80>

tests/test_coroutine_sink.py:431: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-89' coro=<test_enqueue_coroutine_loop.<locals>.worker() done, defined at /testbed/tests/test_coroutine_sink.py:427> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=False debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def worker():
        logger.info("A")
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression


tests/test_coroutine_sink.py:429: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_enqueue_coroutine_from_inside_coroutine_without_loop">test_coroutine_sink.py::test_enqueue_coroutine_from_inside_coroutine_without_loop</h3>
<details><summary> <pre>test_coroutine_sink.py::test_enqueue_coroutine_from_inside_coroutine_without_loop</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac08fbafe0>

    def test_enqueue_coroutine_from_inside_coroutine_without_loop(capsys):
        loop = asyncio.new_event_loop()

        async def worker():
            logger.add(async_writer, enqueue=True, loop=None, format="{message}", catch=False)
            logger.info("A")
            await logger.complete()

>       loop.run_until_complete(worker())

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac08fbafe0>
loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>
worker     = <function test_enqueue_coroutine_from_inside_coroutine_without_loop.<locals>.worker at 0x7fac093a92d0>

tests/test_coroutine_sink.py:446: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-90' coro=<test_enqueue_coroutine_from_inside_coroutine_without_loop.<locals>.worker() done, ... /testbed/tests/test_coroutine_sink.py:441> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=False debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def worker():
        logger.add(async_writer, enqueue=True, loop=None, format="{message}", catch=False)
        logger.info("A")
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression


tests/test_coroutine_sink.py:444: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_custom_complete_function">test_coroutine_sink.py::test_custom_complete_function</h3>
<details><summary> <pre>test_coroutine_sink.py::test_custom_complete_function</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac09450370>

    def test_custom_complete_function(capsys):
        awaited = False

        class Handler:
            def write(self, message):
                print(message, end="")

            async def complete(self):
                nonlocal awaited
                awaited = True

        async def worker():
            logger.info("A")
            await logger.complete()

        logger.add(Handler(), catch=False, format="{message}")

>       asyncio.run(worker())

Handler    = <class 'tests.test_coroutine_sink.test_custom_complete_function.<locals>.Handler'>
awaited    = False
capsys     = <_pytest.capture.CaptureFixture object at 0x7fac09450370>
worker     = <function test_custom_complete_function.<locals>.worker at 0x7fac093a97e0>

tests/test_coroutine_sink.py:470: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object test_custom_complete_function.<locals>.worker at 0x7fac093f14d0>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-91' coro=<test_custom_complete_function.<locals>.worker() done, defined at /testbed/tests/test_coroutine_sink.py:464> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def worker():
        logger.info("A")
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression


tests/test_coroutine_sink.py:466: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_complete_from_another_looptrue">test_coroutine_sink.py::test_complete_from_another_loop[True]</h3>
<details><summary> <pre>test_coroutine_sink.py::test_complete_from_another_loop[True]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0942f8b0>
loop_is_none = True

    @pytest.mark.skipif(sys.version_info < (3, 5, 3), reason="Coroutine can't access running loop")
    @pytest.mark.parametrize("loop_is_none", [True, False])
    def test_complete_from_another_loop(capsys, loop_is_none):
        main_loop = asyncio.new_event_loop()
        second_loop = asyncio.new_event_loop()

        loop = None if loop_is_none else main_loop
        logger.add(async_writer, loop=loop, format="{message}")

        async def worker_1():
            logger.info("A")

        async def worker_2():
            await logger.complete()

        main_loop.run_until_complete(worker_1())
>       second_loop.run_until_complete(worker_2())

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0942f8b0>
loop       = None
loop_is_none = True
main_loop  = <_UnixSelectorEventLoop running=False closed=False debug=False>
second_loop = <_UnixSelectorEventLoop running=False closed=False debug=False>
worker_1   = <function test_complete_from_another_loop.<locals>.worker_1 at 0x7fac093a96c0>
worker_2   = <function test_complete_from_another_loop.<locals>.worker_2 at 0x7fac093a91b0>

tests/test_coroutine_sink.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-95' coro=<test_complete_from_another_loop.<locals>.worker_2() done, defined at /testbed/tests/test_coroutine_sink.py:490> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=False debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def worker_2():
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression


tests/test_coroutine_sink.py:491: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_complete_from_another_loopfalse">test_coroutine_sink.py::test_complete_from_another_loop[False]</h3>
<details><summary> <pre>test_coroutine_sink.py::test_complete_from_another_loop[False]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0b0ea830>
loop_is_none = False

    @pytest.mark.skipif(sys.version_info < (3, 5, 3), reason="Coroutine can't access running loop")
    @pytest.mark.parametrize("loop_is_none", [True, False])
    def test_complete_from_another_loop(capsys, loop_is_none):
        main_loop = asyncio.new_event_loop()
        second_loop = asyncio.new_event_loop()

        loop = None if loop_is_none else main_loop
        logger.add(async_writer, loop=loop, format="{message}")

        async def worker_1():
            logger.info("A")

        async def worker_2():
            await logger.complete()

        main_loop.run_until_complete(worker_1())
>       second_loop.run_until_complete(worker_2())

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0b0ea830>
loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>
loop_is_none = False
main_loop  = <_UnixSelectorEventLoop running=False closed=False debug=False>
second_loop = <_UnixSelectorEventLoop running=False closed=False debug=False>
worker_1   = <function test_complete_from_another_loop.<locals>.worker_1 at 0x7fac093a9ea0>
worker_2   = <function test_complete_from_another_loop.<locals>.worker_2 at 0x7fac093a8ee0>

tests/test_coroutine_sink.py:494: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-97' coro=<test_complete_from_another_loop.<locals>.worker_2() done, defined at /testbed/tests/test_coroutine_sink.py:490> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=False debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def worker_2():
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression


tests/test_coroutine_sink.py:491: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_complete_from_multiple_threads_loop_is_none">test_coroutine_sink.py::test_complete_from_multiple_threads_loop_is_none</h3>
<details><summary> <pre>test_coroutine_sink.py::test_complete_from_multiple_threads_loop_is_none</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac09320c10>

    def test_complete_from_multiple_threads_loop_is_none(capsys):
        async def worker(i):
            for _ in range(100):
                await asyncio.sleep(0)
                logger.info("{:03}", i)
            await logger.complete()

        async def sink(msg):
            print(msg, end="")

        def worker_(i):
            asyncio.run(worker(i))

        logger.add(sink, catch=False, format="{message}")

        threads = [threading.Thread(target=worker_, args=(i,)) for i in range(10)]

        for t in threads:
            t.start()

        for t in threads:
            t.join()

        out, err = capsys.readouterr()
>       assert sorted(out.splitlines()) == ["{:03}".format(i) for i in range(10) for _ in range(100)]
E       AssertionError: assert [] == ['000', '000'...', '000', ...]
E         
E         Right contains 1000 more items, first extra item: '000'
E         Use -v to get more diff

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac09320c10>
err        = ''
out        = ''
sink       = <function test_complete_from_multiple_threads_loop_is_none.<locals>.sink at 0x7fac093a9cf0>
t          = <Thread(Thread-15 (worker_), stopped 140376291661376)>
threads    = [<Thread(Thread-6 (worker_), stopped 140376308446784)>, <Thread(Thread-7 (worker_), stopped 140376300054080)>, <Thread...>, <Thread(Thread-10 (worker_), stopped 140376283268672)>, <Thread(Thread-11 (worker_), stopped 140376274875968)>, ...]
worker     = <function test_complete_from_multiple_threads_loop_is_none.<locals>.worker at 0x7fac093a8af0>
worker_    = <function test_complete_from_multiple_threads_loop_is_none.<locals>.worker_ at 0x7fac093a9510>

tests/test_coroutine_sink.py:530: AssertionError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_complete_from_multiple_threads_loop_is_not_none">test_coroutine_sink.py::test_complete_from_multiple_threads_loop_is_not_none</h3>
<details><summary> <pre>test_coroutine_sink.py::test_complete_from_multiple_threads_loop_is_not_none</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0bca8d60>

    def test_complete_from_multiple_threads_loop_is_not_none(capsys):
        async def worker(i):
            for _ in range(100):
                await asyncio.sleep(0)
                logger.info("{:03}", i)
            await logger.complete()

        async def sink(msg):
            print(msg, end="")

        def worker_(i):
            asyncio.run(worker(i))

        loop = asyncio.new_event_loop()
        logger.add(sink, catch=False, format="{message}", loop=loop)

        threads = [threading.Thread(target=worker_, args=(i,)) for i in range(10)]

        for t in threads:
            t.start()

        for t in threads:
            t.join()

        async def complete():
            await logger.complete()

>       loop.run_until_complete(complete())

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0bca8d60>
complete   = <function test_complete_from_multiple_threads_loop_is_not_none.<locals>.complete at 0x7fac093ab640>
loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>
sink       = <function test_complete_from_multiple_threads_loop_is_not_none.<locals>.sink at 0x7fac093aaef0>
t          = <Thread(Thread-25 (worker_), stopped 140376274875968)>
threads    = [<Thread(Thread-16 (worker_), stopped 140376274875968)>, <Thread(Thread-17 (worker_), stopped 140376291661376)>, <Thre...>, <Thread(Thread-20 (worker_), stopped 140376308446784)>, <Thread(Thread-21 (worker_), stopped 140376291661376)>, ...]
worker     = <function test_complete_from_multiple_threads_loop_is_not_none.<locals>.worker at 0x7fac093aadd0>
worker_    = <function test_complete_from_multiple_threads_loop_is_not_none.<locals>.worker_ at 0x7fac093aaf80>

tests/test_coroutine_sink.py:561: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-158' coro=<test_complete_from_multiple_threads_loop_is_not_none.<locals>.complete() done, de... /testbed/tests/test_coroutine_sink.py:558> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=False debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def complete():
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression


tests/test_coroutine_sink.py:559: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_complete_and_sink_write_concurrency">test_coroutine_sink.py::test_complete_and_sink_write_concurrency</h3>
<details><summary> <pre>test_coroutine_sink.py::test_complete_and_sink_write_concurrency</pre></summary><pre>
def test_complete_and_sink_write_concurrency():
        count = 1000
        n = 0

        async def sink(message):
            nonlocal n
            n += 1

        async def some_task():
            for _ in range(count):
                logger.info("Message")
                await asyncio.sleep(0)

        async def another_task():
            for _ in range(count):
                await logger.complete()
                await asyncio.sleep(0)

        async def main():
            logger.remove()
            logger.add(sink, catch=False)

            await asyncio.gather(some_task(), another_task())

>       asyncio.run(main())

another_task = <function test_complete_and_sink_write_concurrency.<locals>.another_task at 0x7fac093aba30>
count      = 1000
main       = <function test_complete_and_sink_write_concurrency.<locals>.main at 0x7fac093abac0>
n          = 0
sink       = <function test_complete_and_sink_write_concurrency.<locals>.sink at 0x7fac093ab880>
some_task  = <function test_complete_and_sink_write_concurrency.<locals>.some_task at 0x7fac093ab910>

tests/test_coroutine_sink.py:592: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object test_complete_and_sink_write_concurrency.<locals>.main at 0x7fac093f30d0>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-159' coro=<test_complete_and_sink_write_concurrency.<locals>.main() done, defined at /testbed/tests/test_coroutine_sink.py:586> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
tests/test_coroutine_sink.py:590: in main
    await asyncio.gather(some_task(), another_task())
        another_task = <function test_complete_and_sink_write_concurrency.<locals>.another_task at 0x7fac093aba30>
        sink       = <function test_complete_and_sink_write_concurrency.<locals>.sink at 0x7fac093ab880>
        some_task  = <function test_complete_and_sink_write_concurrency.<locals>.some_task at 0x7fac093ab910>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def another_task():
        for _ in range(count):
>           await logger.complete()
E           TypeError: object NoneType can't be used in 'await' expression

_          = 0
count      = 1000

tests/test_coroutine_sink.py:583: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_complete_and_contextualize_concurrency">test_coroutine_sink.py::test_complete_and_contextualize_concurrency</h3>
<details><summary> <pre>test_coroutine_sink.py::test_complete_and_contextualize_concurrency</pre></summary><pre>
def test_complete_and_contextualize_concurrency():
        called = False

        async def main():
            logging_event = asyncio.Event()
            contextualize_event = asyncio.Event()

            async def sink(message):
                nonlocal called
                logging_event.set()
                await contextualize_event.wait()
                called = True

            async def logging_task():
                logger.info("Message")
                await logger.complete()

            async def contextualize_task():
                with logger.contextualize():
                    contextualize_event.set()
                    await logging_event.wait()

            logger.remove()
            logger.add(sink, catch=False)

            await asyncio.gather(logging_task(), contextualize_task())

>       asyncio.run(main())

called     = False
main       = <function test_complete_and_contextualize_concurrency.<locals>.main at 0x7fac093f8b80>

tests/test_coroutine_sink.py:624: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object test_complete_and_contextualize_concurrency.<locals>.main at 0x7fac093f05f0>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-164' coro=<test_complete_and_contextualize_concurrency.<locals>.main() done, defined at /testbed/tests/test_coroutine_sink.py:600> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
tests/test_coroutine_sink.py:622: in main
    await asyncio.gather(logging_task(), contextualize_task())
        called     = False
        contextualize_event = <asyncio.locks.Event object at 0x7fac094fc880 [unset]>
        contextualize_task = <function test_complete_and_contextualize_concurrency.<locals>.main.<locals>.contextualize_task at 0x7fac093ab5b0>
        logging_event = <asyncio.locks.Event object at 0x7fac094fcc70 [unset]>
        logging_task = <function test_complete_and_contextualize_concurrency.<locals>.main.<locals>.logging_task at 0x7fac093aae60>
        sink       = <function test_complete_and_contextualize_concurrency.<locals>.main.<locals>.sink at 0x7fac093a9750>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def logging_task():
        logger.info("Message")
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression


tests/test_coroutine_sink.py:612: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_complete_with_sub_processes">test_coroutine_sink.py::test_complete_with_sub_processes</h3>
<details><summary> <pre>test_coroutine_sink.py::test_complete_with_sub_processes</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac095cd8d0>

    def test_complete_with_sub_processes(capsys):
        spawn_context = multiprocessing.get_context("spawn")

        loop = asyncio.new_event_loop()
        writer = Writer()
        logger.add(writer.write, context=spawn_context, format="{message}", enqueue=True, loop=loop)

        process = spawn_context.Process(target=subworker, args=[logger])
        process.start()
        process.join()

        async def complete():
            await logger.complete()

>       loop.run_until_complete(complete())

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac095cd8d0>
complete   = <function test_complete_with_sub_processes.<locals>.complete at 0x7fac093aacb0>
loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>
process    = <SpawnProcess name='SpawnProcess-1' pid=36 parent=8 stopped exitcode=1>
spawn_context = <multiprocessing.context.SpawnContext object at 0x7fac0d34afb0>
writer     = <tests.test_coroutine_sink.Writer object at 0x7fac095cc6a0>

tests/test_coroutine_sink.py:666: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-169' coro=<test_complete_with_sub_processes.<locals>.complete() done, defined at /testbed/tests/test_coroutine_sink.py:663> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=False debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def complete():
>       await logger.complete()
E       TypeError: object NoneType can't be used in 'await' expression


tests/test_coroutine_sink.py:664: TypeError
</pre>
</details>
<h3 id="test_coroutine_sinkpytest_invalid_coroutine_sink_if_no_loop_with_enqueue">test_coroutine_sink.py::test_invalid_coroutine_sink_if_no_loop_with_enqueue</h3>
<details><summary> <pre>test_coroutine_sink.py::test_invalid_coroutine_sink_if_no_loop_with_enqueue</pre></summary><pre>
@pytest.mark.skipif(sys.version_info < (3, 5, 3), reason="Coroutine can't access running loop")
    def test_invalid_coroutine_sink_if_no_loop_with_enqueue():
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>


tests/test_coroutine_sink.py:675: Failed
</pre>
</details>
<h3 id="test_datetimepytest_formattingy-m-d-h-m-s-f-z-z-2018-06-09-010203000045-timezone0-2018-06-09-01-02-03-000045-utc-0000">test_datetime.py::test_formatting[%Y-%m-%d %H-%M-%S %f %Z %z-2018-06-09 01:02:03.000045-timezone0-2018-06-09 01-02-03 000045 UTC +0000]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[%Y-%m-%d %H-%M-%S %f %Z %z-2018-06-09 01:02:03.000045-timezone0-2018-06-09 01-02-03 000045 UTC +0000]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0c1f9630>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac0c1f9c60>
time_format = '%Y-%m-%d %H-%M-%S %f %Z %z', date = '2018-06-09 01:02:03.000045'
timezone = ('UTC', 0), expected = '2018-06-09 01-02-03 000045 UTC +0000'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '2018-06-09 0...5 UTC +0000\n'
E             
E             - 2018-06-09 01-02-03 000045 UTC +0000

date       = '2018-06-09 01:02:03.000045'
expected   = '2018-06-09 01-02-03 000045 UTC +0000'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac0c1f9c60>
result     = ''
time_format = '%Y-%m-%d %H-%M-%S %f %Z %z'
timezone   = ('UTC', 0)
writer     = <function writer.<locals>.w at 0x7fac0c1f9630>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formattingyyyy-mm-dd-hh-mm-ss-ssssss-zz-zz-2018-06-09-010203000045-timezone1-2018-06-09-01-02-03-000045-utc-0000">test_datetime.py::test_formatting[YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ-2018-06-09 01:02:03.000045-timezone1-2018-06-09 01-02-03 000045 UTC +0000]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ-2018-06-09 01:02:03.000045-timezone1-2018-06-09 01-02-03 000045 UTC +0000]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f5c280>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f5dcf0>
time_format = 'YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ'
date = '2018-06-09 01:02:03.000045', timezone = ('UTC', 0)
expected = '2018-06-09 01-02-03 000045 UTC +0000'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '2018-06-09 0...5 UTC +0000\n'
E             
E             - 2018-06-09 01-02-03 000045 UTC +0000

date       = '2018-06-09 01:02:03.000045'
expected   = '2018-06-09 01-02-03 000045 UTC +0000'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f5dcf0>
result     = ''
time_format = 'YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ'
timezone   = ('UTC', 0)
writer     = <function writer.<locals>.w at 0x7fac08f5c280>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formattingy-m-d-h-m-s-f-z-z-2018-06-09-010203000045-timezone2-2018-06-09-01-02-03-000045-est-0500">test_datetime.py::test_formatting[%Y-%m-%d %H-%M-%S %f %Z %z-2018-06-09 01:02:03.000045-timezone2-2018-06-09 01-02-03 000045 EST -0500]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[%Y-%m-%d %H-%M-%S %f %Z %z-2018-06-09 01:02:03.000045-timezone2-2018-06-09 01-02-03 000045 EST -0500]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f5d1b0>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f5e5f0>
time_format = '%Y-%m-%d %H-%M-%S %f %Z %z', date = '2018-06-09 01:02:03.000045'
timezone = ('EST', -18000), expected = '2018-06-09 01-02-03 000045 EST -0500'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '2018-06-09 0...5 EST -0500\n'
E             
E             - 2018-06-09 01-02-03 000045 EST -0500

date       = '2018-06-09 01:02:03.000045'
expected   = '2018-06-09 01-02-03 000045 EST -0500'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f5e5f0>
result     = ''
time_format = '%Y-%m-%d %H-%M-%S %f %Z %z'
timezone   = ('EST', -18000)
writer     = <function writer.<locals>.w at 0x7fac08f5d1b0>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formattingyyyy-mm-dd-hh-mm-ss-ssssss-zz-zz-2018-06-09-010203000045-timezone3-2018-06-09-01-02-03-000045-est-0500">test_datetime.py::test_formatting[YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ-2018-06-09 01:02:03.000045-timezone3-2018-06-09 01-02-03 000045 EST -0500]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ-2018-06-09 01:02:03.000045-timezone3-2018-06-09 01-02-03 000045 EST -0500]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0c1f9b40>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f5db40>
time_format = 'YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ'
date = '2018-06-09 01:02:03.000045', timezone = ('EST', -18000)
expected = '2018-06-09 01-02-03 000045 EST -0500'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '2018-06-09 0...5 EST -0500\n'
E             
E             - 2018-06-09 01-02-03 000045 EST -0500

date       = '2018-06-09 01:02:03.000045'
expected   = '2018-06-09 01-02-03 000045 EST -0500'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f5db40>
result     = ''
time_format = 'YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ'
timezone   = ('EST', -18000)
writer     = <function writer.<locals>.w at 0x7fac0c1f9b40>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formattingy-m-d-h-m-s-f-zutc-2018-06-09-010203000045-timezone4-2018-06-09-01-02-03-000045-utc">test_datetime.py::test_formatting[%Y-%m-%d %H-%M-%S %f %Z!UTC-2018-06-09 01:02:03.000045-timezone4-2018-06-09 01-02-03 000045 UTC]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[%Y-%m-%d %H-%M-%S %f %Z!UTC-2018-06-09 01:02:03.000045-timezone4-2018-06-09 01-02-03 000045 UTC]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f5d750>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f5f010>
time_format = '%Y-%m-%d %H-%M-%S %f %Z!UTC', date = '2018-06-09 01:02:03.000045'
timezone = ('UTC', 0), expected = '2018-06-09 01-02-03 000045 UTC'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '2018-06-09 0... 000045 UTC\n'
E             
E             - 2018-06-09 01-02-03 000045 UTC

date       = '2018-06-09 01:02:03.000045'
expected   = '2018-06-09 01-02-03 000045 UTC'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f5f010>
result     = ''
time_format = '%Y-%m-%d %H-%M-%S %f %Z!UTC'
timezone   = ('UTC', 0)
writer     = <function writer.<locals>.w at 0x7fac08f5d750>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formattingyyyy-mm-dd-hh-mm-ss-ssssss-zzutc-2018-06-09-010203000045-timezone5-2018-06-09-01-02-03-000045-utc">test_datetime.py::test_formatting[YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC-2018-06-09 01:02:03.000045-timezone5-2018-06-09 01-02-03 000045 UTC]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC-2018-06-09 01:02:03.000045-timezone5-2018-06-09 01-02-03 000045 UTC]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f5f640>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f5f9a0>
time_format = 'YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC'
date = '2018-06-09 01:02:03.000045', timezone = ('UTC', 0)
expected = '2018-06-09 01-02-03 000045 UTC'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '2018-06-09 0... 000045 UTC\n'
E             
E             - 2018-06-09 01-02-03 000045 UTC

date       = '2018-06-09 01:02:03.000045'
expected   = '2018-06-09 01-02-03 000045 UTC'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f5f9a0>
result     = ''
time_format = 'YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC'
timezone   = ('UTC', 0)
writer     = <function writer.<locals>.w at 0x7fac08f5f640>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formattingy-m-d-h-m-s-f-z-zutc-2018-06-09-010203000045-timezone6-2018-06-09-06-02-03-000045-utc-0000">test_datetime.py::test_formatting[%Y-%m-%d %H-%M-%S %f %Z %z!UTC-2018-06-09 01:02:03.000045-timezone6-2018-06-09 06-02-03 000045 UTC +0000]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[%Y-%m-%d %H-%M-%S %f %Z %z!UTC-2018-06-09 01:02:03.000045-timezone6-2018-06-09 06-02-03 000045 UTC +0000]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f5c280>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f5eb00>
time_format = '%Y-%m-%d %H-%M-%S %f %Z %z!UTC'
date = '2018-06-09 01:02:03.000045', timezone = ('EST', -18000)
expected = '2018-06-09 06-02-03 000045 UTC +0000'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '2018-06-09 0...5 UTC +0000\n'
E             
E             - 2018-06-09 06-02-03 000045 UTC +0000

date       = '2018-06-09 01:02:03.000045'
expected   = '2018-06-09 06-02-03 000045 UTC +0000'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f5eb00>
result     = ''
time_format = '%Y-%m-%d %H-%M-%S %f %Z %z!UTC'
timezone   = ('EST', -18000)
writer     = <function writer.<locals>.w at 0x7fac08f5c280>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formattingyyyy-mm-dd-hh-mm-ss-ssssss-zz-zzutc-2018-06-09-010203000045-timezone7-2018-06-09-06-02-03-000045-utc-0000">test_datetime.py::test_formatting[YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC-2018-06-09 01:02:03.000045-timezone7-2018-06-09 06-02-03 000045 UTC +0000]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC-2018-06-09 01:02:03.000045-timezone7-2018-06-09 06-02-03 000045 UTC +0000]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0c1f9c60>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f5edd0>
time_format = 'YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC'
date = '2018-06-09 01:02:03.000045', timezone = ('UTC', -18000)
expected = '2018-06-09 06-02-03 000045 UTC +0000'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '2018-06-09 0...5 UTC +0000\n'
E             
E             - 2018-06-09 06-02-03 000045 UTC +0000

date       = '2018-06-09 01:02:03.000045'
expected   = '2018-06-09 06-02-03 000045 UTC +0000'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f5edd0>
result     = ''
time_format = 'YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC'
timezone   = ('UTC', -18000)
writer     = <function writer.<locals>.w at 0x7fac0c1f9c60>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formattingyy-m-d-h-m-s-sss-z-2005-04-07-090308002320-timezone8-05-4-7-9-3-8-002-0100">test_datetime.py::test_formatting[YY-M-D H-m-s SSS Z-2005-04-07 09:03:08.002320-timezone8-05-4-7 9-3-8 002 +01:00]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[YY-M-D H-m-s SSS Z-2005-04-07 09:03:08.002320-timezone8-05-4-7 9-3-8 002 +01:00]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f5f010>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f5d750>
time_format = 'YY-M-D H-m-s SSS Z', date = '2005-04-07 09:03:08.002320'
timezone = ('A', 3600), expected = '05-4-7 9-3-8 002 +01:00'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '05-4-7 9-3-8 002 +01:00\n'
E             
E             - 05-4-7 9-3-8 002 +01:00

date       = '2005-04-07 09:03:08.002320'
expected   = '05-4-7 9-3-8 002 +01:00'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f5d750>
result     = ''
time_format = 'YY-M-D H-m-s SSS Z'
timezone   = ('A', 3600)
writer     = <function writer.<locals>.w at 0x7fac08f5f010>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formattingq_dddd_ddd-d_e-h_hh-a-ss-zz-2000-01-01-1400009-timezone9-1_001_1-5_6-2_02-pm-90-0030">test_datetime.py::test_formatting[Q_DDDD_DDD d_E h_hh A SS ZZ-2000-01-01 14:00:00.9-timezone9-1_001_1 5_6 2_02 PM 90 -0030]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[Q_DDDD_DDD d_E h_hh A SS ZZ-2000-01-01 14:00:00.9-timezone9-1_001_1 5_6 2_02 PM 90 -0030]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f54b80>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f54ee0>
time_format = 'Q_DDDD_DDD d_E h_hh A SS ZZ', date = '2000-01-01 14:00:00.9'
timezone = ('B', -1800), expected = '1_001_1 5_6 2_02 PM 90 -0030'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '1_001_1 5_6 ...PM 90 -0030\n'
E             
E             - 1_001_1 5_6 2_02 PM 90 -0030

date       = '2000-01-01 14:00:00.9'
expected   = '1_001_1 5_6 2_02 PM 90 -0030'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f54ee0>
result     = ''
time_format = 'Q_DDDD_DDD d_E h_hh A SS ZZ'
timezone   = ('B', -1800)
writer     = <function writer.<locals>.w at 0x7fac08f54b80>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formattinghh-a-2018-01-01-000102000003-timezone10-12-am">test_datetime.py::test_formatting[hh A-2018-01-01 00:01:02.000003-timezone10-12 AM]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[hh A-2018-01-01 00:01:02.000003-timezone10-12 AM]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f55510>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f54820>
time_format = 'hh A', date = '2018-01-01 00:01:02.000003', timezone = ('UTC', 0)
expected = '12 AM'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '12 AM\n'
E             
E             - 12 AM

date       = '2018-01-01 00:01:02.000003'
expected   = '12 AM'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f54820>
result     = ''
time_format = 'hh A'
timezone   = ('UTC', 0)
writer     = <function writer.<locals>.w at 0x7fac08f55510>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formattinghh-a-2018-01-01-1200000-timezone11-12-pm">test_datetime.py::test_formatting[hh A-2018-01-01 12:00:00.0-timezone11-12 PM]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[hh A-2018-01-01 12:00:00.0-timezone11-12 PM]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac093f9480>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f5e950>
time_format = 'hh A', date = '2018-01-01 12:00:00.0', timezone = ('UTC', 0)
expected = '12 PM'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '12 PM\n'
E             
E             - 12 PM

date       = '2018-01-01 12:00:00.0'
expected   = '12 PM'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f5e950>
result     = ''
time_format = 'hh A'
timezone   = ('UTC', 0)
writer     = <function writer.<locals>.w at 0x7fac093f9480>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formattinghh-a-2018-01-01-2300000-timezone12-11-pm">test_datetime.py::test_formatting[hh A-2018-01-01 23:00:00.0-timezone12-11 PM]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[hh A-2018-01-01 23:00:00.0-timezone12-11 PM]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0c1ea7a0>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac0c1f9cf0>
time_format = 'hh A', date = '2018-01-01 23:00:00.0', timezone = ('UTC', 0)
expected = '11 PM'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '11 PM\n'
E             
E             - 11 PM

date       = '2018-01-01 23:00:00.0'
expected   = '11 PM'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac0c1f9cf0>
result     = ''
time_format = 'hh A'
timezone   = ('UTC', 0)
writer     = <function writer.<locals>.w at 0x7fac0c1ea7a0>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formattingyyyy-mm-dd-2018-02-03-110900000002-timezone13-yyyy-02-dd">test_datetime.py::test_formatting[[YYYY] MM [DD]-2018-02-03 11:09:00.000002-timezone13-YYYY 02 DD]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[[YYYY] MM [DD]-2018-02-03 11:09:00.000002-timezone13-YYYY 02 DD]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac093ab7f0>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f5eb00>
time_format = '[YYYY] MM [DD]', date = '2018-02-03 11:09:00.000002'
timezone = ('UTC', 0), expected = 'YYYY 02 DD'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == 'YYYY 02 DD\n'
E             
E             - YYYY 02 DD

date       = '2018-02-03 11:09:00.000002'
expected   = 'YYYY 02 DD'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f5eb00>
result     = ''
time_format = '[YYYY] MM [DD]'
timezone   = ('UTC', 0)
writer     = <function writer.<locals>.w at 0x7fac093ab7f0>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formattingyyyy-mm-dd-2018-01-03-110304000002-timezone14-2018-01-03">test_datetime.py::test_formatting[[YYYY MM DD]-2018-01-03 11:03:04.000002-timezone14-[2018 01 03]]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[[YYYY MM DD]-2018-01-03 11:03:04.000002-timezone14-[2018 01 03]]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f5e170>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f5f400>
time_format = '[YYYY MM DD]', date = '2018-01-03 11:03:04.000002'
timezone = ('UTC', 0), expected = '[2018 01 03]'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '[2018 01 03]\n'
E             
E             - [2018 01 03]

date       = '2018-01-03 11:03:04.000002'
expected   = '[2018 01 03]'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f5f400>
result     = ''
time_format = '[YYYY MM DD]'
timezone   = ('UTC', 0)
writer     = <function writer.<locals>.w at 0x7fac08f5e170>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formattingyy-2018-01-03-110304000002-timezone15-yy">test_datetime.py::test_formatting[[[YY]]-2018-01-03 11:03:04.000002-timezone15-[YY]]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[[[YY]]-2018-01-03 11:03:04.000002-timezone15-[YY]]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac093ab7f0>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac0c1ea4d0>
time_format = '[[YY]]', date = '2018-01-03 11:03:04.000002'
timezone = ('UTC', 0), expected = '[YY]'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '[YY]\n'
E             
E             - [YY]

date       = '2018-01-03 11:03:04.000002'
expected   = '[YY]'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac0c1ea4d0>
result     = ''
time_format = '[[YY]]'
timezone   = ('UTC', 0)
writer     = <function writer.<locals>.w at 0x7fac093ab7f0>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formatting-2018-01-03-110304000002-timezone16-">test_datetime.py::test_formatting[[]-2018-01-03 11:03:04.000002-timezone16-]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[[]-2018-01-03 11:03:04.000002-timezone16-]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f5eb00>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f55900>
time_format = '[]', date = '2018-01-03 11:03:04.000002', timezone = ('UTC', 0)
expected = ''

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '\n'
E             
E             Strings contain only whitespace, escaping them using repr()
E             - '\n'
E             + ''

date       = '2018-01-03 11:03:04.000002'
expected   = ''
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f55900>
result     = ''
time_format = '[]'
timezone   = ('UTC', 0)
writer     = <function writer.<locals>.w at 0x7fac08f5eb00>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formatting-2018-01-03-110304000002-timezone17-">test_datetime.py::test_formatting[[[]]-2018-01-03 11:03:04.000002-timezone17-[]]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[[[]]-2018-01-03 11:03:04.000002-timezone17-[]]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f54ca0>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f55e10>
time_format = '[[]]', date = '2018-01-03 11:03:04.000002', timezone = ('UTC', 0)
expected = '[]'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '[]\n'
E             
E             - []

date       = '2018-01-03 11:03:04.000002'
expected   = '[]'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f55e10>
result     = ''
time_format = '[[]]'
timezone   = ('UTC', 0)
writer     = <function writer.<locals>.w at 0x7fac08f54ca0>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formattingsssssssssssssss-2018-01-03-110304100002-timezone18-100002100100002">test_datetime.py::test_formatting[SSSSSS[]SSS[]SSSSSS-2018-01-03 11:03:04.100002-timezone18-100002100100002]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[SSSSSS[]SSS[]SSSSSS-2018-01-03 11:03:04.100002-timezone18-100002100100002]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f54b80>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f56680>
time_format = 'SSSSSS[]SSS[]SSSSSS', date = '2018-01-03 11:03:04.100002'
timezone = ('UTC', 0), expected = '100002100100002'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '100002100100002\n'
E             
E             - 100002100100002

date       = '2018-01-03 11:03:04.100002'
expected   = '100002100100002'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f56680>
result     = ''
time_format = 'SSSSSS[]SSS[]SSSSSS'
timezone   = ('UTC', 0)
writer     = <function writer.<locals>.w at 0x7fac08f54b80>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formattinghhmmss-2018-01-03-110304000002-timezone19-110304">test_datetime.py::test_formatting[[HHmmss-2018-01-03 11:03:04.000002-timezone19-[110304]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[[HHmmss-2018-01-03 11:03:04.000002-timezone19-[110304]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0c1ea5f0>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac093aae60>
time_format = '[HHmmss', date = '2018-01-03 11:03:04.000002'
timezone = ('UTC', 0), expected = '[110304'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '[110304\n'
E             
E             - [110304

date       = '2018-01-03 11:03:04.000002'
expected   = '[110304'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac093aae60>
result     = ''
time_format = '[HHmmss'
timezone   = ('UTC', 0)
writer     = <function writer.<locals>.w at 0x7fac0c1ea5f0>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formattinghhmmss-2018-01-03-110304000002-timezone20-110304">test_datetime.py::test_formatting[HHmmss]-2018-01-03 11:03:04.000002-timezone20-110304]]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[HHmmss]-2018-01-03 11:03:04.000002-timezone20-110304]]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f5eb00>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f56950>
time_format = 'HHmmss]', date = '2018-01-03 11:03:04.000002'
timezone = ('UTC', 0), expected = '110304]'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '110304]\n'
E             
E             - 110304]

date       = '2018-01-03 11:03:04.000002'
expected   = '110304]'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f56950>
result     = ''
time_format = 'HHmmss]'
timezone   = ('UTC', 0)
writer     = <function writer.<locals>.w at 0x7fac08f5eb00>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formattinghhmmssutc-2018-01-01-1130000-timezone21-093000">test_datetime.py::test_formatting[HH:mm:ss!UTC-2018-01-01 11:30:00.0-timezone21-09:30:00]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[HH:mm:ss!UTC-2018-01-01 11:30:00.0-timezone21-09:30:00]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f56ef0>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f57250>
time_format = 'HH:mm:ss!UTC', date = '2018-01-01 11:30:00.0'
timezone = ('A', 7200), expected = '09:30:00'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '09:30:00\n'
E             
E             - 09:30:00

date       = '2018-01-01 11:30:00.0'
expected   = '09:30:00'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f57250>
result     = ''
time_format = 'HH:mm:ss!UTC'
timezone   = ('A', 7200)
writer     = <function writer.<locals>.w at 0x7fac08f56ef0>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formattingutc-hhmmss-2018-01-01-1130000-timezone22-utc-113000">test_datetime.py::test_formatting[UTC! HH:mm:ss-2018-01-01 11:30:00.0-timezone22-UTC! 11:30:00]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[UTC! HH:mm:ss-2018-01-01 11:30:00.0-timezone22-UTC! 11:30:00]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f569e0>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f57ac0>
time_format = 'UTC! HH:mm:ss', date = '2018-01-01 11:30:00.0'
timezone = ('A', 7200), expected = 'UTC! 11:30:00'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == 'UTC! 11:30:00\n'
E             
E             - UTC! 11:30:00

date       = '2018-01-01 11:30:00.0'
expected   = 'UTC! 11:30:00'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f57ac0>
result     = ''
time_format = 'UTC! HH:mm:ss'
timezone   = ('A', 7200)
writer     = <function writer.<locals>.w at 0x7fac08f569e0>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formattingutc-hhmmss-2018-01-01-1130000-timezone23-utc-113000">test_datetime.py::test_formatting[!UTC HH:mm:ss-2018-01-01 11:30:00.0-timezone23-!UTC 11:30:00]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[!UTC HH:mm:ss-2018-01-01 11:30:00.0-timezone23-!UTC 11:30:00]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0c1ea320>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac093ab7f0>
time_format = '!UTC HH:mm:ss', date = '2018-01-01 11:30:00.0'
timezone = ('A', 7200), expected = '!UTC 11:30:00'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '!UTC 11:30:00\n'
E             
E             - !UTC 11:30:00

date       = '2018-01-01 11:30:00.0'
expected   = '!UTC 11:30:00'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac093ab7f0>
result     = ''
time_format = '!UTC HH:mm:ss'
timezone   = ('A', 7200)
writer     = <function writer.<locals>.w at 0x7fac0c1ea320>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formattinghhmmss-a-z-zz-utc-2018-01-01-1230000-timezone24-110000-am-0000-0000">test_datetime.py::test_formatting[hh:mm:ss A - Z ZZ !UTC-2018-01-01 12:30:00.0-timezone24-11:00:00 AM - +00:00 +0000 ]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[hh:mm:ss A - Z ZZ !UTC-2018-01-01 12:30:00.0-timezone24-11:00:00 AM - +00:00 +0000 ]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0c1ea5f0>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f57d90>
time_format = 'hh:mm:ss A - Z ZZ !UTC', date = '2018-01-01 12:30:00.0'
timezone = ('A', 5400), expected = '11:00:00 AM - +00:00 +0000 '

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '11:00:00 AM ...0:00 +0000 \n'
E             
E             - 11:00:00 AM - +00:00 +0000

date       = '2018-01-01 12:30:00.0'
expected   = '11:00:00 AM - +00:00 +0000 '
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f57d90>
result     = ''
time_format = 'hh:mm:ss A - Z ZZ !UTC'
timezone   = ('A', 5400)
writer     = <function writer.<locals>.w at 0x7fac0c1ea5f0>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formattingyyyy-mm-dd-hhmmsszutc-2018-01-03-1103042-timezone25-2018-01-03-130304z">test_datetime.py::test_formatting[YYYY-MM-DD HH:mm:ss[Z]!UTC-2018-01-03 11:03:04.2-timezone25-2018-01-03 13:03:04Z]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[YYYY-MM-DD HH:mm:ss[Z]!UTC-2018-01-03 11:03:04.2-timezone25-2018-01-03 13:03:04Z]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f57130>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f567a0>
time_format = 'YYYY-MM-DD HH:mm:ss[Z]!UTC', date = '2018-01-03 11:03:04.2'
timezone = ('XYZ', -7200), expected = '2018-01-03 13:03:04Z'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '2018-01-03 13:03:04Z\n'
E             
E             - 2018-01-03 13:03:04Z

date       = '2018-01-03 11:03:04.2'
expected   = '2018-01-03 13:03:04Z'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f567a0>
result     = ''
time_format = 'YYYY-MM-DD HH:mm:ss[Z]!UTC'
timezone   = ('XYZ', -7200)
writer     = <function writer.<locals>.w at 0x7fac08f57130>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formattinghhmmssutc-2018-01-01-1130000-timezone26-113000utc">test_datetime.py::test_formatting[HH:mm:ss[!UTC]-2018-01-01 11:30:00.0-timezone26-11:30:00!UTC]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[HH:mm:ss[!UTC]-2018-01-01 11:30:00.0-timezone26-11:30:00!UTC]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08fa4d30>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08fa43a0>
time_format = 'HH:mm:ss[!UTC]', date = '2018-01-01 11:30:00.0'
timezone = ('A', 7200), expected = '11:30:00!UTC'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '11:30:00!UTC\n'
E             
E             - 11:30:00!UTC

date       = '2018-01-01 11:30:00.0'
expected   = '11:30:00!UTC'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08fa43a0>
result     = ''
time_format = 'HH:mm:ss[!UTC]'
timezone   = ('A', 7200)
writer     = <function writer.<locals>.w at 0x7fac08fa4d30>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formatting-2018-02-03-110900000002-timezone27-2018-02-03t1109000000020030">test_datetime.py::test_formatting[-2018-02-03 11:09:00.000002-timezone27-2018-02-03T11:09:00.000002+0030]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[-2018-02-03 11:09:00.000002-timezone27-2018-02-03T11:09:00.000002+0030]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac093aba30>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f552d0>
time_format = '', date = '2018-02-03 11:09:00.000002', timezone = ('Z', 1800)
expected = '2018-02-03T11:09:00.000002+0030'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '2018-02-03T1...000002+0030\n'
E             
E             - 2018-02-03T11:09:00.000002+0030

date       = '2018-02-03 11:09:00.000002'
expected   = '2018-02-03T11:09:00.000002+0030'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f552d0>
result     = ''
time_format = ''
timezone   = ('Z', 1800)
writer     = <function writer.<locals>.w at 0x7fac093aba30>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formattingutc-2018-02-03-110900000002-timezone28-2018-02-03t1039000000020000">test_datetime.py::test_formatting[!UTC-2018-02-03 11:09:00.000002-timezone28-2018-02-03T10:39:00.000002+0000]</h3>
<details><summary> <pre>test_datetime.py::test_formatting[!UTC-2018-02-03 11:09:00.000002-timezone28-2018-02-03T10:39:00.000002+0000]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac093ab910>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08fa48b0>
time_format = '!UTC', date = '2018-02-03 11:09:00.000002'
timezone = ('Z', 1800), expected = '2018-02-03T10:39:00.000002+0000'

    @pytest.mark.parametrize(
        "time_format, date, timezone, expected",
        [
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 UTC +0000",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 01-02-03 000045 EST -0500",
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", 0),
                "2018-06-09 01-02-03 000045 %s" % UTC_NAME,
            ),
            (
                "%Y-%m-%d %H-%M-%S %f %Z %z!UTC",
                "2018-06-09 01:02:03.000045",
                ("EST", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YYYY-MM-DD HH-mm-ss SSSSSS zz ZZ!UTC",
                "2018-06-09 01:02:03.000045",
                ("UTC", -18000),
                "2018-06-09 06-02-03 000045 %s +0000" % UTC_NAME,
            ),
            (
                "YY-M-D H-m-s SSS Z",
                "2005-04-07 09:03:08.002320",
                ("A", 3600),
                "05-4-7 9-3-8 002 +01:00",
            ),
            (
                "Q_DDDD_DDD d_E h_hh A SS ZZ",
                "2000-01-01 14:00:00.9",
                ("B", -1800),
                "1_001_1 5_6 2_02 PM 90 -0030",
            ),
            ("hh A", "2018-01-01 00:01:02.000003", ("UTC", 0), "12 AM"),
            ("hh A", "2018-01-01 12:00:00.0", ("UTC", 0), "12 PM"),
            ("hh A", "2018-01-01 23:00:00.0", ("UTC", 0), "11 PM"),
            ("[YYYY] MM [DD]", "2018-02-03 11:09:00.000002", ("UTC", 0), "YYYY 02 DD"),
            ("[YYYY MM DD]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[2018 01 03]"),
            ("[[YY]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[YY]"),
            ("[]", "2018-01-03 11:03:04.000002", ("UTC", 0), ""),
            ("[[]]", "2018-01-03 11:03:04.000002", ("UTC", 0), "[]"),
            ("SSSSSS[]SSS[]SSSSSS", "2018-01-03 11:03:04.100002", ("UTC", 0), "100002100100002"),
            ("[HHmmss", "2018-01-03 11:03:04.000002", ("UTC", 0), "[110304"),
            ("HHmmss]", "2018-01-03 11:03:04.000002", ("UTC", 0), "110304]"),
            ("HH:mm:ss!UTC", "2018-01-01 11:30:00.0", ("A", 7200), "09:30:00"),
            ("UTC! HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "UTC! 11:30:00"),
            ("!UTC HH:mm:ss", "2018-01-01 11:30:00.0", ("A", 7200), "!UTC 11:30:00"),
            (
                "hh:mm:ss A - Z ZZ !UTC",
                "2018-01-01 12:30:00.0",
                ("A", 5400),
                "11:00:00 AM - +00:00 +0000 ",
            ),
            (
                "YYYY-MM-DD HH:mm:ss[Z]!UTC",
                "2018-01-03 11:03:04.2",
                ("XYZ", -7200),
                "2018-01-03 13:03:04Z",
            ),
            ("HH:mm:ss[!UTC]", "2018-01-01 11:30:00.0", ("A", 7200), "11:30:00!UTC"),
            ("", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T11:09:00.000002+0030"),
            ("!UTC", "2018-02-03 11:09:00.000002", ("Z", 1800), "2018-02-03T10:39:00.000002+0000"),
        ],
    )
    def test_formatting(writer, freeze_time, time_format, date, timezone, expected):
        with freeze_time(date, timezone):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("X")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '2018-02-03T1...000002+0000\n'
E             
E             - 2018-02-03T10:39:00.000002+0000

date       = '2018-02-03 11:09:00.000002'
expected   = '2018-02-03T10:39:00.000002+0000'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08fa48b0>
result     = ''
time_format = '!UTC'
timezone   = ('Z', 1800)
writer     = <function writer.<locals>.w at 0x7fac093ab910>

tests/test_datetime.py:115: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formatting_timezone_offset_down_to_the_secondy-m-d-h-m-s-f-z-z-7230099-2018-06-09-01-02-03-000000-abc-020030099000">test_datetime.py::test_formatting_timezone_offset_down_to_the_second[%Y-%m-%d %H-%M-%S %f %Z %z-7230.099-2018-06-09 01-02-03 000000 ABC +020030.099000]</h3>
<details><summary> <pre>test_datetime.py::test_formatting_timezone_offset_down_to_the_second[%Y-%m-%d %H-%M-%S %f %Z %z-7230.099-2018-06-09 01-02-03 000000 ABC +020030.099000]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08fa52d0>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08fa5e10>
time_format = '%Y-%m-%d %H-%M-%S %f %Z %z', offset = 7230.099
expected = '2018-06-09 01-02-03 000000 ABC +020030.099000'

    @pytest.mark.parametrize(
        "time_format, offset, expected",
        [
            ("%Y-%m-%d %H-%M-%S %f %Z %z", 7230.099, "2018-06-09 01-02-03 000000 ABC +020030.099000"),
            ("YYYY-MM-DD HH-mm-ss zz Z ZZ", 6543, "2018-06-09 01-02-03 ABC +01:49:03 +014903"),
            ("HH-mm-ss zz Z ZZ", -12345.06702, "01-02-03 ABC -03:26:45.067020 -032645.067020"),
        ],
    )
    @pytest.mark.skipif(sys.version_info < (3, 7), reason="Offset must be a whole number of minutes")
    def test_formatting_timezone_offset_down_to_the_second(
        writer, freeze_time, time_format, offset, expected
    ):
        date = datetime.datetime(2018, 6, 9, 1, 2, 3)
        with freeze_time(date, ("ABC", offset)):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("Test")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '2018-06-09 0...0030.099000\n'
E             
E             - 2018-06-09 01-02-03 000000 ABC +020030.099000

date       = datetime.datetime(2018, 6, 9, 1, 2, 3)
expected   = '2018-06-09 01-02-03 000000 ABC +020030.099000'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08fa5e10>
offset     = 7230.099
result     = ''
time_format = '%Y-%m-%d %H-%M-%S %f %Z %z'
writer     = <function writer.<locals>.w at 0x7fac08fa52d0>

tests/test_datetime.py:135: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formatting_timezone_offset_down_to_the_secondyyyy-mm-dd-hh-mm-ss-zz-z-zz-6543-2018-06-09-01-02-03-abc-014903-014903">test_datetime.py::test_formatting_timezone_offset_down_to_the_second[YYYY-MM-DD HH-mm-ss zz Z ZZ-6543-2018-06-09 01-02-03 ABC +01:49:03 +014903]</h3>
<details><summary> <pre>test_datetime.py::test_formatting_timezone_offset_down_to_the_second[YYYY-MM-DD HH-mm-ss zz Z ZZ-6543-2018-06-09 01-02-03 ABC +01:49:03 +014903]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08fa51b0>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08fa5630>
time_format = 'YYYY-MM-DD HH-mm-ss zz Z ZZ', offset = 6543
expected = '2018-06-09 01-02-03 ABC +01:49:03 +014903'

    @pytest.mark.parametrize(
        "time_format, offset, expected",
        [
            ("%Y-%m-%d %H-%M-%S %f %Z %z", 7230.099, "2018-06-09 01-02-03 000000 ABC +020030.099000"),
            ("YYYY-MM-DD HH-mm-ss zz Z ZZ", 6543, "2018-06-09 01-02-03 ABC +01:49:03 +014903"),
            ("HH-mm-ss zz Z ZZ", -12345.06702, "01-02-03 ABC -03:26:45.067020 -032645.067020"),
        ],
    )
    @pytest.mark.skipif(sys.version_info < (3, 7), reason="Offset must be a whole number of minutes")
    def test_formatting_timezone_offset_down_to_the_second(
        writer, freeze_time, time_format, offset, expected
    ):
        date = datetime.datetime(2018, 6, 9, 1, 2, 3)
        with freeze_time(date, ("ABC", offset)):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("Test")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '2018-06-09 0...:03 +014903\n'
E             
E             - 2018-06-09 01-02-03 ABC +01:49:03 +014903

date       = datetime.datetime(2018, 6, 9, 1, 2, 3)
expected   = '2018-06-09 01-02-03 ABC +01:49:03 +014903'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08fa5630>
offset     = 6543
result     = ''
time_format = 'YYYY-MM-DD HH-mm-ss zz Z ZZ'
writer     = <function writer.<locals>.w at 0x7fac08fa51b0>

tests/test_datetime.py:135: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_formatting_timezone_offset_down_to_the_secondhh-mm-ss-zz-z-zz-1234506702-01-02-03-abc-032645067020-032645067020">test_datetime.py::test_formatting_timezone_offset_down_to_the_second[HH-mm-ss zz Z ZZ--12345.06702-01-02-03 ABC -03:26:45.067020 -032645.067020]</h3>
<details><summary> <pre>test_datetime.py::test_formatting_timezone_offset_down_to_the_second[HH-mm-ss zz Z ZZ--12345.06702-01-02-03 ABC -03:26:45.067020 -032645.067020]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08fa4c10>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08fa5fc0>
time_format = 'HH-mm-ss zz Z ZZ', offset = -12345.06702
expected = '01-02-03 ABC -03:26:45.067020 -032645.067020'

    @pytest.mark.parametrize(
        "time_format, offset, expected",
        [
            ("%Y-%m-%d %H-%M-%S %f %Z %z", 7230.099, "2018-06-09 01-02-03 000000 ABC +020030.099000"),
            ("YYYY-MM-DD HH-mm-ss zz Z ZZ", 6543, "2018-06-09 01-02-03 ABC +01:49:03 +014903"),
            ("HH-mm-ss zz Z ZZ", -12345.06702, "01-02-03 ABC -03:26:45.067020 -032645.067020"),
        ],
    )
    @pytest.mark.skipif(sys.version_info < (3, 7), reason="Offset must be a whole number of minutes")
    def test_formatting_timezone_offset_down_to_the_second(
        writer, freeze_time, time_format, offset, expected
    ):
        date = datetime.datetime(2018, 6, 9, 1, 2, 3)
        with freeze_time(date, ("ABC", offset)):
            logger.add(writer, format="{time:%s}" % time_format)
            logger.debug("Test")
            result = writer.read()
>           assert result == expected + "\n"
E           AssertionError: assert '' == '01-02-03 ABC...2645.067020\n'
E             
E             - 01-02-03 ABC -03:26:45.067020 -032645.067020

date       = datetime.datetime(2018, 6, 9, 1, 2, 3)
expected   = '01-02-03 ABC -03:26:45.067020 -032645.067020'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08fa5fc0>
offset     = -12345.06702
result     = ''
time_format = 'HH-mm-ss zz Z ZZ'
writer     = <function writer.<locals>.w at 0x7fac08fa4c10>

tests/test_datetime.py:135: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_locale_formatting">test_datetime.py::test_locale_formatting</h3>
<details><summary> <pre>test_datetime.py::test_locale_formatting</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac093aae60>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f567a0>

    def test_locale_formatting(writer, freeze_time):
        dt = datetime.datetime(2011, 1, 1, 22, 22, 22, 0)
        with freeze_time(dt):
            logger.add(writer, format="{time:MMMM MMM dddd ddd}")
            logger.debug("Test")
>           assert writer.read() == dt.strftime("%B %b %A %a\n")
E           AssertionError: assert '' == 'January Jan Saturday Sat\n'
E             
E             - January Jan Saturday Sat

dt         = datetime.datetime(2011, 1, 1, 22, 22, 22)
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f567a0>
writer     = <function writer.<locals>.w at 0x7fac093aae60>

tests/test_datetime.py:143: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_stdout_formatting">test_datetime.py::test_stdout_formatting</h3>
<details><summary> <pre>test_datetime.py::test_stdout_formatting</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f57130>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac093136a0>

    def test_stdout_formatting(freeze_time, capsys):
        with freeze_time("2015-12-25 19:13:18", ("A", 5400)):
            logger.add(sys.stdout, format="{time:YYYY [MM] DD HHmmss Z} {message}")
            logger.debug("Y")
            out, err = capsys.readouterr()
>           assert out == "2015 MM 25 191318 +01:30 Y\n"
E           AssertionError: assert '' == '2015 MM 25 191318 +01:30 Y\n'
E             
E             - 2015 MM 25 191318 +01:30 Y

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac093136a0>
err        = ''
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08f57130>
out        = ''

tests/test_datetime.py:151: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_file_formatting">test_datetime.py::test_file_formatting</h3>
<details><summary> <pre>test_datetime.py::test_file_formatting</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08fa63b0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_formatting0')

    def test_file_formatting(freeze_time, tmp_path):
        with freeze_time("2015-12-25 19:13:18", ("A", -5400)):
            logger.add(tmp_path / "{time:YYYY [MM] DD HHmmss ZZ}.log")
            logger.debug("Z")
>           assert list(tmp_path.iterdir()) == [tmp_path / "2015 MM 25 191318 -0130.log"]
E           AssertionError: assert [] == [PosixPath('/...8 -0130.log')]
E             
E             Right contains one more item: PosixPath('/tmp/pytest-of-root/pytest-0/test_file_formatting0/2015 MM 25 191318 -0130.log')
E             Use -v to get more diff

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08fa63b0>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_formatting0')

tests/test_datetime.py:159: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_missing_struct_time_fields">test_datetime.py::test_missing_struct_time_fields</h3>
<details><summary> <pre>test_datetime.py::test_missing_struct_time_fields</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08fa6680>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08fa4af0>

    def test_missing_struct_time_fields(writer, freeze_time):
        with freeze_time("2011-01-02 03:04:05.6", include_tm_zone=False):
            logger.add(writer, format="{time:YYYY MM DD HH mm ss SSSSSS ZZ zz}")
            logger.debug("X")

            result = writer.read()
>           assert re.fullmatch(r"2011 01 02 03 04 05 600000 [+-]\d{4} .*\n", result)
E           AssertionError: assert None
E            +  where None = <function fullmatch at 0x7fac0d921b40>('2011 01 02 03 04 05 600000 [+-]\\d{4} .*\\n', '')
E            +    where <function fullmatch at 0x7fac0d921b40> = re.fullmatch

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08fa4af0>
result     = ''
writer     = <function writer.<locals>.w at 0x7fac08fa6680>

tests/test_datetime.py:168: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_freezegun_mocking">test_datetime.py::test_freezegun_mocking</h3>
<details><summary> <pre>test_datetime.py::test_freezegun_mocking</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08fa6440>

    def test_freezegun_mocking(writer):
        logger.add(writer, format="[{time:YYYY MM DD HH:mm:ss}] {message}")

        with freezegun.freeze_time("2000-01-01 18:00:05"):
            logger.info("Frozen")

>       assert writer.read() == "[2000 01 01 18:00:05] Frozen\n"
E       AssertionError: assert '' == '[2000 01 01 ...:05] Frozen\n'
E         
E         - [2000 01 01 18:00:05] Frozen

writer     = <function writer.<locals>.w at 0x7fac08fa6440>

tests/test_datetime.py:177: AssertionError
</pre>
</details>
<h3 id="test_datetimepytest_invalid_time_formatsssssssss">test_datetime.py::test_invalid_time_format[ss.SSSSSSS]</h3>
<details><summary> <pre>test_datetime.py::test_invalid_time_format[ss.SSSSSSS]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08fa69e0>
time_format = 'ss.SSSSSSS'

    @pytest.mark.parametrize(
        "time_format", ["ss.SSSSSSS", "SS.SSSSSSSS.SS", "HH:mm:ss.SSSSSSSSS", "SSSSSSSSSS"]
    )
    def test_invalid_time_format(writer, time_format):
        logger.add(writer, format="{time:%s} {message}" % time_format, catch=False)
>       with pytest.raises(ValueError, match="Invalid time format"):
E       Failed: DID NOT RAISE <class 'ValueError'>

time_format = 'ss.SSSSSSS'
writer     = <function writer.<locals>.w at 0x7fac08fa69e0>

tests/test_datetime.py:185: Failed
</pre>
</details>
<h3 id="test_datetimepytest_invalid_time_formatssssssssssss">test_datetime.py::test_invalid_time_format[SS.SSSSSSSS.SS]</h3>
<details><summary> <pre>test_datetime.py::test_invalid_time_format[SS.SSSSSSSS.SS]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f57130>
time_format = 'SS.SSSSSSSS.SS'

    @pytest.mark.parametrize(
        "time_format", ["ss.SSSSSSS", "SS.SSSSSSSS.SS", "HH:mm:ss.SSSSSSSSS", "SSSSSSSSSS"]
    )
    def test_invalid_time_format(writer, time_format):
        logger.add(writer, format="{time:%s} {message}" % time_format, catch=False)
>       with pytest.raises(ValueError, match="Invalid time format"):
E       Failed: DID NOT RAISE <class 'ValueError'>

time_format = 'SS.SSSSSSSS.SS'
writer     = <function writer.<locals>.w at 0x7fac08f57130>

tests/test_datetime.py:185: Failed
</pre>
</details>
<h3 id="test_datetimepytest_invalid_time_formathhmmsssssssssss">test_datetime.py::test_invalid_time_format[HH:mm:ss.SSSSSSSSS]</h3>
<details><summary> <pre>test_datetime.py::test_invalid_time_format[HH:mm:ss.SSSSSSSSS]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac093ab7f0>
time_format = 'HH:mm:ss.SSSSSSSSS'

    @pytest.mark.parametrize(
        "time_format", ["ss.SSSSSSS", "SS.SSSSSSSS.SS", "HH:mm:ss.SSSSSSSSS", "SSSSSSSSSS"]
    )
    def test_invalid_time_format(writer, time_format):
        logger.add(writer, format="{time:%s} {message}" % time_format, catch=False)
>       with pytest.raises(ValueError, match="Invalid time format"):
E       Failed: DID NOT RAISE <class 'ValueError'>

time_format = 'HH:mm:ss.SSSSSSSSS'
writer     = <function writer.<locals>.w at 0x7fac093ab7f0>

tests/test_datetime.py:185: Failed
</pre>
</details>
<h3 id="test_datetimepytest_invalid_time_formatssssssssss">test_datetime.py::test_invalid_time_format[SSSSSSSSSS]</h3>
<details><summary> <pre>test_datetime.py::test_invalid_time_format[SSSSSSSSSS]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08fa5360>
time_format = 'SSSSSSSSSS'

    @pytest.mark.parametrize(
        "time_format", ["ss.SSSSSSS", "SS.SSSSSSSS.SS", "HH:mm:ss.SSSSSSSSS", "SSSSSSSSSS"]
    )
    def test_invalid_time_format(writer, time_format):
        logger.add(writer, format="{time:%s} {message}" % time_format, catch=False)
>       with pytest.raises(ValueError, match="Invalid time format"):
E       Failed: DID NOT RAISE <class 'ValueError'>

time_format = 'SSSSSSSSSS'
writer     = <function writer.<locals>.w at 0x7fac08fa5360>

tests/test_datetime.py:185: Failed
</pre>
</details>
<h3 id="test_deepcopypytest_add_sink_after_deepcopy">test_deepcopy.py::test_add_sink_after_deepcopy</h3>
<details><summary> <pre>test_deepcopy.py::test_add_sink_after_deepcopy</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac09308520>

    def test_add_sink_after_deepcopy(capsys):
        logger_ = copy.deepcopy(logger)

        logger_.add(print_, format="{message}", catch=False)

        logger_.info("A")
        logger.info("B")

        out, err = capsys.readouterr()
>       assert out == "A\n"
E       AssertionError: assert '' == 'A\n'
E         
E         - A

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac09308520>
err        = ''
logger_    = <loguru.logger handlers=[]>
out        = ''

tests/test_deepcopy.py:19: AssertionError
</pre>
</details>
<h3 id="test_deepcopypytest_add_sink_before_deepcopy">test_deepcopy.py::test_add_sink_before_deepcopy</h3>
<details><summary> <pre>test_deepcopy.py::test_add_sink_before_deepcopy</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac093319f0>

    def test_add_sink_before_deepcopy(capsys):
        logger.add(print_, format="{message}", catch=False)

        logger_ = copy.deepcopy(logger)

        logger_.info("A")
        logger.info("B")

        out, err = capsys.readouterr()
>       assert out == "A\nB\n"
E       AssertionError: assert '' == 'A\nB\n'
E         
E         - A
E         - B

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac093319f0>
err        = ''
logger_    = <loguru.logger handlers=[]>
out        = ''

tests/test_deepcopy.py:32: AssertionError
</pre>
</details>
<h3 id="test_deepcopypytest_remove_from_original">test_deepcopy.py::test_remove_from_original</h3>
<details><summary> <pre>test_deepcopy.py::test_remove_from_original</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0930bfa0>

    def test_remove_from_original(capsys):
        logger.add(print_, format="{message}", catch=False)

        logger_ = copy.deepcopy(logger)
        logger.remove()

        logger_.info("A")
        logger.info("B")

        out, err = capsys.readouterr()
>       assert out == "A\n"
E       AssertionError: assert '' == 'A\n'
E         
E         - A

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0930bfa0>
err        = ''
logger_    = <loguru.logger handlers=[]>
out        = ''

tests/test_deepcopy.py:46: AssertionError
</pre>
</details>
<h3 id="test_deepcopypytest_remove_from_copy">test_deepcopy.py::test_remove_from_copy</h3>
<details><summary> <pre>test_deepcopy.py::test_remove_from_copy</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac08fbb490>

    def test_remove_from_copy(capsys):
        logger.add(print_, format="{message}", catch=False)

        logger_ = copy.deepcopy(logger)
        logger_.remove()

        logger_.info("A")
        logger.info("B")

        out, err = capsys.readouterr()
>       assert out == "B\n"
E       AssertionError: assert '' == 'B\n'
E         
E         - B

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac08fbb490>
err        = ''
logger_    = <loguru.logger handlers=[]>
out        = ''

tests/test_deepcopy.py:60: AssertionError
</pre>
</details>
<h3 id="test_defaultspytest_stringtest">test_defaults.py::test_string[test]</h3>
<details><summary> <pre>test_defaults.py::test_string[test]</pre></summary><pre>
value = 'test'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0930b040>

    @pytest.mark.parametrize("value", ["test", ""])
    def test_string(value, monkeypatch):
        key = "VALID_STRING"
        monkeypatch.setenv(key, value)
>       assert env(key, str) == value
E       TypeError: env() missing 1 required positional argument: 'default'

key        = 'VALID_STRING'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0930b040>
value      = 'test'

tests/test_defaults.py:10: TypeError
</pre>
</details>
<h3 id="test_defaultspytest_string">test_defaults.py::test_string[]</h3>
<details><summary> <pre>test_defaults.py::test_string[]</pre></summary><pre>
value = ''
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08fb8dc0>

    @pytest.mark.parametrize("value", ["test", ""])
    def test_string(value, monkeypatch):
        key = "VALID_STRING"
        monkeypatch.setenv(key, value)
>       assert env(key, str) == value
E       TypeError: env() missing 1 required positional argument: 'default'

key        = 'VALID_STRING'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08fb8dc0>
value      = ''

tests/test_defaults.py:10: TypeError
</pre>
</details>
<h3 id="test_defaultspytest_bool_positivey">test_defaults.py::test_bool_positive[y]</h3>
<details><summary> <pre>test_defaults.py::test_bool_positive[y]</pre></summary><pre>
value = 'y'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0930b460>

    @pytest.mark.parametrize("value", ["y", "1", "TRUE"])
    def test_bool_positive(value, monkeypatch):
        key = "VALID_BOOL_POS"
        monkeypatch.setenv(key, value)
>       assert env(key, bool) is True
E       TypeError: env() missing 1 required positional argument: 'default'

key        = 'VALID_BOOL_POS'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0930b460>
value      = 'y'

tests/test_defaults.py:17: TypeError
</pre>
</details>
<h3 id="test_defaultspytest_bool_positive1">test_defaults.py::test_bool_positive[1]</h3>
<details><summary> <pre>test_defaults.py::test_bool_positive[1]</pre></summary><pre>
value = '1'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08fbb970>

    @pytest.mark.parametrize("value", ["y", "1", "TRUE"])
    def test_bool_positive(value, monkeypatch):
        key = "VALID_BOOL_POS"
        monkeypatch.setenv(key, value)
>       assert env(key, bool) is True
E       TypeError: env() missing 1 required positional argument: 'default'

key        = 'VALID_BOOL_POS'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08fbb970>
value      = '1'

tests/test_defaults.py:17: TypeError
</pre>
</details>
<h3 id="test_defaultspytest_bool_positivetrue">test_defaults.py::test_bool_positive[TRUE]</h3>
<details><summary> <pre>test_defaults.py::test_bool_positive[TRUE]</pre></summary><pre>
value = 'TRUE'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08f47340>

    @pytest.mark.parametrize("value", ["y", "1", "TRUE"])
    def test_bool_positive(value, monkeypatch):
        key = "VALID_BOOL_POS"
        monkeypatch.setenv(key, value)
>       assert env(key, bool) is True
E       TypeError: env() missing 1 required positional argument: 'default'

key        = 'VALID_BOOL_POS'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08f47340>
value      = 'TRUE'

tests/test_defaults.py:17: TypeError
</pre>
</details>
<h3 id="test_defaultspytest_bool_negativeno">test_defaults.py::test_bool_negative[NO]</h3>
<details><summary> <pre>test_defaults.py::test_bool_negative[NO]</pre></summary><pre>
value = 'NO'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08fb8b20>

    @pytest.mark.parametrize("value", ["NO", "0", "false"])
    def test_bool_negative(value, monkeypatch):
        key = "VALID_BOOL_NEG"
        monkeypatch.setenv(key, value)
>       assert env(key, bool) is False
E       TypeError: env() missing 1 required positional argument: 'default'

key        = 'VALID_BOOL_NEG'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08fb8b20>
value      = 'NO'

tests/test_defaults.py:24: TypeError
</pre>
</details>
<h3 id="test_defaultspytest_bool_negative0">test_defaults.py::test_bool_negative[0]</h3>
<details><summary> <pre>test_defaults.py::test_bool_negative[0]</pre></summary><pre>
value = '0'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08f448e0>

    @pytest.mark.parametrize("value", ["NO", "0", "false"])
    def test_bool_negative(value, monkeypatch):
        key = "VALID_BOOL_NEG"
        monkeypatch.setenv(key, value)
>       assert env(key, bool) is False
E       TypeError: env() missing 1 required positional argument: 'default'

key        = 'VALID_BOOL_NEG'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08f448e0>
value      = '0'

tests/test_defaults.py:24: TypeError
</pre>
</details>
<h3 id="test_defaultspytest_bool_negativefalse">test_defaults.py::test_bool_negative[false]</h3>
<details><summary> <pre>test_defaults.py::test_bool_negative[false]</pre></summary><pre>
value = 'false'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08fb86a0>

    @pytest.mark.parametrize("value", ["NO", "0", "false"])
    def test_bool_negative(value, monkeypatch):
        key = "VALID_BOOL_NEG"
        monkeypatch.setenv(key, value)
>       assert env(key, bool) is False
E       TypeError: env() missing 1 required positional argument: 'default'

key        = 'VALID_BOOL_NEG'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08fb86a0>
value      = 'false'

tests/test_defaults.py:24: TypeError
</pre>
</details>
<h3 id="test_defaultspytest_int">test_defaults.py::test_int</h3>
<details><summary> <pre>test_defaults.py::test_int</pre></summary><pre>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08fbbd90>

    def test_int(monkeypatch):
        key = "VALID_INT"
        monkeypatch.setenv(key, "42")
>       assert env(key, int) == 42
E       TypeError: env() missing 1 required positional argument: 'default'

key        = 'VALID_INT'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08fbbd90>

tests/test_defaults.py:30: TypeError
</pre>
</details>
<h3 id="test_defaultspytest_invalid_int">test_defaults.py::test_invalid_int[]</h3>
<details><summary> <pre>test_defaults.py::test_invalid_int[]</pre></summary><pre>
value = ''
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08f46b30>

    @pytest.mark.parametrize("value", ["", "a"])
    def test_invalid_int(value, monkeypatch):
        key = "INVALID_INT"
        monkeypatch.setenv(key, value)
        with pytest.raises(ValueError):
>           env(key, int)
E           TypeError: env() missing 1 required positional argument: 'default'

key        = 'INVALID_INT'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08f46b30>
value      = ''

tests/test_defaults.py:38: TypeError
</pre>
</details>
<h3 id="test_defaultspytest_invalid_inta">test_defaults.py::test_invalid_int[a]</h3>
<details><summary> <pre>test_defaults.py::test_invalid_int[a]</pre></summary><pre>
value = 'a'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0b0eab00>

    @pytest.mark.parametrize("value", ["", "a"])
    def test_invalid_int(value, monkeypatch):
        key = "INVALID_INT"
        monkeypatch.setenv(key, value)
        with pytest.raises(ValueError):
>           env(key, int)
E           TypeError: env() missing 1 required positional argument: 'default'

key        = 'INVALID_INT'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0b0eab00>
value      = 'a'

tests/test_defaults.py:38: TypeError
</pre>
</details>
<h3 id="test_defaultspytest_invalid_bool">test_defaults.py::test_invalid_bool[]</h3>
<details><summary> <pre>test_defaults.py::test_invalid_bool[]</pre></summary><pre>
value = ''
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08f4efe0>

    @pytest.mark.parametrize("value", ["", "a"])
    def test_invalid_bool(value, monkeypatch):
        key = "INVALID_BOOL"
        monkeypatch.setenv(key, value)
        with pytest.raises(ValueError):
>           env(key, bool)
E           TypeError: env() missing 1 required positional argument: 'default'

key        = 'INVALID_BOOL'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08f4efe0>
value      = ''

tests/test_defaults.py:46: TypeError
</pre>
</details>
<h3 id="test_defaultspytest_invalid_boola">test_defaults.py::test_invalid_bool[a]</h3>
<details><summary> <pre>test_defaults.py::test_invalid_bool[a]</pre></summary><pre>
value = 'a'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0b0e8ca0>

    @pytest.mark.parametrize("value", ["", "a"])
    def test_invalid_bool(value, monkeypatch):
        key = "INVALID_BOOL"
        monkeypatch.setenv(key, value)
        with pytest.raises(ValueError):
>           env(key, bool)
E           TypeError: env() missing 1 required positional argument: 'default'

key        = 'INVALID_BOOL'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0b0e8ca0>
value      = 'a'

tests/test_defaults.py:46: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_caret_not_maskedfalse">test_exceptions_catch.py::test_caret_not_masked[False]</h3>
<details><summary> <pre>test_exceptions_catch.py::test_caret_not_masked[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f56950>, diagnose = False

    @pytest.mark.parametrize("diagnose", [False, True])
    def test_caret_not_masked(writer, diagnose):
        logger.add(writer, backtrace=True, diagnose=diagnose, colorize=False, format="")

        @logger.catch
        def f(n):
            1 / n
            f(n - 1)

>       f(30)
E       TypeError: 'NoneType' object is not callable

diagnose   = False
f          = None
writer     = <function writer.<locals>.w at 0x7fac08f56950>

tests/test_exceptions_catch.py:21: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_caret_not_maskedtrue">test_exceptions_catch.py::test_caret_not_masked[True]</h3>
<details><summary> <pre>test_exceptions_catch.py::test_caret_not_masked[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f57370>, diagnose = True

    @pytest.mark.parametrize("diagnose", [False, True])
    def test_caret_not_masked(writer, diagnose):
        logger.add(writer, backtrace=True, diagnose=diagnose, colorize=False, format="")

        @logger.catch
        def f(n):
            1 / n
            f(n - 1)

>       f(30)
E       TypeError: 'NoneType' object is not callable

diagnose   = True
f          = None
writer     = <function writer.<locals>.w at 0x7fac08f57370>

tests/test_exceptions_catch.py:21: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_no_caret_if_no_backtracefalse">test_exceptions_catch.py::test_no_caret_if_no_backtrace[False]</h3>
<details><summary> <pre>test_exceptions_catch.py::test_no_caret_if_no_backtrace[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f552d0>, diagnose = False

    @pytest.mark.parametrize("diagnose", [False, True])
    def test_no_caret_if_no_backtrace(writer, diagnose):
        logger.add(writer, backtrace=False, diagnose=diagnose, colorize=False, format="")

        @logger.catch
        def f(n):
            1 / n
            f(n - 1)

>       f(30)
E       TypeError: 'NoneType' object is not callable

diagnose   = False
f          = None
writer     = <function writer.<locals>.w at 0x7fac08f552d0>

tests/test_exceptions_catch.py:35: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_no_caret_if_no_backtracetrue">test_exceptions_catch.py::test_no_caret_if_no_backtrace[True]</h3>
<details><summary> <pre>test_exceptions_catch.py::test_no_caret_if_no_backtrace[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08fa6e60>, diagnose = True

    @pytest.mark.parametrize("diagnose", [False, True])
    def test_no_caret_if_no_backtrace(writer, diagnose):
        logger.add(writer, backtrace=False, diagnose=diagnose, colorize=False, format="")

        @logger.catch
        def f(n):
            1 / n
            f(n - 1)

>       f(30)
E       TypeError: 'NoneType' object is not callable

diagnose   = True
f          = None
writer     = <function writer.<locals>.w at 0x7fac08fa6e60>

tests/test_exceptions_catch.py:35: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_sink_encodingascii">test_exceptions_catch.py::test_sink_encoding[ascii]</h3>
<details><summary> <pre>test_exceptions_catch.py::test_sink_encoding[ascii]</pre></summary><pre>
writer = <tests.test_exceptions_catch.test_sink_encoding.<locals>.Writer object at 0x7fac09309270>
encoding = 'ascii'

    @pytest.mark.parametrize("encoding", ["ascii", "UTF8", None, "unknown-encoding", "", object()])
    def test_sink_encoding(writer, encoding):
        class Writer:
            def __init__(self, encoding):
                self.encoding = encoding
                self.output = ""

            def write(self, message):
                self.output += message

        writer = Writer(encoding)
        logger.add(writer, backtrace=True, diagnose=True, colorize=False, format="", catch=False)

        def foo(a, b):
            a / b

        def bar(c):
            foo(c, 0)

        try:
            bar(4)
        except ZeroDivisionError:
            logger.exception("")

>       assert writer.output.endswith("ZeroDivisionError: division by zero\n")
E       AssertionError: assert False
E        +  where False = <built-in method endswith of str object at 0x7fac0db08030>('ZeroDivisionError: division by zero\n')
E        +    where <built-in method endswith of str object at 0x7fac0db08030> = ''.endswith
E        +      where '' = <tests.test_exceptions_catch.test_sink_encoding.<locals>.Writer object at 0x7fac09309270>.output

Writer     = <class 'tests.test_exceptions_catch.test_sink_encoding.<locals>.Writer'>
bar        = <function test_sink_encoding.<locals>.bar at 0x7fac08fa7400>
encoding   = 'ascii'
foo        = <function test_sink_encoding.<locals>.foo at 0x7fac08f57130>
writer     = <tests.test_exceptions_catch.test_sink_encoding.<locals>.Writer object at 0x7fac09309270>

tests/test_exceptions_catch.py:64: AssertionError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_sink_encodingutf8">test_exceptions_catch.py::test_sink_encoding[UTF8]</h3>
<details><summary> <pre>test_exceptions_catch.py::test_sink_encoding[UTF8]</pre></summary><pre>
writer = <tests.test_exceptions_catch.test_sink_encoding.<locals>.Writer object at 0x7fac0930b790>
encoding = 'UTF8'

    @pytest.mark.parametrize("encoding", ["ascii", "UTF8", None, "unknown-encoding", "", object()])
    def test_sink_encoding(writer, encoding):
        class Writer:
            def __init__(self, encoding):
                self.encoding = encoding
                self.output = ""

            def write(self, message):
                self.output += message

        writer = Writer(encoding)
        logger.add(writer, backtrace=True, diagnose=True, colorize=False, format="", catch=False)

        def foo(a, b):
            a / b

        def bar(c):
            foo(c, 0)

        try:
            bar(4)
        except ZeroDivisionError:
            logger.exception("")

>       assert writer.output.endswith("ZeroDivisionError: division by zero\n")
E       AssertionError: assert False
E        +  where False = <built-in method endswith of str object at 0x7fac0db08030>('ZeroDivisionError: division by zero\n')
E        +    where <built-in method endswith of str object at 0x7fac0db08030> = ''.endswith
E        +      where '' = <tests.test_exceptions_catch.test_sink_encoding.<locals>.Writer object at 0x7fac0930b790>.output

Writer     = <class 'tests.test_exceptions_catch.test_sink_encoding.<locals>.Writer'>
bar        = <function test_sink_encoding.<locals>.bar at 0x7fac08fa7640>
encoding   = 'UTF8'
foo        = <function test_sink_encoding.<locals>.foo at 0x7fac093aae60>
writer     = <tests.test_exceptions_catch.test_sink_encoding.<locals>.Writer object at 0x7fac0930b790>

tests/test_exceptions_catch.py:64: AssertionError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_sink_encodingnone">test_exceptions_catch.py::test_sink_encoding[None]</h3>
<details><summary> <pre>test_exceptions_catch.py::test_sink_encoding[None]</pre></summary><pre>
writer = <tests.test_exceptions_catch.test_sink_encoding.<locals>.Writer object at 0x7fac08fb8d00>
encoding = None

    @pytest.mark.parametrize("encoding", ["ascii", "UTF8", None, "unknown-encoding", "", object()])
    def test_sink_encoding(writer, encoding):
        class Writer:
            def __init__(self, encoding):
                self.encoding = encoding
                self.output = ""

            def write(self, message):
                self.output += message

        writer = Writer(encoding)
        logger.add(writer, backtrace=True, diagnose=True, colorize=False, format="", catch=False)

        def foo(a, b):
            a / b

        def bar(c):
            foo(c, 0)

        try:
            bar(4)
        except ZeroDivisionError:
            logger.exception("")

>       assert writer.output.endswith("ZeroDivisionError: division by zero\n")
E       AssertionError: assert False
E        +  where False = <built-in method endswith of str object at 0x7fac0db08030>('ZeroDivisionError: division by zero\n')
E        +    where <built-in method endswith of str object at 0x7fac0db08030> = ''.endswith
E        +      where '' = <tests.test_exceptions_catch.test_sink_encoding.<locals>.Writer object at 0x7fac08fb8d00>.output

Writer     = <class 'tests.test_exceptions_catch.test_sink_encoding.<locals>.Writer'>
bar        = <function test_sink_encoding.<locals>.bar at 0x7fac08fa7c70>
encoding   = None
foo        = <function test_sink_encoding.<locals>.foo at 0x7fac08fa76d0>
writer     = <tests.test_exceptions_catch.test_sink_encoding.<locals>.Writer object at 0x7fac08fb8d00>

tests/test_exceptions_catch.py:64: AssertionError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_sink_encodingunknown-encoding">test_exceptions_catch.py::test_sink_encoding[unknown-encoding]</h3>
<details><summary> <pre>test_exceptions_catch.py::test_sink_encoding[unknown-encoding]</pre></summary><pre>
writer = <tests.test_exceptions_catch.test_sink_encoding.<locals>.Writer object at 0x7fac0930b100>
encoding = 'unknown-encoding'

    @pytest.mark.parametrize("encoding", ["ascii", "UTF8", None, "unknown-encoding", "", object()])
    def test_sink_encoding(writer, encoding):
        class Writer:
            def __init__(self, encoding):
                self.encoding = encoding
                self.output = ""

            def write(self, message):
                self.output += message

        writer = Writer(encoding)
        logger.add(writer, backtrace=True, diagnose=True, colorize=False, format="", catch=False)

        def foo(a, b):
            a / b

        def bar(c):
            foo(c, 0)

        try:
            bar(4)
        except ZeroDivisionError:
            logger.exception("")

>       assert writer.output.endswith("ZeroDivisionError: division by zero\n")
E       AssertionError: assert False
E        +  where False = <built-in method endswith of str object at 0x7fac0db08030>('ZeroDivisionError: division by zero\n')
E        +    where <built-in method endswith of str object at 0x7fac0db08030> = ''.endswith
E        +      where '' = <tests.test_exceptions_catch.test_sink_encoding.<locals>.Writer object at 0x7fac0930b100>.output

Writer     = <class 'tests.test_exceptions_catch.test_sink_encoding.<locals>.Writer'>
bar        = <function test_sink_encoding.<locals>.bar at 0x7fac08fa7520>
encoding   = 'unknown-encoding'
foo        = <function test_sink_encoding.<locals>.foo at 0x7fac093aae60>
writer     = <tests.test_exceptions_catch.test_sink_encoding.<locals>.Writer object at 0x7fac0930b100>

tests/test_exceptions_catch.py:64: AssertionError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_sink_encoding">test_exceptions_catch.py::test_sink_encoding[]</h3>
<details><summary> <pre>test_exceptions_catch.py::test_sink_encoding[]</pre></summary><pre>
writer = <tests.test_exceptions_catch.test_sink_encoding.<locals>.Writer object at 0x7fac08fb8070>
encoding = ''

    @pytest.mark.parametrize("encoding", ["ascii", "UTF8", None, "unknown-encoding", "", object()])
    def test_sink_encoding(writer, encoding):
        class Writer:
            def __init__(self, encoding):
                self.encoding = encoding
                self.output = ""

            def write(self, message):
                self.output += message

        writer = Writer(encoding)
        logger.add(writer, backtrace=True, diagnose=True, colorize=False, format="", catch=False)

        def foo(a, b):
            a / b

        def bar(c):
            foo(c, 0)

        try:
            bar(4)
        except ZeroDivisionError:
            logger.exception("")

>       assert writer.output.endswith("ZeroDivisionError: division by zero\n")
E       AssertionError: assert False
E        +  where False = <built-in method endswith of str object at 0x7fac0db08030>('ZeroDivisionError: division by zero\n')
E        +    where <built-in method endswith of str object at 0x7fac0db08030> = ''.endswith
E        +      where '' = <tests.test_exceptions_catch.test_sink_encoding.<locals>.Writer object at 0x7fac08fb8070>.output

Writer     = <class 'tests.test_exceptions_catch.test_sink_encoding.<locals>.Writer'>
bar        = <function test_sink_encoding.<locals>.bar at 0x7fac089bc160>
encoding   = ''
foo        = <function test_sink_encoding.<locals>.foo at 0x7fac08fa75b0>
writer     = <tests.test_exceptions_catch.test_sink_encoding.<locals>.Writer object at 0x7fac08fb8070>

tests/test_exceptions_catch.py:64: AssertionError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_sink_encodingencoding5">test_exceptions_catch.py::test_sink_encoding[encoding5]</h3>
<details><summary> <pre>test_exceptions_catch.py::test_sink_encoding[encoding5]</pre></summary><pre>
writer = <tests.test_exceptions_catch.test_sink_encoding.<locals>.Writer object at 0x7fac0930b610>
encoding = <object object at 0x7fac0bf245e0>

    @pytest.mark.parametrize("encoding", ["ascii", "UTF8", None, "unknown-encoding", "", object()])
    def test_sink_encoding(writer, encoding):
        class Writer:
            def __init__(self, encoding):
                self.encoding = encoding
                self.output = ""

            def write(self, message):
                self.output += message

        writer = Writer(encoding)
        logger.add(writer, backtrace=True, diagnose=True, colorize=False, format="", catch=False)

        def foo(a, b):
            a / b

        def bar(c):
            foo(c, 0)

        try:
            bar(4)
        except ZeroDivisionError:
            logger.exception("")

>       assert writer.output.endswith("ZeroDivisionError: division by zero\n")
E       AssertionError: assert False
E        +  where False = <built-in method endswith of str object at 0x7fac0db08030>('ZeroDivisionError: division by zero\n')
E        +    where <built-in method endswith of str object at 0x7fac0db08030> = ''.endswith
E        +      where '' = <tests.test_exceptions_catch.test_sink_encoding.<locals>.Writer object at 0x7fac0930b610>.output

Writer     = <class 'tests.test_exceptions_catch.test_sink_encoding.<locals>.Writer'>
bar        = <function test_sink_encoding.<locals>.bar at 0x7fac089bc550>
encoding   = <object object at 0x7fac0bf245e0>
foo        = <function test_sink_encoding.<locals>.foo at 0x7fac093aae60>
writer     = <tests.test_exceptions_catch.test_sink_encoding.<locals>.Writer object at 0x7fac0930b610>

tests/test_exceptions_catch.py:64: AssertionError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_file_sink_ascii_encoding">test_exceptions_catch.py::test_file_sink_ascii_encoding</h3>
<details><summary> <pre>test_exceptions_catch.py::test_file_sink_ascii_encoding</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_ascii_encoding1')

    def test_file_sink_ascii_encoding(tmp_path):
        file = tmp_path / "test.log"
        logger.add(file, format="", encoding="ascii", errors="backslashreplace", catch=False)
        a = ""

        try:
            "" * a
        except Exception:
            logger.exception("")

        logger.remove()
>       result = file.read_text("ascii")

a          = ''
file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_ascii_encoding1/test.log')
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_ascii_encoding1')

tests/test_exceptions_catch.py:78: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'ascii'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_ascii_encoding1/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_ascii_encoding1/test.log')
mode = 'r', buffering = -1, encoding = 'ascii', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_sink_ascii_encoding1/test.log'

buffering  = -1
encoding   = 'ascii'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_ascii_encoding1/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_file_sink_utf8_encoding">test_exceptions_catch.py::test_file_sink_utf8_encoding</h3>
<details><summary> <pre>test_exceptions_catch.py::test_file_sink_utf8_encoding</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_utf8_encoding1')

    def test_file_sink_utf8_encoding(tmp_path):
        file = tmp_path / "test.log"
        logger.add(file, format="", encoding="utf8", errors="strict", catch=False)
        a = ""

        try:
            "" * a
        except Exception:
            logger.exception("")

        logger.remove()
>       result = file.read_text("utf8")

a          = ''
file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_utf8_encoding1/test.log')
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_utf8_encoding1')

tests/test_exceptions_catch.py:94: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'utf8'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_utf8_encoding1/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_utf8_encoding1/test.log')
mode = 'r', buffering = -1, encoding = 'utf8', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_sink_utf8_encoding1/test.log'

buffering  = -1
encoding   = 'utf8'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_sink_utf8_encoding1/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_has_sys_real_prefix">test_exceptions_catch.py::test_has_sys_real_prefix</h3>
<details><summary> <pre>test_exceptions_catch.py::test_has_sys_real_prefix</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08fa7d00>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08f44e80>

    def test_has_sys_real_prefix(writer, monkeypatch):
        monkeypatch.setattr(sys, "real_prefix", "/foo/bar/baz", raising=False)
        logger.add(writer, backtrace=False, diagnose=True, colorize=False, format="")

        try:
            1 / 0  # noqa: B018
        except ZeroDivisionError:
            logger.exception("")

>       assert writer.read().endswith("ZeroDivisionError: division by zero\n")
E       AssertionError: assert False
E        +  where False = <built-in method endswith of str object at 0x7fac0db08030>('ZeroDivisionError: division by zero\n')
E        +    where <built-in method endswith of str object at 0x7fac0db08030> = ''.endswith
E        +      where '' = <function writer.<locals>.<lambda> at 0x7fac08fa5ea0>()
E        +        where <function writer.<locals>.<lambda> at 0x7fac08fa5ea0> = <function writer.<locals>.w at 0x7fac08fa7d00>.read

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08f44e80>
writer     = <function writer.<locals>.w at 0x7fac08fa7d00>

tests/test_exceptions_catch.py:108: AssertionError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_no_sys_real_prefix">test_exceptions_catch.py::test_no_sys_real_prefix</h3>
<details><summary> <pre>test_exceptions_catch.py::test_no_sys_real_prefix</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08fa7eb0>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac09300250>

    def test_no_sys_real_prefix(writer, monkeypatch):
        monkeypatch.delattr(sys, "real_prefix", raising=False)
        logger.add(writer, backtrace=False, diagnose=True, colorize=False, format="")

        try:
            1 / 0  # noqa: B018
        except ZeroDivisionError:
            logger.exception("")

>       assert writer.read().endswith("ZeroDivisionError: division by zero\n")
E       AssertionError: assert False
E        +  where False = <built-in method endswith of str object at 0x7fac0db08030>('ZeroDivisionError: division by zero\n')
E        +    where <built-in method endswith of str object at 0x7fac0db08030> = ''.endswith
E        +      where '' = <function writer.<locals>.<lambda> at 0x7fac08fa5900>()
E        +        where <function writer.<locals>.<lambda> at 0x7fac08fa5900> = <function writer.<locals>.w at 0x7fac08fa7eb0>.read

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac09300250>
writer     = <function writer.<locals>.w at 0x7fac08fa7eb0>

tests/test_exceptions_catch.py:120: AssertionError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_has_site_getsitepackages">test_exceptions_catch.py::test_has_site_getsitepackages</h3>
<details><summary> <pre>test_exceptions_catch.py::test_has_site_getsitepackages</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08fa56c0>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac09541fc0>

    def test_has_site_getsitepackages(writer, monkeypatch):
        monkeypatch.setattr(site, "getsitepackages", lambda: ["foo", "bar", "baz"], raising=False)
        logger.add(writer, backtrace=False, diagnose=True, colorize=False, format="")

        try:
            1 / 0  # noqa: B018
        except ZeroDivisionError:
            logger.exception("")

>       assert writer.read().endswith("ZeroDivisionError: division by zero\n")
E       AssertionError: assert False
E        +  where False = <built-in method endswith of str object at 0x7fac0db08030>('ZeroDivisionError: division by zero\n')
E        +    where <built-in method endswith of str object at 0x7fac0db08030> = ''.endswith
E        +      where '' = <function writer.<locals>.<lambda> at 0x7fac08fa7760>()
E        +        where <function writer.<locals>.<lambda> at 0x7fac08fa7760> = <function writer.<locals>.w at 0x7fac08fa56c0>.read

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac09541fc0>
writer     = <function writer.<locals>.w at 0x7fac08fa56c0>

tests/test_exceptions_catch.py:132: AssertionError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_no_site_getsitepackages">test_exceptions_catch.py::test_no_site_getsitepackages</h3>
<details><summary> <pre>test_exceptions_catch.py::test_no_site_getsitepackages</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08fa7130>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac093021d0>

    def test_no_site_getsitepackages(writer, monkeypatch):
        monkeypatch.delattr(site, "getsitepackages", raising=False)
        logger.add(writer, backtrace=False, diagnose=True, colorize=False, format="")

        try:
            1 / 0  # noqa: B018
        except ZeroDivisionError:
            logger.exception("")

>       assert writer.read().endswith("ZeroDivisionError: division by zero\n")
E       AssertionError: assert False
E        +  where False = <built-in method endswith of str object at 0x7fac0db08030>('ZeroDivisionError: division by zero\n')
E        +    where <built-in method endswith of str object at 0x7fac0db08030> = ''.endswith
E        +      where '' = <function writer.<locals>.<lambda> at 0x7fac08fa5990>()
E        +        where <function writer.<locals>.<lambda> at 0x7fac08fa5990> = <function writer.<locals>.w at 0x7fac08fa7130>.read

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac093021d0>
writer     = <function writer.<locals>.w at 0x7fac08fa7130>

tests/test_exceptions_catch.py:144: AssertionError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_user_site_is_path">test_exceptions_catch.py::test_user_site_is_path</h3>
<details><summary> <pre>test_exceptions_catch.py::test_user_site_is_path</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08fa76d0>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac09457dc0>

    def test_user_site_is_path(writer, monkeypatch):
        monkeypatch.setattr(site, "USER_SITE", "/foo/bar/baz")
        logger.add(writer, backtrace=False, diagnose=True, colorize=False, format="")

        try:
            1 / 0  # noqa: B018
        except ZeroDivisionError:
            logger.exception("")

>       assert writer.read().endswith("ZeroDivisionError: division by zero\n")
E       AssertionError: assert False
E        +  where False = <built-in method endswith of str object at 0x7fac0db08030>('ZeroDivisionError: division by zero\n')
E        +    where <built-in method endswith of str object at 0x7fac0db08030> = ''.endswith
E        +      where '' = <function writer.<locals>.<lambda> at 0x7fac08fa5f30>()
E        +        where <function writer.<locals>.<lambda> at 0x7fac08fa5f30> = <function writer.<locals>.w at 0x7fac08fa76d0>.read

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac09457dc0>
writer     = <function writer.<locals>.w at 0x7fac08fa76d0>

tests/test_exceptions_catch.py:156: AssertionError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_user_site_is_none">test_exceptions_catch.py::test_user_site_is_none</h3>
<details><summary> <pre>test_exceptions_catch.py::test_user_site_is_none</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08fa7400>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac09303610>

    def test_user_site_is_none(writer, monkeypatch):
        monkeypatch.setattr(site, "USER_SITE", None)
        logger.add(writer, backtrace=False, diagnose=True, colorize=False, format="")

        try:
            1 / 0  # noqa: B018
        except ZeroDivisionError:
            logger.exception("")

>       assert writer.read().endswith("ZeroDivisionError: division by zero\n")
E       AssertionError: assert False
E        +  where False = <built-in method endswith of str object at 0x7fac0db08030>('ZeroDivisionError: division by zero\n')
E        +    where <built-in method endswith of str object at 0x7fac0db08030> = ''.endswith
E        +      where '' = <function writer.<locals>.<lambda> at 0x7fac08fa5fc0>()
E        +        where <function writer.<locals>.<lambda> at 0x7fac08fa5fc0> = <function writer.<locals>.w at 0x7fac08fa7400>.read

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac09303610>
writer     = <function writer.<locals>.w at 0x7fac08fa7400>

tests/test_exceptions_catch.py:168: AssertionError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_sysconfig_get_path_return_path">test_exceptions_catch.py::test_sysconfig_get_path_return_path</h3>
<details><summary> <pre>test_exceptions_catch.py::test_sysconfig_get_path_return_path</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08fa64d0>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac094541c0>

    def test_sysconfig_get_path_return_path(writer, monkeypatch):
        monkeypatch.setattr(sysconfig, "get_path", lambda *a, **k: "/foo/bar/baz")
        logger.add(writer, backtrace=False, diagnose=True, colorize=False, format="")

        try:
            1 / 0  # noqa: B018
        except ZeroDivisionError:
            logger.exception("")

>       assert writer.read().endswith("ZeroDivisionError: division by zero\n")
E       AssertionError: assert False
E        +  where False = <built-in method endswith of str object at 0x7fac0db08030>('ZeroDivisionError: division by zero\n')
E        +    where <built-in method endswith of str object at 0x7fac0db08030> = ''.endswith
E        +      where '' = <function writer.<locals>.<lambda> at 0x7fac08fa4f70>()
E        +        where <function writer.<locals>.<lambda> at 0x7fac08fa4f70> = <function writer.<locals>.w at 0x7fac08fa64d0>.read

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac094541c0>
writer     = <function writer.<locals>.w at 0x7fac08fa64d0>

tests/test_exceptions_catch.py:180: AssertionError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_sysconfig_get_path_return_none">test_exceptions_catch.py::test_sysconfig_get_path_return_none</h3>
<details><summary> <pre>test_exceptions_catch.py::test_sysconfig_get_path_return_none</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08fa7c70>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0930bfd0>

    def test_sysconfig_get_path_return_none(writer, monkeypatch):
        monkeypatch.setattr(sysconfig, "get_path", lambda *a, **k: None)
        logger.add(writer, backtrace=False, diagnose=True, colorize=False, format="")

        try:
            1 / 0  # noqa: B018
        except ZeroDivisionError:
            logger.exception("")

>       assert writer.read().endswith("ZeroDivisionError: division by zero\n")
E       AssertionError: assert False
E        +  where False = <built-in method endswith of str object at 0x7fac0db08030>('ZeroDivisionError: division by zero\n')
E        +    where <built-in method endswith of str object at 0x7fac0db08030> = ''.endswith
E        +      where '' = <function writer.<locals>.<lambda> at 0x7fac08fa5870>()
E        +        where <function writer.<locals>.<lambda> at 0x7fac08fa5870> = <function writer.<locals>.w at 0x7fac08fa7c70>.read

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0930bfd0>
writer     = <function writer.<locals>.w at 0x7fac08fa7c70>

tests/test_exceptions_catch.py:192: AssertionError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_no_exception">test_exceptions_catch.py::test_no_exception</h3>
<details><summary> <pre>test_exceptions_catch.py::test_no_exception</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08fa5000>

    def test_no_exception(writer):
        logger.add(writer, backtrace=False, diagnose=False, colorize=False, format="{message}")

        logger.exception("No Error.")

>       assert writer.read() in (
            "No Error.\nNoneType\n",
            "No Error.\nNoneType: None\n",  # Old versions of Python 3.5
        )
E       AssertionError: assert '' in ('No Error.\nNoneType\n', 'No Error.\nNoneType: None\n')
E        +  where '' = <function writer.<locals>.<lambda> at 0x7fac08fa6f80>()
E        +    where <function writer.<locals>.<lambda> at 0x7fac08fa6f80> = <function writer.<locals>.w at 0x7fac08fa5000>.read

writer     = <function writer.<locals>.w at 0x7fac08fa5000>

tests/test_exceptions_catch.py:200: AssertionError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_exception_is_none">test_exceptions_catch.py::test_exception_is_none</h3>
<details><summary> <pre>test_exceptions_catch.py::test_exception_is_none</pre></summary><pre>
def test_exception_is_none():
        err = object()

        def writer(msg):
            nonlocal err
            err = msg.record["exception"]

        logger.add(writer)

        logger.error("No exception")

>       assert err is None
E       assert <object object at 0x7fac0bb29880> is None

err        = <object object at 0x7fac0bb29880>
writer     = <function test_exception_is_none.<locals>.writer at 0x7fac08f57ac0>

tests/test_exceptions_catch.py:217: AssertionError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_exception_is_tuple">test_exceptions_catch.py::test_exception_is_tuple</h3>
<details><summary> <pre>test_exceptions_catch.py::test_exception_is_tuple</pre></summary><pre>
def test_exception_is_tuple():
        exception = None

        def writer(msg):
            nonlocal exception
            exception = msg.record["exception"]

        logger.add(writer, catch=False)

        try:
            1 / 0  # noqa: B018
        except ZeroDivisionError:
            logger.exception("Exception")
            reference = sys.exc_info()

>       t_1, v_1, tb_1 = exception
E       TypeError: cannot unpack non-iterable NoneType object

exception  = None
reference  = (<class 'ZeroDivisionError'>, ZeroDivisionError('division by zero'), <traceback object at 0x7fac0943c400>)
writer     = <function test_exception_is_tuple.<locals>.writer at 0x7fac08f579a0>

tests/test_exceptions_catch.py:235: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_exception_not_raisingzerodivisionerror">test_exceptions_catch.py::test_exception_not_raising[ZeroDivisionError]</h3>
<details><summary> <pre>test_exceptions_catch.py::test_exception_not_raising[ZeroDivisionError]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f57e20>
exception = <class 'ZeroDivisionError'>

    @pytest.mark.parametrize(
        "exception", [ZeroDivisionError, ArithmeticError, (ValueError, ZeroDivisionError)]
    )
    def test_exception_not_raising(writer, exception):
        logger.add(writer)

        @logger.catch(exception)
>       def a():
E       TypeError: 'NoneType' object is not callable

exception  = <class 'ZeroDivisionError'>
writer     = <function writer.<locals>.w at 0x7fac08f57e20>

tests/test_exceptions_catch.py:258: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_exception_not_raisingarithmeticerror">test_exceptions_catch.py::test_exception_not_raising[ArithmeticError]</h3>
<details><summary> <pre>test_exceptions_catch.py::test_exception_not_raising[ArithmeticError]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f5e170>
exception = <class 'ArithmeticError'>

    @pytest.mark.parametrize(
        "exception", [ZeroDivisionError, ArithmeticError, (ValueError, ZeroDivisionError)]
    )
    def test_exception_not_raising(writer, exception):
        logger.add(writer)

        @logger.catch(exception)
>       def a():
E       TypeError: 'NoneType' object is not callable

exception  = <class 'ArithmeticError'>
writer     = <function writer.<locals>.w at 0x7fac08f5e170>

tests/test_exceptions_catch.py:258: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_exception_not_raisingexception2">test_exceptions_catch.py::test_exception_not_raising[exception2]</h3>
<details><summary> <pre>test_exceptions_catch.py::test_exception_not_raising[exception2]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f5eb00>
exception = (<class 'ValueError'>, <class 'ZeroDivisionError'>)

    @pytest.mark.parametrize(
        "exception", [ZeroDivisionError, ArithmeticError, (ValueError, ZeroDivisionError)]
    )
    def test_exception_not_raising(writer, exception):
        logger.add(writer)

        @logger.catch(exception)
>       def a():
E       TypeError: 'NoneType' object is not callable

exception  = (<class 'ValueError'>, <class 'ZeroDivisionError'>)
writer     = <function writer.<locals>.w at 0x7fac08f5eb00>

tests/test_exceptions_catch.py:258: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_exception_raisingvalueerror">test_exceptions_catch.py::test_exception_raising[ValueError]</h3>
<details><summary> <pre>test_exceptions_catch.py::test_exception_raising[ValueError]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f56950>
exception = <class 'ValueError'>

    @pytest.mark.parametrize("exception", [ValueError, ((SyntaxError, TypeError))])
    def test_exception_raising(writer, exception):
        logger.add(writer)

        @logger.catch(exception=exception)
>       def a():
E       TypeError: 'NoneType' object is not callable

exception  = <class 'ValueError'>
writer     = <function writer.<locals>.w at 0x7fac08f56950>

tests/test_exceptions_catch.py:270: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_exception_raisingexception1">test_exceptions_catch.py::test_exception_raising[exception1]</h3>
<details><summary> <pre>test_exceptions_catch.py::test_exception_raising[exception1]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08fa5090>
exception = (<class 'SyntaxError'>, <class 'TypeError'>)

    @pytest.mark.parametrize("exception", [ValueError, ((SyntaxError, TypeError))])
    def test_exception_raising(writer, exception):
        logger.add(writer)

        @logger.catch(exception=exception)
>       def a():
E       TypeError: 'NoneType' object is not callable

exception  = (<class 'SyntaxError'>, <class 'TypeError'>)
writer     = <function writer.<locals>.w at 0x7fac08fa5090>

tests/test_exceptions_catch.py:270: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_exclude_exception_raisingbaseexception-zerodivisionerror">test_exceptions_catch.py::test_exclude_exception_raising[BaseException-ZeroDivisionError]</h3>
<details><summary> <pre>test_exceptions_catch.py::test_exclude_exception_raising[BaseException-ZeroDivisionError]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f5e170>
exclude = <class 'ZeroDivisionError'>, exception = <class 'BaseException'>

    @pytest.mark.parametrize(
        "exclude", [ZeroDivisionError, ArithmeticError, (ValueError, ZeroDivisionError)]
    )
    @pytest.mark.parametrize("exception", [BaseException, ZeroDivisionError])
    def test_exclude_exception_raising(writer, exclude, exception):
        logger.add(writer)

        @logger.catch(exception, exclude=exclude)
>       def a():
E       TypeError: 'NoneType' object is not callable

exception  = <class 'BaseException'>
exclude    = <class 'ZeroDivisionError'>
writer     = <function writer.<locals>.w at 0x7fac08f5e170>

tests/test_exceptions_catch.py:287: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_exclude_exception_raisingbaseexception-arithmeticerror">test_exceptions_catch.py::test_exclude_exception_raising[BaseException-ArithmeticError]</h3>
<details><summary> <pre>test_exceptions_catch.py::test_exclude_exception_raising[BaseException-ArithmeticError]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08fa76d0>
exclude = <class 'ArithmeticError'>, exception = <class 'BaseException'>

    @pytest.mark.parametrize(
        "exclude", [ZeroDivisionError, ArithmeticError, (ValueError, ZeroDivisionError)]
    )
    @pytest.mark.parametrize("exception", [BaseException, ZeroDivisionError])
    def test_exclude_exception_raising(writer, exclude, exception):
        logger.add(writer)

        @logger.catch(exception, exclude=exclude)
>       def a():
E       TypeError: 'NoneType' object is not callable

exception  = <class 'BaseException'>
exclude    = <class 'ArithmeticError'>
writer     = <function writer.<locals>.w at 0x7fac08fa76d0>

tests/test_exceptions_catch.py:287: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_exclude_exception_raisingbaseexception-exclude2">test_exceptions_catch.py::test_exclude_exception_raising[BaseException-exclude2]</h3>
<details><summary> <pre>test_exceptions_catch.py::test_exclude_exception_raising[BaseException-exclude2]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f56950>
exclude = (<class 'ValueError'>, <class 'ZeroDivisionError'>)
exception = <class 'BaseException'>

    @pytest.mark.parametrize(
        "exclude", [ZeroDivisionError, ArithmeticError, (ValueError, ZeroDivisionError)]
    )
    @pytest.mark.parametrize("exception", [BaseException, ZeroDivisionError])
    def test_exclude_exception_raising(writer, exclude, exception):
        logger.add(writer)

        @logger.catch(exception, exclude=exclude)
>       def a():
E       TypeError: 'NoneType' object is not callable

exception  = <class 'BaseException'>
exclude    = (<class 'ValueError'>, <class 'ZeroDivisionError'>)
writer     = <function writer.<locals>.w at 0x7fac08f56950>

tests/test_exceptions_catch.py:287: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_exclude_exception_raisingzerodivisionerror-zerodivisionerror">test_exceptions_catch.py::test_exclude_exception_raising[ZeroDivisionError-ZeroDivisionError]</h3>
<details><summary> <pre>test_exceptions_catch.py::test_exclude_exception_raising[ZeroDivisionError-ZeroDivisionError]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f5f910>
exclude = <class 'ZeroDivisionError'>, exception = <class 'ZeroDivisionError'>

    @pytest.mark.parametrize(
        "exclude", [ZeroDivisionError, ArithmeticError, (ValueError, ZeroDivisionError)]
    )
    @pytest.mark.parametrize("exception", [BaseException, ZeroDivisionError])
    def test_exclude_exception_raising(writer, exclude, exception):
        logger.add(writer)

        @logger.catch(exception, exclude=exclude)
>       def a():
E       TypeError: 'NoneType' object is not callable

exception  = <class 'ZeroDivisionError'>
exclude    = <class 'ZeroDivisionError'>
writer     = <function writer.<locals>.w at 0x7fac08f5f910>

tests/test_exceptions_catch.py:287: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_exclude_exception_raisingzerodivisionerror-arithmeticerror">test_exceptions_catch.py::test_exclude_exception_raising[ZeroDivisionError-ArithmeticError]</h3>
<details><summary> <pre>test_exceptions_catch.py::test_exclude_exception_raising[ZeroDivisionError-ArithmeticError]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08fa76d0>
exclude = <class 'ArithmeticError'>, exception = <class 'ZeroDivisionError'>

    @pytest.mark.parametrize(
        "exclude", [ZeroDivisionError, ArithmeticError, (ValueError, ZeroDivisionError)]
    )
    @pytest.mark.parametrize("exception", [BaseException, ZeroDivisionError])
    def test_exclude_exception_raising(writer, exclude, exception):
        logger.add(writer)

        @logger.catch(exception, exclude=exclude)
>       def a():
E       TypeError: 'NoneType' object is not callable

exception  = <class 'ZeroDivisionError'>
exclude    = <class 'ArithmeticError'>
writer     = <function writer.<locals>.w at 0x7fac08fa76d0>

tests/test_exceptions_catch.py:287: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_exclude_exception_raisingzerodivisionerror-exclude2">test_exceptions_catch.py::test_exclude_exception_raising[ZeroDivisionError-exclude2]</h3>
<details><summary> <pre>test_exceptions_catch.py::test_exclude_exception_raising[ZeroDivisionError-exclude2]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f5f400>
exclude = (<class 'ValueError'>, <class 'ZeroDivisionError'>)
exception = <class 'ZeroDivisionError'>

    @pytest.mark.parametrize(
        "exclude", [ZeroDivisionError, ArithmeticError, (ValueError, ZeroDivisionError)]
    )
    @pytest.mark.parametrize("exception", [BaseException, ZeroDivisionError])
    def test_exclude_exception_raising(writer, exclude, exception):
        logger.add(writer)

        @logger.catch(exception, exclude=exclude)
>       def a():
E       TypeError: 'NoneType' object is not callable

exception  = <class 'ZeroDivisionError'>
exclude    = (<class 'ValueError'>, <class 'ZeroDivisionError'>)
writer     = <function writer.<locals>.w at 0x7fac08f5f400>

tests/test_exceptions_catch.py:287: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_exclude_exception_not_raisingbaseexception-valueerror">test_exceptions_catch.py::test_exclude_exception_not_raising[BaseException-ValueError]</h3>
<details><summary> <pre>test_exceptions_catch.py::test_exclude_exception_not_raising[BaseException-ValueError]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac089bd240>
exclude = <class 'ValueError'>, exception = <class 'BaseException'>

    @pytest.mark.parametrize("exclude", [ValueError, ((SyntaxError, TypeError))])
    @pytest.mark.parametrize("exception", [BaseException, ZeroDivisionError])
    def test_exclude_exception_not_raising(writer, exclude, exception):
        logger.add(writer)

        @logger.catch(exception, exclude=exclude)
>       def a():
E       TypeError: 'NoneType' object is not callable

exception  = <class 'BaseException'>
exclude    = <class 'ValueError'>
writer     = <function writer.<locals>.w at 0x7fac089bd240>

tests/test_exceptions_catch.py:302: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_exclude_exception_not_raisingbaseexception-exclude1">test_exceptions_catch.py::test_exclude_exception_not_raising[BaseException-exclude1]</h3>
<details><summary> <pre>test_exceptions_catch.py::test_exclude_exception_not_raising[BaseException-exclude1]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac089bc550>
exclude = (<class 'SyntaxError'>, <class 'TypeError'>)
exception = <class 'BaseException'>

    @pytest.mark.parametrize("exclude", [ValueError, ((SyntaxError, TypeError))])
    @pytest.mark.parametrize("exception", [BaseException, ZeroDivisionError])
    def test_exclude_exception_not_raising(writer, exclude, exception):
        logger.add(writer)

        @logger.catch(exception, exclude=exclude)
>       def a():
E       TypeError: 'NoneType' object is not callable

exception  = <class 'BaseException'>
exclude    = (<class 'SyntaxError'>, <class 'TypeError'>)
writer     = <function writer.<locals>.w at 0x7fac089bc550>

tests/test_exceptions_catch.py:302: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_exclude_exception_not_raisingzerodivisionerror-valueerror">test_exceptions_catch.py::test_exclude_exception_not_raising[ZeroDivisionError-ValueError]</h3>
<details><summary> <pre>test_exceptions_catch.py::test_exclude_exception_not_raising[ZeroDivisionError-ValueError]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08fa7400>
exclude = <class 'ValueError'>, exception = <class 'ZeroDivisionError'>

    @pytest.mark.parametrize("exclude", [ValueError, ((SyntaxError, TypeError))])
    @pytest.mark.parametrize("exception", [BaseException, ZeroDivisionError])
    def test_exclude_exception_not_raising(writer, exclude, exception):
        logger.add(writer)

        @logger.catch(exception, exclude=exclude)
>       def a():
E       TypeError: 'NoneType' object is not callable

exception  = <class 'ZeroDivisionError'>
exclude    = <class 'ValueError'>
writer     = <function writer.<locals>.w at 0x7fac08fa7400>

tests/test_exceptions_catch.py:302: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_exclude_exception_not_raisingzerodivisionerror-exclude1">test_exceptions_catch.py::test_exclude_exception_not_raising[ZeroDivisionError-exclude1]</h3>
<details><summary> <pre>test_exceptions_catch.py::test_exclude_exception_not_raising[ZeroDivisionError-exclude1]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08fa76d0>
exclude = (<class 'SyntaxError'>, <class 'TypeError'>)
exception = <class 'ZeroDivisionError'>

    @pytest.mark.parametrize("exclude", [ValueError, ((SyntaxError, TypeError))])
    @pytest.mark.parametrize("exception", [BaseException, ZeroDivisionError])
    def test_exclude_exception_not_raising(writer, exclude, exception):
        logger.add(writer)

        @logger.catch(exception, exclude=exclude)
>       def a():
E       TypeError: 'NoneType' object is not callable

exception  = <class 'ZeroDivisionError'>
exclude    = (<class 'SyntaxError'>, <class 'TypeError'>)
writer     = <function writer.<locals>.w at 0x7fac08fa76d0>

tests/test_exceptions_catch.py:302: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_reraise">test_exceptions_catch.py::test_reraise</h3>
<details><summary> <pre>test_exceptions_catch.py::test_reraise</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f5e320>

    def test_reraise(writer):
        logger.add(writer)

        @logger.catch(reraise=True)
>       def a():
E       TypeError: 'NoneType' object is not callable

writer     = <function writer.<locals>.w at 0x7fac08f5e320>

tests/test_exceptions_catch.py:313: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_onerror">test_exceptions_catch.py::test_onerror</h3>
<details><summary> <pre>test_exceptions_catch.py::test_onerror</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f5c280>

    def test_onerror(writer):
        is_error_valid = False
        logger.add(writer, format="{message}")

        def onerror(error):
            nonlocal is_error_valid
            logger.info("Called after logged message")
            _, exception, _ = sys.exc_info()
            is_error_valid = (error == exception) and isinstance(error, ZeroDivisionError)

        @logger.catch(onerror=onerror)
>       def a():
E       TypeError: 'NoneType' object is not callable

is_error_valid = False
onerror    = <function test_onerror.<locals>.onerror at 0x7fac08f5ff40>
writer     = <function writer.<locals>.w at 0x7fac08f5c280>

tests/test_exceptions_catch.py:333: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_onerror_with_reraise">test_exceptions_catch.py::test_onerror_with_reraise</h3>
<details><summary> <pre>test_exceptions_catch.py::test_onerror_with_reraise</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08fa6050>

    def test_onerror_with_reraise(writer):
        called = False
        logger.add(writer, format="{message}")

        def onerror(_):
            nonlocal called
            called = True

        with pytest.raises(ZeroDivisionError):
>           with logger.catch(onerror=onerror, reraise=True):
E           AttributeError: __enter__

called     = False
onerror    = <function test_onerror_with_reraise.<locals>.onerror at 0x7fac08fa68c0>
writer     = <function writer.<locals>.w at 0x7fac08fa6050>

tests/test_exceptions_catch.py:353: AttributeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_decorate_function">test_exceptions_catch.py::test_decorate_function</h3>
<details><summary> <pre>test_exceptions_catch.py::test_decorate_function</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f57e20>

    def test_decorate_function(writer):
        logger.add(writer, format="{message}", diagnose=False, backtrace=False, colorize=False)

        @logger.catch
        def a(x):
            return 100 / x

>       assert a(50) == 2
E       TypeError: 'NoneType' object is not callable

a          = None
writer     = <function writer.<locals>.w at 0x7fac08f57e20>

tests/test_exceptions_catch.py:366: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_decorate_coroutine">test_exceptions_catch.py::test_decorate_coroutine</h3>
<details><summary> <pre>test_exceptions_catch.py::test_decorate_coroutine</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08f5ff40>

    def test_decorate_coroutine(writer):
        logger.add(writer, format="{message}", diagnose=False, backtrace=False, colorize=False)

        @logger.catch
        async def foo(a, b):
            return a + b

>       result = asyncio.run(foo(100, 5))
E       TypeError: 'NoneType' object is not callable

foo        = None
writer     = <function writer.<locals>.w at 0x7fac08f5ff40>

tests/test_exceptions_catch.py:377: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_decorate_generator">test_exceptions_catch.py::test_decorate_generator</h3>
<details><summary> <pre>test_exceptions_catch.py::test_decorate_generator</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac08fa5870>

    def test_decorate_generator(writer):
        @logger.catch
        def foo(x, y, z):
            yield x
            yield y
            return z

>       f = foo(1, 2, 3)
E       TypeError: 'NoneType' object is not callable

foo        = None
writer     = <function writer.<locals>.w at 0x7fac08fa5870>

tests/test_exceptions_catch.py:390: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_decorate_generator_with_error">test_exceptions_catch.py::test_decorate_generator_with_error</h3>
<details><summary> <pre>test_exceptions_catch.py::test_decorate_generator_with_error</pre></summary><pre>
def test_decorate_generator_with_error():
        @logger.catch
        def foo():
            for i in range(3):
                1 / (2 - i)
                yield i

>       assert list(foo()) == [0, 1]
E       TypeError: 'NoneType' object is not callable

foo        = None

tests/test_exceptions_catch.py:405: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_default_with_function">test_exceptions_catch.py::test_default_with_function</h3>
<details><summary> <pre>test_exceptions_catch.py::test_default_with_function</pre></summary><pre>
def test_default_with_function():
        @logger.catch(default=42)
>       def foo():
E       TypeError: 'NoneType' object is not callable


tests/test_exceptions_catch.py:410: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_default_with_generator">test_exceptions_catch.py::test_default_with_generator</h3>
<details><summary> <pre>test_exceptions_catch.py::test_default_with_generator</pre></summary><pre>
def test_default_with_generator():
        @logger.catch(default=42)
>       def foo():
E       TypeError: 'NoneType' object is not callable


tests/test_exceptions_catch.py:418: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_default_with_coroutine">test_exceptions_catch.py::test_default_with_coroutine</h3>
<details><summary> <pre>test_exceptions_catch.py::test_default_with_coroutine</pre></summary><pre>
def test_default_with_coroutine():
        @logger.catch(default=42)
>       async def foo():
E       TypeError: 'NoneType' object is not callable


tests/test_exceptions_catch.py:427: TypeError
</pre>
</details>
<h3 id="test_exceptions_catchpytest_error_when_decorating_class_without_parentheses">test_exceptions_catch.py::test_error_when_decorating_class_without_parentheses</h3>
<details><summary> <pre>test_exceptions_catch.py::test_error_when_decorating_class_without_parentheses</pre></summary><pre>
def test_error_when_decorating_class_without_parentheses():
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

Foo        = None

tests/test_exceptions_catch.py:434: Failed
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_backtracechained_expression_direct">test_exceptions_formatting.py::test_backtrace[chained_expression_direct]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_backtrace[chained_expression_direct]</pre></summary><pre>
filename = 'chained_expression_direct'

    @pytest.mark.parametrize(
        "filename",
        [
            "chained_expression_direct",
            "chained_expression_indirect",
            "chaining_first",
            "chaining_second",
            "chaining_third",
            "enqueue",
            "enqueue_with_others_handlers",
            "frame_values_backward",
            "frame_values_forward",
            "function",
            "head_recursion",
            "missing_attributes_traceback_objects",
            "nested",
            "nested_chained_catch_up",
            "nested_decorator_catch_up",
            "nested_explicit_catch_up",
            "nested_wrapping",
            "no_tb",
            "not_enough_arguments",
            "raising_recursion",
            "suppressed_expression_direct",
            "suppressed_expression_indirect",
            "tail_recursion",
            "too_many_arguments",
        ],
    )
    def test_backtrace(filename):
>       compare_exception("backtrace", filename)

filename   = 'chained_expression_direct'

tests/test_exceptions_formatting.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'backtrace', filename = 'chained_expression_direct'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'backtrace'
filename   = 'chained_expression_direct'
filepath   = 'tests/exceptions/source/backtrace/chained_expression_direct.py'
outpath    = '/testbed/tests/exceptions/output/backtrace/chained_expression_direct.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/backtrace/chained_expression_direct.py", line 10, in <module>\n    def a_decorated():\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_backtracechained_expression_indirect">test_exceptions_formatting.py::test_backtrace[chained_expression_indirect]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_backtrace[chained_expression_indirect]</pre></summary><pre>
filename = 'chained_expression_indirect'

    @pytest.mark.parametrize(
        "filename",
        [
            "chained_expression_direct",
            "chained_expression_indirect",
            "chaining_first",
            "chaining_second",
            "chaining_third",
            "enqueue",
            "enqueue_with_others_handlers",
            "frame_values_backward",
            "frame_values_forward",
            "function",
            "head_recursion",
            "missing_attributes_traceback_objects",
            "nested",
            "nested_chained_catch_up",
            "nested_decorator_catch_up",
            "nested_explicit_catch_up",
            "nested_wrapping",
            "no_tb",
            "not_enough_arguments",
            "raising_recursion",
            "suppressed_expression_direct",
            "suppressed_expression_indirect",
            "tail_recursion",
            "too_many_arguments",
        ],
    )
    def test_backtrace(filename):
>       compare_exception("backtrace", filename)

filename   = 'chained_expression_indirect'

tests/test_exceptions_formatting.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'backtrace', filename = 'chained_expression_indirect'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'backtrace'
filename   = 'chained_expression_indirect'
filepath   = 'tests/exceptions/source/backtrace/chained_expression_indirect.py'
outpath    = '/testbed/tests/exceptions/output/backtrace/chained_expression_indirect.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/backtrace/chained_expression_indirect.py", line 21, in <module>\n    b()\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_backtracechaining_first">test_exceptions_formatting.py::test_backtrace[chaining_first]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_backtrace[chaining_first]</pre></summary><pre>
filename = 'chaining_first'

    @pytest.mark.parametrize(
        "filename",
        [
            "chained_expression_direct",
            "chained_expression_indirect",
            "chaining_first",
            "chaining_second",
            "chaining_third",
            "enqueue",
            "enqueue_with_others_handlers",
            "frame_values_backward",
            "frame_values_forward",
            "function",
            "head_recursion",
            "missing_attributes_traceback_objects",
            "nested",
            "nested_chained_catch_up",
            "nested_decorator_catch_up",
            "nested_explicit_catch_up",
            "nested_wrapping",
            "no_tb",
            "not_enough_arguments",
            "raising_recursion",
            "suppressed_expression_direct",
            "suppressed_expression_indirect",
            "tail_recursion",
            "too_many_arguments",
        ],
    )
    def test_backtrace(filename):
>       compare_exception("backtrace", filename)

filename   = 'chaining_first'

tests/test_exceptions_formatting.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'backtrace', filename = 'chaining_first'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'backtrace'
filename   = 'chaining_first'
filepath   = 'tests/exceptions/source/backtrace/chaining_first.py'
outpath    = '/testbed/tests/exceptions/output/backtrace/chaining_first.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/backtrace/chaining_first.py", line 26, in <module>\n    a_decorated()\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_backtracechaining_second">test_exceptions_formatting.py::test_backtrace[chaining_second]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_backtrace[chaining_second]</pre></summary><pre>
filename = 'chaining_second'

    @pytest.mark.parametrize(
        "filename",
        [
            "chained_expression_direct",
            "chained_expression_indirect",
            "chaining_first",
            "chaining_second",
            "chaining_third",
            "enqueue",
            "enqueue_with_others_handlers",
            "frame_values_backward",
            "frame_values_forward",
            "function",
            "head_recursion",
            "missing_attributes_traceback_objects",
            "nested",
            "nested_chained_catch_up",
            "nested_decorator_catch_up",
            "nested_explicit_catch_up",
            "nested_wrapping",
            "no_tb",
            "not_enough_arguments",
            "raising_recursion",
            "suppressed_expression_direct",
            "suppressed_expression_indirect",
            "tail_recursion",
            "too_many_arguments",
        ],
    )
    def test_backtrace(filename):
>       compare_exception("backtrace", filename)

filename   = 'chaining_second'

tests/test_exceptions_formatting.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'backtrace', filename = 'chaining_second'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'backtrace'
filename   = 'chaining_second'
filepath   = 'tests/exceptions/source/backtrace/chaining_second.py'
outpath    = '/testbed/tests/exceptions/output/backtrace/chaining_second.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/backtrace/chaining_second.py", line 26, in <module>\n    def b_decorated():\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_backtracechaining_third">test_exceptions_formatting.py::test_backtrace[chaining_third]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_backtrace[chaining_third]</pre></summary><pre>
filename = 'chaining_third'

    @pytest.mark.parametrize(
        "filename",
        [
            "chained_expression_direct",
            "chained_expression_indirect",
            "chaining_first",
            "chaining_second",
            "chaining_third",
            "enqueue",
            "enqueue_with_others_handlers",
            "frame_values_backward",
            "frame_values_forward",
            "function",
            "head_recursion",
            "missing_attributes_traceback_objects",
            "nested",
            "nested_chained_catch_up",
            "nested_decorator_catch_up",
            "nested_explicit_catch_up",
            "nested_wrapping",
            "no_tb",
            "not_enough_arguments",
            "raising_recursion",
            "suppressed_expression_direct",
            "suppressed_expression_indirect",
            "tail_recursion",
            "too_many_arguments",
        ],
    )
    def test_backtrace(filename):
>       compare_exception("backtrace", filename)

filename   = 'chaining_third'

tests/test_exceptions_formatting.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'backtrace', filename = 'chaining_third'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'backtrace'
filename   = 'chaining_third'
filepath   = 'tests/exceptions/source/backtrace/chaining_third.py'
outpath    = '/testbed/tests/exceptions/output/backtrace/chaining_third.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/backtrace/chaining_third.py", line 46, i...trace/chaining_third.py", line 22, in b_decorator\n    c_decorated()\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_backtraceenqueue">test_exceptions_formatting.py::test_backtrace[enqueue]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_backtrace[enqueue]</pre></summary><pre>
filename = 'enqueue'

    @pytest.mark.parametrize(
        "filename",
        [
            "chained_expression_direct",
            "chained_expression_indirect",
            "chaining_first",
            "chaining_second",
            "chaining_third",
            "enqueue",
            "enqueue_with_others_handlers",
            "frame_values_backward",
            "frame_values_forward",
            "function",
            "head_recursion",
            "missing_attributes_traceback_objects",
            "nested",
            "nested_chained_catch_up",
            "nested_decorator_catch_up",
            "nested_explicit_catch_up",
            "nested_wrapping",
            "no_tb",
            "not_enough_arguments",
            "raising_recursion",
            "suppressed_expression_direct",
            "suppressed_expression_indirect",
            "tail_recursion",
            "too_many_arguments",
        ],
    )
    def test_backtrace(filename):
>       compare_exception("backtrace", filename)

filename   = 'enqueue'

tests/test_exceptions_formatting.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'backtrace', filename = 'enqueue'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'backtrace'
filename   = 'enqueue'
filepath   = 'tests/exceptions/source/backtrace/enqueue.py'
outpath    = '/testbed/tests/exceptions/output/backtrace/enqueue.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_backtraceenqueue_with_others_handlers">test_exceptions_formatting.py::test_backtrace[enqueue_with_others_handlers]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_backtrace[enqueue_with_others_handlers]</pre></summary><pre>
filename = 'enqueue_with_others_handlers'

    @pytest.mark.parametrize(
        "filename",
        [
            "chained_expression_direct",
            "chained_expression_indirect",
            "chaining_first",
            "chaining_second",
            "chaining_third",
            "enqueue",
            "enqueue_with_others_handlers",
            "frame_values_backward",
            "frame_values_forward",
            "function",
            "head_recursion",
            "missing_attributes_traceback_objects",
            "nested",
            "nested_chained_catch_up",
            "nested_decorator_catch_up",
            "nested_explicit_catch_up",
            "nested_wrapping",
            "no_tb",
            "not_enough_arguments",
            "raising_recursion",
            "suppressed_expression_direct",
            "suppressed_expression_indirect",
            "tail_recursion",
            "too_many_arguments",
        ],
    )
    def test_backtrace(filename):
>       compare_exception("backtrace", filename)

filename   = 'enqueue_with_others_handlers'

tests/test_exceptions_formatting.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'backtrace', filename = 'enqueue_with_others_handlers'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'backtrace'
filename   = 'enqueue_with_others_handlers'
filepath   = 'tests/exceptions/source/backtrace/enqueue_with_others_handlers.py'
outpath    = '/testbed/tests/exceptions/output/backtrace/enqueue_with_others_handlers.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_backtraceframe_values_backward">test_exceptions_formatting.py::test_backtrace[frame_values_backward]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_backtrace[frame_values_backward]</pre></summary><pre>
filename = 'frame_values_backward'

    @pytest.mark.parametrize(
        "filename",
        [
            "chained_expression_direct",
            "chained_expression_indirect",
            "chaining_first",
            "chaining_second",
            "chaining_third",
            "enqueue",
            "enqueue_with_others_handlers",
            "frame_values_backward",
            "frame_values_forward",
            "function",
            "head_recursion",
            "missing_attributes_traceback_objects",
            "nested",
            "nested_chained_catch_up",
            "nested_decorator_catch_up",
            "nested_explicit_catch_up",
            "nested_wrapping",
            "no_tb",
            "not_enough_arguments",
            "raising_recursion",
            "suppressed_expression_direct",
            "suppressed_expression_indirect",
            "tail_recursion",
            "too_many_arguments",
        ],
    )
    def test_backtrace(filename):
>       compare_exception("backtrace", filename)

filename   = 'frame_values_backward'

tests/test_exceptions_formatting.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'backtrace', filename = 'frame_values_backward'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'backtrace'
filename   = 'frame_values_backward'
filepath   = 'tests/exceptions/source/backtrace/frame_values_backward.py'
outpath    = '/testbed/tests/exceptions/output/backtrace/frame_values_backward.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/backtrace/frame_values_backward.py", lin...rce/backtrace/frame_values_backward.py", line 17, in b\n    a(n - 1)\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_backtraceframe_values_forward">test_exceptions_formatting.py::test_backtrace[frame_values_forward]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_backtrace[frame_values_forward]</pre></summary><pre>
filename = 'frame_values_forward'

    @pytest.mark.parametrize(
        "filename",
        [
            "chained_expression_direct",
            "chained_expression_indirect",
            "chaining_first",
            "chaining_second",
            "chaining_third",
            "enqueue",
            "enqueue_with_others_handlers",
            "frame_values_backward",
            "frame_values_forward",
            "function",
            "head_recursion",
            "missing_attributes_traceback_objects",
            "nested",
            "nested_chained_catch_up",
            "nested_decorator_catch_up",
            "nested_explicit_catch_up",
            "nested_wrapping",
            "no_tb",
            "not_enough_arguments",
            "raising_recursion",
            "suppressed_expression_direct",
            "suppressed_expression_indirect",
            "tail_recursion",
            "too_many_arguments",
        ],
    )
    def test_backtrace(filename):
>       compare_exception("backtrace", filename)

filename   = 'frame_values_forward'

tests/test_exceptions_formatting.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'backtrace', filename = 'frame_values_forward'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'backtrace'
filename   = 'frame_values_forward'
filepath   = 'tests/exceptions/source/backtrace/frame_values_forward.py'
outpath    = '/testbed/tests/exceptions/output/backtrace/frame_values_forward.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/backtrace/frame_values_forward.py", line 24, in <module>\n    c(k)\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_backtracefunction">test_exceptions_formatting.py::test_backtrace[function]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_backtrace[function]</pre></summary><pre>
filename = 'function'

    @pytest.mark.parametrize(
        "filename",
        [
            "chained_expression_direct",
            "chained_expression_indirect",
            "chaining_first",
            "chaining_second",
            "chaining_third",
            "enqueue",
            "enqueue_with_others_handlers",
            "frame_values_backward",
            "frame_values_forward",
            "function",
            "head_recursion",
            "missing_attributes_traceback_objects",
            "nested",
            "nested_chained_catch_up",
            "nested_decorator_catch_up",
            "nested_explicit_catch_up",
            "nested_wrapping",
            "no_tb",
            "not_enough_arguments",
            "raising_recursion",
            "suppressed_expression_direct",
            "suppressed_expression_indirect",
            "tail_recursion",
            "too_many_arguments",
        ],
    )
    def test_backtrace(filename):
>       compare_exception("backtrace", filename)

filename   = 'function'

tests/test_exceptions_formatting.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'backtrace', filename = 'function'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'backtrace'
filename   = 'function'
filepath   = 'tests/exceptions/source/backtrace/function.py'
outpath    = '/testbed/tests/exceptions/output/backtrace/function.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/backtrace/function.py", line 10, in <module>\n    def a():\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_backtracehead_recursion">test_exceptions_formatting.py::test_backtrace[head_recursion]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_backtrace[head_recursion]</pre></summary><pre>
filename = 'head_recursion'

    @pytest.mark.parametrize(
        "filename",
        [
            "chained_expression_direct",
            "chained_expression_indirect",
            "chaining_first",
            "chaining_second",
            "chaining_third",
            "enqueue",
            "enqueue_with_others_handlers",
            "frame_values_backward",
            "frame_values_forward",
            "function",
            "head_recursion",
            "missing_attributes_traceback_objects",
            "nested",
            "nested_chained_catch_up",
            "nested_decorator_catch_up",
            "nested_explicit_catch_up",
            "nested_wrapping",
            "no_tb",
            "not_enough_arguments",
            "raising_recursion",
            "suppressed_expression_direct",
            "suppressed_expression_indirect",
            "tail_recursion",
            "too_many_arguments",
        ],
    )
    def test_backtrace(filename):
>       compare_exception("backtrace", filename)

filename   = 'head_recursion'

tests/test_exceptions_formatting.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'backtrace', filename = 'head_recursion'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'backtrace'
filename   = 'head_recursion'
filepath   = 'tests/exceptions/source/backtrace/head_recursion.py'
outpath    = '/testbed/tests/exceptions/output/backtrace/head_recursion.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/backtrace/head_recursion.py", line 10, in <module>\n    def a(n):\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_backtracemissing_attributes_traceback_objects">test_exceptions_formatting.py::test_backtrace[missing_attributes_traceback_objects]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_backtrace[missing_attributes_traceback_objects]</pre></summary><pre>
filename = 'missing_attributes_traceback_objects'

    @pytest.mark.parametrize(
        "filename",
        [
            "chained_expression_direct",
            "chained_expression_indirect",
            "chaining_first",
            "chaining_second",
            "chaining_third",
            "enqueue",
            "enqueue_with_others_handlers",
            "frame_values_backward",
            "frame_values_forward",
            "function",
            "head_recursion",
            "missing_attributes_traceback_objects",
            "nested",
            "nested_chained_catch_up",
            "nested_decorator_catch_up",
            "nested_explicit_catch_up",
            "nested_wrapping",
            "no_tb",
            "not_enough_arguments",
            "raising_recursion",
            "suppressed_expression_direct",
            "suppressed_expression_indirect",
            "tail_recursion",
            "too_many_arguments",
        ],
    )
    def test_backtrace(filename):
>       compare_exception("backtrace", filename)

filename   = 'missing_attributes_traceback_objects'

tests/test_exceptions_formatting.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'backtrace', filename = 'missing_attributes_traceback_objects'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'backtrace'
filename   = 'missing_attributes_traceback_objects'
filepath   = 'tests/exceptions/source/backtrace/missing_attributes_traceback_objects.py'
outpath    = '/testbed/tests/exceptions/output/backtrace/missing_attributes_traceback_objects.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/backtrace/missing_attributes_traceback_o...  logger.opt(exception=(type_, value, tb)).error("")\nAttributeError: \'NoneType\' object has no attribute \'error\'\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_backtracenested">test_exceptions_formatting.py::test_backtrace[nested]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_backtrace[nested]</pre></summary><pre>
filename = 'nested'

    @pytest.mark.parametrize(
        "filename",
        [
            "chained_expression_direct",
            "chained_expression_indirect",
            "chaining_first",
            "chaining_second",
            "chaining_third",
            "enqueue",
            "enqueue_with_others_handlers",
            "frame_values_backward",
            "frame_values_forward",
            "function",
            "head_recursion",
            "missing_attributes_traceback_objects",
            "nested",
            "nested_chained_catch_up",
            "nested_decorator_catch_up",
            "nested_explicit_catch_up",
            "nested_wrapping",
            "no_tb",
            "not_enough_arguments",
            "raising_recursion",
            "suppressed_expression_direct",
            "suppressed_expression_indirect",
            "tail_recursion",
            "too_many_arguments",
        ],
    )
    def test_backtrace(filename):
>       compare_exception("backtrace", filename)

filename   = 'nested'

tests/test_exceptions_formatting.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'backtrace', filename = 'nested'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'backtrace'
filename   = 'nested'
filepath   = 'tests/exceptions/source/backtrace/nested.py'
outpath    = '/testbed/tests/exceptions/output/backtrace/nested.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/backtrace/nested.py", line 17, in <modul...exceptions/source/backtrace/nested.py", line 14, in a\n    nested(x)\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_backtracenested_chained_catch_up">test_exceptions_formatting.py::test_backtrace[nested_chained_catch_up]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_backtrace[nested_chained_catch_up]</pre></summary><pre>
filename = 'nested_chained_catch_up'

    @pytest.mark.parametrize(
        "filename",
        [
            "chained_expression_direct",
            "chained_expression_indirect",
            "chaining_first",
            "chaining_second",
            "chaining_third",
            "enqueue",
            "enqueue_with_others_handlers",
            "frame_values_backward",
            "frame_values_forward",
            "function",
            "head_recursion",
            "missing_attributes_traceback_objects",
            "nested",
            "nested_chained_catch_up",
            "nested_decorator_catch_up",
            "nested_explicit_catch_up",
            "nested_wrapping",
            "no_tb",
            "not_enough_arguments",
            "raising_recursion",
            "suppressed_expression_direct",
            "suppressed_expression_indirect",
            "tail_recursion",
            "too_many_arguments",
        ],
    )
    def test_backtrace(filename):
>       compare_exception("backtrace", filename)

filename   = 'nested_chained_catch_up'

tests/test_exceptions_formatting.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'backtrace', filename = 'nested_chained_catch_up'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'backtrace'
filename   = 'nested_chained_catch_up'
filepath   = 'tests/exceptions/source/backtrace/nested_chained_catch_up.py'
outpath    = '/testbed/tests/exceptions/output/backtrace/nested_chained_catch_up.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/backtrace/nested_chained_catch_up.py", line 15, in <module>\n    def bar():\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_backtracenested_decorator_catch_up">test_exceptions_formatting.py::test_backtrace[nested_decorator_catch_up]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_backtrace[nested_decorator_catch_up]</pre></summary><pre>
filename = 'nested_decorator_catch_up'

    @pytest.mark.parametrize(
        "filename",
        [
            "chained_expression_direct",
            "chained_expression_indirect",
            "chaining_first",
            "chaining_second",
            "chaining_third",
            "enqueue",
            "enqueue_with_others_handlers",
            "frame_values_backward",
            "frame_values_forward",
            "function",
            "head_recursion",
            "missing_attributes_traceback_objects",
            "nested",
            "nested_chained_catch_up",
            "nested_decorator_catch_up",
            "nested_explicit_catch_up",
            "nested_wrapping",
            "no_tb",
            "not_enough_arguments",
            "raising_recursion",
            "suppressed_expression_direct",
            "suppressed_expression_indirect",
            "tail_recursion",
            "too_many_arguments",
        ],
    )
    def test_backtrace(filename):
>       compare_exception("backtrace", filename)

filename   = 'nested_decorator_catch_up'

tests/test_exceptions_formatting.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'backtrace', filename = 'nested_decorator_catch_up'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'backtrace'
filename   = 'nested_decorator_catch_up'
filepath   = 'tests/exceptions/source/backtrace/nested_decorator_catch_up.py'
outpath    = '/testbed/tests/exceptions/output/backtrace/nested_decorator_catch_up.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/backtrace/nested_decorator_catch_up.py", line 11, in <module>\n    def foo():\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_backtracenested_explicit_catch_up">test_exceptions_formatting.py::test_backtrace[nested_explicit_catch_up]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_backtrace[nested_explicit_catch_up]</pre></summary><pre>
filename = 'nested_explicit_catch_up'

    @pytest.mark.parametrize(
        "filename",
        [
            "chained_expression_direct",
            "chained_expression_indirect",
            "chaining_first",
            "chaining_second",
            "chaining_third",
            "enqueue",
            "enqueue_with_others_handlers",
            "frame_values_backward",
            "frame_values_forward",
            "function",
            "head_recursion",
            "missing_attributes_traceback_objects",
            "nested",
            "nested_chained_catch_up",
            "nested_decorator_catch_up",
            "nested_explicit_catch_up",
            "nested_wrapping",
            "no_tb",
            "not_enough_arguments",
            "raising_recursion",
            "suppressed_expression_direct",
            "suppressed_expression_indirect",
            "tail_recursion",
            "too_many_arguments",
        ],
    )
    def test_backtrace(filename):
>       compare_exception("backtrace", filename)

filename   = 'nested_explicit_catch_up'

tests/test_exceptions_formatting.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'backtrace', filename = 'nested_explicit_catch_up'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'backtrace'
filename   = 'nested_explicit_catch_up'
filepath   = 'tests/exceptions/source/backtrace/nested_explicit_catch_up.py'
outpath    = '/testbed/tests/exceptions/output/backtrace/nested_explicit_catch_up.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/backtrace/nested_explicit_catch_up.py", line 15, in <module>\n    def bar():\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_backtracenested_wrapping">test_exceptions_formatting.py::test_backtrace[nested_wrapping]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_backtrace[nested_wrapping]</pre></summary><pre>
filename = 'nested_wrapping'

    @pytest.mark.parametrize(
        "filename",
        [
            "chained_expression_direct",
            "chained_expression_indirect",
            "chaining_first",
            "chaining_second",
            "chaining_third",
            "enqueue",
            "enqueue_with_others_handlers",
            "frame_values_backward",
            "frame_values_forward",
            "function",
            "head_recursion",
            "missing_attributes_traceback_objects",
            "nested",
            "nested_chained_catch_up",
            "nested_decorator_catch_up",
            "nested_explicit_catch_up",
            "nested_wrapping",
            "no_tb",
            "not_enough_arguments",
            "raising_recursion",
            "suppressed_expression_direct",
            "suppressed_expression_indirect",
            "tail_recursion",
            "too_many_arguments",
        ],
    )
    def test_backtrace(filename):
>       compare_exception("backtrace", filename)

filename   = 'nested_wrapping'

tests/test_exceptions_formatting.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'backtrace', filename = 'nested_wrapping'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'backtrace'
filename   = 'nested_wrapping'
filepath   = 'tests/exceptions/source/backtrace/nested_wrapping.py'
outpath    = '/testbed/tests/exceptions/output/backtrace/nested_wrapping.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/backtrace/nested_wrapping.py", line 15, in <module>\n    def a(x):\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_backtraceno_tb">test_exceptions_formatting.py::test_backtrace[no_tb]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_backtrace[no_tb]</pre></summary><pre>
filename = 'no_tb'

    @pytest.mark.parametrize(
        "filename",
        [
            "chained_expression_direct",
            "chained_expression_indirect",
            "chaining_first",
            "chaining_second",
            "chaining_third",
            "enqueue",
            "enqueue_with_others_handlers",
            "frame_values_backward",
            "frame_values_forward",
            "function",
            "head_recursion",
            "missing_attributes_traceback_objects",
            "nested",
            "nested_chained_catch_up",
            "nested_decorator_catch_up",
            "nested_explicit_catch_up",
            "nested_wrapping",
            "no_tb",
            "not_enough_arguments",
            "raising_recursion",
            "suppressed_expression_direct",
            "suppressed_expression_indirect",
            "tail_recursion",
            "too_many_arguments",
        ],
    )
    def test_backtrace(filename):
>       compare_exception("backtrace", filename)

filename   = 'no_tb'

tests/test_exceptions_formatting.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'backtrace', filename = 'no_tb'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'backtrace'
filename   = 'no_tb'
filepath   = 'tests/exceptions/source/backtrace/no_tb.py'
outpath    = '/testbed/tests/exceptions/output/backtrace/no_tb.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/backtrace/no_tb.py", line 19, in <module...gger.opt(exception=(ex_type, ex, tb)).debug("Test:")\nAttributeError: \'NoneType\' object has no attribute \'debug\'\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_backtracenot_enough_arguments">test_exceptions_formatting.py::test_backtrace[not_enough_arguments]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_backtrace[not_enough_arguments]</pre></summary><pre>
filename = 'not_enough_arguments'

    @pytest.mark.parametrize(
        "filename",
        [
            "chained_expression_direct",
            "chained_expression_indirect",
            "chaining_first",
            "chaining_second",
            "chaining_third",
            "enqueue",
            "enqueue_with_others_handlers",
            "frame_values_backward",
            "frame_values_forward",
            "function",
            "head_recursion",
            "missing_attributes_traceback_objects",
            "nested",
            "nested_chained_catch_up",
            "nested_decorator_catch_up",
            "nested_explicit_catch_up",
            "nested_wrapping",
            "no_tb",
            "not_enough_arguments",
            "raising_recursion",
            "suppressed_expression_direct",
            "suppressed_expression_indirect",
            "tail_recursion",
            "too_many_arguments",
        ],
    )
    def test_backtrace(filename):
>       compare_exception("backtrace", filename)

filename   = 'not_enough_arguments'

tests/test_exceptions_formatting.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'backtrace', filename = 'not_enough_arguments'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'backtrace'
filename   = 'not_enough_arguments'
filepath   = 'tests/exceptions/source/backtrace/not_enough_arguments.py'
outpath    = '/testbed/tests/exceptions/output/backtrace/not_enough_arguments.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/backtrace/not_enough_arguments.py", line 18, in <module>\n    decorated(1)\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_backtraceraising_recursion">test_exceptions_formatting.py::test_backtrace[raising_recursion]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_backtrace[raising_recursion]</pre></summary><pre>
filename = 'raising_recursion'

    @pytest.mark.parametrize(
        "filename",
        [
            "chained_expression_direct",
            "chained_expression_indirect",
            "chaining_first",
            "chaining_second",
            "chaining_third",
            "enqueue",
            "enqueue_with_others_handlers",
            "frame_values_backward",
            "frame_values_forward",
            "function",
            "head_recursion",
            "missing_attributes_traceback_objects",
            "nested",
            "nested_chained_catch_up",
            "nested_decorator_catch_up",
            "nested_explicit_catch_up",
            "nested_wrapping",
            "no_tb",
            "not_enough_arguments",
            "raising_recursion",
            "suppressed_expression_direct",
            "suppressed_expression_indirect",
            "tail_recursion",
            "too_many_arguments",
        ],
    )
    def test_backtrace(filename):
>       compare_exception("backtrace", filename)

filename   = 'raising_recursion'

tests/test_exceptions_formatting.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'backtrace', filename = 'raising_recursion'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'backtrace'
filename   = 'raising_recursion'
filepath   = 'tests/exceptions/source/backtrace/raising_recursion.py'
outpath    = '/testbed/tests/exceptions/output/backtrace/raising_recursion.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/backtrace/raising_recursion.py", line 32, in <module>\n    a(1)\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_backtracesuppressed_expression_direct">test_exceptions_formatting.py::test_backtrace[suppressed_expression_direct]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_backtrace[suppressed_expression_direct]</pre></summary><pre>
filename = 'suppressed_expression_direct'

    @pytest.mark.parametrize(
        "filename",
        [
            "chained_expression_direct",
            "chained_expression_indirect",
            "chaining_first",
            "chaining_second",
            "chaining_third",
            "enqueue",
            "enqueue_with_others_handlers",
            "frame_values_backward",
            "frame_values_forward",
            "function",
            "head_recursion",
            "missing_attributes_traceback_objects",
            "nested",
            "nested_chained_catch_up",
            "nested_decorator_catch_up",
            "nested_explicit_catch_up",
            "nested_wrapping",
            "no_tb",
            "not_enough_arguments",
            "raising_recursion",
            "suppressed_expression_direct",
            "suppressed_expression_indirect",
            "tail_recursion",
            "too_many_arguments",
        ],
    )
    def test_backtrace(filename):
>       compare_exception("backtrace", filename)

filename   = 'suppressed_expression_direct'

tests/test_exceptions_formatting.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'backtrace', filename = 'suppressed_expression_direct'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'backtrace'
filename   = 'suppressed_expression_direct'
filepath   = 'tests/exceptions/source/backtrace/suppressed_expression_direct.py'
outpath    = '/testbed/tests/exceptions/output/backtrace/suppressed_expression_direct.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/backtrace/suppressed_expression_direct.p...ed_expression_direct.py", line 29, in c_decorator\n    b_decorated()\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_backtracesuppressed_expression_indirect">test_exceptions_formatting.py::test_backtrace[suppressed_expression_indirect]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_backtrace[suppressed_expression_indirect]</pre></summary><pre>
filename = 'suppressed_expression_indirect'

    @pytest.mark.parametrize(
        "filename",
        [
            "chained_expression_direct",
            "chained_expression_indirect",
            "chaining_first",
            "chaining_second",
            "chaining_third",
            "enqueue",
            "enqueue_with_others_handlers",
            "frame_values_backward",
            "frame_values_forward",
            "function",
            "head_recursion",
            "missing_attributes_traceback_objects",
            "nested",
            "nested_chained_catch_up",
            "nested_decorator_catch_up",
            "nested_explicit_catch_up",
            "nested_wrapping",
            "no_tb",
            "not_enough_arguments",
            "raising_recursion",
            "suppressed_expression_direct",
            "suppressed_expression_indirect",
            "tail_recursion",
            "too_many_arguments",
        ],
    )
    def test_backtrace(filename):
>       compare_exception("backtrace", filename)

filename   = 'suppressed_expression_indirect'

tests/test_exceptions_formatting.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'backtrace', filename = 'suppressed_expression_indirect'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'backtrace'
filename   = 'suppressed_expression_indirect'
filepath   = 'tests/exceptions/source/backtrace/suppressed_expression_indirect.py'
outpath    = '/testbed/tests/exceptions/output/backtrace/suppressed_expression_indirect.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/backtrace/suppressed_expression_indirect.py", line 29, in <module>\n    c_decorated()\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_backtracetail_recursion">test_exceptions_formatting.py::test_backtrace[tail_recursion]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_backtrace[tail_recursion]</pre></summary><pre>
filename = 'tail_recursion'

    @pytest.mark.parametrize(
        "filename",
        [
            "chained_expression_direct",
            "chained_expression_indirect",
            "chaining_first",
            "chaining_second",
            "chaining_third",
            "enqueue",
            "enqueue_with_others_handlers",
            "frame_values_backward",
            "frame_values_forward",
            "function",
            "head_recursion",
            "missing_attributes_traceback_objects",
            "nested",
            "nested_chained_catch_up",
            "nested_decorator_catch_up",
            "nested_explicit_catch_up",
            "nested_wrapping",
            "no_tb",
            "not_enough_arguments",
            "raising_recursion",
            "suppressed_expression_direct",
            "suppressed_expression_indirect",
            "tail_recursion",
            "too_many_arguments",
        ],
    )
    def test_backtrace(filename):
>       compare_exception("backtrace", filename)

filename   = 'tail_recursion'

tests/test_exceptions_formatting.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'backtrace', filename = 'tail_recursion'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'backtrace'
filename   = 'tail_recursion'
filepath   = 'tests/exceptions/source/backtrace/tail_recursion.py'
outpath    = '/testbed/tests/exceptions/output/backtrace/tail_recursion.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/backtrace/tail_recursion.py", line 10, in <module>\n    def a(n):\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_backtracetoo_many_arguments">test_exceptions_formatting.py::test_backtrace[too_many_arguments]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_backtrace[too_many_arguments]</pre></summary><pre>
filename = 'too_many_arguments'

    @pytest.mark.parametrize(
        "filename",
        [
            "chained_expression_direct",
            "chained_expression_indirect",
            "chaining_first",
            "chaining_second",
            "chaining_third",
            "enqueue",
            "enqueue_with_others_handlers",
            "frame_values_backward",
            "frame_values_forward",
            "function",
            "head_recursion",
            "missing_attributes_traceback_objects",
            "nested",
            "nested_chained_catch_up",
            "nested_decorator_catch_up",
            "nested_explicit_catch_up",
            "nested_wrapping",
            "no_tb",
            "not_enough_arguments",
            "raising_recursion",
            "suppressed_expression_direct",
            "suppressed_expression_indirect",
            "tail_recursion",
            "too_many_arguments",
        ],
    )
    def test_backtrace(filename):
>       compare_exception("backtrace", filename)

filename   = 'too_many_arguments'

tests/test_exceptions_formatting.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'backtrace', filename = 'too_many_arguments'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'backtrace'
filename   = 'too_many_arguments'
filepath   = 'tests/exceptions/source/backtrace/too_many_arguments.py'
outpath    = '/testbed/tests/exceptions/output/backtrace/too_many_arguments.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/backtrace/too_many_arguments.py", line 18, in <module>\n    decorated(1)\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_diagnoseassertion_error">test_exceptions_formatting.py::test_diagnose[assertion_error]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_diagnose[assertion_error]</pre></summary><pre>
filename = 'assertion_error'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_error",
            "assertion_error_custom",
            "assertion_error_in_string",
            "attributes",
            "chained_both",
            "encoding",
            "global_variable",
            "indentation_error",
            "keyword_argument",
            "multilines_repr",
            "no_error_message",
            "parenthesis",
            "source_multilines",
            "source_strings",
            "syntax_error",
            "syntax_highlighting",
            "truncating",
            "unprintable_object",
        ],
    )
    def test_diagnose(filename):
>       compare_exception("diagnose", filename)

filename   = 'assertion_error'

tests/test_exceptions_formatting.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'diagnose', filename = 'assertion_error'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'diagnose'
filename   = 'assertion_error'
filepath   = 'tests/exceptions/source/diagnose/assertion_error.py'
outpath    = '/testbed/tests/exceptions/output/diagnose/assertion_error.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_diagnoseassertion_error_custom">test_exceptions_formatting.py::test_diagnose[assertion_error_custom]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_diagnose[assertion_error_custom]</pre></summary><pre>
filename = 'assertion_error_custom'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_error",
            "assertion_error_custom",
            "assertion_error_in_string",
            "attributes",
            "chained_both",
            "encoding",
            "global_variable",
            "indentation_error",
            "keyword_argument",
            "multilines_repr",
            "no_error_message",
            "parenthesis",
            "source_multilines",
            "source_strings",
            "syntax_error",
            "syntax_highlighting",
            "truncating",
            "unprintable_object",
        ],
    )
    def test_diagnose(filename):
>       compare_exception("diagnose", filename)

filename   = 'assertion_error_custom'

tests/test_exceptions_formatting.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'diagnose', filename = 'assertion_error_custom'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'diagnose'
filename   = 'assertion_error_custom'
filepath   = 'tests/exceptions/source/diagnose/assertion_error_custom.py'
outpath    = '/testbed/tests/exceptions/output/diagnose/assertion_error_custom.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_diagnoseassertion_error_in_string">test_exceptions_formatting.py::test_diagnose[assertion_error_in_string]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_diagnose[assertion_error_in_string]</pre></summary><pre>
filename = 'assertion_error_in_string'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_error",
            "assertion_error_custom",
            "assertion_error_in_string",
            "attributes",
            "chained_both",
            "encoding",
            "global_variable",
            "indentation_error",
            "keyword_argument",
            "multilines_repr",
            "no_error_message",
            "parenthesis",
            "source_multilines",
            "source_strings",
            "syntax_error",
            "syntax_highlighting",
            "truncating",
            "unprintable_object",
        ],
    )
    def test_diagnose(filename):
>       compare_exception("diagnose", filename)

filename   = 'assertion_error_in_string'

tests/test_exceptions_formatting.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'diagnose', filename = 'assertion_error_in_string'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'diagnose'
filename   = 'assertion_error_in_string'
filepath   = 'tests/exceptions/source/diagnose/assertion_error_in_string.py'
outpath    = '/testbed/tests/exceptions/output/diagnose/assertion_error_in_string.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_diagnoseattributes">test_exceptions_formatting.py::test_diagnose[attributes]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_diagnose[attributes]</pre></summary><pre>
filename = 'attributes'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_error",
            "assertion_error_custom",
            "assertion_error_in_string",
            "attributes",
            "chained_both",
            "encoding",
            "global_variable",
            "indentation_error",
            "keyword_argument",
            "multilines_repr",
            "no_error_message",
            "parenthesis",
            "source_multilines",
            "source_strings",
            "syntax_error",
            "syntax_highlighting",
            "truncating",
            "unprintable_object",
        ],
    )
    def test_diagnose(filename):
>       compare_exception("diagnose", filename)

filename   = 'attributes'

tests/test_exceptions_formatting.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'diagnose', filename = 'attributes'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'diagnose'
filename   = 'attributes'
filepath   = 'tests/exceptions/source/diagnose/attributes.py'
outpath    = '/testbed/tests/exceptions/output/diagnose/attributes.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_diagnosechained_both">test_exceptions_formatting.py::test_diagnose[chained_both]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_diagnose[chained_both]</pre></summary><pre>
filename = 'chained_both'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_error",
            "assertion_error_custom",
            "assertion_error_in_string",
            "attributes",
            "chained_both",
            "encoding",
            "global_variable",
            "indentation_error",
            "keyword_argument",
            "multilines_repr",
            "no_error_message",
            "parenthesis",
            "source_multilines",
            "source_strings",
            "syntax_error",
            "syntax_highlighting",
            "truncating",
            "unprintable_object",
        ],
    )
    def test_diagnose(filename):
>       compare_exception("diagnose", filename)

filename   = 'chained_both'

tests/test_exceptions_formatting.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'diagnose', filename = 'chained_both'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'diagnose'
filename   = 'chained_both'
filepath   = 'tests/exceptions/source/diagnose/chained_both.py'
outpath    = '/testbed/tests/exceptions/output/diagnose/chained_both.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_diagnoseencoding">test_exceptions_formatting.py::test_diagnose[encoding]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_diagnose[encoding]</pre></summary><pre>
filename = 'encoding'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_error",
            "assertion_error_custom",
            "assertion_error_in_string",
            "attributes",
            "chained_both",
            "encoding",
            "global_variable",
            "indentation_error",
            "keyword_argument",
            "multilines_repr",
            "no_error_message",
            "parenthesis",
            "source_multilines",
            "source_strings",
            "syntax_error",
            "syntax_highlighting",
            "truncating",
            "unprintable_object",
        ],
    )
    def test_diagnose(filename):
>       compare_exception("diagnose", filename)

filename   = 'encoding'

tests/test_exceptions_formatting.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'diagnose', filename = 'encoding'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'diagnose'
filename   = 'encoding'
filepath   = 'tests/exceptions/source/diagnose/encoding.py'
outpath    = '/testbed/tests/exceptions/output/diagnose/encoding.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_diagnoseglobal_variable">test_exceptions_formatting.py::test_diagnose[global_variable]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_diagnose[global_variable]</pre></summary><pre>
filename = 'global_variable'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_error",
            "assertion_error_custom",
            "assertion_error_in_string",
            "attributes",
            "chained_both",
            "encoding",
            "global_variable",
            "indentation_error",
            "keyword_argument",
            "multilines_repr",
            "no_error_message",
            "parenthesis",
            "source_multilines",
            "source_strings",
            "syntax_error",
            "syntax_highlighting",
            "truncating",
            "unprintable_object",
        ],
    )
    def test_diagnose(filename):
>       compare_exception("diagnose", filename)

filename   = 'global_variable'

tests/test_exceptions_formatting.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'diagnose', filename = 'global_variable'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'diagnose'
filename   = 'global_variable'
filepath   = 'tests/exceptions/source/diagnose/global_variable.py'
outpath    = '/testbed/tests/exceptions/output/diagnose/global_variable.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_diagnoseindentation_error">test_exceptions_formatting.py::test_diagnose[indentation_error]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_diagnose[indentation_error]</pre></summary><pre>
filename = 'indentation_error'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_error",
            "assertion_error_custom",
            "assertion_error_in_string",
            "attributes",
            "chained_both",
            "encoding",
            "global_variable",
            "indentation_error",
            "keyword_argument",
            "multilines_repr",
            "no_error_message",
            "parenthesis",
            "source_multilines",
            "source_strings",
            "syntax_error",
            "syntax_highlighting",
            "truncating",
            "unprintable_object",
        ],
    )
    def test_diagnose(filename):
>       compare_exception("diagnose", filename)

filename   = 'indentation_error'

tests/test_exceptions_formatting.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'diagnose', filename = 'indentation_error'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'diagnose'
filename   = 'indentation_error'
filepath   = 'tests/exceptions/source/diagnose/indentation_error.py'
outpath    = '/testbed/tests/exceptions/output/diagnose/indentation_error.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_diagnosekeyword_argument">test_exceptions_formatting.py::test_diagnose[keyword_argument]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_diagnose[keyword_argument]</pre></summary><pre>
filename = 'keyword_argument'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_error",
            "assertion_error_custom",
            "assertion_error_in_string",
            "attributes",
            "chained_both",
            "encoding",
            "global_variable",
            "indentation_error",
            "keyword_argument",
            "multilines_repr",
            "no_error_message",
            "parenthesis",
            "source_multilines",
            "source_strings",
            "syntax_error",
            "syntax_highlighting",
            "truncating",
            "unprintable_object",
        ],
    )
    def test_diagnose(filename):
>       compare_exception("diagnose", filename)

filename   = 'keyword_argument'

tests/test_exceptions_formatting.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'diagnose', filename = 'keyword_argument'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'diagnose'
filename   = 'keyword_argument'
filepath   = 'tests/exceptions/source/diagnose/keyword_argument.py'
outpath    = '/testbed/tests/exceptions/output/diagnose/keyword_argument.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/diagnose/keyword_argument.py", line 15, in <module>\n    with logger.catch():\nAttributeError: __enter__\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_diagnosemultilines_repr">test_exceptions_formatting.py::test_diagnose[multilines_repr]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_diagnose[multilines_repr]</pre></summary><pre>
filename = 'multilines_repr'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_error",
            "assertion_error_custom",
            "assertion_error_in_string",
            "attributes",
            "chained_both",
            "encoding",
            "global_variable",
            "indentation_error",
            "keyword_argument",
            "multilines_repr",
            "no_error_message",
            "parenthesis",
            "source_multilines",
            "source_strings",
            "syntax_error",
            "syntax_highlighting",
            "truncating",
            "unprintable_object",
        ],
    )
    def test_diagnose(filename):
>       compare_exception("diagnose", filename)

filename   = 'multilines_repr'

tests/test_exceptions_formatting.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'diagnose', filename = 'multilines_repr'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'diagnose'
filename   = 'multilines_repr'
filepath   = 'tests/exceptions/source/diagnose/multilines_repr.py'
outpath    = '/testbed/tests/exceptions/output/diagnose/multilines_repr.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_diagnoseno_error_message">test_exceptions_formatting.py::test_diagnose[no_error_message]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_diagnose[no_error_message]</pre></summary><pre>
filename = 'no_error_message'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_error",
            "assertion_error_custom",
            "assertion_error_in_string",
            "attributes",
            "chained_both",
            "encoding",
            "global_variable",
            "indentation_error",
            "keyword_argument",
            "multilines_repr",
            "no_error_message",
            "parenthesis",
            "source_multilines",
            "source_strings",
            "syntax_error",
            "syntax_highlighting",
            "truncating",
            "unprintable_object",
        ],
    )
    def test_diagnose(filename):
>       compare_exception("diagnose", filename)

filename   = 'no_error_message'

tests/test_exceptions_formatting.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'diagnose', filename = 'no_error_message'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'diagnose'
filename   = 'no_error_message'
filepath   = 'tests/exceptions/source/diagnose/no_error_message.py'
outpath    = '/testbed/tests/exceptions/output/diagnose/no_error_message.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_diagnoseparenthesis">test_exceptions_formatting.py::test_diagnose[parenthesis]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_diagnose[parenthesis]</pre></summary><pre>
filename = 'parenthesis'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_error",
            "assertion_error_custom",
            "assertion_error_in_string",
            "attributes",
            "chained_both",
            "encoding",
            "global_variable",
            "indentation_error",
            "keyword_argument",
            "multilines_repr",
            "no_error_message",
            "parenthesis",
            "source_multilines",
            "source_strings",
            "syntax_error",
            "syntax_highlighting",
            "truncating",
            "unprintable_object",
        ],
    )
    def test_diagnose(filename):
>       compare_exception("diagnose", filename)

filename   = 'parenthesis'

tests/test_exceptions_formatting.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'diagnose', filename = 'parenthesis'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'diagnose'
filename   = 'parenthesis'
filepath   = 'tests/exceptions/source/diagnose/parenthesis.py'
outpath    = '/testbed/tests/exceptions/output/diagnose/parenthesis.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/diagnose/parenthesis.py", line 46, in <module>\n    with logger.catch():\nAttributeError: __enter__\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_diagnosesource_multilines">test_exceptions_formatting.py::test_diagnose[source_multilines]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_diagnose[source_multilines]</pre></summary><pre>
filename = 'source_multilines'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_error",
            "assertion_error_custom",
            "assertion_error_in_string",
            "attributes",
            "chained_both",
            "encoding",
            "global_variable",
            "indentation_error",
            "keyword_argument",
            "multilines_repr",
            "no_error_message",
            "parenthesis",
            "source_multilines",
            "source_strings",
            "syntax_error",
            "syntax_highlighting",
            "truncating",
            "unprintable_object",
        ],
    )
    def test_diagnose(filename):
>       compare_exception("diagnose", filename)

filename   = 'source_multilines'

tests/test_exceptions_formatting.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'diagnose', filename = 'source_multilines'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'diagnose'
filename   = 'source_multilines'
filepath   = 'tests/exceptions/source/diagnose/source_multilines.py'
outpath    = '/testbed/tests/exceptions/output/diagnose/source_multilines.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_diagnosesource_strings">test_exceptions_formatting.py::test_diagnose[source_strings]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_diagnose[source_strings]</pre></summary><pre>
filename = 'source_strings'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_error",
            "assertion_error_custom",
            "assertion_error_in_string",
            "attributes",
            "chained_both",
            "encoding",
            "global_variable",
            "indentation_error",
            "keyword_argument",
            "multilines_repr",
            "no_error_message",
            "parenthesis",
            "source_multilines",
            "source_strings",
            "syntax_error",
            "syntax_highlighting",
            "truncating",
            "unprintable_object",
        ],
    )
    def test_diagnose(filename):
>       compare_exception("diagnose", filename)

filename   = 'source_strings'

tests/test_exceptions_formatting.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'diagnose', filename = 'source_strings'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'diagnose'
filename   = 'source_strings'
filepath   = 'tests/exceptions/source/diagnose/source_strings.py'
outpath    = '/testbed/tests/exceptions/output/diagnose/source_strings.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_diagnosesyntax_error">test_exceptions_formatting.py::test_diagnose[syntax_error]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_diagnose[syntax_error]</pre></summary><pre>
filename = 'syntax_error'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_error",
            "assertion_error_custom",
            "assertion_error_in_string",
            "attributes",
            "chained_both",
            "encoding",
            "global_variable",
            "indentation_error",
            "keyword_argument",
            "multilines_repr",
            "no_error_message",
            "parenthesis",
            "source_multilines",
            "source_strings",
            "syntax_error",
            "syntax_highlighting",
            "truncating",
            "unprintable_object",
        ],
    )
    def test_diagnose(filename):
>       compare_exception("diagnose", filename)

filename   = 'syntax_error'

tests/test_exceptions_formatting.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'diagnose', filename = 'syntax_error'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'diagnose'
filename   = 'syntax_error'
filepath   = 'tests/exceptions/source/diagnose/syntax_error.py'
outpath    = '/testbed/tests/exceptions/output/diagnose/syntax_error.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_diagnosesyntax_highlighting">test_exceptions_formatting.py::test_diagnose[syntax_highlighting]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_diagnose[syntax_highlighting]</pre></summary><pre>
filename = 'syntax_highlighting'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_error",
            "assertion_error_custom",
            "assertion_error_in_string",
            "attributes",
            "chained_both",
            "encoding",
            "global_variable",
            "indentation_error",
            "keyword_argument",
            "multilines_repr",
            "no_error_message",
            "parenthesis",
            "source_multilines",
            "source_strings",
            "syntax_error",
            "syntax_highlighting",
            "truncating",
            "unprintable_object",
        ],
    )
    def test_diagnose(filename):
>       compare_exception("diagnose", filename)

filename   = 'syntax_highlighting'

tests/test_exceptions_formatting.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'diagnose', filename = 'syntax_highlighting'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'diagnose'
filename   = 'syntax_highlighting'
filepath   = 'tests/exceptions/source/diagnose/syntax_highlighting.py'
outpath    = '/testbed/tests/exceptions/output/diagnose/syntax_highlighting.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_diagnosetruncating">test_exceptions_formatting.py::test_diagnose[truncating]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_diagnose[truncating]</pre></summary><pre>
filename = 'truncating'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_error",
            "assertion_error_custom",
            "assertion_error_in_string",
            "attributes",
            "chained_both",
            "encoding",
            "global_variable",
            "indentation_error",
            "keyword_argument",
            "multilines_repr",
            "no_error_message",
            "parenthesis",
            "source_multilines",
            "source_strings",
            "syntax_error",
            "syntax_highlighting",
            "truncating",
            "unprintable_object",
        ],
    )
    def test_diagnose(filename):
>       compare_exception("diagnose", filename)

filename   = 'truncating'

tests/test_exceptions_formatting.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'diagnose', filename = 'truncating'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'diagnose'
filename   = 'truncating'
filepath   = 'tests/exceptions/source/diagnose/truncating.py'
outpath    = '/testbed/tests/exceptions/output/diagnose/truncating.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_diagnoseunprintable_object">test_exceptions_formatting.py::test_diagnose[unprintable_object]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_diagnose[unprintable_object]</pre></summary><pre>
filename = 'unprintable_object'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_error",
            "assertion_error_custom",
            "assertion_error_in_string",
            "attributes",
            "chained_both",
            "encoding",
            "global_variable",
            "indentation_error",
            "keyword_argument",
            "multilines_repr",
            "no_error_message",
            "parenthesis",
            "source_multilines",
            "source_strings",
            "syntax_error",
            "syntax_highlighting",
            "truncating",
            "unprintable_object",
        ],
    )
    def test_diagnose(filename):
>       compare_exception("diagnose", filename)

filename   = 'unprintable_object'

tests/test_exceptions_formatting.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'diagnose', filename = 'unprintable_object'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'diagnose'
filename   = 'unprintable_object'
filepath   = 'tests/exceptions/source/diagnose/unprintable_object.py'
outpath    = '/testbed/tests/exceptions/output/diagnose/unprintable_object.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_ownershipassertion_from_lib">test_exceptions_formatting.py::test_exception_ownership[assertion_from_lib]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_ownership[assertion_from_lib]</pre></summary><pre>
filename = 'assertion_from_lib'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_from_lib",
            "assertion_from_local",
            "callback",
            "catch_decorator",
            "catch_decorator_from_lib",
            "decorated_callback",
            "direct",
            "indirect",
            "string_lib",
            "string_source",
            "syntaxerror",
        ],
    )
    def test_exception_ownership(filename):
>       compare_exception("ownership", filename)

filename   = 'assertion_from_lib'

tests/test_exceptions_formatting.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'ownership', filename = 'assertion_from_lib'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'ownership'
filename   = 'assertion_from_lib'
filepath   = 'tests/exceptions/source/ownership/assertion_from_lib.py'
outpath    = '/testbed/tests/exceptions/output/ownership/assertion_from_lib.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_ownershipassertion_from_local">test_exceptions_formatting.py::test_exception_ownership[assertion_from_local]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_ownership[assertion_from_local]</pre></summary><pre>
filename = 'assertion_from_local'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_from_lib",
            "assertion_from_local",
            "callback",
            "catch_decorator",
            "catch_decorator_from_lib",
            "decorated_callback",
            "direct",
            "indirect",
            "string_lib",
            "string_source",
            "syntaxerror",
        ],
    )
    def test_exception_ownership(filename):
>       compare_exception("ownership", filename)

filename   = 'assertion_from_local'

tests/test_exceptions_formatting.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'ownership', filename = 'assertion_from_local'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'ownership'
filename   = 'assertion_from_local'
filepath   = 'tests/exceptions/source/ownership/assertion_from_local.py'
outpath    = '/testbed/tests/exceptions/output/ownership/assertion_from_local.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_ownershipcallback">test_exceptions_formatting.py::test_exception_ownership[callback]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_ownership[callback]</pre></summary><pre>
filename = 'callback'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_from_lib",
            "assertion_from_local",
            "callback",
            "catch_decorator",
            "catch_decorator_from_lib",
            "decorated_callback",
            "direct",
            "indirect",
            "string_lib",
            "string_source",
            "syntaxerror",
        ],
    )
    def test_exception_ownership(filename):
>       compare_exception("ownership", filename)

filename   = 'callback'

tests/test_exceptions_formatting.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'ownership', filename = 'callback'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'ownership'
filename   = 'callback'
filepath   = 'tests/exceptions/source/ownership/callback.py'
outpath    = '/testbed/tests/exceptions/output/ownership/callback.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_ownershipcatch_decorator">test_exceptions_formatting.py::test_exception_ownership[catch_decorator]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_ownership[catch_decorator]</pre></summary><pre>
filename = 'catch_decorator'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_from_lib",
            "assertion_from_local",
            "callback",
            "catch_decorator",
            "catch_decorator_from_lib",
            "decorated_callback",
            "direct",
            "indirect",
            "string_lib",
            "string_source",
            "syntaxerror",
        ],
    )
    def test_exception_ownership(filename):
>       compare_exception("ownership", filename)

filename   = 'catch_decorator'

tests/test_exceptions_formatting.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'ownership', filename = 'catch_decorator'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'ownership'
filename   = 'catch_decorator'
filepath   = 'tests/exceptions/source/ownership/catch_decorator.py'
outpath    = '/testbed/tests/exceptions/output/ownership/catch_decorator.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/ownership/catch_decorator.py", line 20, ...ns/source/ownership/catch_decorator.py", line 17, in test\n    foo()\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_ownershipcatch_decorator_from_lib">test_exceptions_formatting.py::test_exception_ownership[catch_decorator_from_lib]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_ownership[catch_decorator_from_lib]</pre></summary><pre>
filename = 'catch_decorator_from_lib'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_from_lib",
            "assertion_from_local",
            "callback",
            "catch_decorator",
            "catch_decorator_from_lib",
            "decorated_callback",
            "direct",
            "indirect",
            "string_lib",
            "string_source",
            "syntaxerror",
        ],
    )
    def test_exception_ownership(filename):
>       compare_exception("ownership", filename)

filename   = 'catch_decorator_from_lib'

tests/test_exceptions_formatting.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'ownership', filename = 'catch_decorator_from_lib'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'ownership'
filename   = 'catch_decorator_from_lib'
filepath   = 'tests/exceptions/source/ownership/catch_decorator_from_lib.py'
outpath    = '/testbed/tests/exceptions/output/ownership/catch_decorator_from_lib.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/ownership/catch_decorator_from_lib.py", ...ip/usersite/somelib/__init__.py", line 10, in callme\n    callback()\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_ownershipdecorated_callback">test_exceptions_formatting.py::test_exception_ownership[decorated_callback]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_ownership[decorated_callback]</pre></summary><pre>
filename = 'decorated_callback'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_from_lib",
            "assertion_from_local",
            "callback",
            "catch_decorator",
            "catch_decorator_from_lib",
            "decorated_callback",
            "direct",
            "indirect",
            "string_lib",
            "string_source",
            "syntaxerror",
        ],
    )
    def test_exception_ownership(filename):
>       compare_exception("ownership", filename)

filename   = 'decorated_callback'

tests/test_exceptions_formatting.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'ownership', filename = 'decorated_callback'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'ownership'
filename   = 'decorated_callback'
filepath   = 'tests/exceptions/source/ownership/decorated_callback.py'
outpath    = '/testbed/tests/exceptions/output/ownership/decorated_callback.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/ownership/decorated_callback.py", line 2...ip/usersite/somelib/__init__.py", line 10, in callme\n    callback()\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_ownershipdirect">test_exceptions_formatting.py::test_exception_ownership[direct]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_ownership[direct]</pre></summary><pre>
filename = 'direct'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_from_lib",
            "assertion_from_local",
            "callback",
            "catch_decorator",
            "catch_decorator_from_lib",
            "decorated_callback",
            "direct",
            "indirect",
            "string_lib",
            "string_source",
            "syntaxerror",
        ],
    )
    def test_exception_ownership(filename):
>       compare_exception("ownership", filename)

filename   = 'direct'

tests/test_exceptions_formatting.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'ownership', filename = 'direct'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'ownership'
filename   = 'direct'
filepath   = 'tests/exceptions/source/ownership/direct.py'
outpath    = '/testbed/tests/exceptions/output/ownership/direct.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_ownershipindirect">test_exceptions_formatting.py::test_exception_ownership[indirect]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_ownership[indirect]</pre></summary><pre>
filename = 'indirect'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_from_lib",
            "assertion_from_local",
            "callback",
            "catch_decorator",
            "catch_decorator_from_lib",
            "decorated_callback",
            "direct",
            "indirect",
            "string_lib",
            "string_source",
            "syntaxerror",
        ],
    )
    def test_exception_ownership(filename):
>       compare_exception("ownership", filename)

filename   = 'indirect'

tests/test_exceptions_formatting.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'ownership', filename = 'indirect'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'ownership'
filename   = 'indirect'
filepath   = 'tests/exceptions/source/ownership/indirect.py'
outpath    = '/testbed/tests/exceptions/output/ownership/indirect.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_ownershipstring_lib">test_exceptions_formatting.py::test_exception_ownership[string_lib]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_ownership[string_lib]</pre></summary><pre>
filename = 'string_lib'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_from_lib",
            "assertion_from_local",
            "callback",
            "catch_decorator",
            "catch_decorator_from_lib",
            "decorated_callback",
            "direct",
            "indirect",
            "string_lib",
            "string_source",
            "syntaxerror",
        ],
    )
    def test_exception_ownership(filename):
>       compare_exception("ownership", filename)

filename   = 'string_lib'

tests/test_exceptions_formatting.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'ownership', filename = 'string_lib'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'ownership'
filename   = 'string_lib'
filepath   = 'tests/exceptions/source/ownership/string_lib.py'
outpath    = '/testbed/tests/exceptions/output/ownership/string_lib.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_ownershipstring_source">test_exceptions_formatting.py::test_exception_ownership[string_source]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_ownership[string_source]</pre></summary><pre>
filename = 'string_source'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_from_lib",
            "assertion_from_local",
            "callback",
            "catch_decorator",
            "catch_decorator_from_lib",
            "decorated_callback",
            "direct",
            "indirect",
            "string_lib",
            "string_source",
            "syntaxerror",
        ],
    )
    def test_exception_ownership(filename):
>       compare_exception("ownership", filename)

filename   = 'string_source'

tests/test_exceptions_formatting.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'ownership', filename = 'string_source'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'ownership'
filename   = 'string_source'
filepath   = 'tests/exceptions/source/ownership/string_source.py'
outpath    = '/testbed/tests/exceptions/output/ownership/string_source.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_ownershipsyntaxerror">test_exceptions_formatting.py::test_exception_ownership[syntaxerror]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_ownership[syntaxerror]</pre></summary><pre>
filename = 'syntaxerror'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertion_from_lib",
            "assertion_from_local",
            "callback",
            "catch_decorator",
            "catch_decorator_from_lib",
            "decorated_callback",
            "direct",
            "indirect",
            "string_lib",
            "string_source",
            "syntaxerror",
        ],
    )
    def test_exception_ownership(filename):
>       compare_exception("ownership", filename)

filename   = 'syntaxerror'

tests/test_exceptions_formatting.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'ownership', filename = 'syntaxerror'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'ownership'
filename   = 'syntaxerror'
filepath   = 'tests/exceptions/source/ownership/syntaxerror.py'
outpath    = '/testbed/tests/exceptions/output/ownership/syntaxerror.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_othersassertionerror_without_traceback">test_exceptions_formatting.py::test_exception_others[assertionerror_without_traceback]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_others[assertionerror_without_traceback]</pre></summary><pre>
filename = 'assertionerror_without_traceback'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertionerror_without_traceback",
            "catch_as_context_manager",
            "catch_as_decorator_with_parentheses",
            "catch_as_decorator_without_parentheses",
            "catch_as_function",
            "catch_message",
            "exception_formatting_coroutine",
            "exception_formatting_function",
            "exception_formatting_generator",
            "exception_in_property",
            "handler_formatting_with_context_manager",
            "handler_formatting_with_decorator",
            "level_name",
            "level_number",
            "message_formatting_with_context_manager",
            "message_formatting_with_decorator",
            "nested_with_reraise",
            "syntaxerror_without_traceback",
            "sys_tracebacklimit",
            "sys_tracebacklimit_negative",
            "sys_tracebacklimit_none",
            "sys_tracebacklimit_unset",
            "zerodivisionerror_without_traceback",
        ],
    )
    def test_exception_others(filename):
>       compare_exception("others", filename)

filename   = 'assertionerror_without_traceback'

tests/test_exceptions_formatting.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'others', filename = 'assertionerror_without_traceback'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'others'
filename   = 'assertionerror_without_traceback'
filepath   = 'tests/exceptions/source/others/assertionerror_without_traceback.py'
outpath    = '/testbed/tests/exceptions/output/others/assertionerror_without_traceback.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/others/assertionerror_without_traceback....logger.opt(exception=(type_, value, None)).error("")\nAttributeError: \'NoneType\' object has no attribute \'error\'\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_otherscatch_as_context_manager">test_exceptions_formatting.py::test_exception_others[catch_as_context_manager]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_others[catch_as_context_manager]</pre></summary><pre>
filename = 'catch_as_context_manager'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertionerror_without_traceback",
            "catch_as_context_manager",
            "catch_as_decorator_with_parentheses",
            "catch_as_decorator_without_parentheses",
            "catch_as_function",
            "catch_message",
            "exception_formatting_coroutine",
            "exception_formatting_function",
            "exception_formatting_generator",
            "exception_in_property",
            "handler_formatting_with_context_manager",
            "handler_formatting_with_decorator",
            "level_name",
            "level_number",
            "message_formatting_with_context_manager",
            "message_formatting_with_decorator",
            "nested_with_reraise",
            "syntaxerror_without_traceback",
            "sys_tracebacklimit",
            "sys_tracebacklimit_negative",
            "sys_tracebacklimit_none",
            "sys_tracebacklimit_unset",
            "zerodivisionerror_without_traceback",
        ],
    )
    def test_exception_others(filename):
>       compare_exception("others", filename)

filename   = 'catch_as_context_manager'

tests/test_exceptions_formatting.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'others', filename = 'catch_as_context_manager'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'others'
filename   = 'catch_as_context_manager'
filepath   = 'tests/exceptions/source/others/catch_as_context_manager.py'
outpath    = '/testbed/tests/exceptions/output/others/catch_as_context_manager.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/others/catch_as_context_manager.py", line 9, in <module>\n    with logger.catch():\nAttributeError: __enter__\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_otherscatch_as_decorator_with_parentheses">test_exceptions_formatting.py::test_exception_others[catch_as_decorator_with_parentheses]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_others[catch_as_decorator_with_parentheses]</pre></summary><pre>
filename = 'catch_as_decorator_with_parentheses'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertionerror_without_traceback",
            "catch_as_context_manager",
            "catch_as_decorator_with_parentheses",
            "catch_as_decorator_without_parentheses",
            "catch_as_function",
            "catch_message",
            "exception_formatting_coroutine",
            "exception_formatting_function",
            "exception_formatting_generator",
            "exception_in_property",
            "handler_formatting_with_context_manager",
            "handler_formatting_with_decorator",
            "level_name",
            "level_number",
            "message_formatting_with_context_manager",
            "message_formatting_with_decorator",
            "nested_with_reraise",
            "syntaxerror_without_traceback",
            "sys_tracebacklimit",
            "sys_tracebacklimit_negative",
            "sys_tracebacklimit_none",
            "sys_tracebacklimit_unset",
            "zerodivisionerror_without_traceback",
        ],
    )
    def test_exception_others(filename):
>       compare_exception("others", filename)

filename   = 'catch_as_decorator_with_parentheses'

tests/test_exceptions_formatting.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'others', filename = 'catch_as_decorator_with_parentheses'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'others'
filename   = 'catch_as_decorator_with_parentheses'
filepath   = 'tests/exceptions/source/others/catch_as_decorator_with_parentheses.py'
outpath    = '/testbed/tests/exceptions/output/others/catch_as_decorator_with_parentheses.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/others/catch_as_decorator_with_parentheses.py", line 10, in <module>\n    def c(a, b):\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_otherscatch_as_decorator_without_parentheses">test_exceptions_formatting.py::test_exception_others[catch_as_decorator_without_parentheses]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_others[catch_as_decorator_without_parentheses]</pre></summary><pre>
filename = 'catch_as_decorator_without_parentheses'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertionerror_without_traceback",
            "catch_as_context_manager",
            "catch_as_decorator_with_parentheses",
            "catch_as_decorator_without_parentheses",
            "catch_as_function",
            "catch_message",
            "exception_formatting_coroutine",
            "exception_formatting_function",
            "exception_formatting_generator",
            "exception_in_property",
            "handler_formatting_with_context_manager",
            "handler_formatting_with_decorator",
            "level_name",
            "level_number",
            "message_formatting_with_context_manager",
            "message_formatting_with_decorator",
            "nested_with_reraise",
            "syntaxerror_without_traceback",
            "sys_tracebacklimit",
            "sys_tracebacklimit_negative",
            "sys_tracebacklimit_none",
            "sys_tracebacklimit_unset",
            "zerodivisionerror_without_traceback",
        ],
    )
    def test_exception_others(filename):
>       compare_exception("others", filename)

filename   = 'catch_as_decorator_without_parentheses'

tests/test_exceptions_formatting.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'others', filename = 'catch_as_decorator_without_parentheses'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'others'
filename   = 'catch_as_decorator_without_parentheses'
filepath   = 'tests/exceptions/source/others/catch_as_decorator_without_parentheses.py'
outpath    = '/testbed/tests/exceptions/output/others/catch_as_decorator_without_parentheses.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/others/catch_as_decorator_without_parentheses.py", line 14, in <module>\n    c(2)\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_otherscatch_as_function">test_exceptions_formatting.py::test_exception_others[catch_as_function]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_others[catch_as_function]</pre></summary><pre>
filename = 'catch_as_function'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertionerror_without_traceback",
            "catch_as_context_manager",
            "catch_as_decorator_with_parentheses",
            "catch_as_decorator_without_parentheses",
            "catch_as_function",
            "catch_message",
            "exception_formatting_coroutine",
            "exception_formatting_function",
            "exception_formatting_generator",
            "exception_in_property",
            "handler_formatting_with_context_manager",
            "handler_formatting_with_decorator",
            "level_name",
            "level_number",
            "message_formatting_with_context_manager",
            "message_formatting_with_decorator",
            "nested_with_reraise",
            "syntaxerror_without_traceback",
            "sys_tracebacklimit",
            "sys_tracebacklimit_negative",
            "sys_tracebacklimit_none",
            "sys_tracebacklimit_unset",
            "zerodivisionerror_without_traceback",
        ],
    )
    def test_exception_others(filename):
>       compare_exception("others", filename)

filename   = 'catch_as_function'

tests/test_exceptions_formatting.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'others', filename = 'catch_as_function'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'others'
filename   = 'catch_as_function'
filepath   = 'tests/exceptions/source/others/catch_as_function.py'
outpath    = '/testbed/tests/exceptions/output/others/catch_as_function.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/others/catch_as_function.py", line 13, in <module>\n    a = logger.catch()(a)\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_otherscatch_message">test_exceptions_formatting.py::test_exception_others[catch_message]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_others[catch_message]</pre></summary><pre>
filename = 'catch_message'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertionerror_without_traceback",
            "catch_as_context_manager",
            "catch_as_decorator_with_parentheses",
            "catch_as_decorator_without_parentheses",
            "catch_as_function",
            "catch_message",
            "exception_formatting_coroutine",
            "exception_formatting_function",
            "exception_formatting_generator",
            "exception_in_property",
            "handler_formatting_with_context_manager",
            "handler_formatting_with_decorator",
            "level_name",
            "level_number",
            "message_formatting_with_context_manager",
            "message_formatting_with_decorator",
            "nested_with_reraise",
            "syntaxerror_without_traceback",
            "sys_tracebacklimit",
            "sys_tracebacklimit_negative",
            "sys_tracebacklimit_none",
            "sys_tracebacklimit_unset",
            "zerodivisionerror_without_traceback",
        ],
    )
    def test_exception_others(filename):
>       compare_exception("others", filename)

filename   = 'catch_message'

tests/test_exceptions_formatting.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'others', filename = 'catch_message'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'others'
filename   = 'catch_message'
filepath   = 'tests/exceptions/source/others/catch_message.py'
outpath    = '/testbed/tests/exceptions/output/others/catch_message.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/others/catch_message.py", line 13, in <module>\n    with logger.catch(message="An error occurred (1):"):\nAttributeError: __enter__\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_othersexception_formatting_coroutine">test_exceptions_formatting.py::test_exception_others[exception_formatting_coroutine]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_others[exception_formatting_coroutine]</pre></summary><pre>
filename = 'exception_formatting_coroutine'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertionerror_without_traceback",
            "catch_as_context_manager",
            "catch_as_decorator_with_parentheses",
            "catch_as_decorator_without_parentheses",
            "catch_as_function",
            "catch_message",
            "exception_formatting_coroutine",
            "exception_formatting_function",
            "exception_formatting_generator",
            "exception_in_property",
            "handler_formatting_with_context_manager",
            "handler_formatting_with_decorator",
            "level_name",
            "level_number",
            "message_formatting_with_context_manager",
            "message_formatting_with_decorator",
            "nested_with_reraise",
            "syntaxerror_without_traceback",
            "sys_tracebacklimit",
            "sys_tracebacklimit_negative",
            "sys_tracebacklimit_none",
            "sys_tracebacklimit_unset",
            "zerodivisionerror_without_traceback",
        ],
    )
    def test_exception_others(filename):
>       compare_exception("others", filename)

filename   = 'exception_formatting_coroutine'

tests/test_exceptions_formatting.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'others', filename = 'exception_formatting_coroutine'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'others'
filename   = 'exception_formatting_coroutine'
filepath   = 'tests/exceptions/source/others/exception_formatting_coroutine.py'
outpath    = '/testbed/tests/exceptions/output/others/exception_formatting_coroutine.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/others/exception_formatting_coroutine.py", line 17, in <module>\n    f = foo(1, 0)\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_othersexception_formatting_function">test_exceptions_formatting.py::test_exception_others[exception_formatting_function]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_others[exception_formatting_function]</pre></summary><pre>
filename = 'exception_formatting_function'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertionerror_without_traceback",
            "catch_as_context_manager",
            "catch_as_decorator_with_parentheses",
            "catch_as_decorator_without_parentheses",
            "catch_as_function",
            "catch_message",
            "exception_formatting_coroutine",
            "exception_formatting_function",
            "exception_formatting_generator",
            "exception_in_property",
            "handler_formatting_with_context_manager",
            "handler_formatting_with_decorator",
            "level_name",
            "level_number",
            "message_formatting_with_context_manager",
            "message_formatting_with_decorator",
            "nested_with_reraise",
            "syntaxerror_without_traceback",
            "sys_tracebacklimit",
            "sys_tracebacklimit_negative",
            "sys_tracebacklimit_none",
            "sys_tracebacklimit_unset",
            "zerodivisionerror_without_traceback",
        ],
    )
    def test_exception_others(filename):
>       compare_exception("others", filename)

filename   = 'exception_formatting_function'

tests/test_exceptions_formatting.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'others', filename = 'exception_formatting_function'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'others'
filename   = 'exception_formatting_function'
filepath   = 'tests/exceptions/source/others/exception_formatting_function.py'
outpath    = '/testbed/tests/exceptions/output/others/exception_formatting_function.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/others/exception_formatting_function.py", line 17, in <module>\n    a(1, 0)\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_othersexception_formatting_generator">test_exceptions_formatting.py::test_exception_others[exception_formatting_generator]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_others[exception_formatting_generator]</pre></summary><pre>
filename = 'exception_formatting_generator'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertionerror_without_traceback",
            "catch_as_context_manager",
            "catch_as_decorator_with_parentheses",
            "catch_as_decorator_without_parentheses",
            "catch_as_function",
            "catch_message",
            "exception_formatting_coroutine",
            "exception_formatting_function",
            "exception_formatting_generator",
            "exception_in_property",
            "handler_formatting_with_context_manager",
            "handler_formatting_with_decorator",
            "level_name",
            "level_number",
            "message_formatting_with_context_manager",
            "message_formatting_with_decorator",
            "nested_with_reraise",
            "syntaxerror_without_traceback",
            "sys_tracebacklimit",
            "sys_tracebacklimit_negative",
            "sys_tracebacklimit_none",
            "sys_tracebacklimit_unset",
            "zerodivisionerror_without_traceback",
        ],
    )
    def test_exception_others(filename):
>       compare_exception("others", filename)

filename   = 'exception_formatting_generator'

tests/test_exceptions_formatting.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'others', filename = 'exception_formatting_generator'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'others'
filename   = 'exception_formatting_generator'
filepath   = 'tests/exceptions/source/others/exception_formatting_generator.py'
outpath    = '/testbed/tests/exceptions/output/others/exception_formatting_generator.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/others/exception_formatting_generator.py", line 17, in <module>\n    f = foo(1, 0)\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_othersexception_in_property">test_exceptions_formatting.py::test_exception_others[exception_in_property]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_others[exception_in_property]</pre></summary><pre>
filename = 'exception_in_property'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertionerror_without_traceback",
            "catch_as_context_manager",
            "catch_as_decorator_with_parentheses",
            "catch_as_decorator_without_parentheses",
            "catch_as_function",
            "catch_message",
            "exception_formatting_coroutine",
            "exception_formatting_function",
            "exception_formatting_generator",
            "exception_in_property",
            "handler_formatting_with_context_manager",
            "handler_formatting_with_decorator",
            "level_name",
            "level_number",
            "message_formatting_with_context_manager",
            "message_formatting_with_decorator",
            "nested_with_reraise",
            "syntaxerror_without_traceback",
            "sys_tracebacklimit",
            "sys_tracebacklimit_negative",
            "sys_tracebacklimit_none",
            "sys_tracebacklimit_unset",
            "zerodivisionerror_without_traceback",
        ],
    )
    def test_exception_others(filename):
>       compare_exception("others", filename)

filename   = 'exception_in_property'

tests/test_exceptions_formatting.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'others', filename = 'exception_in_property'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'others'
filename   = 'exception_in_property'
filepath   = 'tests/exceptions/source/others/exception_in_property.py'
outpath    = '/testbed/tests/exceptions/output/others/exception_in_property.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/others/exception_in_property.py", line 1... value\n    logger.opt(exception=True).debug("test")\nAttributeError: \'NoneType\' object has no attribute \'debug\'\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_othershandler_formatting_with_context_manager">test_exceptions_formatting.py::test_exception_others[handler_formatting_with_context_manager]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_others[handler_formatting_with_context_manager]</pre></summary><pre>
filename = 'handler_formatting_with_context_manager'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertionerror_without_traceback",
            "catch_as_context_manager",
            "catch_as_decorator_with_parentheses",
            "catch_as_decorator_without_parentheses",
            "catch_as_function",
            "catch_message",
            "exception_formatting_coroutine",
            "exception_formatting_function",
            "exception_formatting_generator",
            "exception_in_property",
            "handler_formatting_with_context_manager",
            "handler_formatting_with_decorator",
            "level_name",
            "level_number",
            "message_formatting_with_context_manager",
            "message_formatting_with_decorator",
            "nested_with_reraise",
            "syntaxerror_without_traceback",
            "sys_tracebacklimit",
            "sys_tracebacklimit_negative",
            "sys_tracebacklimit_none",
            "sys_tracebacklimit_unset",
            "zerodivisionerror_without_traceback",
        ],
    )
    def test_exception_others(filename):
>       compare_exception("others", filename)

filename   = 'handler_formatting_with_context_manager'

tests/test_exceptions_formatting.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'others', filename = 'handler_formatting_with_context_manager'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'others'
filename   = 'handler_formatting_with_context_manager'
filepath   = 'tests/exceptions/source/others/handler_formatting_with_context_manager.py'
outpath    = '/testbed/tests/exceptions/output/others/handler_formatting_with_context_manager.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/others/handler_formatting_with_context_m...hers/handler_formatting_with_context_manager.py", line 16, in a\n    with logger.catch():\nAttributeError: __enter__\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_othershandler_formatting_with_decorator">test_exceptions_formatting.py::test_exception_others[handler_formatting_with_decorator]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_others[handler_formatting_with_decorator]</pre></summary><pre>
filename = 'handler_formatting_with_decorator'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertionerror_without_traceback",
            "catch_as_context_manager",
            "catch_as_decorator_with_parentheses",
            "catch_as_decorator_without_parentheses",
            "catch_as_function",
            "catch_message",
            "exception_formatting_coroutine",
            "exception_formatting_function",
            "exception_formatting_generator",
            "exception_in_property",
            "handler_formatting_with_context_manager",
            "handler_formatting_with_decorator",
            "level_name",
            "level_number",
            "message_formatting_with_context_manager",
            "message_formatting_with_decorator",
            "nested_with_reraise",
            "syntaxerror_without_traceback",
            "sys_tracebacklimit",
            "sys_tracebacklimit_negative",
            "sys_tracebacklimit_none",
            "sys_tracebacklimit_unset",
            "zerodivisionerror_without_traceback",
        ],
    )
    def test_exception_others(filename):
>       compare_exception("others", filename)

filename   = 'handler_formatting_with_decorator'

tests/test_exceptions_formatting.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'others', filename = 'handler_formatting_with_decorator'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'others'
filename   = 'handler_formatting_with_decorator'
filepath   = 'tests/exceptions/source/others/handler_formatting_with_decorator.py'
outpath    = '/testbed/tests/exceptions/output/others/handler_formatting_with_decorator.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/others/handler_formatting_with_decorator.py", line 20, in <module>\n    a()\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_otherslevel_name">test_exceptions_formatting.py::test_exception_others[level_name]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_others[level_name]</pre></summary><pre>
filename = 'level_name'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertionerror_without_traceback",
            "catch_as_context_manager",
            "catch_as_decorator_with_parentheses",
            "catch_as_decorator_without_parentheses",
            "catch_as_function",
            "catch_message",
            "exception_formatting_coroutine",
            "exception_formatting_function",
            "exception_formatting_generator",
            "exception_in_property",
            "handler_formatting_with_context_manager",
            "handler_formatting_with_decorator",
            "level_name",
            "level_number",
            "message_formatting_with_context_manager",
            "message_formatting_with_decorator",
            "nested_with_reraise",
            "syntaxerror_without_traceback",
            "sys_tracebacklimit",
            "sys_tracebacklimit_negative",
            "sys_tracebacklimit_none",
            "sys_tracebacklimit_unset",
            "zerodivisionerror_without_traceback",
        ],
    )
    def test_exception_others(filename):
>       compare_exception("others", filename)

filename   = 'level_name'

tests/test_exceptions_formatting.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'others', filename = 'level_name'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'others'
filename   = 'level_name'
filepath   = 'tests/exceptions/source/others/level_name.py'
outpath    = '/testbed/tests/exceptions/output/others/level_name.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/others/level_name.py", line 16, in <modu...ptions/source/others/level_name.py", line 12, in a\n    with logger.catch(level="DEBUG"):\nAttributeError: __enter__\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_otherslevel_number">test_exceptions_formatting.py::test_exception_others[level_number]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_others[level_number]</pre></summary><pre>
filename = 'level_number'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertionerror_without_traceback",
            "catch_as_context_manager",
            "catch_as_decorator_with_parentheses",
            "catch_as_decorator_without_parentheses",
            "catch_as_function",
            "catch_message",
            "exception_formatting_coroutine",
            "exception_formatting_function",
            "exception_formatting_generator",
            "exception_in_property",
            "handler_formatting_with_context_manager",
            "handler_formatting_with_decorator",
            "level_name",
            "level_number",
            "message_formatting_with_context_manager",
            "message_formatting_with_decorator",
            "nested_with_reraise",
            "syntaxerror_without_traceback",
            "sys_tracebacklimit",
            "sys_tracebacklimit_negative",
            "sys_tracebacklimit_none",
            "sys_tracebacklimit_unset",
            "zerodivisionerror_without_traceback",
        ],
    )
    def test_exception_others(filename):
>       compare_exception("others", filename)

filename   = 'level_number'

tests/test_exceptions_formatting.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'others', filename = 'level_number'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'others'
filename   = 'level_number'
filepath   = 'tests/exceptions/source/others/level_number.py'
outpath    = '/testbed/tests/exceptions/output/others/level_number.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/others/level_number.py", line 16, in <mo...xceptions/source/others/level_number.py", line 12, in a\n    with logger.catch(level=13):\nAttributeError: __enter__\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_othersmessage_formatting_with_context_manager">test_exceptions_formatting.py::test_exception_others[message_formatting_with_context_manager]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_others[message_formatting_with_context_manager]</pre></summary><pre>
filename = 'message_formatting_with_context_manager'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertionerror_without_traceback",
            "catch_as_context_manager",
            "catch_as_decorator_with_parentheses",
            "catch_as_decorator_without_parentheses",
            "catch_as_function",
            "catch_message",
            "exception_formatting_coroutine",
            "exception_formatting_function",
            "exception_formatting_generator",
            "exception_in_property",
            "handler_formatting_with_context_manager",
            "handler_formatting_with_decorator",
            "level_name",
            "level_number",
            "message_formatting_with_context_manager",
            "message_formatting_with_decorator",
            "nested_with_reraise",
            "syntaxerror_without_traceback",
            "sys_tracebacklimit",
            "sys_tracebacklimit_negative",
            "sys_tracebacklimit_none",
            "sys_tracebacklimit_unset",
            "zerodivisionerror_without_traceback",
        ],
    )
    def test_exception_others(filename):
>       compare_exception("others", filename)

filename   = 'message_formatting_with_context_manager'

tests/test_exceptions_formatting.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'others', filename = 'message_formatting_with_context_manager'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'others'
filename   = 'message_formatting_with_context_manager'
filepath   = 'tests/exceptions/source/others/message_formatting_with_context_manager.py'
outpath    = '/testbed/tests/exceptions/output/others/message_formatting_with_context_manager.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/others/message_formatting_with_context_m...others/message_formatting_with_context_manager.py", line 10, in a\n    with logger.catch(\nAttributeError: __enter__\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_othersmessage_formatting_with_decorator">test_exceptions_formatting.py::test_exception_others[message_formatting_with_decorator]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_others[message_formatting_with_decorator]</pre></summary><pre>
filename = 'message_formatting_with_decorator'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertionerror_without_traceback",
            "catch_as_context_manager",
            "catch_as_decorator_with_parentheses",
            "catch_as_decorator_without_parentheses",
            "catch_as_function",
            "catch_message",
            "exception_formatting_coroutine",
            "exception_formatting_function",
            "exception_formatting_generator",
            "exception_in_property",
            "handler_formatting_with_context_manager",
            "handler_formatting_with_decorator",
            "level_name",
            "level_number",
            "message_formatting_with_context_manager",
            "message_formatting_with_decorator",
            "nested_with_reraise",
            "syntaxerror_without_traceback",
            "sys_tracebacklimit",
            "sys_tracebacklimit_negative",
            "sys_tracebacklimit_none",
            "sys_tracebacklimit_unset",
            "zerodivisionerror_without_traceback",
        ],
    )
    def test_exception_others(filename):
>       compare_exception("others", filename)

filename   = 'message_formatting_with_decorator'

tests/test_exceptions_formatting.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'others', filename = 'message_formatting_with_decorator'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'others'
filename   = 'message_formatting_with_decorator'
filepath   = 'tests/exceptions/source/others/message_formatting_with_decorator.py'
outpath    = '/testbed/tests/exceptions/output/others/message_formatting_with_decorator.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/others/message_formatting_with_decorator.py", line 10, in <module>\n    def a():\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_othersnested_with_reraise">test_exceptions_formatting.py::test_exception_others[nested_with_reraise]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_others[nested_with_reraise]</pre></summary><pre>
filename = 'nested_with_reraise'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertionerror_without_traceback",
            "catch_as_context_manager",
            "catch_as_decorator_with_parentheses",
            "catch_as_decorator_without_parentheses",
            "catch_as_function",
            "catch_message",
            "exception_formatting_coroutine",
            "exception_formatting_function",
            "exception_formatting_generator",
            "exception_in_property",
            "handler_formatting_with_context_manager",
            "handler_formatting_with_decorator",
            "level_name",
            "level_number",
            "message_formatting_with_context_manager",
            "message_formatting_with_decorator",
            "nested_with_reraise",
            "syntaxerror_without_traceback",
            "sys_tracebacklimit",
            "sys_tracebacklimit_negative",
            "sys_tracebacklimit_none",
            "sys_tracebacklimit_unset",
            "zerodivisionerror_without_traceback",
        ],
    )
    def test_exception_others(filename):
>       compare_exception("others", filename)

filename   = 'nested_with_reraise'

tests/test_exceptions_formatting.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'others', filename = 'nested_with_reraise'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'others'
filename   = 'nested_with_reraise'
filepath   = 'tests/exceptions/source/others/nested_with_reraise.py'
outpath    = '/testbed/tests/exceptions/output/others/nested_with_reraise.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/others/nested_with_reraise.py", line 13, in <module>\n    def foo(a, b):\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_otherssyntaxerror_without_traceback">test_exceptions_formatting.py::test_exception_others[syntaxerror_without_traceback]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_others[syntaxerror_without_traceback]</pre></summary><pre>
filename = 'syntaxerror_without_traceback'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertionerror_without_traceback",
            "catch_as_context_manager",
            "catch_as_decorator_with_parentheses",
            "catch_as_decorator_without_parentheses",
            "catch_as_function",
            "catch_message",
            "exception_formatting_coroutine",
            "exception_formatting_function",
            "exception_formatting_generator",
            "exception_in_property",
            "handler_formatting_with_context_manager",
            "handler_formatting_with_decorator",
            "level_name",
            "level_number",
            "message_formatting_with_context_manager",
            "message_formatting_with_decorator",
            "nested_with_reraise",
            "syntaxerror_without_traceback",
            "sys_tracebacklimit",
            "sys_tracebacklimit_negative",
            "sys_tracebacklimit_none",
            "sys_tracebacklimit_unset",
            "zerodivisionerror_without_traceback",
        ],
    )
    def test_exception_others(filename):
>       compare_exception("others", filename)

filename   = 'syntaxerror_without_traceback'

tests/test_exceptions_formatting.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'others', filename = 'syntaxerror_without_traceback'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'others'
filename   = 'syntaxerror_without_traceback'
filepath   = 'tests/exceptions/source/others/syntaxerror_without_traceback.py'
outpath    = '/testbed/tests/exceptions/output/others/syntaxerror_without_traceback.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/others/syntaxerror_without_traceback.py"...logger.opt(exception=(type_, value, None)).error("")\nAttributeError: \'NoneType\' object has no attribute \'error\'\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_otherssys_tracebacklimit">test_exceptions_formatting.py::test_exception_others[sys_tracebacklimit]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_others[sys_tracebacklimit]</pre></summary><pre>
filename = 'sys_tracebacklimit'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertionerror_without_traceback",
            "catch_as_context_manager",
            "catch_as_decorator_with_parentheses",
            "catch_as_decorator_without_parentheses",
            "catch_as_function",
            "catch_message",
            "exception_formatting_coroutine",
            "exception_formatting_function",
            "exception_formatting_generator",
            "exception_in_property",
            "handler_formatting_with_context_manager",
            "handler_formatting_with_decorator",
            "level_name",
            "level_number",
            "message_formatting_with_context_manager",
            "message_formatting_with_decorator",
            "nested_with_reraise",
            "syntaxerror_without_traceback",
            "sys_tracebacklimit",
            "sys_tracebacklimit_negative",
            "sys_tracebacklimit_none",
            "sys_tracebacklimit_unset",
            "zerodivisionerror_without_traceback",
        ],
    )
    def test_exception_others(filename):
>       compare_exception("others", filename)

filename   = 'sys_tracebacklimit'

tests/test_exceptions_formatting.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'others', filename = 'sys_tracebacklimit'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'others'
filename   = 'sys_tracebacklimit'
filepath   = 'tests/exceptions/source/others/sys_tracebacklimit.py'
outpath    = '/testbed/tests/exceptions/output/others/sys_tracebacklimit.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_otherssys_tracebacklimit_negative">test_exceptions_formatting.py::test_exception_others[sys_tracebacklimit_negative]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_others[sys_tracebacklimit_negative]</pre></summary><pre>
filename = 'sys_tracebacklimit_negative'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertionerror_without_traceback",
            "catch_as_context_manager",
            "catch_as_decorator_with_parentheses",
            "catch_as_decorator_without_parentheses",
            "catch_as_function",
            "catch_message",
            "exception_formatting_coroutine",
            "exception_formatting_function",
            "exception_formatting_generator",
            "exception_in_property",
            "handler_formatting_with_context_manager",
            "handler_formatting_with_decorator",
            "level_name",
            "level_number",
            "message_formatting_with_context_manager",
            "message_formatting_with_decorator",
            "nested_with_reraise",
            "syntaxerror_without_traceback",
            "sys_tracebacklimit",
            "sys_tracebacklimit_negative",
            "sys_tracebacklimit_none",
            "sys_tracebacklimit_unset",
            "zerodivisionerror_without_traceback",
        ],
    )
    def test_exception_others(filename):
>       compare_exception("others", filename)

filename   = 'sys_tracebacklimit_negative'

tests/test_exceptions_formatting.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'others', filename = 'sys_tracebacklimit_negative'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'others'
filename   = 'sys_tracebacklimit_negative'
filepath   = 'tests/exceptions/source/others/sys_tracebacklimit_negative.py'
outpath    = '/testbed/tests/exceptions/output/others/sys_tracebacklimit_negative.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_otherssys_tracebacklimit_none">test_exceptions_formatting.py::test_exception_others[sys_tracebacklimit_none]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_others[sys_tracebacklimit_none]</pre></summary><pre>
filename = 'sys_tracebacklimit_none'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertionerror_without_traceback",
            "catch_as_context_manager",
            "catch_as_decorator_with_parentheses",
            "catch_as_decorator_without_parentheses",
            "catch_as_function",
            "catch_message",
            "exception_formatting_coroutine",
            "exception_formatting_function",
            "exception_formatting_generator",
            "exception_in_property",
            "handler_formatting_with_context_manager",
            "handler_formatting_with_decorator",
            "level_name",
            "level_number",
            "message_formatting_with_context_manager",
            "message_formatting_with_decorator",
            "nested_with_reraise",
            "syntaxerror_without_traceback",
            "sys_tracebacklimit",
            "sys_tracebacklimit_negative",
            "sys_tracebacklimit_none",
            "sys_tracebacklimit_unset",
            "zerodivisionerror_without_traceback",
        ],
    )
    def test_exception_others(filename):
>       compare_exception("others", filename)

filename   = 'sys_tracebacklimit_none'

tests/test_exceptions_formatting.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'others', filename = 'sys_tracebacklimit_none'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'others'
filename   = 'sys_tracebacklimit_none'
filepath   = 'tests/exceptions/source/others/sys_tracebacklimit_none.py'
outpath    = '/testbed/tests/exceptions/output/others/sys_tracebacklimit_none.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_otherssys_tracebacklimit_unset">test_exceptions_formatting.py::test_exception_others[sys_tracebacklimit_unset]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_others[sys_tracebacklimit_unset]</pre></summary><pre>
filename = 'sys_tracebacklimit_unset'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertionerror_without_traceback",
            "catch_as_context_manager",
            "catch_as_decorator_with_parentheses",
            "catch_as_decorator_without_parentheses",
            "catch_as_function",
            "catch_message",
            "exception_formatting_coroutine",
            "exception_formatting_function",
            "exception_formatting_generator",
            "exception_in_property",
            "handler_formatting_with_context_manager",
            "handler_formatting_with_decorator",
            "level_name",
            "level_number",
            "message_formatting_with_context_manager",
            "message_formatting_with_decorator",
            "nested_with_reraise",
            "syntaxerror_without_traceback",
            "sys_tracebacklimit",
            "sys_tracebacklimit_negative",
            "sys_tracebacklimit_none",
            "sys_tracebacklimit_unset",
            "zerodivisionerror_without_traceback",
        ],
    )
    def test_exception_others(filename):
>       compare_exception("others", filename)

filename   = 'sys_tracebacklimit_unset'

tests/test_exceptions_formatting.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'others', filename = 'sys_tracebacklimit_unset'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
            assert proc.returncode == 0
            assert stdout == ""
>           assert stderr != ""
E           AssertionError: assert '' != ''

cwd        = '/testbed'
dirname    = 'others'
filename   = 'sys_tracebacklimit_unset'
filepath   = 'tests/exceptions/source/others/sys_tracebacklimit_unset.py'
outpath    = '/testbed/tests/exceptions/output/others/sys_tracebacklimit_unset.txt'
proc       = <Popen: returncode: 0 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = ''
stdout     = ''

tests/test_exceptions_formatting.py:107: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_otherszerodivisionerror_without_traceback">test_exceptions_formatting.py::test_exception_others[zerodivisionerror_without_traceback]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_others[zerodivisionerror_without_traceback]</pre></summary><pre>
filename = 'zerodivisionerror_without_traceback'

    @pytest.mark.parametrize(
        "filename",
        [
            "assertionerror_without_traceback",
            "catch_as_context_manager",
            "catch_as_decorator_with_parentheses",
            "catch_as_decorator_without_parentheses",
            "catch_as_function",
            "catch_message",
            "exception_formatting_coroutine",
            "exception_formatting_function",
            "exception_formatting_generator",
            "exception_in_property",
            "handler_formatting_with_context_manager",
            "handler_formatting_with_decorator",
            "level_name",
            "level_number",
            "message_formatting_with_context_manager",
            "message_formatting_with_decorator",
            "nested_with_reraise",
            "syntaxerror_without_traceback",
            "sys_tracebacklimit",
            "sys_tracebacklimit_negative",
            "sys_tracebacklimit_none",
            "sys_tracebacklimit_unset",
            "zerodivisionerror_without_traceback",
        ],
    )
    def test_exception_others(filename):
>       compare_exception("others", filename)

filename   = 'zerodivisionerror_without_traceback'

tests/test_exceptions_formatting.py:226: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'others', filename = 'zerodivisionerror_without_traceback'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'others'
filename   = 'zerodivisionerror_without_traceback'
filepath   = 'tests/exceptions/source/others/zerodivisionerror_without_traceback.py'
outpath    = '/testbed/tests/exceptions/output/others/zerodivisionerror_without_traceback.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/others/zerodivisionerror_without_traceba...logger.opt(exception=(type_, value, None)).error("")\nAttributeError: \'NoneType\' object has no attribute \'error\'\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_moderntype_hints-minimum_python_version0">test_exceptions_formatting.py::test_exception_modern[type_hints-minimum_python_version0]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_modern[type_hints-minimum_python_version0]</pre></summary><pre>
filename = 'type_hints', minimum_python_version = (3, 6)

    @pytest.mark.parametrize(
        "filename, minimum_python_version",
        [
            ("type_hints", (3, 6)),
            ("positional_only_argument", (3, 8)),
            ("walrus_operator", (3, 8)),
            ("match_statement", (3, 10)),
            ("exception_group_catch", (3, 11)),
            ("notes", (3, 11)),
            ("grouped_simple", (3, 11)),
            ("grouped_nested", (3, 11)),
            ("grouped_with_cause_and_context", (3, 11)),
            ("grouped_as_cause_and_context", (3, 11)),
            ("grouped_max_length", (3, 11)),
            ("grouped_max_depth", (3, 11)),
            ("f_string", (3, 12)),  # Available since 3.6 but in 3.12 the lexer for f-string changed.
        ],
    )
    def test_exception_modern(filename, minimum_python_version):
        if sys.version_info < minimum_python_version:
            pytest.skip("Feature not supported in this Python version")

>       compare_exception("modern", filename)

filename   = 'type_hints'
minimum_python_version = (3, 6)

tests/test_exceptions_formatting.py:251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'modern', filename = 'type_hints'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'modern'
filename   = 'type_hints'
filepath   = 'tests/exceptions/source/modern/type_hints.py'
outpath    = '/testbed/tests/exceptions/output/modern/type_hints.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/modern/type_hints.py", line 22, in <module>\n    with logger.catch():\nAttributeError: __enter__\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_modernpositional_only_argument-minimum_python_version1">test_exceptions_formatting.py::test_exception_modern[positional_only_argument-minimum_python_version1]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_modern[positional_only_argument-minimum_python_version1]</pre></summary><pre>
filename = 'positional_only_argument', minimum_python_version = (3, 8)

    @pytest.mark.parametrize(
        "filename, minimum_python_version",
        [
            ("type_hints", (3, 6)),
            ("positional_only_argument", (3, 8)),
            ("walrus_operator", (3, 8)),
            ("match_statement", (3, 10)),
            ("exception_group_catch", (3, 11)),
            ("notes", (3, 11)),
            ("grouped_simple", (3, 11)),
            ("grouped_nested", (3, 11)),
            ("grouped_with_cause_and_context", (3, 11)),
            ("grouped_as_cause_and_context", (3, 11)),
            ("grouped_max_length", (3, 11)),
            ("grouped_max_depth", (3, 11)),
            ("f_string", (3, 12)),  # Available since 3.6 but in 3.12 the lexer for f-string changed.
        ],
    )
    def test_exception_modern(filename, minimum_python_version):
        if sys.version_info < minimum_python_version:
            pytest.skip("Feature not supported in this Python version")

>       compare_exception("modern", filename)

filename   = 'positional_only_argument'
minimum_python_version = (3, 8)

tests/test_exceptions_formatting.py:251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'modern', filename = 'positional_only_argument'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'modern'
filename   = 'positional_only_argument'
filepath   = 'tests/exceptions/source/modern/positional_only_argument.py'
outpath    = '/testbed/tests/exceptions/output/modern/positional_only_argument.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/modern/positional_only_argument.py", line 22, in <module>\n    with logger.catch():\nAttributeError: __enter__\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_modernwalrus_operator-minimum_python_version2">test_exceptions_formatting.py::test_exception_modern[walrus_operator-minimum_python_version2]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_modern[walrus_operator-minimum_python_version2]</pre></summary><pre>
filename = 'walrus_operator', minimum_python_version = (3, 8)

    @pytest.mark.parametrize(
        "filename, minimum_python_version",
        [
            ("type_hints", (3, 6)),
            ("positional_only_argument", (3, 8)),
            ("walrus_operator", (3, 8)),
            ("match_statement", (3, 10)),
            ("exception_group_catch", (3, 11)),
            ("notes", (3, 11)),
            ("grouped_simple", (3, 11)),
            ("grouped_nested", (3, 11)),
            ("grouped_with_cause_and_context", (3, 11)),
            ("grouped_as_cause_and_context", (3, 11)),
            ("grouped_max_length", (3, 11)),
            ("grouped_max_depth", (3, 11)),
            ("f_string", (3, 12)),  # Available since 3.6 but in 3.12 the lexer for f-string changed.
        ],
    )
    def test_exception_modern(filename, minimum_python_version):
        if sys.version_info < minimum_python_version:
            pytest.skip("Feature not supported in this Python version")

>       compare_exception("modern", filename)

filename   = 'walrus_operator'
minimum_python_version = (3, 8)

tests/test_exceptions_formatting.py:251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'modern', filename = 'walrus_operator'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'modern'
filename   = 'walrus_operator'
filepath   = 'tests/exceptions/source/modern/walrus_operator.py'
outpath    = '/testbed/tests/exceptions/output/modern/walrus_operator.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/modern/walrus_operator.py", line 25, in <module>\n    main()\nTypeError: \'NoneType\' object is not callable\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_exception_modernmatch_statement-minimum_python_version3">test_exceptions_formatting.py::test_exception_modern[match_statement-minimum_python_version3]</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_exception_modern[match_statement-minimum_python_version3]</pre></summary><pre>
filename = 'match_statement', minimum_python_version = (3, 10)

    @pytest.mark.parametrize(
        "filename, minimum_python_version",
        [
            ("type_hints", (3, 6)),
            ("positional_only_argument", (3, 8)),
            ("walrus_operator", (3, 8)),
            ("match_statement", (3, 10)),
            ("exception_group_catch", (3, 11)),
            ("notes", (3, 11)),
            ("grouped_simple", (3, 11)),
            ("grouped_nested", (3, 11)),
            ("grouped_with_cause_and_context", (3, 11)),
            ("grouped_as_cause_and_context", (3, 11)),
            ("grouped_max_length", (3, 11)),
            ("grouped_max_depth", (3, 11)),
            ("f_string", (3, 12)),  # Available since 3.6 but in 3.12 the lexer for f-string changed.
        ],
    )
    def test_exception_modern(filename, minimum_python_version):
        if sys.version_info < minimum_python_version:
            pytest.skip("Feature not supported in this Python version")

>       compare_exception("modern", filename)

filename   = 'match_statement'
minimum_python_version = (3, 10)

tests/test_exceptions_formatting.py:251: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dirname = 'modern', filename = 'match_statement'

    def compare_exception(dirname, filename):
        cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
        python = sys.executable or "python"
        filepath = os.path.join("tests", "exceptions", "source", dirname, filename + ".py")
        outpath = os.path.join(cwd, "tests", "exceptions", "output", dirname, filename + ".txt")

        with subprocess.Popen(
            [python, filepath],
            shell=False,
            cwd=cwd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            env=dict(os.environ, PYTHONPATH=cwd, PYTHONIOENCODING="utf8"),
        ) as proc:
            stdout, stderr = proc.communicate()
            print(stderr, file=sys.stderr)
>           assert proc.returncode == 0
E           AssertionError: assert 1 == 0
E            +  where 1 = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>.returncode

cwd        = '/testbed'
dirname    = 'modern'
filename   = 'match_statement'
filepath   = 'tests/exceptions/source/modern/match_statement.py'
outpath    = '/testbed/tests/exceptions/output/modern/match_statement.txt'
proc       = <Popen: returncode: 1 args: ['/testbed/.venv/bin/python3', 'tests/exceptions...>
python     = '/testbed/.venv/bin/python3'
stderr     = 'Traceback (most recent call last):\n  File "/testbed/tests/exceptions/source/modern/match_statement.py", line 20, in <module>\n    with logger.catch():\nAttributeError: __enter__\n'
stdout     = ''

tests/test_exceptions_formatting.py:105: AssertionError
</pre>
</details>
<h3 id="test_exceptions_formattingpytest_group_exception_using_backport">test_exceptions_formatting.py::test_group_exception_using_backport</h3>
<details><summary> <pre>test_exceptions_formatting.py::test_group_exception_using_backport</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0889f6d0>

    @pytest.mark.skipif(
        not (3, 7) <= sys.version_info < (3, 11), reason="No backport available or needed"
    )
    def test_group_exception_using_backport(writer):
        from exceptiongroup import ExceptionGroup

        from loguru import logger

        logger.add(writer, backtrace=True, diagnose=True, colorize=False, format="")

        try:
            raise ExceptionGroup("Test", [ValueError(1), ValueError(2)])
        except Exception:
            logger.exception("")

>       assert writer.read().strip().startswith("+ Exception Group Traceback (most recent call last):")
E       AssertionError: assert False
E        +  where False = <built-in method startswith of str object at 0x7fac0db08030>('+ Exception Group Traceback (most recent call last):')
E        +    where <built-in method startswith of str object at 0x7fac0db08030> = ''.startswith
E        +      where '' = <built-in method strip of str object at 0x7fac0db08030>()
E        +        where <built-in method strip of str object at 0x7fac0db08030> = ''.strip
E        +          where '' = <function writer.<locals>.<lambda> at 0x7fac0889ea70>()
E        +            where <function writer.<locals>.<lambda> at 0x7fac0889ea70> = <function writer.<locals>.w at 0x7fac0889f6d0>.read

ExceptionGroup = <class 'exceptiongroup.ExceptionGroup'>
logger     = <loguru.logger handlers=[]>
writer     = <function writer.<locals>.w at 0x7fac0889f6d0>

tests/test_exceptions_formatting.py:269: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_compression_extgz">test_filesink_compression.py::test_compression_ext[gz]</h3>
<details><summary> <pre>test_filesink_compression.py::test_compression_ext[gz]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_gz_0')
compression = 'gz'

    @pytest.mark.parametrize(
        "compression", ["gz", "bz2", "zip", "xz", "lzma", "tar", "tar.gz", "tar.bz2", "tar.xz"]
    )
    def test_compression_ext(tmp_path, compression):
        i = logger.add(tmp_path / "file.log", compression=compression)
        logger.remove(i)

>       check_dir(tmp_path, files=[("file.log.%s" % compression, None)])

compression = 'gz'
i          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_gz_0')

tests/test_filesink_compression.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_gz_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('file.log.gz', None)])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_gz_0')
files      = [('file.log.gz', None)]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_compression_extbz2">test_filesink_compression.py::test_compression_ext[bz2]</h3>
<details><summary> <pre>test_filesink_compression.py::test_compression_ext[bz2]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_bz2_0')
compression = 'bz2'

    @pytest.mark.parametrize(
        "compression", ["gz", "bz2", "zip", "xz", "lzma", "tar", "tar.gz", "tar.bz2", "tar.xz"]
    )
    def test_compression_ext(tmp_path, compression):
        i = logger.add(tmp_path / "file.log", compression=compression)
        logger.remove(i)

>       check_dir(tmp_path, files=[("file.log.%s" % compression, None)])

compression = 'bz2'
i          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_bz2_0')

tests/test_filesink_compression.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_bz2_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('file.log.bz2', None)])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_bz2_0')
files      = [('file.log.bz2', None)]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_compression_extzip">test_filesink_compression.py::test_compression_ext[zip]</h3>
<details><summary> <pre>test_filesink_compression.py::test_compression_ext[zip]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_zip_0')
compression = 'zip'

    @pytest.mark.parametrize(
        "compression", ["gz", "bz2", "zip", "xz", "lzma", "tar", "tar.gz", "tar.bz2", "tar.xz"]
    )
    def test_compression_ext(tmp_path, compression):
        i = logger.add(tmp_path / "file.log", compression=compression)
        logger.remove(i)

>       check_dir(tmp_path, files=[("file.log.%s" % compression, None)])

compression = 'zip'
i          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_zip_0')

tests/test_filesink_compression.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_zip_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('file.log.zip', None)])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_zip_0')
files      = [('file.log.zip', None)]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_compression_extxz">test_filesink_compression.py::test_compression_ext[xz]</h3>
<details><summary> <pre>test_filesink_compression.py::test_compression_ext[xz]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_xz_0')
compression = 'xz'

    @pytest.mark.parametrize(
        "compression", ["gz", "bz2", "zip", "xz", "lzma", "tar", "tar.gz", "tar.bz2", "tar.xz"]
    )
    def test_compression_ext(tmp_path, compression):
        i = logger.add(tmp_path / "file.log", compression=compression)
        logger.remove(i)

>       check_dir(tmp_path, files=[("file.log.%s" % compression, None)])

compression = 'xz'
i          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_xz_0')

tests/test_filesink_compression.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_xz_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('file.log.xz', None)])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_xz_0')
files      = [('file.log.xz', None)]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_compression_extlzma">test_filesink_compression.py::test_compression_ext[lzma]</h3>
<details><summary> <pre>test_filesink_compression.py::test_compression_ext[lzma]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_lzma_0')
compression = 'lzma'

    @pytest.mark.parametrize(
        "compression", ["gz", "bz2", "zip", "xz", "lzma", "tar", "tar.gz", "tar.bz2", "tar.xz"]
    )
    def test_compression_ext(tmp_path, compression):
        i = logger.add(tmp_path / "file.log", compression=compression)
        logger.remove(i)

>       check_dir(tmp_path, files=[("file.log.%s" % compression, None)])

compression = 'lzma'
i          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_lzma_0')

tests/test_filesink_compression.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_lzma_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('file.log.lzma', None)])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_lzma_0')
files      = [('file.log.lzma', None)]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_compression_exttar">test_filesink_compression.py::test_compression_ext[tar]</h3>
<details><summary> <pre>test_filesink_compression.py::test_compression_ext[tar]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_tar_0')
compression = 'tar'

    @pytest.mark.parametrize(
        "compression", ["gz", "bz2", "zip", "xz", "lzma", "tar", "tar.gz", "tar.bz2", "tar.xz"]
    )
    def test_compression_ext(tmp_path, compression):
        i = logger.add(tmp_path / "file.log", compression=compression)
        logger.remove(i)

>       check_dir(tmp_path, files=[("file.log.%s" % compression, None)])

compression = 'tar'
i          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_tar_0')

tests/test_filesink_compression.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_tar_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('file.log.tar', None)])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_tar_0')
files      = [('file.log.tar', None)]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_compression_exttargz">test_filesink_compression.py::test_compression_ext[tar.gz]</h3>
<details><summary> <pre>test_filesink_compression.py::test_compression_ext[tar.gz]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_tar_gz_0')
compression = 'tar.gz'

    @pytest.mark.parametrize(
        "compression", ["gz", "bz2", "zip", "xz", "lzma", "tar", "tar.gz", "tar.bz2", "tar.xz"]
    )
    def test_compression_ext(tmp_path, compression):
        i = logger.add(tmp_path / "file.log", compression=compression)
        logger.remove(i)

>       check_dir(tmp_path, files=[("file.log.%s" % compression, None)])

compression = 'tar.gz'
i          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_tar_gz_0')

tests/test_filesink_compression.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_tar_gz_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('file.log.tar.gz', None)])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_tar_gz_0')
files      = [('file.log.tar.gz', None)]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_compression_exttarbz2">test_filesink_compression.py::test_compression_ext[tar.bz2]</h3>
<details><summary> <pre>test_filesink_compression.py::test_compression_ext[tar.bz2]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_tar_bz2_0')
compression = 'tar.bz2'

    @pytest.mark.parametrize(
        "compression", ["gz", "bz2", "zip", "xz", "lzma", "tar", "tar.gz", "tar.bz2", "tar.xz"]
    )
    def test_compression_ext(tmp_path, compression):
        i = logger.add(tmp_path / "file.log", compression=compression)
        logger.remove(i)

>       check_dir(tmp_path, files=[("file.log.%s" % compression, None)])

compression = 'tar.bz2'
i          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_tar_bz2_0')

tests/test_filesink_compression.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_tar_bz2_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('file.log.tar.bz2', None)])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_tar_bz2_0')
files      = [('file.log.tar.bz2', None)]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_compression_exttarxz">test_filesink_compression.py::test_compression_ext[tar.xz]</h3>
<details><summary> <pre>test_filesink_compression.py::test_compression_ext[tar.xz]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_tar_xz_0')
compression = 'tar.xz'

    @pytest.mark.parametrize(
        "compression", ["gz", "bz2", "zip", "xz", "lzma", "tar", "tar.gz", "tar.bz2", "tar.xz"]
    )
    def test_compression_ext(tmp_path, compression):
        i = logger.add(tmp_path / "file.log", compression=compression)
        logger.remove(i)

>       check_dir(tmp_path, files=[("file.log.%s" % compression, None)])

compression = 'tar.xz'
i          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_tar_xz_0')

tests/test_filesink_compression.py:21: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_tar_xz_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('file.log.tar.xz', None)])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_ext_tar_xz_0')
files      = [('file.log.tar.xz', None)]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_compression_function">test_filesink_compression.py::test_compression_function</h3>
<details><summary> <pre>test_filesink_compression.py::test_compression_function</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_function0')

    def test_compression_function(tmp_path):
        def compress(file):
            os.replace(file, file + ".rar")

        i = logger.add(tmp_path / "file.log", compression=compress)
        logger.remove(i)

>       check_dir(tmp_path, files=[("file.log.rar", None)])

compress   = <function test_compression_function.<locals>.compress at 0x7fac088ed5a0>
i          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_function0')

tests/test_filesink_compression.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_function0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('file.log.rar', None)])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_function0')
files      = [('file.log.rar', None)]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_compression_at_rotationa">test_filesink_compression.py::test_compression_at_rotation[a]</h3>
<details><summary> <pre>test_filesink_compression.py::test_compression_at_rotation[a]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_rotation_a0')
mode = 'a'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac088edb40>

    @pytest.mark.parametrize("mode", ["a", "a+", "w", "x"])
    def test_compression_at_rotation(tmp_path, mode, freeze_time):
        with freeze_time("2010-10-09 11:30:59"):
            logger.add(
                tmp_path / "file.log", format="{message}", rotation=0, compression="gz", mode=mode
            )
            logger.debug("After compression")

>       check_dir(
            tmp_path,
            files=[
                ("file.2010-10-09_11-30-59_000000.log.gz", None),
                ("file.log", "After compression\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac088edb40>
mode       = 'a'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_rotation_a0')

tests/test_filesink_compression.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_rotation_a0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('file.2010-10-09_11-30-59_000000.log.gz', None), ('file.log', 'After compression\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_rotation_a0')
files      = [('file.2010-10-09_11-30-59_000000.log.gz', None), ('file.log', 'After compression\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_compression_at_rotationa_1">test_filesink_compression.py::test_compression_at_rotation[a+]</h3>
<details><summary> <pre>test_filesink_compression.py::test_compression_at_rotation[a+]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_rotation_a1')
mode = 'a+'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac088ede10>

    @pytest.mark.parametrize("mode", ["a", "a+", "w", "x"])
    def test_compression_at_rotation(tmp_path, mode, freeze_time):
        with freeze_time("2010-10-09 11:30:59"):
            logger.add(
                tmp_path / "file.log", format="{message}", rotation=0, compression="gz", mode=mode
            )
            logger.debug("After compression")

>       check_dir(
            tmp_path,
            files=[
                ("file.2010-10-09_11-30-59_000000.log.gz", None),
                ("file.log", "After compression\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac088ede10>
mode       = 'a+'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_rotation_a1')

tests/test_filesink_compression.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_rotation_a1')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('file.2010-10-09_11-30-59_000000.log.gz', None), ('file.log', 'After compression\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_rotation_a1')
files      = [('file.2010-10-09_11-30-59_000000.log.gz', None), ('file.log', 'After compression\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_compression_at_rotationw">test_filesink_compression.py::test_compression_at_rotation[w]</h3>
<details><summary> <pre>test_filesink_compression.py::test_compression_at_rotation[w]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_rotation_w0')
mode = 'w'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac0889e050>

    @pytest.mark.parametrize("mode", ["a", "a+", "w", "x"])
    def test_compression_at_rotation(tmp_path, mode, freeze_time):
        with freeze_time("2010-10-09 11:30:59"):
            logger.add(
                tmp_path / "file.log", format="{message}", rotation=0, compression="gz", mode=mode
            )
            logger.debug("After compression")

>       check_dir(
            tmp_path,
            files=[
                ("file.2010-10-09_11-30-59_000000.log.gz", None),
                ("file.log", "After compression\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac0889e050>
mode       = 'w'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_rotation_w0')

tests/test_filesink_compression.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_rotation_w0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('file.2010-10-09_11-30-59_000000.log.gz', None), ('file.log', 'After compression\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_rotation_w0')
files      = [('file.2010-10-09_11-30-59_000000.log.gz', None), ('file.log', 'After compression\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_compression_at_rotationx">test_filesink_compression.py::test_compression_at_rotation[x]</h3>
<details><summary> <pre>test_filesink_compression.py::test_compression_at_rotation[x]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_rotation_x0')
mode = 'x'
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac088ecb80>

    @pytest.mark.parametrize("mode", ["a", "a+", "w", "x"])
    def test_compression_at_rotation(tmp_path, mode, freeze_time):
        with freeze_time("2010-10-09 11:30:59"):
            logger.add(
                tmp_path / "file.log", format="{message}", rotation=0, compression="gz", mode=mode
            )
            logger.debug("After compression")

>       check_dir(
            tmp_path,
            files=[
                ("file.2010-10-09_11-30-59_000000.log.gz", None),
                ("file.log", "After compression\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac088ecb80>
mode       = 'x'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_rotation_x0')

tests/test_filesink_compression.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_rotation_x0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('file.2010-10-09_11-30-59_000000.log.gz', None), ('file.log', 'After compression\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_rotation_x0')
files      = [('file.2010-10-09_11-30-59_000000.log.gz', None), ('file.log', 'After compression\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_compression_at_remove_without_rotationa">test_filesink_compression.py::test_compression_at_remove_without_rotation[a]</h3>
<details><summary> <pre>test_filesink_compression.py::test_compression_at_remove_without_rotation[a]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_remove_wit0')
mode = 'a'

    @pytest.mark.parametrize("mode", ["a", "a+", "w", "x"])
    def test_compression_at_remove_without_rotation(tmp_path, mode):
        i = logger.add(tmp_path / "file.log", compression="gz", mode=mode)
        logger.debug("test")
        logger.remove(i)

>       check_dir(tmp_path, files=[("file.log.gz", None)])

i          = None
mode       = 'a'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_remove_wit0')

tests/test_filesink_compression.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_remove_wit0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('file.log.gz', None)])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_remove_wit0')
files      = [('file.log.gz', None)]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_compression_at_remove_without_rotationa_1">test_filesink_compression.py::test_compression_at_remove_without_rotation[a+]</h3>
<details><summary> <pre>test_filesink_compression.py::test_compression_at_remove_without_rotation[a+]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_remove_wit1')
mode = 'a+'

    @pytest.mark.parametrize("mode", ["a", "a+", "w", "x"])
    def test_compression_at_remove_without_rotation(tmp_path, mode):
        i = logger.add(tmp_path / "file.log", compression="gz", mode=mode)
        logger.debug("test")
        logger.remove(i)

>       check_dir(tmp_path, files=[("file.log.gz", None)])

i          = None
mode       = 'a+'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_remove_wit1')

tests/test_filesink_compression.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_remove_wit1')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('file.log.gz', None)])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_remove_wit1')
files      = [('file.log.gz', None)]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_compression_at_remove_without_rotationw">test_filesink_compression.py::test_compression_at_remove_without_rotation[w]</h3>
<details><summary> <pre>test_filesink_compression.py::test_compression_at_remove_without_rotation[w]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_remove_wit2')
mode = 'w'

    @pytest.mark.parametrize("mode", ["a", "a+", "w", "x"])
    def test_compression_at_remove_without_rotation(tmp_path, mode):
        i = logger.add(tmp_path / "file.log", compression="gz", mode=mode)
        logger.debug("test")
        logger.remove(i)

>       check_dir(tmp_path, files=[("file.log.gz", None)])

i          = None
mode       = 'w'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_remove_wit2')

tests/test_filesink_compression.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_remove_wit2')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('file.log.gz', None)])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_remove_wit2')
files      = [('file.log.gz', None)]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_compression_at_remove_without_rotationx">test_filesink_compression.py::test_compression_at_remove_without_rotation[x]</h3>
<details><summary> <pre>test_filesink_compression.py::test_compression_at_remove_without_rotation[x]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_remove_wit3')
mode = 'x'

    @pytest.mark.parametrize("mode", ["a", "a+", "w", "x"])
    def test_compression_at_remove_without_rotation(tmp_path, mode):
        i = logger.add(tmp_path / "file.log", compression="gz", mode=mode)
        logger.debug("test")
        logger.remove(i)

>       check_dir(tmp_path, files=[("file.log.gz", None)])

i          = None
mode       = 'x'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_remove_wit3')

tests/test_filesink_compression.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_remove_wit3')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('file.log.gz', None)])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_at_remove_wit3')
files      = [('file.log.gz', None)]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_no_compression_at_remove_with_rotationa">test_filesink_compression.py::test_no_compression_at_remove_with_rotation[a]</h3>
<details><summary> <pre>test_filesink_compression.py::test_no_compression_at_remove_with_rotation[a]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_compression_at_remove_0')
mode = 'a'

    @pytest.mark.parametrize("mode", ["a", "a+", "w", "x"])
    def test_no_compression_at_remove_with_rotation(tmp_path, mode):
        i = logger.add(tmp_path / "test.log", compression="gz", rotation="100 MB", mode=mode)
        logger.debug("test")
        logger.remove(i)

>       check_dir(tmp_path, files=[("test.log", None)])

i          = None
mode       = 'a'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_compression_at_remove_0')

tests/test_filesink_compression.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_compression_at_remove_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('test.log', None)])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_compression_at_remove_0')
files      = [('test.log', None)]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_no_compression_at_remove_with_rotationa_1">test_filesink_compression.py::test_no_compression_at_remove_with_rotation[a+]</h3>
<details><summary> <pre>test_filesink_compression.py::test_no_compression_at_remove_with_rotation[a+]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_compression_at_remove_1')
mode = 'a+'

    @pytest.mark.parametrize("mode", ["a", "a+", "w", "x"])
    def test_no_compression_at_remove_with_rotation(tmp_path, mode):
        i = logger.add(tmp_path / "test.log", compression="gz", rotation="100 MB", mode=mode)
        logger.debug("test")
        logger.remove(i)

>       check_dir(tmp_path, files=[("test.log", None)])

i          = None
mode       = 'a+'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_compression_at_remove_1')

tests/test_filesink_compression.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_compression_at_remove_1')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('test.log', None)])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_compression_at_remove_1')
files      = [('test.log', None)]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_no_compression_at_remove_with_rotationw">test_filesink_compression.py::test_no_compression_at_remove_with_rotation[w]</h3>
<details><summary> <pre>test_filesink_compression.py::test_no_compression_at_remove_with_rotation[w]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_compression_at_remove_2')
mode = 'w'

    @pytest.mark.parametrize("mode", ["a", "a+", "w", "x"])
    def test_no_compression_at_remove_with_rotation(tmp_path, mode):
        i = logger.add(tmp_path / "test.log", compression="gz", rotation="100 MB", mode=mode)
        logger.debug("test")
        logger.remove(i)

>       check_dir(tmp_path, files=[("test.log", None)])

i          = None
mode       = 'w'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_compression_at_remove_2')

tests/test_filesink_compression.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_compression_at_remove_2')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('test.log', None)])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_compression_at_remove_2')
files      = [('test.log', None)]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_no_compression_at_remove_with_rotationx">test_filesink_compression.py::test_no_compression_at_remove_with_rotation[x]</h3>
<details><summary> <pre>test_filesink_compression.py::test_no_compression_at_remove_with_rotation[x]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_compression_at_remove_3')
mode = 'x'

    @pytest.mark.parametrize("mode", ["a", "a+", "w", "x"])
    def test_no_compression_at_remove_with_rotation(tmp_path, mode):
        i = logger.add(tmp_path / "test.log", compression="gz", rotation="100 MB", mode=mode)
        logger.debug("test")
        logger.remove(i)

>       check_dir(tmp_path, files=[("test.log", None)])

i          = None
mode       = 'x'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_compression_at_remove_3')

tests/test_filesink_compression.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_compression_at_remove_3')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('test.log', None)])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_compression_at_remove_3')
files      = [('test.log', None)]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_rename_existing_with_creation_time">test_filesink_compression.py::test_rename_existing_with_creation_time</h3>
<details><summary> <pre>test_filesink_compression.py::test_rename_existing_with_creation_time</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_rename_existing_with_crea0')
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac088eeb00>

    def test_rename_existing_with_creation_time(tmp_path, freeze_time):
        with freeze_time("2018-01-01") as frozen:
            i = logger.add(tmp_path / "test.log", compression="tar.gz")
            logger.debug("test")
            logger.remove(i)
            frozen.tick()
            j = logger.add(tmp_path / "test.log", compression="tar.gz")
            logger.debug("test")
            logger.remove(j)

>       check_dir(
            tmp_path,
            files=[("test.2018-01-01_00-00-00_000000.log.tar.gz", None), ("test.log.tar.gz", None)],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac088eeb00>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08773d30>
i          = None
j          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_rename_existing_with_crea0')

tests/test_filesink_compression.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_rename_existing_with_crea0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test.2018-01-01_00-00-00_000000.log.tar.gz', None), ('test.log.tar.gz', None)])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_rename_existing_with_crea0')
files      = [('test.2018-01-01_00-00-00_000000.log.tar.gz', None), ('test.log.tar.gz', None)]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_renaming_compression_dest_exists">test_filesink_compression.py::test_renaming_compression_dest_exists</h3>
<details><summary> <pre>test_filesink_compression.py::test_renaming_compression_dest_exists</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac088eef80>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_renaming_compression_dest0')

    def test_renaming_compression_dest_exists(freeze_time, tmp_path):
        with freeze_time("2019-01-02 03:04:05.000006"):
            for i in range(4):
                logger.add(tmp_path / "rotate.log", compression=".tar.gz", format="{message}")
                logger.info(str(i))
                logger.remove()

>       check_dir(
            tmp_path,
            files=[
                ("rotate.log.tar.gz", None),
                ("rotate.2019-01-02_03-04-05_000006.log.tar.gz", None),
                ("rotate.2019-01-02_03-04-05_000006.2.log.tar.gz", None),
                ("rotate.2019-01-02_03-04-05_000006.3.log.tar.gz", None),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac088eef80>
i          = 3
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_renaming_compression_dest0')

tests/test_filesink_compression.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_renaming_compression_dest0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 4
E            +  where 0 = len(set())
E            +  and   4 = len([('rotate.log.tar.gz', None), ('rotate.2019-01-02_03-04-05_000006.log.tar.gz', None), ('rotate.2019-01-02_03-04-05_000006.2.log.tar.gz', None), ('rotate.2019-01-02_03-04-05_000006.3.log.tar.gz', None)])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_renaming_compression_dest0')
files      = [('rotate.log.tar.gz', None), ('rotate.2019-01-02_03-04-05_000006.log.tar.gz', None), ('rotate.2019-01-02_03-04-05_000006.2.log.tar.gz', None), ('rotate.2019-01-02_03-04-05_000006.3.log.tar.gz', None)]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_renaming_compression_dest_exists_with_time">test_filesink_compression.py::test_renaming_compression_dest_exists_with_time</h3>
<details><summary> <pre>test_filesink_compression.py::test_renaming_compression_dest_exists_with_time</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac088ef370>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_renaming_compression_dest1')

    def test_renaming_compression_dest_exists_with_time(freeze_time, tmp_path):
        with freeze_time("2019-01-02 03:04:05.000006"):
            for i in range(4):
                logger.add(tmp_path / "rotate.{time}.log", compression=".tar.gz", format="{message}")
                logger.info(str(i))
                logger.remove()

>       check_dir(
            tmp_path,
            files=[
                ("rotate.2019-01-02_03-04-05_000006.log.tar.gz", None),
                ("rotate.2019-01-02_03-04-05_000006.2019-01-02_03-04-05_000006.log.tar.gz", None),
                ("rotate.2019-01-02_03-04-05_000006.2019-01-02_03-04-05_000006.2.log.tar.gz", None),
                ("rotate.2019-01-02_03-04-05_000006.2019-01-02_03-04-05_000006.3.log.tar.gz", None),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac088ef370>
i          = 3
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_renaming_compression_dest1')

tests/test_filesink_compression.py:110: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_renaming_compression_dest1')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 4
E            +  where 0 = len(set())
E            +  and   4 = len([('rotate.2019-01-02_03-04-05_000006.log.tar.gz', None), ('rotate.2019-01-02_03-04-05_000006.2019-01-02_03-04-05_00000...04-05_000006.2.log.tar.gz', None), ('rotate.2019-01-02_03-04-05_000006.2019-01-02_03-04-05_000006.3.log.tar.gz', None)])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_renaming_compression_dest1')
files      = [('rotate.2019-01-02_03-04-05_000006.log.tar.gz', None), ('rotate.2019-01-02_03-04-05_000006.2019-01-02_03-04-05_00000...04-05_000006.2.log.tar.gz', None), ('rotate.2019-01-02_03-04-05_000006.2019-01-02_03-04-05_000006.3.log.tar.gz', None)]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_compression_use_renamed_file_after_rotation">test_filesink_compression.py::test_compression_use_renamed_file_after_rotation</h3>
<details><summary> <pre>test_filesink_compression.py::test_compression_use_renamed_file_after_rotation</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_use_renamed_f0')
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac088ef7f0>

    def test_compression_use_renamed_file_after_rotation(tmp_path, freeze_time):
        def rotation(message, _):
            return message.record["extra"].get("rotate", False)

        compression = Mock()

        with freeze_time("2020-01-02"):
            logger.add(
                tmp_path / "test.log", format="{message}", compression=compression, rotation=rotation
            )

            logger.info("Before")
>           logger.bind(rotate=True).info("Rotation")
E           AttributeError: 'NoneType' object has no attribute 'info'

compression = <Mock id='140376852747488'>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac088ef7f0>
rotation   = <function test_compression_use_renamed_file_after_rotation.<locals>.rotation at 0x7fac088edea0>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression_use_renamed_f0')

tests/test_filesink_compression.py:133: AttributeError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_threaded_compression_after_rotation">test_filesink_compression.py::test_threaded_compression_after_rotation</h3>
<details><summary> <pre>test_filesink_compression.py::test_threaded_compression_after_rotation</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_threaded_compression_afte0')

    def test_threaded_compression_after_rotation(tmp_path):
        thread = None

        def rename(filepath):
            time.sleep(1)
            os.rename(filepath, str(tmp_path / "test.log.mv"))

        def compression(filepath):
            nonlocal thread
            thread = threading.Thread(target=rename, args=(filepath,))
            thread.start()

        def rotation(message, _):
            return message.record["extra"].get("rotate", False)

        logger.add(
            tmp_path / "test.log", format="{message}", compression=compression, rotation=rotation
        )

        logger.info("Before")
>       logger.bind(rotate=True).info("Rotation")
E       AttributeError: 'NoneType' object has no attribute 'info'

compression = <function test_threaded_compression_after_rotation.<locals>.compression at 0x7fac088eee60>
rename     = <function test_threaded_compression_after_rotation.<locals>.rename at 0x7fac088edfc0>
rotation   = <function test_threaded_compression_after_rotation.<locals>.rotation at 0x7fac088ef9a0>
thread     = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_threaded_compression_afte0')

tests/test_filesink_compression.py:167: AttributeError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_exception_during_compression_at_rotationtrue">test_filesink_compression.py::test_exception_during_compression_at_rotation[True]</h3>
<details><summary> <pre>test_filesink_compression.py::test_exception_during_compression_at_rotation[True]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac088efbe0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_compress0')
capsys = <_pytest.capture.CaptureFixture object at 0x7fac094c0eb0>, delay = True

    @pytest.mark.parametrize("delay", [True, False])
    def test_exception_during_compression_at_rotation(freeze_time, tmp_path, capsys, delay):
        with freeze_time("2017-07-01") as frozen:
            logger.add(
                tmp_path / "test.log",
                format="{message}",
                compression=Mock(side_effect=[Exception("Compression error"), None]),
                rotation=0,
                catch=True,
                delay=delay,
            )
            logger.debug("AAA")
            frozen.tick()
            logger.debug("BBB")

>       check_dir(
            tmp_path,
            files=[
                ("test.2017-07-01_00-00-00_000000.log", ""),
                ("test.2017-07-01_00-00-01_000000.log", ""),
                ("test.log", "BBB\n"),
            ],
        )

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac094c0eb0>
delay      = True
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac088efbe0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac094c0ac0>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_compress0')

tests/test_filesink_compression.py:196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_compress0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 3
E            +  where 0 = len(set())
E            +  and   3 = len([('test.2017-07-01_00-00-00_000000.log', ''), ('test.2017-07-01_00-00-01_000000.log', ''), ('test.log', 'BBB\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_compress0')
files      = [('test.2017-07-01_00-00-00_000000.log', ''), ('test.2017-07-01_00-00-01_000000.log', ''), ('test.log', 'BBB\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_exception_during_compression_at_rotationfalse">test_filesink_compression.py::test_exception_during_compression_at_rotation[False]</h3>
<details><summary> <pre>test_filesink_compression.py::test_exception_during_compression_at_rotation[False]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac088ef9a0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_compress1')
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0876dc60>
delay = False

    @pytest.mark.parametrize("delay", [True, False])
    def test_exception_during_compression_at_rotation(freeze_time, tmp_path, capsys, delay):
        with freeze_time("2017-07-01") as frozen:
            logger.add(
                tmp_path / "test.log",
                format="{message}",
                compression=Mock(side_effect=[Exception("Compression error"), None]),
                rotation=0,
                catch=True,
                delay=delay,
            )
            logger.debug("AAA")
            frozen.tick()
            logger.debug("BBB")

>       check_dir(
            tmp_path,
            files=[
                ("test.2017-07-01_00-00-00_000000.log", ""),
                ("test.2017-07-01_00-00-01_000000.log", ""),
                ("test.log", "BBB\n"),
            ],
        )

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0876dc60>
delay      = False
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac088ef9a0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac0876da20>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_compress1')

tests/test_filesink_compression.py:196: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_compress1')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 3
E            +  where 0 = len(set())
E            +  and   3 = len([('test.2017-07-01_00-00-00_000000.log', ''), ('test.2017-07-01_00-00-01_000000.log', ''), ('test.log', 'BBB\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_compress1')
files      = [('test.2017-07-01_00-00-00_000000.log', ''), ('test.2017-07-01_00-00-01_000000.log', ''), ('test.log', 'BBB\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_compressionpytest_exception_during_compression_at_rotation_not_caughttrue">test_filesink_compression.py::test_exception_during_compression_at_rotation_not_caught[True]</h3>
<details><summary> <pre>test_filesink_compression.py::test_exception_during_compression_at_rotation_not_caught[True]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087ac040>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_compress2')
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0885fb50>, delay = True

    @pytest.mark.parametrize("delay", [True, False])
    def test_exception_during_compression_at_rotation_not_caught(freeze_time, tmp_path, capsys, delay):
        with freeze_time("2017-07-01") as frozen:
            logger.add(
                tmp_path / "test.log",
                format="{message}",
                compression=Mock(side_effect=[OSError("Compression error"), None]),
                rotation=0,
                catch=False,
                delay=delay,
            )
>           with pytest.raises(OSError, match="Compression error"):
E           Failed: DID NOT RAISE <class 'OSError'>

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0885fb50>
delay      = True
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087ac040>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac0885e290>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_compress2')

tests/test_filesink_compression.py:222: Failed
</pre>
</details>
<h3 id="test_filesink_compressionpytest_exception_during_compression_at_rotation_not_caughtfalse">test_filesink_compression.py::test_exception_during_compression_at_rotation_not_caught[False]</h3>
<details><summary> <pre>test_filesink_compression.py::test_exception_during_compression_at_rotation_not_caught[False]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087ac5e0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_compress3')
capsys = <_pytest.capture.CaptureFixture object at 0x7fac08716da0>
delay = False

    @pytest.mark.parametrize("delay", [True, False])
    def test_exception_during_compression_at_rotation_not_caught(freeze_time, tmp_path, capsys, delay):
        with freeze_time("2017-07-01") as frozen:
            logger.add(
                tmp_path / "test.log",
                format="{message}",
                compression=Mock(side_effect=[OSError("Compression error"), None]),
                rotation=0,
                catch=False,
                delay=delay,
            )
>           with pytest.raises(OSError, match="Compression error"):
E           Failed: DID NOT RAISE <class 'OSError'>

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac08716da0>
delay      = False
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087ac5e0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08715de0>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_compress3')

tests/test_filesink_compression.py:222: Failed
</pre>
</details>
<h3 id="test_filesink_compressionpytest_exception_during_compression_at_removetrue">test_filesink_compression.py::test_exception_during_compression_at_remove[True]</h3>
<details><summary> <pre>test_filesink_compression.py::test_exception_during_compression_at_remove[True]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_compress4')
capsys = <_pytest.capture.CaptureFixture object at 0x7fac088e7610>, delay = True

    @pytest.mark.parametrize("delay", [True, False])
    def test_exception_during_compression_at_remove(tmp_path, capsys, delay):
        i = logger.add(
            tmp_path / "test.log",
            format="{message}",
            compression=Mock(side_effect=[OSError("Compression error"), None]),
            catch=True,
            delay=delay,
        )
        logger.debug("AAA")

>       with pytest.raises(OSError, match=r"Compression error"):
E       Failed: DID NOT RAISE <class 'OSError'>

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac088e7610>
delay      = True
i          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_compress4')

tests/test_filesink_compression.py:252: Failed
</pre>
</details>
<h3 id="test_filesink_compressionpytest_exception_during_compression_at_removefalse">test_filesink_compression.py::test_exception_during_compression_at_remove[False]</h3>
<details><summary> <pre>test_filesink_compression.py::test_exception_during_compression_at_remove[False]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_compress5')
capsys = <_pytest.capture.CaptureFixture object at 0x7fac09332fe0>
delay = False

    @pytest.mark.parametrize("delay", [True, False])
    def test_exception_during_compression_at_remove(tmp_path, capsys, delay):
        i = logger.add(
            tmp_path / "test.log",
            format="{message}",
            compression=Mock(side_effect=[OSError("Compression error"), None]),
            catch=True,
            delay=delay,
        )
        logger.debug("AAA")

>       with pytest.raises(OSError, match=r"Compression error"):
E       Failed: DID NOT RAISE <class 'OSError'>

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac09332fe0>
delay      = False
i          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_compress5')

tests/test_filesink_compression.py:252: Failed
</pre>
</details>
<h3 id="test_filesink_compressionpytest_invalid_compression0">test_filesink_compression.py::test_invalid_compression[0]</h3>
<details><summary> <pre>test_filesink_compression.py::test_invalid_compression[0]</pre></summary><pre>
compression = 0

    @pytest.mark.parametrize("compression", [0, True, os, object(), {"zip"}])
    def test_invalid_compression(compression):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

compression = 0

tests/test_filesink_compression.py:270: Failed
</pre>
</details>
<h3 id="test_filesink_compressionpytest_invalid_compressiontrue">test_filesink_compression.py::test_invalid_compression[True]</h3>
<details><summary> <pre>test_filesink_compression.py::test_invalid_compression[True]</pre></summary><pre>
compression = True

    @pytest.mark.parametrize("compression", [0, True, os, object(), {"zip"}])
    def test_invalid_compression(compression):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

compression = True

tests/test_filesink_compression.py:270: Failed
</pre>
</details>
<h3 id="test_filesink_compressionpytest_invalid_compressionos">test_filesink_compression.py::test_invalid_compression[os]</h3>
<details><summary> <pre>test_filesink_compression.py::test_invalid_compression[os]</pre></summary><pre>
compression = <module 'os' from '/usr/lib/python3.10/os.py'>

    @pytest.mark.parametrize("compression", [0, True, os, object(), {"zip"}])
    def test_invalid_compression(compression):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

compression = <module 'os' from '/usr/lib/python3.10/os.py'>

tests/test_filesink_compression.py:270: Failed
</pre>
</details>
<h3 id="test_filesink_compressionpytest_invalid_compressioncompression3">test_filesink_compression.py::test_invalid_compression[compression3]</h3>
<details><summary> <pre>test_filesink_compression.py::test_invalid_compression[compression3]</pre></summary><pre>
compression = <object object at 0x7fac0bf24a20>

    @pytest.mark.parametrize("compression", [0, True, os, object(), {"zip"}])
    def test_invalid_compression(compression):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

compression = <object object at 0x7fac0bf24a20>

tests/test_filesink_compression.py:270: Failed
</pre>
</details>
<h3 id="test_filesink_compressionpytest_invalid_compressioncompression4">test_filesink_compression.py::test_invalid_compression[compression4]</h3>
<details><summary> <pre>test_filesink_compression.py::test_invalid_compression[compression4]</pre></summary><pre>
compression = {'zip'}

    @pytest.mark.parametrize("compression", [0, True, os, object(), {"zip"}])
    def test_invalid_compression(compression):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

compression = {'zip'}

tests/test_filesink_compression.py:270: Failed
</pre>
</details>
<h3 id="test_filesink_compressionpytest_unknown_compressionrar">test_filesink_compression.py::test_unknown_compression[rar]</h3>
<details><summary> <pre>test_filesink_compression.py::test_unknown_compression[rar]</pre></summary><pre>
compression = 'rar'

    @pytest.mark.parametrize("compression", ["rar", ".7z", "tar.zip", "__dict__"])
    def test_unknown_compression(compression):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

compression = 'rar'

tests/test_filesink_compression.py:276: Failed
</pre>
</details>
<h3 id="test_filesink_compressionpytest_unknown_compression7z">test_filesink_compression.py::test_unknown_compression[.7z]</h3>
<details><summary> <pre>test_filesink_compression.py::test_unknown_compression[.7z]</pre></summary><pre>
compression = '.7z'

    @pytest.mark.parametrize("compression", ["rar", ".7z", "tar.zip", "__dict__"])
    def test_unknown_compression(compression):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

compression = '.7z'

tests/test_filesink_compression.py:276: Failed
</pre>
</details>
<h3 id="test_filesink_compressionpytest_unknown_compressiontarzip">test_filesink_compression.py::test_unknown_compression[tar.zip]</h3>
<details><summary> <pre>test_filesink_compression.py::test_unknown_compression[tar.zip]</pre></summary><pre>
compression = 'tar.zip'

    @pytest.mark.parametrize("compression", ["rar", ".7z", "tar.zip", "__dict__"])
    def test_unknown_compression(compression):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

compression = 'tar.zip'

tests/test_filesink_compression.py:276: Failed
</pre>
</details>
<h3 id="test_filesink_compressionpytest_unknown_compressiondict">test_filesink_compression.py::test_unknown_compression[<strong>dict</strong>]</h3>
<details><summary> <pre>test_filesink_compression.py::test_unknown_compression[__dict__]</pre></summary><pre>
compression = '__dict__'

    @pytest.mark.parametrize("compression", ["rar", ".7z", "tar.zip", "__dict__"])
    def test_unknown_compression(compression):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

compression = '__dict__'

tests/test_filesink_compression.py:276: Failed
</pre>
</details>
<h3 id="test_filesink_compressionpytest_gzip_module_unavailablegz">test_filesink_compression.py::test_gzip_module_unavailable[gz]</h3>
<details><summary> <pre>test_filesink_compression.py::test_gzip_module_unavailable[gz]</pre></summary><pre>
ext = 'gz'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0936c340>

    @pytest.mark.parametrize("ext", ["gz", "tar.gz"])
    def test_gzip_module_unavailable(ext, monkeypatch):
        monkeypatch.setitem(sys.modules, "gzip", None)
>       with pytest.raises(ImportError):
E       Failed: DID NOT RAISE <class 'ImportError'>

ext        = 'gz'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0936c340>

tests/test_filesink_compression.py:283: Failed
</pre>
</details>
<h3 id="test_filesink_compressionpytest_gzip_module_unavailabletargz">test_filesink_compression.py::test_gzip_module_unavailable[tar.gz]</h3>
<details><summary> <pre>test_filesink_compression.py::test_gzip_module_unavailable[tar.gz]</pre></summary><pre>
ext = 'tar.gz'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0876c6d0>

    @pytest.mark.parametrize("ext", ["gz", "tar.gz"])
    def test_gzip_module_unavailable(ext, monkeypatch):
        monkeypatch.setitem(sys.modules, "gzip", None)
>       with pytest.raises(ImportError):
E       Failed: DID NOT RAISE <class 'ImportError'>

ext        = 'tar.gz'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0876c6d0>

tests/test_filesink_compression.py:283: Failed
</pre>
</details>
<h3 id="test_filesink_compressionpytest_bz2_module_unavailablebz2">test_filesink_compression.py::test_bz2_module_unavailable[bz2]</h3>
<details><summary> <pre>test_filesink_compression.py::test_bz2_module_unavailable[bz2]</pre></summary><pre>
ext = 'bz2'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0942dcc0>

    @pytest.mark.parametrize("ext", ["bz2", "tar.bz2"])
    def test_bz2_module_unavailable(ext, monkeypatch):
        monkeypatch.setitem(sys.modules, "bz2", None)
>       with pytest.raises(ImportError):
E       Failed: DID NOT RAISE <class 'ImportError'>

ext        = 'bz2'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0942dcc0>

tests/test_filesink_compression.py:290: Failed
</pre>
</details>
<h3 id="test_filesink_compressionpytest_bz2_module_unavailabletarbz2">test_filesink_compression.py::test_bz2_module_unavailable[tar.bz2]</h3>
<details><summary> <pre>test_filesink_compression.py::test_bz2_module_unavailable[tar.bz2]</pre></summary><pre>
ext = 'tar.bz2'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0b0cdbd0>

    @pytest.mark.parametrize("ext", ["bz2", "tar.bz2"])
    def test_bz2_module_unavailable(ext, monkeypatch):
        monkeypatch.setitem(sys.modules, "bz2", None)
>       with pytest.raises(ImportError):
E       Failed: DID NOT RAISE <class 'ImportError'>

ext        = 'tar.bz2'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0b0cdbd0>

tests/test_filesink_compression.py:290: Failed
</pre>
</details>
<h3 id="test_filesink_compressionpytest_lzma_module_unavailablexz">test_filesink_compression.py::test_lzma_module_unavailable[xz]</h3>
<details><summary> <pre>test_filesink_compression.py::test_lzma_module_unavailable[xz]</pre></summary><pre>
ext = 'xz'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac09300670>

    @pytest.mark.parametrize("ext", ["xz", "lzma", "tar.xz"])
    def test_lzma_module_unavailable(ext, monkeypatch):
        monkeypatch.setitem(sys.modules, "lzma", None)
>       with pytest.raises(ImportError):
E       Failed: DID NOT RAISE <class 'ImportError'>

ext        = 'xz'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac09300670>

tests/test_filesink_compression.py:297: Failed
</pre>
</details>
<h3 id="test_filesink_compressionpytest_lzma_module_unavailablelzma">test_filesink_compression.py::test_lzma_module_unavailable[lzma]</h3>
<details><summary> <pre>test_filesink_compression.py::test_lzma_module_unavailable[lzma]</pre></summary><pre>
ext = 'lzma'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac094c2830>

    @pytest.mark.parametrize("ext", ["xz", "lzma", "tar.xz"])
    def test_lzma_module_unavailable(ext, monkeypatch):
        monkeypatch.setitem(sys.modules, "lzma", None)
>       with pytest.raises(ImportError):
E       Failed: DID NOT RAISE <class 'ImportError'>

ext        = 'lzma'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac094c2830>

tests/test_filesink_compression.py:297: Failed
</pre>
</details>
<h3 id="test_filesink_compressionpytest_lzma_module_unavailabletarxz">test_filesink_compression.py::test_lzma_module_unavailable[tar.xz]</h3>
<details><summary> <pre>test_filesink_compression.py::test_lzma_module_unavailable[tar.xz]</pre></summary><pre>
ext = 'tar.xz'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac093056f0>

    @pytest.mark.parametrize("ext", ["xz", "lzma", "tar.xz"])
    def test_lzma_module_unavailable(ext, monkeypatch):
        monkeypatch.setitem(sys.modules, "lzma", None)
>       with pytest.raises(ImportError):
E       Failed: DID NOT RAISE <class 'ImportError'>

ext        = 'tar.xz'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac093056f0>

tests/test_filesink_compression.py:297: Failed
</pre>
</details>
<h3 id="test_filesink_compressionpytest_tarfile_module_unavailabletar">test_filesink_compression.py::test_tarfile_module_unavailable[tar]</h3>
<details><summary> <pre>test_filesink_compression.py::test_tarfile_module_unavailable[tar]</pre></summary><pre>
ext = 'tar'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac09320400>

    @pytest.mark.parametrize("ext", ["tar", "tar.gz", "tar.bz2", "tar.xz"])
    def test_tarfile_module_unavailable(ext, monkeypatch):
        monkeypatch.setitem(sys.modules, "tarfile", None)
>       with pytest.raises(ImportError):
E       Failed: DID NOT RAISE <class 'ImportError'>

ext        = 'tar'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac09320400>

tests/test_filesink_compression.py:304: Failed
</pre>
</details>
<h3 id="test_filesink_compressionpytest_tarfile_module_unavailabletargz">test_filesink_compression.py::test_tarfile_module_unavailable[tar.gz]</h3>
<details><summary> <pre>test_filesink_compression.py::test_tarfile_module_unavailable[tar.gz]</pre></summary><pre>
ext = 'tar.gz'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0936c2b0>

    @pytest.mark.parametrize("ext", ["tar", "tar.gz", "tar.bz2", "tar.xz"])
    def test_tarfile_module_unavailable(ext, monkeypatch):
        monkeypatch.setitem(sys.modules, "tarfile", None)
>       with pytest.raises(ImportError):
E       Failed: DID NOT RAISE <class 'ImportError'>

ext        = 'tar.gz'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0936c2b0>

tests/test_filesink_compression.py:304: Failed
</pre>
</details>
<h3 id="test_filesink_compressionpytest_tarfile_module_unavailabletarbz2">test_filesink_compression.py::test_tarfile_module_unavailable[tar.bz2]</h3>
<details><summary> <pre>test_filesink_compression.py::test_tarfile_module_unavailable[tar.bz2]</pre></summary><pre>
ext = 'tar.bz2'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08f46b00>

    @pytest.mark.parametrize("ext", ["tar", "tar.gz", "tar.bz2", "tar.xz"])
    def test_tarfile_module_unavailable(ext, monkeypatch):
        monkeypatch.setitem(sys.modules, "tarfile", None)
>       with pytest.raises(ImportError):
E       Failed: DID NOT RAISE <class 'ImportError'>

ext        = 'tar.bz2'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08f46b00>

tests/test_filesink_compression.py:304: Failed
</pre>
</details>
<h3 id="test_filesink_compressionpytest_tarfile_module_unavailabletarxz">test_filesink_compression.py::test_tarfile_module_unavailable[tar.xz]</h3>
<details><summary> <pre>test_filesink_compression.py::test_tarfile_module_unavailable[tar.xz]</pre></summary><pre>
ext = 'tar.xz'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0930eb30>

    @pytest.mark.parametrize("ext", ["tar", "tar.gz", "tar.bz2", "tar.xz"])
    def test_tarfile_module_unavailable(ext, monkeypatch):
        monkeypatch.setitem(sys.modules, "tarfile", None)
>       with pytest.raises(ImportError):
E       Failed: DID NOT RAISE <class 'ImportError'>

ext        = 'tar.xz'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0930eb30>

tests/test_filesink_compression.py:304: Failed
</pre>
</details>
<h3 id="test_filesink_compressionpytest_zipfile_module_unavailablezip">test_filesink_compression.py::test_zipfile_module_unavailable[zip]</h3>
<details><summary> <pre>test_filesink_compression.py::test_zipfile_module_unavailable[zip]</pre></summary><pre>
ext = 'zip'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac09303400>

    @pytest.mark.parametrize("ext", ["zip"])
    def test_zipfile_module_unavailable(ext, monkeypatch):
        monkeypatch.setitem(sys.modules, "zipfile", None)
>       with pytest.raises(ImportError):
E       Failed: DID NOT RAISE <class 'ImportError'>

ext        = 'zip'
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac09303400>

tests/test_filesink_compression.py:311: Failed
</pre>
</details>
<h3 id="test_filesink_delaypytest_file_not_delayed">test_filesink_delay.py::test_file_not_delayed</h3>
<details><summary> <pre>test_filesink_delay.py::test_file_not_delayed</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_not_delayed0')

    def test_file_not_delayed(tmp_path):
        file = tmp_path / "test.log"
        logger.add(file, format="{message}", delay=False)
>       assert file.read_text() == ""

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_not_delayed0/test.log')
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_not_delayed0')

tests/test_filesink_delay.py:12: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_not_delayed0/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_not_delayed0/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_not_delayed0/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_not_delayed0/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_filesink_delaypytest_file_delayed">test_filesink_delay.py::test_file_delayed</h3>
<details><summary> <pre>test_filesink_delay.py::test_file_delayed</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_delayed0')

    def test_file_delayed(tmp_path):
        file = tmp_path / "test.log"
        logger.add(file, format="{message}", delay=True)
        assert not file.exists()
        logger.debug("Delayed")
>       assert file.read_text() == "Delayed\n"

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_delayed0/test.log')
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_delayed0')

tests/test_filesink_delay.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_delayed0/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_delayed0/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_delayed0/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_delayed0/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_filesink_delaypytest_compression">test_filesink_delay.py::test_compression</h3>
<details><summary> <pre>test_filesink_delay.py::test_compression</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression0')

    def test_compression(tmp_path):
        i = logger.add(tmp_path / "file.log", compression="gz", delay=True)
        logger.debug("a")
        logger.remove(i)

>       check_dir(tmp_path, files=[("file.log.gz", None)])

i          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression0')

tests/test_filesink_delay.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('file.log.gz', None)])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_compression0')
files      = [('file.log.gz', None)]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_delaypytest_retention">test_filesink_delay.py::test_retention</h3>
<details><summary> <pre>test_filesink_delay.py::test_retention</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention0')

    def test_retention(tmp_path):
        for i in range(5):
            tmp_path.joinpath("test.2020-01-01_01-01-%d_000001.log" % i).write_text("test")

        i = logger.add(tmp_path / "test.log", retention=0, delay=True)
        logger.debug("a")
        logger.remove(i)

>       check_dir(tmp_path, size=0)

i          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention0')

tests/test_filesink_delay.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           AssertionError: assert 5 == 0
E            +  where 5 = len({PosixPath('/tmp/pytest-of-root/pytest-0/test_retention0/test.2020-01-01_01-01-0_000001.log'), PosixPath('/tmp/pytest-...-01_01-01-3_000001.log'), PosixPath('/tmp/pytest-of-root/pytest-0/test_retention0/test.2020-01-01_01-01-4_000001.log')})

actual_files = {PosixPath('/tmp/pytest-of-root/pytest-0/test_retention0/test.2020-01-01_01-01-0_000001.log'), PosixPath('/tmp/pytest-...-01_01-01-3_000001.log'), PosixPath('/tmp/pytest-of-root/pytest-0/test_retention0/test.2020-01-01_01-01-4_000001.log')}
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention0')
files      = None
seen       = set()
size       = 0

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_delaypytest_retention_early_remove">test_filesink_delay.py::test_retention_early_remove</h3>
<details><summary> <pre>test_filesink_delay.py::test_retention_early_remove</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_early_remove0')

    def test_retention_early_remove(tmp_path):
        for i in range(5):
            tmp_path.joinpath("test.2020-01-01_01-01-%d_000001.log" % i).write_text("test")

        i = logger.add(tmp_path / "test.log", retention=0, delay=True)
        logger.remove(i)

>       check_dir(tmp_path, size=0)

i          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_early_remove0')

tests/test_filesink_delay.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_early_remove0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           AssertionError: assert 5 == 0
E            +  where 5 = len({PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_early_remove0/test.2020-01-01_01-01-0_000001.log'), PosixPath(...00001.log'), PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_early_remove0/test.2020-01-01_01-01-4_000001.log')})

actual_files = {PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_early_remove0/test.2020-01-01_01-01-0_000001.log'), PosixPath(...00001.log'), PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_early_remove0/test.2020-01-01_01-01-4_000001.log')}
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_early_remove0')
files      = None
seen       = set()
size       = 0

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_delaypytest_rotation">test_filesink_delay.py::test_rotation</h3>
<details><summary> <pre>test_filesink_delay.py::test_rotation</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation0')
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac088ee560>

    def test_rotation(tmp_path, freeze_time):
        with freeze_time("2001-02-03"):
            i = logger.add(tmp_path / "file.log", rotation=0, delay=True, format="{message}")
            logger.debug("a")
            logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("file.2001-02-03_00-00-00_000000.log", ""),
                ("file.log", "a\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac088ee560>
i          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation0')

tests/test_filesink_delay.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('file.2001-02-03_00-00-00_000000.log', ''), ('file.log', 'a\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation0')
files      = [('file.2001-02-03_00-00-00_000000.log', ''), ('file.log', 'a\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_delaypytest_rotation_and_retention">test_filesink_delay.py::test_rotation_and_retention</h3>
<details><summary> <pre>test_filesink_delay.py::test_rotation_and_retention</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac088efbe0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_and_retention0')

    def test_rotation_and_retention(freeze_time, tmp_path):
        with freeze_time("1999-12-12") as frozen:
            filepath = tmp_path / "file.log"
            logger.add(filepath, rotation=30, retention=2, delay=True, format="{message}")
            for i in range(1, 10):
                time.sleep(0.05)  # Retention is based on mtime.
                frozen.tick(datetime.timedelta(seconds=0.05))
                logger.info(str(i) * 20)

>       check_dir(
            tmp_path,
            files=[
                ("file.1999-12-12_00-00-00_350000.log", "7" * 20 + "\n"),
                ("file.1999-12-12_00-00-00_400000.log", "8" * 20 + "\n"),
                ("file.log", "9" * 20 + "\n"),
            ],
        )

filepath   = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_and_retention0/file.log')
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac088efbe0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac0930ea40>
i          = 9
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_and_retention0')

tests/test_filesink_delay.py:91: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_and_retention0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 3
E            +  where 0 = len(set())
E            +  and   3 = len([('file.1999-12-12_00-00-00_350000.log', '77777777777777777777\n'), ('file.1999-12-12_00-00-00_400000.log', '88888888888888888888\n'), ('file.log', '99999999999999999999\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_and_retention0')
files      = [('file.1999-12-12_00-00-00_350000.log', '77777777777777777777\n'), ('file.1999-12-12_00-00-00_400000.log', '88888888888888888888\n'), ('file.log', '99999999999999999999\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_delaypytest_rotation_and_retention_timed_file">test_filesink_delay.py::test_rotation_and_retention_timed_file</h3>
<details><summary> <pre>test_filesink_delay.py::test_rotation_and_retention_timed_file</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087aca60>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_and_retention_ti0')

    def test_rotation_and_retention_timed_file(freeze_time, tmp_path):
        with freeze_time("1999-12-12") as frozen:
            filepath = tmp_path / "file.{time}.log"
            logger.add(filepath, rotation=30, retention=2, delay=True, format="{message}")
            for i in range(1, 10):
                time.sleep(0.05)  # Retention is based on mtime.
                frozen.tick(datetime.timedelta(seconds=0.05))
                logger.info(str(i) * 20)

>       check_dir(
            tmp_path,
            files=[
                ("file.1999-12-12_00-00-00_350000.log", "7" * 20 + "\n"),
                ("file.1999-12-12_00-00-00_400000.log", "8" * 20 + "\n"),
                ("file.1999-12-12_00-00-00_450000.log", "9" * 20 + "\n"),
            ],
        )

filepath   = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_and_retention_ti0/file.{time}.log')
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087aca60>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08f46260>
i          = 9
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_and_retention_ti0')

tests/test_filesink_delay.py:110: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_and_retention_ti0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 3
E            +  where 0 = len(set())
E            +  and   3 = len([('file.1999-12-12_00-00-00_350000.log', '77777777777777777777\n'), ('file.1999-12-12_00-00-00_400000.log', '88888888888888888888\n'), ('file.1999-12-12_00-00-00_450000.log', '99999999999999999999\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_and_retention_ti0')
files      = [('file.1999-12-12_00-00-00_350000.log', '77777777777777777777\n'), ('file.1999-12-12_00-00-00_400000.log', '88888888888888888888\n'), ('file.1999-12-12_00-00-00_450000.log', '99999999999999999999\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_permissionspytest_log_file_permissions511">test_filesink_permissions.py::test_log_file_permissions[511]</h3>
<details><summary> <pre>test_filesink_permissions.py::test_log_file_permissions[511]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_log_file_permissions_511_0')
permissions = 511

    @pytest.mark.parametrize("permissions", [0o777, 0o766, 0o744, 0o700, 0o611])
    def test_log_file_permissions(tmp_path, permissions):
        def file_permission_opener(file, flags):
            return os.open(file, flags, permissions)

        filepath = tmp_path / "file.log"
        logger.add(filepath, opener=file_permission_opener)

        logger.debug("Message")
>       stat_result = os.stat(str(filepath))
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_log_file_permissions_511_0/file.log'

file_permission_opener = <function test_log_file_permissions.<locals>.file_permission_opener at 0x7fac0889ea70>
filepath   = PosixPath('/tmp/pytest-of-root/pytest-0/test_log_file_permissions_511_0/file.log')
permissions = 511
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_log_file_permissions_511_0')

tests/test_filesink_permissions.py:25: FileNotFoundError
</pre>
</details>
<h3 id="test_filesink_permissionspytest_log_file_permissions502">test_filesink_permissions.py::test_log_file_permissions[502]</h3>
<details><summary> <pre>test_filesink_permissions.py::test_log_file_permissions[502]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_log_file_permissions_502_0')
permissions = 502

    @pytest.mark.parametrize("permissions", [0o777, 0o766, 0o744, 0o700, 0o611])
    def test_log_file_permissions(tmp_path, permissions):
        def file_permission_opener(file, flags):
            return os.open(file, flags, permissions)

        filepath = tmp_path / "file.log"
        logger.add(filepath, opener=file_permission_opener)

        logger.debug("Message")
>       stat_result = os.stat(str(filepath))
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_log_file_permissions_502_0/file.log'

file_permission_opener = <function test_log_file_permissions.<locals>.file_permission_opener at 0x7fac088ef010>
filepath   = PosixPath('/tmp/pytest-of-root/pytest-0/test_log_file_permissions_502_0/file.log')
permissions = 502
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_log_file_permissions_502_0')

tests/test_filesink_permissions.py:25: FileNotFoundError
</pre>
</details>
<h3 id="test_filesink_permissionspytest_log_file_permissions484">test_filesink_permissions.py::test_log_file_permissions[484]</h3>
<details><summary> <pre>test_filesink_permissions.py::test_log_file_permissions[484]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_log_file_permissions_484_0')
permissions = 484

    @pytest.mark.parametrize("permissions", [0o777, 0o766, 0o744, 0o700, 0o611])
    def test_log_file_permissions(tmp_path, permissions):
        def file_permission_opener(file, flags):
            return os.open(file, flags, permissions)

        filepath = tmp_path / "file.log"
        logger.add(filepath, opener=file_permission_opener)

        logger.debug("Message")
>       stat_result = os.stat(str(filepath))
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_log_file_permissions_484_0/file.log'

file_permission_opener = <function test_log_file_permissions.<locals>.file_permission_opener at 0x7fac087ac4c0>
filepath   = PosixPath('/tmp/pytest-of-root/pytest-0/test_log_file_permissions_484_0/file.log')
permissions = 484
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_log_file_permissions_484_0')

tests/test_filesink_permissions.py:25: FileNotFoundError
</pre>
</details>
<h3 id="test_filesink_permissionspytest_log_file_permissions448">test_filesink_permissions.py::test_log_file_permissions[448]</h3>
<details><summary> <pre>test_filesink_permissions.py::test_log_file_permissions[448]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_log_file_permissions_448_0')
permissions = 448

    @pytest.mark.parametrize("permissions", [0o777, 0o766, 0o744, 0o700, 0o611])
    def test_log_file_permissions(tmp_path, permissions):
        def file_permission_opener(file, flags):
            return os.open(file, flags, permissions)

        filepath = tmp_path / "file.log"
        logger.add(filepath, opener=file_permission_opener)

        logger.debug("Message")
>       stat_result = os.stat(str(filepath))
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_log_file_permissions_448_0/file.log'

file_permission_opener = <function test_log_file_permissions.<locals>.file_permission_opener at 0x7fac087ac280>
filepath   = PosixPath('/tmp/pytest-of-root/pytest-0/test_log_file_permissions_448_0/file.log')
permissions = 448
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_log_file_permissions_448_0')

tests/test_filesink_permissions.py:25: FileNotFoundError
</pre>
</details>
<h3 id="test_filesink_permissionspytest_log_file_permissions393">test_filesink_permissions.py::test_log_file_permissions[393]</h3>
<details><summary> <pre>test_filesink_permissions.py::test_log_file_permissions[393]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_log_file_permissions_393_0')
permissions = 393

    @pytest.mark.parametrize("permissions", [0o777, 0o766, 0o744, 0o700, 0o611])
    def test_log_file_permissions(tmp_path, permissions):
        def file_permission_opener(file, flags):
            return os.open(file, flags, permissions)

        filepath = tmp_path / "file.log"
        logger.add(filepath, opener=file_permission_opener)

        logger.debug("Message")
>       stat_result = os.stat(str(filepath))
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_log_file_permissions_393_0/file.log'

file_permission_opener = <function test_log_file_permissions.<locals>.file_permission_opener at 0x7fac087acd30>
filepath   = PosixPath('/tmp/pytest-of-root/pytest-0/test_log_file_permissions_393_0/file.log')
permissions = 393
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_log_file_permissions_393_0')

tests/test_filesink_permissions.py:25: FileNotFoundError
</pre>
</details>
<h3 id="test_filesink_permissionspytest_rotation_permissions511">test_filesink_permissions.py::test_rotation_permissions[511]</h3>
<details><summary> <pre>test_filesink_permissions.py::test_rotation_permissions[511]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_permissions_511_0')
permissions = 511, set_umask = None

    @pytest.mark.parametrize("permissions", [0o777, 0o766, 0o744, 0o700, 0o611])
    def test_rotation_permissions(tmp_path, permissions, set_umask):
        def file_permission_opener(file, flags):
            return os.open(file, flags, permissions)

        logger.add(tmp_path / "file.log", rotation=0, opener=file_permission_opener)

        logger.debug("Message")

        files = list(tmp_path.iterdir())
>       assert len(files) == 2
E       assert 0 == 2
E        +  where 0 = len([])

file_permission_opener = <function test_rotation_permissions.<locals>.file_permission_opener at 0x7fac087ad120>
files      = []
permissions = 511
set_umask  = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_permissions_511_0')

tests/test_filesink_permissions.py:40: AssertionError
</pre>
</details>
<h3 id="test_filesink_permissionspytest_rotation_permissions502">test_filesink_permissions.py::test_rotation_permissions[502]</h3>
<details><summary> <pre>test_filesink_permissions.py::test_rotation_permissions[502]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_permissions_502_0')
permissions = 502, set_umask = None

    @pytest.mark.parametrize("permissions", [0o777, 0o766, 0o744, 0o700, 0o611])
    def test_rotation_permissions(tmp_path, permissions, set_umask):
        def file_permission_opener(file, flags):
            return os.open(file, flags, permissions)

        logger.add(tmp_path / "file.log", rotation=0, opener=file_permission_opener)

        logger.debug("Message")

        files = list(tmp_path.iterdir())
>       assert len(files) == 2
E       assert 0 == 2
E        +  where 0 = len([])

file_permission_opener = <function test_rotation_permissions.<locals>.file_permission_opener at 0x7fac087ac1f0>
files      = []
permissions = 502
set_umask  = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_permissions_502_0')

tests/test_filesink_permissions.py:40: AssertionError
</pre>
</details>
<h3 id="test_filesink_permissionspytest_rotation_permissions484">test_filesink_permissions.py::test_rotation_permissions[484]</h3>
<details><summary> <pre>test_filesink_permissions.py::test_rotation_permissions[484]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_permissions_484_0')
permissions = 484, set_umask = None

    @pytest.mark.parametrize("permissions", [0o777, 0o766, 0o744, 0o700, 0o611])
    def test_rotation_permissions(tmp_path, permissions, set_umask):
        def file_permission_opener(file, flags):
            return os.open(file, flags, permissions)

        logger.add(tmp_path / "file.log", rotation=0, opener=file_permission_opener)

        logger.debug("Message")

        files = list(tmp_path.iterdir())
>       assert len(files) == 2
E       assert 0 == 2
E        +  where 0 = len([])

file_permission_opener = <function test_rotation_permissions.<locals>.file_permission_opener at 0x7fac087ad510>
files      = []
permissions = 484
set_umask  = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_permissions_484_0')

tests/test_filesink_permissions.py:40: AssertionError
</pre>
</details>
<h3 id="test_filesink_permissionspytest_rotation_permissions448">test_filesink_permissions.py::test_rotation_permissions[448]</h3>
<details><summary> <pre>test_filesink_permissions.py::test_rotation_permissions[448]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_permissions_448_0')
permissions = 448, set_umask = None

    @pytest.mark.parametrize("permissions", [0o777, 0o766, 0o744, 0o700, 0o611])
    def test_rotation_permissions(tmp_path, permissions, set_umask):
        def file_permission_opener(file, flags):
            return os.open(file, flags, permissions)

        logger.add(tmp_path / "file.log", rotation=0, opener=file_permission_opener)

        logger.debug("Message")

        files = list(tmp_path.iterdir())
>       assert len(files) == 2
E       assert 0 == 2
E        +  where 0 = len([])

file_permission_opener = <function test_rotation_permissions.<locals>.file_permission_opener at 0x7fac087ad1b0>
files      = []
permissions = 448
set_umask  = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_permissions_448_0')

tests/test_filesink_permissions.py:40: AssertionError
</pre>
</details>
<h3 id="test_filesink_permissionspytest_rotation_permissions393">test_filesink_permissions.py::test_rotation_permissions[393]</h3>
<details><summary> <pre>test_filesink_permissions.py::test_rotation_permissions[393]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_permissions_393_0')
permissions = 393, set_umask = None

    @pytest.mark.parametrize("permissions", [0o777, 0o766, 0o744, 0o700, 0o611])
    def test_rotation_permissions(tmp_path, permissions, set_umask):
        def file_permission_opener(file, flags):
            return os.open(file, flags, permissions)

        logger.add(tmp_path / "file.log", rotation=0, opener=file_permission_opener)

        logger.debug("Message")

        files = list(tmp_path.iterdir())
>       assert len(files) == 2
E       assert 0 == 2
E        +  where 0 = len([])

file_permission_opener = <function test_rotation_permissions.<locals>.file_permission_opener at 0x7fac087ad990>
files      = []
permissions = 393
set_umask  = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_permissions_393_0')

tests/test_filesink_permissions.py:40: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_retention_time1-hour">test_filesink_retention.py::test_retention_time[1 hour]</h3>
<details><summary> <pre>test_filesink_retention.py::test_retention_time[1 hour]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087adb40>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_time_1_hour_0')
retention = '1 hour'

    @pytest.mark.parametrize("retention", ["1 hour", "1H", " 1 h ", datetime.timedelta(hours=1)])
    def test_retention_time(freeze_time, tmp_path, retention):
        i = logger.add(tmp_path / "test.log.x", retention=retention)
        logger.debug("test")
        logger.remove(i)

>       check_dir(tmp_path, size=1)

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087adb40>
i          = None
retention  = '1 hour'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_time_1_hour_0')

tests/test_filesink_retention.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_time_1_hour_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           assert 0 == 1
E            +  where 0 = len(set())

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_time_1_hour_0')
files      = None
seen       = set()
size       = 1

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_retention_time1h">test_filesink_retention.py::test_retention_time[1H]</h3>
<details><summary> <pre>test_filesink_retention.py::test_retention_time[1H]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087ae4d0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_time_1H_0')
retention = '1H'

    @pytest.mark.parametrize("retention", ["1 hour", "1H", " 1 h ", datetime.timedelta(hours=1)])
    def test_retention_time(freeze_time, tmp_path, retention):
        i = logger.add(tmp_path / "test.log.x", retention=retention)
        logger.debug("test")
        logger.remove(i)

>       check_dir(tmp_path, size=1)

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087ae4d0>
i          = None
retention  = '1H'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_time_1H_0')

tests/test_filesink_retention.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_time_1H_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           assert 0 == 1
E            +  where 0 = len(set())

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_time_1H_0')
files      = None
seen       = set()
size       = 1

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_retention_time-1-h">test_filesink_retention.py::test_retention_time[ 1 h ]</h3>
<details><summary> <pre>test_filesink_retention.py::test_retention_time[ 1 h ]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087ad900>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_time__1_h__0')
retention = ' 1 h '

    @pytest.mark.parametrize("retention", ["1 hour", "1H", " 1 h ", datetime.timedelta(hours=1)])
    def test_retention_time(freeze_time, tmp_path, retention):
        i = logger.add(tmp_path / "test.log.x", retention=retention)
        logger.debug("test")
        logger.remove(i)

>       check_dir(tmp_path, size=1)

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087ad900>
i          = None
retention  = ' 1 h '
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_time__1_h__0')

tests/test_filesink_retention.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_time__1_h__0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           assert 0 == 1
E            +  where 0 = len(set())

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_time__1_h__0')
files      = None
seen       = set()
size       = 1

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_retention_timeretention3">test_filesink_retention.py::test_retention_time[retention3]</h3>
<details><summary> <pre>test_filesink_retention.py::test_retention_time[retention3]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087ae320>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_time_retention30')
retention = datetime.timedelta(seconds=3600)

    @pytest.mark.parametrize("retention", ["1 hour", "1H", " 1 h ", datetime.timedelta(hours=1)])
    def test_retention_time(freeze_time, tmp_path, retention):
        i = logger.add(tmp_path / "test.log.x", retention=retention)
        logger.debug("test")
        logger.remove(i)

>       check_dir(tmp_path, size=1)

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087ae320>
i          = None
retention  = datetime.timedelta(seconds=3600)
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_time_retention30')

tests/test_filesink_retention.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_time_retention30')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           assert 0 == 1
E            +  where 0 = len(set())

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_time_retention30')
files      = None
seen       = set()
size       = 1

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_retention_function">test_filesink_retention.py::test_retention_function</h3>
<details><summary> <pre>test_filesink_retention.py::test_retention_function</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_function0')

    def test_retention_function(tmp_path):
        def func(logs):
            for log in logs:
                os.rename(log, log + ".xyz")

        tmp_path.joinpath("test.log.1").write_text("A")
        tmp_path.joinpath("test").write_text("B")

        i = logger.add(tmp_path / "test.log", retention=func)
        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test.log.1.xyz", "A"),
                ("test", "B"),
                ("test.log.xyz", ""),
            ],
        )

func       = <function test_retention_function.<locals>.func at 0x7fac087aea70>
i          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_function0')

tests/test_filesink_retention.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_function0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 2 == 3
E            +  where 2 = len({PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_function0/test'), PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_function0/test.log.1')})
E            +  and   3 = len([('test.log.1.xyz', 'A'), ('test', 'B'), ('test.log.xyz', '')])

actual_files = {PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_function0/test'), PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_function0/test.log.1')}
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_function0')
files      = [('test.log.1.xyz', 'A'), ('test', 'B'), ('test.log.xyz', '')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_managed_files">test_filesink_retention.py::test_managed_files</h3>
<details><summary> <pre>test_filesink_retention.py::test_managed_files</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_managed_files0')

    def test_managed_files(tmp_path):
        others = {
            "test.log",
            "test.log.1",
            "test.log.1.gz",
            "test.log.rar",
            "test.2019-11-12_03-22-07_018985.log",
            "test.2019-11-12_03-22-07_018985.log.tar.gz",
            "test.2019-11-12_03-22-07_018985.2.log",
            "test.2019-11-12_03-22-07_018985.2.log.tar.gz",
            "test.foo.log",
            "test.123.log",
            "test.2019-11-12_03-22-07_018985.abc.log",
            "test.2019-11-12_03-22-07_018985.123.abc.log",
            "test.foo.log.bar",
            "test.log.log",
        }

        for other in others:
            tmp_path.joinpath(other).write_text(other)

        i = logger.add(tmp_path / "test.log", retention=0, catch=False)
        logger.remove(i)

>       check_dir(tmp_path, size=0)

i          = None
other      = 'test.2019-11-12_03-22-07_018985.abc.log'
others     = {'test.123.log', 'test.2019-11-12_03-22-07_018985.123.abc.log', 'test.2019-11-12_03-22-07_018985.2.log', 'test.2019-11-12_03-22-07_018985.2.log.tar.gz', 'test.2019-11-12_03-22-07_018985.abc.log', 'test.2019-11-12_03-22-07_018985.log', ...}
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_managed_files0')

tests/test_filesink_retention.py:89: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_managed_files0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           AssertionError: assert 14 == 0
E            +  where 14 = len({PosixPath('/tmp/pytest-of-root/pytest-0/test_managed_files0/test.123.log'), PosixPath('/tmp/pytest-of-root/pytest-0/t...8985.abc.log'), PosixPath('/tmp/pytest-of-root/pytest-0/test_managed_files0/test.2019-11-12_03-22-07_018985.log'), ...})

actual_files = {PosixPath('/tmp/pytest-of-root/pytest-0/test_managed_files0/test.123.log'), PosixPath('/tmp/pytest-of-root/pytest-0/t...8985.abc.log'), PosixPath('/tmp/pytest-of-root/pytest-0/test_managed_files0/test.2019-11-12_03-22-07_018985.log'), ...}
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_managed_files0')
files      = None
seen       = set()
size       = 0

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_no_duplicates_in_listed_filestest">test_filesink_retention.py::test_no_duplicates_in_listed_files[test]</h3>
<details><summary> <pre>test_filesink_retention.py::test_no_duplicates_in_listed_files[test]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_duplicates_in_listed_f0')
filename = 'test'

    @pytest.mark.parametrize("filename", ["test", "test.log"])
    def test_no_duplicates_in_listed_files(tmp_path, filename):
        others = [
            "test.log",
            "test.log.log",
            "test.log.log.log",
            "test",
            "test..",
            "test.log..",
            "test..log",
            "test...log",
            "test.log..",
            "test.log.a.log.b",
        ]

        for other in others:
            tmp_path.joinpath(other).write_text(other)

        retention = Mock()
        i = logger.add(tmp_path / filename, retention=retention, catch=False)
        logger.remove(i)

>       assert retention.call_count == 1
E       AssertionError: assert 0 == 1
E        +  where 0 = <Mock id='140376865349568'>.call_count

filename   = 'test'
i          = None
other      = 'test.log.a.log.b'
others     = ['test.log', 'test.log.log', 'test.log.log.log', 'test', 'test..', 'test.log..', ...]
retention  = <Mock id='140376865349568'>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_duplicates_in_listed_f0')

tests/test_filesink_retention.py:143: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_no_duplicates_in_listed_filestestlog">test_filesink_retention.py::test_no_duplicates_in_listed_files[test.log]</h3>
<details><summary> <pre>test_filesink_retention.py::test_no_duplicates_in_listed_files[test.log]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_duplicates_in_listed_f1')
filename = 'test.log'

    @pytest.mark.parametrize("filename", ["test", "test.log"])
    def test_no_duplicates_in_listed_files(tmp_path, filename):
        others = [
            "test.log",
            "test.log.log",
            "test.log.log.log",
            "test",
            "test..",
            "test.log..",
            "test..log",
            "test...log",
            "test.log..",
            "test.log.a.log.b",
        ]

        for other in others:
            tmp_path.joinpath(other).write_text(other)

        retention = Mock()
        i = logger.add(tmp_path / filename, retention=retention, catch=False)
        logger.remove(i)

>       assert retention.call_count == 1
E       AssertionError: assert 0 == 1
E        +  where 0 = <Mock id='140376853141280'>.call_count

filename   = 'test.log'
i          = None
other      = 'test.log.a.log.b'
others     = ['test.log', 'test.log.log', 'test.log.log.log', 'test', 'test..', 'test.log..', ...]
retention  = <Mock id='140376853141280'>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_duplicates_in_listed_f1')

tests/test_filesink_retention.py:143: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_manage_formatted_files">test_filesink_retention.py::test_manage_formatted_files</h3>
<details><summary> <pre>test_filesink_retention.py::test_manage_formatted_files</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087ad900>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_manage_formatted_files0')

    def test_manage_formatted_files(freeze_time, tmp_path):
        with freeze_time("2018-01-01 00:00:00"):
            f1 = tmp_path / "temp/2018/file.log"
            f2 = tmp_path / "temp/file2018.log"
            f3 = tmp_path / "temp/d2018/f2018.2018.log"

            a = logger.add(tmp_path / "temp/{time:YYYY}/file.log", retention=0)
            b = logger.add(tmp_path / "temp/file{time:YYYY}.log", retention=0)
            c = logger.add(tmp_path / "temp/d{time:YYYY}/f{time:YYYY}.{time:YYYY}.log", retention=0)

            logger.debug("test")

>           assert f1.exists()
E           AssertionError: assert False
E            +  where False = exists()
E            +    where exists = PosixPath('/tmp/pytest-of-root/pytest-0/test_manage_formatted_files0/temp/2018/file.log').exists

a          = None
b          = None
c          = None
f1         = PosixPath('/tmp/pytest-of-root/pytest-0/test_manage_formatted_files0/temp/2018/file.log')
f2         = PosixPath('/tmp/pytest-of-root/pytest-0/test_manage_formatted_files0/temp/file2018.log')
f3         = PosixPath('/tmp/pytest-of-root/pytest-0/test_manage_formatted_files0/temp/d2018/f2018.2018.log')
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087ad900>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_manage_formatted_files0')

tests/test_filesink_retention.py:171: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_manage_file_without_extension">test_filesink_retention.py::test_manage_file_without_extension</h3>
<details><summary> <pre>test_filesink_retention.py::test_manage_file_without_extension</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_manage_file_without_exten0')

    def test_manage_file_without_extension(tmp_path):
        file = tmp_path / "file"

        i = logger.add(file, retention=0)
        logger.debug("?")
>       check_dir(tmp_path, files=[("file", None)])

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_manage_file_without_exten0/file')
i          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_manage_file_without_exten0')

tests/test_filesink_retention.py:210: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_manage_file_without_exten0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('file', None)])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_manage_file_without_exten0')
files      = [('file', None)]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_manage_formatted_files_without_extension">test_filesink_retention.py::test_manage_formatted_files_without_extension</h3>
<details><summary> <pre>test_filesink_retention.py::test_manage_formatted_files_without_extension</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_manage_formatted_files_wi0')

    def test_manage_formatted_files_without_extension(tmp_path):
        tmp_path.joinpath("file_8").touch()
        tmp_path.joinpath("file_7").touch()
        tmp_path.joinpath("file_6").touch()

        i = logger.add(tmp_path / "file_{time}", retention=0)
        logger.debug("1")
        logger.remove(i)

>       check_dir(tmp_path, size=0)

i          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_manage_formatted_files_wi0')

tests/test_filesink_retention.py:224: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_manage_formatted_files_wi0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           AssertionError: assert 3 == 0
E            +  where 3 = len({PosixPath('/tmp/pytest-of-root/pytest-0/test_manage_formatted_files_wi0/file_6'), PosixPath('/tmp/pytest-of-root/pyte..._manage_formatted_files_wi0/file_7'), PosixPath('/tmp/pytest-of-root/pytest-0/test_manage_formatted_files_wi0/file_8')})

actual_files = {PosixPath('/tmp/pytest-of-root/pytest-0/test_manage_formatted_files_wi0/file_6'), PosixPath('/tmp/pytest-of-root/pyte..._manage_formatted_files_wi0/file_7'), PosixPath('/tmp/pytest-of-root/pytest-0/test_manage_formatted_files_wi0/file_8')}
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_manage_formatted_files_wi0')
files      = None
seen       = set()
size       = 0

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_retention_at_rotationa">test_filesink_retention.py::test_retention_at_rotation[a]</h3>
<details><summary> <pre>test_filesink_retention.py::test_retention_at_rotation[a]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_a_0')
mode = 'a'

    @pytest.mark.parametrize("mode", ["a", "a+", "w", "x"])
    def test_retention_at_rotation(tmp_path, mode):
        tmp_path.joinpath("test.log.1").touch()
        tmp_path.joinpath("test.log.2").touch()
        tmp_path.joinpath("test.log.3").touch()

        logger.add(tmp_path / "test.log", retention=1, rotation=0, mode=mode)
        logger.debug("test")

>       check_dir(tmp_path, size=2)

mode       = 'a'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_a_0')

tests/test_filesink_retention.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_a_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           AssertionError: assert 3 == 2
E            +  where 3 = len({PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_a_0/test.log.1'), PosixPath('/tmp/pytest-of-root/p...tion_at_rotation_a_0/test.log.2'), PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_a_0/test.log.3')})

actual_files = {PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_a_0/test.log.1'), PosixPath('/tmp/pytest-of-root/p...tion_at_rotation_a_0/test.log.2'), PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_a_0/test.log.3')}
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_a_0')
files      = None
seen       = set()
size       = 2

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_retention_at_rotationa_1">test_filesink_retention.py::test_retention_at_rotation[a+]</h3>
<details><summary> <pre>test_filesink_retention.py::test_retention_at_rotation[a+]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_a__0')
mode = 'a+'

    @pytest.mark.parametrize("mode", ["a", "a+", "w", "x"])
    def test_retention_at_rotation(tmp_path, mode):
        tmp_path.joinpath("test.log.1").touch()
        tmp_path.joinpath("test.log.2").touch()
        tmp_path.joinpath("test.log.3").touch()

        logger.add(tmp_path / "test.log", retention=1, rotation=0, mode=mode)
        logger.debug("test")

>       check_dir(tmp_path, size=2)

mode       = 'a+'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_a__0')

tests/test_filesink_retention.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_a__0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           AssertionError: assert 3 == 2
E            +  where 3 = len({PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_a__0/test.log.1'), PosixPath('/tmp/pytest-of-root/...on_at_rotation_a__0/test.log.2'), PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_a__0/test.log.3')})

actual_files = {PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_a__0/test.log.1'), PosixPath('/tmp/pytest-of-root/...on_at_rotation_a__0/test.log.2'), PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_a__0/test.log.3')}
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_a__0')
files      = None
seen       = set()
size       = 2

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_retention_at_rotationw">test_filesink_retention.py::test_retention_at_rotation[w]</h3>
<details><summary> <pre>test_filesink_retention.py::test_retention_at_rotation[w]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_w_0')
mode = 'w'

    @pytest.mark.parametrize("mode", ["a", "a+", "w", "x"])
    def test_retention_at_rotation(tmp_path, mode):
        tmp_path.joinpath("test.log.1").touch()
        tmp_path.joinpath("test.log.2").touch()
        tmp_path.joinpath("test.log.3").touch()

        logger.add(tmp_path / "test.log", retention=1, rotation=0, mode=mode)
        logger.debug("test")

>       check_dir(tmp_path, size=2)

mode       = 'w'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_w_0')

tests/test_filesink_retention.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_w_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           AssertionError: assert 3 == 2
E            +  where 3 = len({PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_w_0/test.log.1'), PosixPath('/tmp/pytest-of-root/p...tion_at_rotation_w_0/test.log.2'), PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_w_0/test.log.3')})

actual_files = {PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_w_0/test.log.1'), PosixPath('/tmp/pytest-of-root/p...tion_at_rotation_w_0/test.log.2'), PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_w_0/test.log.3')}
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_w_0')
files      = None
seen       = set()
size       = 2

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_retention_at_rotationx">test_filesink_retention.py::test_retention_at_rotation[x]</h3>
<details><summary> <pre>test_filesink_retention.py::test_retention_at_rotation[x]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_x_0')
mode = 'x'

    @pytest.mark.parametrize("mode", ["a", "a+", "w", "x"])
    def test_retention_at_rotation(tmp_path, mode):
        tmp_path.joinpath("test.log.1").touch()
        tmp_path.joinpath("test.log.2").touch()
        tmp_path.joinpath("test.log.3").touch()

        logger.add(tmp_path / "test.log", retention=1, rotation=0, mode=mode)
        logger.debug("test")

>       check_dir(tmp_path, size=2)

mode       = 'x'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_x_0')

tests/test_filesink_retention.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_x_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           AssertionError: assert 3 == 2
E            +  where 3 = len({PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_x_0/test.log.1'), PosixPath('/tmp/pytest-of-root/p...tion_at_rotation_x_0/test.log.2'), PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_x_0/test.log.3')})

actual_files = {PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_x_0/test.log.1'), PosixPath('/tmp/pytest-of-root/p...tion_at_rotation_x_0/test.log.2'), PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_x_0/test.log.3')}
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_rotation_x_0')
files      = None
seen       = set()
size       = 2

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_retention_at_remove_without_rotationa">test_filesink_retention.py::test_retention_at_remove_without_rotation[a]</h3>
<details><summary> <pre>test_filesink_retention.py::test_retention_at_remove_without_rotation[a]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_remove_witho0')
mode = 'a'

    @pytest.mark.parametrize("mode", ["a", "a+", "w", "x"])
    def test_retention_at_remove_without_rotation(tmp_path, mode):
        i = logger.add(tmp_path / "file.log", retention=0, mode=mode)
        logger.debug("1")
>       check_dir(tmp_path, size=1)

i          = None
mode       = 'a'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_remove_witho0')

tests/test_filesink_retention.py:243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_remove_witho0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           assert 0 == 1
E            +  where 0 = len(set())

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_remove_witho0')
files      = None
seen       = set()
size       = 1

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_retention_at_remove_without_rotationa_1">test_filesink_retention.py::test_retention_at_remove_without_rotation[a+]</h3>
<details><summary> <pre>test_filesink_retention.py::test_retention_at_remove_without_rotation[a+]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_remove_witho1')
mode = 'a+'

    @pytest.mark.parametrize("mode", ["a", "a+", "w", "x"])
    def test_retention_at_remove_without_rotation(tmp_path, mode):
        i = logger.add(tmp_path / "file.log", retention=0, mode=mode)
        logger.debug("1")
>       check_dir(tmp_path, size=1)

i          = None
mode       = 'a+'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_remove_witho1')

tests/test_filesink_retention.py:243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_remove_witho1')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           assert 0 == 1
E            +  where 0 = len(set())

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_remove_witho1')
files      = None
seen       = set()
size       = 1

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_retention_at_remove_without_rotationw">test_filesink_retention.py::test_retention_at_remove_without_rotation[w]</h3>
<details><summary> <pre>test_filesink_retention.py::test_retention_at_remove_without_rotation[w]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_remove_witho2')
mode = 'w'

    @pytest.mark.parametrize("mode", ["a", "a+", "w", "x"])
    def test_retention_at_remove_without_rotation(tmp_path, mode):
        i = logger.add(tmp_path / "file.log", retention=0, mode=mode)
        logger.debug("1")
>       check_dir(tmp_path, size=1)

i          = None
mode       = 'w'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_remove_witho2')

tests/test_filesink_retention.py:243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_remove_witho2')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           assert 0 == 1
E            +  where 0 = len(set())

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_remove_witho2')
files      = None
seen       = set()
size       = 1

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_retention_at_remove_without_rotationx">test_filesink_retention.py::test_retention_at_remove_without_rotation[x]</h3>
<details><summary> <pre>test_filesink_retention.py::test_retention_at_remove_without_rotation[x]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_remove_witho3')
mode = 'x'

    @pytest.mark.parametrize("mode", ["a", "a+", "w", "x"])
    def test_retention_at_remove_without_rotation(tmp_path, mode):
        i = logger.add(tmp_path / "file.log", retention=0, mode=mode)
        logger.debug("1")
>       check_dir(tmp_path, size=1)

i          = None
mode       = 'x'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_remove_witho3')

tests/test_filesink_retention.py:243: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_remove_witho3')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           assert 0 == 1
E            +  where 0 = len(set())

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_retention_at_remove_witho3')
files      = None
seen       = set()
size       = 1

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_no_retention_at_remove_with_rotationw">test_filesink_retention.py::test_no_retention_at_remove_with_rotation[w]</h3>
<details><summary> <pre>test_filesink_retention.py::test_no_retention_at_remove_with_rotation[w]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_retention_at_remove_wi0')
mode = 'w'

    @pytest.mark.parametrize("mode", ["w", "x", "a", "a+"])
    def test_no_retention_at_remove_with_rotation(tmp_path, mode):
        i = logger.add(tmp_path / "file.log", retention=0, rotation="100 MB", mode=mode)
        logger.debug("1")
>       check_dir(tmp_path, size=1)

i          = None
mode       = 'w'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_retention_at_remove_wi0')

tests/test_filesink_retention.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_retention_at_remove_wi0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           assert 0 == 1
E            +  where 0 = len(set())

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_retention_at_remove_wi0')
files      = None
seen       = set()
size       = 1

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_no_retention_at_remove_with_rotationx">test_filesink_retention.py::test_no_retention_at_remove_with_rotation[x]</h3>
<details><summary> <pre>test_filesink_retention.py::test_no_retention_at_remove_with_rotation[x]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_retention_at_remove_wi1')
mode = 'x'

    @pytest.mark.parametrize("mode", ["w", "x", "a", "a+"])
    def test_no_retention_at_remove_with_rotation(tmp_path, mode):
        i = logger.add(tmp_path / "file.log", retention=0, rotation="100 MB", mode=mode)
        logger.debug("1")
>       check_dir(tmp_path, size=1)

i          = None
mode       = 'x'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_retention_at_remove_wi1')

tests/test_filesink_retention.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_retention_at_remove_wi1')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           assert 0 == 1
E            +  where 0 = len(set())

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_retention_at_remove_wi1')
files      = None
seen       = set()
size       = 1

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_no_retention_at_remove_with_rotationa">test_filesink_retention.py::test_no_retention_at_remove_with_rotation[a]</h3>
<details><summary> <pre>test_filesink_retention.py::test_no_retention_at_remove_with_rotation[a]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_retention_at_remove_wi2')
mode = 'a'

    @pytest.mark.parametrize("mode", ["w", "x", "a", "a+"])
    def test_no_retention_at_remove_with_rotation(tmp_path, mode):
        i = logger.add(tmp_path / "file.log", retention=0, rotation="100 MB", mode=mode)
        logger.debug("1")
>       check_dir(tmp_path, size=1)

i          = None
mode       = 'a'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_retention_at_remove_wi2')

tests/test_filesink_retention.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_retention_at_remove_wi2')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           assert 0 == 1
E            +  where 0 = len(set())

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_retention_at_remove_wi2')
files      = None
seen       = set()
size       = 1

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_no_retention_at_remove_with_rotationa_1">test_filesink_retention.py::test_no_retention_at_remove_with_rotation[a+]</h3>
<details><summary> <pre>test_filesink_retention.py::test_no_retention_at_remove_with_rotation[a+]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_retention_at_remove_wi3')
mode = 'a+'

    @pytest.mark.parametrize("mode", ["w", "x", "a", "a+"])
    def test_no_retention_at_remove_with_rotation(tmp_path, mode):
        i = logger.add(tmp_path / "file.log", retention=0, rotation="100 MB", mode=mode)
        logger.debug("1")
>       check_dir(tmp_path, size=1)

i          = None
mode       = 'a+'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_retention_at_remove_wi3')

tests/test_filesink_retention.py:252: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_retention_at_remove_wi3')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           assert 0 == 1
E            +  where 0 = len(set())

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_retention_at_remove_wi3')
files      = None
seen       = set()
size       = 1

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_no_renaming">test_filesink_retention.py::test_no_renaming</h3>
<details><summary> <pre>test_filesink_retention.py::test_no_renaming</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_renaming0')

    def test_no_renaming(tmp_path):
        i = logger.add(tmp_path / "test.log", format="{message}", retention=10)
        logger.debug("test")
        logger.remove(i)

>       check_dir(tmp_path, files=[("test.log", "test\n")])

i          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_renaming0')

tests/test_filesink_retention.py:262: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_renaming0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('test.log', 'test\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_renaming0')
files      = [('test.log', 'test\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_exception_during_retention_at_rotationtrue">test_filesink_retention.py::test_exception_during_retention_at_rotation[True]</h3>
<details><summary> <pre>test_filesink_retention.py::test_exception_during_retention_at_rotation[True]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087ac5e0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_retentio0')
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0885c5e0>, delay = True

    @pytest.mark.parametrize("delay", [True, False])
    def test_exception_during_retention_at_rotation(freeze_time, tmp_path, capsys, delay):
        with freeze_time("2022-02-22") as frozen:
            logger.add(
                tmp_path / "test.log",
                format="{message}",
                retention=Mock(side_effect=[Exception("Retention error"), None]),
                rotation=0,
                catch=True,
                delay=delay,
            )
            logger.debug("AAA")
            frozen.tick()
            logger.debug("BBB")

>       check_dir(
            tmp_path,
            files=[
                ("test.2022-02-22_00-00-00_000000.log", ""),
                ("test.2022-02-22_00-00-01_000000.log", ""),
                ("test.log", "BBB\n"),
            ],
        )

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0885c5e0>
delay      = True
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087ac5e0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac0885d2d0>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_retentio0')

tests/test_filesink_retention.py:280: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_retentio0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 3
E            +  where 0 = len(set())
E            +  and   3 = len([('test.2022-02-22_00-00-00_000000.log', ''), ('test.2022-02-22_00-00-01_000000.log', ''), ('test.log', 'BBB\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_retentio0')
files      = [('test.2022-02-22_00-00-00_000000.log', ''), ('test.2022-02-22_00-00-01_000000.log', ''), ('test.log', 'BBB\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_exception_during_retention_at_rotationfalse">test_filesink_retention.py::test_exception_during_retention_at_rotation[False]</h3>
<details><summary> <pre>test_filesink_retention.py::test_exception_during_retention_at_rotation[False]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087afa30>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_retentio1')
capsys = <_pytest.capture.CaptureFixture object at 0x7fac08733bb0>
delay = False

    @pytest.mark.parametrize("delay", [True, False])
    def test_exception_during_retention_at_rotation(freeze_time, tmp_path, capsys, delay):
        with freeze_time("2022-02-22") as frozen:
            logger.add(
                tmp_path / "test.log",
                format="{message}",
                retention=Mock(side_effect=[Exception("Retention error"), None]),
                rotation=0,
                catch=True,
                delay=delay,
            )
            logger.debug("AAA")
            frozen.tick()
            logger.debug("BBB")

>       check_dir(
            tmp_path,
            files=[
                ("test.2022-02-22_00-00-00_000000.log", ""),
                ("test.2022-02-22_00-00-01_000000.log", ""),
                ("test.log", "BBB\n"),
            ],
        )

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac08733bb0>
delay      = False
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087afa30>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac087314e0>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_retentio1')

tests/test_filesink_retention.py:280: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_retentio1')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 3
E            +  where 0 = len(set())
E            +  and   3 = len([('test.2022-02-22_00-00-00_000000.log', ''), ('test.2022-02-22_00-00-01_000000.log', ''), ('test.log', 'BBB\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_retentio1')
files      = [('test.2022-02-22_00-00-00_000000.log', ''), ('test.2022-02-22_00-00-01_000000.log', ''), ('test.log', 'BBB\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_retentionpytest_exception_during_retention_at_rotation_not_caughttrue">test_filesink_retention.py::test_exception_during_retention_at_rotation_not_caught[True]</h3>
<details><summary> <pre>test_filesink_retention.py::test_exception_during_retention_at_rotation_not_caught[True]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087afd00>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_retentio2')
capsys = <_pytest.capture.CaptureFixture object at 0x7fac093113c0>, delay = True

    @pytest.mark.parametrize("delay", [True, False])
    def test_exception_during_retention_at_rotation_not_caught(freeze_time, tmp_path, capsys, delay):
        with freeze_time("2022-02-22") as frozen:
            logger.add(
                tmp_path / "test.log",
                format="{message}",
                retention=Mock(side_effect=[OSError("Retention error"), None]),
                rotation=0,
                catch=False,
                delay=delay,
            )
>           with pytest.raises(OSError, match=r"Retention error"):
E           Failed: DID NOT RAISE <class 'OSError'>

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac093113c0>
delay      = True
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087afd00>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac09311300>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_retentio2')

tests/test_filesink_retention.py:306: Failed
</pre>
</details>
<h3 id="test_filesink_retentionpytest_exception_during_retention_at_rotation_not_caughtfalse">test_filesink_retention.py::test_exception_during_retention_at_rotation_not_caught[False]</h3>
<details><summary> <pre>test_filesink_retention.py::test_exception_during_retention_at_rotation_not_caught[False]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b41f0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_retentio3')
capsys = <_pytest.capture.CaptureFixture object at 0x7fac08707850>
delay = False

    @pytest.mark.parametrize("delay", [True, False])
    def test_exception_during_retention_at_rotation_not_caught(freeze_time, tmp_path, capsys, delay):
        with freeze_time("2022-02-22") as frozen:
            logger.add(
                tmp_path / "test.log",
                format="{message}",
                retention=Mock(side_effect=[OSError("Retention error"), None]),
                rotation=0,
                catch=False,
                delay=delay,
            )
>           with pytest.raises(OSError, match=r"Retention error"):
E           Failed: DID NOT RAISE <class 'OSError'>

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac08707850>
delay      = False
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b41f0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08706fb0>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_retentio3')

tests/test_filesink_retention.py:306: Failed
</pre>
</details>
<h3 id="test_filesink_retentionpytest_exception_during_retention_at_removetrue">test_filesink_retention.py::test_exception_during_retention_at_remove[True]</h3>
<details><summary> <pre>test_filesink_retention.py::test_exception_during_retention_at_remove[True]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_retentio4')
capsys = <_pytest.capture.CaptureFixture object at 0x7fac09311630>, delay = True

    @pytest.mark.parametrize("delay", [True, False])
    def test_exception_during_retention_at_remove(tmp_path, capsys, delay):
        i = logger.add(
            tmp_path / "test.log",
            format="{message}",
            retention=Mock(side_effect=[OSError("Retention error"), None]),
            catch=False,
            delay=delay,
        )
        logger.debug("AAA")

>       with pytest.raises(OSError, match=r"Retention error"):
E       Failed: DID NOT RAISE <class 'OSError'>

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac09311630>
delay      = True
i          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_retentio4')

tests/test_filesink_retention.py:335: Failed
</pre>
</details>
<h3 id="test_filesink_retentionpytest_exception_during_retention_at_removefalse">test_filesink_retention.py::test_exception_during_retention_at_remove[False]</h3>
<details><summary> <pre>test_filesink_retention.py::test_exception_during_retention_at_remove[False]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_retentio5')
capsys = <_pytest.capture.CaptureFixture object at 0x7fac088e90f0>
delay = False

    @pytest.mark.parametrize("delay", [True, False])
    def test_exception_during_retention_at_remove(tmp_path, capsys, delay):
        i = logger.add(
            tmp_path / "test.log",
            format="{message}",
            retention=Mock(side_effect=[OSError("Retention error"), None]),
            catch=False,
            delay=delay,
        )
        logger.debug("AAA")

>       with pytest.raises(OSError, match=r"Retention error"):
E       Failed: DID NOT RAISE <class 'OSError'>

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac088e90f0>
delay      = False
i          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_retentio5')

tests/test_filesink_retention.py:335: Failed
</pre>
</details>
<h3 id="test_filesink_retentionpytest_invalid_retentionretention0">test_filesink_retention.py::test_invalid_retention[retention0]</h3>
<details><summary> <pre>test_filesink_retention.py::test_invalid_retention[retention0]</pre></summary><pre>
retention = datetime.time(12, 12, 12)

    @pytest.mark.parametrize("retention", [datetime.time(12, 12, 12), os, object()])
    def test_invalid_retention(retention):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

retention  = datetime.time(12, 12, 12)

tests/test_filesink_retention.py:348: Failed
</pre>
</details>
<h3 id="test_filesink_retentionpytest_invalid_retentionos">test_filesink_retention.py::test_invalid_retention[os]</h3>
<details><summary> <pre>test_filesink_retention.py::test_invalid_retention[os]</pre></summary><pre>
retention = <module 'os' from '/usr/lib/python3.10/os.py'>

    @pytest.mark.parametrize("retention", [datetime.time(12, 12, 12), os, object()])
    def test_invalid_retention(retention):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

retention  = <module 'os' from '/usr/lib/python3.10/os.py'>

tests/test_filesink_retention.py:348: Failed
</pre>
</details>
<h3 id="test_filesink_retentionpytest_invalid_retentionretention2">test_filesink_retention.py::test_invalid_retention[retention2]</h3>
<details><summary> <pre>test_filesink_retention.py::test_invalid_retention[retention2]</pre></summary><pre>
retention = <object object at 0x7fac0bf279f0>

    @pytest.mark.parametrize("retention", [datetime.time(12, 12, 12), os, object()])
    def test_invalid_retention(retention):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

retention  = <object object at 0x7fac0bf279f0>

tests/test_filesink_retention.py:348: Failed
</pre>
</details>
<h3 id="test_filesink_retentionpytest_unkown_retentionw5">test_filesink_retention.py::test_unkown_retention[W5]</h3>
<details><summary> <pre>test_filesink_retention.py::test_unkown_retention[W5]</pre></summary><pre>
retention = 'W5'

    @pytest.mark.parametrize(
        "retention",
        ["W5", "monday at 14:00", "sunday", "nope", "5 MB", "3 hours 2 dayz", "d", "H", "__dict__"],
    )
    def test_unkown_retention(retention):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

retention  = 'W5'

tests/test_filesink_retention.py:357: Failed
</pre>
</details>
<h3 id="test_filesink_retentionpytest_unkown_retentionmonday-at-1400">test_filesink_retention.py::test_unkown_retention[monday at 14:00]</h3>
<details><summary> <pre>test_filesink_retention.py::test_unkown_retention[monday at 14:00]</pre></summary><pre>
retention = 'monday at 14:00'

    @pytest.mark.parametrize(
        "retention",
        ["W5", "monday at 14:00", "sunday", "nope", "5 MB", "3 hours 2 dayz", "d", "H", "__dict__"],
    )
    def test_unkown_retention(retention):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

retention  = 'monday at 14:00'

tests/test_filesink_retention.py:357: Failed
</pre>
</details>
<h3 id="test_filesink_retentionpytest_unkown_retentionsunday">test_filesink_retention.py::test_unkown_retention[sunday]</h3>
<details><summary> <pre>test_filesink_retention.py::test_unkown_retention[sunday]</pre></summary><pre>
retention = 'sunday'

    @pytest.mark.parametrize(
        "retention",
        ["W5", "monday at 14:00", "sunday", "nope", "5 MB", "3 hours 2 dayz", "d", "H", "__dict__"],
    )
    def test_unkown_retention(retention):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

retention  = 'sunday'

tests/test_filesink_retention.py:357: Failed
</pre>
</details>
<h3 id="test_filesink_retentionpytest_unkown_retentionnope">test_filesink_retention.py::test_unkown_retention[nope]</h3>
<details><summary> <pre>test_filesink_retention.py::test_unkown_retention[nope]</pre></summary><pre>
retention = 'nope'

    @pytest.mark.parametrize(
        "retention",
        ["W5", "monday at 14:00", "sunday", "nope", "5 MB", "3 hours 2 dayz", "d", "H", "__dict__"],
    )
    def test_unkown_retention(retention):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

retention  = 'nope'

tests/test_filesink_retention.py:357: Failed
</pre>
</details>
<h3 id="test_filesink_retentionpytest_unkown_retention5-mb">test_filesink_retention.py::test_unkown_retention[5 MB]</h3>
<details><summary> <pre>test_filesink_retention.py::test_unkown_retention[5 MB]</pre></summary><pre>
retention = '5 MB'

    @pytest.mark.parametrize(
        "retention",
        ["W5", "monday at 14:00", "sunday", "nope", "5 MB", "3 hours 2 dayz", "d", "H", "__dict__"],
    )
    def test_unkown_retention(retention):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

retention  = '5 MB'

tests/test_filesink_retention.py:357: Failed
</pre>
</details>
<h3 id="test_filesink_retentionpytest_unkown_retention3-hours-2-dayz">test_filesink_retention.py::test_unkown_retention[3 hours 2 dayz]</h3>
<details><summary> <pre>test_filesink_retention.py::test_unkown_retention[3 hours 2 dayz]</pre></summary><pre>
retention = '3 hours 2 dayz'

    @pytest.mark.parametrize(
        "retention",
        ["W5", "monday at 14:00", "sunday", "nope", "5 MB", "3 hours 2 dayz", "d", "H", "__dict__"],
    )
    def test_unkown_retention(retention):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

retention  = '3 hours 2 dayz'

tests/test_filesink_retention.py:357: Failed
</pre>
</details>
<h3 id="test_filesink_retentionpytest_unkown_retentiond">test_filesink_retention.py::test_unkown_retention[d]</h3>
<details><summary> <pre>test_filesink_retention.py::test_unkown_retention[d]</pre></summary><pre>
retention = 'd'

    @pytest.mark.parametrize(
        "retention",
        ["W5", "monday at 14:00", "sunday", "nope", "5 MB", "3 hours 2 dayz", "d", "H", "__dict__"],
    )
    def test_unkown_retention(retention):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

retention  = 'd'

tests/test_filesink_retention.py:357: Failed
</pre>
</details>
<h3 id="test_filesink_retentionpytest_unkown_retentionh">test_filesink_retention.py::test_unkown_retention[H]</h3>
<details><summary> <pre>test_filesink_retention.py::test_unkown_retention[H]</pre></summary><pre>
retention = 'H'

    @pytest.mark.parametrize(
        "retention",
        ["W5", "monday at 14:00", "sunday", "nope", "5 MB", "3 hours 2 dayz", "d", "H", "__dict__"],
    )
    def test_unkown_retention(retention):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

retention  = 'H'

tests/test_filesink_retention.py:357: Failed
</pre>
</details>
<h3 id="test_filesink_retentionpytest_unkown_retentiondict">test_filesink_retention.py::test_unkown_retention[<strong>dict</strong>]</h3>
<details><summary> <pre>test_filesink_retention.py::test_unkown_retention[__dict__]</pre></summary><pre>
retention = '__dict__'

    @pytest.mark.parametrize(
        "retention",
        ["W5", "monday at 14:00", "sunday", "nope", "5 MB", "3 hours 2 dayz", "d", "H", "__dict__"],
    )
    def test_unkown_retention(retention):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

retention  = '__dict__'

tests/test_filesink_retention.py:357: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_renaming">test_filesink_rotation.py::test_renaming</h3>
<details><summary> <pre>test_filesink_rotation.py::test_renaming</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087add80>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_renaming0')

    def test_renaming(freeze_time, tmp_path):
        with freeze_time("2020-01-01") as frozen:
            logger.add(tmp_path / "file.log", rotation=0, format="{message}")

            frozen.tick()
            logger.debug("a")

>           check_dir(
                tmp_path,
                files=[
                    ("file.2020-01-01_00-00-00_000000.log", ""),
                    ("file.log", "a\n"),
                ],
            )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087add80>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08773190>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_renaming0')

tests/test_filesink_rotation.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_renaming0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('file.2020-01-01_00-00-00_000000.log', ''), ('file.log', 'a\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_renaming0')
files      = [('file.2020-01-01_00-00-00_000000.log', ''), ('file.log', 'a\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_no_renaming">test_filesink_rotation.py::test_no_renaming</h3>
<details><summary> <pre>test_filesink_rotation.py::test_no_renaming</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b5870>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_renaming1')

    def test_no_renaming(freeze_time, tmp_path):
        with freeze_time("2018-01-01 00:00:00") as frozen:
            logger.add(tmp_path / "file_{time}.log", rotation=0, format="{message}")

            frozen.move_to("2019-01-01 00:00:00")
            logger.debug("a")
>           check_dir(
                tmp_path,
                files=[
                    ("file_2018-01-01_00-00-00_000000.log", ""),
                    ("file_2019-01-01_00-00-00_000000.log", "a\n"),
                ],
            )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b5870>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac09301a50>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_renaming1')

tests/test_filesink_rotation.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_renaming1')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('file_2018-01-01_00-00-00_000000.log', ''), ('file_2019-01-01_00-00-00_000000.log', 'a\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_renaming1')
files      = [('file_2018-01-01_00-00-00_000000.log', ''), ('file_2019-01-01_00-00-00_000000.log', 'a\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_size_rotation8">test_filesink_rotation.py::test_size_rotation[8]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_size_rotation[8]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b5c60>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_8_0')
size = 8

    @pytest.mark.parametrize("size", [8, 8.0, 7.99, "8 B", "8e-6MB", "0.008 kiB", "64b"])
    def test_size_rotation(freeze_time, tmp_path, size):
        with freeze_time("2018-01-01 00:00:00") as frozen:
            i = logger.add(tmp_path / "test_{time}.log", format="{message}", rotation=size, mode="w")

            frozen.tick()
            logger.debug("abcde")

            frozen.tick()
            logger.debug("fghij")

            frozen.tick()
            logger.debug("klmno")

            frozen.tick()
            logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-01-01_00-00-00_000000.log", "abcde\n"),
                ("test_2018-01-01_00-00-02_000000.log", "fghij\n"),
                ("test_2018-01-01_00-00-03_000000.log", "klmno\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b5c60>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08383460>
i          = None
size       = 8
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_8_0')

tests/test_filesink_rotation.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_8_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 3
E            +  where 0 = len(set())
E            +  and   3 = len([('test_2018-01-01_00-00-00_000000.log', 'abcde\n'), ('test_2018-01-01_00-00-02_000000.log', 'fghij\n'), ('test_2018-01-01_00-00-03_000000.log', 'klmno\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_8_0')
files      = [('test_2018-01-01_00-00-00_000000.log', 'abcde\n'), ('test_2018-01-01_00-00-02_000000.log', 'fghij\n'), ('test_2018-01-01_00-00-03_000000.log', 'klmno\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_size_rotation80">test_filesink_rotation.py::test_size_rotation[8.0]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_size_rotation[8.0]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6050>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_8_0_0')
size = 8.0

    @pytest.mark.parametrize("size", [8, 8.0, 7.99, "8 B", "8e-6MB", "0.008 kiB", "64b"])
    def test_size_rotation(freeze_time, tmp_path, size):
        with freeze_time("2018-01-01 00:00:00") as frozen:
            i = logger.add(tmp_path / "test_{time}.log", format="{message}", rotation=size, mode="w")

            frozen.tick()
            logger.debug("abcde")

            frozen.tick()
            logger.debug("fghij")

            frozen.tick()
            logger.debug("klmno")

            frozen.tick()
            logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-01-01_00-00-00_000000.log", "abcde\n"),
                ("test_2018-01-01_00-00-02_000000.log", "fghij\n"),
                ("test_2018-01-01_00-00-03_000000.log", "klmno\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6050>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac093037c0>
i          = None
size       = 8.0
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_8_0_0')

tests/test_filesink_rotation.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_8_0_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 3
E            +  where 0 = len(set())
E            +  and   3 = len([('test_2018-01-01_00-00-00_000000.log', 'abcde\n'), ('test_2018-01-01_00-00-02_000000.log', 'fghij\n'), ('test_2018-01-01_00-00-03_000000.log', 'klmno\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_8_0_0')
files      = [('test_2018-01-01_00-00-00_000000.log', 'abcde\n'), ('test_2018-01-01_00-00-02_000000.log', 'fghij\n'), ('test_2018-01-01_00-00-03_000000.log', 'klmno\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_size_rotation799">test_filesink_rotation.py::test_size_rotation[7.99]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_size_rotation[7.99]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6440>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_7_99_0')
size = 7.99

    @pytest.mark.parametrize("size", [8, 8.0, 7.99, "8 B", "8e-6MB", "0.008 kiB", "64b"])
    def test_size_rotation(freeze_time, tmp_path, size):
        with freeze_time("2018-01-01 00:00:00") as frozen:
            i = logger.add(tmp_path / "test_{time}.log", format="{message}", rotation=size, mode="w")

            frozen.tick()
            logger.debug("abcde")

            frozen.tick()
            logger.debug("fghij")

            frozen.tick()
            logger.debug("klmno")

            frozen.tick()
            logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-01-01_00-00-00_000000.log", "abcde\n"),
                ("test_2018-01-01_00-00-02_000000.log", "fghij\n"),
                ("test_2018-01-01_00-00-03_000000.log", "klmno\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6440>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08380850>
i          = None
size       = 7.99
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_7_99_0')

tests/test_filesink_rotation.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_7_99_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 3
E            +  where 0 = len(set())
E            +  and   3 = len([('test_2018-01-01_00-00-00_000000.log', 'abcde\n'), ('test_2018-01-01_00-00-02_000000.log', 'fghij\n'), ('test_2018-01-01_00-00-03_000000.log', 'klmno\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_7_99_0')
files      = [('test_2018-01-01_00-00-00_000000.log', 'abcde\n'), ('test_2018-01-01_00-00-02_000000.log', 'fghij\n'), ('test_2018-01-01_00-00-03_000000.log', 'klmno\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_size_rotation8-b">test_filesink_rotation.py::test_size_rotation[8 B]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_size_rotation[8 B]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6950>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_8_B_0')
size = '8 B'

    @pytest.mark.parametrize("size", [8, 8.0, 7.99, "8 B", "8e-6MB", "0.008 kiB", "64b"])
    def test_size_rotation(freeze_time, tmp_path, size):
        with freeze_time("2018-01-01 00:00:00") as frozen:
            i = logger.add(tmp_path / "test_{time}.log", format="{message}", rotation=size, mode="w")

            frozen.tick()
            logger.debug("abcde")

            frozen.tick()
            logger.debug("fghij")

            frozen.tick()
            logger.debug("klmno")

            frozen.tick()
            logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-01-01_00-00-00_000000.log", "abcde\n"),
                ("test_2018-01-01_00-00-02_000000.log", "fghij\n"),
                ("test_2018-01-01_00-00-03_000000.log", "klmno\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6950>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac09323430>
i          = None
size       = '8 B'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_8_B_0')

tests/test_filesink_rotation.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_8_B_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 3
E            +  where 0 = len(set())
E            +  and   3 = len([('test_2018-01-01_00-00-00_000000.log', 'abcde\n'), ('test_2018-01-01_00-00-02_000000.log', 'fghij\n'), ('test_2018-01-01_00-00-03_000000.log', 'klmno\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_8_B_0')
files      = [('test_2018-01-01_00-00-00_000000.log', 'abcde\n'), ('test_2018-01-01_00-00-02_000000.log', 'fghij\n'), ('test_2018-01-01_00-00-03_000000.log', 'klmno\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_size_rotation8e-6mb">test_filesink_rotation.py::test_size_rotation[8e-6MB]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_size_rotation[8e-6MB]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6d40>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_8e_6MB_0')
size = '8e-6MB'

    @pytest.mark.parametrize("size", [8, 8.0, 7.99, "8 B", "8e-6MB", "0.008 kiB", "64b"])
    def test_size_rotation(freeze_time, tmp_path, size):
        with freeze_time("2018-01-01 00:00:00") as frozen:
            i = logger.add(tmp_path / "test_{time}.log", format="{message}", rotation=size, mode="w")

            frozen.tick()
            logger.debug("abcde")

            frozen.tick()
            logger.debug("fghij")

            frozen.tick()
            logger.debug("klmno")

            frozen.tick()
            logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-01-01_00-00-00_000000.log", "abcde\n"),
                ("test_2018-01-01_00-00-02_000000.log", "fghij\n"),
                ("test_2018-01-01_00-00-03_000000.log", "klmno\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6d40>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08381db0>
i          = None
size       = '8e-6MB'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_8e_6MB_0')

tests/test_filesink_rotation.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_8e_6MB_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 3
E            +  where 0 = len(set())
E            +  and   3 = len([('test_2018-01-01_00-00-00_000000.log', 'abcde\n'), ('test_2018-01-01_00-00-02_000000.log', 'fghij\n'), ('test_2018-01-01_00-00-03_000000.log', 'klmno\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_8e_6MB_0')
files      = [('test_2018-01-01_00-00-00_000000.log', 'abcde\n'), ('test_2018-01-01_00-00-02_000000.log', 'fghij\n'), ('test_2018-01-01_00-00-03_000000.log', 'klmno\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_size_rotation0008-kib">test_filesink_rotation.py::test_size_rotation[0.008 kiB]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_size_rotation[0.008 kiB]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087aea70>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_0_008_kiB_0')
size = '0.008 kiB'

    @pytest.mark.parametrize("size", [8, 8.0, 7.99, "8 B", "8e-6MB", "0.008 kiB", "64b"])
    def test_size_rotation(freeze_time, tmp_path, size):
        with freeze_time("2018-01-01 00:00:00") as frozen:
            i = logger.add(tmp_path / "test_{time}.log", format="{message}", rotation=size, mode="w")

            frozen.tick()
            logger.debug("abcde")

            frozen.tick()
            logger.debug("fghij")

            frozen.tick()
            logger.debug("klmno")

            frozen.tick()
            logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-01-01_00-00-00_000000.log", "abcde\n"),
                ("test_2018-01-01_00-00-02_000000.log", "fghij\n"),
                ("test_2018-01-01_00-00-03_000000.log", "klmno\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087aea70>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac088f0700>
i          = None
size       = '0.008 kiB'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_0_008_kiB_0')

tests/test_filesink_rotation.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_0_008_kiB_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 3
E            +  where 0 = len(set())
E            +  and   3 = len([('test_2018-01-01_00-00-00_000000.log', 'abcde\n'), ('test_2018-01-01_00-00-02_000000.log', 'fghij\n'), ('test_2018-01-01_00-00-03_000000.log', 'klmno\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_0_008_kiB_0')
files      = [('test_2018-01-01_00-00-00_000000.log', 'abcde\n'), ('test_2018-01-01_00-00-02_000000.log', 'fghij\n'), ('test_2018-01-01_00-00-03_000000.log', 'klmno\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_size_rotation64b">test_filesink_rotation.py::test_size_rotation[64b]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_size_rotation[64b]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6f80>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_64b_0')
size = '64b'

    @pytest.mark.parametrize("size", [8, 8.0, 7.99, "8 B", "8e-6MB", "0.008 kiB", "64b"])
    def test_size_rotation(freeze_time, tmp_path, size):
        with freeze_time("2018-01-01 00:00:00") as frozen:
            i = logger.add(tmp_path / "test_{time}.log", format="{message}", rotation=size, mode="w")

            frozen.tick()
            logger.debug("abcde")

            frozen.tick()
            logger.debug("fghij")

            frozen.tick()
            logger.debug("klmno")

            frozen.tick()
            logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-01-01_00-00-00_000000.log", "abcde\n"),
                ("test_2018-01-01_00-00-02_000000.log", "fghij\n"),
                ("test_2018-01-01_00-00-03_000000.log", "klmno\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6f80>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08717250>
i          = None
size       = '64b'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_64b_0')

tests/test_filesink_rotation.py:97: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_64b_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 3
E            +  where 0 = len(set())
E            +  and   3 = len([('test_2018-01-01_00-00-00_000000.log', 'abcde\n'), ('test_2018-01-01_00-00-02_000000.log', 'fghij\n'), ('test_2018-01-01_00-00-03_000000.log', 'klmno\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_size_rotation_64b_0')
files      = [('test_2018-01-01_00-00-00_000000.log', 'abcde\n'), ('test_2018-01-01_00-00-02_000000.log', 'fghij\n'), ('test_2018-01-01_00-00-03_000000.log', 'klmno\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation13-hours0">test_filesink_rotation.py::test_time_rotation[13-hours0]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[13-hours0]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7400>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_13_hours0_0')
when = '13', hours = [0, 1, 20, 4, 24]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7400>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac088e5810>
h          = 24
hours      = [0, 1, 20, 4, 24]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_13_hours0_0')
when       = '13'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation1300-hours1">test_filesink_rotation.py::test_time_rotation[13:00-hours1]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[13:00-hours1]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7760>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_13_00_hours0')
when = '13:00', hours = [0.2, 0.9, 23, 1, 48]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7760>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac083800d0>
h          = 48
hours      = [0.2, 0.9, 23, 1, 48]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_13_00_hours0')
when       = '13:00'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation130000-hours2">test_filesink_rotation.py::test_time_rotation[13:00:00-hours2]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[13:00:00-hours2]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7ac0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_13_00_00_ho0')
when = '13:00:00', hours = [0.5, 1.5, 10, 15, 72]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7ac0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08313f40>
h          = 72
hours      = [0.5, 1.5, 10, 15, 72]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_13_00_00_ho0')
when       = '13:00:00'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation130000123456-hours3">test_filesink_rotation.py::test_time_rotation[13:00:00.123456-hours3]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[13:00:00.123456-hours3]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7e20>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_13_00_00_120')
when = '13:00:00.123456', hours = [0.9, 2, 10, 15, 256]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7e20>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac0885d300>
h          = 256
hours      = [0.9, 2, 10, 15, 256]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_13_00_00_120')
when       = '13:00:00.123456'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation1100-hours4">test_filesink_rotation.py::test_time_rotation[11:00-hours4]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[11:00-hours4]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6830>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_11_00_hours0')
when = '11:00', hours = [22.9, 0.2, 23, 1, 24]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6830>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac088ea740>
h          = 24
hours      = [22.9, 0.2, 23, 1, 24]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_11_00_hours0')
when       = '11:00'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotationw0-hours5">test_filesink_rotation.py::test_time_rotation[w0-hours5]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[w0-hours5]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6050>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_w0_hours5_0')
when = 'w0', hours = [11, 1, 167, 1, 168]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6050>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac083ca440>
h          = 168
hours      = [11, 1, 167, 1, 168]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_w0_hours5_0')
when       = 'w0'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotationw0-at-0000-hours6">test_filesink_rotation.py::test_time_rotation[W0 at 00:00-hours6]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[W0 at 00:00-hours6]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087afb50>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_W0_at_00_000')
when = 'W0 at 00:00', hours = [10, 163, 0.1, 720, 336]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac087afb50>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac087ee590>
h          = 336
hours      = [10, 163, 0.1, 720, 336]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_W0_at_00_000')
when       = 'W0 at 00:00'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotationw6-hours7">test_filesink_rotation.py::test_time_rotation[W6-hours7]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[W6-hours7]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b5c60>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_W6_hours7_0')
when = 'W6', hours = [24, 672, 120, 24, 8736]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b5c60>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08381f30>
h          = 8736
hours      = [24, 672, 120, 24, 8736]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_W6_hours7_0')
when       = 'W6'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotationsaturday-hours8">test_filesink_rotation.py::test_time_rotation[saturday-hours8]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[saturday-hours8]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b5750>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_saturday_ho0')
when = 'saturday', hours = [25, 300, 0, 300, 192]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b5750>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08706740>
h          = 192
hours      = [25, 300, 0, 300, 192]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_saturday_ho0')
when       = 'saturday'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotationw6-at-00-hours9">test_filesink_rotation.py::test_time_rotation[w6 at 00-hours9]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[w6 at 00-hours9]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7c70>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_w6_at_00_ho0')
when = 'w6 at 00', hours = [8, 168, 144, 24, 192]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7c70>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08731390>
h          = 192
hours      = [8, 168, 144, 24, 192]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_w6_at_00_ho0')
when       = 'w6 at 00'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation-w6-at-13-hours10">test_filesink_rotation.py::test_time_rotation[ W6 at 13 -hours10]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[ W6 at 13 -hours10]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7d90>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation__W6_at_13__0')
when = ' W6 at 13 ', hours = [0.5, 1, 144, 144, 8760]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7d90>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac088e6740>
h          = 8760
hours      = [0.5, 1, 144, 144, 8760]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation__W6_at_13__0')
when       = ' W6 at 13 '

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotationw2-at-110000-am-hours11">test_filesink_rotation.py::test_time_rotation[w2  at  11:00:00 AM-hours11]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[w2  at  11:00:00 AM-hours11]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7760>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_w2__at__11_0')
when = 'w2  at  11:00:00 AM', hours = [70, 3, 144, 24, 8784]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7760>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac087eed70>
h          = 8784
hours      = [70, 3, 144, 24, 8784]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_w2__at__11_0')
when       = 'w2  at  11:00:00 AM'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotationmonday-at-110030123-hours12">test_filesink_rotation.py::test_time_rotation[MoNdAy at 11:00:30.123-hours12]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[MoNdAy at 11:00:30.123-hours12]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7250>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_MoNdAy_at_10')
when = 'MoNdAy at 11:00:30.123', hours = [22, 24, 24, 168, 168]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7250>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac083cb490>
h          = 168
hours      = [22, 24, 24, 168, 168]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_MoNdAy_at_10')
when       = 'MoNdAy at 11:00:30.123'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotationsunday-hours13">test_filesink_rotation.py::test_time_rotation[sunday-hours13]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[sunday-hours13]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6cb0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_sunday_hour0')
when = 'sunday', hours = [0.1, 158, 24, 144, 168]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6cb0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac087073d0>
h          = 168
hours      = [0.1, 158, 24, 144, 168]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_sunday_hour0')
when       = 'sunday'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotationsunday-at-1100-hours14">test_filesink_rotation.py::test_time_rotation[SUNDAY at 11:00-hours14]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[SUNDAY at 11:00-hours14]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6f80>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_SUNDAY_at_10')
when = 'SUNDAY at 11:00', hours = [1, 168, 2, 168, 360]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6f80>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08789f90>
h          = 360
hours      = [1, 168, 2, 168, 360]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_SUNDAY_at_10')
when       = 'SUNDAY at 11:00'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotationsunday-at-1000-pm-hours15">test_filesink_rotation.py::test_time_rotation[sunDAY at 1:0:0.0 pm-hours15]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[sunDAY at 1:0:0.0 pm-hours15]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7520>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_sunDAY_at_11')
when = 'sunDAY at 1:0:0.0 pm', hours = [0.9, 0.2, 166, 3, 192]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7520>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08704310>
h          = 192
hours      = [0.9, 0.2, 166, 3, 192]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_sunDAY_at_11')
when       = 'sunDAY at 1:0:0.0 pm'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotationwhen16-hours16">test_filesink_rotation.py::test_time_rotation[when16-hours16]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[when16-hours16]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b56c0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when16_hour0')
when = datetime.time(15, 0), hours = [2, 3, 19, 5, 24]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b56c0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac09300b50>
h          = 24
hours      = [2, 3, 19, 5, 24]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when16_hour0')
when       = datetime.time(15, 0)

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotationwhen17-hours17">test_filesink_rotation.py::test_time_rotation[when17-hours17]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[when17-hours17]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7490>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when17_hour0')
when = datetime.time(18, 30, 11, 123), hours = [1, 5.51, 20, 24, 40]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7490>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08731c00>
h          = 40
hours      = [1, 5.51, 20, 24, 40]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when17_hour0')
when       = datetime.time(18, 30, 11, 123)

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation2-h-hours18">test_filesink_rotation.py::test_time_rotation[2 h-hours18]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[2 h-hours18]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6320>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_2_h_hours180')
when = '2 h', hours = [1, 2, 0.9, 0.5, 10]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6320>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac093238b0>
h          = 10
hours      = [1, 2, 0.9, 0.5, 10]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_2_h_hours180')
when       = '2 h'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation1-hour-hours19">test_filesink_rotation.py::test_time_rotation[1 hour-hours19]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[1 hour-hours19]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b5c60>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_1_hour_hour0')
when = '1 hour', hours = [0.5, 1, 0.1, 100, 1000]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b5c60>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac0830bf70>
h          = 1000
hours      = [0.5, 1, 0.1, 100, 1000]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_1_hour_hour0')
when       = '1 hour'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation7-days-hours20">test_filesink_rotation.py::test_time_rotation[7 days-hours20]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[7 days-hours20]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7b50>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_7_days_hour0')
when = '7 days', hours = [167, 1, 48, 240, 8760]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7b50>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac087739d0>
h          = 8760
hours      = [167, 1, 48, 240, 8760]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_7_days_hour0')
when       = '7 days'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation1h-30-minutes-hours21">test_filesink_rotation.py::test_time_rotation[1h 30 minutes-hours21]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[1h 30 minutes-hours21]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7f40>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_1h_30_minut0')
when = '1h 30 minutes', hours = [1.4, 0.2, 1, 2, 10]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7f40>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08394ca0>
h          = 10
hours      = [1.4, 0.2, 1, 2, 10]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_1h_30_minut0')
when       = '1h 30 minutes'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation1-w-2d-hours22">test_filesink_rotation.py::test_time_rotation[1 w, 2D-hours22]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[1 w, 2D-hours22]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b5e10>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_1_w__2D_hou0')
when = '1 w, 2D', hours = [192, 48, 24, 216, 216]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b5e10>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac087e21a0>
h          = 216
hours      = [192, 48, 24, 216, 216]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_1_w__2D_hou0')
when       = '1 w, 2D'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation15d-hours23">test_filesink_rotation.py::test_time_rotation[1.5d-hours23]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[1.5d-hours23]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6050>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_1_5d_hours20')
when = '1.5d', hours = [30, 10, 0.9, 48, 35]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6050>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac083818d0>
h          = 35
hours      = [30, 10, 0.9, 48, 35]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_1_5d_hours20')
when       = '1.5d'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation1222-hours-344s-hours24">test_filesink_rotation.py::test_time_rotation[1.222 hours, 3.44s-hours24]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[1.222 hours, 3.44s-hours24]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6320>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_1_222_hours0')
when = '1.222 hours, 3.44s', hours = [1.222, 0.1, 1, 1.2, 2]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6320>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08716050>
h          = 2
hours      = [1.222, 0.1, 1, 1.2, 2]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_1_222_hours0')
when       = '1.222 hours, 3.44s'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotationwhen25-hours25">test_filesink_rotation.py::test_time_rotation[when25-hours25]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[when25-hours25]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b79a0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when25_hour0')
when = datetime.timedelta(seconds=3600), hours = [0.9, 0.2, 0.7, 0.5, 3]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b79a0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08312da0>
h          = 3
hours      = [0.9, 0.2, 0.7, 0.5, 3]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when25_hour0')
when       = datetime.timedelta(seconds=3600)

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotationwhen26-hours26">test_filesink_rotation.py::test_time_rotation[when26-hours26]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[when26-hours26]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b69e0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when26_hour0')
when = datetime.timedelta(seconds=1800), hours = [0.48, 0.04, 0.07, 0.44, 0.5]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b69e0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08704f40>
h          = 0.5
hours      = [0.48, 0.04, 0.07, 0.44, 0.5]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when26_hour0')
when       = datetime.timedelta(seconds=1800)

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotationhourly-hours27">test_filesink_rotation.py::test_time_rotation[hourly-hours27]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[hourly-hours27]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6b00>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_hourly_hour0')
when = 'hourly', hours = [0.9, 0.2, 0.8, 3, 1]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6b00>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac083fcd30>
h          = 1
hours      = [0.9, 0.2, 0.8, 3, 1]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_hourly_hour0')
when       = 'hourly'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotationdaily-hours28">test_filesink_rotation.py::test_time_rotation[daily-hours28]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[daily-hours28]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7d00>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_daily_hours0')
when = 'daily', hours = [11, 1, 23, 1, 24]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7d00>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac083c8bb0>
h          = 24
hours      = [11, 1, 23, 1, 24]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_daily_hours0')
when       = 'daily'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotationweekly-hours29">test_filesink_rotation.py::test_time_rotation[WEEKLY-hours29]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[WEEKLY-hours29]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083843a0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_WEEKLY_hour0')
when = 'WEEKLY', hours = [11, 2, 144, 24, 168]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083843a0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac0876ece0>
h          = 168
hours      = [11, 2, 144, 24, 168]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_WEEKLY_hour0')
when       = 'WEEKLY'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotationmonthly-hours30">test_filesink_rotation.py::test_time_rotation[mOnthLY-hours30]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[mOnthLY-hours30]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08384790>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_mOnthLY_hou0')
when = 'mOnthLY', hours = [0, 312, 696, 1440, 840]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08384790>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac087e2b30>
h          = 840
hours      = [0, 312, 696, 1440, 840]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_mOnthLY_hou0')
when       = 'mOnthLY'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotationmonthly-hours31">test_filesink_rotation.py::test_time_rotation[monthly-hours31]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[monthly-hours31]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6cb0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_monthly_hou1')
when = 'monthly', hours = [240, 4320, 24, 168, 744]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6cb0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac088eb430>
h          = 744
hours      = [240, 4320, 24, 168, 744]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_monthly_hou1')
when       = 'monthly'

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotationyearly-hours32">test_filesink_rotation.py::test_time_rotation[Yearly -hours32]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation[Yearly -hours32]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b75b0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_Yearly__hou0')
when = 'Yearly ', hours = [100, 5040, 7200, 2400, 9600]

    @pytest.mark.parametrize(
        "when, hours",
        [
            # hours = [
            #   Should not trigger, should trigger, should not trigger, should trigger, should trigger
            # ]
            ("13", [0, 1, 20, 4, 24]),
            ("13:00", [0.2, 0.9, 23, 1, 48]),
            ("13:00:00", [0.5, 1.5, 10, 15, 72]),
            ("13:00:00.123456", [0.9, 2, 10, 15, 256]),
            ("11:00", [22.9, 0.2, 23, 1, 24]),
            ("w0", [11, 1, 24 * 7 - 1, 1, 24 * 7]),
            ("W0 at 00:00", [10, 24 * 7 - 5, 0.1, 24 * 30, 24 * 14]),
            ("W6", [24, 24 * 28, 24 * 5, 24, 364 * 24]),
            ("saturday", [25, 25 * 12, 0, 25 * 12, 24 * 8]),
            ("w6 at 00", [8, 24 * 7, 24 * 6, 24, 24 * 8]),
            (" W6 at 13 ", [0.5, 1, 24 * 6, 24 * 6, 365 * 24]),
            ("w2  at  11:00:00 AM", [48 + 22, 3, 24 * 6, 24, 366 * 24]),
            ("MoNdAy at 11:00:30.123", [22, 24, 24, 24 * 7, 24 * 7]),
            ("sunday", [0.1, 24 * 7 - 10, 24, 24 * 6, 24 * 7]),
            ("SUNDAY at 11:00", [1, 24 * 7, 2, 24 * 7, 30 * 12]),
            ("sunDAY at 1:0:0.0 pm", [0.9, 0.2, 24 * 7 - 2, 3, 24 * 8]),
            (datetime.time(15), [2, 3, 19, 5, 24]),
            (datetime.time(18, 30, 11, 123), [1, 5.51, 20, 24, 40]),
            ("2 h", [1, 2, 0.9, 0.5, 10]),
            ("1 hour", [0.5, 1, 0.1, 100, 1000]),
            ("7 days", [24 * 7 - 1, 1, 48, 24 * 10, 24 * 365]),
            ("1h 30 minutes", [1.4, 0.2, 1, 2, 10]),
            ("1 w, 2D", [24 * 8, 24 * 2, 24, 24 * 9, 24 * 9]),
            ("1.5d", [30, 10, 0.9, 48, 35]),
            ("1.222 hours, 3.44s", [1.222, 0.1, 1, 1.2, 2]),
            (datetime.timedelta(hours=1), [0.9, 0.2, 0.7, 0.5, 3]),
            (datetime.timedelta(minutes=30), [0.48, 0.04, 0.07, 0.44, 0.5]),
            ("hourly", [0.9, 0.2, 0.8, 3, 1]),
            ("daily", [11, 1, 23, 1, 24]),
            ("WEEKLY", [11, 2, 24 * 6, 24, 24 * 7]),
            ("mOnthLY", [0, 24 * 13, 29 * 24, 60 * 24, 24 * 35]),
            ("monthly", [10 * 24, 30 * 24 * 6, 24, 24 * 7, 24 * 31]),
            ("Yearly ", [100, 24 * 7 * 30, 24 * 300, 24 * 100, 24 * 400]),
        ],
    )
    def test_time_rotation(freeze_time, tmp_path, when, hours):
        with freeze_time("2017-06-18 12:00:00") as frozen:  # Sunday
            i = logger.add(
                tmp_path / "test_{time}.log",
                format="{message}",
                rotation=when,
                mode="w",
            )

            for h, m in zip(hours, ["a", "b", "c", "d", "e"]):
                frozen.tick(delta=datetime.timedelta(hours=h))
                logger.debug(m)

            logger.remove(i)

        content = [path.read_text() for path in sorted(tmp_path.iterdir())]
>       assert content == ["a\n", "b\nc\n", "d\n", "e\n"]
E       AssertionError: assert [] == ['a\n', 'b\nc... 'd\n', 'e\n']
E         
E         Right contains 4 more items, first extra item: 'a\n'
E         Use -v to get more diff

content    = []
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b75b0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac087e32b0>
h          = 9600
hours      = [100, 5040, 7200, 2400, 9600]
i          = None
m          = 'e'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_Yearly__hou0')
when       = 'Yearly '

tests/test_filesink_rotation.py:164: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_dst">test_filesink_rotation.py::test_time_rotation_dst</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_dst</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7520>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_dst0')

    def test_time_rotation_dst(freeze_time, tmp_path):
        with freeze_time("2018-10-27 05:00:00", ("CET", 3600)):
            i = logger.add(tmp_path / "test_{time}.log", format="{message}", rotation="1 day")
            logger.debug("First")

            with freeze_time("2018-10-28 05:30:00", ("CEST", 7200)):
                logger.debug("Second")

                with freeze_time("2018-10-29 06:00:00", ("CET", 3600)):
                    logger.debug("Third")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_05-00-00_000000.log", "First\n"),
                ("test_2018-10-28_05-30-00_000000.log", "Second\n"),
                ("test_2018-10-29_06-00-00_000000.log", "Third\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7520>
i          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_dst0')

tests/test_filesink_rotation.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_dst0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 3
E            +  where 0 = len(set())
E            +  and   3 = len([('test_2018-10-27_05-00-00_000000.log', 'First\n'), ('test_2018-10-28_05-30-00_000000.log', 'Second\n'), ('test_2018-10-29_06-00-00_000000.log', 'Third\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_dst0')
files      = [('test_2018-10-27_05-00-00_000000.log', 'First\n'), ('test_2018-10-28_05-30-00_000000.log', 'Second\n'), ('test_2018-10-29_06-00-00_000000.log', 'Third\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_with_tzinfo_diff_bigger">test_filesink_rotation.py::test_time_rotation_with_tzinfo_diff_bigger</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_with_tzinfo_diff_bigger</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7760>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_with_tzinfo0')

    def test_time_rotation_with_tzinfo_diff_bigger(freeze_time, tmp_path):
        with freeze_time("2018-10-27 05:00:00", ("CET", 3600)) as frozen:
            tzinfo = datetime.timezone(datetime.timedelta(seconds=7200))
            rotation = datetime.time(7, 0, 0, tzinfo=tzinfo)

            i = logger.add(tmp_path / "test_{time}.log", format="{message}", rotation=rotation)

            frozen.tick(delta=datetime.timedelta(minutes=30))
            logger.debug("First")
            frozen.tick(delta=datetime.timedelta(hours=1))
            logger.debug("Second")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_05-00-00_000000.log", "First\n"),
                ("test_2018-10-27_06-30-00_000000.log", "Second\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7760>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac088ebbb0>
i          = None
rotation   = datetime.time(7, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=7200)))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_with_tzinfo0')
tzinfo     = datetime.timezone(datetime.timedelta(seconds=7200))

tests/test_filesink_rotation.py:204: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_with_tzinfo0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_05-00-00_000000.log', 'First\n'), ('test_2018-10-27_06-30-00_000000.log', 'Second\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_with_tzinfo0')
files      = [('test_2018-10-27_05-00-00_000000.log', 'First\n'), ('test_2018-10-27_06-30-00_000000.log', 'Second\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_with_tzinfo_diff_lower">test_filesink_rotation.py::test_time_rotation_with_tzinfo_diff_lower</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_with_tzinfo_diff_lower</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7f40>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_with_tzinfo1')

    def test_time_rotation_with_tzinfo_diff_lower(freeze_time, tmp_path):
        with freeze_time("2018-10-27 06:00:00", ("CEST", 7200)) as frozen:
            tzinfo = datetime.timezone(datetime.timedelta(seconds=3600))
            rotation = datetime.time(6, 0, 0, tzinfo=tzinfo)

            i = logger.add(tmp_path / "test_{time}.log", format="{message}", rotation=rotation)

            frozen.tick(delta=datetime.timedelta(minutes=30))
            logger.debug("First")
            frozen.tick(delta=datetime.timedelta(hours=1))
            logger.debug("Second")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_06-00-00_000000.log", "First\n"),
                ("test_2018-10-27_07-30-00_000000.log", "Second\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7f40>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08733700>
i          = None
rotation   = datetime.time(6, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600)))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_with_tzinfo1')
tzinfo     = datetime.timezone(datetime.timedelta(seconds=3600))

tests/test_filesink_rotation.py:227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_with_tzinfo1')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_06-00-00_000000.log', 'First\n'), ('test_2018-10-27_07-30-00_000000.log', 'Second\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_with_tzinfo1')
files      = [('test_2018-10-27_06-00-00_000000.log', 'First\n'), ('test_2018-10-27_07-30-00_000000.log', 'Second\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_with_tzinfo_utc">test_filesink_rotation.py::test_time_rotation_with_tzinfo_utc</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_with_tzinfo_utc</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08384430>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_with_tzinfo2')

    def test_time_rotation_with_tzinfo_utc(freeze_time, tmp_path):
        with freeze_time("2018-10-27 05:00:00", ("CET", 3600)) as frozen:
            rotation = datetime.time(5, 0, 0, tzinfo=datetime.timezone.utc)

            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss!UTC}.log",
                format="{message}",
                rotation=rotation,
            )

            frozen.tick(delta=datetime.timedelta(minutes=30))
            logger.debug("First")
            frozen.tick(delta=datetime.timedelta(hours=1))
            logger.debug("Second")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_04-00-00.log", "First\n"),
                ("test_2018-10-27_05-30-00.log", "Second\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08384430>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac09310730>
i          = None
rotation   = datetime.time(5, 0, tzinfo=datetime.timezone.utc)
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_with_tzinfo2')

tests/test_filesink_rotation.py:253: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_with_tzinfo2')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_04-00-00.log', 'First\n'), ('test_2018-10-27_05-30-00.log', 'Second\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_with_tzinfo2')
files      = [('test_2018-10-27_04-00-00.log', 'First\n'), ('test_2018-10-27_05-30-00.log', 'Second\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_multiple_days_at_midnight_utc">test_filesink_rotation.py::test_time_rotation_multiple_days_at_midnight_utc</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_multiple_days_at_midnight_utc</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08384d30>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_multiple_da0')

    def test_time_rotation_multiple_days_at_midnight_utc(freeze_time, tmp_path):
        with freeze_time("2018-10-27 10:00:00", ("CET", 3600)) as frozen:
            rotation = datetime.time(0, 0, 0, tzinfo=datetime.timezone.utc)

            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD!UTC}.log",
                format="{message}",
                rotation=rotation,
            )

            frozen.tick(delta=datetime.timedelta(hours=13, minutes=30))
            logger.debug("First")
            frozen.tick(delta=datetime.timedelta(hours=1))
            logger.debug("Second")
            frozen.tick(delta=datetime.timedelta(hours=1))
            logger.debug("Third")
            frozen.tick(delta=datetime.timedelta(hours=24))
            logger.debug("Fourth")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27.log", "First\nSecond\n"),
                ("test_2018-10-28.log", "Third\n"),
                ("test_2018-10-29.log", "Fourth\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08384d30>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac088f1060>
i          = None
rotation   = datetime.time(0, 0, tzinfo=datetime.timezone.utc)
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_multiple_da0')

tests/test_filesink_rotation.py:283: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_multiple_da0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 3
E            +  where 0 = len(set())
E            +  and   3 = len([('test_2018-10-27.log', 'First\nSecond\n'), ('test_2018-10-28.log', 'Third\n'), ('test_2018-10-29.log', 'Fourth\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_multiple_da0')
files      = [('test_2018-10-27.log', 'First\nSecond\n'), ('test_2018-10-28.log', 'Third\n'), ('test_2018-10-29.log', 'Fourth\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_daily_rotation_with_different_timezone-3600">test_filesink_rotation.py::test_daily_rotation_with_different_timezone[-3600]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_daily_rotation_with_different_timezone[-3600]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7f40>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_daily_rotation_with_diffe0')
offset = -3600

    @pytest.mark.parametrize("offset", [-3600, 0, 3600])
    def test_daily_rotation_with_different_timezone(freeze_time, tmp_path, offset):
        with freeze_time("2018-10-27 00:00:00", ("A", offset)) as frozen:
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD}.log",
                format="{message}",
                rotation="daily",
            )

            logger.debug("First")
            frozen.tick(delta=datetime.timedelta(hours=23, minutes=30))
            logger.debug("Second")
            frozen.tick(delta=datetime.timedelta(hours=1))
            logger.debug("Third")
            frozen.tick(delta=datetime.timedelta(hours=24))
            logger.debug("Fourth")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27.log", "First\nSecond\n"),
                ("test_2018-10-28.log", "Third\n"),
                ("test_2018-10-29.log", "Fourth\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7f40>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac0885c0a0>
i          = None
offset     = -3600
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_daily_rotation_with_diffe0')

tests/test_filesink_rotation.py:312: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_daily_rotation_with_diffe0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 3
E            +  where 0 = len(set())
E            +  and   3 = len([('test_2018-10-27.log', 'First\nSecond\n'), ('test_2018-10-28.log', 'Third\n'), ('test_2018-10-29.log', 'Fourth\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_daily_rotation_with_diffe0')
files      = [('test_2018-10-27.log', 'First\nSecond\n'), ('test_2018-10-28.log', 'Third\n'), ('test_2018-10-29.log', 'Fourth\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_daily_rotation_with_different_timezone0">test_filesink_rotation.py::test_daily_rotation_with_different_timezone[0]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_daily_rotation_with_different_timezone[0]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6830>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_daily_rotation_with_diffe1')
offset = 0

    @pytest.mark.parametrize("offset", [-3600, 0, 3600])
    def test_daily_rotation_with_different_timezone(freeze_time, tmp_path, offset):
        with freeze_time("2018-10-27 00:00:00", ("A", offset)) as frozen:
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD}.log",
                format="{message}",
                rotation="daily",
            )

            logger.debug("First")
            frozen.tick(delta=datetime.timedelta(hours=23, minutes=30))
            logger.debug("Second")
            frozen.tick(delta=datetime.timedelta(hours=1))
            logger.debug("Third")
            frozen.tick(delta=datetime.timedelta(hours=24))
            logger.debug("Fourth")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27.log", "First\nSecond\n"),
                ("test_2018-10-28.log", "Third\n"),
                ("test_2018-10-29.log", "Fourth\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6830>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac0878b550>
i          = None
offset     = 0
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_daily_rotation_with_diffe1')

tests/test_filesink_rotation.py:312: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_daily_rotation_with_diffe1')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 3
E            +  where 0 = len(set())
E            +  and   3 = len([('test_2018-10-27.log', 'First\nSecond\n'), ('test_2018-10-28.log', 'Third\n'), ('test_2018-10-29.log', 'Fourth\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_daily_rotation_with_diffe1')
files      = [('test_2018-10-27.log', 'First\nSecond\n'), ('test_2018-10-28.log', 'Third\n'), ('test_2018-10-29.log', 'Fourth\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_daily_rotation_with_different_timezone3600">test_filesink_rotation.py::test_daily_rotation_with_different_timezone[3600]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_daily_rotation_with_different_timezone[3600]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b68c0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_daily_rotation_with_diffe2')
offset = 3600

    @pytest.mark.parametrize("offset", [-3600, 0, 3600])
    def test_daily_rotation_with_different_timezone(freeze_time, tmp_path, offset):
        with freeze_time("2018-10-27 00:00:00", ("A", offset)) as frozen:
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD}.log",
                format="{message}",
                rotation="daily",
            )

            logger.debug("First")
            frozen.tick(delta=datetime.timedelta(hours=23, minutes=30))
            logger.debug("Second")
            frozen.tick(delta=datetime.timedelta(hours=1))
            logger.debug("Third")
            frozen.tick(delta=datetime.timedelta(hours=24))
            logger.debug("Fourth")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27.log", "First\nSecond\n"),
                ("test_2018-10-28.log", "Third\n"),
                ("test_2018-10-29.log", "Fourth\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b68c0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac087709a0>
i          = None
offset     = 3600
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_daily_rotation_with_diffe2')

tests/test_filesink_rotation.py:312: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_daily_rotation_with_diffe2')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 3
E            +  where 0 = len(set())
E            +  and   3 = len([('test_2018-10-27.log', 'First\nSecond\n'), ('test_2018-10-28.log', 'Third\n'), ('test_2018-10-29.log', 'Fourth\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_daily_rotation_with_diffe2')
files      = [('test_2018-10-27.log', 'First\nSecond\n'), ('test_2018-10-28.log', 'Third\n'), ('test_2018-10-29.log', 'Fourth\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_after_positive_timezone_changes_forwardrotation0">test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_forward[rotation0]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_forward[rotation0]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08385090>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit0')
rotation = datetime.time(1, 30, tzinfo=datetime.timezone.utc)

    @pytest.mark.parametrize(
        "rotation",
        [
            datetime.time(1, 30, 0, tzinfo=datetime.timezone.utc),
            datetime.time(2, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600))),
            datetime.time(0, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
            datetime.time(3, 30, 0),
            "03:30:00",
        ],
    )
    def test_time_rotation_after_positive_timezone_changes_forward(freeze_time, tmp_path, rotation):
        with freeze_time("2018-10-27 02:00:00", ("CET", 3600)):
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss!UTC}.log",
                format="{message}",
                rotation=rotation,
            )

            logger.debug("First")

            with freeze_time("2018-10-27 03:00:00", ("CET", 7200)) as frozen:
                logger.debug("Second")
                frozen.tick(delta=datetime.timedelta(hours=1))
                logger.debug("Third")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_01-00-00.log", "First\nSecond\n"),
                ("test_2018-10-27_02-00-00.log", "Third\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08385090>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac09313ca0>
i          = None
rotation   = datetime.time(1, 30, tzinfo=datetime.timezone.utc)
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit0')

tests/test_filesink_rotation.py:349: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_01-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_02-00-00.log', 'Third\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit0')
files      = [('test_2018-10-27_01-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_02-00-00.log', 'Third\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_after_positive_timezone_changes_forwardrotation1">test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_forward[rotation1]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_forward[rotation1]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083853f0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit1')
rotation = datetime.time(2, 30, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600)))

    @pytest.mark.parametrize(
        "rotation",
        [
            datetime.time(1, 30, 0, tzinfo=datetime.timezone.utc),
            datetime.time(2, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600))),
            datetime.time(0, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
            datetime.time(3, 30, 0),
            "03:30:00",
        ],
    )
    def test_time_rotation_after_positive_timezone_changes_forward(freeze_time, tmp_path, rotation):
        with freeze_time("2018-10-27 02:00:00", ("CET", 3600)):
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss!UTC}.log",
                format="{message}",
                rotation=rotation,
            )

            logger.debug("First")

            with freeze_time("2018-10-27 03:00:00", ("CET", 7200)) as frozen:
                logger.debug("Second")
                frozen.tick(delta=datetime.timedelta(hours=1))
                logger.debug("Third")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_01-00-00.log", "First\nSecond\n"),
                ("test_2018-10-27_02-00-00.log", "Third\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083853f0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08311420>
i          = None
rotation   = datetime.time(2, 30, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600)))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit1')

tests/test_filesink_rotation.py:349: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit1')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_01-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_02-00-00.log', 'Third\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit1')
files      = [('test_2018-10-27_01-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_02-00-00.log', 'Third\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_after_positive_timezone_changes_forwardrotation2">test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_forward[rotation2]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_forward[rotation2]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08385990>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit2')
rotation = datetime.time(0, 30, tzinfo=datetime.timezone(datetime.timedelta(days=-1, seconds=82800)))

    @pytest.mark.parametrize(
        "rotation",
        [
            datetime.time(1, 30, 0, tzinfo=datetime.timezone.utc),
            datetime.time(2, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600))),
            datetime.time(0, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
            datetime.time(3, 30, 0),
            "03:30:00",
        ],
    )
    def test_time_rotation_after_positive_timezone_changes_forward(freeze_time, tmp_path, rotation):
        with freeze_time("2018-10-27 02:00:00", ("CET", 3600)):
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss!UTC}.log",
                format="{message}",
                rotation=rotation,
            )

            logger.debug("First")

            with freeze_time("2018-10-27 03:00:00", ("CET", 7200)) as frozen:
                logger.debug("Second")
                frozen.tick(delta=datetime.timedelta(hours=1))
                logger.debug("Third")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_01-00-00.log", "First\nSecond\n"),
                ("test_2018-10-27_02-00-00.log", "Third\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08385990>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac087167a0>
i          = None
rotation   = datetime.time(0, 30, tzinfo=datetime.timezone(datetime.timedelta(days=-1, seconds=82800)))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit2')

tests/test_filesink_rotation.py:349: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit2')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_01-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_02-00-00.log', 'Third\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit2')
files      = [('test_2018-10-27_01-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_02-00-00.log', 'Third\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_after_positive_timezone_changes_forwardrotation3">test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_forward[rotation3]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_forward[rotation3]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08385d80>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit3')
rotation = datetime.time(3, 30)

    @pytest.mark.parametrize(
        "rotation",
        [
            datetime.time(1, 30, 0, tzinfo=datetime.timezone.utc),
            datetime.time(2, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600))),
            datetime.time(0, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
            datetime.time(3, 30, 0),
            "03:30:00",
        ],
    )
    def test_time_rotation_after_positive_timezone_changes_forward(freeze_time, tmp_path, rotation):
        with freeze_time("2018-10-27 02:00:00", ("CET", 3600)):
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss!UTC}.log",
                format="{message}",
                rotation=rotation,
            )

            logger.debug("First")

            with freeze_time("2018-10-27 03:00:00", ("CET", 7200)) as frozen:
                logger.debug("Second")
                frozen.tick(delta=datetime.timedelta(hours=1))
                logger.debug("Third")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_01-00-00.log", "First\nSecond\n"),
                ("test_2018-10-27_02-00-00.log", "Third\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08385d80>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac087ec6d0>
i          = None
rotation   = datetime.time(3, 30)
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit3')

tests/test_filesink_rotation.py:349: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit3')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_01-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_02-00-00.log', 'Third\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit3')
files      = [('test_2018-10-27_01-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_02-00-00.log', 'Third\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_after_positive_timezone_changes_forward033000">test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_forward[03:30:00]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_forward[03:30:00]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08386170>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit4')
rotation = '03:30:00'

    @pytest.mark.parametrize(
        "rotation",
        [
            datetime.time(1, 30, 0, tzinfo=datetime.timezone.utc),
            datetime.time(2, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600))),
            datetime.time(0, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
            datetime.time(3, 30, 0),
            "03:30:00",
        ],
    )
    def test_time_rotation_after_positive_timezone_changes_forward(freeze_time, tmp_path, rotation):
        with freeze_time("2018-10-27 02:00:00", ("CET", 3600)):
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss!UTC}.log",
                format="{message}",
                rotation=rotation,
            )

            logger.debug("First")

            with freeze_time("2018-10-27 03:00:00", ("CET", 7200)) as frozen:
                logger.debug("Second")
                frozen.tick(delta=datetime.timedelta(hours=1))
                logger.debug("Third")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_01-00-00.log", "First\nSecond\n"),
                ("test_2018-10-27_02-00-00.log", "Third\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08386170>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac093227d0>
i          = None
rotation   = '03:30:00'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit4')

tests/test_filesink_rotation.py:349: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit4')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_01-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_02-00-00.log', 'Third\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit4')
files      = [('test_2018-10-27_01-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_02-00-00.log', 'Third\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_when_positive_timezone_changes_forwardrotation0">test_filesink_rotation.py::test_time_rotation_when_positive_timezone_changes_forward[rotation0]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_when_positive_timezone_changes_forward[rotation0]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6cb0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when_positi0')
rotation = datetime.time(2, 30)

    @pytest.mark.parametrize("rotation", [datetime.time(2, 30, 0), "02:30:00"])
    def test_time_rotation_when_positive_timezone_changes_forward(freeze_time, tmp_path, rotation):
        with freeze_time("2018-10-27 02:00:00", ("CET", 3600)):
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss}.log",
                format="{message}",
                rotation=rotation,
            )

            logger.debug("First")

            with freeze_time("2018-10-27 03:00:00", ("CET", 7200)) as frozen:
                logger.debug("Second")
                frozen.tick(delta=datetime.timedelta(hours=1))
                logger.debug("Third")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_02-00-00.log", "First\n"),
                ("test_2018-10-27_03-00-00.log", "Second\nThird\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b6cb0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac087e1900>
i          = None
rotation   = datetime.time(2, 30)
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when_positi0')

tests/test_filesink_rotation.py:376: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when_positi0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_02-00-00.log', 'First\n'), ('test_2018-10-27_03-00-00.log', 'Second\nThird\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when_positi0')
files      = [('test_2018-10-27_02-00-00.log', 'First\n'), ('test_2018-10-27_03-00-00.log', 'Second\nThird\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_when_positive_timezone_changes_forward023000">test_filesink_rotation.py::test_time_rotation_when_positive_timezone_changes_forward[02:30:00]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_when_positive_timezone_changes_forward[02:30:00]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b79a0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when_positi1')
rotation = '02:30:00'

    @pytest.mark.parametrize("rotation", [datetime.time(2, 30, 0), "02:30:00"])
    def test_time_rotation_when_positive_timezone_changes_forward(freeze_time, tmp_path, rotation):
        with freeze_time("2018-10-27 02:00:00", ("CET", 3600)):
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss}.log",
                format="{message}",
                rotation=rotation,
            )

            logger.debug("First")

            with freeze_time("2018-10-27 03:00:00", ("CET", 7200)) as frozen:
                logger.debug("Second")
                frozen.tick(delta=datetime.timedelta(hours=1))
                logger.debug("Third")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_02-00-00.log", "First\n"),
                ("test_2018-10-27_03-00-00.log", "Second\nThird\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b79a0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08772aa0>
i          = None
rotation   = '02:30:00'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when_positi1')

tests/test_filesink_rotation.py:376: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when_positi1')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_02-00-00.log', 'First\n'), ('test_2018-10-27_03-00-00.log', 'Second\nThird\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when_positi1')
files      = [('test_2018-10-27_02-00-00.log', 'First\n'), ('test_2018-10-27_03-00-00.log', 'Second\nThird\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_after_negative_timezone_changes_forwardrotation0">test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_forward[rotation0]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_forward[rotation0]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08386200>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat0')
rotation = datetime.time(4, 30, tzinfo=datetime.timezone.utc)

    @pytest.mark.parametrize(
        "rotation",
        [
            datetime.time(4, 30, 0, tzinfo=datetime.timezone.utc),
            datetime.time(5, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600))),
            datetime.time(3, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
            datetime.time(3, 30, 0),
            "03:30:00",
        ],
    )
    def test_time_rotation_after_negative_timezone_changes_forward(freeze_time, tmp_path, rotation):
        with freeze_time("2018-10-27 02:00:00", ("CET", -7200)):
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss!UTC}.log",
                format="{message}",
                rotation=rotation,
            )

            logger.debug("First")

            with freeze_time("2018-10-27 03:00:00", ("CET", -3600)) as frozen:
                logger.debug("Second")
                frozen.tick(delta=datetime.timedelta(hours=1))
                logger.debug("Third")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_04-00-00.log", "First\nSecond\n"),
                ("test_2018-10-27_05-00-00.log", "Third\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08386200>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac088ead40>
i          = None
rotation   = datetime.time(4, 30, tzinfo=datetime.timezone.utc)
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat0')

tests/test_filesink_rotation.py:412: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_04-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_05-00-00.log', 'Third\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat0')
files      = [('test_2018-10-27_04-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_05-00-00.log', 'Third\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_after_negative_timezone_changes_forwardrotation1">test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_forward[rotation1]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_forward[rotation1]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083841f0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat1')
rotation = datetime.time(5, 30, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600)))

    @pytest.mark.parametrize(
        "rotation",
        [
            datetime.time(4, 30, 0, tzinfo=datetime.timezone.utc),
            datetime.time(5, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600))),
            datetime.time(3, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
            datetime.time(3, 30, 0),
            "03:30:00",
        ],
    )
    def test_time_rotation_after_negative_timezone_changes_forward(freeze_time, tmp_path, rotation):
        with freeze_time("2018-10-27 02:00:00", ("CET", -7200)):
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss!UTC}.log",
                format="{message}",
                rotation=rotation,
            )

            logger.debug("First")

            with freeze_time("2018-10-27 03:00:00", ("CET", -3600)) as frozen:
                logger.debug("Second")
                frozen.tick(delta=datetime.timedelta(hours=1))
                logger.debug("Third")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_04-00-00.log", "First\nSecond\n"),
                ("test_2018-10-27_05-00-00.log", "Third\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083841f0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac083fc700>
i          = None
rotation   = datetime.time(5, 30, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600)))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat1')

tests/test_filesink_rotation.py:412: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat1')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_04-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_05-00-00.log', 'Third\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat1')
files      = [('test_2018-10-27_04-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_05-00-00.log', 'Third\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_after_negative_timezone_changes_forwardrotation2">test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_forward[rotation2]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_forward[rotation2]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08384040>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat2')
rotation = datetime.time(3, 30, tzinfo=datetime.timezone(datetime.timedelta(days=-1, seconds=82800)))

    @pytest.mark.parametrize(
        "rotation",
        [
            datetime.time(4, 30, 0, tzinfo=datetime.timezone.utc),
            datetime.time(5, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600))),
            datetime.time(3, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
            datetime.time(3, 30, 0),
            "03:30:00",
        ],
    )
    def test_time_rotation_after_negative_timezone_changes_forward(freeze_time, tmp_path, rotation):
        with freeze_time("2018-10-27 02:00:00", ("CET", -7200)):
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss!UTC}.log",
                format="{message}",
                rotation=rotation,
            )

            logger.debug("First")

            with freeze_time("2018-10-27 03:00:00", ("CET", -3600)) as frozen:
                logger.debug("Second")
                frozen.tick(delta=datetime.timedelta(hours=1))
                logger.debug("Third")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_04-00-00.log", "First\nSecond\n"),
                ("test_2018-10-27_05-00-00.log", "Third\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08384040>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac0830a4a0>
i          = None
rotation   = datetime.time(3, 30, tzinfo=datetime.timezone(datetime.timedelta(days=-1, seconds=82800)))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat2')

tests/test_filesink_rotation.py:412: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat2')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_04-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_05-00-00.log', 'Third\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat2')
files      = [('test_2018-10-27_04-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_05-00-00.log', 'Third\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_after_negative_timezone_changes_forwardrotation3">test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_forward[rotation3]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_forward[rotation3]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083868c0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat3')
rotation = datetime.time(3, 30)

    @pytest.mark.parametrize(
        "rotation",
        [
            datetime.time(4, 30, 0, tzinfo=datetime.timezone.utc),
            datetime.time(5, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600))),
            datetime.time(3, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
            datetime.time(3, 30, 0),
            "03:30:00",
        ],
    )
    def test_time_rotation_after_negative_timezone_changes_forward(freeze_time, tmp_path, rotation):
        with freeze_time("2018-10-27 02:00:00", ("CET", -7200)):
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss!UTC}.log",
                format="{message}",
                rotation=rotation,
            )

            logger.debug("First")

            with freeze_time("2018-10-27 03:00:00", ("CET", -3600)) as frozen:
                logger.debug("Second")
                frozen.tick(delta=datetime.timedelta(hours=1))
                logger.debug("Third")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_04-00-00.log", "First\nSecond\n"),
                ("test_2018-10-27_05-00-00.log", "Third\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083868c0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08312110>
i          = None
rotation   = datetime.time(3, 30)
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat3')

tests/test_filesink_rotation.py:412: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat3')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_04-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_05-00-00.log', 'Third\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat3')
files      = [('test_2018-10-27_04-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_05-00-00.log', 'Third\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_after_negative_timezone_changes_forward033000">test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_forward[03:30:00]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_forward[03:30:00]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08386b90>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat4')
rotation = '03:30:00'

    @pytest.mark.parametrize(
        "rotation",
        [
            datetime.time(4, 30, 0, tzinfo=datetime.timezone.utc),
            datetime.time(5, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600))),
            datetime.time(3, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
            datetime.time(3, 30, 0),
            "03:30:00",
        ],
    )
    def test_time_rotation_after_negative_timezone_changes_forward(freeze_time, tmp_path, rotation):
        with freeze_time("2018-10-27 02:00:00", ("CET", -7200)):
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss!UTC}.log",
                format="{message}",
                rotation=rotation,
            )

            logger.debug("First")

            with freeze_time("2018-10-27 03:00:00", ("CET", -3600)) as frozen:
                logger.debug("Second")
                frozen.tick(delta=datetime.timedelta(hours=1))
                logger.debug("Third")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_04-00-00.log", "First\nSecond\n"),
                ("test_2018-10-27_05-00-00.log", "Third\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08386b90>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac09303280>
i          = None
rotation   = '03:30:00'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat4')

tests/test_filesink_rotation.py:412: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat4')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_04-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_05-00-00.log', 'Third\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat4')
files      = [('test_2018-10-27_04-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_05-00-00.log', 'Third\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_when_negative_timezone_changes_forwardrotation0">test_filesink_rotation.py::test_time_rotation_when_negative_timezone_changes_forward[rotation0]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_when_negative_timezone_changes_forward[rotation0]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7be0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when_negati0')
rotation = datetime.time(2, 30)

    @pytest.mark.parametrize("rotation", [datetime.time(2, 30, 0), "02:30:00"])
    def test_time_rotation_when_negative_timezone_changes_forward(freeze_time, tmp_path, rotation):
        with freeze_time("2018-10-27 02:00:00", ("CET", -7200)):
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss}.log",
                format="{message}",
                rotation=rotation,
            )

            logger.debug("First")

            with freeze_time("2018-10-27 03:00:00", ("CET", -3600)) as frozen:
                logger.debug("Second")
                frozen.tick(delta=datetime.timedelta(hours=1))
                logger.debug("Third")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_02-00-00.log", "First\n"),
                ("test_2018-10-27_03-00-00.log", "Second\nThird\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b7be0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac088e5390>
i          = None
rotation   = datetime.time(2, 30)
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when_negati0')

tests/test_filesink_rotation.py:439: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when_negati0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_02-00-00.log', 'First\n'), ('test_2018-10-27_03-00-00.log', 'Second\nThird\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when_negati0')
files      = [('test_2018-10-27_02-00-00.log', 'First\n'), ('test_2018-10-27_03-00-00.log', 'Second\nThird\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_when_negative_timezone_changes_forward023000">test_filesink_rotation.py::test_time_rotation_when_negative_timezone_changes_forward[02:30:00]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_when_negative_timezone_changes_forward[02:30:00]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083851b0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when_negati1')
rotation = '02:30:00'

    @pytest.mark.parametrize("rotation", [datetime.time(2, 30, 0), "02:30:00"])
    def test_time_rotation_when_negative_timezone_changes_forward(freeze_time, tmp_path, rotation):
        with freeze_time("2018-10-27 02:00:00", ("CET", -7200)):
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss}.log",
                format="{message}",
                rotation=rotation,
            )

            logger.debug("First")

            with freeze_time("2018-10-27 03:00:00", ("CET", -3600)) as frozen:
                logger.debug("Second")
                frozen.tick(delta=datetime.timedelta(hours=1))
                logger.debug("Third")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_02-00-00.log", "First\n"),
                ("test_2018-10-27_03-00-00.log", "Second\nThird\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083851b0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac0885c430>
i          = None
rotation   = '02:30:00'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when_negati1')

tests/test_filesink_rotation.py:439: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when_negati1')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_02-00-00.log', 'First\n'), ('test_2018-10-27_03-00-00.log', 'Second\nThird\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when_negati1')
files      = [('test_2018-10-27_02-00-00.log', 'First\n'), ('test_2018-10-27_03-00-00.log', 'Second\nThird\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_after_positive_timezone_changes_backward_awarerotation0">test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_backward_aware[rotation0]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_backward_aware[rotation0]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08385bd0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit5')
rotation = datetime.time(1, 30, tzinfo=datetime.timezone.utc)

    @pytest.mark.parametrize(
        "rotation",
        [
            datetime.time(1, 30, 0, tzinfo=datetime.timezone.utc),
            datetime.time(2, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600))),
            datetime.time(0, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
        ],
    )
    def test_time_rotation_after_positive_timezone_changes_backward_aware(
        freeze_time, tmp_path, rotation
    ):
        with freeze_time("2018-10-27 03:00:00", ("CET", 7200)):
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss!UTC}.log",
                format="{message}",
                rotation=rotation,
            )

            logger.debug("First")

            with freeze_time("2018-10-27 02:00:00", ("CET", 3600)) as frozen:
                logger.debug("Second")
                frozen.tick(delta=datetime.timedelta(hours=1))
                logger.debug("Third")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_01-00-00.log", "First\nSecond\n"),
                ("test_2018-10-27_02-00-00.log", "Third\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08385bd0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac088f1060>
i          = None
rotation   = datetime.time(1, 30, tzinfo=datetime.timezone.utc)
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit5')

tests/test_filesink_rotation.py:475: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit5')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_01-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_02-00-00.log', 'Third\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit5')
files      = [('test_2018-10-27_01-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_02-00-00.log', 'Third\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_after_positive_timezone_changes_backward_awarerotation1">test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_backward_aware[rotation1]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_backward_aware[rotation1]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08387250>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit6')
rotation = datetime.time(2, 30, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600)))

    @pytest.mark.parametrize(
        "rotation",
        [
            datetime.time(1, 30, 0, tzinfo=datetime.timezone.utc),
            datetime.time(2, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600))),
            datetime.time(0, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
        ],
    )
    def test_time_rotation_after_positive_timezone_changes_backward_aware(
        freeze_time, tmp_path, rotation
    ):
        with freeze_time("2018-10-27 03:00:00", ("CET", 7200)):
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss!UTC}.log",
                format="{message}",
                rotation=rotation,
            )

            logger.debug("First")

            with freeze_time("2018-10-27 02:00:00", ("CET", 3600)) as frozen:
                logger.debug("Second")
                frozen.tick(delta=datetime.timedelta(hours=1))
                logger.debug("Third")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_01-00-00.log", "First\nSecond\n"),
                ("test_2018-10-27_02-00-00.log", "Third\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08387250>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac0876d840>
i          = None
rotation   = datetime.time(2, 30, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600)))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit6')

tests/test_filesink_rotation.py:475: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit6')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_01-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_02-00-00.log', 'Third\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit6')
files      = [('test_2018-10-27_01-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_02-00-00.log', 'Third\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_after_positive_timezone_changes_backward_awarerotation2">test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_backward_aware[rotation2]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_backward_aware[rotation2]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08386050>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit7')
rotation = datetime.time(0, 30, tzinfo=datetime.timezone(datetime.timedelta(days=-1, seconds=82800)))

    @pytest.mark.parametrize(
        "rotation",
        [
            datetime.time(1, 30, 0, tzinfo=datetime.timezone.utc),
            datetime.time(2, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600))),
            datetime.time(0, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
        ],
    )
    def test_time_rotation_after_positive_timezone_changes_backward_aware(
        freeze_time, tmp_path, rotation
    ):
        with freeze_time("2018-10-27 03:00:00", ("CET", 7200)):
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss!UTC}.log",
                format="{message}",
                rotation=rotation,
            )

            logger.debug("First")

            with freeze_time("2018-10-27 02:00:00", ("CET", 3600)) as frozen:
                logger.debug("Second")
                frozen.tick(delta=datetime.timedelta(hours=1))
                logger.debug("Third")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_01-00-00.log", "First\nSecond\n"),
                ("test_2018-10-27_02-00-00.log", "Third\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08386050>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08380eb0>
i          = None
rotation   = datetime.time(0, 30, tzinfo=datetime.timezone(datetime.timedelta(days=-1, seconds=82800)))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit7')

tests/test_filesink_rotation.py:475: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit7')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_01-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_02-00-00.log', 'Third\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit7')
files      = [('test_2018-10-27_01-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_02-00-00.log', 'Third\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_after_positive_timezone_changes_backward_naiverotation0">test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_backward_naive[rotation0]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_backward_naive[rotation0]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08384940>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit8')
rotation = datetime.time(2, 30)

    @pytest.mark.parametrize("rotation", [datetime.time(2, 30, 0), "02:30:00"])
    def test_time_rotation_after_positive_timezone_changes_backward_naive(
        freeze_time, tmp_path, rotation
    ):
        with freeze_time("2018-10-27 03:00:00", ("CET", 7200)):
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss!UTC}.log",
                format="{message}",
                rotation=rotation,
            )

            logger.debug("First")

            with freeze_time("2018-10-27 02:00:00", ("CET", 3600)) as frozen:
                logger.debug("Second")
                frozen.tick(delta=datetime.timedelta(hours=1))
                logger.debug("Third")
                frozen.tick(delta=datetime.timedelta(days=1))
                logger.debug("Fourth")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_01-00-00.log", "First\nSecond\nThird\n"),
                ("test_2018-10-28_02-00-00.log", "Fourth\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08384940>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac093107f0>
i          = None
rotation   = datetime.time(2, 30)
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit8')

tests/test_filesink_rotation.py:506: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit8')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_01-00-00.log', 'First\nSecond\nThird\n'), ('test_2018-10-28_02-00-00.log', 'Fourth\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit8')
files      = [('test_2018-10-27_01-00-00.log', 'First\nSecond\nThird\n'), ('test_2018-10-28_02-00-00.log', 'Fourth\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_after_positive_timezone_changes_backward_naive023000">test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_backward_naive[02:30:00]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_after_positive_timezone_changes_backward_naive[02:30:00]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08384c10>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit9')
rotation = '02:30:00'

    @pytest.mark.parametrize("rotation", [datetime.time(2, 30, 0), "02:30:00"])
    def test_time_rotation_after_positive_timezone_changes_backward_naive(
        freeze_time, tmp_path, rotation
    ):
        with freeze_time("2018-10-27 03:00:00", ("CET", 7200)):
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss!UTC}.log",
                format="{message}",
                rotation=rotation,
            )

            logger.debug("First")

            with freeze_time("2018-10-27 02:00:00", ("CET", 3600)) as frozen:
                logger.debug("Second")
                frozen.tick(delta=datetime.timedelta(hours=1))
                logger.debug("Third")
                frozen.tick(delta=datetime.timedelta(days=1))
                logger.debug("Fourth")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_01-00-00.log", "First\nSecond\nThird\n"),
                ("test_2018-10-28_02-00-00.log", "Fourth\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08384c10>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac0820cb80>
i          = None
rotation   = '02:30:00'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit9')

tests/test_filesink_rotation.py:506: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit9')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_01-00-00.log', 'First\nSecond\nThird\n'), ('test_2018-10-28_02-00-00.log', 'Fourth\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_posit9')
files      = [('test_2018-10-27_01-00-00.log', 'First\nSecond\nThird\n'), ('test_2018-10-28_02-00-00.log', 'Fourth\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_after_negative_timezone_changes_backward_awarerotation0">test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_backward_aware[rotation0]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_backward_aware[rotation0]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b79a0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat5')
rotation = datetime.time(4, 30, tzinfo=datetime.timezone.utc)

    @pytest.mark.parametrize(
        "rotation",
        [
            datetime.time(4, 30, 0, tzinfo=datetime.timezone.utc),
            datetime.time(5, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600))),
            datetime.time(3, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
        ],
    )
    def test_time_rotation_after_negative_timezone_changes_backward_aware(
        freeze_time, tmp_path, rotation
    ):
        with freeze_time("2018-10-27 03:00:00", ("CET", -3600)):
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss!UTC}.log",
                format="{message}",
                rotation=rotation,
            )

            logger.debug("First")

            with freeze_time("2018-10-27 02:00:00", ("CET", -7200)) as frozen:
                logger.debug("Second")
                frozen.tick(delta=datetime.timedelta(hours=1))
                logger.debug("Third")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_04-00-00.log", "First\nSecond\n"),
                ("test_2018-10-27_05-00-00.log", "Third\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083b79a0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08788730>
i          = None
rotation   = datetime.time(4, 30, tzinfo=datetime.timezone.utc)
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat5')

tests/test_filesink_rotation.py:542: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat5')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_04-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_05-00-00.log', 'Third\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat5')
files      = [('test_2018-10-27_04-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_05-00-00.log', 'Third\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_after_negative_timezone_changes_backward_awarerotation1">test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_backward_aware[rotation1]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_backward_aware[rotation1]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08386290>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat6')
rotation = datetime.time(5, 30, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600)))

    @pytest.mark.parametrize(
        "rotation",
        [
            datetime.time(4, 30, 0, tzinfo=datetime.timezone.utc),
            datetime.time(5, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600))),
            datetime.time(3, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
        ],
    )
    def test_time_rotation_after_negative_timezone_changes_backward_aware(
        freeze_time, tmp_path, rotation
    ):
        with freeze_time("2018-10-27 03:00:00", ("CET", -3600)):
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss!UTC}.log",
                format="{message}",
                rotation=rotation,
            )

            logger.debug("First")

            with freeze_time("2018-10-27 02:00:00", ("CET", -7200)) as frozen:
                logger.debug("Second")
                frozen.tick(delta=datetime.timedelta(hours=1))
                logger.debug("Third")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_04-00-00.log", "First\nSecond\n"),
                ("test_2018-10-27_05-00-00.log", "Third\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08386290>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac087313c0>
i          = None
rotation   = datetime.time(5, 30, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600)))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat6')

tests/test_filesink_rotation.py:542: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat6')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_04-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_05-00-00.log', 'Third\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat6')
files      = [('test_2018-10-27_04-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_05-00-00.log', 'Third\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_after_negative_timezone_changes_backward_awarerotation2">test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_backward_aware[rotation2]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_backward_aware[rotation2]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08387ac0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat7')
rotation = datetime.time(3, 30, tzinfo=datetime.timezone(datetime.timedelta(days=-1, seconds=82800)))

    @pytest.mark.parametrize(
        "rotation",
        [
            datetime.time(4, 30, 0, tzinfo=datetime.timezone.utc),
            datetime.time(5, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600))),
            datetime.time(3, 30, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
        ],
    )
    def test_time_rotation_after_negative_timezone_changes_backward_aware(
        freeze_time, tmp_path, rotation
    ):
        with freeze_time("2018-10-27 03:00:00", ("CET", -3600)):
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss!UTC}.log",
                format="{message}",
                rotation=rotation,
            )

            logger.debug("First")

            with freeze_time("2018-10-27 02:00:00", ("CET", -7200)) as frozen:
                logger.debug("Second")
                frozen.tick(delta=datetime.timedelta(hours=1))
                logger.debug("Third")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_04-00-00.log", "First\nSecond\n"),
                ("test_2018-10-27_05-00-00.log", "Third\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08387ac0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac09301ba0>
i          = None
rotation   = datetime.time(3, 30, tzinfo=datetime.timezone(datetime.timedelta(days=-1, seconds=82800)))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat7')

tests/test_filesink_rotation.py:542: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat7')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_04-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_05-00-00.log', 'Third\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat7')
files      = [('test_2018-10-27_04-00-00.log', 'First\nSecond\n'), ('test_2018-10-27_05-00-00.log', 'Third\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_after_negative_timezone_changes_backward_naiverotation0">test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_backward_naive[rotation0]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_backward_naive[rotation0]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08384040>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat8')
rotation = datetime.time(2, 30)

    @pytest.mark.parametrize("rotation", [datetime.time(2, 30, 0), "02:30:00"])
    def test_time_rotation_after_negative_timezone_changes_backward_naive(
        freeze_time, tmp_path, rotation
    ):
        with freeze_time("2018-10-27 03:00:00", ("CET", -3600)):
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss!UTC}.log",
                format="{message}",
                rotation=rotation,
            )

            logger.debug("First")

            with freeze_time("2018-10-27 02:00:00", ("CET", -7200)) as frozen:
                logger.debug("Second")
                frozen.tick(delta=datetime.timedelta(hours=1))
                logger.debug("Third")
                frozen.tick(delta=datetime.timedelta(days=1))
                logger.debug("Fourth")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_04-00-00.log", "First\nSecond\nThird\n"),
                ("test_2018-10-28_05-00-00.log", "Fourth\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08384040>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac088f1990>
i          = None
rotation   = datetime.time(2, 30)
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat8')

tests/test_filesink_rotation.py:573: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat8')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_04-00-00.log', 'First\nSecond\nThird\n'), ('test_2018-10-28_05-00-00.log', 'Fourth\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat8')
files      = [('test_2018-10-27_04-00-00.log', 'First\nSecond\nThird\n'), ('test_2018-10-28_05-00-00.log', 'Fourth\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_after_negative_timezone_changes_backward_naive023000">test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_backward_naive[02:30:00]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_after_negative_timezone_changes_backward_naive[02:30:00]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08387370>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat9')
rotation = '02:30:00'

    @pytest.mark.parametrize("rotation", [datetime.time(2, 30, 0), "02:30:00"])
    def test_time_rotation_after_negative_timezone_changes_backward_naive(
        freeze_time, tmp_path, rotation
    ):
        with freeze_time("2018-10-27 03:00:00", ("CET", -3600)):
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss!UTC}.log",
                format="{message}",
                rotation=rotation,
            )

            logger.debug("First")

            with freeze_time("2018-10-27 02:00:00", ("CET", -7200)) as frozen:
                logger.debug("Second")
                frozen.tick(delta=datetime.timedelta(hours=1))
                logger.debug("Third")
                frozen.tick(delta=datetime.timedelta(days=1))
                logger.debug("Fourth")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_04-00-00.log", "First\nSecond\nThird\n"),
                ("test_2018-10-28_05-00-00.log", "Fourth\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08387370>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac088e9210>
i          = None
rotation   = '02:30:00'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat9')

tests/test_filesink_rotation.py:573: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat9')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_04-00-00.log', 'First\nSecond\nThird\n'), ('test_2018-10-28_05-00-00.log', 'Fourth\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_after_negat9')
files      = [('test_2018-10-27_04-00-00.log', 'First\nSecond\nThird\n'), ('test_2018-10-28_05-00-00.log', 'Fourth\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_when_timezone_changes_backward_rename_file">test_filesink_rotation.py::test_time_rotation_when_timezone_changes_backward_rename_file</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_when_timezone_changes_backward_rename_file</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08387d00>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when_timezo0')

    def test_time_rotation_when_timezone_changes_backward_rename_file(freeze_time, tmp_path):
        with freeze_time("2018-10-27 02:00:00", ("CET", 3600)):
            i = logger.add(
                tmp_path / "test_{time:YYYY-MM-DD_HH-mm-ss!UTC}.log",
                format="{message}",
                rotation="02:30:00",
            )

            logger.debug("First")

            with freeze_time("2018-10-27 03:00:00", ("CET", 7200)) as frozen:
                logger.debug("Second")
                frozen.tick(delta=datetime.timedelta(hours=1))
                logger.debug("Third")

        logger.remove(i)

>       check_dir(
            tmp_path,
            files=[
                ("test_2018-10-27_01-00-00.2018-10-27_03-00-00_000000.log", "First\n"),
                ("test_2018-10-27_01-00-00.log", "Second\nThird\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08387d00>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08732020>
i          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when_timezo0')

tests/test_filesink_rotation.py:599: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when_timezo0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test_2018-10-27_01-00-00.2018-10-27_03-00-00_000000.log', 'First\n'), ('test_2018-10-27_01-00-00.log', 'Second\nThird\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_time_rotation_when_timezo0')
files      = [('test_2018-10-27_01-00-00.2018-10-27_03-00-00_000000.log', 'First\n'), ('test_2018-10-27_01-00-00.log', 'Second\nThird\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_dont_rotate_earlier_when_utc_is_one_day_before0015">test_filesink_rotation.py::test_dont_rotate_earlier_when_utc_is_one_day_before[00:15]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_dont_rotate_earlier_when_utc_is_one_day_before[00:15]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08384940>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_earlier_when_0')
rotation = '00:15'

    @pytest.mark.parametrize(
        "rotation",
        [
            "00:15",
            datetime.time(0, 15, 0),
            datetime.time(23, 15, 0, tzinfo=datetime.timezone.utc),
            datetime.time(0, 15, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=+3600))),
            datetime.time(22, 15, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
        ],
    )
    def test_dont_rotate_earlier_when_utc_is_one_day_before(freeze_time, tmp_path, rotation):
        with freeze_time("2018-10-24 00:30:00", ("CET", +3600)) as frozen:
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("First")
            logger.remove()

            frozen.tick(delta=datetime.timedelta(hours=1))
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("Second")
            logger.remove()

            frozen.tick(delta=datetime.timedelta(hours=23))
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("Third")
            logger.remove()

>       check_dir(
            tmp_path,
            files=[
                ("test.2018-10-24_00-30-00_000000.log", "First\nSecond\n"),
                ("test.log", "Third\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08384940>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac0876c5b0>
rotation   = '00:15'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_earlier_when_0')

tests/test_filesink_rotation.py:634: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_earlier_when_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test.2018-10-24_00-30-00_000000.log', 'First\nSecond\n'), ('test.log', 'Third\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_earlier_when_0')
files      = [('test.2018-10-24_00-30-00_000000.log', 'First\nSecond\n'), ('test.log', 'Third\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_dont_rotate_earlier_when_utc_is_one_day_beforerotation1">test_filesink_rotation.py::test_dont_rotate_earlier_when_utc_is_one_day_before[rotation1]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_dont_rotate_earlier_when_utc_is_one_day_before[rotation1]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08387760>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_earlier_when_1')
rotation = datetime.time(0, 15)

    @pytest.mark.parametrize(
        "rotation",
        [
            "00:15",
            datetime.time(0, 15, 0),
            datetime.time(23, 15, 0, tzinfo=datetime.timezone.utc),
            datetime.time(0, 15, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=+3600))),
            datetime.time(22, 15, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
        ],
    )
    def test_dont_rotate_earlier_when_utc_is_one_day_before(freeze_time, tmp_path, rotation):
        with freeze_time("2018-10-24 00:30:00", ("CET", +3600)) as frozen:
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("First")
            logger.remove()

            frozen.tick(delta=datetime.timedelta(hours=1))
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("Second")
            logger.remove()

            frozen.tick(delta=datetime.timedelta(hours=23))
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("Third")
            logger.remove()

>       check_dir(
            tmp_path,
            files=[
                ("test.2018-10-24_00-30-00_000000.log", "First\nSecond\n"),
                ("test.log", "Third\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08387760>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac088f0a30>
rotation   = datetime.time(0, 15)
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_earlier_when_1')

tests/test_filesink_rotation.py:634: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_earlier_when_1')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test.2018-10-24_00-30-00_000000.log', 'First\nSecond\n'), ('test.log', 'Third\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_earlier_when_1')
files      = [('test.2018-10-24_00-30-00_000000.log', 'First\nSecond\n'), ('test.log', 'Third\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_dont_rotate_earlier_when_utc_is_one_day_beforerotation2">test_filesink_rotation.py::test_dont_rotate_earlier_when_utc_is_one_day_before[rotation2]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_dont_rotate_earlier_when_utc_is_one_day_before[rotation2]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083872e0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_earlier_when_2')
rotation = datetime.time(23, 15, tzinfo=datetime.timezone.utc)

    @pytest.mark.parametrize(
        "rotation",
        [
            "00:15",
            datetime.time(0, 15, 0),
            datetime.time(23, 15, 0, tzinfo=datetime.timezone.utc),
            datetime.time(0, 15, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=+3600))),
            datetime.time(22, 15, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
        ],
    )
    def test_dont_rotate_earlier_when_utc_is_one_day_before(freeze_time, tmp_path, rotation):
        with freeze_time("2018-10-24 00:30:00", ("CET", +3600)) as frozen:
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("First")
            logger.remove()

            frozen.tick(delta=datetime.timedelta(hours=1))
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("Second")
            logger.remove()

            frozen.tick(delta=datetime.timedelta(hours=23))
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("Third")
            logger.remove()

>       check_dir(
            tmp_path,
            files=[
                ("test.2018-10-24_00-30-00_000000.log", "First\nSecond\n"),
                ("test.log", "Third\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083872e0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac083806a0>
rotation   = datetime.time(23, 15, tzinfo=datetime.timezone.utc)
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_earlier_when_2')

tests/test_filesink_rotation.py:634: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_earlier_when_2')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test.2018-10-24_00-30-00_000000.log', 'First\nSecond\n'), ('test.log', 'Third\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_earlier_when_2')
files      = [('test.2018-10-24_00-30-00_000000.log', 'First\nSecond\n'), ('test.log', 'Third\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_dont_rotate_earlier_when_utc_is_one_day_beforerotation3">test_filesink_rotation.py::test_dont_rotate_earlier_when_utc_is_one_day_before[rotation3]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_dont_rotate_earlier_when_utc_is_one_day_before[rotation3]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08387d00>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_earlier_when_3')
rotation = datetime.time(0, 15, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600)))

    @pytest.mark.parametrize(
        "rotation",
        [
            "00:15",
            datetime.time(0, 15, 0),
            datetime.time(23, 15, 0, tzinfo=datetime.timezone.utc),
            datetime.time(0, 15, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=+3600))),
            datetime.time(22, 15, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
        ],
    )
    def test_dont_rotate_earlier_when_utc_is_one_day_before(freeze_time, tmp_path, rotation):
        with freeze_time("2018-10-24 00:30:00", ("CET", +3600)) as frozen:
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("First")
            logger.remove()

            frozen.tick(delta=datetime.timedelta(hours=1))
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("Second")
            logger.remove()

            frozen.tick(delta=datetime.timedelta(hours=23))
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("Third")
            logger.remove()

>       check_dir(
            tmp_path,
            files=[
                ("test.2018-10-24_00-30-00_000000.log", "First\nSecond\n"),
                ("test.log", "Third\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08387d00>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac087ee9b0>
rotation   = datetime.time(0, 15, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600)))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_earlier_when_3')

tests/test_filesink_rotation.py:634: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_earlier_when_3')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test.2018-10-24_00-30-00_000000.log', 'First\nSecond\n'), ('test.log', 'Third\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_earlier_when_3')
files      = [('test.2018-10-24_00-30-00_000000.log', 'First\nSecond\n'), ('test.log', 'Third\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_dont_rotate_earlier_when_utc_is_one_day_beforerotation4">test_filesink_rotation.py::test_dont_rotate_earlier_when_utc_is_one_day_before[rotation4]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_dont_rotate_earlier_when_utc_is_one_day_before[rotation4]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08386950>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_earlier_when_4')
rotation = datetime.time(22, 15, tzinfo=datetime.timezone(datetime.timedelta(days=-1, seconds=82800)))

    @pytest.mark.parametrize(
        "rotation",
        [
            "00:15",
            datetime.time(0, 15, 0),
            datetime.time(23, 15, 0, tzinfo=datetime.timezone.utc),
            datetime.time(0, 15, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=+3600))),
            datetime.time(22, 15, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
        ],
    )
    def test_dont_rotate_earlier_when_utc_is_one_day_before(freeze_time, tmp_path, rotation):
        with freeze_time("2018-10-24 00:30:00", ("CET", +3600)) as frozen:
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("First")
            logger.remove()

            frozen.tick(delta=datetime.timedelta(hours=1))
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("Second")
            logger.remove()

            frozen.tick(delta=datetime.timedelta(hours=23))
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("Third")
            logger.remove()

>       check_dir(
            tmp_path,
            files=[
                ("test.2018-10-24_00-30-00_000000.log", "First\nSecond\n"),
                ("test.log", "Third\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08386950>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac088f3580>
rotation   = datetime.time(22, 15, tzinfo=datetime.timezone(datetime.timedelta(days=-1, seconds=82800)))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_earlier_when_4')

tests/test_filesink_rotation.py:634: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_earlier_when_4')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test.2018-10-24_00-30-00_000000.log', 'First\nSecond\n'), ('test.log', 'Third\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_earlier_when_4')
files      = [('test.2018-10-24_00-30-00_000000.log', 'First\nSecond\n'), ('test.log', 'Third\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_dont_rotate_later_when_utc_is_one_day_after2345">test_filesink_rotation.py::test_dont_rotate_later_when_utc_is_one_day_after[23:45]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_dont_rotate_later_when_utc_is_one_day_after[23:45]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08386b90>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_later_when_ut0')
rotation = '23:45'

    @pytest.mark.parametrize(
        "rotation",
        [
            "23:45",
            datetime.time(23, 45, 0),
            datetime.time(0, 45, 0, tzinfo=datetime.timezone.utc),
            datetime.time(1, 45, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=+3600))),
            datetime.time(23, 45, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
        ],
    )
    def test_dont_rotate_later_when_utc_is_one_day_after(freeze_time, tmp_path, rotation):
        with freeze_time("2018-10-23 23:30:00", ("CET", -3600)) as frozen:
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("First")
            logger.remove()

            frozen.tick(delta=datetime.timedelta(hours=1))
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("Second")
            logger.remove()

            frozen.tick(delta=datetime.timedelta(hours=23))
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("Third")
            logger.remove()

>       check_dir(
            tmp_path,
            files=[
                ("test.2018-10-23_23-30-00_000000.log", "First\n"),
                ("test.log", "Second\nThird\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08386b90>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08380220>
rotation   = '23:45'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_later_when_ut0')

tests/test_filesink_rotation.py:669: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_later_when_ut0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test.2018-10-23_23-30-00_000000.log', 'First\n'), ('test.log', 'Second\nThird\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_later_when_ut0')
files      = [('test.2018-10-23_23-30-00_000000.log', 'First\n'), ('test.log', 'Second\nThird\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_dont_rotate_later_when_utc_is_one_day_afterrotation1">test_filesink_rotation.py::test_dont_rotate_later_when_utc_is_one_day_after[rotation1]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_dont_rotate_later_when_utc_is_one_day_after[rotation1]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083853f0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_later_when_ut1')
rotation = datetime.time(23, 45)

    @pytest.mark.parametrize(
        "rotation",
        [
            "23:45",
            datetime.time(23, 45, 0),
            datetime.time(0, 45, 0, tzinfo=datetime.timezone.utc),
            datetime.time(1, 45, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=+3600))),
            datetime.time(23, 45, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
        ],
    )
    def test_dont_rotate_later_when_utc_is_one_day_after(freeze_time, tmp_path, rotation):
        with freeze_time("2018-10-23 23:30:00", ("CET", -3600)) as frozen:
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("First")
            logger.remove()

            frozen.tick(delta=datetime.timedelta(hours=1))
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("Second")
            logger.remove()

            frozen.tick(delta=datetime.timedelta(hours=23))
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("Third")
            logger.remove()

>       check_dir(
            tmp_path,
            files=[
                ("test.2018-10-23_23-30-00_000000.log", "First\n"),
                ("test.log", "Second\nThird\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac083853f0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08312530>
rotation   = datetime.time(23, 45)
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_later_when_ut1')

tests/test_filesink_rotation.py:669: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_later_when_ut1')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test.2018-10-23_23-30-00_000000.log', 'First\n'), ('test.log', 'Second\nThird\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_later_when_ut1')
files      = [('test.2018-10-23_23-30-00_000000.log', 'First\n'), ('test.log', 'Second\nThird\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_dont_rotate_later_when_utc_is_one_day_afterrotation2">test_filesink_rotation.py::test_dont_rotate_later_when_utc_is_one_day_after[rotation2]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_dont_rotate_later_when_utc_is_one_day_after[rotation2]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac081ec8b0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_later_when_ut2')
rotation = datetime.time(0, 45, tzinfo=datetime.timezone.utc)

    @pytest.mark.parametrize(
        "rotation",
        [
            "23:45",
            datetime.time(23, 45, 0),
            datetime.time(0, 45, 0, tzinfo=datetime.timezone.utc),
            datetime.time(1, 45, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=+3600))),
            datetime.time(23, 45, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
        ],
    )
    def test_dont_rotate_later_when_utc_is_one_day_after(freeze_time, tmp_path, rotation):
        with freeze_time("2018-10-23 23:30:00", ("CET", -3600)) as frozen:
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("First")
            logger.remove()

            frozen.tick(delta=datetime.timedelta(hours=1))
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("Second")
            logger.remove()

            frozen.tick(delta=datetime.timedelta(hours=23))
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("Third")
            logger.remove()

>       check_dir(
            tmp_path,
            files=[
                ("test.2018-10-23_23-30-00_000000.log", "First\n"),
                ("test.log", "Second\nThird\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac081ec8b0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac09323970>
rotation   = datetime.time(0, 45, tzinfo=datetime.timezone.utc)
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_later_when_ut2')

tests/test_filesink_rotation.py:669: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_later_when_ut2')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test.2018-10-23_23-30-00_000000.log', 'First\n'), ('test.log', 'Second\nThird\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_later_when_ut2')
files      = [('test.2018-10-23_23-30-00_000000.log', 'First\n'), ('test.log', 'Second\nThird\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_dont_rotate_later_when_utc_is_one_day_afterrotation3">test_filesink_rotation.py::test_dont_rotate_later_when_utc_is_one_day_after[rotation3]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_dont_rotate_later_when_utc_is_one_day_after[rotation3]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac081ecf70>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_later_when_ut3')
rotation = datetime.time(1, 45, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600)))

    @pytest.mark.parametrize(
        "rotation",
        [
            "23:45",
            datetime.time(23, 45, 0),
            datetime.time(0, 45, 0, tzinfo=datetime.timezone.utc),
            datetime.time(1, 45, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=+3600))),
            datetime.time(23, 45, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
        ],
    )
    def test_dont_rotate_later_when_utc_is_one_day_after(freeze_time, tmp_path, rotation):
        with freeze_time("2018-10-23 23:30:00", ("CET", -3600)) as frozen:
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("First")
            logger.remove()

            frozen.tick(delta=datetime.timedelta(hours=1))
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("Second")
            logger.remove()

            frozen.tick(delta=datetime.timedelta(hours=23))
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("Third")
            logger.remove()

>       check_dir(
            tmp_path,
            files=[
                ("test.2018-10-23_23-30-00_000000.log", "First\n"),
                ("test.log", "Second\nThird\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac081ecf70>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac087ed5a0>
rotation   = datetime.time(1, 45, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600)))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_later_when_ut3')

tests/test_filesink_rotation.py:669: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_later_when_ut3')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test.2018-10-23_23-30-00_000000.log', 'First\n'), ('test.log', 'Second\nThird\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_later_when_ut3')
files      = [('test.2018-10-23_23-30-00_000000.log', 'First\n'), ('test.log', 'Second\nThird\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_dont_rotate_later_when_utc_is_one_day_afterrotation4">test_filesink_rotation.py::test_dont_rotate_later_when_utc_is_one_day_after[rotation4]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_dont_rotate_later_when_utc_is_one_day_after[rotation4]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08387d90>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_later_when_ut4')
rotation = datetime.time(23, 45, tzinfo=datetime.timezone(datetime.timedelta(days=-1, seconds=82800)))

    @pytest.mark.parametrize(
        "rotation",
        [
            "23:45",
            datetime.time(23, 45, 0),
            datetime.time(0, 45, 0, tzinfo=datetime.timezone.utc),
            datetime.time(1, 45, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=+3600))),
            datetime.time(23, 45, 0, tzinfo=datetime.timezone(datetime.timedelta(seconds=-3600))),
        ],
    )
    def test_dont_rotate_later_when_utc_is_one_day_after(freeze_time, tmp_path, rotation):
        with freeze_time("2018-10-23 23:30:00", ("CET", -3600)) as frozen:
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("First")
            logger.remove()

            frozen.tick(delta=datetime.timedelta(hours=1))
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("Second")
            logger.remove()

            frozen.tick(delta=datetime.timedelta(hours=23))
            logger.add(tmp_path / "test.log", format="{message}", rotation=rotation)
            logger.info("Third")
            logger.remove()

>       check_dir(
            tmp_path,
            files=[
                ("test.2018-10-23_23-30-00_000000.log", "First\n"),
                ("test.log", "Second\nThird\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08387d90>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac083e7f40>
rotation   = datetime.time(23, 45, tzinfo=datetime.timezone(datetime.timedelta(days=-1, seconds=82800)))
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_later_when_ut4')

tests/test_filesink_rotation.py:669: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_later_when_ut4')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test.2018-10-23_23-30-00_000000.log', 'First\n'), ('test.log', 'Second\nThird\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_dont_rotate_later_when_ut4')
files      = [('test.2018-10-23_23-30-00_000000.log', 'First\n'), ('test.log', 'Second\nThird\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_rotation_at_midnight_with_date_in_filenametimezone0">test_filesink_rotation.py::test_rotation_at_midnight_with_date_in_filename[timezone0]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_rotation_at_midnight_with_date_in_filename[timezone0]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08385bd0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_at_midnight_with0')
timezone = ('CET', 3600)

    @pytest.mark.parametrize("timezone", [("CET", +3600), ("CET", -3600), ("UTC", 0)])
    def test_rotation_at_midnight_with_date_in_filename(freeze_time, tmp_path, timezone):
        with freeze_time("2018-10-23 23:55:00", timezone) as frozen:
            logger.add(tmp_path / "test.{time:YYYY-MM-DD}.log", format="{message}", rotation="00:00")
            logger.info("First")
            logger.remove()

            frozen.tick(delta=datetime.timedelta(minutes=10))

            logger.add(tmp_path / "test.{time:YYYY-MM-DD}.log", format="{message}", rotation="00:00")
            logger.info("Second")
            logger.remove()

>       check_dir(
            tmp_path,
            files=[
                ("test.2018-10-23.log", "First\n"),
                ("test.2018-10-24.log", "Second\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac08385bd0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac088ea2c0>
timezone   = ('CET', 3600)
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_at_midnight_with0')

tests/test_filesink_rotation.py:691: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_at_midnight_with0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test.2018-10-23.log', 'First\n'), ('test.2018-10-24.log', 'Second\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_at_midnight_with0')
files      = [('test.2018-10-23.log', 'First\n'), ('test.2018-10-24.log', 'Second\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_rotation_at_midnight_with_date_in_filenametimezone1">test_filesink_rotation.py::test_rotation_at_midnight_with_date_in_filename[timezone1]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_rotation_at_midnight_with_date_in_filename[timezone1]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac081ec5e0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_at_midnight_with1')
timezone = ('CET', -3600)

    @pytest.mark.parametrize("timezone", [("CET", +3600), ("CET", -3600), ("UTC", 0)])
    def test_rotation_at_midnight_with_date_in_filename(freeze_time, tmp_path, timezone):
        with freeze_time("2018-10-23 23:55:00", timezone) as frozen:
            logger.add(tmp_path / "test.{time:YYYY-MM-DD}.log", format="{message}", rotation="00:00")
            logger.info("First")
            logger.remove()

            frozen.tick(delta=datetime.timedelta(minutes=10))

            logger.add(tmp_path / "test.{time:YYYY-MM-DD}.log", format="{message}", rotation="00:00")
            logger.info("Second")
            logger.remove()

>       check_dir(
            tmp_path,
            files=[
                ("test.2018-10-23.log", "First\n"),
                ("test.2018-10-24.log", "Second\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac081ec5e0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac083c5210>
timezone   = ('CET', -3600)
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_at_midnight_with1')

tests/test_filesink_rotation.py:691: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_at_midnight_with1')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test.2018-10-23.log', 'First\n'), ('test.2018-10-24.log', 'Second\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_at_midnight_with1')
files      = [('test.2018-10-23.log', 'First\n'), ('test.2018-10-24.log', 'Second\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_rotation_at_midnight_with_date_in_filenametimezone2">test_filesink_rotation.py::test_rotation_at_midnight_with_date_in_filename[timezone2]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_rotation_at_midnight_with_date_in_filename[timezone2]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac081edf30>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_at_midnight_with2')
timezone = ('UTC', 0)

    @pytest.mark.parametrize("timezone", [("CET", +3600), ("CET", -3600), ("UTC", 0)])
    def test_rotation_at_midnight_with_date_in_filename(freeze_time, tmp_path, timezone):
        with freeze_time("2018-10-23 23:55:00", timezone) as frozen:
            logger.add(tmp_path / "test.{time:YYYY-MM-DD}.log", format="{message}", rotation="00:00")
            logger.info("First")
            logger.remove()

            frozen.tick(delta=datetime.timedelta(minutes=10))

            logger.add(tmp_path / "test.{time:YYYY-MM-DD}.log", format="{message}", rotation="00:00")
            logger.info("Second")
            logger.remove()

>       check_dir(
            tmp_path,
            files=[
                ("test.2018-10-23.log", "First\n"),
                ("test.2018-10-24.log", "Second\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac081edf30>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac088e5d20>
timezone   = ('UTC', 0)
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_at_midnight_with2')

tests/test_filesink_rotation.py:691: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_at_midnight_with2')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test.2018-10-23.log', 'First\n'), ('test.2018-10-24.log', 'Second\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_at_midnight_with2')
files      = [('test.2018-10-23.log', 'First\n'), ('test.2018-10-24.log', 'Second\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_reopening_xattr_attributeerrorfalse">test_filesink_rotation.py::test_time_rotation_reopening_xattr_attributeerror[False]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_reopening_xattr_attributeerror[False]</pre></summary><pre>
tmp_path_local = PosixPath('tmp0bc4lgqn')
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08771fc0>
delay = False

    @pytest.mark.parametrize("delay", [False, True])
    @pytest.mark.skipif(
        os.name == "nt"
        or hasattr(os.stat_result, "st_birthtime")
        or not hasattr(os, "setxattr")
        or not hasattr(os, "getxattr"),
        reason="Testing implementation specific to Linux",
    )
    def test_time_rotation_reopening_xattr_attributeerror(tmp_path_local, monkeypatch, delay):
        monkeypatch.delattr(os, "setxattr")
        monkeypatch.delattr(os, "getxattr")
        get_ctime, set_ctime = load_ctime_functions()

        monkeypatch.setattr(loguru._file_sink, "get_ctime", get_ctime)
        monkeypatch.setattr(loguru._file_sink, "set_ctime", set_ctime)

        filepath = tmp_path_local / "test.log"
        i = logger.add(filepath, format="{message}", delay=delay, rotation="2 s")
        time.sleep(1)
        logger.info("1")
        logger.remove(i)
        time.sleep(1.5)
        i = logger.add(filepath, format="{message}", delay=delay, rotation="2 s")
        logger.info("2")
        logger.remove(i)
>       check_dir(tmp_path_local, size=1)

delay      = False
filepath   = PosixPath('tmp0bc4lgqn/test.log')
get_ctime  = <function load_ctime_functions.<locals>.get_ctime at 0x7fac081ec430>
i          = None
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08771fc0>
set_ctime  = <function load_ctime_functions.<locals>.set_ctime at 0x7fac081ed630>
tmp_path_local = PosixPath('tmp0bc4lgqn')

tests/test_filesink_rotation.py:774: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('tmp0bc4lgqn')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           assert 0 == 1
E            +  where 0 = len(set())

actual_files = set()
dir        = PosixPath('tmp0bc4lgqn')
files      = None
seen       = set()
size       = 1

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_reopening_xattr_attributeerrortrue">test_filesink_rotation.py::test_time_rotation_reopening_xattr_attributeerror[True]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_reopening_xattr_attributeerror[True]</pre></summary><pre>
tmp_path_local = PosixPath('tmpswlcz772')
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac093223b0>
delay = True

    @pytest.mark.parametrize("delay", [False, True])
    @pytest.mark.skipif(
        os.name == "nt"
        or hasattr(os.stat_result, "st_birthtime")
        or not hasattr(os, "setxattr")
        or not hasattr(os, "getxattr"),
        reason="Testing implementation specific to Linux",
    )
    def test_time_rotation_reopening_xattr_attributeerror(tmp_path_local, monkeypatch, delay):
        monkeypatch.delattr(os, "setxattr")
        monkeypatch.delattr(os, "getxattr")
        get_ctime, set_ctime = load_ctime_functions()

        monkeypatch.setattr(loguru._file_sink, "get_ctime", get_ctime)
        monkeypatch.setattr(loguru._file_sink, "set_ctime", set_ctime)

        filepath = tmp_path_local / "test.log"
        i = logger.add(filepath, format="{message}", delay=delay, rotation="2 s")
        time.sleep(1)
        logger.info("1")
        logger.remove(i)
        time.sleep(1.5)
        i = logger.add(filepath, format="{message}", delay=delay, rotation="2 s")
        logger.info("2")
        logger.remove(i)
>       check_dir(tmp_path_local, size=1)

delay      = True
filepath   = PosixPath('tmpswlcz772/test.log')
get_ctime  = <function load_ctime_functions.<locals>.get_ctime at 0x7fac081ede10>
i          = None
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac093223b0>
set_ctime  = <function load_ctime_functions.<locals>.set_ctime at 0x7fac081ed120>
tmp_path_local = PosixPath('tmpswlcz772')

tests/test_filesink_rotation.py:774: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('tmpswlcz772')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           assert 0 == 1
E            +  where 0 = len(set())

actual_files = set()
dir        = PosixPath('tmpswlcz772')
files      = None
seen       = set()
size       = 1

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_reopening_xattr_oserrorfalse">test_filesink_rotation.py::test_time_rotation_reopening_xattr_oserror[False]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_reopening_xattr_oserror[False]</pre></summary><pre>
tmp_path_local = PosixPath('tmpmu5odrao')
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08704d00>
delay = False

    @pytest.mark.parametrize("delay", [False, True])
    @pytest.mark.skipif(
        os.name == "nt"
        or hasattr(os.stat_result, "st_birthtime")
        or not hasattr(os, "setxattr")
        or not hasattr(os, "getxattr"),
        reason="Testing implementation specific to Linux",
    )
    def test_time_rotation_reopening_xattr_oserror(tmp_path_local, monkeypatch, delay):
        monkeypatch.setattr(os, "setxattr", Mock(side_effect=OSError))
        monkeypatch.setattr(os, "getxattr", Mock(side_effect=OSError))
        get_ctime, set_ctime = load_ctime_functions()

        monkeypatch.setattr(loguru._file_sink, "get_ctime", get_ctime)
        monkeypatch.setattr(loguru._file_sink, "set_ctime", set_ctime)

        filepath = tmp_path_local / "test.log"
        i = logger.add(filepath, format="{message}", delay=delay, rotation="2 s")
        time.sleep(1)
        logger.info("1")
        logger.remove(i)
        time.sleep(1.5)
        i = logger.add(filepath, format="{message}", delay=delay, rotation="2 s")
        logger.info("2")
        logger.remove(i)
>       check_dir(tmp_path_local, size=1)

delay      = False
filepath   = PosixPath('tmpmu5odrao/test.log')
get_ctime  = <function load_ctime_functions.<locals>.get_ctime at 0x7fac081ecd30>
i          = None
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08704d00>
set_ctime  = <function load_ctime_functions.<locals>.set_ctime at 0x7fac081ee5f0>
tmp_path_local = PosixPath('tmpmu5odrao')

tests/test_filesink_rotation.py:809: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('tmpmu5odrao')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           assert 0 == 1
E            +  where 0 = len(set())

actual_files = set()
dir        = PosixPath('tmpmu5odrao')
files      = None
seen       = set()
size       = 1

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_time_rotation_reopening_xattr_oserrortrue">test_filesink_rotation.py::test_time_rotation_reopening_xattr_oserror[True]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_time_rotation_reopening_xattr_oserror[True]</pre></summary><pre>
tmp_path_local = PosixPath('tmpjyysvo7a')
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08255870>
delay = True

    @pytest.mark.parametrize("delay", [False, True])
    @pytest.mark.skipif(
        os.name == "nt"
        or hasattr(os.stat_result, "st_birthtime")
        or not hasattr(os, "setxattr")
        or not hasattr(os, "getxattr"),
        reason="Testing implementation specific to Linux",
    )
    def test_time_rotation_reopening_xattr_oserror(tmp_path_local, monkeypatch, delay):
        monkeypatch.setattr(os, "setxattr", Mock(side_effect=OSError))
        monkeypatch.setattr(os, "getxattr", Mock(side_effect=OSError))
        get_ctime, set_ctime = load_ctime_functions()

        monkeypatch.setattr(loguru._file_sink, "get_ctime", get_ctime)
        monkeypatch.setattr(loguru._file_sink, "set_ctime", set_ctime)

        filepath = tmp_path_local / "test.log"
        i = logger.add(filepath, format="{message}", delay=delay, rotation="2 s")
        time.sleep(1)
        logger.info("1")
        logger.remove(i)
        time.sleep(1.5)
        i = logger.add(filepath, format="{message}", delay=delay, rotation="2 s")
        logger.info("2")
        logger.remove(i)
>       check_dir(tmp_path_local, size=1)

delay      = True
filepath   = PosixPath('tmpjyysvo7a/test.log')
get_ctime  = <function load_ctime_functions.<locals>.get_ctime at 0x7fac08386cb0>
i          = None
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac08255870>
set_ctime  = <function load_ctime_functions.<locals>.set_ctime at 0x7fac08386b00>
tmp_path_local = PosixPath('tmpjyysvo7a')

tests/test_filesink_rotation.py:809: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('tmpjyysvo7a')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           assert 0 == 1
E            +  where 0 = len(set())

actual_files = set()
dir        = PosixPath('tmpjyysvo7a')
files      = None
seen       = set()
size       = 1

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_function_rotation">test_filesink_rotation.py::test_function_rotation</h3>
<details><summary> <pre>test_filesink_rotation.py::test_function_rotation</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac081ee7a0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_function_rotation0')

    def test_function_rotation(freeze_time, tmp_path):
        with freeze_time("2018-01-01 00:00:00") as frozen:
            logger.add(
                tmp_path / "test_{time}.log",
                rotation=Mock(side_effect=[False, True, False]),
                format="{message}",
            )
            logger.debug("a")
>           check_dir(tmp_path, files=[("test_2018-01-01_00-00-00_000000.log", "a\n")])

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac081ee7a0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08395f60>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_function_rotation0')

tests/test_filesink_rotation.py:871: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_function_rotation0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('test_2018-01-01_00-00-00_000000.log', 'a\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_function_rotation0')
files      = [('test_2018-01-01_00-00-00_000000.log', 'a\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_rotation_at_removew">test_filesink_rotation.py::test_rotation_at_remove[w]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_rotation_at_remove[w]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac081ee950>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_at_remove_w_0')
mode = 'w'

    @pytest.mark.parametrize("mode", ["w", "x"])
    def test_rotation_at_remove(freeze_time, tmp_path, mode):
        with freeze_time("2018-01-01"):
            i = logger.add(
                tmp_path / "test_{time:YYYY}.log",
                rotation="10 MB",
                mode=mode,
                format="{message}",
            )
            logger.debug("test")
            logger.remove(i)

>       check_dir(tmp_path, files=[("test_2018.log", "test\n")])

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac081ee950>
i          = None
mode       = 'w'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_at_remove_w_0')

tests/test_filesink_rotation.py:906: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_at_remove_w_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('test_2018.log', 'test\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_at_remove_w_0')
files      = [('test_2018.log', 'test\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_rotation_at_removex">test_filesink_rotation.py::test_rotation_at_remove[x]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_rotation_at_remove[x]</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac081eec20>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_at_remove_x_0')
mode = 'x'

    @pytest.mark.parametrize("mode", ["w", "x"])
    def test_rotation_at_remove(freeze_time, tmp_path, mode):
        with freeze_time("2018-01-01"):
            i = logger.add(
                tmp_path / "test_{time:YYYY}.log",
                rotation="10 MB",
                mode=mode,
                format="{message}",
            )
            logger.debug("test")
            logger.remove(i)

>       check_dir(tmp_path, files=[("test_2018.log", "test\n")])

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac081eec20>
i          = None
mode       = 'x'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_at_remove_x_0')

tests/test_filesink_rotation.py:906: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_at_remove_x_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('test_2018.log', 'test\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_rotation_at_remove_x_0')
files      = [('test_2018.log', 'test\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_no_rotation_at_removea">test_filesink_rotation.py::test_no_rotation_at_remove[a]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_no_rotation_at_remove[a]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_rotation_at_remove_a_0')
mode = 'a'

    @pytest.mark.parametrize("mode", ["a", "a+"])
    def test_no_rotation_at_remove(tmp_path, mode):
        i = logger.add(tmp_path / "test.log", rotation="10 MB", mode=mode, format="{message}")
        logger.debug("test")
        logger.remove(i)

>       check_dir(tmp_path, files=[("test.log", "test\n")])

i          = None
mode       = 'a'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_rotation_at_remove_a_0')

tests/test_filesink_rotation.py:915: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_rotation_at_remove_a_0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('test.log', 'test\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_rotation_at_remove_a_0')
files      = [('test.log', 'test\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_no_rotation_at_removea_1">test_filesink_rotation.py::test_no_rotation_at_remove[a+]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_no_rotation_at_remove[a+]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_rotation_at_remove_a__0')
mode = 'a+'

    @pytest.mark.parametrize("mode", ["a", "a+"])
    def test_no_rotation_at_remove(tmp_path, mode):
        i = logger.add(tmp_path / "test.log", rotation="10 MB", mode=mode, format="{message}")
        logger.debug("test")
        logger.remove(i)

>       check_dir(tmp_path, files=[("test.log", "test\n")])

i          = None
mode       = 'a+'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_rotation_at_remove_a__0')

tests/test_filesink_rotation.py:915: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_rotation_at_remove_a__0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('test.log', 'test\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_rotation_at_remove_a__0')
files      = [('test.log', 'test\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_rename_existing_with_creation_time">test_filesink_rotation.py::test_rename_existing_with_creation_time</h3>
<details><summary> <pre>test_filesink_rotation.py::test_rename_existing_with_creation_time</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac081ef7f0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_rename_existing_with_crea1')

    def test_rename_existing_with_creation_time(freeze_time, tmp_path):
        with freeze_time("2018-01-01") as frozen:
            logger.add(tmp_path / "test.log", rotation=10, format="{message}")
            logger.debug("X")
            frozen.tick()
            logger.debug("Y" * 20)

>       check_dir(
            tmp_path,
            files=[
                ("test.2018-01-01_00-00-00_000000.log", "X\n"),
                ("test.log", "Y" * 20 + "\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac081ef7f0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac09303d90>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_rename_existing_with_crea1')

tests/test_filesink_rotation.py:925: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_rename_existing_with_crea1')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 2
E            +  where 0 = len(set())
E            +  and   2 = len([('test.2018-01-01_00-00-00_000000.log', 'X\n'), ('test.log', 'YYYYYYYYYYYYYYYYYYYY\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_rename_existing_with_crea1')
files      = [('test.2018-01-01_00-00-00_000000.log', 'X\n'), ('test.log', 'YYYYYYYYYYYYYYYYYYYY\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_renaming_rotation_dest_exists">test_filesink_rotation.py::test_renaming_rotation_dest_exists</h3>
<details><summary> <pre>test_filesink_rotation.py::test_renaming_rotation_dest_exists</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac081efac0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_renaming_rotation_dest_ex0')

    def test_renaming_rotation_dest_exists(freeze_time, tmp_path):
        with freeze_time("2019-01-02 03:04:05.000006"):
            logger.add(tmp_path / "rotate.log", rotation=Mock(return_value=True), format="{message}")
            logger.info("A")
            logger.info("B")
            logger.info("C")

>       check_dir(
            tmp_path,
            files=[
                ("rotate.2019-01-02_03-04-05_000006.log", ""),
                ("rotate.2019-01-02_03-04-05_000006.2.log", "A\n"),
                ("rotate.2019-01-02_03-04-05_000006.3.log", "B\n"),
                ("rotate.log", "C\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac081efac0>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_renaming_rotation_dest_ex0')

tests/test_filesink_rotation.py:941: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_renaming_rotation_dest_ex0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 4
E            +  where 0 = len(set())
E            +  and   4 = len([('rotate.2019-01-02_03-04-05_000006.log', ''), ('rotate.2019-01-02_03-04-05_000006.2.log', 'A\n'), ('rotate.2019-01-02_03-04-05_000006.3.log', 'B\n'), ('rotate.log', 'C\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_renaming_rotation_dest_ex0')
files      = [('rotate.2019-01-02_03-04-05_000006.log', ''), ('rotate.2019-01-02_03-04-05_000006.2.log', 'A\n'), ('rotate.2019-01-02_03-04-05_000006.3.log', 'B\n'), ('rotate.log', 'C\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_renaming_rotation_dest_exists_with_time">test_filesink_rotation.py::test_renaming_rotation_dest_exists_with_time</h3>
<details><summary> <pre>test_filesink_rotation.py::test_renaming_rotation_dest_exists_with_time</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac081eeb00>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_renaming_rotation_dest_ex1')

    def test_renaming_rotation_dest_exists_with_time(freeze_time, tmp_path):
        with freeze_time("2019-01-02 03:04:05.000006"):
            logger.add(
                tmp_path / "rotate.{time}.log", rotation=Mock(return_value=True), format="{message}"
            )
            logger.info("A")
            logger.info("B")
            logger.info("C")

>       check_dir(
            tmp_path,
            files=[
                ("rotate.2019-01-02_03-04-05_000006.2019-01-02_03-04-05_000006.log", ""),
                ("rotate.2019-01-02_03-04-05_000006.2019-01-02_03-04-05_000006.2.log", "A\n"),
                ("rotate.2019-01-02_03-04-05_000006.2019-01-02_03-04-05_000006.3.log", "B\n"),
                ("rotate.2019-01-02_03-04-05_000006.log", "C\n"),
            ],
        )

freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac081eeb00>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_renaming_rotation_dest_ex1')

tests/test_filesink_rotation.py:961: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_renaming_rotation_dest_ex1')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 4
E            +  where 0 = len(set())
E            +  and   4 = len([('rotate.2019-01-02_03-04-05_000006.2019-01-02_03-04-05_000006.log', ''), ('rotate.2019-01-02_03-04-05_000006.2019-01...2019-01-02_03-04-05_000006.2019-01-02_03-04-05_000006.3.log', 'B\n'), ('rotate.2019-01-02_03-04-05_000006.log', 'C\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_renaming_rotation_dest_ex1')
files      = [('rotate.2019-01-02_03-04-05_000006.2019-01-02_03-04-05_000006.log', ''), ('rotate.2019-01-02_03-04-05_000006.2019-01...2019-01-02_03-04-05_000006.2019-01-02_03-04-05_000006.3.log', 'B\n'), ('rotate.2019-01-02_03-04-05_000006.log', 'C\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_exception_during_rotation">test_filesink_rotation.py::test_exception_during_rotation</h3>
<details><summary> <pre>test_filesink_rotation.py::test_exception_during_rotation</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_rotation0')
capsys = <_pytest.capture.CaptureFixture object at 0x7fac09312110>

    def test_exception_during_rotation(tmp_path, capsys):
        logger.add(
            tmp_path / "test.log",
            rotation=Mock(side_effect=[Exception("Rotation error"), False]),
            format="{message}",
            catch=True,
        )

        logger.info("A")
        logger.info("B")

>       check_dir(tmp_path, files=[("test.log", "B\n")])

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac09312110>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_rotation0')

tests/test_filesink_rotation.py:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_rotation0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 1
E            +  where 0 = len(set())
E            +  and   1 = len([('test.log', 'B\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_rotation0')
files      = [('test.log', 'B\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_exception_during_rotation_not_caught">test_filesink_rotation.py::test_exception_during_rotation_not_caught</h3>
<details><summary> <pre>test_filesink_rotation.py::test_exception_during_rotation_not_caught</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_rotation1')
capsys = <_pytest.capture.CaptureFixture object at 0x7fac088f0f70>

    def test_exception_during_rotation_not_caught(tmp_path, capsys):
        logger.add(
            tmp_path / "test.log",
            rotation=Mock(side_effect=[OSError("Rotation error"), False]),
            format="{message}",
            catch=False,
        )

>       with pytest.raises(OSError, match=r"Rotation error"):
E       Failed: DID NOT RAISE <class 'OSError'>

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac088f0f70>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_during_rotation1')

tests/test_filesink_rotation.py:999: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_recipe_rotation_both_size_and_time">test_filesink_rotation.py::test_recipe_rotation_both_size_and_time</h3>
<details><summary> <pre>test_filesink_rotation.py::test_recipe_rotation_both_size_and_time</pre></summary><pre>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac081ec1f0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_recipe_rotation_both_size0')

    def test_recipe_rotation_both_size_and_time(freeze_time, tmp_path):
        class Rotator:
            def __init__(self, *, size, at):
                now = datetime.datetime.now()

                self._size_limit = size
                self._time_limit = now.replace(hour=at.hour, minute=at.minute, second=at.second)

                if now >= self._time_limit:
                    # The current time is already past the target time so it would rotate already.
                    # Add one day to prevent an immediate rotation.
                    self._time_limit += datetime.timedelta(days=1)

            def should_rotate(self, message, file):
                file.seek(0, 2)
                if file.tell() + len(message) > self._size_limit:
                    return True
                excess = message.record["time"].timestamp() - self._time_limit.timestamp()
                if excess >= 0:
                    elapsed_days = datetime.timedelta(seconds=excess).days
                    self._time_limit += datetime.timedelta(days=elapsed_days + 1)
                    return True
                return False

        with freeze_time("2020-01-01 20:00:00") as frozen:
            rotator = Rotator(size=20, at=datetime.time(12, 0, 0))
            logger.add(tmp_path / "file.log", rotation=rotator.should_rotate, format="{message}")
            logger.info("A" * 15)
            frozen.tick()
            logger.info("B" * 10)
            frozen.move_to("2020-01-02 13:00:00")
            logger.info("C")
            frozen.move_to("2020-01-10 13:10:00")
            logger.info("D")
            logger.info("E")

>       check_dir(
            tmp_path,
            files=[
                ("file.2020-01-01_20-00-00_000000.log", "A" * 15 + "\n"),
                ("file.2020-01-01_20-00-01_000000.log", "B" * 10 + "\n"),
                ("file.2020-01-02_13-00-00_000000.log", "C\n"),
                ("file.log", "D\nE\n"),
            ],
        )

Rotator    = <class 'tests.test_filesink_rotation.test_recipe_rotation_both_size_and_time.<locals>.Rotator'>
freeze_time = <function freeze_time.<locals>.freeze_time at 0x7fac081ec1f0>
frozen     = <freezegun.api.FrozenDateTimeFactory object at 0x7fac08381d20>
rotator    = <tests.test_filesink_rotation.test_recipe_rotation_both_size_and_time.<locals>.Rotator object at 0x7fac08383af0>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_recipe_rotation_both_size0')

tests/test_filesink_rotation.py:1046: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_recipe_rotation_both_size0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
            assert len(actual_files) == size
        if files is not None:
>           assert len(actual_files) == len(files)
E           AssertionError: assert 0 == 4
E            +  where 0 = len(set())
E            +  and   4 = len([('file.2020-01-01_20-00-00_000000.log', 'AAAAAAAAAAAAAAA\n'), ('file.2020-01-01_20-00-01_000000.log', 'BBBBBBBBBB\n'), ('file.2020-01-02_13-00-00_000000.log', 'C\n'), ('file.log', 'D\nE\n')])

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_recipe_rotation_both_size0')
files      = [('file.2020-01-01_20-00-00_000000.log', 'AAAAAAAAAAAAAAA\n'), ('file.2020-01-01_20-00-01_000000.log', 'BBBBBBBBBB\n'), ('file.2020-01-02_13-00-00_000000.log', 'C\n'), ('file.log', 'D\nE\n')]
seen       = set()
size       = None

tests/conftest.py:67: AssertionError
</pre>
</details>
<h3 id="test_filesink_rotationpytest_invalid_rotationrotation0">test_filesink_rotation.py::test_invalid_rotation[rotation0]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_invalid_rotation[rotation0]</pre></summary><pre>
rotation = <object object at 0x7fac0bf24b20>

    @pytest.mark.parametrize(
        "rotation", [object(), os, datetime.date(2017, 11, 11), datetime.datetime.now(), 1j]
    )
    def test_invalid_rotation(rotation):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

rotation   = <object object at 0x7fac0bf24b20>

tests/test_filesink_rotation.py:1061: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_invalid_rotationos">test_filesink_rotation.py::test_invalid_rotation[os]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_invalid_rotation[os]</pre></summary><pre>
rotation = <module 'os' from '/usr/lib/python3.10/os.py'>

    @pytest.mark.parametrize(
        "rotation", [object(), os, datetime.date(2017, 11, 11), datetime.datetime.now(), 1j]
    )
    def test_invalid_rotation(rotation):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

rotation   = <module 'os' from '/usr/lib/python3.10/os.py'>

tests/test_filesink_rotation.py:1061: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_invalid_rotationrotation2">test_filesink_rotation.py::test_invalid_rotation[rotation2]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_invalid_rotation[rotation2]</pre></summary><pre>
rotation = datetime.date(2017, 11, 11)

    @pytest.mark.parametrize(
        "rotation", [object(), os, datetime.date(2017, 11, 11), datetime.datetime.now(), 1j]
    )
    def test_invalid_rotation(rotation):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

rotation   = datetime.date(2017, 11, 11)

tests/test_filesink_rotation.py:1061: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_invalid_rotationrotation3">test_filesink_rotation.py::test_invalid_rotation[rotation3]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_invalid_rotation[rotation3]</pre></summary><pre>
rotation = datetime.datetime(2024, 11, 29, 4, 33, 21, 593677)

    @pytest.mark.parametrize(
        "rotation", [object(), os, datetime.date(2017, 11, 11), datetime.datetime.now(), 1j]
    )
    def test_invalid_rotation(rotation):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

rotation   = datetime.datetime(2024, 11, 29, 4, 33, 21, 593677)

tests/test_filesink_rotation.py:1061: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_invalid_rotation1j">test_filesink_rotation.py::test_invalid_rotation[1j]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_invalid_rotation[1j]</pre></summary><pre>
rotation = 1j

    @pytest.mark.parametrize(
        "rotation", [object(), os, datetime.date(2017, 11, 11), datetime.datetime.now(), 1j]
    )
    def test_invalid_rotation(rotation):
>       with pytest.raises(TypeError):
E       Failed: DID NOT RAISE <class 'TypeError'>

rotation   = 1j

tests/test_filesink_rotation.py:1061: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_unknown_rotationw7">test_filesink_rotation.py::test_unknown_rotation[w7]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_unknown_rotation[w7]</pre></summary><pre>
rotation = 'w7'

    @pytest.mark.parametrize(
        "rotation",
        [
            "w7",
            "w10",
            "w-1",
            "h",
            "M",
            "w1at13",
            "www",
            "13 at w2",
            "w",
            "K",
            "tufy MB",
            "111.111.111 kb",
            "3 Ki",
            "2017.11.12",
            "11:99",
            "01:00:00!UTC",
            "monday at 2017",
            "e days",
            "2 days 8 pouooi",
            "foobar",
            "w5 at [not|a|time]",
            "[not|a|day] at 12:00",
            "__dict__",
        ],
    )
    def test_unknown_rotation(rotation):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

rotation   = 'w7'

tests/test_filesink_rotation.py:1094: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_unknown_rotationw10">test_filesink_rotation.py::test_unknown_rotation[w10]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_unknown_rotation[w10]</pre></summary><pre>
rotation = 'w10'

    @pytest.mark.parametrize(
        "rotation",
        [
            "w7",
            "w10",
            "w-1",
            "h",
            "M",
            "w1at13",
            "www",
            "13 at w2",
            "w",
            "K",
            "tufy MB",
            "111.111.111 kb",
            "3 Ki",
            "2017.11.12",
            "11:99",
            "01:00:00!UTC",
            "monday at 2017",
            "e days",
            "2 days 8 pouooi",
            "foobar",
            "w5 at [not|a|time]",
            "[not|a|day] at 12:00",
            "__dict__",
        ],
    )
    def test_unknown_rotation(rotation):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

rotation   = 'w10'

tests/test_filesink_rotation.py:1094: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_unknown_rotationw-1">test_filesink_rotation.py::test_unknown_rotation[w-1]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_unknown_rotation[w-1]</pre></summary><pre>
rotation = 'w-1'

    @pytest.mark.parametrize(
        "rotation",
        [
            "w7",
            "w10",
            "w-1",
            "h",
            "M",
            "w1at13",
            "www",
            "13 at w2",
            "w",
            "K",
            "tufy MB",
            "111.111.111 kb",
            "3 Ki",
            "2017.11.12",
            "11:99",
            "01:00:00!UTC",
            "monday at 2017",
            "e days",
            "2 days 8 pouooi",
            "foobar",
            "w5 at [not|a|time]",
            "[not|a|day] at 12:00",
            "__dict__",
        ],
    )
    def test_unknown_rotation(rotation):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

rotation   = 'w-1'

tests/test_filesink_rotation.py:1094: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_unknown_rotationh">test_filesink_rotation.py::test_unknown_rotation[h]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_unknown_rotation[h]</pre></summary><pre>
rotation = 'h'

    @pytest.mark.parametrize(
        "rotation",
        [
            "w7",
            "w10",
            "w-1",
            "h",
            "M",
            "w1at13",
            "www",
            "13 at w2",
            "w",
            "K",
            "tufy MB",
            "111.111.111 kb",
            "3 Ki",
            "2017.11.12",
            "11:99",
            "01:00:00!UTC",
            "monday at 2017",
            "e days",
            "2 days 8 pouooi",
            "foobar",
            "w5 at [not|a|time]",
            "[not|a|day] at 12:00",
            "__dict__",
        ],
    )
    def test_unknown_rotation(rotation):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

rotation   = 'h'

tests/test_filesink_rotation.py:1094: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_unknown_rotationm">test_filesink_rotation.py::test_unknown_rotation[M]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_unknown_rotation[M]</pre></summary><pre>
rotation = 'M'

    @pytest.mark.parametrize(
        "rotation",
        [
            "w7",
            "w10",
            "w-1",
            "h",
            "M",
            "w1at13",
            "www",
            "13 at w2",
            "w",
            "K",
            "tufy MB",
            "111.111.111 kb",
            "3 Ki",
            "2017.11.12",
            "11:99",
            "01:00:00!UTC",
            "monday at 2017",
            "e days",
            "2 days 8 pouooi",
            "foobar",
            "w5 at [not|a|time]",
            "[not|a|day] at 12:00",
            "__dict__",
        ],
    )
    def test_unknown_rotation(rotation):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

rotation   = 'M'

tests/test_filesink_rotation.py:1094: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_unknown_rotationw1at13">test_filesink_rotation.py::test_unknown_rotation[w1at13]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_unknown_rotation[w1at13]</pre></summary><pre>
rotation = 'w1at13'

    @pytest.mark.parametrize(
        "rotation",
        [
            "w7",
            "w10",
            "w-1",
            "h",
            "M",
            "w1at13",
            "www",
            "13 at w2",
            "w",
            "K",
            "tufy MB",
            "111.111.111 kb",
            "3 Ki",
            "2017.11.12",
            "11:99",
            "01:00:00!UTC",
            "monday at 2017",
            "e days",
            "2 days 8 pouooi",
            "foobar",
            "w5 at [not|a|time]",
            "[not|a|day] at 12:00",
            "__dict__",
        ],
    )
    def test_unknown_rotation(rotation):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

rotation   = 'w1at13'

tests/test_filesink_rotation.py:1094: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_unknown_rotationwww">test_filesink_rotation.py::test_unknown_rotation[www]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_unknown_rotation[www]</pre></summary><pre>
rotation = 'www'

    @pytest.mark.parametrize(
        "rotation",
        [
            "w7",
            "w10",
            "w-1",
            "h",
            "M",
            "w1at13",
            "www",
            "13 at w2",
            "w",
            "K",
            "tufy MB",
            "111.111.111 kb",
            "3 Ki",
            "2017.11.12",
            "11:99",
            "01:00:00!UTC",
            "monday at 2017",
            "e days",
            "2 days 8 pouooi",
            "foobar",
            "w5 at [not|a|time]",
            "[not|a|day] at 12:00",
            "__dict__",
        ],
    )
    def test_unknown_rotation(rotation):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

rotation   = 'www'

tests/test_filesink_rotation.py:1094: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_unknown_rotation13-at-w2">test_filesink_rotation.py::test_unknown_rotation[13 at w2]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_unknown_rotation[13 at w2]</pre></summary><pre>
rotation = '13 at w2'

    @pytest.mark.parametrize(
        "rotation",
        [
            "w7",
            "w10",
            "w-1",
            "h",
            "M",
            "w1at13",
            "www",
            "13 at w2",
            "w",
            "K",
            "tufy MB",
            "111.111.111 kb",
            "3 Ki",
            "2017.11.12",
            "11:99",
            "01:00:00!UTC",
            "monday at 2017",
            "e days",
            "2 days 8 pouooi",
            "foobar",
            "w5 at [not|a|time]",
            "[not|a|day] at 12:00",
            "__dict__",
        ],
    )
    def test_unknown_rotation(rotation):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

rotation   = '13 at w2'

tests/test_filesink_rotation.py:1094: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_unknown_rotationw">test_filesink_rotation.py::test_unknown_rotation[w]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_unknown_rotation[w]</pre></summary><pre>
rotation = 'w'

    @pytest.mark.parametrize(
        "rotation",
        [
            "w7",
            "w10",
            "w-1",
            "h",
            "M",
            "w1at13",
            "www",
            "13 at w2",
            "w",
            "K",
            "tufy MB",
            "111.111.111 kb",
            "3 Ki",
            "2017.11.12",
            "11:99",
            "01:00:00!UTC",
            "monday at 2017",
            "e days",
            "2 days 8 pouooi",
            "foobar",
            "w5 at [not|a|time]",
            "[not|a|day] at 12:00",
            "__dict__",
        ],
    )
    def test_unknown_rotation(rotation):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

rotation   = 'w'

tests/test_filesink_rotation.py:1094: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_unknown_rotationk">test_filesink_rotation.py::test_unknown_rotation[K]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_unknown_rotation[K]</pre></summary><pre>
rotation = 'K'

    @pytest.mark.parametrize(
        "rotation",
        [
            "w7",
            "w10",
            "w-1",
            "h",
            "M",
            "w1at13",
            "www",
            "13 at w2",
            "w",
            "K",
            "tufy MB",
            "111.111.111 kb",
            "3 Ki",
            "2017.11.12",
            "11:99",
            "01:00:00!UTC",
            "monday at 2017",
            "e days",
            "2 days 8 pouooi",
            "foobar",
            "w5 at [not|a|time]",
            "[not|a|day] at 12:00",
            "__dict__",
        ],
    )
    def test_unknown_rotation(rotation):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

rotation   = 'K'

tests/test_filesink_rotation.py:1094: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_unknown_rotationtufy-mb">test_filesink_rotation.py::test_unknown_rotation[tufy MB]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_unknown_rotation[tufy MB]</pre></summary><pre>
rotation = 'tufy MB'

    @pytest.mark.parametrize(
        "rotation",
        [
            "w7",
            "w10",
            "w-1",
            "h",
            "M",
            "w1at13",
            "www",
            "13 at w2",
            "w",
            "K",
            "tufy MB",
            "111.111.111 kb",
            "3 Ki",
            "2017.11.12",
            "11:99",
            "01:00:00!UTC",
            "monday at 2017",
            "e days",
            "2 days 8 pouooi",
            "foobar",
            "w5 at [not|a|time]",
            "[not|a|day] at 12:00",
            "__dict__",
        ],
    )
    def test_unknown_rotation(rotation):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

rotation   = 'tufy MB'

tests/test_filesink_rotation.py:1094: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_unknown_rotation111111111-kb">test_filesink_rotation.py::test_unknown_rotation[111.111.111 kb]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_unknown_rotation[111.111.111 kb]</pre></summary><pre>
rotation = '111.111.111 kb'

    @pytest.mark.parametrize(
        "rotation",
        [
            "w7",
            "w10",
            "w-1",
            "h",
            "M",
            "w1at13",
            "www",
            "13 at w2",
            "w",
            "K",
            "tufy MB",
            "111.111.111 kb",
            "3 Ki",
            "2017.11.12",
            "11:99",
            "01:00:00!UTC",
            "monday at 2017",
            "e days",
            "2 days 8 pouooi",
            "foobar",
            "w5 at [not|a|time]",
            "[not|a|day] at 12:00",
            "__dict__",
        ],
    )
    def test_unknown_rotation(rotation):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

rotation   = '111.111.111 kb'

tests/test_filesink_rotation.py:1094: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_unknown_rotation3-ki">test_filesink_rotation.py::test_unknown_rotation[3 Ki]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_unknown_rotation[3 Ki]</pre></summary><pre>
rotation = '3 Ki'

    @pytest.mark.parametrize(
        "rotation",
        [
            "w7",
            "w10",
            "w-1",
            "h",
            "M",
            "w1at13",
            "www",
            "13 at w2",
            "w",
            "K",
            "tufy MB",
            "111.111.111 kb",
            "3 Ki",
            "2017.11.12",
            "11:99",
            "01:00:00!UTC",
            "monday at 2017",
            "e days",
            "2 days 8 pouooi",
            "foobar",
            "w5 at [not|a|time]",
            "[not|a|day] at 12:00",
            "__dict__",
        ],
    )
    def test_unknown_rotation(rotation):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

rotation   = '3 Ki'

tests/test_filesink_rotation.py:1094: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_unknown_rotation20171112">test_filesink_rotation.py::test_unknown_rotation[2017.11.12]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_unknown_rotation[2017.11.12]</pre></summary><pre>
rotation = '2017.11.12'

    @pytest.mark.parametrize(
        "rotation",
        [
            "w7",
            "w10",
            "w-1",
            "h",
            "M",
            "w1at13",
            "www",
            "13 at w2",
            "w",
            "K",
            "tufy MB",
            "111.111.111 kb",
            "3 Ki",
            "2017.11.12",
            "11:99",
            "01:00:00!UTC",
            "monday at 2017",
            "e days",
            "2 days 8 pouooi",
            "foobar",
            "w5 at [not|a|time]",
            "[not|a|day] at 12:00",
            "__dict__",
        ],
    )
    def test_unknown_rotation(rotation):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

rotation   = '2017.11.12'

tests/test_filesink_rotation.py:1094: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_unknown_rotation1199">test_filesink_rotation.py::test_unknown_rotation[11:99]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_unknown_rotation[11:99]</pre></summary><pre>
rotation = '11:99'

    @pytest.mark.parametrize(
        "rotation",
        [
            "w7",
            "w10",
            "w-1",
            "h",
            "M",
            "w1at13",
            "www",
            "13 at w2",
            "w",
            "K",
            "tufy MB",
            "111.111.111 kb",
            "3 Ki",
            "2017.11.12",
            "11:99",
            "01:00:00!UTC",
            "monday at 2017",
            "e days",
            "2 days 8 pouooi",
            "foobar",
            "w5 at [not|a|time]",
            "[not|a|day] at 12:00",
            "__dict__",
        ],
    )
    def test_unknown_rotation(rotation):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

rotation   = '11:99'

tests/test_filesink_rotation.py:1094: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_unknown_rotation010000utc">test_filesink_rotation.py::test_unknown_rotation[01:00:00!UTC]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_unknown_rotation[01:00:00!UTC]</pre></summary><pre>
rotation = '01:00:00!UTC'

    @pytest.mark.parametrize(
        "rotation",
        [
            "w7",
            "w10",
            "w-1",
            "h",
            "M",
            "w1at13",
            "www",
            "13 at w2",
            "w",
            "K",
            "tufy MB",
            "111.111.111 kb",
            "3 Ki",
            "2017.11.12",
            "11:99",
            "01:00:00!UTC",
            "monday at 2017",
            "e days",
            "2 days 8 pouooi",
            "foobar",
            "w5 at [not|a|time]",
            "[not|a|day] at 12:00",
            "__dict__",
        ],
    )
    def test_unknown_rotation(rotation):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

rotation   = '01:00:00!UTC'

tests/test_filesink_rotation.py:1094: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_unknown_rotationmonday-at-2017">test_filesink_rotation.py::test_unknown_rotation[monday at 2017]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_unknown_rotation[monday at 2017]</pre></summary><pre>
rotation = 'monday at 2017'

    @pytest.mark.parametrize(
        "rotation",
        [
            "w7",
            "w10",
            "w-1",
            "h",
            "M",
            "w1at13",
            "www",
            "13 at w2",
            "w",
            "K",
            "tufy MB",
            "111.111.111 kb",
            "3 Ki",
            "2017.11.12",
            "11:99",
            "01:00:00!UTC",
            "monday at 2017",
            "e days",
            "2 days 8 pouooi",
            "foobar",
            "w5 at [not|a|time]",
            "[not|a|day] at 12:00",
            "__dict__",
        ],
    )
    def test_unknown_rotation(rotation):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

rotation   = 'monday at 2017'

tests/test_filesink_rotation.py:1094: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_unknown_rotatione-days">test_filesink_rotation.py::test_unknown_rotation[e days]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_unknown_rotation[e days]</pre></summary><pre>
rotation = 'e days'

    @pytest.mark.parametrize(
        "rotation",
        [
            "w7",
            "w10",
            "w-1",
            "h",
            "M",
            "w1at13",
            "www",
            "13 at w2",
            "w",
            "K",
            "tufy MB",
            "111.111.111 kb",
            "3 Ki",
            "2017.11.12",
            "11:99",
            "01:00:00!UTC",
            "monday at 2017",
            "e days",
            "2 days 8 pouooi",
            "foobar",
            "w5 at [not|a|time]",
            "[not|a|day] at 12:00",
            "__dict__",
        ],
    )
    def test_unknown_rotation(rotation):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

rotation   = 'e days'

tests/test_filesink_rotation.py:1094: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_unknown_rotation2-days-8-pouooi">test_filesink_rotation.py::test_unknown_rotation[2 days 8 pouooi]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_unknown_rotation[2 days 8 pouooi]</pre></summary><pre>
rotation = '2 days 8 pouooi'

    @pytest.mark.parametrize(
        "rotation",
        [
            "w7",
            "w10",
            "w-1",
            "h",
            "M",
            "w1at13",
            "www",
            "13 at w2",
            "w",
            "K",
            "tufy MB",
            "111.111.111 kb",
            "3 Ki",
            "2017.11.12",
            "11:99",
            "01:00:00!UTC",
            "monday at 2017",
            "e days",
            "2 days 8 pouooi",
            "foobar",
            "w5 at [not|a|time]",
            "[not|a|day] at 12:00",
            "__dict__",
        ],
    )
    def test_unknown_rotation(rotation):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

rotation   = '2 days 8 pouooi'

tests/test_filesink_rotation.py:1094: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_unknown_rotationfoobar">test_filesink_rotation.py::test_unknown_rotation[foobar]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_unknown_rotation[foobar]</pre></summary><pre>
rotation = 'foobar'

    @pytest.mark.parametrize(
        "rotation",
        [
            "w7",
            "w10",
            "w-1",
            "h",
            "M",
            "w1at13",
            "www",
            "13 at w2",
            "w",
            "K",
            "tufy MB",
            "111.111.111 kb",
            "3 Ki",
            "2017.11.12",
            "11:99",
            "01:00:00!UTC",
            "monday at 2017",
            "e days",
            "2 days 8 pouooi",
            "foobar",
            "w5 at [not|a|time]",
            "[not|a|day] at 12:00",
            "__dict__",
        ],
    )
    def test_unknown_rotation(rotation):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

rotation   = 'foobar'

tests/test_filesink_rotation.py:1094: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_unknown_rotationw5-at-notatime">test_filesink_rotation.py::test_unknown_rotation[w5 at [not|a|time]]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_unknown_rotation[w5 at [not|a|time]]</pre></summary><pre>
rotation = 'w5 at [not|a|time]'

    @pytest.mark.parametrize(
        "rotation",
        [
            "w7",
            "w10",
            "w-1",
            "h",
            "M",
            "w1at13",
            "www",
            "13 at w2",
            "w",
            "K",
            "tufy MB",
            "111.111.111 kb",
            "3 Ki",
            "2017.11.12",
            "11:99",
            "01:00:00!UTC",
            "monday at 2017",
            "e days",
            "2 days 8 pouooi",
            "foobar",
            "w5 at [not|a|time]",
            "[not|a|day] at 12:00",
            "__dict__",
        ],
    )
    def test_unknown_rotation(rotation):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

rotation   = 'w5 at [not|a|time]'

tests/test_filesink_rotation.py:1094: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_unknown_rotationnotaday-at-1200">test_filesink_rotation.py::test_unknown_rotation[[not|a|day] at 12:00]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_unknown_rotation[[not|a|day] at 12:00]</pre></summary><pre>
rotation = '[not|a|day] at 12:00'

    @pytest.mark.parametrize(
        "rotation",
        [
            "w7",
            "w10",
            "w-1",
            "h",
            "M",
            "w1at13",
            "www",
            "13 at w2",
            "w",
            "K",
            "tufy MB",
            "111.111.111 kb",
            "3 Ki",
            "2017.11.12",
            "11:99",
            "01:00:00!UTC",
            "monday at 2017",
            "e days",
            "2 days 8 pouooi",
            "foobar",
            "w5 at [not|a|time]",
            "[not|a|day] at 12:00",
            "__dict__",
        ],
    )
    def test_unknown_rotation(rotation):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

rotation   = '[not|a|day] at 12:00'

tests/test_filesink_rotation.py:1094: Failed
</pre>
</details>
<h3 id="test_filesink_rotationpytest_unknown_rotationdict">test_filesink_rotation.py::test_unknown_rotation[<strong>dict</strong>]</h3>
<details><summary> <pre>test_filesink_rotation.py::test_unknown_rotation[__dict__]</pre></summary><pre>
rotation = '__dict__'

    @pytest.mark.parametrize(
        "rotation",
        [
            "w7",
            "w10",
            "w-1",
            "h",
            "M",
            "w1at13",
            "www",
            "13 at w2",
            "w",
            "K",
            "tufy MB",
            "111.111.111 kb",
            "3 Ki",
            "2017.11.12",
            "11:99",
            "01:00:00!UTC",
            "monday at 2017",
            "e days",
            "2 days 8 pouooi",
            "foobar",
            "w5 at [not|a|time]",
            "[not|a|day] at 12:00",
            "__dict__",
        ],
    )
    def test_unknown_rotation(rotation):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

rotation   = '__dict__'

tests/test_filesink_rotation.py:1094: Failed
</pre>
</details>
<h3 id="test_filesink_watchpytest_file_deleted_before_write_without_delay">test_filesink_watch.py::test_file_deleted_before_write_without_delay</h3>
<details><summary> <pre>test_filesink_watch.py::test_file_deleted_before_write_without_delay</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_deleted_before_write0')

    @pytest.mark.skipif(os.name == "nt", reason="Windows can't delete file in use")
    def test_file_deleted_before_write_without_delay(tmp_path):
        file = tmp_path / "test.log"
        logger.add(file, format="{message}", watch=True, delay=False)
>       os.remove(str(file))
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_deleted_before_write0/test.log'

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_deleted_before_write0/test.log')
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_deleted_before_write0')

tests/test_filesink_watch.py:15: FileNotFoundError
</pre>
</details>
<h3 id="test_filesink_watchpytest_file_deleted_before_write_with_delay">test_filesink_watch.py::test_file_deleted_before_write_with_delay</h3>
<details><summary> <pre>test_filesink_watch.py::test_file_deleted_before_write_with_delay</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_deleted_before_write1')

    @pytest.mark.skipif(os.name == "nt", reason="Windows can't delete file in use")
    def test_file_deleted_before_write_with_delay(tmp_path):
        file = tmp_path / "test.log"
        logger.add(file, format="{message}", watch=True, delay=True)
        logger.info("Test 1")
>       os.remove(str(file))
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_deleted_before_write1/test.log'

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_deleted_before_write1/test.log')
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_deleted_before_write1')

tests/test_filesink_watch.py:25: FileNotFoundError
</pre>
</details>
<h3 id="test_filesink_watchpytest_file_path_containing_placeholder">test_filesink_watch.py::test_file_path_containing_placeholder</h3>
<details><summary> <pre>test_filesink_watch.py::test_file_path_containing_placeholder</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_path_containing_plac0')

    @pytest.mark.skipif(os.name == "nt", reason="Windows can't delete file in use")
    def test_file_path_containing_placeholder(tmp_path):
        logger.add(tmp_path / "test_{time}.log", format="{message}", watch=True)
>       check_dir(tmp_path, size=1)

tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_path_containing_plac0')

tests/test_filesink_watch.py:33: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_path_containing_plac0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           assert 0 == 1
E            +  where 0 = len(set())

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_path_containing_plac0')
files      = None
seen       = set()
size       = 1

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_watchpytest_file_reopened_with_arguments">test_filesink_watch.py::test_file_reopened_with_arguments</h3>
<details><summary> <pre>test_filesink_watch.py::test_file_reopened_with_arguments</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_reopened_with_argume0')

    @pytest.mark.skipif(os.name == "nt", reason="Windows can't delete file in use")
    def test_file_reopened_with_arguments(tmp_path):
        file = tmp_path / "test.log"
        logger.add(file, format="{message}", watch=True, encoding="ascii", errors="replace")
>       os.remove(str(file))
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_reopened_with_argume0/test.log'

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_reopened_with_argume0/test.log')
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_reopened_with_argume0')

tests/test_filesink_watch.py:45: FileNotFoundError
</pre>
</details>
<h3 id="test_filesink_watchpytest_file_manually_changed">test_filesink_watch.py::test_file_manually_changed</h3>
<details><summary> <pre>test_filesink_watch.py::test_file_manually_changed</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_manually_changed0')

    @pytest.mark.skipif(os.name == "nt", reason="Windows can't delete file in use")
    def test_file_manually_changed(tmp_path):
        file = tmp_path / "test.log"
        logger.add(file, format="{message}", watch=True, mode="w")
>       os.remove(str(file))
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_manually_changed0/test.log'

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_manually_changed0/test.log')
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_manually_changed0')

tests/test_filesink_watch.py:54: FileNotFoundError
</pre>
</details>
<h3 id="test_filesink_watchpytest_file_folder_deleted">test_filesink_watch.py::test_file_folder_deleted</h3>
<details><summary> <pre>test_filesink_watch.py::test_file_folder_deleted</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_folder_deleted0')

    @pytest.mark.skipif(os.name == "nt", reason="Windows can't delete file in use")
    def test_file_folder_deleted(tmp_path):
        file = tmp_path / "foo/bar/test.log"
        logger.add(file, format="{message}", watch=True)
>       os.remove(str(file))
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_folder_deleted0/foo/bar/test.log'

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_folder_deleted0/foo/bar/test.log')
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_folder_deleted0')

tests/test_filesink_watch.py:64: FileNotFoundError
</pre>
</details>
<h3 id="test_filesink_watchpytest_file_deleted_before_rotation">test_filesink_watch.py::test_file_deleted_before_rotation</h3>
<details><summary> <pre>test_filesink_watch.py::test_file_deleted_before_rotation</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_deleted_before_rotat0')

    @pytest.mark.skipif(os.name == "nt", reason="Windows can't delete file in use")
    def test_file_deleted_before_rotation(tmp_path):
        exists = None
        file = tmp_path / "test.log"

        def rotate(_, __):
            nonlocal exists
            exists = file.exists()
            return False

        logger.add(file, format="{message}", watch=True, rotation=rotate)
>       os.remove(str(file))
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_deleted_before_rotat0/test.log'

exists     = None
file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_deleted_before_rotat0/test.log')
rotate     = <function test_file_deleted_before_rotation.<locals>.rotate at 0x7fac081efc70>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_deleted_before_rotat0')

tests/test_filesink_watch.py:81: FileNotFoundError
</pre>
</details>
<h3 id="test_filesink_watchpytest_file_deleted_before_compression">test_filesink_watch.py::test_file_deleted_before_compression</h3>
<details><summary> <pre>test_filesink_watch.py::test_file_deleted_before_compression</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_deleted_before_compr0')

    @pytest.mark.skipif(os.name == "nt", reason="Windows can't delete file in use")
    def test_file_deleted_before_compression(tmp_path):
        exists = None
        file = tmp_path / "test.log"

        def compress(_):
            nonlocal exists
            exists = file.exists()
            return False

        logger.add(file, format="{message}", watch=True, compression=compress)
>       os.remove(str(file))
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_deleted_before_compr0/test.log'

compress   = <function test_file_deleted_before_compression.<locals>.compress at 0x7fac081eeb00>
exists     = None
file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_deleted_before_compr0/test.log')
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_deleted_before_compr0')

tests/test_filesink_watch.py:97: FileNotFoundError
</pre>
</details>
<h3 id="test_filesink_watchpytest_file_deleted_before_retention">test_filesink_watch.py::test_file_deleted_before_retention</h3>
<details><summary> <pre>test_filesink_watch.py::test_file_deleted_before_retention</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_deleted_before_reten0')

    @pytest.mark.skipif(os.name == "nt", reason="Windows can't delete file in use")
    def test_file_deleted_before_retention(tmp_path):
        exists = None
        file = tmp_path / "test.log"

        def retain(_):
            nonlocal exists
            exists = file.exists()
            return False

        logger.add(file, format="{message}", watch=True, retention=retain)
>       os.remove(str(file))
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_file_deleted_before_reten0/test.log'

exists     = None
file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_deleted_before_reten0/test.log')
retain     = <function test_file_deleted_before_retention.<locals>.retain at 0x7fac081ee170>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_deleted_before_reten0')

tests/test_filesink_watch.py:113: FileNotFoundError
</pre>
</details>
<h3 id="test_filesink_watchpytest_file_correctly_reused_after_rotation">test_filesink_watch.py::test_file_correctly_reused_after_rotation</h3>
<details><summary> <pre>test_filesink_watch.py::test_file_correctly_reused_after_rotation</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_correctly_reused_aft0')

    def test_file_correctly_reused_after_rotation(tmp_path):
        filepath = tmp_path / "test.log"
        logger.add(
            filepath,
            format="{message}",
            mode="w",
            watch=True,
            rotation=Mock(side_effect=[False, True, False]),
        )
        logger.info("Test 1")
        logger.info("Test 2")
        logger.info("Test 3")
>       check_dir(tmp_path, size=2)

filepath   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_correctly_reused_aft0/test.log')
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_correctly_reused_aft0')

tests/test_filesink_watch.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dir = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_correctly_reused_aft0')

    def check_dir(dir, *, files=None, size=None):
        actual_files = set(dir.iterdir())
        seen = set()
        if size is not None:
>           assert len(actual_files) == size
E           assert 0 == 2
E            +  where 0 = len(set())

actual_files = set()
dir        = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_correctly_reused_aft0')
files      = None
seen       = set()
size       = 2

tests/conftest.py:65: AssertionError
</pre>
</details>
<h3 id="test_filesink_watchpytest_file_closed_without_being_loggednone-false">test_filesink_watch.py::test_file_closed_without_being_logged[None-False]</h3>
<details><summary> <pre>test_filesink_watch.py::test_file_closed_without_being_logged[None-False]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_closed_without_being1')
delay = False, compression = None

    @pytest.mark.parametrize("delay", [True, False])
    @pytest.mark.parametrize("compression", [None, lambda _: None])
    def test_file_closed_without_being_logged(tmp_path, delay, compression):
        filepath = tmp_path / "test.log"
        logger.add(
            filepath,
            format="{message}",
            watch=True,
            delay=delay,
            compression=compression,
        )
        logger.remove()
>       assert filepath.exists() is (False if delay else True)
E       AssertionError: assert False is True
E        +  where False = exists()
E        +    where exists = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_closed_without_being1/test.log').exists

compression = None
delay      = False
filepath   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_closed_without_being1/test.log')
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_closed_without_being1')

tests/test_filesink_watch.py:148: AssertionError
</pre>
</details>
<h3 id="test_filesink_watchpytest_file_closed_without_being_logged-false">test_filesink_watch.py::test_file_closed_without_being_logged[<lambda>-False]</h3>
<details><summary> <pre>test_filesink_watch.py::test_file_closed_without_being_logged[<lambda>-False]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_closed_without_being3')
delay = False, compression = <function <lambda> at 0x7fac0bb0ca60>

    @pytest.mark.parametrize("delay", [True, False])
    @pytest.mark.parametrize("compression", [None, lambda _: None])
    def test_file_closed_without_being_logged(tmp_path, delay, compression):
        filepath = tmp_path / "test.log"
        logger.add(
            filepath,
            format="{message}",
            watch=True,
            delay=delay,
            compression=compression,
        )
        logger.remove()
>       assert filepath.exists() is (False if delay else True)
E       AssertionError: assert False is True
E        +  where False = exists()
E        +    where exists = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_closed_without_being3/test.log').exists

compression = <function <lambda> at 0x7fac0bb0ca60>
delay      = False
filepath   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_closed_without_being3/test.log')
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_closed_without_being3')

tests/test_filesink_watch.py:148: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattersfalse-name-">test_formatting.py::test_log_formatters[False-{name}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[False-{name}-<lambda>]</pre></summary><pre>
format = '{name}', validator = <function <lambda> at 0x7fac0bb0d3f0>
writer = <function writer.<locals>.w at 0x7fac0812c280>
use_log_function = False

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0d3f0>('')

format     = '{name}'
message    = 'Message'
result     = ''
use_log_function = False
validator  = <function <lambda> at 0x7fac0bb0d3f0>
writer     = <function writer.<locals>.w at 0x7fac0812c280>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattersfalse-time-">test_formatting.py::test_log_formatters[False-{time}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[False-{time}-<lambda>]</pre></summary><pre>
format = '{time}', validator = <function <lambda> at 0x7fac0bb0d5a0>
writer = <function writer.<locals>.w at 0x7fac0812d090>
use_log_function = False

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert None
E        +  where None = <function <lambda> at 0x7fac0bb0d5a0>('')

format     = '{time}'
message    = 'Message'
result     = ''
use_log_function = False
validator  = <function <lambda> at 0x7fac0bb0d5a0>
writer     = <function writer.<locals>.w at 0x7fac0812d090>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattersfalse-elapsed-">test_formatting.py::test_log_formatters[False-{elapsed}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[False-{elapsed}-<lambda>]</pre></summary><pre>
format = '{elapsed}', validator = <function <lambda> at 0x7fac0bb0d630>
writer = <function writer.<locals>.w at 0x7fac0812c940>
use_log_function = False

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert None
E        +  where None = <function <lambda> at 0x7fac0bb0d630>('')

format     = '{elapsed}'
message    = 'Message'
result     = ''
use_log_function = False
validator  = <function <lambda> at 0x7fac0bb0d630>
writer     = <function writer.<locals>.w at 0x7fac0812c940>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattersfalse-elapsedseconds-">test_formatting.py::test_log_formatters[False-{elapsed.seconds}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[False-{elapsed.seconds}-<lambda>]</pre></summary><pre>
format = '{elapsed.seconds}', validator = <function <lambda> at 0x7fac0bb0d6c0>
writer = <function writer.<locals>.w at 0x7fac0812cee0>
use_log_function = False

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert None
E        +  where None = <function <lambda> at 0x7fac0bb0d6c0>('')

format     = '{elapsed.seconds}'
message    = 'Message'
result     = ''
use_log_function = False
validator  = <function <lambda> at 0x7fac0bb0d6c0>
writer     = <function writer.<locals>.w at 0x7fac0812cee0>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattersfalse-line-">test_formatting.py::test_log_formatters[False-{line}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[False-{line}-<lambda>]</pre></summary><pre>
format = '{line}', validator = <function <lambda> at 0x7fac0bb0d750>
writer = <function writer.<locals>.w at 0x7fac0812d2d0>
use_log_function = False

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert None
E        +  where None = <function <lambda> at 0x7fac0bb0d750>('')

format     = '{line}'
message    = 'Message'
result     = ''
use_log_function = False
validator  = <function <lambda> at 0x7fac0bb0d750>
writer     = <function writer.<locals>.w at 0x7fac0812d2d0>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattersfalse-level-">test_formatting.py::test_log_formatters[False-{level}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[False-{level}-<lambda>]</pre></summary><pre>
format = '{level}', validator = <function <lambda> at 0x7fac0bb0d7e0>
writer = <function writer.<locals>.w at 0x7fac0812d6c0>
use_log_function = False

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0d7e0>('')

format     = '{level}'
message    = 'Message'
result     = ''
use_log_function = False
validator  = <function <lambda> at 0x7fac0bb0d7e0>
writer     = <function writer.<locals>.w at 0x7fac0812d6c0>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattersfalse-levelname-">test_formatting.py::test_log_formatters[False-{level.name}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[False-{level.name}-<lambda>]</pre></summary><pre>
format = '{level.name}', validator = <function <lambda> at 0x7fac0bb0d870>
writer = <function writer.<locals>.w at 0x7fac081eff40>
use_log_function = False

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0d870>('')

format     = '{level.name}'
message    = 'Message'
result     = ''
use_log_function = False
validator  = <function <lambda> at 0x7fac0bb0d870>
writer     = <function writer.<locals>.w at 0x7fac081eff40>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattersfalse-levelno-">test_formatting.py::test_log_formatters[False-{level.no}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[False-{level.no}-<lambda>]</pre></summary><pre>
format = '{level.no}', validator = <function <lambda> at 0x7fac0bb0d900>
writer = <function writer.<locals>.w at 0x7fac081eeb00>
use_log_function = False

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0d900>('')

format     = '{level.no}'
message    = 'Message'
result     = ''
use_log_function = False
validator  = <function <lambda> at 0x7fac0bb0d900>
writer     = <function writer.<locals>.w at 0x7fac081eeb00>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattersfalse-levelicon-">test_formatting.py::test_log_formatters[False-{level.icon}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[False-{level.icon}-<lambda>]</pre></summary><pre>
format = '{level.icon}', validator = <function <lambda> at 0x7fac0bb0d990>
writer = <function writer.<locals>.w at 0x7fac0812dea0>
use_log_function = False

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0d990>('')

format     = '{level.icon}'
message    = 'Message'
result     = ''
use_log_function = False
validator  = <function <lambda> at 0x7fac0bb0d990>
writer     = <function writer.<locals>.w at 0x7fac0812dea0>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattersfalse-file-">test_formatting.py::test_log_formatters[False-{file}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[False-{file}-<lambda>]</pre></summary><pre>
format = '{file}', validator = <function <lambda> at 0x7fac0bb0da20>
writer = <function writer.<locals>.w at 0x7fac081eeb00>
use_log_function = False

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0da20>('')

format     = '{file}'
message    = 'Message'
result     = ''
use_log_function = False
validator  = <function <lambda> at 0x7fac0bb0da20>
writer     = <function writer.<locals>.w at 0x7fac081eeb00>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattersfalse-filename-">test_formatting.py::test_log_formatters[False-{file.name}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[False-{file.name}-<lambda>]</pre></summary><pre>
format = '{file.name}', validator = <function <lambda> at 0x7fac0bb0dab0>
writer = <function writer.<locals>.w at 0x7fac0812d090>
use_log_function = False

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0dab0>('')

format     = '{file.name}'
message    = 'Message'
result     = ''
use_log_function = False
validator  = <function <lambda> at 0x7fac0bb0dab0>
writer     = <function writer.<locals>.w at 0x7fac0812d090>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattersfalse-filepath-">test_formatting.py::test_log_formatters[False-{file.path}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[False-{file.path}-<lambda>]</pre></summary><pre>
format = '{file.path}', validator = <function <lambda> at 0x7fac0bb0db40>
writer = <function writer.<locals>.w at 0x7fac0812d480>
use_log_function = False

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0db40>('')

format     = '{file.path}'
message    = 'Message'
result     = ''
use_log_function = False
validator  = <function <lambda> at 0x7fac0bb0db40>
writer     = <function writer.<locals>.w at 0x7fac0812d480>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattersfalse-function-">test_formatting.py::test_log_formatters[False-{function}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[False-{function}-<lambda>]</pre></summary><pre>
format = '{function}', validator = <function <lambda> at 0x7fac0bb0dbd0>
writer = <function writer.<locals>.w at 0x7fac081eff40>
use_log_function = False

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0dbd0>('')

format     = '{function}'
message    = 'Message'
result     = ''
use_log_function = False
validator  = <function <lambda> at 0x7fac0bb0dbd0>
writer     = <function writer.<locals>.w at 0x7fac081eff40>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattersfalse-module-">test_formatting.py::test_log_formatters[False-{module}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[False-{module}-<lambda>]</pre></summary><pre>
format = '{module}', validator = <function <lambda> at 0x7fac0bb0dc60>
writer = <function writer.<locals>.w at 0x7fac0812e5f0>
use_log_function = False

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0dc60>('')

format     = '{module}'
message    = 'Message'
result     = ''
use_log_function = False
validator  = <function <lambda> at 0x7fac0bb0dc60>
writer     = <function writer.<locals>.w at 0x7fac0812e5f0>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattersfalse-thread-">test_formatting.py::test_log_formatters[False-{thread}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[False-{thread}-<lambda>]</pre></summary><pre>
format = '{thread}', validator = <function <lambda> at 0x7fac0bb0dcf0>
writer = <function writer.<locals>.w at 0x7fac0812e290>
use_log_function = False

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert None
E        +  where None = <function <lambda> at 0x7fac0bb0dcf0>('')

format     = '{thread}'
message    = 'Message'
result     = ''
use_log_function = False
validator  = <function <lambda> at 0x7fac0bb0dcf0>
writer     = <function writer.<locals>.w at 0x7fac0812e290>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattersfalse-threadid-">test_formatting.py::test_log_formatters[False-{thread.id}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[False-{thread.id}-<lambda>]</pre></summary><pre>
format = '{thread.id}', validator = <function <lambda> at 0x7fac0bb0dd80>
writer = <function writer.<locals>.w at 0x7fac0812c550>
use_log_function = False

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert None
E        +  where None = <function <lambda> at 0x7fac0bb0dd80>('')

format     = '{thread.id}'
message    = 'Message'
result     = ''
use_log_function = False
validator  = <function <lambda> at 0x7fac0bb0dd80>
writer     = <function writer.<locals>.w at 0x7fac0812c550>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattersfalse-threadname-">test_formatting.py::test_log_formatters[False-{thread.name}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[False-{thread.name}-<lambda>]</pre></summary><pre>
format = '{thread.name}', validator = <function <lambda> at 0x7fac0bb0de10>
writer = <function writer.<locals>.w at 0x7fac0812e830>
use_log_function = False

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0de10>('')

format     = '{thread.name}'
message    = 'Message'
result     = ''
use_log_function = False
validator  = <function <lambda> at 0x7fac0bb0de10>
writer     = <function writer.<locals>.w at 0x7fac0812e830>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattersfalse-process-">test_formatting.py::test_log_formatters[False-{process}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[False-{process}-<lambda>]</pre></summary><pre>
format = '{process}', validator = <function <lambda> at 0x7fac0bb0dea0>
writer = <function writer.<locals>.w at 0x7fac0812e950>
use_log_function = False

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert None
E        +  where None = <function <lambda> at 0x7fac0bb0dea0>('')

format     = '{process}'
message    = 'Message'
result     = ''
use_log_function = False
validator  = <function <lambda> at 0x7fac0bb0dea0>
writer     = <function writer.<locals>.w at 0x7fac0812e950>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattersfalse-processid-">test_formatting.py::test_log_formatters[False-{process.id}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[False-{process.id}-<lambda>]</pre></summary><pre>
format = '{process.id}', validator = <function <lambda> at 0x7fac0bb0df30>
writer = <function writer.<locals>.w at 0x7fac0812ecb0>
use_log_function = False

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert None
E        +  where None = <function <lambda> at 0x7fac0bb0df30>('')

format     = '{process.id}'
message    = 'Message'
result     = ''
use_log_function = False
validator  = <function <lambda> at 0x7fac0bb0df30>
writer     = <function writer.<locals>.w at 0x7fac0812ecb0>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattersfalse-processname-">test_formatting.py::test_log_formatters[False-{process.name}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[False-{process.name}-<lambda>]</pre></summary><pre>
format = '{process.name}', validator = <function <lambda> at 0x7fac0bb0dfc0>
writer = <function writer.<locals>.w at 0x7fac0812e0e0>
use_log_function = False

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0dfc0>('')

format     = '{process.name}'
message    = 'Message'
result     = ''
use_log_function = False
validator  = <function <lambda> at 0x7fac0bb0dfc0>
writer     = <function writer.<locals>.w at 0x7fac0812e0e0>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattersfalse-message-">test_formatting.py::test_log_formatters[False-{message}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[False-{message}-<lambda>]</pre></summary><pre>
format = '{message}', validator = <function <lambda> at 0x7fac0bb0e050>
writer = <function writer.<locals>.w at 0x7fac0812ef80>
use_log_function = False

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0e050>('')

format     = '{message}'
message    = 'Message'
result     = ''
use_log_function = False
validator  = <function <lambda> at 0x7fac0bb0e050>
writer     = <function writer.<locals>.w at 0x7fac0812ef80>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattersfalse-s-a-u5929-1-d-">test_formatting.py::test_log_formatters[False-%s {{a}} \u5929 {{1}} %d-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[False-%s {{a}} \u5929 {{1}} %d-<lambda>]</pre></summary><pre>
format = '%s {{a}}  {{1}} %d'
validator = <function <lambda> at 0x7fac0bb0e0e0>
writer = <function writer.<locals>.w at 0x7fac0812f130>
use_log_function = False

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0e0e0>('')

format     = '%s {{a}}  {{1}} %d'
message    = 'Message'
result     = ''
use_log_function = False
validator  = <function <lambda> at 0x7fac0bb0e0e0>
writer     = <function writer.<locals>.w at 0x7fac0812f130>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formatterstrue-name-">test_formatting.py::test_log_formatters[True-{name}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[True-{name}-<lambda>]</pre></summary><pre>
format = '{name}', validator = <function <lambda> at 0x7fac0bb0d3f0>
writer = <function writer.<locals>.w at 0x7fac0812f6d0>, use_log_function = True

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0d3f0>('')

format     = '{name}'
message    = 'Message'
result     = ''
use_log_function = True
validator  = <function <lambda> at 0x7fac0bb0d3f0>
writer     = <function writer.<locals>.w at 0x7fac0812f6d0>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formatterstrue-time-">test_formatting.py::test_log_formatters[True-{time}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[True-{time}-<lambda>]</pre></summary><pre>
format = '{time}', validator = <function <lambda> at 0x7fac0bb0d5a0>
writer = <function writer.<locals>.w at 0x7fac0812e5f0>, use_log_function = True

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert None
E        +  where None = <function <lambda> at 0x7fac0bb0d5a0>('')

format     = '{time}'
message    = 'Message'
result     = ''
use_log_function = True
validator  = <function <lambda> at 0x7fac0bb0d5a0>
writer     = <function writer.<locals>.w at 0x7fac0812e5f0>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formatterstrue-elapsed-">test_formatting.py::test_log_formatters[True-{elapsed}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[True-{elapsed}-<lambda>]</pre></summary><pre>
format = '{elapsed}', validator = <function <lambda> at 0x7fac0bb0d630>
writer = <function writer.<locals>.w at 0x7fac0812fa30>, use_log_function = True

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert None
E        +  where None = <function <lambda> at 0x7fac0bb0d630>('')

format     = '{elapsed}'
message    = 'Message'
result     = ''
use_log_function = True
validator  = <function <lambda> at 0x7fac0bb0d630>
writer     = <function writer.<locals>.w at 0x7fac0812fa30>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formatterstrue-elapsedseconds-">test_formatting.py::test_log_formatters[True-{elapsed.seconds}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[True-{elapsed.seconds}-<lambda>]</pre></summary><pre>
format = '{elapsed.seconds}', validator = <function <lambda> at 0x7fac0bb0d6c0>
writer = <function writer.<locals>.w at 0x7fac0812f0a0>, use_log_function = True

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert None
E        +  where None = <function <lambda> at 0x7fac0bb0d6c0>('')

format     = '{elapsed.seconds}'
message    = 'Message'
result     = ''
use_log_function = True
validator  = <function <lambda> at 0x7fac0bb0d6c0>
writer     = <function writer.<locals>.w at 0x7fac0812f0a0>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formatterstrue-line-">test_formatting.py::test_log_formatters[True-{line}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[True-{line}-<lambda>]</pre></summary><pre>
format = '{line}', validator = <function <lambda> at 0x7fac0bb0d750>
writer = <function writer.<locals>.w at 0x7fac07d043a0>, use_log_function = True

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert None
E        +  where None = <function <lambda> at 0x7fac0bb0d750>('')

format     = '{line}'
message    = 'Message'
result     = ''
use_log_function = True
validator  = <function <lambda> at 0x7fac0bb0d750>
writer     = <function writer.<locals>.w at 0x7fac07d043a0>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formatterstrue-level-">test_formatting.py::test_log_formatters[True-{level}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[True-{level}-<lambda>]</pre></summary><pre>
format = '{level}', validator = <function <lambda> at 0x7fac0bb0d7e0>
writer = <function writer.<locals>.w at 0x7fac0812fa30>, use_log_function = True

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0d7e0>('')

format     = '{level}'
message    = 'Message'
result     = ''
use_log_function = True
validator  = <function <lambda> at 0x7fac0bb0d7e0>
writer     = <function writer.<locals>.w at 0x7fac0812fa30>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formatterstrue-levelname-">test_formatting.py::test_log_formatters[True-{level.name}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[True-{level.name}-<lambda>]</pre></summary><pre>
format = '{level.name}', validator = <function <lambda> at 0x7fac0bb0d870>
writer = <function writer.<locals>.w at 0x7fac07d04670>, use_log_function = True

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0d870>('')

format     = '{level.name}'
message    = 'Message'
result     = ''
use_log_function = True
validator  = <function <lambda> at 0x7fac0bb0d870>
writer     = <function writer.<locals>.w at 0x7fac07d04670>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formatterstrue-levelno-">test_formatting.py::test_log_formatters[True-{level.no}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[True-{level.no}-<lambda>]</pre></summary><pre>
format = '{level.no}', validator = <function <lambda> at 0x7fac0bb0d900>
writer = <function writer.<locals>.w at 0x7fac07d04280>, use_log_function = True

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0d900>('')

format     = '{level.no}'
message    = 'Message'
result     = ''
use_log_function = True
validator  = <function <lambda> at 0x7fac0bb0d900>
writer     = <function writer.<locals>.w at 0x7fac07d04280>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formatterstrue-levelicon-">test_formatting.py::test_log_formatters[True-{level.icon}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[True-{level.icon}-<lambda>]</pre></summary><pre>
format = '{level.icon}', validator = <function <lambda> at 0x7fac0bb0d990>
writer = <function writer.<locals>.w at 0x7fac0812f6d0>, use_log_function = True

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0d990>('')

format     = '{level.icon}'
message    = 'Message'
result     = ''
use_log_function = True
validator  = <function <lambda> at 0x7fac0bb0d990>
writer     = <function writer.<locals>.w at 0x7fac0812f6d0>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formatterstrue-file-">test_formatting.py::test_log_formatters[True-{file}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[True-{file}-<lambda>]</pre></summary><pre>
format = '{file}', validator = <function <lambda> at 0x7fac0bb0da20>
writer = <function writer.<locals>.w at 0x7fac07d051b0>, use_log_function = True

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0da20>('')

format     = '{file}'
message    = 'Message'
result     = ''
use_log_function = True
validator  = <function <lambda> at 0x7fac0bb0da20>
writer     = <function writer.<locals>.w at 0x7fac07d051b0>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formatterstrue-filename-">test_formatting.py::test_log_formatters[True-{file.name}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[True-{file.name}-<lambda>]</pre></summary><pre>
format = '{file.name}', validator = <function <lambda> at 0x7fac0bb0dab0>
writer = <function writer.<locals>.w at 0x7fac07d05120>, use_log_function = True

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0dab0>('')

format     = '{file.name}'
message    = 'Message'
result     = ''
use_log_function = True
validator  = <function <lambda> at 0x7fac0bb0dab0>
writer     = <function writer.<locals>.w at 0x7fac07d05120>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formatterstrue-filepath-">test_formatting.py::test_log_formatters[True-{file.path}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[True-{file.path}-<lambda>]</pre></summary><pre>
format = '{file.path}', validator = <function <lambda> at 0x7fac0bb0db40>
writer = <function writer.<locals>.w at 0x7fac07d04ca0>, use_log_function = True

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0db40>('')

format     = '{file.path}'
message    = 'Message'
result     = ''
use_log_function = True
validator  = <function <lambda> at 0x7fac0bb0db40>
writer     = <function writer.<locals>.w at 0x7fac07d04ca0>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formatterstrue-function-">test_formatting.py::test_log_formatters[True-{function}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[True-{function}-<lambda>]</pre></summary><pre>
format = '{function}', validator = <function <lambda> at 0x7fac0bb0dbd0>
writer = <function writer.<locals>.w at 0x7fac07d05510>, use_log_function = True

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0dbd0>('')

format     = '{function}'
message    = 'Message'
result     = ''
use_log_function = True
validator  = <function <lambda> at 0x7fac0bb0dbd0>
writer     = <function writer.<locals>.w at 0x7fac07d05510>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formatterstrue-module-">test_formatting.py::test_log_formatters[True-{module}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[True-{module}-<lambda>]</pre></summary><pre>
format = '{module}', validator = <function <lambda> at 0x7fac0bb0dc60>
writer = <function writer.<locals>.w at 0x7fac07d05630>, use_log_function = True

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0dc60>('')

format     = '{module}'
message    = 'Message'
result     = ''
use_log_function = True
validator  = <function <lambda> at 0x7fac0bb0dc60>
writer     = <function writer.<locals>.w at 0x7fac07d05630>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formatterstrue-thread-">test_formatting.py::test_log_formatters[True-{thread}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[True-{thread}-<lambda>]</pre></summary><pre>
format = '{thread}', validator = <function <lambda> at 0x7fac0bb0dcf0>
writer = <function writer.<locals>.w at 0x7fac07d05990>, use_log_function = True

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert None
E        +  where None = <function <lambda> at 0x7fac0bb0dcf0>('')

format     = '{thread}'
message    = 'Message'
result     = ''
use_log_function = True
validator  = <function <lambda> at 0x7fac0bb0dcf0>
writer     = <function writer.<locals>.w at 0x7fac07d05990>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formatterstrue-threadid-">test_formatting.py::test_log_formatters[True-{thread.id}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[True-{thread.id}-<lambda>]</pre></summary><pre>
format = '{thread.id}', validator = <function <lambda> at 0x7fac0bb0dd80>
writer = <function writer.<locals>.w at 0x7fac07d04dc0>, use_log_function = True

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert None
E        +  where None = <function <lambda> at 0x7fac0bb0dd80>('')

format     = '{thread.id}'
message    = 'Message'
result     = ''
use_log_function = True
validator  = <function <lambda> at 0x7fac0bb0dd80>
writer     = <function writer.<locals>.w at 0x7fac07d04dc0>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formatterstrue-threadname-">test_formatting.py::test_log_formatters[True-{thread.name}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[True-{thread.name}-<lambda>]</pre></summary><pre>
format = '{thread.name}', validator = <function <lambda> at 0x7fac0bb0de10>
writer = <function writer.<locals>.w at 0x7fac07d05c60>, use_log_function = True

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0de10>('')

format     = '{thread.name}'
message    = 'Message'
result     = ''
use_log_function = True
validator  = <function <lambda> at 0x7fac0bb0de10>
writer     = <function writer.<locals>.w at 0x7fac07d05c60>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formatterstrue-process-">test_formatting.py::test_log_formatters[True-{process}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[True-{process}-<lambda>]</pre></summary><pre>
format = '{process}', validator = <function <lambda> at 0x7fac0bb0dea0>
writer = <function writer.<locals>.w at 0x7fac07d05240>, use_log_function = True

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert None
E        +  where None = <function <lambda> at 0x7fac0bb0dea0>('')

format     = '{process}'
message    = 'Message'
result     = ''
use_log_function = True
validator  = <function <lambda> at 0x7fac0bb0dea0>
writer     = <function writer.<locals>.w at 0x7fac07d05240>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formatterstrue-processid-">test_formatting.py::test_log_formatters[True-{process.id}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[True-{process.id}-<lambda>]</pre></summary><pre>
format = '{process.id}', validator = <function <lambda> at 0x7fac0bb0df30>
writer = <function writer.<locals>.w at 0x7fac07d053f0>, use_log_function = True

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert None
E        +  where None = <function <lambda> at 0x7fac0bb0df30>('')

format     = '{process.id}'
message    = 'Message'
result     = ''
use_log_function = True
validator  = <function <lambda> at 0x7fac0bb0df30>
writer     = <function writer.<locals>.w at 0x7fac07d053f0>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formatterstrue-processname-">test_formatting.py::test_log_formatters[True-{process.name}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[True-{process.name}-<lambda>]</pre></summary><pre>
format = '{process.name}', validator = <function <lambda> at 0x7fac0bb0dfc0>
writer = <function writer.<locals>.w at 0x7fac07d063b0>, use_log_function = True

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0dfc0>('')

format     = '{process.name}'
message    = 'Message'
result     = ''
use_log_function = True
validator  = <function <lambda> at 0x7fac0bb0dfc0>
writer     = <function writer.<locals>.w at 0x7fac07d063b0>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formatterstrue-message-">test_formatting.py::test_log_formatters[True-{message}-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[True-{message}-<lambda>]</pre></summary><pre>
format = '{message}', validator = <function <lambda> at 0x7fac0bb0e050>
writer = <function writer.<locals>.w at 0x7fac07d06710>, use_log_function = True

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0e050>('')

format     = '{message}'
message    = 'Message'
result     = ''
use_log_function = True
validator  = <function <lambda> at 0x7fac0bb0e050>
writer     = <function writer.<locals>.w at 0x7fac07d06710>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formatterstrue-s-a-u5929-1-d-">test_formatting.py::test_log_formatters[True-%s {{a}} \u5929 {{1}} %d-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatters[True-%s {{a}} \u5929 {{1}} %d-<lambda>]</pre></summary><pre>
format = '%s {{a}}  {{1}} %d'
validator = <function <lambda> at 0x7fac0bb0e0e0>
writer = <function writer.<locals>.w at 0x7fac07d05ab0>, use_log_function = True

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{name}", lambda r: r == "tests.test_formatting"),
            ("{time}", lambda r: re.fullmatch(r"\d+-\d+-\d+T\d+:\d+:\d+[.,]\d+[+-]\d{4}", r)),
            ("{elapsed}", lambda r: re.fullmatch(r"\d:\d{2}:\d{2}\.\d{6}", r)),
            ("{elapsed.seconds}", lambda r: re.fullmatch(r"\d+", r)),
            ("{line}", lambda r: re.fullmatch(r"\d+", r)),
            ("{level}", lambda r: r == "DEBUG"),
            ("{level.name}", lambda r: r == "DEBUG"),
            ("{level.no}", lambda r: r == "10"),
            ("{level.icon}", lambda r: r == ""),
            ("{file}", lambda r: r == "test_formatting.py"),
            ("{file.name}", lambda r: r == "test_formatting.py"),
            ("{file.path}", lambda r: os.path.normcase(r) == os.path.normcase(__file__)),
            ("{function}", lambda r: r == "test_log_formatters"),
            ("{module}", lambda r: r == "test_formatting"),
            ("{thread}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{thread.name}", lambda r: isinstance(r, str) and r != ""),
            ("{process}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.id}", lambda r: re.fullmatch(r"\d+", r)),
            ("{process.name}", lambda r: isinstance(r, str) and r != ""),
            ("{message}", lambda r: r == "Message"),
            ("%s {{a}}  {{1}} %d", lambda r: r == "%s {a}  {1} %d"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatters(format, validator, writer, use_log_function):
        message = "Message"

        logger.add(writer, format=format)

        if use_log_function:
            logger.log("DEBUG", message)
        else:
            logger.debug(message)

        result = writer.read().rstrip("\n")
>       assert validator(result)
E       AssertionError: assert False
E        +  where False = <function <lambda> at 0x7fac0bb0e0e0>('')

format     = '%s {{a}}  {{1}} %d'
message    = 'Message'
result     = ''
use_log_function = True
validator  = <function <lambda> at 0x7fac0bb0e0e0>
writer     = <function writer.<locals>.w at 0x7fac07d05ab0>

tests/test_formatting.py:48: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_file_formattersfile-timelog-">test_formatting.py::test_file_formatters[file-{time}.log-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_file_formatters[file-{time}.log-<lambda>]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_formatters_file__tim0')
format = '{time}.log', validator = <function <lambda> at 0x7fac0bb0e200>
part = 'file'

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{time}.log", lambda r: re.fullmatch(r"\d+-\d+-\d+_\d+-\d+-\d+\_\d+.log", r)),
            ("%s_{{a}}__{{1}}_%d", lambda r: r == "%s_{a}__{1}_%d"),
        ],
    )
    @pytest.mark.parametrize("part", ["file", "dir", "both"])
    def test_file_formatters(tmp_path, format, validator, part):
        if part == "file":
            file = tmp_path.joinpath(format)
        elif part == "dir":
            file = tmp_path.joinpath(format, "log.log")
        elif part == "both":
            file = tmp_path.joinpath(format, format)

        logger.add(file)
        logger.debug("Message")

        files = [f for f in tmp_path.glob("**/*") if f.is_file()]

>       assert len(files) == 1
E       assert 0 == 1
E        +  where 0 = len([])

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_formatters_file__tim0/{time}.log')
files      = []
format     = '{time}.log'
part       = 'file'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_formatters_file__tim0')
validator  = <function <lambda> at 0x7fac0bb0e200>

tests/test_formatting.py:72: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_file_formattersfile-s_au59291_d-">test_formatting.py::test_file_formatters[file-%s_{{a}}<em>\u5929</em>{{1}}_%d-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_file_formatters[file-%s_{{a}}_\u5929_{{1}}_%d-<lambda>]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_formatters_file__s__0')
format = '%s_{{a}}__{{1}}_%d'
validator = <function <lambda> at 0x7fac0bb0e290>, part = 'file'

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{time}.log", lambda r: re.fullmatch(r"\d+-\d+-\d+_\d+-\d+-\d+\_\d+.log", r)),
            ("%s_{{a}}__{{1}}_%d", lambda r: r == "%s_{a}__{1}_%d"),
        ],
    )
    @pytest.mark.parametrize("part", ["file", "dir", "both"])
    def test_file_formatters(tmp_path, format, validator, part):
        if part == "file":
            file = tmp_path.joinpath(format)
        elif part == "dir":
            file = tmp_path.joinpath(format, "log.log")
        elif part == "both":
            file = tmp_path.joinpath(format, format)

        logger.add(file)
        logger.debug("Message")

        files = [f for f in tmp_path.glob("**/*") if f.is_file()]

>       assert len(files) == 1
E       assert 0 == 1
E        +  where 0 = len([])

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_formatters_file__s__0/%s_{{a}}__{{1}}_%d')
files      = []
format     = '%s_{{a}}__{{1}}_%d'
part       = 'file'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_formatters_file__s__0')
validator  = <function <lambda> at 0x7fac0bb0e290>

tests/test_formatting.py:72: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_file_formattersdir-timelog-">test_formatting.py::test_file_formatters[dir-{time}.log-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_file_formatters[dir-{time}.log-<lambda>]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_formatters_dir__time0')
format = '{time}.log', validator = <function <lambda> at 0x7fac0bb0e200>
part = 'dir'

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{time}.log", lambda r: re.fullmatch(r"\d+-\d+-\d+_\d+-\d+-\d+\_\d+.log", r)),
            ("%s_{{a}}__{{1}}_%d", lambda r: r == "%s_{a}__{1}_%d"),
        ],
    )
    @pytest.mark.parametrize("part", ["file", "dir", "both"])
    def test_file_formatters(tmp_path, format, validator, part):
        if part == "file":
            file = tmp_path.joinpath(format)
        elif part == "dir":
            file = tmp_path.joinpath(format, "log.log")
        elif part == "both":
            file = tmp_path.joinpath(format, format)

        logger.add(file)
        logger.debug("Message")

        files = [f for f in tmp_path.glob("**/*") if f.is_file()]

>       assert len(files) == 1
E       assert 0 == 1
E        +  where 0 = len([])

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_formatters_dir__time0/{time}.log/log.log')
files      = []
format     = '{time}.log'
part       = 'dir'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_formatters_dir__time0')
validator  = <function <lambda> at 0x7fac0bb0e200>

tests/test_formatting.py:72: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_file_formattersdir-s_au59291_d-">test_formatting.py::test_file_formatters[dir-%s_{{a}}<em>\u5929</em>{{1}}_%d-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_file_formatters[dir-%s_{{a}}_\u5929_{{1}}_%d-<lambda>]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_formatters_dir__s___0')
format = '%s_{{a}}__{{1}}_%d'
validator = <function <lambda> at 0x7fac0bb0e290>, part = 'dir'

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{time}.log", lambda r: re.fullmatch(r"\d+-\d+-\d+_\d+-\d+-\d+\_\d+.log", r)),
            ("%s_{{a}}__{{1}}_%d", lambda r: r == "%s_{a}__{1}_%d"),
        ],
    )
    @pytest.mark.parametrize("part", ["file", "dir", "both"])
    def test_file_formatters(tmp_path, format, validator, part):
        if part == "file":
            file = tmp_path.joinpath(format)
        elif part == "dir":
            file = tmp_path.joinpath(format, "log.log")
        elif part == "both":
            file = tmp_path.joinpath(format, format)

        logger.add(file)
        logger.debug("Message")

        files = [f for f in tmp_path.glob("**/*") if f.is_file()]

>       assert len(files) == 1
E       assert 0 == 1
E        +  where 0 = len([])

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_formatters_dir__s___0/%s_{{a}}__{{1}}_%d/log.log')
files      = []
format     = '%s_{{a}}__{{1}}_%d'
part       = 'dir'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_formatters_dir__s___0')
validator  = <function <lambda> at 0x7fac0bb0e290>

tests/test_formatting.py:72: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_file_formattersboth-timelog-">test_formatting.py::test_file_formatters[both-{time}.log-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_file_formatters[both-{time}.log-<lambda>]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_formatters_both__tim0')
format = '{time}.log', validator = <function <lambda> at 0x7fac0bb0e200>
part = 'both'

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{time}.log", lambda r: re.fullmatch(r"\d+-\d+-\d+_\d+-\d+-\d+\_\d+.log", r)),
            ("%s_{{a}}__{{1}}_%d", lambda r: r == "%s_{a}__{1}_%d"),
        ],
    )
    @pytest.mark.parametrize("part", ["file", "dir", "both"])
    def test_file_formatters(tmp_path, format, validator, part):
        if part == "file":
            file = tmp_path.joinpath(format)
        elif part == "dir":
            file = tmp_path.joinpath(format, "log.log")
        elif part == "both":
            file = tmp_path.joinpath(format, format)

        logger.add(file)
        logger.debug("Message")

        files = [f for f in tmp_path.glob("**/*") if f.is_file()]

>       assert len(files) == 1
E       assert 0 == 1
E        +  where 0 = len([])

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_formatters_both__tim0/{time}.log/{time}.log')
files      = []
format     = '{time}.log'
part       = 'both'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_formatters_both__tim0')
validator  = <function <lambda> at 0x7fac0bb0e200>

tests/test_formatting.py:72: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_file_formattersboth-s_au59291_d-">test_formatting.py::test_file_formatters[both-%s_{{a}}<em>\u5929</em>{{1}}_%d-<lambda>]</h3>
<details><summary> <pre>test_formatting.py::test_file_formatters[both-%s_{{a}}_\u5929_{{1}}_%d-<lambda>]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_formatters_both__s__0')
format = '%s_{{a}}__{{1}}_%d'
validator = <function <lambda> at 0x7fac0bb0e290>, part = 'both'

    @pytest.mark.parametrize(
        "format, validator",
        [
            ("{time}.log", lambda r: re.fullmatch(r"\d+-\d+-\d+_\d+-\d+-\d+\_\d+.log", r)),
            ("%s_{{a}}__{{1}}_%d", lambda r: r == "%s_{a}__{1}_%d"),
        ],
    )
    @pytest.mark.parametrize("part", ["file", "dir", "both"])
    def test_file_formatters(tmp_path, format, validator, part):
        if part == "file":
            file = tmp_path.joinpath(format)
        elif part == "dir":
            file = tmp_path.joinpath(format, "log.log")
        elif part == "both":
            file = tmp_path.joinpath(format, format)

        logger.add(file)
        logger.debug("Message")

        files = [f for f in tmp_path.glob("**/*") if f.is_file()]

>       assert len(files) == 1
E       assert 0 == 1
E        +  where 0 = len([])

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_formatters_both__s__0/%s_{{a}}__{{1}}_%d/%s_{{a}}__{{1}}_%d')
files      = []
format     = '%s_{{a}}__{{1}}_%d'
part       = 'both'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_formatters_both__s__0')
validator  = <function <lambda> at 0x7fac0bb0e290>

tests/test_formatting.py:72: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattingfalse-1-2-3-0-args0-kwargs0-1-2-3-0-">test_formatting.py::test_log_formatting[False-{1, 2, 3} - {0} - {-args0-kwargs0-{1, 2, 3} - {0} - {]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatting[False-{1, 2, 3} - {0} - {-args0-kwargs0-{1, 2, 3} - {0} - {]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0812fd90>
message = '{1, 2, 3} - {0} - {', args = [], kwargs = {}
expected = '{1, 2, 3} - {0} - {', use_log_function = False

    @pytest.mark.parametrize(
        "message, args, kwargs, expected",
        [
            ("{1, 2, 3} - {0} - {", [], {}, "{1, 2, 3} - {0} - {"),
            ("{} + {} = {}", [1, 2, 3], {}, "1 + 2 = 3"),
            ("{a} + {b} = {c}", [], dict(a=1, b=2, c=3), "1 + 2 = 3"),
            ("{0} + {two} = {1}", [1, 3], dict(two=2, nope=4), "1 + 2 = 3"),
            (
                "{self} or {message} or {level}",
                [],
                dict(self="a", message="b", level="c"),
                "a or b or c",
            ),
            ("{:.2f}", [1], {}, "1.00"),
            ("{0:0{three}d}", [5], dict(three=3), "005"),
            ("{{nope}} {my_dict} {}", ["{{!}}"], dict(my_dict={"a": 1}), "{nope} {'a': 1} {{!}}"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatting(writer, message, args, kwargs, expected, use_log_function):
        logger.add(writer, format="{message}", colorize=False)

        if use_log_function:
            logger.log(10, message, *args, **kwargs)
        else:
            logger.debug(message, *args, **kwargs)

>       assert writer.read() == expected + "\n"
E       AssertionError: assert '' == '{1, 2, 3} - {0} - {\n'
E         
E         - {1, 2, 3} - {0} - {

args       = []
expected   = '{1, 2, 3} - {0} - {'
kwargs     = {}
message    = '{1, 2, 3} - {0} - {'
use_log_function = False
writer     = <function writer.<locals>.w at 0x7fac0812fd90>

tests/test_formatting.py:113: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattingfalse-args1-kwargs1-1-2-3">test_formatting.py::test_log_formatting[False-{} + {} = {}-args1-kwargs1-1 + 2 = 3]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatting[False-{} + {} = {}-args1-kwargs1-1 + 2 = 3]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0812e5f0>
message = '{} + {} = {}', args = [1, 2, 3], kwargs = {}, expected = '1 + 2 = 3'
use_log_function = False

    @pytest.mark.parametrize(
        "message, args, kwargs, expected",
        [
            ("{1, 2, 3} - {0} - {", [], {}, "{1, 2, 3} - {0} - {"),
            ("{} + {} = {}", [1, 2, 3], {}, "1 + 2 = 3"),
            ("{a} + {b} = {c}", [], dict(a=1, b=2, c=3), "1 + 2 = 3"),
            ("{0} + {two} = {1}", [1, 3], dict(two=2, nope=4), "1 + 2 = 3"),
            (
                "{self} or {message} or {level}",
                [],
                dict(self="a", message="b", level="c"),
                "a or b or c",
            ),
            ("{:.2f}", [1], {}, "1.00"),
            ("{0:0{three}d}", [5], dict(three=3), "005"),
            ("{{nope}} {my_dict} {}", ["{{!}}"], dict(my_dict={"a": 1}), "{nope} {'a': 1} {{!}}"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatting(writer, message, args, kwargs, expected, use_log_function):
        logger.add(writer, format="{message}", colorize=False)

        if use_log_function:
            logger.log(10, message, *args, **kwargs)
        else:
            logger.debug(message, *args, **kwargs)

>       assert writer.read() == expected + "\n"
E       AssertionError: assert '' == '1 + 2 = 3\n'
E         
E         - 1 + 2 = 3

args       = [1, 2, 3]
expected   = '1 + 2 = 3'
kwargs     = {}
message    = '{} + {} = {}'
use_log_function = False
writer     = <function writer.<locals>.w at 0x7fac0812e5f0>

tests/test_formatting.py:113: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattingfalse-a-b-c-args2-kwargs2-1-2-3">test_formatting.py::test_log_formatting[False-{a} + {b} = {c}-args2-kwargs2-1 + 2 = 3]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatting[False-{a} + {b} = {c}-args2-kwargs2-1 + 2 = 3]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0812d2d0>
message = '{a} + {b} = {c}', args = [], kwargs = {'a': 1, 'b': 2, 'c': 3}
expected = '1 + 2 = 3', use_log_function = False

    @pytest.mark.parametrize(
        "message, args, kwargs, expected",
        [
            ("{1, 2, 3} - {0} - {", [], {}, "{1, 2, 3} - {0} - {"),
            ("{} + {} = {}", [1, 2, 3], {}, "1 + 2 = 3"),
            ("{a} + {b} = {c}", [], dict(a=1, b=2, c=3), "1 + 2 = 3"),
            ("{0} + {two} = {1}", [1, 3], dict(two=2, nope=4), "1 + 2 = 3"),
            (
                "{self} or {message} or {level}",
                [],
                dict(self="a", message="b", level="c"),
                "a or b or c",
            ),
            ("{:.2f}", [1], {}, "1.00"),
            ("{0:0{three}d}", [5], dict(three=3), "005"),
            ("{{nope}} {my_dict} {}", ["{{!}}"], dict(my_dict={"a": 1}), "{nope} {'a': 1} {{!}}"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatting(writer, message, args, kwargs, expected, use_log_function):
        logger.add(writer, format="{message}", colorize=False)

        if use_log_function:
            logger.log(10, message, *args, **kwargs)
        else:
            logger.debug(message, *args, **kwargs)

>       assert writer.read() == expected + "\n"
E       AssertionError: assert '' == '1 + 2 = 3\n'
E         
E         - 1 + 2 = 3

args       = []
expected   = '1 + 2 = 3'
kwargs     = {'a': 1, 'b': 2, 'c': 3}
message    = '{a} + {b} = {c}'
use_log_function = False
writer     = <function writer.<locals>.w at 0x7fac0812d2d0>

tests/test_formatting.py:113: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattingfalse-0-two-1-args3-kwargs3-1-2-3">test_formatting.py::test_log_formatting[False-{0} + {two} = {1}-args3-kwargs3-1 + 2 = 3]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatting[False-{0} + {two} = {1}-args3-kwargs3-1 + 2 = 3]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0812e560>
message = '{0} + {two} = {1}', args = [1, 3], kwargs = {'nope': 4, 'two': 2}
expected = '1 + 2 = 3', use_log_function = False

    @pytest.mark.parametrize(
        "message, args, kwargs, expected",
        [
            ("{1, 2, 3} - {0} - {", [], {}, "{1, 2, 3} - {0} - {"),
            ("{} + {} = {}", [1, 2, 3], {}, "1 + 2 = 3"),
            ("{a} + {b} = {c}", [], dict(a=1, b=2, c=3), "1 + 2 = 3"),
            ("{0} + {two} = {1}", [1, 3], dict(two=2, nope=4), "1 + 2 = 3"),
            (
                "{self} or {message} or {level}",
                [],
                dict(self="a", message="b", level="c"),
                "a or b or c",
            ),
            ("{:.2f}", [1], {}, "1.00"),
            ("{0:0{three}d}", [5], dict(three=3), "005"),
            ("{{nope}} {my_dict} {}", ["{{!}}"], dict(my_dict={"a": 1}), "{nope} {'a': 1} {{!}}"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatting(writer, message, args, kwargs, expected, use_log_function):
        logger.add(writer, format="{message}", colorize=False)

        if use_log_function:
            logger.log(10, message, *args, **kwargs)
        else:
            logger.debug(message, *args, **kwargs)

>       assert writer.read() == expected + "\n"
E       AssertionError: assert '' == '1 + 2 = 3\n'
E         
E         - 1 + 2 = 3

args       = [1, 3]
expected   = '1 + 2 = 3'
kwargs     = {'nope': 4, 'two': 2}
message    = '{0} + {two} = {1}'
use_log_function = False
writer     = <function writer.<locals>.w at 0x7fac0812e560>

tests/test_formatting.py:113: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattingfalse-self-or-message-or-level-args4-kwargs4-a-or-b-or-c">test_formatting.py::test_log_formatting[False-{self} or {message} or {level}-args4-kwargs4-a or b or c]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatting[False-{self} or {message} or {level}-args4-kwargs4-a or b or c]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d06b00>
message = '{self} or {message} or {level}', args = []
kwargs = {'level': 'c', 'message': 'b', 'self': 'a'}, expected = 'a or b or c'
use_log_function = False

    @pytest.mark.parametrize(
        "message, args, kwargs, expected",
        [
            ("{1, 2, 3} - {0} - {", [], {}, "{1, 2, 3} - {0} - {"),
            ("{} + {} = {}", [1, 2, 3], {}, "1 + 2 = 3"),
            ("{a} + {b} = {c}", [], dict(a=1, b=2, c=3), "1 + 2 = 3"),
            ("{0} + {two} = {1}", [1, 3], dict(two=2, nope=4), "1 + 2 = 3"),
            (
                "{self} or {message} or {level}",
                [],
                dict(self="a", message="b", level="c"),
                "a or b or c",
            ),
            ("{:.2f}", [1], {}, "1.00"),
            ("{0:0{three}d}", [5], dict(three=3), "005"),
            ("{{nope}} {my_dict} {}", ["{{!}}"], dict(my_dict={"a": 1}), "{nope} {'a': 1} {{!}}"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatting(writer, message, args, kwargs, expected, use_log_function):
        logger.add(writer, format="{message}", colorize=False)

        if use_log_function:
            logger.log(10, message, *args, **kwargs)
        else:
            logger.debug(message, *args, **kwargs)

>       assert writer.read() == expected + "\n"
E       AssertionError: assert '' == 'a or b or c\n'
E         
E         - a or b or c

args       = []
expected   = 'a or b or c'
kwargs     = {'level': 'c', 'message': 'b', 'self': 'a'}
message    = '{self} or {message} or {level}'
use_log_function = False
writer     = <function writer.<locals>.w at 0x7fac07d06b00>

tests/test_formatting.py:113: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattingfalse-2f-args5-kwargs5-100">test_formatting.py::test_log_formatting[False-{:.2f}-args5-kwargs5-1.00]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatting[False-{:.2f}-args5-kwargs5-1.00]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0812f0a0>, message = '{:.2f}'
args = [1], kwargs = {}, expected = '1.00', use_log_function = False

    @pytest.mark.parametrize(
        "message, args, kwargs, expected",
        [
            ("{1, 2, 3} - {0} - {", [], {}, "{1, 2, 3} - {0} - {"),
            ("{} + {} = {}", [1, 2, 3], {}, "1 + 2 = 3"),
            ("{a} + {b} = {c}", [], dict(a=1, b=2, c=3), "1 + 2 = 3"),
            ("{0} + {two} = {1}", [1, 3], dict(two=2, nope=4), "1 + 2 = 3"),
            (
                "{self} or {message} or {level}",
                [],
                dict(self="a", message="b", level="c"),
                "a or b or c",
            ),
            ("{:.2f}", [1], {}, "1.00"),
            ("{0:0{three}d}", [5], dict(three=3), "005"),
            ("{{nope}} {my_dict} {}", ["{{!}}"], dict(my_dict={"a": 1}), "{nope} {'a': 1} {{!}}"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatting(writer, message, args, kwargs, expected, use_log_function):
        logger.add(writer, format="{message}", colorize=False)

        if use_log_function:
            logger.log(10, message, *args, **kwargs)
        else:
            logger.debug(message, *args, **kwargs)

>       assert writer.read() == expected + "\n"
E       AssertionError: assert '' == '1.00\n'
E         
E         - 1.00

args       = [1]
expected   = '1.00'
kwargs     = {}
message    = '{:.2f}'
use_log_function = False
writer     = <function writer.<locals>.w at 0x7fac0812f0a0>

tests/test_formatting.py:113: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattingfalse-00threed-args6-kwargs6-005">test_formatting.py::test_log_formatting[False-{0:0{three}d}-args6-kwargs6-005]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatting[False-{0:0{three}d}-args6-kwargs6-005]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0812d6c0>
message = '{0:0{three}d}', args = [5], kwargs = {'three': 3}, expected = '005'
use_log_function = False

    @pytest.mark.parametrize(
        "message, args, kwargs, expected",
        [
            ("{1, 2, 3} - {0} - {", [], {}, "{1, 2, 3} - {0} - {"),
            ("{} + {} = {}", [1, 2, 3], {}, "1 + 2 = 3"),
            ("{a} + {b} = {c}", [], dict(a=1, b=2, c=3), "1 + 2 = 3"),
            ("{0} + {two} = {1}", [1, 3], dict(two=2, nope=4), "1 + 2 = 3"),
            (
                "{self} or {message} or {level}",
                [],
                dict(self="a", message="b", level="c"),
                "a or b or c",
            ),
            ("{:.2f}", [1], {}, "1.00"),
            ("{0:0{three}d}", [5], dict(three=3), "005"),
            ("{{nope}} {my_dict} {}", ["{{!}}"], dict(my_dict={"a": 1}), "{nope} {'a': 1} {{!}}"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatting(writer, message, args, kwargs, expected, use_log_function):
        logger.add(writer, format="{message}", colorize=False)

        if use_log_function:
            logger.log(10, message, *args, **kwargs)
        else:
            logger.debug(message, *args, **kwargs)

>       assert writer.read() == expected + "\n"
E       AssertionError: assert '' == '005\n'
E         
E         - 005

args       = [5]
expected   = '005'
kwargs     = {'three': 3}
message    = '{0:0{three}d}'
use_log_function = False
writer     = <function writer.<locals>.w at 0x7fac0812d6c0>

tests/test_formatting.py:113: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattingfalse-nope-my_dict-args7-kwargs7-nope-a-1">test_formatting.py::test_log_formatting[False-{{nope}} {my_dict} {}-args7-kwargs7-{nope} {'a': 1} {{!}}]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatting[False-{{nope}} {my_dict} {}-args7-kwargs7-{nope} {'a': 1} {{!}}]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d05ab0>
message = '{{nope}} {my_dict} {}', args = ['{{!}}']
kwargs = {'my_dict': {'a': 1}}, expected = "{nope} {'a': 1} {{!}}"
use_log_function = False

    @pytest.mark.parametrize(
        "message, args, kwargs, expected",
        [
            ("{1, 2, 3} - {0} - {", [], {}, "{1, 2, 3} - {0} - {"),
            ("{} + {} = {}", [1, 2, 3], {}, "1 + 2 = 3"),
            ("{a} + {b} = {c}", [], dict(a=1, b=2, c=3), "1 + 2 = 3"),
            ("{0} + {two} = {1}", [1, 3], dict(two=2, nope=4), "1 + 2 = 3"),
            (
                "{self} or {message} or {level}",
                [],
                dict(self="a", message="b", level="c"),
                "a or b or c",
            ),
            ("{:.2f}", [1], {}, "1.00"),
            ("{0:0{three}d}", [5], dict(three=3), "005"),
            ("{{nope}} {my_dict} {}", ["{{!}}"], dict(my_dict={"a": 1}), "{nope} {'a': 1} {{!}}"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatting(writer, message, args, kwargs, expected, use_log_function):
        logger.add(writer, format="{message}", colorize=False)

        if use_log_function:
            logger.log(10, message, *args, **kwargs)
        else:
            logger.debug(message, *args, **kwargs)

>       assert writer.read() == expected + "\n"
E       assert '' == "{nope} {'a': 1} {{!}}\n"
E         
E         - {nope} {'a': 1} {{!}}

args       = ['{{!}}']
expected   = "{nope} {'a': 1} {{!}}"
kwargs     = {'my_dict': {'a': 1}}
message    = '{{nope}} {my_dict} {}'
use_log_function = False
writer     = <function writer.<locals>.w at 0x7fac07d05ab0>

tests/test_formatting.py:113: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattingtrue-1-2-3-0-args0-kwargs0-1-2-3-0-">test_formatting.py::test_log_formatting[True-{1, 2, 3} - {0} - {-args0-kwargs0-{1, 2, 3} - {0} - {]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatting[True-{1, 2, 3} - {0} - {-args0-kwargs0-{1, 2, 3} - {0} - {]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0812d7e0>
message = '{1, 2, 3} - {0} - {', args = [], kwargs = {}
expected = '{1, 2, 3} - {0} - {', use_log_function = True

    @pytest.mark.parametrize(
        "message, args, kwargs, expected",
        [
            ("{1, 2, 3} - {0} - {", [], {}, "{1, 2, 3} - {0} - {"),
            ("{} + {} = {}", [1, 2, 3], {}, "1 + 2 = 3"),
            ("{a} + {b} = {c}", [], dict(a=1, b=2, c=3), "1 + 2 = 3"),
            ("{0} + {two} = {1}", [1, 3], dict(two=2, nope=4), "1 + 2 = 3"),
            (
                "{self} or {message} or {level}",
                [],
                dict(self="a", message="b", level="c"),
                "a or b or c",
            ),
            ("{:.2f}", [1], {}, "1.00"),
            ("{0:0{three}d}", [5], dict(three=3), "005"),
            ("{{nope}} {my_dict} {}", ["{{!}}"], dict(my_dict={"a": 1}), "{nope} {'a': 1} {{!}}"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatting(writer, message, args, kwargs, expected, use_log_function):
        logger.add(writer, format="{message}", colorize=False)

        if use_log_function:
            logger.log(10, message, *args, **kwargs)
        else:
            logger.debug(message, *args, **kwargs)

>       assert writer.read() == expected + "\n"
E       AssertionError: assert '' == '{1, 2, 3} - {0} - {\n'
E         
E         - {1, 2, 3} - {0} - {

args       = []
expected   = '{1, 2, 3} - {0} - {'
kwargs     = {}
message    = '{1, 2, 3} - {0} - {'
use_log_function = True
writer     = <function writer.<locals>.w at 0x7fac0812d7e0>

tests/test_formatting.py:113: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattingtrue-args1-kwargs1-1-2-3">test_formatting.py::test_log_formatting[True-{} + {} = {}-args1-kwargs1-1 + 2 = 3]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatting[True-{} + {} = {}-args1-kwargs1-1 + 2 = 3]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d06f80>
message = '{} + {} = {}', args = [1, 2, 3], kwargs = {}, expected = '1 + 2 = 3'
use_log_function = True

    @pytest.mark.parametrize(
        "message, args, kwargs, expected",
        [
            ("{1, 2, 3} - {0} - {", [], {}, "{1, 2, 3} - {0} - {"),
            ("{} + {} = {}", [1, 2, 3], {}, "1 + 2 = 3"),
            ("{a} + {b} = {c}", [], dict(a=1, b=2, c=3), "1 + 2 = 3"),
            ("{0} + {two} = {1}", [1, 3], dict(two=2, nope=4), "1 + 2 = 3"),
            (
                "{self} or {message} or {level}",
                [],
                dict(self="a", message="b", level="c"),
                "a or b or c",
            ),
            ("{:.2f}", [1], {}, "1.00"),
            ("{0:0{three}d}", [5], dict(three=3), "005"),
            ("{{nope}} {my_dict} {}", ["{{!}}"], dict(my_dict={"a": 1}), "{nope} {'a': 1} {{!}}"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatting(writer, message, args, kwargs, expected, use_log_function):
        logger.add(writer, format="{message}", colorize=False)

        if use_log_function:
            logger.log(10, message, *args, **kwargs)
        else:
            logger.debug(message, *args, **kwargs)

>       assert writer.read() == expected + "\n"
E       AssertionError: assert '' == '1 + 2 = 3\n'
E         
E         - 1 + 2 = 3

args       = [1, 2, 3]
expected   = '1 + 2 = 3'
kwargs     = {}
message    = '{} + {} = {}'
use_log_function = True
writer     = <function writer.<locals>.w at 0x7fac07d06f80>

tests/test_formatting.py:113: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattingtrue-a-b-c-args2-kwargs2-1-2-3">test_formatting.py::test_log_formatting[True-{a} + {b} = {c}-args2-kwargs2-1 + 2 = 3]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatting[True-{a} + {b} = {c}-args2-kwargs2-1 + 2 = 3]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d07130>
message = '{a} + {b} = {c}', args = [], kwargs = {'a': 1, 'b': 2, 'c': 3}
expected = '1 + 2 = 3', use_log_function = True

    @pytest.mark.parametrize(
        "message, args, kwargs, expected",
        [
            ("{1, 2, 3} - {0} - {", [], {}, "{1, 2, 3} - {0} - {"),
            ("{} + {} = {}", [1, 2, 3], {}, "1 + 2 = 3"),
            ("{a} + {b} = {c}", [], dict(a=1, b=2, c=3), "1 + 2 = 3"),
            ("{0} + {two} = {1}", [1, 3], dict(two=2, nope=4), "1 + 2 = 3"),
            (
                "{self} or {message} or {level}",
                [],
                dict(self="a", message="b", level="c"),
                "a or b or c",
            ),
            ("{:.2f}", [1], {}, "1.00"),
            ("{0:0{three}d}", [5], dict(three=3), "005"),
            ("{{nope}} {my_dict} {}", ["{{!}}"], dict(my_dict={"a": 1}), "{nope} {'a': 1} {{!}}"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatting(writer, message, args, kwargs, expected, use_log_function):
        logger.add(writer, format="{message}", colorize=False)

        if use_log_function:
            logger.log(10, message, *args, **kwargs)
        else:
            logger.debug(message, *args, **kwargs)

>       assert writer.read() == expected + "\n"
E       AssertionError: assert '' == '1 + 2 = 3\n'
E         
E         - 1 + 2 = 3

args       = []
expected   = '1 + 2 = 3'
kwargs     = {'a': 1, 'b': 2, 'c': 3}
message    = '{a} + {b} = {c}'
use_log_function = True
writer     = <function writer.<locals>.w at 0x7fac07d07130>

tests/test_formatting.py:113: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattingtrue-0-two-1-args3-kwargs3-1-2-3">test_formatting.py::test_log_formatting[True-{0} + {two} = {1}-args3-kwargs3-1 + 2 = 3]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatting[True-{0} + {two} = {1}-args3-kwargs3-1 + 2 = 3]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d05630>
message = '{0} + {two} = {1}', args = [1, 3], kwargs = {'nope': 4, 'two': 2}
expected = '1 + 2 = 3', use_log_function = True

    @pytest.mark.parametrize(
        "message, args, kwargs, expected",
        [
            ("{1, 2, 3} - {0} - {", [], {}, "{1, 2, 3} - {0} - {"),
            ("{} + {} = {}", [1, 2, 3], {}, "1 + 2 = 3"),
            ("{a} + {b} = {c}", [], dict(a=1, b=2, c=3), "1 + 2 = 3"),
            ("{0} + {two} = {1}", [1, 3], dict(two=2, nope=4), "1 + 2 = 3"),
            (
                "{self} or {message} or {level}",
                [],
                dict(self="a", message="b", level="c"),
                "a or b or c",
            ),
            ("{:.2f}", [1], {}, "1.00"),
            ("{0:0{three}d}", [5], dict(three=3), "005"),
            ("{{nope}} {my_dict} {}", ["{{!}}"], dict(my_dict={"a": 1}), "{nope} {'a': 1} {{!}}"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatting(writer, message, args, kwargs, expected, use_log_function):
        logger.add(writer, format="{message}", colorize=False)

        if use_log_function:
            logger.log(10, message, *args, **kwargs)
        else:
            logger.debug(message, *args, **kwargs)

>       assert writer.read() == expected + "\n"
E       AssertionError: assert '' == '1 + 2 = 3\n'
E         
E         - 1 + 2 = 3

args       = [1, 3]
expected   = '1 + 2 = 3'
kwargs     = {'nope': 4, 'two': 2}
message    = '{0} + {two} = {1}'
use_log_function = True
writer     = <function writer.<locals>.w at 0x7fac07d05630>

tests/test_formatting.py:113: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattingtrue-self-or-message-or-level-args4-kwargs4-a-or-b-or-c">test_formatting.py::test_log_formatting[True-{self} or {message} or {level}-args4-kwargs4-a or b or c]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatting[True-{self} or {message} or {level}-args4-kwargs4-a or b or c]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d05c60>
message = '{self} or {message} or {level}', args = []
kwargs = {'level': 'c', 'message': 'b', 'self': 'a'}, expected = 'a or b or c'
use_log_function = True

    @pytest.mark.parametrize(
        "message, args, kwargs, expected",
        [
            ("{1, 2, 3} - {0} - {", [], {}, "{1, 2, 3} - {0} - {"),
            ("{} + {} = {}", [1, 2, 3], {}, "1 + 2 = 3"),
            ("{a} + {b} = {c}", [], dict(a=1, b=2, c=3), "1 + 2 = 3"),
            ("{0} + {two} = {1}", [1, 3], dict(two=2, nope=4), "1 + 2 = 3"),
            (
                "{self} or {message} or {level}",
                [],
                dict(self="a", message="b", level="c"),
                "a or b or c",
            ),
            ("{:.2f}", [1], {}, "1.00"),
            ("{0:0{three}d}", [5], dict(three=3), "005"),
            ("{{nope}} {my_dict} {}", ["{{!}}"], dict(my_dict={"a": 1}), "{nope} {'a': 1} {{!}}"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatting(writer, message, args, kwargs, expected, use_log_function):
        logger.add(writer, format="{message}", colorize=False)

        if use_log_function:
            logger.log(10, message, *args, **kwargs)
        else:
            logger.debug(message, *args, **kwargs)

>       assert writer.read() == expected + "\n"
E       AssertionError: assert '' == 'a or b or c\n'
E         
E         - a or b or c

args       = []
expected   = 'a or b or c'
kwargs     = {'level': 'c', 'message': 'b', 'self': 'a'}
message    = '{self} or {message} or {level}'
use_log_function = True
writer     = <function writer.<locals>.w at 0x7fac07d05c60>

tests/test_formatting.py:113: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattingtrue-2f-args5-kwargs5-100">test_formatting.py::test_log_formatting[True-{:.2f}-args5-kwargs5-1.00]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatting[True-{:.2f}-args5-kwargs5-1.00]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d065f0>, message = '{:.2f}'
args = [1], kwargs = {}, expected = '1.00', use_log_function = True

    @pytest.mark.parametrize(
        "message, args, kwargs, expected",
        [
            ("{1, 2, 3} - {0} - {", [], {}, "{1, 2, 3} - {0} - {"),
            ("{} + {} = {}", [1, 2, 3], {}, "1 + 2 = 3"),
            ("{a} + {b} = {c}", [], dict(a=1, b=2, c=3), "1 + 2 = 3"),
            ("{0} + {two} = {1}", [1, 3], dict(two=2, nope=4), "1 + 2 = 3"),
            (
                "{self} or {message} or {level}",
                [],
                dict(self="a", message="b", level="c"),
                "a or b or c",
            ),
            ("{:.2f}", [1], {}, "1.00"),
            ("{0:0{three}d}", [5], dict(three=3), "005"),
            ("{{nope}} {my_dict} {}", ["{{!}}"], dict(my_dict={"a": 1}), "{nope} {'a': 1} {{!}}"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatting(writer, message, args, kwargs, expected, use_log_function):
        logger.add(writer, format="{message}", colorize=False)

        if use_log_function:
            logger.log(10, message, *args, **kwargs)
        else:
            logger.debug(message, *args, **kwargs)

>       assert writer.read() == expected + "\n"
E       AssertionError: assert '' == '1.00\n'
E         
E         - 1.00

args       = [1]
expected   = '1.00'
kwargs     = {}
message    = '{:.2f}'
use_log_function = True
writer     = <function writer.<locals>.w at 0x7fac07d065f0>

tests/test_formatting.py:113: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattingtrue-00threed-args6-kwargs6-005">test_formatting.py::test_log_formatting[True-{0:0{three}d}-args6-kwargs6-005]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatting[True-{0:0{three}d}-args6-kwargs6-005]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d05090>
message = '{0:0{three}d}', args = [5], kwargs = {'three': 3}, expected = '005'
use_log_function = True

    @pytest.mark.parametrize(
        "message, args, kwargs, expected",
        [
            ("{1, 2, 3} - {0} - {", [], {}, "{1, 2, 3} - {0} - {"),
            ("{} + {} = {}", [1, 2, 3], {}, "1 + 2 = 3"),
            ("{a} + {b} = {c}", [], dict(a=1, b=2, c=3), "1 + 2 = 3"),
            ("{0} + {two} = {1}", [1, 3], dict(two=2, nope=4), "1 + 2 = 3"),
            (
                "{self} or {message} or {level}",
                [],
                dict(self="a", message="b", level="c"),
                "a or b or c",
            ),
            ("{:.2f}", [1], {}, "1.00"),
            ("{0:0{three}d}", [5], dict(three=3), "005"),
            ("{{nope}} {my_dict} {}", ["{{!}}"], dict(my_dict={"a": 1}), "{nope} {'a': 1} {{!}}"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatting(writer, message, args, kwargs, expected, use_log_function):
        logger.add(writer, format="{message}", colorize=False)

        if use_log_function:
            logger.log(10, message, *args, **kwargs)
        else:
            logger.debug(message, *args, **kwargs)

>       assert writer.read() == expected + "\n"
E       AssertionError: assert '' == '005\n'
E         
E         - 005

args       = [5]
expected   = '005'
kwargs     = {'three': 3}
message    = '{0:0{three}d}'
use_log_function = True
writer     = <function writer.<locals>.w at 0x7fac07d05090>

tests/test_formatting.py:113: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_log_formattingtrue-nope-my_dict-args7-kwargs7-nope-a-1">test_formatting.py::test_log_formatting[True-{{nope}} {my_dict} {}-args7-kwargs7-{nope} {'a': 1} {{!}}]</h3>
<details><summary> <pre>test_formatting.py::test_log_formatting[True-{{nope}} {my_dict} {}-args7-kwargs7-{nope} {'a': 1} {{!}}]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d05c60>
message = '{{nope}} {my_dict} {}', args = ['{{!}}']
kwargs = {'my_dict': {'a': 1}}, expected = "{nope} {'a': 1} {{!}}"
use_log_function = True

    @pytest.mark.parametrize(
        "message, args, kwargs, expected",
        [
            ("{1, 2, 3} - {0} - {", [], {}, "{1, 2, 3} - {0} - {"),
            ("{} + {} = {}", [1, 2, 3], {}, "1 + 2 = 3"),
            ("{a} + {b} = {c}", [], dict(a=1, b=2, c=3), "1 + 2 = 3"),
            ("{0} + {two} = {1}", [1, 3], dict(two=2, nope=4), "1 + 2 = 3"),
            (
                "{self} or {message} or {level}",
                [],
                dict(self="a", message="b", level="c"),
                "a or b or c",
            ),
            ("{:.2f}", [1], {}, "1.00"),
            ("{0:0{three}d}", [5], dict(three=3), "005"),
            ("{{nope}} {my_dict} {}", ["{{!}}"], dict(my_dict={"a": 1}), "{nope} {'a': 1} {{!}}"),
        ],
    )
    @pytest.mark.parametrize("use_log_function", [False, True])
    def test_log_formatting(writer, message, args, kwargs, expected, use_log_function):
        logger.add(writer, format="{message}", colorize=False)

        if use_log_function:
            logger.log(10, message, *args, **kwargs)
        else:
            logger.debug(message, *args, **kwargs)

>       assert writer.read() == expected + "\n"
E       assert '' == "{nope} {'a': 1} {{!}}\n"
E         
E         - {nope} {'a': 1} {{!}}

args       = ['{{!}}']
expected   = "{nope} {'a': 1} {{!}}"
kwargs     = {'my_dict': {'a': 1}}
message    = '{{nope}} {my_dict} {}'
use_log_function = True
writer     = <function writer.<locals>.w at 0x7fac07d05c60>

tests/test_formatting.py:113: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_f_globals_name_absent">test_formatting.py::test_f_globals_name_absent</h3>
<details><summary> <pre>test_formatting.py::test_f_globals_name_absent</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d043a0>
f_globals_name_absent = None

    def test_f_globals_name_absent(writer, f_globals_name_absent):
        logger.add(writer, format="{name} {message}", colorize=False)
        logger.info("Foobar")
>       assert writer.read() == "None Foobar\n"
E       AssertionError: assert '' == 'None Foobar\n'
E         
E         - None Foobar

f_globals_name_absent = None
writer     = <function writer.<locals>.w at 0x7fac07d043a0>

tests/test_formatting.py:119: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_extra_formatting">test_formatting.py::test_extra_formatting</h3>
<details><summary> <pre>test_formatting.py::test_extra_formatting</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d06950>

    def test_extra_formatting(writer):
        logger.configure(extra={"test": "my_test", "dict": {"a": 10}})
        logger.add(writer, format="{extra[test]} -> {extra[dict]} -> {message}")
        logger.debug("level: {name}", name="DEBUG")
>       assert writer.read() == "my_test -> {'a': 10} -> level: DEBUG\n"
E       assert '' == "my_test -> {...evel: DEBUG\n"
E         
E         - my_test -> {'a': 10} -> level: DEBUG

writer     = <function writer.<locals>.w at 0x7fac07d06950>

tests/test_formatting.py:126: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_kwargs_in_extra_dict">test_formatting.py::test_kwargs_in_extra_dict</h3>
<details><summary> <pre>test_formatting.py::test_kwargs_in_extra_dict</pre></summary><pre>
def test_kwargs_in_extra_dict():
        extra_dicts = []
        messages = []

        def sink(message):
            extra_dicts.append(message.record["extra"])
            messages.append(str(message))

        logger.add(sink, format="{message}")
        logger.info("A")
        logger.info("B", foo=123)
>       logger.bind(merge=True).info("C", other=False)
E       AttributeError: 'NoneType' object has no attribute 'info'

extra_dicts = []
messages   = []
sink       = <function test_kwargs_in_extra_dict.<locals>.sink at 0x7fac07d07880>

tests/test_formatting.py:140: AttributeError
</pre>
</details>
<h3 id="test_formattingpytest_non_string_message">test_formatting.py::test_non_string_message</h3>
<details><summary> <pre>test_formatting.py::test_non_string_message</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d07760>

    def test_non_string_message(writer):
        logger.add(writer, format="{message}")

        logger.info(1)
        logger.info({})
        logger.info(b"test")

>       assert writer.read() == "1\n{}\nb'test'\n"
E       assert '' == "1\n{}\nb'test'\n"
E         
E         - 1
E         - {}
E         - b'test'

writer     = <function writer.<locals>.w at 0x7fac07d07760>

tests/test_formatting.py:177: AssertionError
</pre>
</details>
<h3 id="test_formattingpytest_non_string_message_is_str_in_recordtrue">test_formatting.py::test_non_string_message_is_str_in_record[True]</h3>
<details><summary> <pre>test_formatting.py::test_non_string_message_is_str_in_record[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d076d0>, colors = True

    @pytest.mark.parametrize("colors", [True, False])
    def test_non_string_message_is_str_in_record(writer, colors):
        output = ""

        def sink(message):
            nonlocal output
            assert isinstance(message.record["message"], str)
            output += message

        def format(record):
            assert isinstance(record["message"], str)
            return "[{message}]\n"

        logger.add(sink, format=format, catch=False)
>       logger.opt(colors=colors).info(123)
E       AttributeError: 'NoneType' object has no attribute 'info'

colors     = True
format     = <function test_non_string_message_is_str_in_record.<locals>.format at 0x7fac07d07b50>
output     = ''
sink       = <function test_non_string_message_is_str_in_record.<locals>.sink at 0x7fac07d07910>
writer     = <function writer.<locals>.w at 0x7fac07d076d0>

tests/test_formatting.py:194: AttributeError
</pre>
</details>
<h3 id="test_formattingpytest_non_string_message_is_str_in_recordfalse">test_formatting.py::test_non_string_message_is_str_in_record[False]</h3>
<details><summary> <pre>test_formatting.py::test_non_string_message_is_str_in_record[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d07520>, colors = False

    @pytest.mark.parametrize("colors", [True, False])
    def test_non_string_message_is_str_in_record(writer, colors):
        output = ""

        def sink(message):
            nonlocal output
            assert isinstance(message.record["message"], str)
            output += message

        def format(record):
            assert isinstance(record["message"], str)
            return "[{message}]\n"

        logger.add(sink, format=format, catch=False)
>       logger.opt(colors=colors).info(123)
E       AttributeError: 'NoneType' object has no attribute 'info'

colors     = False
format     = <function test_non_string_message_is_str_in_record.<locals>.format at 0x7fac07d07eb0>
output     = ''
sink       = <function test_non_string_message_is_str_in_record.<locals>.sink at 0x7fac07d07be0>
writer     = <function writer.<locals>.w at 0x7fac07d07520>

tests/test_formatting.py:194: AttributeError
</pre>
</details>
<h3 id="test_formattingpytest_missing_positional_field_during_formattingtrue">test_formatting.py::test_missing_positional_field_during_formatting[True]</h3>
<details><summary> <pre>test_formatting.py::test_missing_positional_field_during_formatting[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d05090>, colors = True

    @pytest.mark.parametrize("colors", [True, False])
    def test_missing_positional_field_during_formatting(writer, colors):
        logger.add(writer)

        with pytest.raises(IndexError):
>           logger.opt(colors=colors).info("Foo {} {}", 123)
E           AttributeError: 'NoneType' object has no attribute 'info'

colors     = True
writer     = <function writer.<locals>.w at 0x7fac07d05090>

tests/test_formatting.py:203: AttributeError
</pre>
</details>
<h3 id="test_formattingpytest_missing_positional_field_during_formattingfalse">test_formatting.py::test_missing_positional_field_during_formatting[False]</h3>
<details><summary> <pre>test_formatting.py::test_missing_positional_field_during_formatting[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d07ac0>, colors = False

    @pytest.mark.parametrize("colors", [True, False])
    def test_missing_positional_field_during_formatting(writer, colors):
        logger.add(writer)

        with pytest.raises(IndexError):
>           logger.opt(colors=colors).info("Foo {} {}", 123)
E           AttributeError: 'NoneType' object has no attribute 'info'

colors     = False
writer     = <function writer.<locals>.w at 0x7fac07d07ac0>

tests/test_formatting.py:203: AttributeError
</pre>
</details>
<h3 id="test_formattingpytest_missing_named_field_during_formattingtrue">test_formatting.py::test_missing_named_field_during_formatting[True]</h3>
<details><summary> <pre>test_formatting.py::test_missing_named_field_during_formatting[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0812e9e0>, colors = True

    @pytest.mark.parametrize("colors", [True, False])
    def test_missing_named_field_during_formatting(writer, colors):
        logger.add(writer)

        with pytest.raises(KeyError):
>           logger.opt(colors=colors).info("Foo {bar}", baz=123)
E           AttributeError: 'NoneType' object has no attribute 'info'

colors     = True
writer     = <function writer.<locals>.w at 0x7fac0812e9e0>

tests/test_formatting.py:211: AttributeError
</pre>
</details>
<h3 id="test_formattingpytest_missing_named_field_during_formattingfalse">test_formatting.py::test_missing_named_field_during_formatting[False]</h3>
<details><summary> <pre>test_formatting.py::test_missing_named_field_during_formatting[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d079a0>, colors = False

    @pytest.mark.parametrize("colors", [True, False])
    def test_missing_named_field_during_formatting(writer, colors):
        logger.add(writer)

        with pytest.raises(KeyError):
>           logger.opt(colors=colors).info("Foo {bar}", baz=123)
E           AttributeError: 'NoneType' object has no attribute 'info'

colors     = False
writer     = <function writer.<locals>.w at 0x7fac07d079a0>

tests/test_formatting.py:211: AttributeError
</pre>
</details>
<h3 id="test_formattingpytest_not_formattable_message">test_formatting.py::test_not_formattable_message</h3>
<details><summary> <pre>test_formatting.py::test_not_formattable_message</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d07490>

    def test_not_formattable_message(writer):
        logger.add(writer)

>       with pytest.raises(AttributeError):
E       Failed: DID NOT RAISE <class 'AttributeError'>

writer     = <function writer.<locals>.w at 0x7fac07d07490>

tests/test_formatting.py:217: Failed
</pre>
</details>
<h3 id="test_formattingpytest_not_formattable_message_with_colors">test_formatting.py::test_not_formattable_message_with_colors</h3>
<details><summary> <pre>test_formatting.py::test_not_formattable_message_with_colors</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d05ea0>

    def test_not_formattable_message_with_colors(writer):
        logger.add(writer)

        with pytest.raises(TypeError):
>           logger.opt(colors=True).info(123, baz=456)
E           AttributeError: 'NoneType' object has no attribute 'info'

writer     = <function writer.<locals>.w at 0x7fac07d05ea0>

tests/test_formatting.py:225: AttributeError
</pre>
</details>
<h3 id="test_formattingpytest_invalid_color_markup">test_formatting.py::test_invalid_color_markup</h3>
<details><summary> <pre>test_formatting.py::test_invalid_color_markup</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d05090>

    def test_invalid_color_markup(writer):
>       with pytest.raises(ValueError):
E       Failed: DID NOT RAISE <class 'ValueError'>

writer     = <function writer.<locals>.w at 0x7fac07d05090>

tests/test_formatting.py:229: Failed
</pre>
</details>
<h3 id="test_get_framepytest_with_sys_getframe">test_get_frame.py::test_with_sys_getframe</h3>
<details><summary> <pre>test_get_frame.py::test_with_sys_getframe</pre></summary><pre>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0885c040>

    def test_with_sys_getframe(monkeypatch):
        def patched():
            return

        monkeypatch.setattr(sys, "_getframe", patched())
>       assert load_get_frame_function() == patched()
E       assert <function load_get_frame_function.<locals>.get_frame at 0x7fac07d07d00> == None
E        +  where <function load_get_frame_function.<locals>.get_frame at 0x7fac07d07d00> = load_get_frame_function()
E        +  and   None = <function test_with_sys_getframe.<locals>.patched at 0x7fac07d05ea0>()

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac0885c040>
patched    = <function test_with_sys_getframe.<locals>.patched at 0x7fac07d05ea0>

tests/test_get_frame.py:12: AssertionError
</pre>
</details>
<h3 id="test_get_framepytest_without_sys_getframe">test_get_frame.py::test_without_sys_getframe</h3>
<details><summary> <pre>test_get_frame.py::test_without_sys_getframe</pre></summary><pre>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac088e85e0>

    def test_without_sys_getframe(monkeypatch):
        monkeypatch.delattr(sys, "_getframe")
>       assert load_get_frame_function() == loguru._get_frame.get_frame_fallback
E       AttributeError: module 'loguru._get_frame' has no attribute 'get_frame_fallback'

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac088e85e0>

tests/test_get_frame.py:17: AttributeError
</pre>
</details>
<h3 id="test_get_framepytest_get_frame_fallback">test_get_frame.py::test_get_frame_fallback</h3>
<details><summary> <pre>test_get_frame.py::test_get_frame_fallback</pre></summary><pre>
def test_get_frame_fallback():
        frame_root = frame_a = frame_b = None

        def a():
            nonlocal frame_a
            frame_a = loguru._get_frame.get_frame_fallback(1)
            b()

        def b():
            nonlocal frame_b
            frame_b = loguru._get_frame.get_frame_fallback(2)

>       frame_root = loguru._get_frame.get_frame_fallback(0)
E       AttributeError: module 'loguru._get_frame' has no attribute 'get_frame_fallback'

a          = <function test_get_frame_fallback.<locals>.a at 0x7fac07d07c70>
b          = <function test_get_frame_fallback.<locals>.b at 0x7fac07d9c1f0>
frame_a    = None
frame_b    = None
frame_root = None

tests/test_get_frame.py:32: AttributeError
</pre>
</details>
<h3 id="test_interceptionpytest_formatting">test_interception.py::test_formatting</h3>
<details><summary> <pre>test_interception.py::test_formatting</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d07520>

    def test_formatting(writer):
        fmt = (
            "{name} - {file.name} - {function} - {level.name} - "
            "{level.no} - {line} - {module} - {message}"
        )

        expected = (
            "tests.test_interception - test_interception.py - test_formatting - DEBUG - "
            "10 - 39 - test_interception - This is the message\n"
        )

        with make_logging_logger("tests", InterceptHandler()) as logging_logger:
            logger.add(writer, format=fmt)
>           logging_logger.debug("This is the %s", "message")

expected   = 'tests.test_interception - test_interception.py - test_formatting - DEBUG - 10 - 39 - test_interception - This is the message\n'
fmt        = '{name} - {file.name} - {function} - {level.name} - {level.no} - {line} - {module} - {message}'
logging_logger = <Logger tests (DEBUG)>
writer     = <function writer.<locals>.w at 0x7fac07d07520>

tests/test_interception.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/logging/__init__.py:1465: in debug
    self._log(DEBUG, msg, args, **kwargs)
        args       = ('message',)
        kwargs     = {}
        msg        = 'This is the %s'
        self       = <Logger tests (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:1624: in _log
    self.handle(record)
        args       = ('message',)
        exc_info   = None
        extra      = None
        fn         = '/testbed/tests/test_interception.py'
        func       = 'test_formatting'
        level      = 10
        lno        = 39
        msg        = 'This is the %s'
        record     = <LogRecord: tests, 10, /testbed/tests/test_interception.py, 39, "This is the %s">
        self       = <Logger tests (DEBUG)>
        sinfo      = None
        stack_info = False
        stacklevel = 1
/usr/lib/python3.10/logging/__init__.py:1634: in handle
    self.callHandlers(record)
        record     = <LogRecord: tests, 10, /testbed/tests/test_interception.py, 39, "This is the %s">
        self       = <Logger tests (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:1696: in callHandlers
    hdlr.handle(record)
        c          = <Logger tests (DEBUG)>
        found      = 1
        hdlr       = <InterceptHandler (DEBUG)>
        record     = <LogRecord: tests, 10, /testbed/tests/test_interception.py, 39, "This is the %s">
        self       = <Logger tests (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:968: in handle
    self.emit(record)
        record     = <LogRecord: tests, 10, /testbed/tests/test_interception.py, 39, "This is the %s">
        rv         = True
        self       = <InterceptHandler (DEBUG)>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <InterceptHandler (DEBUG)>
record = <LogRecord: tests, 10, /testbed/tests/test_interception.py, 39, "This is the %s">

    def emit(self, record):
        # Get corresponding Loguru level if it exists.
        try:
>           level = logger.level(record.levelname).name
E           AttributeError: 'NoneType' object has no attribute 'name'

record     = <LogRecord: tests, 10, /testbed/tests/test_interception.py, 39, "This is the %s">
self       = <InterceptHandler (DEBUG)>

tests/test_interception.py:13: AttributeError
</pre>
</details>
<h3 id="test_interceptionpytest_intercept">test_interception.py::test_intercept</h3>
<details><summary> <pre>test_interception.py::test_intercept</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d9edd0>

    def test_intercept(writer):
        with make_logging_logger(None, InterceptHandler()) as logging_logger:
>           logging_logger.info("Nope")

logging_logger = <RootLogger root (DEBUG)>
writer     = <function writer.<locals>.w at 0x7fac07d9edd0>

tests/test_interception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/logging/__init__.py:1477: in info
    self._log(INFO, msg, args, **kwargs)
        args       = ()
        kwargs     = {}
        msg        = 'Nope'
        self       = <RootLogger root (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:1624: in _log
    self.handle(record)
        args       = ()
        exc_info   = None
        extra      = None
        fn         = '/testbed/tests/test_interception.py'
        func       = 'test_intercept'
        level      = 20
        lno        = 47
        msg        = 'Nope'
        record     = <LogRecord: root, 20, /testbed/tests/test_interception.py, 47, "Nope">
        self       = <RootLogger root (DEBUG)>
        sinfo      = None
        stack_info = False
        stacklevel = 1
/usr/lib/python3.10/logging/__init__.py:1634: in handle
    self.callHandlers(record)
        record     = <LogRecord: root, 20, /testbed/tests/test_interception.py, 47, "Nope">
        self       = <RootLogger root (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:1696: in callHandlers
    hdlr.handle(record)
        c          = <RootLogger root (DEBUG)>
        found      = 6
        hdlr       = <InterceptHandler (DEBUG)>
        record     = <LogRecord: root, 20, /testbed/tests/test_interception.py, 47, "Nope">
        self       = <RootLogger root (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:968: in handle
    self.emit(record)
        record     = <LogRecord: root, 20, /testbed/tests/test_interception.py, 47, "Nope">
        rv         = True
        self       = <InterceptHandler (DEBUG)>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <InterceptHandler (DEBUG)>
record = <LogRecord: root, 20, /testbed/tests/test_interception.py, 47, "Nope">

    def emit(self, record):
        # Get corresponding Loguru level if it exists.
        try:
>           level = logger.level(record.levelname).name
E           AttributeError: 'NoneType' object has no attribute 'name'

record     = <LogRecord: root, 20, /testbed/tests/test_interception.py, 47, "Nope">
self       = <InterceptHandler (DEBUG)>

tests/test_interception.py:13: AttributeError
</pre>
</details>
<h3 id="test_interceptionpytest_add_before_intercept">test_interception.py::test_add_before_intercept</h3>
<details><summary> <pre>test_interception.py::test_add_before_intercept</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d9c310>

    def test_add_before_intercept(writer):
        logger.add(writer, format="{message}")

        with make_logging_logger(None, InterceptHandler()) as logging_logger:
>           logging_logger.info("Test")

logging_logger = <RootLogger root (DEBUG)>
writer     = <function writer.<locals>.w at 0x7fac07d9c310>

tests/test_interception.py:59: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/logging/__init__.py:1477: in info
    self._log(INFO, msg, args, **kwargs)
        args       = ()
        kwargs     = {}
        msg        = 'Test'
        self       = <RootLogger root (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:1624: in _log
    self.handle(record)
        args       = ()
        exc_info   = None
        extra      = None
        fn         = '/testbed/tests/test_interception.py'
        func       = 'test_add_before_intercept'
        level      = 20
        lno        = 59
        msg        = 'Test'
        record     = <LogRecord: root, 20, /testbed/tests/test_interception.py, 59, "Test">
        self       = <RootLogger root (DEBUG)>
        sinfo      = None
        stack_info = False
        stacklevel = 1
/usr/lib/python3.10/logging/__init__.py:1634: in handle
    self.callHandlers(record)
        record     = <LogRecord: root, 20, /testbed/tests/test_interception.py, 59, "Test">
        self       = <RootLogger root (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:1696: in callHandlers
    hdlr.handle(record)
        c          = <RootLogger root (DEBUG)>
        found      = 6
        hdlr       = <InterceptHandler (DEBUG)>
        record     = <LogRecord: root, 20, /testbed/tests/test_interception.py, 59, "Test">
        self       = <RootLogger root (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:968: in handle
    self.emit(record)
        record     = <LogRecord: root, 20, /testbed/tests/test_interception.py, 59, "Test">
        rv         = True
        self       = <InterceptHandler (DEBUG)>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <InterceptHandler (DEBUG)>
record = <LogRecord: root, 20, /testbed/tests/test_interception.py, 59, "Test">

    def emit(self, record):
        # Get corresponding Loguru level if it exists.
        try:
>           level = logger.level(record.levelname).name
E           AttributeError: 'NoneType' object has no attribute 'name'

record     = <LogRecord: root, 20, /testbed/tests/test_interception.py, 59, "Test">
self       = <InterceptHandler (DEBUG)>

tests/test_interception.py:13: AttributeError
</pre>
</details>
<h3 id="test_interceptionpytest_remove_interception">test_interception.py::test_remove_interception</h3>
<details><summary> <pre>test_interception.py::test_remove_interception</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0812d3f0>

    def test_remove_interception(writer):
        h = InterceptHandler()

        with make_logging_logger("foobar", h) as logging_logger:
            logger.add(writer, format="{message}")
>           logging_logger.debug("1")

h          = <InterceptHandler (DEBUG)>
logging_logger = <Logger foobar (DEBUG)>
writer     = <function writer.<locals>.w at 0x7fac0812d3f0>

tests/test_interception.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/logging/__init__.py:1465: in debug
    self._log(DEBUG, msg, args, **kwargs)
        args       = ()
        kwargs     = {}
        msg        = '1'
        self       = <Logger foobar (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:1624: in _log
    self.handle(record)
        args       = ()
        exc_info   = None
        extra      = None
        fn         = '/testbed/tests/test_interception.py'
        func       = 'test_remove_interception'
        level      = 10
        lno        = 70
        msg        = '1'
        record     = <LogRecord: foobar, 10, /testbed/tests/test_interception.py, 70, "1">
        self       = <Logger foobar (DEBUG)>
        sinfo      = None
        stack_info = False
        stacklevel = 1
/usr/lib/python3.10/logging/__init__.py:1634: in handle
    self.callHandlers(record)
        record     = <LogRecord: foobar, 10, /testbed/tests/test_interception.py, 70, "1">
        self       = <Logger foobar (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:1696: in callHandlers
    hdlr.handle(record)
        c          = <Logger foobar (DEBUG)>
        found      = 1
        hdlr       = <InterceptHandler (DEBUG)>
        record     = <LogRecord: foobar, 10, /testbed/tests/test_interception.py, 70, "1">
        self       = <Logger foobar (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:968: in handle
    self.emit(record)
        record     = <LogRecord: foobar, 10, /testbed/tests/test_interception.py, 70, "1">
        rv         = True
        self       = <InterceptHandler (DEBUG)>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <InterceptHandler (DEBUG)>
record = <LogRecord: foobar, 10, /testbed/tests/test_interception.py, 70, "1">

    def emit(self, record):
        # Get corresponding Loguru level if it exists.
        try:
>           level = logger.level(record.levelname).name
E           AttributeError: 'NoneType' object has no attribute 'name'

record     = <LogRecord: foobar, 10, /testbed/tests/test_interception.py, 70, "1">
self       = <InterceptHandler (DEBUG)>

tests/test_interception.py:13: AttributeError
</pre>
</details>
<h3 id="test_interceptionpytest_multiple_intercept">test_interception.py::test_multiple_intercept</h3>
<details><summary> <pre>test_interception.py::test_multiple_intercept</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d06c20>

    def test_multiple_intercept(writer):
        with make_logging_logger("test_1", InterceptHandler()) as logging_logger_1:
            with make_logging_logger("test_2", InterceptHandler()) as logging_logger_2:
                logger.add(writer, format="{message}")
>               logging_logger_1.info("1")

logging_logger_1 = <Logger test_1 (DEBUG)>
logging_logger_2 = <Logger test_2 (DEBUG)>
writer     = <function writer.<locals>.w at 0x7fac07d06c20>

tests/test_interception.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/logging/__init__.py:1477: in info
    self._log(INFO, msg, args, **kwargs)
        args       = ()
        kwargs     = {}
        msg        = '1'
        self       = <Logger test_1 (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:1624: in _log
    self.handle(record)
        args       = ()
        exc_info   = None
        extra      = None
        fn         = '/testbed/tests/test_interception.py'
        func       = 'test_multiple_intercept'
        level      = 20
        lno        = 92
        msg        = '1'
        record     = <LogRecord: test_1, 20, /testbed/tests/test_interception.py, 92, "1">
        self       = <Logger test_1 (DEBUG)>
        sinfo      = None
        stack_info = False
        stacklevel = 1
/usr/lib/python3.10/logging/__init__.py:1634: in handle
    self.callHandlers(record)
        record     = <LogRecord: test_1, 20, /testbed/tests/test_interception.py, 92, "1">
        self       = <Logger test_1 (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:1696: in callHandlers
    hdlr.handle(record)
        c          = <Logger test_1 (DEBUG)>
        found      = 1
        hdlr       = <InterceptHandler (DEBUG)>
        record     = <LogRecord: test_1, 20, /testbed/tests/test_interception.py, 92, "1">
        self       = <Logger test_1 (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:968: in handle
    self.emit(record)
        record     = <LogRecord: test_1, 20, /testbed/tests/test_interception.py, 92, "1">
        rv         = True
        self       = <InterceptHandler (DEBUG)>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <InterceptHandler (DEBUG)>
record = <LogRecord: test_1, 20, /testbed/tests/test_interception.py, 92, "1">

    def emit(self, record):
        # Get corresponding Loguru level if it exists.
        try:
>           level = logger.level(record.levelname).name
E           AttributeError: 'NoneType' object has no attribute 'name'

record     = <LogRecord: test_1, 20, /testbed/tests/test_interception.py, 92, "1">
self       = <InterceptHandler (DEBUG)>

tests/test_interception.py:13: AttributeError
</pre>
</details>
<h3 id="test_interceptionpytest_exception">test_interception.py::test_exception</h3>
<details><summary> <pre>test_interception.py::test_exception</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d06b00>

    def test_exception(writer):
        with make_logging_logger("tests.test_interception", InterceptHandler()) as logging_logger:
            logger.add(writer, format="{message}")

            try:
>               1 / 0  # noqa: B018
E               ZeroDivisionError: division by zero

logging_logger = <Logger tests.test_interception (DEBUG)>
writer     = <function writer.<locals>.w at 0x7fac07d06b00>

tests/test_interception.py:104: ZeroDivisionError

During handling of the above exception, another exception occurred:

writer = <function writer.<locals>.w at 0x7fac07d06b00>

    def test_exception(writer):
        with make_logging_logger("tests.test_interception", InterceptHandler()) as logging_logger:
            logger.add(writer, format="{message}")

            try:
                1 / 0  # noqa: B018
            except Exception:
>               logging_logger.exception("Oops...")

logging_logger = <Logger tests.test_interception (DEBUG)>
writer     = <function writer.<locals>.w at 0x7fac07d06b00>

tests/test_interception.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/logging/__init__.py:1512: in exception
    self.error(msg, *args, exc_info=exc_info, **kwargs)
        args       = ()
        exc_info   = True
        kwargs     = {}
        msg        = 'Oops...'
        self       = <Logger tests.test_interception (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:1506: in error
    self._log(ERROR, msg, args, **kwargs)
        args       = ()
        kwargs     = {'exc_info': True}
        msg        = 'Oops...'
        self       = <Logger tests.test_interception (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:1624: in _log
    self.handle(record)
        args       = ()
        exc_info   = (<class 'ZeroDivisionError'>, ZeroDivisionError('division by zero'), <traceback object at 0x7fac0bb2c180>)
        extra      = None
        fn         = '/testbed/tests/test_interception.py'
        func       = 'test_exception'
        level      = 40
        lno        = 106
        msg        = 'Oops...'
        record     = <LogRecord: tests.test_interception, 40, /testbed/tests/test_interception.py, 106, "Oops...">
        self       = <Logger tests.test_interception (DEBUG)>
        sinfo      = None
        stack_info = False
        stacklevel = 1
/usr/lib/python3.10/logging/__init__.py:1634: in handle
    self.callHandlers(record)
        record     = <LogRecord: tests.test_interception, 40, /testbed/tests/test_interception.py, 106, "Oops...">
        self       = <Logger tests.test_interception (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:1696: in callHandlers
    hdlr.handle(record)
        c          = <Logger tests.test_interception (DEBUG)>
        found      = 1
        hdlr       = <InterceptHandler (DEBUG)>
        record     = <LogRecord: tests.test_interception, 40, /testbed/tests/test_interception.py, 106, "Oops...">
        self       = <Logger tests.test_interception (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:968: in handle
    self.emit(record)
        record     = <LogRecord: tests.test_interception, 40, /testbed/tests/test_interception.py, 106, "Oops...">
        rv         = True
        self       = <InterceptHandler (DEBUG)>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <InterceptHandler (DEBUG)>
record = <LogRecord: tests.test_interception, 40, /testbed/tests/test_interception.py, 106, "Oops...">

    def emit(self, record):
        # Get corresponding Loguru level if it exists.
        try:
>           level = logger.level(record.levelname).name
E           AttributeError: 'NoneType' object has no attribute 'name'

record     = <LogRecord: tests.test_interception, 40, /testbed/tests/test_interception.py, 106, "Oops...">
self       = <InterceptHandler (DEBUG)>

tests/test_interception.py:13: AttributeError
</pre>
</details>
<h3 id="test_interceptionpytest_level_is_no">test_interception.py::test_level_is_no</h3>
<details><summary> <pre>test_interception.py::test_level_is_no</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d07d00>

    def test_level_is_no(writer):
        with make_logging_logger("tests", InterceptHandler()) as logging_logger:
            logger.add(writer, format="<lvl>{level.no} - {level.name} - {message}</lvl>", colorize=True)
>           logging_logger.log(12, "Hop")

logging_logger = <Logger tests (DEBUG)>
writer     = <function writer.<locals>.w at 0x7fac07d07d00>

tests/test_interception.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/logging/__init__.py:1547: in log
    self._log(level, msg, args, **kwargs)
        args       = ()
        kwargs     = {}
        level      = 12
        msg        = 'Hop'
        self       = <Logger tests (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:1624: in _log
    self.handle(record)
        args       = ()
        exc_info   = None
        extra      = None
        fn         = '/testbed/tests/test_interception.py'
        func       = 'test_level_is_no'
        level      = 12
        lno        = 117
        msg        = 'Hop'
        record     = <LogRecord: tests, 12, /testbed/tests/test_interception.py, 117, "Hop">
        self       = <Logger tests (DEBUG)>
        sinfo      = None
        stack_info = False
        stacklevel = 1
/usr/lib/python3.10/logging/__init__.py:1634: in handle
    self.callHandlers(record)
        record     = <LogRecord: tests, 12, /testbed/tests/test_interception.py, 117, "Hop">
        self       = <Logger tests (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:1696: in callHandlers
    hdlr.handle(record)
        c          = <Logger tests (DEBUG)>
        found      = 1
        hdlr       = <InterceptHandler (DEBUG)>
        record     = <LogRecord: tests, 12, /testbed/tests/test_interception.py, 117, "Hop">
        self       = <Logger tests (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:968: in handle
    self.emit(record)
        record     = <LogRecord: tests, 12, /testbed/tests/test_interception.py, 117, "Hop">
        rv         = True
        self       = <InterceptHandler (DEBUG)>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <InterceptHandler (DEBUG)>
record = <LogRecord: tests, 12, /testbed/tests/test_interception.py, 117, "Hop">

    def emit(self, record):
        # Get corresponding Loguru level if it exists.
        try:
>           level = logger.level(record.levelname).name
E           AttributeError: 'NoneType' object has no attribute 'name'

record     = <LogRecord: tests, 12, /testbed/tests/test_interception.py, 117, "Hop">
self       = <InterceptHandler (DEBUG)>

tests/test_interception.py:13: AttributeError
</pre>
</details>
<h3 id="test_interceptionpytest_level_does_not_exist">test_interception.py::test_level_does_not_exist</h3>
<details><summary> <pre>test_interception.py::test_level_does_not_exist</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac0812e9e0>

    def test_level_does_not_exist(writer):
        logging.addLevelName(152, "FANCY_LEVEL")

        with make_logging_logger("tests", InterceptHandler()) as logging_logger:
            logger.add(writer, format="<lvl>{level.no} - {level.name} - {message}</lvl>", colorize=True)
>           logging_logger.log(152, "Nop")

logging_logger = <Logger tests (DEBUG)>
writer     = <function writer.<locals>.w at 0x7fac0812e9e0>

tests/test_interception.py:128: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/logging/__init__.py:1547: in log
    self._log(level, msg, args, **kwargs)
        args       = ()
        kwargs     = {}
        level      = 152
        msg        = 'Nop'
        self       = <Logger tests (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:1624: in _log
    self.handle(record)
        args       = ()
        exc_info   = None
        extra      = None
        fn         = '/testbed/tests/test_interception.py'
        func       = 'test_level_does_not_exist'
        level      = 152
        lno        = 128
        msg        = 'Nop'
        record     = <LogRecord: tests, 152, /testbed/tests/test_interception.py, 128, "Nop">
        self       = <Logger tests (DEBUG)>
        sinfo      = None
        stack_info = False
        stacklevel = 1
/usr/lib/python3.10/logging/__init__.py:1634: in handle
    self.callHandlers(record)
        record     = <LogRecord: tests, 152, /testbed/tests/test_interception.py, 128, "Nop">
        self       = <Logger tests (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:1696: in callHandlers
    hdlr.handle(record)
        c          = <Logger tests (DEBUG)>
        found      = 1
        hdlr       = <InterceptHandler (DEBUG)>
        record     = <LogRecord: tests, 152, /testbed/tests/test_interception.py, 128, "Nop">
        self       = <Logger tests (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:968: in handle
    self.emit(record)
        record     = <LogRecord: tests, 152, /testbed/tests/test_interception.py, 128, "Nop">
        rv         = True
        self       = <InterceptHandler (DEBUG)>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <InterceptHandler (DEBUG)>
record = <LogRecord: tests, 152, /testbed/tests/test_interception.py, 128, "Nop">

    def emit(self, record):
        # Get corresponding Loguru level if it exists.
        try:
>           level = logger.level(record.levelname).name
E           AttributeError: 'NoneType' object has no attribute 'name'

record     = <LogRecord: tests, 152, /testbed/tests/test_interception.py, 128, "Nop">
self       = <InterceptHandler (DEBUG)>

tests/test_interception.py:13: AttributeError
</pre>
</details>
<h3 id="test_interceptionpytest_level_exist_builtin">test_interception.py::test_level_exist_builtin</h3>
<details><summary> <pre>test_interception.py::test_level_exist_builtin</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d9e950>

    def test_level_exist_builtin(writer):
        with make_logging_logger("tests", InterceptHandler()) as logging_logger:
            logger.add(writer, format="<lvl>{level.no} - {level.name} - {message}</lvl>", colorize=True)
>           logging_logger.error("Error...")

logging_logger = <Logger tests (DEBUG)>
writer     = <function writer.<locals>.w at 0x7fac07d9e950>

tests/test_interception.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/logging/__init__.py:1506: in error
    self._log(ERROR, msg, args, **kwargs)
        args       = ()
        kwargs     = {}
        msg        = 'Error...'
        self       = <Logger tests (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:1624: in _log
    self.handle(record)
        args       = ()
        exc_info   = None
        extra      = None
        fn         = '/testbed/tests/test_interception.py'
        func       = 'test_level_exist_builtin'
        level      = 40
        lno        = 137
        msg        = 'Error...'
        record     = <LogRecord: tests, 40, /testbed/tests/test_interception.py, 137, "Error...">
        self       = <Logger tests (DEBUG)>
        sinfo      = None
        stack_info = False
        stacklevel = 1
/usr/lib/python3.10/logging/__init__.py:1634: in handle
    self.callHandlers(record)
        record     = <LogRecord: tests, 40, /testbed/tests/test_interception.py, 137, "Error...">
        self       = <Logger tests (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:1696: in callHandlers
    hdlr.handle(record)
        c          = <Logger tests (DEBUG)>
        found      = 1
        hdlr       = <InterceptHandler (DEBUG)>
        record     = <LogRecord: tests, 40, /testbed/tests/test_interception.py, 137, "Error...">
        self       = <Logger tests (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:968: in handle
    self.emit(record)
        record     = <LogRecord: tests, 40, /testbed/tests/test_interception.py, 137, "Error...">
        rv         = True
        self       = <InterceptHandler (DEBUG)>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <InterceptHandler (DEBUG)>
record = <LogRecord: tests, 40, /testbed/tests/test_interception.py, 137, "Error...">

    def emit(self, record):
        # Get corresponding Loguru level if it exists.
        try:
>           level = logger.level(record.levelname).name
E           AttributeError: 'NoneType' object has no attribute 'name'

record     = <LogRecord: tests, 40, /testbed/tests/test_interception.py, 137, "Error...">
self       = <InterceptHandler (DEBUG)>

tests/test_interception.py:13: AttributeError
</pre>
</details>
<h3 id="test_interceptionpytest_level_exists_custom">test_interception.py::test_level_exists_custom</h3>
<details><summary> <pre>test_interception.py::test_level_exists_custom</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d9e4d0>

    def test_level_exists_custom(writer):
        logging.addLevelName(99, "ANOTHER_FANCY_LEVEL")
        logger.level("ANOTHER_FANCY_LEVEL", no=99, color="<green>", icon="")

        with make_logging_logger("tests", InterceptHandler()) as logging_logger:
            logger.add(writer, format="<lvl>{level.no} - {level.name} - {message}</lvl>", colorize=True)
>           logging_logger.log(99, "Yep!")

logging_logger = <Logger tests (DEBUG)>
writer     = <function writer.<locals>.w at 0x7fac07d9e4d0>

tests/test_interception.py:149: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/logging/__init__.py:1547: in log
    self._log(level, msg, args, **kwargs)
        args       = ()
        kwargs     = {}
        level      = 99
        msg        = 'Yep!'
        self       = <Logger tests (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:1624: in _log
    self.handle(record)
        args       = ()
        exc_info   = None
        extra      = None
        fn         = '/testbed/tests/test_interception.py'
        func       = 'test_level_exists_custom'
        level      = 99
        lno        = 149
        msg        = 'Yep!'
        record     = <LogRecord: tests, 99, /testbed/tests/test_interception.py, 149, "Yep!">
        self       = <Logger tests (DEBUG)>
        sinfo      = None
        stack_info = False
        stacklevel = 1
/usr/lib/python3.10/logging/__init__.py:1634: in handle
    self.callHandlers(record)
        record     = <LogRecord: tests, 99, /testbed/tests/test_interception.py, 149, "Yep!">
        self       = <Logger tests (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:1696: in callHandlers
    hdlr.handle(record)
        c          = <Logger tests (DEBUG)>
        found      = 1
        hdlr       = <InterceptHandler (DEBUG)>
        record     = <LogRecord: tests, 99, /testbed/tests/test_interception.py, 149, "Yep!">
        self       = <Logger tests (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:968: in handle
    self.emit(record)
        record     = <LogRecord: tests, 99, /testbed/tests/test_interception.py, 149, "Yep!">
        rv         = True
        self       = <InterceptHandler (DEBUG)>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <InterceptHandler (DEBUG)>
record = <LogRecord: tests, 99, /testbed/tests/test_interception.py, 149, "Yep!">

    def emit(self, record):
        # Get corresponding Loguru level if it exists.
        try:
>           level = logger.level(record.levelname).name
E           AttributeError: 'NoneType' object has no attribute 'name'

record     = <LogRecord: tests, 99, /testbed/tests/test_interception.py, 149, "Yep!">
self       = <InterceptHandler (DEBUG)>

tests/test_interception.py:13: AttributeError
</pre>
</details>
<h3 id="test_interceptionpytest_using_logging_function">test_interception.py::test_using_logging_function</h3>
<details><summary> <pre>test_interception.py::test_using_logging_function</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07d9e560>

    def test_using_logging_function(writer):
        with make_logging_logger(None, InterceptHandler()):
            logger.add(writer, format="{function} {line} {module} {file.name} {message}")
>           logging.warning("ABC")

writer     = <function writer.<locals>.w at 0x7fac07d9e560>

tests/test_interception.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/logging/__init__.py:2123: in warning
    root.warning(msg, *args, **kwargs)
        args       = ()
        kwargs     = {}
        msg        = 'ABC'
/usr/lib/python3.10/logging/__init__.py:1489: in warning
    self._log(WARNING, msg, args, **kwargs)
        args       = ()
        kwargs     = {}
        msg        = 'ABC'
        self       = <RootLogger root (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:1624: in _log
    self.handle(record)
        args       = ()
        exc_info   = None
        extra      = None
        fn         = '/testbed/tests/test_interception.py'
        func       = 'test_using_logging_function'
        level      = 30
        lno        = 158
        msg        = 'ABC'
        record     = <LogRecord: root, 30, /testbed/tests/test_interception.py, 158, "ABC">
        self       = <RootLogger root (DEBUG)>
        sinfo      = None
        stack_info = False
        stacklevel = 1
/usr/lib/python3.10/logging/__init__.py:1634: in handle
    self.callHandlers(record)
        record     = <LogRecord: root, 30, /testbed/tests/test_interception.py, 158, "ABC">
        self       = <RootLogger root (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:1696: in callHandlers
    hdlr.handle(record)
        c          = <RootLogger root (DEBUG)>
        found      = 6
        hdlr       = <InterceptHandler (DEBUG)>
        record     = <LogRecord: root, 30, /testbed/tests/test_interception.py, 158, "ABC">
        self       = <RootLogger root (DEBUG)>
/usr/lib/python3.10/logging/__init__.py:968: in handle
    self.emit(record)
        record     = <LogRecord: root, 30, /testbed/tests/test_interception.py, 158, "ABC">
        rv         = True
        self       = <InterceptHandler (DEBUG)>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <InterceptHandler (DEBUG)>
record = <LogRecord: root, 30, /testbed/tests/test_interception.py, 158, "ABC">

    def emit(self, record):
        # Get corresponding Loguru level if it exists.
        try:
>           level = logger.level(record.levelname).name
E           AttributeError: 'NoneType' object has no attribute 'name'

record     = <LogRecord: root, 30, /testbed/tests/test_interception.py, 158, "ABC">
self       = <InterceptHandler (DEBUG)>

tests/test_interception.py:13: AttributeError
</pre>
</details>
<h3 id="test_lockspytest_no_deadlock_if_logger_used_inside_sink_with_catch">test_locks.py::test_no_deadlock_if_logger_used_inside_sink_with_catch</h3>
<details><summary> <pre>test_locks.py::test_no_deadlock_if_logger_used_inside_sink_with_catch</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0876f3a0>

    def test_no_deadlock_if_logger_used_inside_sink_with_catch(capsys):
        def sink(message):
            logger.info(message)

        logger.add(sink, colorize=False, catch=True)

        logger.info("Test")

        out, err = capsys.readouterr()
        assert out == ""
>       assert "deadlock avoided" in err
E       AssertionError: assert 'deadlock avoided' in ''

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0876f3a0>
err        = ''
out        = ''
sink       = <function test_no_deadlock_if_logger_used_inside_sink_with_catch.<locals>.sink at 0x7fac0812dc60>

tests/test_locks.py:81: AssertionError
</pre>
</details>
<h3 id="test_lockspytest_no_deadlock_if_logger_used_inside_sink_without_catch">test_locks.py::test_no_deadlock_if_logger_used_inside_sink_without_catch</h3>
<details><summary> <pre>test_locks.py::test_no_deadlock_if_logger_used_inside_sink_without_catch</pre></summary><pre>
def test_no_deadlock_if_logger_used_inside_sink_without_catch():
        def sink(message):
            logger.info(message)

        logger.add(sink, colorize=False, catch=False)

>       with pytest.raises(RuntimeError, match=r".*deadlock avoided.*"):
E       Failed: DID NOT RAISE <class 'RuntimeError'>

sink       = <function test_no_deadlock_if_logger_used_inside_sink_without_catch.<locals>.sink at 0x7fac0812e9e0>

tests/test_locks.py:90: Failed
</pre>
</details>
<h3 id="test_lockspytest_no_error_if_multithreading">test_locks.py::test_no_error_if_multithreading</h3>
<details><summary> <pre>test_locks.py::test_no_error_if_multithreading</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0876c730>

    def test_no_error_if_multithreading(capsys):
        barrier = threading.Barrier(2)

        def sink(message):
            barrier.wait()
            sys.stderr.write(message)
            time.sleep(0.5)  # Give time to the other thread to try to acquire the lock.

        def worker():
            logger.info("Thread message")
            barrier.wait()  # Release main thread.

        logger.add(sink, colorize=False, catch=False, format="{message}")
        thread = threading.Thread(target=worker)
        thread.start()

        barrier.wait()
        logger.info("Main message")

        out, err = capsys.readouterr()
        assert out == ""
>       assert err == "Thread message\nMain message\n"
E       AssertionError: assert '' == 'Thread messa...ain message\n'
E         
E         - Thread message
E         - Main message

barrier    = <threading.Barrier object at 0x7fac0876f370>
capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0876c730>
err        = ''
out        = ''
sink       = <function test_no_error_if_multithreading.<locals>.sink at 0x7fac07df5870>
thread     = <Thread(Thread-26 (worker), stopped 140376274875968)>
worker     = <function test_no_error_if_multithreading.<locals>.worker at 0x7fac07df5900>

tests/test_locks.py:115: AssertionError
</pre>
</details>
<h3 id="test_lockspytest_pickled_logger_does_not_inherit_acquired_local">test_locks.py::test_pickled_logger_does_not_inherit_acquired_local</h3>
<details><summary> <pre>test_locks.py::test_pickled_logger_does_not_inherit_acquired_local</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac083c8970>

    def test_pickled_logger_does_not_inherit_acquired_local(capsys):
        logger.add(_pickle_sink, colorize=False, catch=False, format="{message}")

>       logger.bind(clone=True).info("From main")
E       AttributeError: 'NoneType' object has no attribute 'info'

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac083c8970>

tests/test_locks.py:129: AttributeError
</pre>
</details>
<h3 id="test_multiprocessingpytest_apply_spawn">test_multiprocessing.py::test_apply_spawn</h3>
<details><summary> <pre>test_multiprocessing.py::test_apply_spawn</pre></summary><pre>
spawn_context = <multiprocessing.context.SpawnContext object at 0x7fac0d34afb0>

    def test_apply_spawn(spawn_context):
        writer = Writer()

        logger.add(writer, context=spawn_context, format="{message}", enqueue=True, catch=False)

        with spawn_context.Pool(1, set_logger, [logger]) as pool:
            for i in range(3):
                pool.apply(do_something, (i,))
            pool.close()
            pool.join()

        logger.info("Done!")
        logger.remove()

>       assert writer.read() == "#0\n#1\n#2\nDone!\n"
E       AssertionError: assert '' == '#0\n#1\n#2\nDone!\n'
E         
E         - #0
E         - #1
E         - #2
E         - Done!

i          = 2
pool       = <multiprocessing.pool.Pool state=TERMINATE pool_size=1>
spawn_context = <multiprocessing.context.SpawnContext object at 0x7fac0d34afb0>
writer     = <tests.test_multiprocessing.Writer object at 0x7fac082e59f0>

tests/test_multiprocessing.py:111: AssertionError
</pre>
</details>
<h3 id="test_multiprocessingpytest_apply_fork">test_multiprocessing.py::test_apply_fork</h3>
<details><summary> <pre>test_multiprocessing.py::test_apply_fork</pre></summary><pre>
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>

    @pytest.mark.skipif(os.name == "nt", reason="Windows does not support forking")
    def test_apply_fork(fork_context):
        writer = Writer()

        logger.add(writer, context=fork_context, format="{message}", enqueue=True, catch=False)

        with fork_context.Pool(1, set_logger, [logger]) as pool:
            for i in range(3):
                pool.apply(do_something, (i,))
            pool.close()
            pool.join()

        logger.info("Done!")
        logger.remove()

>       assert writer.read() == "#0\n#1\n#2\nDone!\n"
E       AssertionError: assert '' == '#0\n#1\n#2\nDone!\n'
E         
E         - #0
E         - #1
E         - #2
E         - Done!

fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>
i          = 2
pool       = <multiprocessing.pool.Pool state=TERMINATE pool_size=1>
writer     = <tests.test_multiprocessing.Writer object at 0x7fac08254250>

tests/test_multiprocessing.py:129: AssertionError
</pre>
</details>
<h3 id="test_multiprocessingpytest_apply_inheritance">test_multiprocessing.py::test_apply_inheritance</h3>
<details><summary> <pre>test_multiprocessing.py::test_apply_inheritance</pre></summary><pre>
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>

    @pytest.mark.skipif(os.name == "nt", reason="Windows does not support forking")
    def test_apply_inheritance(fork_context):
        writer = Writer()

        logger.add(writer, context=fork_context, format="{message}", enqueue=True, catch=False)

        with fork_context.Pool(1) as pool:
            for i in range(3):
                pool.apply(do_something, (i,))
            pool.close()
            pool.join()

        logger.info("Done!")
        logger.remove()

>       assert writer.read() == "#0\n#1\n#2\nDone!\n"
E       AssertionError: assert '' == '#0\n#1\n#2\nDone!\n'
E         
E         - #0
E         - #1
E         - #2
E         - Done!

fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>
i          = 2
pool       = <multiprocessing.pool.Pool state=TERMINATE pool_size=1>
writer     = <tests.test_multiprocessing.Writer object at 0x7fac0820e0b0>

tests/test_multiprocessing.py:147: AssertionError
</pre>
</details>
<h3 id="test_multiprocessingpytest_apply_async_spawn">test_multiprocessing.py::test_apply_async_spawn</h3>
<details><summary> <pre>test_multiprocessing.py::test_apply_async_spawn</pre></summary><pre>
spawn_context = <multiprocessing.context.SpawnContext object at 0x7fac0d34afb0>

    def test_apply_async_spawn(spawn_context):
        writer = Writer()

        logger.add(writer, context=spawn_context, format="{message}", enqueue=True, catch=False)

        with spawn_context.Pool(1, set_logger, [logger]) as pool:
            for i in range(3):
                result = pool.apply_async(do_something, (i,))
                result.get()
            pool.close()
            pool.join()

        logger.info("Done!")
        logger.remove()

>       assert writer.read() == "#0\n#1\n#2\nDone!\n"
E       AssertionError: assert '' == '#0\n#1\n#2\nDone!\n'
E         
E         - #0
E         - #1
E         - #2
E         - Done!

i          = 2
pool       = <multiprocessing.pool.Pool state=TERMINATE pool_size=1>
result     = <multiprocessing.pool.ApplyResult object at 0x7fac083ff8b0>
spawn_context = <multiprocessing.context.SpawnContext object at 0x7fac0d34afb0>
writer     = <tests.test_multiprocessing.Writer object at 0x7fac083fe590>

tests/test_multiprocessing.py:165: AssertionError
</pre>
</details>
<h3 id="test_multiprocessingpytest_apply_async_fork">test_multiprocessing.py::test_apply_async_fork</h3>
<details><summary> <pre>test_multiprocessing.py::test_apply_async_fork</pre></summary><pre>
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>

    @pytest.mark.skipif(os.name == "nt", reason="Windows does not support forking")
    def test_apply_async_fork(fork_context):
        writer = Writer()

        logger.add(writer, context=fork_context, format="{message}", enqueue=True, catch=False)

        with fork_context.Pool(1, set_logger, [logger]) as pool:
            for i in range(3):
                result = pool.apply_async(do_something, (i,))
                result.get()
            pool.close()
            pool.join()

        logger.info("Done!")
        logger.remove()

>       assert writer.read() == "#0\n#1\n#2\nDone!\n"
E       AssertionError: assert '' == '#0\n#1\n#2\nDone!\n'
E         
E         - #0
E         - #1
E         - #2
E         - Done!

fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>
i          = 2
pool       = <multiprocessing.pool.Pool state=TERMINATE pool_size=1>
result     = <multiprocessing.pool.ApplyResult object at 0x7fac082913c0>
writer     = <tests.test_multiprocessing.Writer object at 0x7fac0820da20>

tests/test_multiprocessing.py:184: AssertionError
</pre>
</details>
<h3 id="test_multiprocessingpytest_apply_async_inheritance">test_multiprocessing.py::test_apply_async_inheritance</h3>
<details><summary> <pre>test_multiprocessing.py::test_apply_async_inheritance</pre></summary><pre>
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>

    @pytest.mark.skipif(os.name == "nt", reason="Windows does not support forking")
    def test_apply_async_inheritance(fork_context):
        writer = Writer()

        logger.add(writer, context=fork_context, format="{message}", enqueue=True, catch=False)

        with fork_context.Pool(1) as pool:
            for i in range(3):
                result = pool.apply_async(do_something, (i,))
                result.get()
            pool.close()
            pool.join()

        logger.info("Done!")
        logger.remove()

>       assert writer.read() == "#0\n#1\n#2\nDone!\n"
E       AssertionError: assert '' == '#0\n#1\n#2\nDone!\n'
E         
E         - #0
E         - #1
E         - #2
E         - Done!

fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>
i          = 2
pool       = <multiprocessing.pool.Pool state=TERMINATE pool_size=1>
result     = <multiprocessing.pool.ApplyResult object at 0x7fac0ba9d5a0>
writer     = <tests.test_multiprocessing.Writer object at 0x7fac083fde70>

tests/test_multiprocessing.py:203: AssertionError
</pre>
</details>
<h3 id="test_multiprocessingpytest_process_spawn">test_multiprocessing.py::test_process_spawn</h3>
<details><summary> <pre>test_multiprocessing.py::test_process_spawn</pre></summary><pre>
spawn_context = <multiprocessing.context.SpawnContext object at 0x7fac0d34afb0>

    def test_process_spawn(spawn_context):
        writer = Writer()

        logger.add(writer, context=spawn_context, format="{message}", enqueue=True, catch=False)

        process = spawn_context.Process(target=subworker, args=(logger,))
        process.start()
        process.join()

        assert process.exitcode == 0

        logger.info("Main")
        logger.remove()

>       assert writer.read() == "Child\nMain\n"
E       AssertionError: assert '' == 'Child\nMain\n'
E         
E         - Child
E         - Main

process    = <SpawnProcess name='SpawnProcess-8' pid=142 parent=8 stopped exitcode=0>
spawn_context = <multiprocessing.context.SpawnContext object at 0x7fac0d34afb0>
writer     = <tests.test_multiprocessing.Writer object at 0x7fac082e9ab0>

tests/test_multiprocessing.py:220: AssertionError
</pre>
</details>
<h3 id="test_multiprocessingpytest_process_fork">test_multiprocessing.py::test_process_fork</h3>
<details><summary> <pre>test_multiprocessing.py::test_process_fork</pre></summary><pre>
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>

    @pytest.mark.skipif(os.name == "nt", reason="Windows does not support forking")
    def test_process_fork(fork_context):
        writer = Writer()

        logger.add(writer, context=fork_context, format="{message}", enqueue=True, catch=False)

        process = fork_context.Process(target=subworker, args=(logger,))
        process.start()
        process.join()

        assert process.exitcode == 0

        logger.info("Main")
        logger.remove()

>       assert writer.read() == "Child\nMain\n"
E       AssertionError: assert '' == 'Child\nMain\n'
E         
E         - Child
E         - Main

fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>
process    = <ForkProcess name='ForkProcess-9' pid=143 parent=8 stopped exitcode=0>
writer     = <tests.test_multiprocessing.Writer object at 0x7fac087e2290>

tests/test_multiprocessing.py:238: AssertionError
</pre>
</details>
<h3 id="test_multiprocessingpytest_process_inheritance">test_multiprocessing.py::test_process_inheritance</h3>
<details><summary> <pre>test_multiprocessing.py::test_process_inheritance</pre></summary><pre>
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>

    @pytest.mark.skipif(os.name == "nt", reason="Windows does not support forking")
    def test_process_inheritance(fork_context):
        writer = Writer()

        logger.add(writer, context=fork_context, format="{message}", enqueue=True, catch=False)

        process = fork_context.Process(target=subworker_inheritance)
        process.start()
        process.join()

        assert process.exitcode == 0

        logger.info("Main")
        logger.remove()

>       assert writer.read() == "Child\nMain\n"
E       AssertionError: assert '' == 'Child\nMain\n'
E         
E         - Child
E         - Main

fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>
process    = <ForkProcess name='ForkProcess-10' pid=144 parent=8 stopped exitcode=0>
writer     = <tests.test_multiprocessing.Writer object at 0x7fac082ea740>

tests/test_multiprocessing.py:256: AssertionError
</pre>
</details>
<h3 id="test_multiprocessingpytest_remove_in_child_process_spawn">test_multiprocessing.py::test_remove_in_child_process_spawn</h3>
<details><summary> <pre>test_multiprocessing.py::test_remove_in_child_process_spawn</pre></summary><pre>
spawn_context = <multiprocessing.context.SpawnContext object at 0x7fac0d34afb0>

    def test_remove_in_child_process_spawn(spawn_context):
        writer = Writer()

        logger.add(writer, context=spawn_context, format="{message}", enqueue=True, catch=False)

        process = spawn_context.Process(target=subworker_remove, args=(logger,))
        process.start()
        process.join()

        assert process.exitcode == 0

        logger.info("Main")
        logger.remove()

>       assert writer.read() == "Child\nMain\n"
E       AssertionError: assert '' == 'Child\nMain\n'
E         
E         - Child
E         - Main

process    = <SpawnProcess name='SpawnProcess-11' pid=145 parent=8 stopped exitcode=0>
spawn_context = <multiprocessing.context.SpawnContext object at 0x7fac0d34afb0>
writer     = <tests.test_multiprocessing.Writer object at 0x7fac08256080>

tests/test_multiprocessing.py:273: AssertionError
</pre>
</details>
<h3 id="test_multiprocessingpytest_remove_in_child_process_fork">test_multiprocessing.py::test_remove_in_child_process_fork</h3>
<details><summary> <pre>test_multiprocessing.py::test_remove_in_child_process_fork</pre></summary><pre>
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>

    @pytest.mark.skipif(os.name == "nt", reason="Windows does not support forking")
    def test_remove_in_child_process_fork(fork_context):
        writer = Writer()

        logger.add(writer, context=fork_context, format="{message}", enqueue=True, catch=False)

        process = fork_context.Process(target=subworker_remove, args=(logger,))
        process.start()
        process.join()

        assert process.exitcode == 0

        logger.info("Main")
        logger.remove()

>       assert writer.read() == "Child\nMain\n"
E       AssertionError: assert '' == 'Child\nMain\n'
E         
E         - Child
E         - Main

fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>
process    = <ForkProcess name='ForkProcess-12' pid=146 parent=8 stopped exitcode=0>
writer     = <tests.test_multiprocessing.Writer object at 0x7fac082eab90>

tests/test_multiprocessing.py:291: AssertionError
</pre>
</details>
<h3 id="test_multiprocessingpytest_remove_in_child_process_inheritance">test_multiprocessing.py::test_remove_in_child_process_inheritance</h3>
<details><summary> <pre>test_multiprocessing.py::test_remove_in_child_process_inheritance</pre></summary><pre>
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>

    @pytest.mark.skipif(os.name == "nt", reason="Windows does not support forking")
    def test_remove_in_child_process_inheritance(fork_context):
        writer = Writer()

        logger.add(writer, context=fork_context, format="{message}", enqueue=True, catch=False)

        process = fork_context.Process(target=subworker_remove_inheritance)
        process.start()
        process.join()

        assert process.exitcode == 0

        logger.info("Main")
        logger.remove()

>       assert writer.read() == "Child\nMain\n"
E       AssertionError: assert '' == 'Child\nMain\n'
E         
E         - Child
E         - Main

fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>
process    = <ForkProcess name='ForkProcess-13' pid=147 parent=8 stopped exitcode=0>
writer     = <tests.test_multiprocessing.Writer object at 0x7fac08256410>

tests/test_multiprocessing.py:309: AssertionError
</pre>
</details>
<h3 id="test_multiprocessingpytest_remove_in_main_process_spawn">test_multiprocessing.py::test_remove_in_main_process_spawn</h3>
<details><summary> <pre>test_multiprocessing.py::test_remove_in_main_process_spawn</pre></summary><pre>
spawn_context = <multiprocessing.context.SpawnContext object at 0x7fac0d34afb0>

    def test_remove_in_main_process_spawn(spawn_context):
        # Actually, this test may fail if sleep time in main process is too small (and no barrier used)
        # In such situation, it seems the child process has not enough time to initialize itself
        # It may fail with an "EOFError" during unpickling of the (garbage collected / closed) Queue
        writer = Writer()
        barrier = spawn_context.Barrier(2)

        logger.add(writer, context=spawn_context, format="{message}", enqueue=True, catch=False)

        process = spawn_context.Process(target=subworker_barrier, args=(logger, barrier))
        process.start()
        barrier.wait()
        logger.info("Main")
        logger.remove()
        process.join()

        assert process.exitcode == 0

>       assert writer.read() == "Child\nMain\n"
E       AssertionError: assert '' == 'Child\nMain\n'
E         
E         - Child
E         - Main

barrier    = <multiprocessing.synchronize.Barrier object at 0x7fac087eef50>
process    = <SpawnProcess name='SpawnProcess-14' pid=148 parent=8 stopped exitcode=0>
spawn_context = <multiprocessing.context.SpawnContext object at 0x7fac0d34afb0>
writer     = <tests.test_multiprocessing.Writer object at 0x7fac087efa90>

tests/test_multiprocessing.py:330: AssertionError
</pre>
</details>
<h3 id="test_multiprocessingpytest_remove_in_main_process_fork">test_multiprocessing.py::test_remove_in_main_process_fork</h3>
<details><summary> <pre>test_multiprocessing.py::test_remove_in_main_process_fork</pre></summary><pre>
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>

    @pytest.mark.skipif(os.name == "nt", reason="Windows does not support forking")
    def test_remove_in_main_process_fork(fork_context):
        writer = Writer()
        barrier = fork_context.Barrier(2)

        logger.add(writer, context=fork_context, format="{message}", enqueue=True, catch=False)

        process = fork_context.Process(target=subworker_barrier, args=(logger, barrier))
        process.start()
        barrier.wait()
        logger.info("Main")
        logger.remove()
        process.join()

        assert process.exitcode == 0

>       assert writer.read() == "Child\nMain\n"
E       AssertionError: assert '' == 'Child\nMain\n'
E         
E         - Child
E         - Main

barrier    = <multiprocessing.synchronize.Barrier object at 0x7fac08254fa0>
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>
process    = <ForkProcess name='ForkProcess-15' pid=149 parent=8 stopped exitcode=0>
writer     = <tests.test_multiprocessing.Writer object at 0x7fac08255600>

tests/test_multiprocessing.py:349: AssertionError
</pre>
</details>
<h3 id="test_multiprocessingpytest_remove_in_main_process_inheritance">test_multiprocessing.py::test_remove_in_main_process_inheritance</h3>
<details><summary> <pre>test_multiprocessing.py::test_remove_in_main_process_inheritance</pre></summary><pre>
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>

    @pytest.mark.skipif(os.name == "nt", reason="Windows does not support forking")
    def test_remove_in_main_process_inheritance(fork_context):
        writer = Writer()
        barrier = fork_context.Barrier(2)

        logger.add(writer, context=fork_context, format="{message}", enqueue=True, catch=False)

        process = fork_context.Process(target=subworker_barrier_inheritance, args=(barrier,))
        process.start()
        barrier.wait()
        logger.info("Main")
        logger.remove()
        process.join()

        assert process.exitcode == 0

>       assert writer.read() == "Child\nMain\n"
E       AssertionError: assert '' == 'Child\nMain\n'
E         
E         - Child
E         - Main

barrier    = <multiprocessing.synchronize.Barrier object at 0x7fac087ee590>
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>
process    = <ForkProcess name='ForkProcess-16' pid=150 parent=8 stopped exitcode=0>
writer     = <tests.test_multiprocessing.Writer object at 0x7fac087ecdc0>

tests/test_multiprocessing.py:368: AssertionError
</pre>
</details>
<h3 id="test_multiprocessingpytest_await_complete_spawn">test_multiprocessing.py::test_await_complete_spawn</h3>
<details><summary> <pre>test_multiprocessing.py::test_await_complete_spawn</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac081df610>
spawn_context = <multiprocessing.context.SpawnContext object at 0x7fac0d34afb0>

    def test_await_complete_spawn(capsys, spawn_context):
        async def writer(msg):
            print(msg, end="")

        loop = asyncio.new_event_loop()

        logger.add(
            writer, context=spawn_context, format="{message}", loop=loop, enqueue=True, catch=False
        )

        process = spawn_context.Process(target=subworker_complete, args=(logger,))
        process.start()
        process.join()

>       assert process.exitcode == 0
E       AssertionError: assert 1 == 0
E        +  where 1 = <SpawnProcess name='SpawnProcess-17' pid=151 parent=8 stopped exitcode=1>.exitcode

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac081df610>
loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>
process    = <SpawnProcess name='SpawnProcess-17' pid=151 parent=8 stopped exitcode=1>
spawn_context = <multiprocessing.context.SpawnContext object at 0x7fac0d34afb0>
writer     = <function test_await_complete_spawn.<locals>.writer at 0x7fac07debc70>

tests/test_multiprocessing.py:385: AssertionError
</pre>
</details>
<h3 id="test_multiprocessingpytest_await_complete_fork">test_multiprocessing.py::test_await_complete_fork</h3>
<details><summary> <pre>test_multiprocessing.py::test_await_complete_fork</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac083c5ba0>
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>

    @pytest.mark.skipif(os.name == "nt", reason="Windows does not support forking")
    def test_await_complete_fork(capsys, fork_context):
        async def writer(msg):
            print(msg, end="")

        loop = asyncio.new_event_loop()

        logger.add(
            writer, context=fork_context, format="{message}", loop=loop, enqueue=True, catch=False
        )

        process = fork_context.Process(target=subworker_complete, args=(logger,))
        process.start()
        process.join()

>       assert process.exitcode == 0
E       AssertionError: assert 1 == 0
E        +  where 1 = <ForkProcess name='ForkProcess-18' pid=152 parent=8 stopped exitcode=1>.exitcode

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac083c5ba0>
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>
loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>
process    = <ForkProcess name='ForkProcess-18' pid=152 parent=8 stopped exitcode=1>
writer     = <function test_await_complete_fork.<locals>.writer at 0x7fac07deb6d0>

tests/test_multiprocessing.py:412: AssertionError
</pre>
</details>
<h3 id="test_multiprocessingpytest_await_complete_inheritance">test_multiprocessing.py::test_await_complete_inheritance</h3>
<details><summary> <pre>test_multiprocessing.py::test_await_complete_inheritance</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac081dff40>
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>

    @pytest.mark.skipif(os.name == "nt", reason="Windows does not support forking")
    def test_await_complete_inheritance(capsys, fork_context):
        async def writer(msg):
            print(msg, end="")

        loop = asyncio.new_event_loop()

        logger.add(
            writer, context=fork_context, format="{message}", loop=loop, enqueue=True, catch=False
        )

        process = fork_context.Process(target=subworker_complete_inheritance)
        process.start()
        process.join()

>       assert process.exitcode == 0
E       AssertionError: assert 1 == 0
E        +  where 1 = <ForkProcess name='ForkProcess-19' pid=153 parent=8 stopped exitcode=1>.exitcode

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac081dff40>
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>
loop       = <_UnixSelectorEventLoop running=False closed=False debug=False>
process    = <ForkProcess name='ForkProcess-19' pid=153 parent=8 stopped exitcode=1>
writer     = <function test_await_complete_inheritance.<locals>.writer at 0x7fac07de8f70>

tests/test_multiprocessing.py:439: AssertionError
</pre>
</details>
<h3 id="test_multiprocessingpytest_not_picklable_sinks_spawn">test_multiprocessing.py::test_not_picklable_sinks_spawn</h3>
<details><summary> <pre>test_multiprocessing.py::test_not_picklable_sinks_spawn</pre></summary><pre>
spawn_context = <multiprocessing.context.SpawnContext object at 0x7fac0d34afb0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_not_picklable_sinks_spawn0')
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0823a980>

    def test_not_picklable_sinks_spawn(spawn_context, tmp_path, capsys):
        filepath = tmp_path / "test.log"
        stream = sys.stderr
        output = []

        logger.add(filepath, context=spawn_context, format="{message}", enqueue=True, catch=False)
        logger.add(stream, context=spawn_context, format="{message}", enqueue=True)
        logger.add(lambda m: output.append(m), context=spawn_context, format="{message}", enqueue=True)

        process = spawn_context.Process(target=subworker, args=[logger])
        process.start()
        process.join()

        assert process.exitcode == 0

        logger.info("Main")
        logger.remove()

        out, err = capsys.readouterr()

>       assert filepath.read_text() == "Child\nMain\n"

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0823a980>
err        = ''
filepath   = PosixPath('/tmp/pytest-of-root/pytest-0/test_not_picklable_sinks_spawn0/test.log')
out        = ''
output     = []
process    = <SpawnProcess name='SpawnProcess-20' pid=154 parent=8 stopped exitcode=0>
spawn_context = <multiprocessing.context.SpawnContext object at 0x7fac0d34afb0>
stream     = <_io.TextIOWrapper encoding='UTF-8'>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_not_picklable_sinks_spawn0')

tests/test_multiprocessing.py:471: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_not_picklable_sinks_spawn0/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_not_picklable_sinks_spawn0/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_not_picklable_sinks_spawn0/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_not_picklable_sinks_spawn0/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_multiprocessingpytest_not_picklable_sinks_fork">test_multiprocessing.py::test_not_picklable_sinks_fork</h3>
<details><summary> <pre>test_multiprocessing.py::test_not_picklable_sinks_fork</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0810bfa0>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_not_picklable_sinks_fork0')
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>

    @pytest.mark.skipif(os.name == "nt", reason="Windows does not support forking")
    def test_not_picklable_sinks_fork(capsys, tmp_path, fork_context):
        filepath = tmp_path / "test.log"
        stream = sys.stderr
        output = []

        logger.add(filepath, context=fork_context, format="{message}", enqueue=True, catch=False)
        logger.add(stream, context=fork_context, format="{message}", enqueue=True, catch=False)
        logger.add(
            lambda m: output.append(m),
            context=fork_context,
            format="{message}",
            enqueue=True,
            catch=False,
        )

        process = fork_context.Process(target=subworker, args=[logger])
        process.start()
        process.join()

        assert process.exitcode == 0

        logger.info("Main")
        logger.remove()

        out, err = capsys.readouterr()

>       assert filepath.read_text() == "Child\nMain\n"

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0810bfa0>
err        = ''
filepath   = PosixPath('/tmp/pytest-of-root/pytest-0/test_not_picklable_sinks_fork0/test.log')
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>
out        = ''
output     = []
process    = <ForkProcess name='ForkProcess-21' pid=155 parent=8 stopped exitcode=0>
stream     = <_io.TextIOWrapper encoding='UTF-8'>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_not_picklable_sinks_fork0')

tests/test_multiprocessing.py:504: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_not_picklable_sinks_fork0/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_not_picklable_sinks_fork0/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_not_picklable_sinks_fork0/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_not_picklable_sinks_fork0/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_multiprocessingpytest_not_picklable_sinks_inheritance">test_multiprocessing.py::test_not_picklable_sinks_inheritance</h3>
<details><summary> <pre>test_multiprocessing.py::test_not_picklable_sinks_inheritance</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0830b130>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_not_picklable_sinks_inher0')
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>

    @pytest.mark.skipif(os.name == "nt", reason="Windows does not support forking")
    def test_not_picklable_sinks_inheritance(capsys, tmp_path, fork_context):
        filepath = tmp_path / "test.log"
        stream = sys.stderr
        output = []

        logger.add(filepath, context=fork_context, format="{message}", enqueue=True, catch=False)
        logger.add(stream, context=fork_context, format="{message}", enqueue=True, catch=False)
        logger.add(
            lambda m: output.append(m),
            context=fork_context,
            format="{message}",
            enqueue=True,
            catch=False,
        )

        process = fork_context.Process(target=subworker_inheritance)
        process.start()
        process.join()

        assert process.exitcode == 0

        logger.info("Main")
        logger.remove()

        out, err = capsys.readouterr()

>       assert filepath.read_text() == "Child\nMain\n"

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0830b130>
err        = ''
filepath   = PosixPath('/tmp/pytest-of-root/pytest-0/test_not_picklable_sinks_inher0/test.log')
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>
out        = ''
output     = []
process    = <ForkProcess name='ForkProcess-22' pid=156 parent=8 stopped exitcode=0>
stream     = <_io.TextIOWrapper encoding='UTF-8'>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_not_picklable_sinks_inher0')

tests/test_multiprocessing.py:537: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_not_picklable_sinks_inher0/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_not_picklable_sinks_inher0/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_not_picklable_sinks_inher0/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_not_picklable_sinks_inher0/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_multiprocessingpytest_no_deadlock_if_internal_lock_in_usetrue-true">test_multiprocessing.py::test_no_deadlock_if_internal_lock_in_use[True-True]</h3>
<details><summary> <pre>test_multiprocessing.py::test_no_deadlock_if_internal_lock_in_use[True-True]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_deadlock_if_internal_l0')
enqueue = True, deepcopied = True
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>

    @pytest.mark.skipif(os.name == "nt", reason="Windows does not support forking")
    @pytest.mark.skipif(sys.version_info < (3, 7), reason="No 'os.register_at_fork()' function")
    @pytest.mark.parametrize("enqueue", [True, False])
    @pytest.mark.parametrize("deepcopied", [True, False])
    def test_no_deadlock_if_internal_lock_in_use(tmp_path, enqueue, deepcopied, fork_context):
        if deepcopied:
            logger_ = copy.deepcopy(logger)
        else:
            logger_ = logger

        output = tmp_path / "stdout.txt"
        stdout = output.open("w")

        def slow_sink(msg):
            time.sleep(0.5)
            stdout.write(msg)
            stdout.flush()

        def main():
            logger_.info("Main")

        def worker():
            logger_.info("Child")

        logger_.add(slow_sink, context=fork_context, format="{message}", enqueue=enqueue, catch=False)

        thread = threading.Thread(target=main)
        thread.start()

        process = fork_context.Process(target=worker)
        process.start()

        thread.join()
        process.join(2)

        assert process.exitcode == 0

        logger_.remove()

>       assert output.read_text() in ("Main\nChild\n", "Child\nMain\n")
E       AssertionError: assert '' in ('Main\nChild\n', 'Child\nMain\n')
E        +  where '' = read_text()
E        +    where read_text = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_deadlock_if_internal_l0/stdout.txt').read_text

deepcopied = True
enqueue    = True
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>
logger_    = <loguru.logger handlers=[]>
main       = <function test_no_deadlock_if_internal_lock_in_use.<locals>.main at 0x7fac07dfec20>
output     = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_deadlock_if_internal_l0/stdout.txt')
process    = <ForkProcess name='ForkProcess-23' pid=158 parent=8 stopped exitcode=0>
slow_sink  = <function test_no_deadlock_if_internal_lock_in_use.<locals>.slow_sink at 0x7fac07df5ab0>
stdout     = <_io.TextIOWrapper name='/tmp/pytest-of-root/pytest-0/test_no_deadlock_if_internal_l0/stdout.txt' mode='w' encoding='UTF-8'>
thread     = <Thread(Thread-45 (main), stopped 140376274875968)>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_deadlock_if_internal_l0')
worker     = <function test_no_deadlock_if_internal_lock_in_use.<locals>.worker at 0x7fac07de8e50>

tests/test_multiprocessing.py:582: AssertionError
</pre>
</details>
<h3 id="test_multiprocessingpytest_no_deadlock_if_internal_lock_in_usetrue-false">test_multiprocessing.py::test_no_deadlock_if_internal_lock_in_use[True-False]</h3>
<details><summary> <pre>test_multiprocessing.py::test_no_deadlock_if_internal_lock_in_use[True-False]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_deadlock_if_internal_l1')
enqueue = False, deepcopied = True
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>

    @pytest.mark.skipif(os.name == "nt", reason="Windows does not support forking")
    @pytest.mark.skipif(sys.version_info < (3, 7), reason="No 'os.register_at_fork()' function")
    @pytest.mark.parametrize("enqueue", [True, False])
    @pytest.mark.parametrize("deepcopied", [True, False])
    def test_no_deadlock_if_internal_lock_in_use(tmp_path, enqueue, deepcopied, fork_context):
        if deepcopied:
            logger_ = copy.deepcopy(logger)
        else:
            logger_ = logger

        output = tmp_path / "stdout.txt"
        stdout = output.open("w")

        def slow_sink(msg):
            time.sleep(0.5)
            stdout.write(msg)
            stdout.flush()

        def main():
            logger_.info("Main")

        def worker():
            logger_.info("Child")

        logger_.add(slow_sink, context=fork_context, format="{message}", enqueue=enqueue, catch=False)

        thread = threading.Thread(target=main)
        thread.start()

        process = fork_context.Process(target=worker)
        process.start()

        thread.join()
        process.join(2)

        assert process.exitcode == 0

        logger_.remove()

>       assert output.read_text() in ("Main\nChild\n", "Child\nMain\n")
E       AssertionError: assert '' in ('Main\nChild\n', 'Child\nMain\n')
E        +  where '' = read_text()
E        +    where read_text = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_deadlock_if_internal_l1/stdout.txt').read_text

deepcopied = True
enqueue    = False
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>
logger_    = <loguru.logger handlers=[]>
main       = <function test_no_deadlock_if_internal_lock_in_use.<locals>.main at 0x7fac07debd00>
output     = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_deadlock_if_internal_l1/stdout.txt')
process    = <ForkProcess name='ForkProcess-24' pid=160 parent=8 stopped exitcode=0>
slow_sink  = <function test_no_deadlock_if_internal_lock_in_use.<locals>.slow_sink at 0x7fac07deadd0>
stdout     = <_io.TextIOWrapper name='/tmp/pytest-of-root/pytest-0/test_no_deadlock_if_internal_l1/stdout.txt' mode='w' encoding='UTF-8'>
thread     = <Thread(Thread-46 (main), stopped 140376274875968)>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_deadlock_if_internal_l1')
worker     = <function test_no_deadlock_if_internal_lock_in_use.<locals>.worker at 0x7fac07de9e10>

tests/test_multiprocessing.py:582: AssertionError
</pre>
</details>
<h3 id="test_multiprocessingpytest_no_deadlock_if_internal_lock_in_usefalse-true">test_multiprocessing.py::test_no_deadlock_if_internal_lock_in_use[False-True]</h3>
<details><summary> <pre>test_multiprocessing.py::test_no_deadlock_if_internal_lock_in_use[False-True]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_deadlock_if_internal_l2')
enqueue = True, deepcopied = False
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>

    @pytest.mark.skipif(os.name == "nt", reason="Windows does not support forking")
    @pytest.mark.skipif(sys.version_info < (3, 7), reason="No 'os.register_at_fork()' function")
    @pytest.mark.parametrize("enqueue", [True, False])
    @pytest.mark.parametrize("deepcopied", [True, False])
    def test_no_deadlock_if_internal_lock_in_use(tmp_path, enqueue, deepcopied, fork_context):
        if deepcopied:
            logger_ = copy.deepcopy(logger)
        else:
            logger_ = logger

        output = tmp_path / "stdout.txt"
        stdout = output.open("w")

        def slow_sink(msg):
            time.sleep(0.5)
            stdout.write(msg)
            stdout.flush()

        def main():
            logger_.info("Main")

        def worker():
            logger_.info("Child")

        logger_.add(slow_sink, context=fork_context, format="{message}", enqueue=enqueue, catch=False)

        thread = threading.Thread(target=main)
        thread.start()

        process = fork_context.Process(target=worker)
        process.start()

        thread.join()
        process.join(2)

        assert process.exitcode == 0

        logger_.remove()

>       assert output.read_text() in ("Main\nChild\n", "Child\nMain\n")
E       AssertionError: assert '' in ('Main\nChild\n', 'Child\nMain\n')
E        +  where '' = read_text()
E        +    where read_text = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_deadlock_if_internal_l2/stdout.txt').read_text

deepcopied = False
enqueue    = True
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>
logger_    = <loguru.logger handlers=[]>
main       = <function test_no_deadlock_if_internal_lock_in_use.<locals>.main at 0x7fac07cb8160>
output     = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_deadlock_if_internal_l2/stdout.txt')
process    = <ForkProcess name='ForkProcess-25' pid=162 parent=8 stopped exitcode=0>
slow_sink  = <function test_no_deadlock_if_internal_lock_in_use.<locals>.slow_sink at 0x7fac07debf40>
stdout     = <_io.TextIOWrapper name='/tmp/pytest-of-root/pytest-0/test_no_deadlock_if_internal_l2/stdout.txt' mode='w' encoding='UTF-8'>
thread     = <Thread(Thread-47 (main), stopped 140376274875968)>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_deadlock_if_internal_l2')
worker     = <function test_no_deadlock_if_internal_lock_in_use.<locals>.worker at 0x7fac07cb81f0>

tests/test_multiprocessing.py:582: AssertionError
</pre>
</details>
<h3 id="test_multiprocessingpytest_no_deadlock_if_internal_lock_in_usefalse-false">test_multiprocessing.py::test_no_deadlock_if_internal_lock_in_use[False-False]</h3>
<details><summary> <pre>test_multiprocessing.py::test_no_deadlock_if_internal_lock_in_use[False-False]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_deadlock_if_internal_l3')
enqueue = False, deepcopied = False
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>

    @pytest.mark.skipif(os.name == "nt", reason="Windows does not support forking")
    @pytest.mark.skipif(sys.version_info < (3, 7), reason="No 'os.register_at_fork()' function")
    @pytest.mark.parametrize("enqueue", [True, False])
    @pytest.mark.parametrize("deepcopied", [True, False])
    def test_no_deadlock_if_internal_lock_in_use(tmp_path, enqueue, deepcopied, fork_context):
        if deepcopied:
            logger_ = copy.deepcopy(logger)
        else:
            logger_ = logger

        output = tmp_path / "stdout.txt"
        stdout = output.open("w")

        def slow_sink(msg):
            time.sleep(0.5)
            stdout.write(msg)
            stdout.flush()

        def main():
            logger_.info("Main")

        def worker():
            logger_.info("Child")

        logger_.add(slow_sink, context=fork_context, format="{message}", enqueue=enqueue, catch=False)

        thread = threading.Thread(target=main)
        thread.start()

        process = fork_context.Process(target=worker)
        process.start()

        thread.join()
        process.join(2)

        assert process.exitcode == 0

        logger_.remove()

>       assert output.read_text() in ("Main\nChild\n", "Child\nMain\n")
E       AssertionError: assert '' in ('Main\nChild\n', 'Child\nMain\n')
E        +  where '' = read_text()
E        +    where read_text = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_deadlock_if_internal_l3/stdout.txt').read_text

deepcopied = False
enqueue    = False
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>
logger_    = <loguru.logger handlers=[]>
main       = <function test_no_deadlock_if_internal_lock_in_use.<locals>.main at 0x7fac07de9e10>
output     = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_deadlock_if_internal_l3/stdout.txt')
process    = <ForkProcess name='ForkProcess-26' pid=164 parent=8 stopped exitcode=0>
slow_sink  = <function test_no_deadlock_if_internal_lock_in_use.<locals>.slow_sink at 0x7fac07de9f30>
stdout     = <_io.TextIOWrapper name='/tmp/pytest-of-root/pytest-0/test_no_deadlock_if_internal_l3/stdout.txt' mode='w' encoding='UTF-8'>
thread     = <Thread(Thread-48 (main), stopped 140376274875968)>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_no_deadlock_if_internal_l3')
worker     = <function test_no_deadlock_if_internal_lock_in_use.<locals>.worker at 0x7fac07debd00>

tests/test_multiprocessing.py:582: AssertionError
</pre>
</details>
<h3 id="test_multiprocessingpytest_no_deadlock_if_external_lock_in_usetrue">test_multiprocessing.py::test_no_deadlock_if_external_lock_in_use[True]</h3>
<details><summary> <pre>test_multiprocessing.py::test_no_deadlock_if_external_lock_in_use[True]</pre></summary><pre>
enqueue = True
capsys = <_pytest.capture.CaptureFixture object at 0x7fac08395e40>
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>

    @pytest.mark.skipif(sys.version_info < (3, 7), reason="No 'os.register_at_fork()' function")
    @pytest.mark.skipif(os.name == "nt", reason="Windows does not support forking")
    @pytest.mark.parametrize("enqueue", [True, False])
    def test_no_deadlock_if_external_lock_in_use(enqueue, capsys, fork_context):
        # Can't reproduce the bug on pytest (even if stderr is not wrapped), but let it anyway
        logger.add(sys.stderr, context=fork_context, enqueue=enqueue, catch=True, format="{message}")
        num = 100

        for i in range(num):
            logger.info("This is a message: {}", i)
            process = fork_context.Process(target=lambda: None)
            process.start()
            process.join(1)
            assert process.exitcode == 0

        logger.remove()

        out, err = capsys.readouterr()
        assert out == ""
>       assert err == "".join("This is a message: %d\n" % i for i in range(num))
E       AssertionError: assert '' == 'This is a me...message: 99\n'
E         
E         - This is a message: 0
E         - This is a message: 1
E         - This is a message: 2
E         - This is a message: 3
E         - This is a message: 4
E         - This is a message: 5...
E         
E         ...Full output truncated (94 lines hidden), use '-vv' to show

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac08395e40>
enqueue    = True
err        = ''
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>
i          = 99
num        = 100
out        = ''
process    = <ForkProcess name='ForkProcess-126' pid=264 parent=8 stopped exitcode=0>

tests/test_multiprocessing.py:604: AssertionError
</pre>
</details>
<h3 id="test_multiprocessingpytest_no_deadlock_if_external_lock_in_usefalse">test_multiprocessing.py::test_no_deadlock_if_external_lock_in_use[False]</h3>
<details><summary> <pre>test_multiprocessing.py::test_no_deadlock_if_external_lock_in_use[False]</pre></summary><pre>
enqueue = False
capsys = <_pytest.capture.CaptureFixture object at 0x7fac082e48e0>
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>

    @pytest.mark.skipif(sys.version_info < (3, 7), reason="No 'os.register_at_fork()' function")
    @pytest.mark.skipif(os.name == "nt", reason="Windows does not support forking")
    @pytest.mark.parametrize("enqueue", [True, False])
    def test_no_deadlock_if_external_lock_in_use(enqueue, capsys, fork_context):
        # Can't reproduce the bug on pytest (even if stderr is not wrapped), but let it anyway
        logger.add(sys.stderr, context=fork_context, enqueue=enqueue, catch=True, format="{message}")
        num = 100

        for i in range(num):
            logger.info("This is a message: {}", i)
            process = fork_context.Process(target=lambda: None)
            process.start()
            process.join(1)
            assert process.exitcode == 0

        logger.remove()

        out, err = capsys.readouterr()
        assert out == ""
>       assert err == "".join("This is a message: %d\n" % i for i in range(num))
E       AssertionError: assert '' == 'This is a me...message: 99\n'
E         
E         - This is a message: 0
E         - This is a message: 1
E         - This is a message: 2
E         - This is a message: 3
E         - This is a message: 4
E         - This is a message: 5...
E         
E         ...Full output truncated (94 lines hidden), use '-vv' to show

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac082e48e0>
enqueue    = False
err        = ''
fork_context = <multiprocessing.context.ForkContext object at 0x7fac0d3490f0>
i          = 99
num        = 100
out        = ''
process    = <ForkProcess name='ForkProcess-226' pid=364 parent=8 stopped exitcode=0>

tests/test_multiprocessing.py:604: AssertionError
</pre>
</details>
<h3 id="test_optpytest_record">test_opt.py::test_record</h3>
<details><summary> <pre>test_opt.py::test_record</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07de9a20>

    def test_record(writer):
        logger.add(writer, format="{message}")

>       logger.opt(record=True).debug("1")
E       AttributeError: 'NoneType' object has no attribute 'debug'

writer     = <function writer.<locals>.w at 0x7fac07de9a20>

tests/test_opt.py:14: AttributeError
</pre>
</details>
<h3 id="test_optpytest_record_in_kwargs_too">test_opt.py::test_record_in_kwargs_too</h3>
<details><summary> <pre>test_opt.py::test_record_in_kwargs_too</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07dfd3f0>

    def test_record_in_kwargs_too(writer):
        logger.add(writer, catch=False)

        with pytest.raises(TypeError, match=r"The message can't be formatted"):
>           logger.opt(record=True).info("Foo {record}", record=123)
E           AttributeError: 'NoneType' object has no attribute 'info'

writer     = <function writer.<locals>.w at 0x7fac07dfd3f0>

tests/test_opt.py:25: AttributeError
</pre>
</details>
<h3 id="test_optpytest_record_not_in_extra">test_opt.py::test_record_not_in_extra</h3>
<details><summary> <pre>test_opt.py::test_record_not_in_extra</pre></summary><pre>
def test_record_not_in_extra():
        extra = None

        def sink(message):
            nonlocal extra
            extra = message.record["extra"]

        logger.add(sink, catch=False)

>       logger.opt(record=True).info("Test")
E       AttributeError: 'NoneType' object has no attribute 'info'

extra      = None
sink       = <function test_record_not_in_extra.<locals>.sink at 0x7fac07de9f30>

tests/test_opt.py:37: AttributeError
</pre>
</details>
<h3 id="test_optpytest_kwargs_in_extra_of_record">test_opt.py::test_kwargs_in_extra_of_record</h3>
<details><summary> <pre>test_opt.py::test_kwargs_in_extra_of_record</pre></summary><pre>
def test_kwargs_in_extra_of_record():
        message = None

        def sink(message_):
            nonlocal message
            message = message_

        logger.add(sink, format="{message}", catch=False)

>       logger.opt(record=True).info("Test {record[extra][foo]}", foo=123)
E       AttributeError: 'NoneType' object has no attribute 'info'

message    = None
sink       = <function test_kwargs_in_extra_of_record.<locals>.sink at 0x7fac07cb9240>

tests/test_opt.py:51: AttributeError
</pre>
</details>
<h3 id="test_optpytest_exception_boolean">test_opt.py::test_exception_boolean</h3>
<details><summary> <pre>test_opt.py::test_exception_boolean</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cb9510>

    def test_exception_boolean(writer):
        logger.add(writer, format="{level.name}: {message}")

        try:
>           1 / 0  # noqa: B018
E           ZeroDivisionError: division by zero

writer     = <function writer.<locals>.w at 0x7fac07cb9510>

tests/test_opt.py:61: ZeroDivisionError

During handling of the above exception, another exception occurred:

writer = <function writer.<locals>.w at 0x7fac07cb9510>

    def test_exception_boolean(writer):
        logger.add(writer, format="{level.name}: {message}")

        try:
            1 / 0  # noqa: B018
        except Exception:
>           logger.opt(exception=True).debug("Error {0} {record}", 1, record="test")
E           AttributeError: 'NoneType' object has no attribute 'debug'

writer     = <function writer.<locals>.w at 0x7fac07cb9510>

tests/test_opt.py:63: AttributeError
</pre>
</details>
<h3 id="test_optpytest_exception_exc_info">test_opt.py::test_exception_exc_info</h3>
<details><summary> <pre>test_opt.py::test_exception_exc_info</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cb91b0>

    def test_exception_exc_info(writer):
        logger.add(writer, format="{message}")

        try:
            1 / 0  # noqa: B018
        except Exception:
            exc_info = sys.exc_info()

>       logger.opt(exception=exc_info).debug("test")
E       AttributeError: 'NoneType' object has no attribute 'debug'

exc_info   = (<class 'ZeroDivisionError'>, ZeroDivisionError('division by zero'), <traceback object at 0x7fac07d42980>)
writer     = <function writer.<locals>.w at 0x7fac07cb91b0>

tests/test_opt.py:79: AttributeError
</pre>
</details>
<h3 id="test_optpytest_exception_class">test_opt.py::test_exception_class</h3>
<details><summary> <pre>test_opt.py::test_exception_class</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cb9120>

    def test_exception_class(writer):
        logger.add(writer, format="{message}")

        try:
            1 / 0  # noqa: B018
        except Exception:
            _, exc_class, _ = sys.exc_info()

>       logger.opt(exception=exc_class).debug("test")
E       AttributeError: 'NoneType' object has no attribute 'debug'

_          = <traceback object at 0x7fac083d23c0>
exc_class  = ZeroDivisionError('division by zero')
writer     = <function writer.<locals>.w at 0x7fac07cb9120>

tests/test_opt.py:95: AttributeError
</pre>
</details>
<h3 id="test_optpytest_exception_log_funcion">test_opt.py::test_exception_log_funcion</h3>
<details><summary> <pre>test_opt.py::test_exception_log_funcion</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cb9ab0>

    def test_exception_log_funcion(writer):
        logger.add(writer, format="{level.no} {message}")

        try:
>           1 / 0  # noqa: B018
E           ZeroDivisionError: division by zero

writer     = <function writer.<locals>.w at 0x7fac07cb9ab0>

tests/test_opt.py:107: ZeroDivisionError

During handling of the above exception, another exception occurred:

writer = <function writer.<locals>.w at 0x7fac07cb9ab0>

    def test_exception_log_funcion(writer):
        logger.add(writer, format="{level.no} {message}")

        try:
            1 / 0  # noqa: B018
        except Exception:
>           logger.opt(exception=True).log(50, "Error")
E           AttributeError: 'NoneType' object has no attribute 'log'

writer     = <function writer.<locals>.w at 0x7fac07cb9ab0>

tests/test_opt.py:109: AttributeError
</pre>
</details>
<h3 id="test_optpytest_lazy">test_opt.py::test_lazy</h3>
<details><summary> <pre>test_opt.py::test_lazy</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cb9f30>

    def test_lazy(writer):
        counter = 0

        def laziness():
            nonlocal counter
            counter += 1
            return counter

        logger.add(writer, level=10, format="{level.no} => {message}")

>       logger.opt(lazy=True).log(10, "1: {lazy}", lazy=laziness)
E       AttributeError: 'NoneType' object has no attribute 'log'

counter    = 0
laziness   = <function test_lazy.<locals>.laziness at 0x7fac07cb8160>
writer     = <function writer.<locals>.w at 0x7fac07cb9f30>

tests/test_opt.py:127: AttributeError
</pre>
</details>
<h3 id="test_optpytest_logging_within_lazy_function">test_opt.py::test_logging_within_lazy_function</h3>
<details><summary> <pre>test_opt.py::test_logging_within_lazy_function</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cba170>

    def test_logging_within_lazy_function(writer):
        logger.add(writer, level=20, format="{message}")

        def laziness():
            logger.trace("Nope")
            logger.warning("Yes Warn")

>       logger.opt(lazy=True).trace("No", laziness)
E       AttributeError: 'NoneType' object has no attribute 'trace'

laziness   = <function test_logging_within_lazy_function.<locals>.laziness at 0x7fac07cba710>
writer     = <function writer.<locals>.w at 0x7fac07cba170>

tests/test_opt.py:157: AttributeError
</pre>
</details>
<h3 id="test_optpytest_depth">test_opt.py::test_depth</h3>
<details><summary> <pre>test_opt.py::test_depth</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cba3b0>

    def test_depth(writer):
        logger.add(writer, format="{function} : {message}")

        def a():
            logger.opt(depth=1).debug("Test 1")
            logger.opt(depth=0).debug("Test 2")
            logger.opt(depth=1).log(10, "Test 3")

>       a()

a          = <function test_depth.<locals>.a at 0x7fac07cba9e0>
writer     = <function writer.<locals>.w at 0x7fac07cba3b0>

tests/test_opt.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def a():
>       logger.opt(depth=1).debug("Test 1")
E       AttributeError: 'NoneType' object has no attribute 'debug'


tests/test_opt.py:170: AttributeError
</pre>
</details>
<h3 id="test_optpytest_capture">test_opt.py::test_capture</h3>
<details><summary> <pre>test_opt.py::test_capture</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cba680>

    def test_capture(writer):
        logger.add(writer, format="{message} {extra}")
>       logger.opt(capture=False).info("No {}", 123, no=False)
E       AttributeError: 'NoneType' object has no attribute 'info'

writer     = <function writer.<locals>.w at 0x7fac07cba680>

tests/test_opt.py:183: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors">test_opt.py::test_colors</h3>
<details><summary> <pre>test_opt.py::test_colors</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cba950>

    def test_colors(writer):
        logger.add(writer, format="<red>a</red> {message}", colorize=True)
>       logger.opt(colors=True).debug("<blue>b</blue>")
E       AttributeError: 'NoneType' object has no attribute 'debug'

writer     = <function writer.<locals>.w at 0x7fac07cba950>

tests/test_opt.py:191: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_not_colorize">test_opt.py::test_colors_not_colorize</h3>
<details><summary> <pre>test_opt.py::test_colors_not_colorize</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbacb0>

    def test_colors_not_colorize(writer):
        logger.add(writer, format="<red>a</red> {message}", colorize=False)
>       logger.opt(colors=True).debug("<blue>b</blue>")
E       AttributeError: 'NoneType' object has no attribute 'debug'

writer     = <function writer.<locals>.w at 0x7fac07cbacb0>

tests/test_opt.py:201: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_doesnt_color_unrelated">test_opt.py::test_colors_doesnt_color_unrelated</h3>
<details><summary> <pre>test_opt.py::test_colors_doesnt_color_unrelated</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbb010>

    def test_colors_doesnt_color_unrelated(writer):
        logger.add(writer, format="{message} {extra[trap]}", colorize=True)
>       logger.bind(trap="<red>B</red>").opt(colors=True).debug("<red>A</red>")
E       AttributeError: 'NoneType' object has no attribute 'opt'

writer     = <function writer.<locals>.w at 0x7fac07cbb010>

tests/test_opt.py:207: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_doesnt_strip_unrelated">test_opt.py::test_colors_doesnt_strip_unrelated</h3>
<details><summary> <pre>test_opt.py::test_colors_doesnt_strip_unrelated</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbb130>

    def test_colors_doesnt_strip_unrelated(writer):
        logger.add(writer, format="{message} {extra[trap]}", colorize=False)
>       logger.bind(trap="<red>B</red>").opt(colors=True).debug("<red>A</red>")
E       AttributeError: 'NoneType' object has no attribute 'opt'

writer     = <function writer.<locals>.w at 0x7fac07cbb130>

tests/test_opt.py:213: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_doesnt_raise_unrelated_colorize">test_opt.py::test_colors_doesnt_raise_unrelated_colorize</h3>
<details><summary> <pre>test_opt.py::test_colors_doesnt_raise_unrelated_colorize</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbb370>

    def test_colors_doesnt_raise_unrelated_colorize(writer):
        logger.add(writer, format="{message} {extra[trap]}", colorize=True, catch=False)
>       logger.bind(trap="</red>").opt(colors=True).debug("A")
E       AttributeError: 'NoneType' object has no attribute 'opt'

writer     = <function writer.<locals>.w at 0x7fac07cbb370>

tests/test_opt.py:219: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_doesnt_raise_unrelated_not_colorize">test_opt.py::test_colors_doesnt_raise_unrelated_not_colorize</h3>
<details><summary> <pre>test_opt.py::test_colors_doesnt_raise_unrelated_not_colorize</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbb5b0>

    def test_colors_doesnt_raise_unrelated_not_colorize(writer):
        logger.add(writer, format="{message} {extra[trap]}", colorize=False, catch=False)
>       logger.bind(trap="</red>").opt(colors=True).debug("A")
E       AttributeError: 'NoneType' object has no attribute 'opt'

writer     = <function writer.<locals>.w at 0x7fac07cbb5b0>

tests/test_opt.py:225: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_doesnt_raise_unrelated_colorize_dynamic">test_opt.py::test_colors_doesnt_raise_unrelated_colorize_dynamic</h3>
<details><summary> <pre>test_opt.py::test_colors_doesnt_raise_unrelated_colorize_dynamic</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbb760>

    def test_colors_doesnt_raise_unrelated_colorize_dynamic(writer):
        logger.add(writer, format=lambda x: "{message} {extra[trap]}", colorize=True, catch=False)
>       logger.bind(trap="</red>").opt(colors=True).debug("A")
E       AttributeError: 'NoneType' object has no attribute 'opt'

writer     = <function writer.<locals>.w at 0x7fac07cbb760>

tests/test_opt.py:231: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_doesnt_raise_unrelated_not_colorize_dynamic">test_opt.py::test_colors_doesnt_raise_unrelated_not_colorize_dynamic</h3>
<details><summary> <pre>test_opt.py::test_colors_doesnt_raise_unrelated_not_colorize_dynamic</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cb9ab0>

    def test_colors_doesnt_raise_unrelated_not_colorize_dynamic(writer):
        logger.add(writer, format=lambda x: "{message} {extra[trap]}", colorize=False, catch=False)
>       logger.bind(trap="</red>").opt(colors=True).debug("A")
E       AttributeError: 'NoneType' object has no attribute 'opt'

writer     = <function writer.<locals>.w at 0x7fac07cb9ab0>

tests/test_opt.py:237: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_within_recordtrue">test_opt.py::test_colors_within_record[True]</h3>
<details><summary> <pre>test_opt.py::test_colors_within_record[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbb9a0>, colorize = True

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_within_record(writer, colorize):
        logger.add(writer, format="{message}", colorize=colorize)
        logger_ = logger.bind(start="<red>", end="</red>")
>       logger_.opt(colors=True, record=True).debug("{record[extra][start]}B{record[extra][end]}")
E       AttributeError: 'NoneType' object has no attribute 'opt'

colorize   = True
logger_    = None
writer     = <function writer.<locals>.w at 0x7fac07cbb9a0>

tests/test_opt.py:245: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_within_recordfalse">test_opt.py::test_colors_within_record[False]</h3>
<details><summary> <pre>test_opt.py::test_colors_within_record[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbbc70>, colorize = False

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_within_record(writer, colorize):
        logger.add(writer, format="{message}", colorize=colorize)
        logger_ = logger.bind(start="<red>", end="</red>")
>       logger_.opt(colors=True, record=True).debug("{record[extra][start]}B{record[extra][end]}")
E       AttributeError: 'NoneType' object has no attribute 'opt'

colorize   = False
logger_    = None
writer     = <function writer.<locals>.w at 0x7fac07cbbc70>

tests/test_opt.py:245: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_nestedtrue">test_opt.py::test_colors_nested[True]</h3>
<details><summary> <pre>test_opt.py::test_colors_nested[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbae60>, colorize = True

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_nested(writer, colorize):
        logger.add(writer, format="(<red>[{message}]</red>)", colorize=colorize)
>       logger.opt(colors=True).debug("A<green>B</green>C<blue>D</blue>E")
E       AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = True
writer     = <function writer.<locals>.w at 0x7fac07cbae60>

tests/test_opt.py:252: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_nestedfalse">test_opt.py::test_colors_nested[False]</h3>
<details><summary> <pre>test_opt.py::test_colors_nested[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cba680>, colorize = False

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_nested(writer, colorize):
        logger.add(writer, format="(<red>[{message}]</red>)", colorize=colorize)
>       logger.opt(colors=True).debug("A<green>B</green>C<blue>D</blue>E")
E       AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = False
writer     = <function writer.<locals>.w at 0x7fac07cba680>

tests/test_opt.py:252: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_stripped_in_message_recordtrue">test_opt.py::test_colors_stripped_in_message_record[True]</h3>
<details><summary> <pre>test_opt.py::test_colors_stripped_in_message_record[True]</pre></summary><pre>
colorize = True

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_stripped_in_message_record(colorize):
        message = None

        def sink(msg):
            nonlocal message
            message = msg.record["message"]

        logger.add(sink, colorize=colorize)
>       logger.opt(colors=True).debug("<red>Test</red>")
E       AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = True
message    = None
sink       = <function test_colors_stripped_in_message_record.<locals>.sink at 0x7fac07cbbbe0>

tests/test_opt.py:267: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_stripped_in_message_recordfalse">test_opt.py::test_colors_stripped_in_message_record[False]</h3>
<details><summary> <pre>test_opt.py::test_colors_stripped_in_message_record[False]</pre></summary><pre>
colorize = False

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_stripped_in_message_record(colorize):
        message = None

        def sink(msg):
            nonlocal message
            message = msg.record["message"]

        logger.add(sink, colorize=colorize)
>       logger.opt(colors=True).debug("<red>Test</red>")
E       AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = False
message    = None
sink       = <function test_colors_stripped_in_message_record.<locals>.sink at 0x7fac07de9990>

tests/test_opt.py:267: AttributeError
</pre>
</details>
<h3 id="test_optpytest_invalid_markup_in_messagetrue-">test_opt.py::test_invalid_markup_in_message[True-<red>]</h3>
<details><summary> <pre>test_opt.py::test_invalid_markup_in_message[True-<red>]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbb1c0>, message = '<red>'
colorize = True

    @pytest.mark.parametrize("message", ["<red>", "</red>", "X </red> <red> Y"])
    @pytest.mark.parametrize("colorize", [True, False])
    def test_invalid_markup_in_message(writer, message, colorize):
        logger.add(writer, format="<red>{message}</red>", colorize=colorize, catch=False)
        with pytest.raises(ValueError):
>           logger.opt(colors=True).debug(message)
E           AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = True
message    = '<red>'
writer     = <function writer.<locals>.w at 0x7fac07cbb1c0>

tests/test_opt.py:276: AttributeError
</pre>
</details>
<h3 id="red_1">red&gt;]</h3>
<details><summary> <pre>red>]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cba4d0>, message = '</red>'
colorize = True

    @pytest.mark.parametrize("message", ["<red>", "</red>", "X </red> <red> Y"])
    @pytest.mark.parametrize("colorize", [True, False])
    def test_invalid_markup_in_message(writer, message, colorize):
        logger.add(writer, format="<red>{message}</red>", colorize=colorize, catch=False)
        with pytest.raises(ValueError):
>           logger.opt(colors=True).debug(message)
E           AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = True
message    = '</red>'
writer     = <function writer.<locals>.w at 0x7fac07cba4d0>

tests/test_opt.py:276: AttributeError
</pre>
</details>
<h3 id="red-y">red&gt; <red> Y]</h3>
<details><summary> <pre>red> <red> Y]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbb130>
message = 'X </red> <red> Y', colorize = True

    @pytest.mark.parametrize("message", ["<red>", "</red>", "X </red> <red> Y"])
    @pytest.mark.parametrize("colorize", [True, False])
    def test_invalid_markup_in_message(writer, message, colorize):
        logger.add(writer, format="<red>{message}</red>", colorize=colorize, catch=False)
        with pytest.raises(ValueError):
>           logger.opt(colors=True).debug(message)
E           AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = True
message    = 'X </red> <red> Y'
writer     = <function writer.<locals>.w at 0x7fac07cbb130>

tests/test_opt.py:276: AttributeError
</pre>
</details>
<h3 id="test_optpytest_invalid_markup_in_messagefalse-">test_opt.py::test_invalid_markup_in_message[False-<red>]</h3>
<details><summary> <pre>test_opt.py::test_invalid_markup_in_message[False-<red>]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cb9f30>, message = '<red>'
colorize = False

    @pytest.mark.parametrize("message", ["<red>", "</red>", "X </red> <red> Y"])
    @pytest.mark.parametrize("colorize", [True, False])
    def test_invalid_markup_in_message(writer, message, colorize):
        logger.add(writer, format="<red>{message}</red>", colorize=colorize, catch=False)
        with pytest.raises(ValueError):
>           logger.opt(colors=True).debug(message)
E           AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = False
message    = '<red>'
writer     = <function writer.<locals>.w at 0x7fac07cb9f30>

tests/test_opt.py:276: AttributeError
</pre>
</details>
<h3 id="red_2">red&gt;]</h3>
<details><summary> <pre>red>]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cba5f0>, message = '</red>'
colorize = False

    @pytest.mark.parametrize("message", ["<red>", "</red>", "X </red> <red> Y"])
    @pytest.mark.parametrize("colorize", [True, False])
    def test_invalid_markup_in_message(writer, message, colorize):
        logger.add(writer, format="<red>{message}</red>", colorize=colorize, catch=False)
        with pytest.raises(ValueError):
>           logger.opt(colors=True).debug(message)
E           AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = False
message    = '</red>'
writer     = <function writer.<locals>.w at 0x7fac07cba5f0>

tests/test_opt.py:276: AttributeError
</pre>
</details>
<h3 id="red-y_1">red&gt; <red> Y]</h3>
<details><summary> <pre>red> <red> Y]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cb81f0>
message = 'X </red> <red> Y', colorize = False

    @pytest.mark.parametrize("message", ["<red>", "</red>", "X </red> <red> Y"])
    @pytest.mark.parametrize("colorize", [True, False])
    def test_invalid_markup_in_message(writer, message, colorize):
        logger.add(writer, format="<red>{message}</red>", colorize=colorize, catch=False)
        with pytest.raises(ValueError):
>           logger.opt(colors=True).debug(message)
E           AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = False
message    = 'X </red> <red> Y'
writer     = <function writer.<locals>.w at 0x7fac07cb81f0>

tests/test_opt.py:276: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_with_argstrue">test_opt.py::test_colors_with_args[True]</h3>
<details><summary> <pre>test_opt.py::test_colors_with_args[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cba0e0>, colorize = True

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_with_args(writer, colorize):
        logger.add(writer, format="=> {message} <=", colorize=colorize)
>       logger.opt(colors=True).debug("the {0}test{end}", "<red>", end="</red>")
E       AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = True
writer     = <function writer.<locals>.w at 0x7fac07cba0e0>

tests/test_opt.py:282: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_with_argsfalse">test_opt.py::test_colors_with_args[False]</h3>
<details><summary> <pre>test_opt.py::test_colors_with_args[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cb9fc0>, colorize = False

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_with_args(writer, colorize):
        logger.add(writer, format="=> {message} <=", colorize=colorize)
>       logger.opt(colors=True).debug("the {0}test{end}", "<red>", end="</red>")
E       AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = False
writer     = <function writer.<locals>.w at 0x7fac07cb9fc0>

tests/test_opt.py:282: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_with_leveltrue">test_opt.py::test_colors_with_level[True]</h3>
<details><summary> <pre>test_opt.py::test_colors_with_level[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cb9990>, colorize = True

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_with_level(writer, colorize):
        logger.add(writer, format="{message}", colorize=colorize)
        logger.level("DEBUG", color="<green>")
>       logger.opt(colors=True).debug("a <level>level</level> b")
E       AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = True
writer     = <function writer.<locals>.w at 0x7fac07cb9990>

tests/test_opt.py:290: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_with_levelfalse">test_opt.py::test_colors_with_level[False]</h3>
<details><summary> <pre>test_opt.py::test_colors_with_level[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbbd90>, colorize = False

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_with_level(writer, colorize):
        logger.add(writer, format="{message}", colorize=colorize)
        logger.level("DEBUG", color="<green>")
>       logger.opt(colors=True).debug("a <level>level</level> b")
E       AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = False
writer     = <function writer.<locals>.w at 0x7fac07cbbd90>

tests/test_opt.py:290: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_double_messagetrue">test_opt.py::test_colors_double_message[True]</h3>
<details><summary> <pre>test_opt.py::test_colors_double_message[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbb0a0>, colorize = True

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_double_message(writer, colorize):
        logger.add(
            writer, format="<red><b>{message}...</b> - <c>...{message}</c></red>", colorize=colorize
        )
>       logger.opt(colors=True).debug("<g>foo</g> bar <g>baz</g>")
E       AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = True
writer     = <function writer.<locals>.w at 0x7fac07cbb0a0>

tests/test_opt.py:299: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_double_messagefalse">test_opt.py::test_colors_double_message[False]</h3>
<details><summary> <pre>test_opt.py::test_colors_double_message[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cba7a0>, colorize = False

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_double_message(writer, colorize):
        logger.add(
            writer, format="<red><b>{message}...</b> - <c>...{message}</c></red>", colorize=colorize
        )
>       logger.opt(colors=True).debug("<g>foo</g> bar <g>baz</g>")
E       AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = False
writer     = <function writer.<locals>.w at 0x7fac07cba7a0>

tests/test_opt.py:299: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_multiple_callstrue">test_opt.py::test_colors_multiple_calls[True]</h3>
<details><summary> <pre>test_opt.py::test_colors_multiple_calls[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbacb0>, colorize = True

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_multiple_calls(writer, colorize):
        logger.add(writer, format="{message}", colorize=colorize)
>       logger.opt(colors=True).debug("a <red>foo</red> b")
E       AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = True
writer     = <function writer.<locals>.w at 0x7fac07cbacb0>

tests/test_opt.py:310: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_multiple_callsfalse">test_opt.py::test_colors_multiple_calls[False]</h3>
<details><summary> <pre>test_opt.py::test_colors_multiple_calls[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cba170>, colorize = False

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_multiple_calls(writer, colorize):
        logger.add(writer, format="{message}", colorize=colorize)
>       logger.opt(colors=True).debug("a <red>foo</red> b")
E       AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = False
writer     = <function writer.<locals>.w at 0x7fac07cba170>

tests/test_opt.py:310: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_multiple_calls_level_color_changedtrue">test_opt.py::test_colors_multiple_calls_level_color_changed[True]</h3>
<details><summary> <pre>test_opt.py::test_colors_multiple_calls_level_color_changed[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbac20>, colorize = True

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_multiple_calls_level_color_changed(writer, colorize):
        logger.add(writer, format="{message}", colorize=colorize)
        logger.level("INFO", color="<blue>")
>       logger.opt(colors=True).info("a <level>foo</level> b")
E       AttributeError: 'NoneType' object has no attribute 'info'

colorize   = True
writer     = <function writer.<locals>.w at 0x7fac07cbac20>

tests/test_opt.py:319: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_multiple_calls_level_color_changedfalse">test_opt.py::test_colors_multiple_calls_level_color_changed[False]</h3>
<details><summary> <pre>test_opt.py::test_colors_multiple_calls_level_color_changed[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cba950>, colorize = False

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_multiple_calls_level_color_changed(writer, colorize):
        logger.add(writer, format="{message}", colorize=colorize)
        logger.level("INFO", color="<blue>")
>       logger.opt(colors=True).info("a <level>foo</level> b")
E       AttributeError: 'NoneType' object has no attribute 'info'

colorize   = False
writer     = <function writer.<locals>.w at 0x7fac07cba950>

tests/test_opt.py:319: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_with_dynamic_formattertrue">test_opt.py::test_colors_with_dynamic_formatter[True]</h3>
<details><summary> <pre>test_opt.py::test_colors_with_dynamic_formatter[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbbac0>, colorize = True

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_with_dynamic_formatter(writer, colorize):
        logger.add(writer, format=lambda r: "<red>{message}</red>", colorize=colorize)
>       logger.opt(colors=True).debug("<b>a</b> <y>b</y>")
E       AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = True
writer     = <function writer.<locals>.w at 0x7fac07cbbac0>

tests/test_opt.py:328: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_with_dynamic_formatterfalse">test_opt.py::test_colors_with_dynamic_formatter[False]</h3>
<details><summary> <pre>test_opt.py::test_colors_with_dynamic_formatter[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cba290>, colorize = False

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_with_dynamic_formatter(writer, colorize):
        logger.add(writer, format=lambda r: "<red>{message}</red>", colorize=colorize)
>       logger.opt(colors=True).debug("<b>a</b> <y>b</y>")
E       AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = False
writer     = <function writer.<locals>.w at 0x7fac07cba290>

tests/test_opt.py:328: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_with_format_specstrue">test_opt.py::test_colors_with_format_specs[True]</h3>
<details><summary> <pre>test_opt.py::test_colors_with_format_specs[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbb910>, colorize = True

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_with_format_specs(writer, colorize):
        fmt = "<g>{level.no:03d} {message:} {message!s:} {{nope}} {extra[a][b]!r}</g>"
        logger.add(writer, colorize=colorize, format=fmt)
>       logger.bind(a={"b": "c"}).opt(colors=True).debug("<g>{X}</g>")
E       AttributeError: 'NoneType' object has no attribute 'opt'

colorize   = True
fmt        = '<g>{level.no:03d} {message:} {message!s:} {{nope}} {extra[a][b]!r}</g>'
writer     = <function writer.<locals>.w at 0x7fac07cbb910>

tests/test_opt.py:336: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_with_format_specsfalse">test_opt.py::test_colors_with_format_specs[False]</h3>
<details><summary> <pre>test_opt.py::test_colors_with_format_specs[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cba0e0>, colorize = False

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_with_format_specs(writer, colorize):
        fmt = "<g>{level.no:03d} {message:} {message!s:} {{nope}} {extra[a][b]!r}</g>"
        logger.add(writer, colorize=colorize, format=fmt)
>       logger.bind(a={"b": "c"}).opt(colors=True).debug("<g>{X}</g>")
E       AttributeError: 'NoneType' object has no attribute 'opt'

colorize   = False
fmt        = '<g>{level.no:03d} {message:} {message!s:} {{nope}} {extra[a][b]!r}</g>'
writer     = <function writer.<locals>.w at 0x7fac07cba0e0>

tests/test_opt.py:336: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_with_message_specstrue">test_opt.py::test_colors_with_message_specs[True]</h3>
<details><summary> <pre>test_opt.py::test_colors_with_message_specs[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbb400>, colorize = True

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_with_message_specs(writer, colorize):
        logger.add(writer, colorize=colorize, format="<g>{message}</g>")
>       logger.opt(colors=True).debug("{} <b>A</b> {{nope}} {key:03d} {let!r}", 1, key=10, let="c")
E       AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = True
writer     = <function writer.<locals>.w at 0x7fac07cbb400>

tests/test_opt.py:343: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_with_message_specsfalse">test_opt.py::test_colors_with_message_specs[False]</h3>
<details><summary> <pre>test_opt.py::test_colors_with_message_specs[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbac20>, colorize = False

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_with_message_specs(writer, colorize):
        logger.add(writer, colorize=colorize, format="<g>{message}</g>")
>       logger.opt(colors=True).debug("{} <b>A</b> {{nope}} {key:03d} {let!r}", 1, key=10, let="c")
E       AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = False
writer     = <function writer.<locals>.w at 0x7fac07cbac20>

tests/test_opt.py:343: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colored_string_used_as_spectrue">test_opt.py::test_colored_string_used_as_spec[True]</h3>
<details><summary> <pre>test_opt.py::test_colored_string_used_as_spec[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbaa70>, colorize = True

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colored_string_used_as_spec(writer, colorize):
        logger.add(writer, colorize=colorize, format="{level.no:{message}} <red>{message}</red>")
>       logger.opt(colors=True).log(30, "03d")
E       AttributeError: 'NoneType' object has no attribute 'log'

colorize   = True
writer     = <function writer.<locals>.w at 0x7fac07cbaa70>

tests/test_opt.py:353: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colored_string_used_as_specfalse">test_opt.py::test_colored_string_used_as_spec[False]</h3>
<details><summary> <pre>test_opt.py::test_colored_string_used_as_spec[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbb0a0>, colorize = False

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colored_string_used_as_spec(writer, colorize):
        logger.add(writer, colorize=colorize, format="{level.no:{message}} <red>{message}</red>")
>       logger.opt(colors=True).log(30, "03d")
E       AttributeError: 'NoneType' object has no attribute 'log'

colorize   = False
writer     = <function writer.<locals>.w at 0x7fac07cbb0a0>

tests/test_opt.py:353: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colored_string_getitemtrue">test_opt.py::test_colored_string_getitem[True]</h3>
<details><summary> <pre>test_opt.py::test_colored_string_getitem[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cb9510>, colorize = True

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colored_string_getitem(writer, colorize):
        logger.add(writer, colorize=colorize, format="<red>{message[0]}</red>")
>       logger.opt(colors=True).info("ABC")
E       AttributeError: 'NoneType' object has no attribute 'info'

colorize   = True
writer     = <function writer.<locals>.w at 0x7fac07cb9510>

tests/test_opt.py:360: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colored_string_getitemfalse">test_opt.py::test_colored_string_getitem[False]</h3>
<details><summary> <pre>test_opt.py::test_colored_string_getitem[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbb010>, colorize = False

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colored_string_getitem(writer, colorize):
        logger.add(writer, colorize=colorize, format="<red>{message[0]}</red>")
>       logger.opt(colors=True).info("ABC")
E       AttributeError: 'NoneType' object has no attribute 'info'

colorize   = False
writer     = <function writer.<locals>.w at 0x7fac07cbb010>

tests/test_opt.py:360: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_without_formatting_argstrue">test_opt.py::test_colors_without_formatting_args[True]</h3>
<details><summary> <pre>test_opt.py::test_colors_without_formatting_args[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cba950>, colorize = True

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_without_formatting_args(writer, colorize):
        string = "{} This { should } not } raise {"
        logger.add(writer, colorize=colorize, format="{message}")
>       logger.opt(colors=True).info(string)
E       AttributeError: 'NoneType' object has no attribute 'info'

colorize   = True
string     = '{} This { should } not } raise {'
writer     = <function writer.<locals>.w at 0x7fac07cba950>

tests/test_opt.py:368: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_without_formatting_argsfalse">test_opt.py::test_colors_without_formatting_args[False]</h3>
<details><summary> <pre>test_opt.py::test_colors_without_formatting_args[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbad40>, colorize = False

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_without_formatting_args(writer, colorize):
        string = "{} This { should } not } raise {"
        logger.add(writer, colorize=colorize, format="{message}")
>       logger.opt(colors=True).info(string)
E       AttributeError: 'NoneType' object has no attribute 'info'

colorize   = False
string     = '{} This { should } not } raise {'
writer     = <function writer.<locals>.w at 0x7fac07cbad40>

tests/test_opt.py:368: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_with_recursion_depth_exceeded_in_formattrue">test_opt.py::test_colors_with_recursion_depth_exceeded_in_format[True]</h3>
<details><summary> <pre>test_opt.py::test_colors_with_recursion_depth_exceeded_in_format[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbbeb0>, colorize = True

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_with_recursion_depth_exceeded_in_format(writer, colorize):
>       with pytest.raises(ValueError, match=r"Invalid format"):
E       Failed: DID NOT RAISE <class 'ValueError'>

colorize   = True
writer     = <function writer.<locals>.w at 0x7fac07cbbeb0>

tests/test_opt.py:374: Failed
</pre>
</details>
<h3 id="test_optpytest_colors_with_recursion_depth_exceeded_in_formatfalse">test_opt.py::test_colors_with_recursion_depth_exceeded_in_format[False]</h3>
<details><summary> <pre>test_opt.py::test_colors_with_recursion_depth_exceeded_in_format[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbaef0>, colorize = False

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_with_recursion_depth_exceeded_in_format(writer, colorize):
>       with pytest.raises(ValueError, match=r"Invalid format"):
E       Failed: DID NOT RAISE <class 'ValueError'>

colorize   = False
writer     = <function writer.<locals>.w at 0x7fac07cbaef0>

tests/test_opt.py:374: Failed
</pre>
</details>
<h3 id="test_optpytest_colors_with_recursion_depth_exceeded_in_messagetrue">test_opt.py::test_colors_with_recursion_depth_exceeded_in_message[True]</h3>
<details><summary> <pre>test_opt.py::test_colors_with_recursion_depth_exceeded_in_message[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbbd90>, colorize = True

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_with_recursion_depth_exceeded_in_message(writer, colorize):
        logger.add(writer, format="{message}", colorize=colorize)

        with pytest.raises(ValueError, match=r"Max string recursion exceeded"):
>           logger.opt(colors=True).info("{foo:{foo:{foo:}}}", foo=123)
E           AttributeError: 'NoneType' object has no attribute 'info'

colorize   = True
writer     = <function writer.<locals>.w at 0x7fac07cbbd90>

tests/test_opt.py:383: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_with_recursion_depth_exceeded_in_messagefalse">test_opt.py::test_colors_with_recursion_depth_exceeded_in_message[False]</h3>
<details><summary> <pre>test_opt.py::test_colors_with_recursion_depth_exceeded_in_message[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbb130>, colorize = False

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_with_recursion_depth_exceeded_in_message(writer, colorize):
        logger.add(writer, format="{message}", colorize=colorize)

        with pytest.raises(ValueError, match=r"Max string recursion exceeded"):
>           logger.opt(colors=True).info("{foo:{foo:{foo:}}}", foo=123)
E           AttributeError: 'NoneType' object has no attribute 'info'

colorize   = False
writer     = <function writer.<locals>.w at 0x7fac07cbb130>

tests/test_opt.py:383: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_with_auto_indexingtrue">test_opt.py::test_colors_with_auto_indexing[True]</h3>
<details><summary> <pre>test_opt.py::test_colors_with_auto_indexing[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cba3b0>, colorize = True

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_with_auto_indexing(writer, colorize):
        logger.add(writer, format="{message}", colorize=colorize)
>       logger.opt(colors=True).info("<red>{}</red> <green>{}</green>", "foo", "bar")
E       AttributeError: 'NoneType' object has no attribute 'info'

colorize   = True
writer     = <function writer.<locals>.w at 0x7fac07cba3b0>

tests/test_opt.py:389: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_with_auto_indexingfalse">test_opt.py::test_colors_with_auto_indexing[False]</h3>
<details><summary> <pre>test_opt.py::test_colors_with_auto_indexing[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cba5f0>, colorize = False

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_with_auto_indexing(writer, colorize):
        logger.add(writer, format="{message}", colorize=colorize)
>       logger.opt(colors=True).info("<red>{}</red> <green>{}</green>", "foo", "bar")
E       AttributeError: 'NoneType' object has no attribute 'info'

colorize   = False
writer     = <function writer.<locals>.w at 0x7fac07cba5f0>

tests/test_opt.py:389: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_with_manual_indexingtrue">test_opt.py::test_colors_with_manual_indexing[True]</h3>
<details><summary> <pre>test_opt.py::test_colors_with_manual_indexing[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cb97e0>, colorize = True

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_with_manual_indexing(writer, colorize):
        logger.add(writer, format="{message}", colorize=colorize)
>       logger.opt(colors=True).info("<red>{1}</red> <green>{0}</green>", "foo", "bar")
E       AttributeError: 'NoneType' object has no attribute 'info'

colorize   = True
writer     = <function writer.<locals>.w at 0x7fac07cb97e0>

tests/test_opt.py:396: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_with_manual_indexingfalse">test_opt.py::test_colors_with_manual_indexing[False]</h3>
<details><summary> <pre>test_opt.py::test_colors_with_manual_indexing[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbb880>, colorize = False

    @pytest.mark.parametrize("colorize", [True, False])
    def test_colors_with_manual_indexing(writer, colorize):
        logger.add(writer, format="{message}", colorize=colorize)
>       logger.opt(colors=True).info("<red>{1}</red> <green>{0}</green>", "foo", "bar")
E       AttributeError: 'NoneType' object has no attribute 'info'

colorize   = False
writer     = <function writer.<locals>.w at 0x7fac07cbb880>

tests/test_opt.py:396: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_with_invalid_indexing-0-true">test_opt.py::test_colors_with_invalid_indexing[{} {0}-True]</h3>
<details><summary> <pre>test_opt.py::test_colors_with_invalid_indexing[{} {0}-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cba7a0>, colorize = True
message = '{} {0}'

    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("message", ["{} {0}", "{1} {}"])
    def test_colors_with_invalid_indexing(writer, colorize, message):
        logger.add(writer, format="{message}", colorize=colorize)

        with pytest.raises(ValueError, match=r"cannot switch"):
>           logger.opt(colors=True).debug(message, 1, 2, 3)
E           AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = True
message    = '{} {0}'
writer     = <function writer.<locals>.w at 0x7fac07cba7a0>

tests/test_opt.py:406: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_with_invalid_indexing-0-false">test_opt.py::test_colors_with_invalid_indexing[{} {0}-False]</h3>
<details><summary> <pre>test_opt.py::test_colors_with_invalid_indexing[{} {0}-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbb6d0>, colorize = False
message = '{} {0}'

    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("message", ["{} {0}", "{1} {}"])
    def test_colors_with_invalid_indexing(writer, colorize, message):
        logger.add(writer, format="{message}", colorize=colorize)

        with pytest.raises(ValueError, match=r"cannot switch"):
>           logger.opt(colors=True).debug(message, 1, 2, 3)
E           AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = False
message    = '{} {0}'
writer     = <function writer.<locals>.w at 0x7fac07cbb6d0>

tests/test_opt.py:406: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_with_invalid_indexing1-true">test_opt.py::test_colors_with_invalid_indexing[{1} {}-True]</h3>
<details><summary> <pre>test_opt.py::test_colors_with_invalid_indexing[{1} {}-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbb0a0>, colorize = True
message = '{1} {}'

    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("message", ["{} {0}", "{1} {}"])
    def test_colors_with_invalid_indexing(writer, colorize, message):
        logger.add(writer, format="{message}", colorize=colorize)

        with pytest.raises(ValueError, match=r"cannot switch"):
>           logger.opt(colors=True).debug(message, 1, 2, 3)
E           AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = True
message    = '{1} {}'
writer     = <function writer.<locals>.w at 0x7fac07cbb0a0>

tests/test_opt.py:406: AttributeError
</pre>
</details>
<h3 id="test_optpytest_colors_with_invalid_indexing1-false">test_opt.py::test_colors_with_invalid_indexing[{1} {}-False]</h3>
<details><summary> <pre>test_opt.py::test_colors_with_invalid_indexing[{1} {}-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cb8ee0>, colorize = False
message = '{1} {}'

    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("message", ["{} {0}", "{1} {}"])
    def test_colors_with_invalid_indexing(writer, colorize, message):
        logger.add(writer, format="{message}", colorize=colorize)

        with pytest.raises(ValueError, match=r"cannot switch"):
>           logger.opt(colors=True).debug(message, 1, 2, 3)
E           AttributeError: 'NoneType' object has no attribute 'debug'

colorize   = False
message    = '{1} {}'
writer     = <function writer.<locals>.w at 0x7fac07cb8ee0>

tests/test_opt.py:406: AttributeError
</pre>
</details>
<h3 id="test_optpytest_raw">test_opt.py::test_raw</h3>
<details><summary> <pre>test_opt.py::test_raw</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cba4d0>

    def test_raw(writer):
        logger.add(writer, format="", colorize=True)
>       logger.opt(raw=True).info("Raw {}", "message")
E       AttributeError: 'NoneType' object has no attribute 'info'

writer     = <function writer.<locals>.w at 0x7fac07cba4d0>

tests/test_opt.py:411: AttributeError
</pre>
</details>
<h3 id="test_optpytest_raw_with_format_function">test_opt.py::test_raw_with_format_function</h3>
<details><summary> <pre>test_opt.py::test_raw_with_format_function</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbb1c0>

    def test_raw_with_format_function(writer):
        logger.add(writer, format=lambda _: "{time} \n")
>       logger.opt(raw=True).debug("Raw {message} bis", message="message")
E       AttributeError: 'NoneType' object has no attribute 'debug'

writer     = <function writer.<locals>.w at 0x7fac07cbb1c0>

tests/test_opt.py:418: AttributeError
</pre>
</details>
<h3 id="test_optpytest_raw_with_colorstrue">test_opt.py::test_raw_with_colors[True]</h3>
<details><summary> <pre>test_opt.py::test_raw_with_colors[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbacb0>, colorize = True

    @pytest.mark.parametrize("colorize", [True, False])
    def test_raw_with_colors(writer, colorize):
        logger.add(writer, format="XYZ", colorize=colorize)
>       logger.opt(raw=True, colors=True).info("Raw <red>colors</red> and <lvl>level</lvl>")
E       AttributeError: 'NoneType' object has no attribute 'info'

colorize   = True
writer     = <function writer.<locals>.w at 0x7fac07cbacb0>

tests/test_opt.py:425: AttributeError
</pre>
</details>
<h3 id="test_optpytest_raw_with_colorsfalse">test_opt.py::test_raw_with_colors[False]</h3>
<details><summary> <pre>test_opt.py::test_raw_with_colors[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbae60>, colorize = False

    @pytest.mark.parametrize("colorize", [True, False])
    def test_raw_with_colors(writer, colorize):
        logger.add(writer, format="XYZ", colorize=colorize)
>       logger.opt(raw=True, colors=True).info("Raw <red>colors</red> and <lvl>level</lvl>")
E       AttributeError: 'NoneType' object has no attribute 'info'

colorize   = False
writer     = <function writer.<locals>.w at 0x7fac07cbae60>

tests/test_opt.py:425: AttributeError
</pre>
</details>
<h3 id="test_optpytest_args_with_colors_not_formatted_twice">test_opt.py::test_args_with_colors_not_formatted_twice</h3>
<details><summary> <pre>test_opt.py::test_args_with_colors_not_formatted_twice</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0876dc30>

    def test_args_with_colors_not_formatted_twice(capsys):
        logger.add(sys.stdout, format="{message}", colorize=True)
        logger.add(sys.stderr, format="{message}", colorize=False)
        a = MagicMock(__format__=MagicMock(return_value="a"))
        b = MagicMock(__format__=MagicMock(return_value="b"))

>       logger.opt(colors=True).info("{} <red>{foo}</red>", a, foo=b)
E       AttributeError: 'NoneType' object has no attribute 'info'

a          = <MagicMock id='140376847776784'>
b          = <MagicMock id='140376842150400'>
capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0876dc30>

tests/test_opt.py:435: AttributeError
</pre>
</details>
<h3 id="test_optpytest_level_tag_wrapping_with_colorstrue">test_opt.py::test_level_tag_wrapping_with_colors[True]</h3>
<details><summary> <pre>test_opt.py::test_level_tag_wrapping_with_colors[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbaf80>, colorize = True

    @pytest.mark.parametrize("colorize", [True, False])
    def test_level_tag_wrapping_with_colors(writer, colorize):
        logger.add(writer, format="<level>FOO {message} BAR</level>", colorize=colorize)
>       logger.opt(colors=True).info("> foo <red>{} bar <lvl>{} baz <green>{}</green> <", 1, 2, 3)
E       AttributeError: 'NoneType' object has no attribute 'info'

colorize   = True
writer     = <function writer.<locals>.w at 0x7fac07cbaf80>

tests/test_opt.py:446: AttributeError
</pre>
</details>
<h3 id="test_optpytest_level_tag_wrapping_with_colorsfalse">test_opt.py::test_level_tag_wrapping_with_colors[False]</h3>
<details><summary> <pre>test_opt.py::test_level_tag_wrapping_with_colors[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbb910>, colorize = False

    @pytest.mark.parametrize("colorize", [True, False])
    def test_level_tag_wrapping_with_colors(writer, colorize):
        logger.add(writer, format="<level>FOO {message} BAR</level>", colorize=colorize)
>       logger.opt(colors=True).info("> foo <red>{} bar <lvl>{} baz <green>{}</green> <", 1, 2, 3)
E       AttributeError: 'NoneType' object has no attribute 'info'

colorize   = False
writer     = <function writer.<locals>.w at 0x7fac07cbb910>

tests/test_opt.py:446: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-true-true-true-true-true">test_opt.py::test_all_colors_combinations[True-True-True-True-True-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-True-True-True-True-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbaa70>, dynamic_format = True
colorize = True, colors = True, raw = True, use_log = True, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
>               logger_.log(20, message, arg)
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = True
colors     = True
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07cbb490>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = True
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07cbaa70>

tests/test_opt.py:476: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-true-true-true-true-false">test_opt.py::test_all_colors_combinations[True-True-True-True-True-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-True-True-True-True-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cb9f30>, dynamic_format = False
colorize = True, colors = True, raw = True, use_log = True, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
>               logger_.log(20, message, arg)
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = True
colors     = True
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07cba0e0>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = True
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07cb9f30>

tests/test_opt.py:476: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-true-true-true-false-true">test_opt.py::test_all_colors_combinations[True-True-True-True-False-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-True-True-True-False-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbbf40>, dynamic_format = True
colorize = False, colors = True, raw = True, use_log = True, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
>               logger_.log(20, message, arg)
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = False
colors     = True
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07cb9ab0>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = True
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07cbbf40>

tests/test_opt.py:476: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-true-true-true-false-false">test_opt.py::test_all_colors_combinations[True-True-True-True-False-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-True-True-True-False-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbb880>, dynamic_format = False
colorize = False, colors = True, raw = True, use_log = True, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
>               logger_.log(20, message, arg)
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = False
colors     = True
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07cbb9a0>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = True
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07cbb880>

tests/test_opt.py:476: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-true-true-false-true-true">test_opt.py::test_all_colors_combinations[True-True-True-False-True-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-True-True-False-True-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cba290>, dynamic_format = True
colorize = True, colors = False, raw = True, use_log = True, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
>               logger_.log(20, message, arg)
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = True
colors     = False
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07cbb6d0>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = True
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07cba290>

tests/test_opt.py:476: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-true-true-false-true-false">test_opt.py::test_all_colors_combinations[True-True-True-False-True-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-True-True-False-True-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbbac0>, dynamic_format = False
colorize = True, colors = False, raw = True, use_log = True, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
>               logger_.log(20, message, arg)
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = True
colors     = False
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07cba440>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = True
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07cbbac0>

tests/test_opt.py:476: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-true-true-false-false-true">test_opt.py::test_all_colors_combinations[True-True-True-False-False-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-True-True-False-False-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cba950>, dynamic_format = True
colorize = False, colors = False, raw = True, use_log = True, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
>               logger_.log(20, message, arg)
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = False
colors     = False
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07cbb880>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = True
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07cba950>

tests/test_opt.py:476: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-true-true-false-false-false">test_opt.py::test_all_colors_combinations[True-True-True-False-False-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-True-True-False-False-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cb9240>, dynamic_format = False
colorize = False, colors = False, raw = True, use_log = True, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
>               logger_.log(20, message, arg)
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = False
colors     = False
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07cbb1c0>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = True
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07cb9240>

tests/test_opt.py:476: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-true-false-true-true-true">test_opt.py::test_all_colors_combinations[True-True-False-True-True-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-True-False-True-True-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7ce50>, dynamic_format = True
colorize = True, colors = True, raw = False, use_log = True, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
>               logger_.log(20, message, arg)
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = True
colors     = True
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7d360>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = True
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07c7ce50>

tests/test_opt.py:476: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-true-false-true-true-false">test_opt.py::test_all_colors_combinations[True-True-False-True-True-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-True-False-True-True-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7c430>, dynamic_format = False
colorize = True, colors = True, raw = False, use_log = True, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
>               logger_.log(20, message, arg)
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = True
colors     = True
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7c280>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = True
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07c7c430>

tests/test_opt.py:476: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-true-false-true-false-true">test_opt.py::test_all_colors_combinations[True-True-False-True-False-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-True-False-True-False-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7c160>, dynamic_format = True
colorize = False, colors = True, raw = False, use_log = True, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
>               logger_.log(20, message, arg)
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = False
colors     = True
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7c700>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = True
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07c7c160>

tests/test_opt.py:476: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-true-false-true-false-false">test_opt.py::test_all_colors_combinations[True-True-False-True-False-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-True-False-True-False-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7c550>, dynamic_format = False
colorize = False, colors = True, raw = False, use_log = True, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
>               logger_.log(20, message, arg)
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = False
colors     = True
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7cd30>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = True
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07c7c550>

tests/test_opt.py:476: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-true-false-false-true-true">test_opt.py::test_all_colors_combinations[True-True-False-False-True-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-True-False-False-True-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7c310>, dynamic_format = True
colorize = True, colors = False, raw = False, use_log = True, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
>               logger_.log(20, message, arg)
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = True
colors     = False
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7d240>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = True
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07c7c310>

tests/test_opt.py:476: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-true-false-false-true-false">test_opt.py::test_all_colors_combinations[True-True-False-False-True-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-True-False-False-True-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7c790>, dynamic_format = False
colorize = True, colors = False, raw = False, use_log = True, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
>               logger_.log(20, message, arg)
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = True
colors     = False
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7d630>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = True
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07c7c790>

tests/test_opt.py:476: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-true-false-false-false-true">test_opt.py::test_all_colors_combinations[True-True-False-False-False-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-True-False-False-False-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbb1c0>, dynamic_format = True
colorize = False, colors = False, raw = False, use_log = True, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
>               logger_.log(20, message, arg)
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = False
colors     = False
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07cbb370>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = True
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07cbb1c0>

tests/test_opt.py:476: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-true-false-false-false-false">test_opt.py::test_all_colors_combinations[True-True-False-False-False-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-True-False-False-False-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbb9a0>, dynamic_format = False
colorize = False, colors = False, raw = False, use_log = True, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
>               logger_.log(20, message, arg)
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = False
colors     = False
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07cb81f0>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = True
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07cbb9a0>

tests/test_opt.py:476: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-false-true-true-true-true">test_opt.py::test_all_colors_combinations[True-False-True-True-True-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-False-True-True-True-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cb9240>, dynamic_format = True
colorize = True, colors = True, raw = True, use_log = False, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
>               logger_.info(message, arg)
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = True
colors     = True
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07cbb6d0>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = True
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07cb9240>

tests/test_opt.py:481: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-false-true-true-true-false">test_opt.py::test_all_colors_combinations[True-False-True-True-True-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-False-True-True-True-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbbc70>, dynamic_format = False
colorize = True, colors = True, raw = True, use_log = False, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
>               logger_.info(message, arg)
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = True
colors     = True
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07cbae60>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = True
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07cbbc70>

tests/test_opt.py:481: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-false-true-true-false-true">test_opt.py::test_all_colors_combinations[True-False-True-True-False-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-False-True-True-False-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cba440>, dynamic_format = True
colorize = False, colors = True, raw = True, use_log = False, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
>               logger_.info(message, arg)
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = False
colors     = True
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07cbb490>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = True
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07cba440>

tests/test_opt.py:481: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-false-true-true-false-false">test_opt.py::test_all_colors_combinations[True-False-True-True-False-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-False-True-True-False-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbbf40>, dynamic_format = False
colorize = False, colors = True, raw = True, use_log = False, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
>               logger_.info(message, arg)
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = False
colors     = True
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07cba5f0>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = True
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07cbbf40>

tests/test_opt.py:481: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-false-true-false-true-true">test_opt.py::test_all_colors_combinations[True-False-True-False-True-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-False-True-False-True-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7c0d0>, dynamic_format = True
colorize = True, colors = False, raw = True, use_log = False, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
>               logger_.info(message, arg)
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = True
colors     = False
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7d7e0>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = True
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07c7c0d0>

tests/test_opt.py:481: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-false-true-false-true-false">test_opt.py::test_all_colors_combinations[True-False-True-False-True-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-False-True-False-True-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7dd80>, dynamic_format = False
colorize = True, colors = False, raw = True, use_log = False, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
>               logger_.info(message, arg)
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = True
colors     = False
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7db40>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = True
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07c7dd80>

tests/test_opt.py:481: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-false-true-false-false-true">test_opt.py::test_all_colors_combinations[True-False-True-False-False-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-False-True-False-False-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7d990>, dynamic_format = True
colorize = False, colors = False, raw = True, use_log = False, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
>               logger_.info(message, arg)
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = False
colors     = False
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7dfc0>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = True
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07c7d990>

tests/test_opt.py:481: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-false-true-false-false-false">test_opt.py::test_all_colors_combinations[True-False-True-False-False-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-False-True-False-False-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7d750>, dynamic_format = False
colorize = False, colors = False, raw = True, use_log = False, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
>               logger_.info(message, arg)
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = False
colors     = False
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7c280>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = True
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07c7d750>

tests/test_opt.py:481: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-false-false-true-true-true">test_opt.py::test_all_colors_combinations[True-False-False-True-True-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-False-False-True-True-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7dbd0>, dynamic_format = True
colorize = True, colors = True, raw = False, use_log = False, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
>               logger_.info(message, arg)
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = True
colors     = True
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7e710>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = True
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07c7dbd0>

tests/test_opt.py:481: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-false-false-true-true-false">test_opt.py::test_all_colors_combinations[True-False-False-True-True-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-False-False-True-True-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7e050>, dynamic_format = False
colorize = True, colors = True, raw = False, use_log = False, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
>               logger_.info(message, arg)
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = True
colors     = True
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7eb90>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = True
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07c7e050>

tests/test_opt.py:481: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-false-false-true-false-true">test_opt.py::test_all_colors_combinations[True-False-False-True-False-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-False-False-True-False-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7e320>, dynamic_format = True
colorize = False, colors = True, raw = False, use_log = False, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
>               logger_.info(message, arg)
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = False
colors     = True
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7c8b0>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = True
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07c7e320>

tests/test_opt.py:481: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-false-false-true-false-false">test_opt.py::test_all_colors_combinations[True-False-False-True-False-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-False-False-True-False-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7e7a0>, dynamic_format = False
colorize = False, colors = True, raw = False, use_log = False, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
>               logger_.info(message, arg)
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = False
colors     = True
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7c700>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = True
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07c7e7a0>

tests/test_opt.py:481: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-false-false-false-true-true">test_opt.py::test_all_colors_combinations[True-False-False-False-True-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-False-False-False-True-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7c310>, dynamic_format = True
colorize = True, colors = False, raw = False, use_log = False, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
>               logger_.info(message, arg)
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = True
colors     = False
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7ca60>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = True
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07c7c310>

tests/test_opt.py:481: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-false-false-false-true-false">test_opt.py::test_all_colors_combinations[True-False-False-False-True-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-False-False-False-True-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cba5f0>, dynamic_format = False
colorize = True, colors = False, raw = False, use_log = False, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
>               logger_.info(message, arg)
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = True
colors     = False
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07cba950>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = True
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07cba5f0>

tests/test_opt.py:481: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-false-false-false-false-true">test_opt.py::test_all_colors_combinations[True-False-False-False-False-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-False-False-False-False-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbb370>, dynamic_format = True
colorize = False, colors = False, raw = False, use_log = False, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
>               logger_.info(message, arg)
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = False
colors     = False
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07cb9d80>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = True
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07cbb370>

tests/test_opt.py:481: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationstrue-false-false-false-false-false">test_opt.py::test_all_colors_combinations[True-False-False-False-False-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[True-False-False-False-False-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbbf40>, dynamic_format = False
colorize = False, colors = False, raw = False, use_log = False, use_arg = True

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
>               logger_.info(message, arg)
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = False
colors     = False
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07cbbac0>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = True
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07cbbf40>

tests/test_opt.py:481: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-true-true-true-true-true">test_opt.py::test_all_colors_combinations[False-True-True-True-True-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-True-True-True-True-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cba0e0>, dynamic_format = True
colorize = True, colors = True, raw = True, use_log = True, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
>               logger_.log(20, message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = True
colors     = True
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07cbb880>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = False
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07cba0e0>

tests/test_opt.py:478: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-true-true-true-true-false">test_opt.py::test_all_colors_combinations[False-True-True-True-True-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-True-True-True-True-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7ec20>, dynamic_format = False
colorize = True, colors = True, raw = True, use_log = True, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
>               logger_.log(20, message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = True
colors     = True
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7ed40>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = False
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07c7ec20>

tests/test_opt.py:478: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-true-true-true-false-true">test_opt.py::test_all_colors_combinations[False-True-True-True-False-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-True-True-True-False-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7c9d0>, dynamic_format = True
colorize = False, colors = True, raw = True, use_log = True, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
>               logger_.log(20, message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = False
colors     = True
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7e050>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = False
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07c7c9d0>

tests/test_opt.py:478: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-true-true-true-false-false">test_opt.py::test_all_colors_combinations[False-True-True-True-False-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-True-True-True-False-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7edd0>, dynamic_format = False
colorize = False, colors = True, raw = True, use_log = True, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
>               logger_.log(20, message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = False
colors     = True
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7f2e0>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = False
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07c7edd0>

tests/test_opt.py:478: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-true-true-false-true-true">test_opt.py::test_all_colors_combinations[False-True-True-False-True-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-True-True-False-True-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7f130>, dynamic_format = True
colorize = True, colors = False, raw = True, use_log = True, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
>               logger_.log(20, message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = True
colors     = False
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7f760>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = False
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07c7f130>

tests/test_opt.py:478: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-true-true-false-true-false">test_opt.py::test_all_colors_combinations[False-True-True-False-True-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-True-True-False-True-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7ef80>, dynamic_format = False
colorize = True, colors = False, raw = True, use_log = True, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
>               logger_.log(20, message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = True
colors     = False
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7fbe0>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = False
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07c7ef80>

tests/test_opt.py:478: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-true-true-false-false-true">test_opt.py::test_all_colors_combinations[False-True-True-False-False-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-True-True-False-False-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7f400>, dynamic_format = True
colorize = False, colors = False, raw = True, use_log = True, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
>               logger_.log(20, message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = False
colors     = False
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7c8b0>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = False
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07c7f400>

tests/test_opt.py:478: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-true-true-false-false-false">test_opt.py::test_all_colors_combinations[False-True-True-False-False-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-True-True-False-False-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7f910>, dynamic_format = False
colorize = False, colors = False, raw = True, use_log = True, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
>               logger_.log(20, message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = False
colors     = False
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7e950>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = False
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07c7f910>

tests/test_opt.py:478: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-true-false-true-true-true">test_opt.py::test_all_colors_combinations[False-True-False-True-True-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-True-False-True-True-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7fd90>, dynamic_format = True
colorize = True, colors = True, raw = False, use_log = True, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
>               logger_.log(20, message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = True
colors     = True
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7e3b0>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = False
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07c7fd90>

tests/test_opt.py:478: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-true-false-true-true-false">test_opt.py::test_all_colors_combinations[False-True-False-True-True-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-True-False-True-True-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7ff40>, dynamic_format = False
colorize = True, colors = True, raw = False, use_log = True, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
>               logger_.log(20, message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = True
colors     = True
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7d990>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = False
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07c7ff40>

tests/test_opt.py:478: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-true-false-true-false-true">test_opt.py::test_all_colors_combinations[False-True-False-True-False-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-True-False-True-False-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cb9240>, dynamic_format = True
colorize = False, colors = True, raw = False, use_log = True, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
>               logger_.log(20, message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = False
colors     = True
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07cb8160>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = False
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07cb9240>

tests/test_opt.py:478: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-true-false-true-false-false">test_opt.py::test_all_colors_combinations[False-True-False-True-False-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-True-False-True-False-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbbf40>, dynamic_format = False
colorize = False, colors = True, raw = False, use_log = True, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
>               logger_.log(20, message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = False
colors     = True
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07cbba30>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = False
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07cbbf40>

tests/test_opt.py:478: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-true-false-false-true-true">test_opt.py::test_all_colors_combinations[False-True-False-False-True-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-True-False-False-True-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7de10>, dynamic_format = True
colorize = True, colors = False, raw = False, use_log = True, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
>               logger_.log(20, message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = True
colors     = False
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07cbb130>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = False
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07c7de10>

tests/test_opt.py:478: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-true-false-false-true-false">test_opt.py::test_all_colors_combinations[False-True-False-False-True-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-True-False-False-True-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbb370>, dynamic_format = False
colorize = True, colors = False, raw = False, use_log = True, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
>               logger_.log(20, message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = True
colors     = False
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07cbaa70>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = False
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07cbb370>

tests/test_opt.py:478: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-true-false-false-false-true">test_opt.py::test_all_colors_combinations[False-True-False-False-False-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-True-False-False-False-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7e9e0>, dynamic_format = True
colorize = False, colors = False, raw = False, use_log = True, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
>               logger_.log(20, message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = False
colors     = False
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7d480>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = False
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07c7e9e0>

tests/test_opt.py:478: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-true-false-false-false-false">test_opt.py::test_all_colors_combinations[False-True-False-False-False-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-True-False-False-False-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7dfc0>, dynamic_format = False
colorize = False, colors = False, raw = False, use_log = True, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
>               logger_.log(20, message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'log'

arg        = 'message'
colorize   = False
colors     = False
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7fe20>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = False
use_log    = True
writer     = <function writer.<locals>.w at 0x7fac07c7dfc0>

tests/test_opt.py:478: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-false-true-true-true-true">test_opt.py::test_all_colors_combinations[False-False-True-True-True-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-False-True-True-True-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7d630>, dynamic_format = True
colorize = True, colors = True, raw = True, use_log = False, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
                logger_.info(message, arg)
            else:
>               logger_.info(message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = True
colors     = True
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7ce50>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = False
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07c7d630>

tests/test_opt.py:483: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-false-true-true-true-false">test_opt.py::test_all_colors_combinations[False-False-True-True-True-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-False-True-True-True-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7d2d0>, dynamic_format = False
colorize = True, colors = True, raw = True, use_log = False, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
                logger_.info(message, arg)
            else:
>               logger_.info(message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = True
colors     = True
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7fac0>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = False
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07c7d2d0>

tests/test_opt.py:483: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-false-true-true-false-true">test_opt.py::test_all_colors_combinations[False-False-True-True-False-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-False-True-True-False-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7e320>, dynamic_format = True
colorize = False, colors = True, raw = True, use_log = False, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
                logger_.info(message, arg)
            else:
>               logger_.info(message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = False
colors     = True
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7f760>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = False
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07c7e320>

tests/test_opt.py:483: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-false-true-true-false-false">test_opt.py::test_all_colors_combinations[False-False-True-True-False-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-False-True-True-False-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7e3b0>, dynamic_format = False
colorize = False, colors = True, raw = True, use_log = False, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
                logger_.info(message, arg)
            else:
>               logger_.info(message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = False
colors     = True
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7ec20>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = False
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07c7e3b0>

tests/test_opt.py:483: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-false-true-false-true-true">test_opt.py::test_all_colors_combinations[False-False-True-False-True-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-False-True-False-True-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7f9a0>, dynamic_format = True
colorize = True, colors = False, raw = True, use_log = False, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
                logger_.info(message, arg)
            else:
>               logger_.info(message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = True
colors     = False
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7d2d0>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = False
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07c7f9a0>

tests/test_opt.py:483: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-false-true-false-true-false">test_opt.py::test_all_colors_combinations[False-False-True-False-True-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-False-True-False-True-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7f1c0>, dynamic_format = False
colorize = True, colors = False, raw = True, use_log = False, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
                logger_.info(message, arg)
            else:
>               logger_.info(message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = True
colors     = False
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7f910>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = False
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07c7f1c0>

tests/test_opt.py:483: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-false-true-false-false-true">test_opt.py::test_all_colors_combinations[False-False-True-False-False-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-False-True-False-False-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07b88280>, dynamic_format = True
colorize = False, colors = False, raw = True, use_log = False, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
                logger_.info(message, arg)
            else:
>               logger_.info(message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = False
colors     = False
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07b88430>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = False
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07b88280>

tests/test_opt.py:483: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-false-true-false-false-false">test_opt.py::test_all_colors_combinations[False-False-True-False-False-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-False-True-False-False-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbaa70>, dynamic_format = False
colorize = False, colors = False, raw = True, use_log = False, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
                logger_.info(message, arg)
            else:
>               logger_.info(message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = False
colors     = False
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07cbbf40>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = True
use_arg    = False
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07cbaa70>

tests/test_opt.py:483: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-false-false-true-true-true">test_opt.py::test_all_colors_combinations[False-False-False-True-True-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-False-False-True-True-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbb370>, dynamic_format = True
colorize = True, colors = True, raw = False, use_log = False, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
                logger_.info(message, arg)
            else:
>               logger_.info(message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = True
colors     = True
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07cbbac0>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = False
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07cbb370>

tests/test_opt.py:483: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-false-false-true-true-false">test_opt.py::test_all_colors_combinations[False-False-False-True-True-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-False-False-True-True-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cbba30>, dynamic_format = False
colorize = True, colors = True, raw = False, use_log = False, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
                logger_.info(message, arg)
            else:
>               logger_.info(message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = True
colors     = True
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07cba440>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = False
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07cbba30>

tests/test_opt.py:483: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-false-false-true-false-true">test_opt.py::test_all_colors_combinations[False-False-False-True-False-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-False-False-True-False-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7f9a0>, dynamic_format = True
colorize = False, colors = True, raw = False, use_log = False, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
                logger_.info(message, arg)
            else:
>               logger_.info(message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = False
colors     = True
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7c310>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = False
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07c7f9a0>

tests/test_opt.py:483: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-false-false-true-false-false">test_opt.py::test_all_colors_combinations[False-False-False-True-False-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-False-False-True-False-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7e7a0>, dynamic_format = False
colorize = False, colors = True, raw = False, use_log = False, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
                logger_.info(message, arg)
            else:
>               logger_.info(message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = False
colors     = True
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7e320>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = False
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07c7e7a0>

tests/test_opt.py:483: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-false-false-false-true-true">test_opt.py::test_all_colors_combinations[False-False-False-False-True-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-False-False-False-True-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7ee60>, dynamic_format = True
colorize = True, colors = False, raw = False, use_log = False, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
                logger_.info(message, arg)
            else:
>               logger_.info(message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = True
colors     = False
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7c8b0>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = False
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07c7ee60>

tests/test_opt.py:483: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-false-false-false-true-false">test_opt.py::test_all_colors_combinations[False-False-False-False-True-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-False-False-False-True-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7d2d0>, dynamic_format = False
colorize = True, colors = False, raw = False, use_log = False, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
                logger_.info(message, arg)
            else:
>               logger_.info(message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = True
colors     = False
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7db40>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = False
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07c7d2d0>

tests/test_opt.py:483: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-false-false-false-false-true">test_opt.py::test_all_colors_combinations[False-False-False-False-False-True]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-False-False-False-False-True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7f640>, dynamic_format = True
colorize = False, colors = False, raw = False, use_log = False, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
                logger_.info(message, arg)
            else:
>               logger_.info(message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = False
colors     = False
dynamic_format = True
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7e170>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = False
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07c7f640>

tests/test_opt.py:483: AttributeError
</pre>
</details>
<h3 id="test_optpytest_all_colors_combinationsfalse-false-false-false-false-false">test_opt.py::test_all_colors_combinations[False-False-False-False-False-False]</h3>
<details><summary> <pre>test_opt.py::test_all_colors_combinations[False-False-False-False-False-False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7fd90>, dynamic_format = False
colorize = False, colors = False, raw = False, use_log = False, use_arg = False

    @pytest.mark.parametrize("dynamic_format", [True, False])
    @pytest.mark.parametrize("colorize", [True, False])
    @pytest.mark.parametrize("colors", [True, False])
    @pytest.mark.parametrize("raw", [True, False])
    @pytest.mark.parametrize("use_log", [True, False])
    @pytest.mark.parametrize("use_arg", [True, False])
    def test_all_colors_combinations(writer, dynamic_format, colorize, colors, raw, use_log, use_arg):
        format_ = "<level>{level.no:03}</level> <red>{message}</red>"
        message = "<green>The</green> <lvl>{}</lvl>"
        arg = "message"

        def formatter(_):
            return format_ + "\n"

        logger.add(writer, format=formatter if dynamic_format else format_, colorize=colorize)

        logger_ = logger.opt(colors=colors, raw=raw)

        if use_log:
            if use_arg:
                logger_.log(20, message, arg)
            else:
                logger_.log(20, message.format(arg))
        else:
            if use_arg:
                logger_.info(message, arg)
            else:
>               logger_.info(message.format(arg))
E               AttributeError: 'NoneType' object has no attribute 'info'

arg        = 'message'
colorize   = False
colors     = False
dynamic_format = False
format_    = '<level>{level.no:03}</level> <red>{message}</red>'
formatter  = <function test_all_colors_combinations.<locals>.formatter at 0x7fac07c7dfc0>
logger_    = None
message    = '<green>The</green> <lvl>{}</lvl>'
raw        = False
use_arg    = False
use_log    = False
writer     = <function writer.<locals>.w at 0x7fac07c7fd90>

tests/test_opt.py:483: AttributeError
</pre>
</details>
<h3 id="test_optpytest_raw_with_record">test_opt.py::test_raw_with_record</h3>
<details><summary> <pre>test_opt.py::test_raw_with_record</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07b89120>

    def test_raw_with_record(writer):
        logger.add(writer, format="Nope\n")
>       logger.opt(raw=True, record=True).debug("Raw in '{record[function]}'\n")
E       AttributeError: 'NoneType' object has no attribute 'debug'

writer     = <function writer.<locals>.w at 0x7fac07b89120>

tests/test_opt.py:525: AttributeError
</pre>
</details>
<h3 id="test_optpytest_keep_extra">test_opt.py::test_keep_extra</h3>
<details><summary> <pre>test_opt.py::test_keep_extra</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07b884c0>

    def test_keep_extra(writer):
        logger.configure(extra=dict(test=123))
        logger.add(writer, format="{extra[test]}")
>       logger.opt().debug("")
E       AttributeError: 'NoneType' object has no attribute 'debug'

writer     = <function writer.<locals>.w at 0x7fac07b884c0>

tests/test_opt.py:532: AttributeError
</pre>
</details>
<h3 id="test_optpytest_before_bind">test_opt.py::test_before_bind</h3>
<details><summary> <pre>test_opt.py::test_before_bind</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07b88160>

    def test_before_bind(writer):
        logger.add(writer, format="{message}")
>       logger.opt(record=True).bind(key="value").info("{record[level]}")
E       AttributeError: 'NoneType' object has no attribute 'bind'

writer     = <function writer.<locals>.w at 0x7fac07b88160>

tests/test_opt.py:540: AttributeError
</pre>
</details>
<h3 id="test_optpytest_deprecated_ansi_argument">test_opt.py::test_deprecated_ansi_argument</h3>
<details><summary> <pre>test_opt.py::test_deprecated_ansi_argument</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07b88790>

    def test_deprecated_ansi_argument(writer):
        logger.add(writer, format="{message}", colorize=True)
        with pytest.warns(DeprecationWarning):
>           logger.opt(ansi=True).info("Foo <red>bar</red> baz")
E           AttributeError: 'NoneType' object has no attribute 'info'

writer     = <function writer.<locals>.w at 0x7fac07b88790>

tests/test_opt.py:547: AttributeError

During handling of the above exception, another exception occurred:

writer = <function writer.<locals>.w at 0x7fac07b88790>

    def test_deprecated_ansi_argument(writer):
        logger.add(writer, format="{message}", colorize=True)
>       with pytest.warns(DeprecationWarning):
E       Failed: DID NOT WARN. No warnings of type (<class 'DeprecationWarning'>,) were emitted.
E        Emitted warnings: [].

writer     = <function writer.<locals>.w at 0x7fac07b88790>

tests/test_opt.py:546: Failed
</pre>
</details>
<h3 id="test_optpytest_message_update_not_overridden_by_patchtrue">test_opt.py::test_message_update_not_overridden_by_patch[True]</h3>
<details><summary> <pre>test_opt.py::test_message_update_not_overridden_by_patch[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07b88700>, colors = True

    @pytest.mark.parametrize("colors", [True, False])
    def test_message_update_not_overridden_by_patch(writer, colors):
        def patcher(record):
            record["message"] += " [Patched]"

        logger.add(writer, format="{level} {message}", colorize=True)
>       logger.patch(patcher).opt(colors=colors).info("Message")
E       AttributeError: 'NoneType' object has no attribute 'opt'

colors     = True
patcher    = <function test_message_update_not_overridden_by_patch.<locals>.patcher at 0x7fac07b88dc0>
writer     = <function writer.<locals>.w at 0x7fac07b88700>

tests/test_opt.py:557: AttributeError
</pre>
</details>
<h3 id="test_optpytest_message_update_not_overridden_by_patchfalse">test_opt.py::test_message_update_not_overridden_by_patch[False]</h3>
<details><summary> <pre>test_opt.py::test_message_update_not_overridden_by_patch[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07cba440>, colors = False

    @pytest.mark.parametrize("colors", [True, False])
    def test_message_update_not_overridden_by_patch(writer, colors):
        def patcher(record):
            record["message"] += " [Patched]"

        logger.add(writer, format="{level} {message}", colorize=True)
>       logger.patch(patcher).opt(colors=colors).info("Message")
E       AttributeError: 'NoneType' object has no attribute 'opt'

colors     = False
patcher    = <function test_message_update_not_overridden_by_patch.<locals>.patcher at 0x7fac07cbbf40>
writer     = <function writer.<locals>.w at 0x7fac07cba440>

tests/test_opt.py:557: AttributeError
</pre>
</details>
<h3 id="test_optpytest_message_update_not_overridden_by_formattrue">test_opt.py::test_message_update_not_overridden_by_format[True]</h3>
<details><summary> <pre>test_opt.py::test_message_update_not_overridden_by_format[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7db40>, colors = True

    @pytest.mark.parametrize("colors", [True, False])
    def test_message_update_not_overridden_by_format(writer, colors):
        def formatter(record):
            record["message"] += " [Formatted]"
            return "{level} {message}\n"

        logger.add(writer, format=formatter, colorize=True)
>       logger.opt(colors=colors).info("Message")
E       AttributeError: 'NoneType' object has no attribute 'info'

colors     = True
formatter  = <function test_message_update_not_overridden_by_format.<locals>.formatter at 0x7fac07cbaa70>
writer     = <function writer.<locals>.w at 0x7fac07c7db40>

tests/test_opt.py:569: AttributeError
</pre>
</details>
<h3 id="test_optpytest_message_update_not_overridden_by_formatfalse">test_opt.py::test_message_update_not_overridden_by_format[False]</h3>
<details><summary> <pre>test_opt.py::test_message_update_not_overridden_by_format[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7d990>, colors = False

    @pytest.mark.parametrize("colors", [True, False])
    def test_message_update_not_overridden_by_format(writer, colors):
        def formatter(record):
            record["message"] += " [Formatted]"
            return "{level} {message}\n"

        logger.add(writer, format=formatter, colorize=True)
>       logger.opt(colors=colors).info("Message")
E       AttributeError: 'NoneType' object has no attribute 'info'

colors     = False
formatter  = <function test_message_update_not_overridden_by_format.<locals>.formatter at 0x7fac07c7e290>
writer     = <function writer.<locals>.w at 0x7fac07c7d990>

tests/test_opt.py:569: AttributeError
</pre>
</details>
<h3 id="test_optpytest_message_update_not_overridden_by_filtertrue">test_opt.py::test_message_update_not_overridden_by_filter[True]</h3>
<details><summary> <pre>test_opt.py::test_message_update_not_overridden_by_filter[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7e170>, colors = True

    @pytest.mark.parametrize("colors", [True, False])
    def test_message_update_not_overridden_by_filter(writer, colors):
        def filter(record):
            record["message"] += " [Filtered]"
            return True

        logger.add(writer, format="{level} {message}", filter=filter, colorize=True)
>       logger.opt(colors=colors).info("Message")
E       AttributeError: 'NoneType' object has no attribute 'info'

colors     = True
filter     = <function test_message_update_not_overridden_by_filter.<locals>.filter at 0x7fac07c7d480>
writer     = <function writer.<locals>.w at 0x7fac07c7e170>

tests/test_opt.py:581: AttributeError
</pre>
</details>
<h3 id="test_optpytest_message_update_not_overridden_by_filterfalse">test_opt.py::test_message_update_not_overridden_by_filter[False]</h3>
<details><summary> <pre>test_opt.py::test_message_update_not_overridden_by_filter[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7d2d0>, colors = False

    @pytest.mark.parametrize("colors", [True, False])
    def test_message_update_not_overridden_by_filter(writer, colors):
        def filter(record):
            record["message"] += " [Filtered]"
            return True

        logger.add(writer, format="{level} {message}", filter=filter, colorize=True)
>       logger.opt(colors=colors).info("Message")
E       AttributeError: 'NoneType' object has no attribute 'info'

colors     = False
filter     = <function test_message_update_not_overridden_by_filter.<locals>.filter at 0x7fac07c7e3b0>
writer     = <function writer.<locals>.w at 0x7fac07c7d2d0>

tests/test_opt.py:581: AttributeError
</pre>
</details>
<h3 id="test_optpytest_message_update_not_overridden_by_rawtrue">test_opt.py::test_message_update_not_overridden_by_raw[True]</h3>
<details><summary> <pre>test_opt.py::test_message_update_not_overridden_by_raw[True]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7dd80>, colors = True

    @pytest.mark.parametrize("colors", [True, False])
    def test_message_update_not_overridden_by_raw(writer, colors):
        logger.add(writer, colorize=True)
>       logger.patch(lambda r: r.update(message="Updated!")).opt(raw=True, colors=colors).info("Raw!")
E       AttributeError: 'NoneType' object has no attribute 'opt'

colors     = True
writer     = <function writer.<locals>.w at 0x7fac07c7dd80>

tests/test_opt.py:589: AttributeError
</pre>
</details>
<h3 id="test_optpytest_message_update_not_overridden_by_rawfalse">test_opt.py::test_message_update_not_overridden_by_raw[False]</h3>
<details><summary> <pre>test_opt.py::test_message_update_not_overridden_by_raw[False]</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7fbe0>, colors = False

    @pytest.mark.parametrize("colors", [True, False])
    def test_message_update_not_overridden_by_raw(writer, colors):
        logger.add(writer, colorize=True)
>       logger.patch(lambda r: r.update(message="Updated!")).opt(raw=True, colors=colors).info("Raw!")
E       AttributeError: 'NoneType' object has no attribute 'opt'

colors     = False
writer     = <function writer.<locals>.w at 0x7fac07c7fbe0>

tests/test_opt.py:589: AttributeError
</pre>
</details>
<h3 id="test_optpytest_overridden_message_ignore_colors">test_opt.py::test_overridden_message_ignore_colors</h3>
<details><summary> <pre>test_opt.py::test_overridden_message_ignore_colors</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07c7e320>

    def test_overridden_message_ignore_colors(writer):
        def formatter(record):
            record["message"] += " <blue>[Ignored]</blue> </xyz>"
            return "{message}\n"

        logger.add(writer, format=formatter, colorize=True)
>       logger.opt(colors=True).info("<red>Message</red>")
E       AttributeError: 'NoneType' object has no attribute 'info'

formatter  = <function test_overridden_message_ignore_colors.<locals>.formatter at 0x7fac07c7f910>
writer     = <function writer.<locals>.w at 0x7fac07c7e320>

tests/test_opt.py:599: AttributeError
</pre>
</details>
<h3 id="test_parsepytest_parse_file">test_parse.py::test_parse_file</h3>
<details><summary> <pre>test_parse.py::test_parse_file</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_parse_file0')

    def test_parse_file(tmp_path):
        file = tmp_path / "test.log"
        file.write_text(TEXT)
>       result, *_ = list(logger.parse(file, r"(?P<num>\d+)"))
E       TypeError: 'NoneType' object is not iterable

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_parse_file0/test.log')
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_parse_file0')

tests/test_parse.py:22: TypeError
</pre>
</details>
<h3 id="test_parsepytest_parse_fileobj">test_parse.py::test_parse_fileobj</h3>
<details><summary> <pre>test_parse.py::test_parse_fileobj</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_parse_fileobj0')

    def test_parse_fileobj(tmp_path):
        file = tmp_path / "test.log"
        file.write_text(TEXT)
>       result, *_ = list(logger.parse(open(str(file)), r"^(?P<t>\w+)"))
E       TypeError: 'NoneType' object is not iterable

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_parse_fileobj0/test.log')
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_parse_fileobj0')

tests/test_parse.py:29: TypeError
</pre>
</details>
<h3 id="test_parsepytest_parse_pathlib">test_parse.py::test_parse_pathlib</h3>
<details><summary> <pre>test_parse.py::test_parse_pathlib</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_parse_pathlib0')

    def test_parse_pathlib(tmp_path):
        file = tmp_path / "test.log"
        file.write_text(TEXT)
>       result, *_ = list(logger.parse(pathlib.Path(str(file)), r"(?P<r>Random)"))
E       TypeError: 'NoneType' object is not iterable

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_parse_pathlib0/test.log')
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_parse_pathlib0')

tests/test_parse.py:36: TypeError
</pre>
</details>
<h3 id="test_parsepytest_parse_string_pattern">test_parse.py::test_parse_string_pattern</h3>
<details><summary> <pre>test_parse.py::test_parse_string_pattern</pre></summary><pre>
fileobj = <_io.StringIO object at 0x7fac07b889d0>

    def test_parse_string_pattern(fileobj):
>       result, *_ = list(logger.parse(fileobj, r"(?P<num>\d+)"))
E       TypeError: 'NoneType' object is not iterable

fileobj    = <_io.StringIO object at 0x7fac07b889d0>

tests/test_parse.py:41: TypeError
</pre>
</details>
<h3 id="test_parsepytest_parse_regex_pattern">test_parse.py::test_parse_regex_pattern</h3>
<details><summary> <pre>test_parse.py::test_parse_regex_pattern</pre></summary><pre>
fileobj = <_io.StringIO object at 0x7fac07b89e10>

    def test_parse_regex_pattern(fileobj):
        regex = re.compile(r"(?P<maj>[a-z]*![a-z]*)", flags=re.I)
>       result, *_ = list(logger.parse(fileobj, regex))
E       TypeError: 'NoneType' object is not iterable

fileobj    = <_io.StringIO object at 0x7fac07b89e10>
regex      = re.compile('(?P<maj>[a-z]*![a-z]*)', re.IGNORECASE)

tests/test_parse.py:47: TypeError
</pre>
</details>
<h3 id="test_parsepytest_parse_multiline_pattern">test_parse.py::test_parse_multiline_pattern</h3>
<details><summary> <pre>test_parse.py::test_parse_multiline_pattern</pre></summary><pre>
fileobj = <_io.StringIO object at 0x7fac07b892d0>

    def test_parse_multiline_pattern(fileobj):
>       result, *_ = list(logger.parse(fileobj, r"(?P<text>This[\s\S]*Text\n)"))
E       TypeError: 'NoneType' object is not iterable

fileobj    = <_io.StringIO object at 0x7fac07b892d0>

tests/test_parse.py:52: TypeError
</pre>
</details>
<h3 id="test_parsepytest_parse_without_group">test_parse.py::test_parse_without_group</h3>
<details><summary> <pre>test_parse.py::test_parse_without_group</pre></summary><pre>
fileobj = <_io.StringIO object at 0x7fac07b89240>

    def test_parse_without_group(fileobj):
>       result, *_ = list(logger.parse(fileobj, r"\d+"))
E       TypeError: 'NoneType' object is not iterable

fileobj    = <_io.StringIO object at 0x7fac07b89240>

tests/test_parse.py:57: TypeError
</pre>
</details>
<h3 id="test_parsepytest_parse_bytes">test_parse.py::test_parse_bytes</h3>
<details><summary> <pre>test_parse.py::test_parse_bytes</pre></summary><pre>
def test_parse_bytes():
        with io.BytesIO(b"Testing bytes!") as fileobj:
>           result, *_ = list(logger.parse(fileobj, rb"(?P<ponct>[?!:])"))
E           TypeError: 'NoneType' object is not iterable

fileobj    = <_io.BytesIO object at 0x7fac07b958a0>

tests/test_parse.py:63: TypeError
</pre>
</details>
<h3 id="test_parsepytest_chunk-1">test_parse.py::test_chunk[-1]</h3>
<details><summary> <pre>test_parse.py::test_chunk[-1]</pre></summary><pre>
fileobj = <_io.StringIO object at 0x7fac07b89750>, chunk = -1

    @pytest.mark.parametrize("chunk", [-1, 1, 2**16])
    def test_chunk(fileobj, chunk):
>       result, *_ = list(logger.parse(fileobj, r"(?P<a>[ABC]+)", chunk=chunk))
E       TypeError: 'NoneType' object is not iterable

chunk      = -1
fileobj    = <_io.StringIO object at 0x7fac07b89750>

tests/test_parse.py:69: TypeError
</pre>
</details>
<h3 id="test_parsepytest_chunk1">test_parse.py::test_chunk[1]</h3>
<details><summary> <pre>test_parse.py::test_chunk[1]</pre></summary><pre>
fileobj = <_io.StringIO object at 0x7fac07b89990>, chunk = 1

    @pytest.mark.parametrize("chunk", [-1, 1, 2**16])
    def test_chunk(fileobj, chunk):
>       result, *_ = list(logger.parse(fileobj, r"(?P<a>[ABC]+)", chunk=chunk))
E       TypeError: 'NoneType' object is not iterable

chunk      = 1
fileobj    = <_io.StringIO object at 0x7fac07b89990>

tests/test_parse.py:69: TypeError
</pre>
</details>
<h3 id="test_parsepytest_chunk65536">test_parse.py::test_chunk[65536]</h3>
<details><summary> <pre>test_parse.py::test_chunk[65536]</pre></summary><pre>
fileobj = <_io.StringIO object at 0x7fac07b89510>, chunk = 65536

    @pytest.mark.parametrize("chunk", [-1, 1, 2**16])
    def test_chunk(fileobj, chunk):
>       result, *_ = list(logger.parse(fileobj, r"(?P<a>[ABC]+)", chunk=chunk))
E       TypeError: 'NoneType' object is not iterable

chunk      = 65536
fileobj    = <_io.StringIO object at 0x7fac07b89510>

tests/test_parse.py:69: TypeError
</pre>
</details>
<h3 id="test_parsepytest_positive_lookbehind_pattern">test_parse.py::test_positive_lookbehind_pattern</h3>
<details><summary> <pre>test_parse.py::test_positive_lookbehind_pattern</pre></summary><pre>
def test_positive_lookbehind_pattern():
        text = "ab" * 100
        pattern = r"(?<=a)(?P<b>b)"
        with io.StringIO(text) as file:
>           result = list(logger.parse(file, pattern, chunk=9))
E           TypeError: 'NoneType' object is not iterable

file       = <_io.StringIO object at 0x7fac07b89c60>
pattern    = '(?<=a)(?P<b>b)'
text       = 'abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababab'

tests/test_parse.py:77: TypeError
</pre>
</details>
<h3 id="test_parsepytest_greedy_pattern">test_parse.py::test_greedy_pattern</h3>
<details><summary> <pre>test_parse.py::test_greedy_pattern</pre></summary><pre>
def test_greedy_pattern():
        text = ("\n" + "a" * 100) * 1000
        pattern = r"\n(?P<a>a+)"
        with io.StringIO(text) as file:
>           result = list(logger.parse(file, pattern, chunk=30))
E           TypeError: 'NoneType' object is not iterable

file       = <_io.StringIO object at 0x7fac07b89240>
pattern    = '\\n(?P<a>a+)'
text       = '\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\naaaaaaaaaaaaa...aaaaaaaaaaaaaaaa\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'

tests/test_parse.py:85: TypeError
</pre>
</details>
<h3 id="test_parsepytest_cast_dict">test_parse.py::test_cast_dict</h3>
<details><summary> <pre>test_parse.py::test_cast_dict</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_cast_dict0')

    def test_cast_dict(tmp_path):
        file = tmp_path / "test.log"
        file.write_text("[123] [1.1] [2017-03-29 11:11:11]\n")
        regex = r"\[(?P<num>.*)\] \[(?P<val>.*)\] \[(?P<date>.*)\]"
        caster = dict(num=int, val=float, date=lambda d: datetime.strptime(d, "%Y-%m-%d %H:%M:%S"))
>       result = next(logger.parse(file, regex, cast=caster))
E       TypeError: 'NoneType' object is not an iterator

caster     = {'date': <function test_cast_dict.<locals>.<lambda> at 0x7fac07b892d0>, 'num': <class 'int'>, 'val': <class 'float'>}
file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_cast_dict0/test.log')
regex      = '\\[(?P<num>.*)\\] \\[(?P<val>.*)\\] \\[(?P<date>.*)\\]'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_cast_dict0')

tests/test_parse.py:94: TypeError
</pre>
</details>
<h3 id="test_parsepytest_cast_function">test_parse.py::test_cast_function</h3>
<details><summary> <pre>test_parse.py::test_cast_function</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_cast_function0')

    def test_cast_function(tmp_path):
        file = tmp_path / "test.log"
        file.write_text("[123] [1.1] [2017-03-29 11:11:11]\n")
        regex = r"\[(?P<num>.*)\] \[(?P<val>.*)\] \[(?P<date>.*)\]"

        def caster(groups):
            groups["num"] = int(groups["num"])
            groups["val"] = float(groups["val"])
            groups["date"] = datetime.strptime(groups["date"], "%Y-%m-%d %H:%M:%S")

>       result = next(logger.parse(file, regex, cast=caster))
E       TypeError: 'NoneType' object is not an iterator

caster     = <function test_cast_function.<locals>.caster at 0x7fac07c7db40>
file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_cast_function0/test.log')
regex      = '\\[(?P<num>.*)\\] \\[(?P<val>.*)\\] \\[(?P<date>.*)\\]'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_cast_function0')

tests/test_parse.py:108: TypeError
</pre>
</details>
<h3 id="test_parsepytest_cast_with_irrelevant_arg">test_parse.py::test_cast_with_irrelevant_arg</h3>
<details><summary> <pre>test_parse.py::test_cast_with_irrelevant_arg</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_cast_with_irrelevant_arg0')

    def test_cast_with_irrelevant_arg(tmp_path):
        file = tmp_path / "test.log"
        file.write_text("[123] Blabla")
        regex = r"\[(?P<a>\d+)\] .*"
        caster = dict(a=int, b=float)
>       result = next(logger.parse(file, regex, cast=caster))
E       TypeError: 'NoneType' object is not an iterator

caster     = {'a': <class 'int'>, 'b': <class 'float'>}
file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_cast_with_irrelevant_arg0/test.log')
regex      = '\\[(?P<a>\\d+)\\] .*'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_cast_with_irrelevant_arg0')

tests/test_parse.py:117: TypeError
</pre>
</details>
<h3 id="test_parsepytest_cast_with_irrelevant_value">test_parse.py::test_cast_with_irrelevant_value</h3>
<details><summary> <pre>test_parse.py::test_cast_with_irrelevant_value</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_cast_with_irrelevant_valu0')

    def test_cast_with_irrelevant_value(tmp_path):
        file = tmp_path / "test.log"
        file.write_text("[123] Blabla")
        regex = r"\[(?P<a>\d+)\] (?P<b>.*)"
        caster = dict(a=int)
>       result = next(logger.parse(file, regex, cast=caster))
E       TypeError: 'NoneType' object is not an iterator

caster     = {'a': <class 'int'>}
file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_cast_with_irrelevant_valu0/test.log')
regex      = '\\[(?P<a>\\d+)\\] (?P<b>.*)'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_cast_with_irrelevant_valu0')

tests/test_parse.py:126: TypeError
</pre>
</details>
<h3 id="test_patchpytest_patch_after_add">test_patch.py::test_patch_after_add</h3>
<details><summary> <pre>test_patch.py::test_patch_after_add</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07b89bd0>

    def test_patch_after_add(writer):
        logger.add(writer, format="{extra[a]} {message}")
        logger_patched = logger.patch(lambda r: r["extra"].update(a=0))
>       logger_patched.debug("A")
E       AttributeError: 'NoneType' object has no attribute 'debug'

logger_patched = None
writer     = <function writer.<locals>.w at 0x7fac07b89bd0>

tests/test_patch.py:7: AttributeError
</pre>
</details>
<h3 id="test_patchpytest_patch_before_add">test_patch.py::test_patch_before_add</h3>
<details><summary> <pre>test_patch.py::test_patch_before_add</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07b897e0>

    def test_patch_before_add(writer):
        logger_patched = logger.patch(lambda r: r["extra"].update(a=0))
        logger.add(writer, format="{extra[a]} {message}")
>       logger_patched.debug("A")
E       AttributeError: 'NoneType' object has no attribute 'debug'

logger_patched = None
writer     = <function writer.<locals>.w at 0x7fac07b897e0>

tests/test_patch.py:15: AttributeError
</pre>
</details>
<h3 id="test_patchpytest_add_using_patched">test_patch.py::test_add_using_patched</h3>
<details><summary> <pre>test_patch.py::test_add_using_patched</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07b89360>

    def test_add_using_patched(writer):
        logger.configure(patcher=lambda r: r["extra"].update(a=-1))
        logger_patched = logger.patch(lambda r: r["extra"].update(a=0))
>       logger_patched.add(writer, format="{extra[a]} {message}")
E       AttributeError: 'NoneType' object has no attribute 'add'

logger_patched = None
writer     = <function writer.<locals>.w at 0x7fac07b89360>

tests/test_patch.py:23: AttributeError
</pre>
</details>
<h3 id="test_patchpytest_not_override_parent_logger">test_patch.py::test_not_override_parent_logger</h3>
<details><summary> <pre>test_patch.py::test_not_override_parent_logger</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07b89cf0>

    def test_not_override_parent_logger(writer):
        logger_1 = logger.patch(lambda r: r["extra"].update(a="a"))
>       logger_2 = logger_1.patch(lambda r: r["extra"].update(a="A"))
E       AttributeError: 'NoneType' object has no attribute 'patch'

logger_1   = None
writer     = <function writer.<locals>.w at 0x7fac07b89cf0>

tests/test_patch.py:32: AttributeError
</pre>
</details>
<h3 id="test_patchpytest_override_previous_patched">test_patch.py::test_override_previous_patched</h3>
<details><summary> <pre>test_patch.py::test_override_previous_patched</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07b8a0e0>

    def test_override_previous_patched(writer):
        logger.add(writer, format="{extra[x]} {message}")
        logger2 = logger.patch(lambda r: r["extra"].update(x=3))
>       logger2.patch(lambda r: r["extra"].update(x=2)).debug("4")
E       AttributeError: 'NoneType' object has no attribute 'patch'

logger2    = None
writer     = <function writer.<locals>.w at 0x7fac07b8a0e0>

tests/test_patch.py:44: AttributeError
</pre>
</details>
<h3 id="test_patchpytest_no_conflict">test_patch.py::test_no_conflict</h3>
<details><summary> <pre>test_patch.py::test_no_conflict</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07b8a320>

    def test_no_conflict(writer):
        logger_ = logger.patch(lambda r: None)
>       logger_2 = logger_.patch(lambda r: r["extra"].update(a=2))
E       AttributeError: 'NoneType' object has no attribute 'patch'

logger_    = None
writer     = <function writer.<locals>.w at 0x7fac07b8a320>

tests/test_patch.py:50: AttributeError
</pre>
</details>
<h3 id="test_patchpytest_override_configured">test_patch.py::test_override_configured</h3>
<details><summary> <pre>test_patch.py::test_override_configured</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07b88d30>

    def test_override_configured(writer):
        logger.configure(patcher=lambda r: r["extra"].update(a=123, b=678))
        logger2 = logger.patch(lambda r: r["extra"].update(a=456))

>       logger2.add(writer, format="{extra[a]} {extra[b]} {message}")
E       AttributeError: 'NoneType' object has no attribute 'add'

logger2    = None
writer     = <function writer.<locals>.w at 0x7fac07b88d30>

tests/test_patch.py:65: AttributeError
</pre>
</details>
<h3 id="test_patchpytest_multiple_patches">test_patch.py::test_multiple_patches</h3>
<details><summary> <pre>test_patch.py::test_multiple_patches</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac07b89cf0>

    def test_multiple_patches(writer):
        def patch_1(record):
            record["extra"]["a"] = 5

        def patch_2(record):
            record["extra"]["a"] += 1

        def patch_3(record):
            record["extra"]["a"] *= 2

        logger.add(writer, format="{extra[a]} {message}")
>       logger.patch(patch_1).patch(patch_2).patch(patch_3).info("Test")
E       AttributeError: 'NoneType' object has no attribute 'patch'

patch_1    = <function test_multiple_patches.<locals>.patch_1 at 0x7fac07b8a290>
patch_2    = <function test_multiple_patches.<locals>.patch_2 at 0x7fac07b8a050>
patch_3    = <function test_multiple_patches.<locals>.patch_3 at 0x7fac07b89f30>
writer     = <function writer.<locals>.w at 0x7fac07b89cf0>

tests/test_patch.py:83: AttributeError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_function_handler">test_pickling.py::test_pickling_function_handler</h3>
<details><summary> <pre>test_pickling.py::test_pickling_function_handler</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac08176e00>

    def test_pickling_function_handler(capsys):
        logger.add(print_, format="{level} - {function} - {message}")
        pickled = pickle.dumps(logger)
        unpikcled = pickle.loads(pickled)
        unpikcled.debug("A message")
        out, err = capsys.readouterr()
>       assert out == "DEBUG - test_pickling_function_handler - A message\n"
E       AssertionError: assert '' == 'DEBUG - test...- A message\n'
E         
E         - DEBUG - test_pickling_function_handler - A message

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac08176e00>
err        = ''
out        = ''
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
unpikcled  = <loguru.logger handlers=[]>

tests/test_pickling.py:88: AssertionError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_coroutine_function_handler">test_pickling.py::test_pickling_coroutine_function_handler</h3>
<details><summary> <pre>test_pickling.py::test_pickling_coroutine_function_handler</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac081deb00>

    def test_pickling_coroutine_function_handler(capsys):
        logger.add(async_print, format="{level} - {function} - {message}")
        pickled = pickle.dumps(logger)
        unpikcled = pickle.loads(pickled)

        async def async_debug():
            unpikcled.debug("A message")
            await unpikcled.complete()

>       asyncio.run(async_debug())

async_debug = <function test_pickling_coroutine_function_handler.<locals>.async_debug at 0x7fac07b88310>
capsys     = <_pytest.capture.CaptureFixture object at 0x7fac081deb00>
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
unpikcled  = <loguru.logger handlers=[]>

tests/test_pickling.py:101: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/asyncio/runners.py:44: in run
    return loop.run_until_complete(main)
        debug      = None
        loop       = <_UnixSelectorEventLoop running=False closed=True debug=False>
        main       = <coroutine object test_pickling_coroutine_function_handler.<locals>.async_debug at 0x7fac077289e0>
/usr/lib/python3.10/asyncio/base_events.py:649: in run_until_complete
    return future.result()
        future     = <Task finished name='Task-170' coro=<test_pickling_coroutine_function_handler.<locals>.async_debug() done, defined at /testbed/tests/test_pickling.py:97> exception=TypeError("object NoneType can't be used in 'await' expression")>
        new_task   = True
        self       = <_UnixSelectorEventLoop running=False closed=True debug=False>
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    async def async_debug():
        unpikcled.debug("A message")
>       await unpikcled.complete()
E       TypeError: object NoneType can't be used in 'await' expression

unpikcled  = <loguru.logger handlers=[]>

tests/test_pickling.py:99: TypeError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_stream_handlertrue-true">test_pickling.py::test_pickling_stream_handler[True-True]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_stream_handler[True-True]</pre></summary><pre>
flushable = True, stoppable = True

    @pytest.mark.parametrize("flushable", [True, False])
    @pytest.mark.parametrize("stoppable", [True, False])
    def test_pickling_stream_handler(flushable, stoppable):
        stream = StreamHandler(flushable, stoppable)
        i = logger.add(stream, format="{level} - {function} - {message}")
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.debug("A message")
>       stream = next(iter(unpickled._core.handlers.values()))._sink._stream
E       StopIteration

flushable  = True
i          = None
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
stoppable  = True
stream     = <tests.test_pickling.StreamHandler object at 0x7fac0bbaf8e0>
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:116: StopIteration

The above exception was the direct cause of the following exception:

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x7fac07cbaa70>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: TResult | None = func()

cls        = <class '_pytest.runner.CallInfo'>
duration   = 0.00027429400000045234
excinfo    = <ExceptionInfo RuntimeError('generator raised StopIteration') tblen=18>
func       = <function call_and_report.<locals>.<lambda> at 0x7fac07cbaa70>
precise_start = 46.496134872
precise_stop = 46.496409166
reraise    = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)
result     = None
start      = 1732854845.8621302
stop       = 1732854845.862405
when       = 'call'

.venv/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.10/site-packages/_pytest/runner.py:242: in <lambda>
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
        item       = <Function test_pickling_stream_handler[True-True]>
        kwds       = {}
        runtest_hook = <HookCaller 'pytest_runtest_call'>
.venv/lib/python3.10/site-packages/pluggy/_hooks.py:513: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
        firstresult = False
        kwargs     = {'item': <Function test_pickling_stream_handler[True-True]>}
        self       = <HookCaller 'pytest_runtest_call'>
.venv/lib/python3.10/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
        firstresult = False
        hook_name  = 'pytest_runtest_call'
        kwargs     = {'item': <Function test_pickling_stream_handler[True-True]>}
        methods    = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/testbed/.venv/lib/python3.10/site-packages/_py...'_pytest.unraisableexception' from '/testbed/.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py'>>, ...]
        self       = <_pytest.config.PytestPluginManager object at 0x7fac0d1fcd00>
.venv/lib/python3.10/site-packages/_pytest/threadexception.py:92: in pytest_runtest_call
    yield from thread_exception_runtest_hook()
.venv/lib/python3.10/site-packages/_pytest/threadexception.py:68: in thread_exception_runtest_hook
    yield
        cm         = <_pytest.threadexception.catch_threading_exception object at 0x7fac0bbadf60>
.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:95: in pytest_runtest_call
    yield from unraisable_exception_runtest_hook()
.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:70: in unraisable_exception_runtest_hook
    yield
        cm         = <_pytest.unraisableexception.catch_unraisable_exception object at 0x7fac0bbae1d0>
.venv/lib/python3.10/site-packages/_pytest/logging.py:846: in pytest_runtest_call
    yield from self._runtest_for(item, "call")
        item       = <Function test_pickling_stream_handler[True-True]>
        self       = <_pytest.logging.LoggingPlugin object at 0x7fac0cf0a710>
.venv/lib/python3.10/site-packages/_pytest/logging.py:829: in _runtest_for
    yield
        caplog_handler = <LogCaptureHandler (NOTSET)>
        item       = <Function test_pickling_stream_handler[True-True]>
        log        = ''
        report_handler = <LogCaptureHandler (NOTSET)>
        self       = <_pytest.logging.LoggingPlugin object at 0x7fac0cf0a710>
        when       = 'call'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io....xtIOWrapper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>
item = <Function test_pickling_stream_handler[True-True]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
E           RuntimeError: generator raised StopIteration

item       = <Function test_pickling_stream_handler[True-True]>
self       = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io....xtIOWrapper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>

.venv/lib/python3.10/site-packages/_pytest/capture.py:880: RuntimeError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_stream_handlertrue-false">test_pickling.py::test_pickling_stream_handler[True-False]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_stream_handler[True-False]</pre></summary><pre>
flushable = False, stoppable = True

    @pytest.mark.parametrize("flushable", [True, False])
    @pytest.mark.parametrize("stoppable", [True, False])
    def test_pickling_stream_handler(flushable, stoppable):
        stream = StreamHandler(flushable, stoppable)
        i = logger.add(stream, format="{level} - {function} - {message}")
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.debug("A message")
>       stream = next(iter(unpickled._core.handlers.values()))._sink._stream
E       StopIteration

flushable  = False
i          = None
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
stoppable  = True
stream     = <tests.test_pickling.StreamHandler object at 0x7fac0751f9d0>
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:116: StopIteration

The above exception was the direct cause of the following exception:

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x7fac0759b370>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: TResult | None = func()

cls        = <class '_pytest.runner.CallInfo'>
duration   = 0.00025117199999868944
excinfo    = <ExceptionInfo RuntimeError('generator raised StopIteration') tblen=18>
func       = <function call_and_report.<locals>.<lambda> at 0x7fac0759b370>
precise_start = 46.548445134
precise_stop = 46.548696306
reraise    = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)
result     = None
start      = 1732854845.9144404
stop       = 1732854845.9146922
when       = 'call'

.venv/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.10/site-packages/_pytest/runner.py:242: in <lambda>
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
        item       = <Function test_pickling_stream_handler[True-False]>
        kwds       = {}
        runtest_hook = <HookCaller 'pytest_runtest_call'>
.venv/lib/python3.10/site-packages/pluggy/_hooks.py:513: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
        firstresult = False
        kwargs     = {'item': <Function test_pickling_stream_handler[True-False]>}
        self       = <HookCaller 'pytest_runtest_call'>
.venv/lib/python3.10/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
        firstresult = False
        hook_name  = 'pytest_runtest_call'
        kwargs     = {'item': <Function test_pickling_stream_handler[True-False]>}
        methods    = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/testbed/.venv/lib/python3.10/site-packages/_py...'_pytest.unraisableexception' from '/testbed/.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py'>>, ...]
        self       = <_pytest.config.PytestPluginManager object at 0x7fac0d1fcd00>
.venv/lib/python3.10/site-packages/_pytest/threadexception.py:92: in pytest_runtest_call
    yield from thread_exception_runtest_hook()
.venv/lib/python3.10/site-packages/_pytest/threadexception.py:68: in thread_exception_runtest_hook
    yield
        cm         = <_pytest.threadexception.catch_threading_exception object at 0x7fac0751fb20>
.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:95: in pytest_runtest_call
    yield from unraisable_exception_runtest_hook()
.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:70: in unraisable_exception_runtest_hook
    yield
        cm         = <_pytest.unraisableexception.catch_unraisable_exception object at 0x7fac0751fc10>
.venv/lib/python3.10/site-packages/_pytest/logging.py:846: in pytest_runtest_call
    yield from self._runtest_for(item, "call")
        item       = <Function test_pickling_stream_handler[True-False]>
        self       = <_pytest.logging.LoggingPlugin object at 0x7fac0cf0a710>
.venv/lib/python3.10/site-packages/_pytest/logging.py:829: in _runtest_for
    yield
        caplog_handler = <LogCaptureHandler (NOTSET)>
        item       = <Function test_pickling_stream_handler[True-False]>
        log        = ''
        report_handler = <LogCaptureHandler (NOTSET)>
        self       = <_pytest.logging.LoggingPlugin object at 0x7fac0cf0a710>
        when       = 'call'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io....xtIOWrapper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>
item = <Function test_pickling_stream_handler[True-False]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
E           RuntimeError: generator raised StopIteration

item       = <Function test_pickling_stream_handler[True-False]>
self       = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io....xtIOWrapper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>

.venv/lib/python3.10/site-packages/_pytest/capture.py:880: RuntimeError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_stream_handlerfalse-true">test_pickling.py::test_pickling_stream_handler[False-True]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_stream_handler[False-True]</pre></summary><pre>
flushable = True, stoppable = False

    @pytest.mark.parametrize("flushable", [True, False])
    @pytest.mark.parametrize("stoppable", [True, False])
    def test_pickling_stream_handler(flushable, stoppable):
        stream = StreamHandler(flushable, stoppable)
        i = logger.add(stream, format="{level} - {function} - {message}")
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.debug("A message")
>       stream = next(iter(unpickled._core.handlers.values()))._sink._stream
E       StopIteration

flushable  = True
i          = None
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
stoppable  = False
stream     = <tests.test_pickling.StreamHandler object at 0x7fac08714220>
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:116: StopIteration

The above exception was the direct cause of the following exception:

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x7fac07b8af80>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: TResult | None = func()

cls        = <class '_pytest.runner.CallInfo'>
duration   = 0.0002406549999989238
excinfo    = <ExceptionInfo RuntimeError('generator raised StopIteration') tblen=18>
func       = <function call_and_report.<locals>.<lambda> at 0x7fac07b8af80>
precise_start = 46.59530823
precise_stop = 46.595548885
reraise    = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)
result     = None
start      = 1732854845.9613035
stop       = 1732854845.9615448
when       = 'call'

.venv/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.10/site-packages/_pytest/runner.py:242: in <lambda>
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
        item       = <Function test_pickling_stream_handler[False-True]>
        kwds       = {}
        runtest_hook = <HookCaller 'pytest_runtest_call'>
.venv/lib/python3.10/site-packages/pluggy/_hooks.py:513: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
        firstresult = False
        kwargs     = {'item': <Function test_pickling_stream_handler[False-True]>}
        self       = <HookCaller 'pytest_runtest_call'>
.venv/lib/python3.10/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
        firstresult = False
        hook_name  = 'pytest_runtest_call'
        kwargs     = {'item': <Function test_pickling_stream_handler[False-True]>}
        methods    = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/testbed/.venv/lib/python3.10/site-packages/_py...'_pytest.unraisableexception' from '/testbed/.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py'>>, ...]
        self       = <_pytest.config.PytestPluginManager object at 0x7fac0d1fcd00>
.venv/lib/python3.10/site-packages/_pytest/threadexception.py:92: in pytest_runtest_call
    yield from thread_exception_runtest_hook()
.venv/lib/python3.10/site-packages/_pytest/threadexception.py:68: in thread_exception_runtest_hook
    yield
        cm         = <_pytest.threadexception.catch_threading_exception object at 0x7fac08715d50>
.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:95: in pytest_runtest_call
    yield from unraisable_exception_runtest_hook()
.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:70: in unraisable_exception_runtest_hook
    yield
        cm         = <_pytest.unraisableexception.catch_unraisable_exception object at 0x7fac08716b00>
.venv/lib/python3.10/site-packages/_pytest/logging.py:846: in pytest_runtest_call
    yield from self._runtest_for(item, "call")
        item       = <Function test_pickling_stream_handler[False-True]>
        self       = <_pytest.logging.LoggingPlugin object at 0x7fac0cf0a710>
.venv/lib/python3.10/site-packages/_pytest/logging.py:829: in _runtest_for
    yield
        caplog_handler = <LogCaptureHandler (NOTSET)>
        item       = <Function test_pickling_stream_handler[False-True]>
        log        = ''
        report_handler = <LogCaptureHandler (NOTSET)>
        self       = <_pytest.logging.LoggingPlugin object at 0x7fac0cf0a710>
        when       = 'call'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io....xtIOWrapper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>
item = <Function test_pickling_stream_handler[False-True]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
E           RuntimeError: generator raised StopIteration

item       = <Function test_pickling_stream_handler[False-True]>
self       = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io....xtIOWrapper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>

.venv/lib/python3.10/site-packages/_pytest/capture.py:880: RuntimeError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_stream_handlerfalse-false">test_pickling.py::test_pickling_stream_handler[False-False]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_stream_handler[False-False]</pre></summary><pre>
flushable = False, stoppable = False

    @pytest.mark.parametrize("flushable", [True, False])
    @pytest.mark.parametrize("stoppable", [True, False])
    def test_pickling_stream_handler(flushable, stoppable):
        stream = StreamHandler(flushable, stoppable)
        i = logger.add(stream, format="{level} - {function} - {message}")
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.debug("A message")
>       stream = next(iter(unpickled._core.handlers.values()))._sink._stream
E       StopIteration

flushable  = False
i          = None
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
stoppable  = False
stream     = <tests.test_pickling.StreamHandler object at 0x7fac077bcee0>
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:116: StopIteration

The above exception was the direct cause of the following exception:

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x7fac07c7e7a0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: TResult | None = func()

cls        = <class '_pytest.runner.CallInfo'>
duration   = 0.00027053899999884834
excinfo    = <ExceptionInfo RuntimeError('generator raised StopIteration') tblen=18>
func       = <function call_and_report.<locals>.<lambda> at 0x7fac07c7e7a0>
precise_start = 46.677860004
precise_stop = 46.678130543
reraise    = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)
result     = None
start      = 1732854846.0438552
stop       = 1732854846.0441265
when       = 'call'

.venv/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.10/site-packages/_pytest/runner.py:242: in <lambda>
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
        item       = <Function test_pickling_stream_handler[False-False]>
        kwds       = {}
        runtest_hook = <HookCaller 'pytest_runtest_call'>
.venv/lib/python3.10/site-packages/pluggy/_hooks.py:513: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
        firstresult = False
        kwargs     = {'item': <Function test_pickling_stream_handler[False-False]>}
        self       = <HookCaller 'pytest_runtest_call'>
.venv/lib/python3.10/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
        firstresult = False
        hook_name  = 'pytest_runtest_call'
        kwargs     = {'item': <Function test_pickling_stream_handler[False-False]>}
        methods    = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/testbed/.venv/lib/python3.10/site-packages/_py...'_pytest.unraisableexception' from '/testbed/.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py'>>, ...]
        self       = <_pytest.config.PytestPluginManager object at 0x7fac0d1fcd00>
.venv/lib/python3.10/site-packages/_pytest/threadexception.py:92: in pytest_runtest_call
    yield from thread_exception_runtest_hook()
.venv/lib/python3.10/site-packages/_pytest/threadexception.py:68: in thread_exception_runtest_hook
    yield
        cm         = <_pytest.threadexception.catch_threading_exception object at 0x7fac077bcf10>
.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:95: in pytest_runtest_call
    yield from unraisable_exception_runtest_hook()
.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:70: in unraisable_exception_runtest_hook
    yield
        cm         = <_pytest.unraisableexception.catch_unraisable_exception object at 0x7fac077bc9a0>
.venv/lib/python3.10/site-packages/_pytest/logging.py:846: in pytest_runtest_call
    yield from self._runtest_for(item, "call")
        item       = <Function test_pickling_stream_handler[False-False]>
        self       = <_pytest.logging.LoggingPlugin object at 0x7fac0cf0a710>
.venv/lib/python3.10/site-packages/_pytest/logging.py:829: in _runtest_for
    yield
        caplog_handler = <LogCaptureHandler (NOTSET)>
        item       = <Function test_pickling_stream_handler[False-False]>
        log        = ''
        report_handler = <LogCaptureHandler (NOTSET)>
        self       = <_pytest.logging.LoggingPlugin object at 0x7fac0cf0a710>
        when       = 'call'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io....xtIOWrapper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>
item = <Function test_pickling_stream_handler[False-False]>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
E           RuntimeError: generator raised StopIteration

item       = <Function test_pickling_stream_handler[False-False]>
self       = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io....xtIOWrapper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>

.venv/lib/python3.10/site-packages/_pytest/capture.py:880: RuntimeError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_standard_handler">test_pickling.py::test_pickling_standard_handler</h3>
<details><summary> <pre>test_pickling.py::test_pickling_standard_handler</pre></summary><pre>
def test_pickling_standard_handler():
        handler = StandardHandler(logging.NOTSET)
        logger.add(handler, format="{level} - {function} - {message}")
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.debug("A message")
>       handler = next(iter(unpickled._core.handlers.values()))._sink._handler
E       StopIteration

handler    = <StandardHandler (NOTSET)>
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:129: StopIteration

The above exception was the direct cause of the following exception:

cls = <class '_pytest.runner.CallInfo'>
func = <function call_and_report.<locals>.<lambda> at 0x7fac07b89ea0>
when = 'call'
reraise = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)

    @classmethod
    def from_call(
        cls,
        func: Callable[[], TResult],
        when: Literal["collect", "setup", "call", "teardown"],
        reraise: type[BaseException] | tuple[type[BaseException], ...] | None = None,
    ) -> CallInfo[TResult]:
        """Call func, wrapping the result in a CallInfo.

        :param func:
            The function to call. Called without arguments.
        :type func: Callable[[], _pytest.runner.TResult]
        :param when:
            The phase in which the function is called.
        :param reraise:
            Exception or exceptions that shall propagate if raised by the
            function, instead of being wrapped in the CallInfo.
        """
        excinfo = None
        start = timing.time()
        precise_start = timing.perf_counter()
        try:
>           result: TResult | None = func()

cls        = <class '_pytest.runner.CallInfo'>
duration   = 0.00025703200000037896
excinfo    = <ExceptionInfo RuntimeError('generator raised StopIteration') tblen=18>
func       = <function call_and_report.<locals>.<lambda> at 0x7fac07b89ea0>
precise_start = 46.724548252
precise_stop = 46.724805284
reraise    = (<class '_pytest.outcomes.Exit'>, <class 'KeyboardInterrupt'>)
result     = None
start      = 1732854846.0905433
stop       = 1732854846.0908012
when       = 'call'

.venv/lib/python3.10/site-packages/_pytest/runner.py:341: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.venv/lib/python3.10/site-packages/_pytest/runner.py:242: in <lambda>
    lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
        item       = <Function test_pickling_standard_handler>
        kwds       = {}
        runtest_hook = <HookCaller 'pytest_runtest_call'>
.venv/lib/python3.10/site-packages/pluggy/_hooks.py:513: in __call__
    return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
        firstresult = False
        kwargs     = {'item': <Function test_pickling_standard_handler>}
        self       = <HookCaller 'pytest_runtest_call'>
.venv/lib/python3.10/site-packages/pluggy/_manager.py:120: in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
        firstresult = False
        hook_name  = 'pytest_runtest_call'
        kwargs     = {'item': <Function test_pickling_standard_handler>}
        methods    = [<HookImpl plugin_name='runner', plugin=<module '_pytest.runner' from '/testbed/.venv/lib/python3.10/site-packages/_py...'_pytest.unraisableexception' from '/testbed/.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py'>>, ...]
        self       = <_pytest.config.PytestPluginManager object at 0x7fac0d1fcd00>
.venv/lib/python3.10/site-packages/_pytest/threadexception.py:92: in pytest_runtest_call
    yield from thread_exception_runtest_hook()
.venv/lib/python3.10/site-packages/_pytest/threadexception.py:68: in thread_exception_runtest_hook
    yield
        cm         = <_pytest.threadexception.catch_threading_exception object at 0x7fac083c44f0>
.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:95: in pytest_runtest_call
    yield from unraisable_exception_runtest_hook()
.venv/lib/python3.10/site-packages/_pytest/unraisableexception.py:70: in unraisable_exception_runtest_hook
    yield
        cm         = <_pytest.unraisableexception.catch_unraisable_exception object at 0x7fac083c7760>
.venv/lib/python3.10/site-packages/_pytest/logging.py:846: in pytest_runtest_call
    yield from self._runtest_for(item, "call")
        item       = <Function test_pickling_standard_handler>
        self       = <_pytest.logging.LoggingPlugin object at 0x7fac0cf0a710>
.venv/lib/python3.10/site-packages/_pytest/logging.py:829: in _runtest_for
    yield
        caplog_handler = <LogCaptureHandler (NOTSET)>
        item       = <Function test_pickling_standard_handler>
        log        = ''
        report_handler = <LogCaptureHandler (NOTSET)>
        self       = <_pytest.logging.LoggingPlugin object at 0x7fac0cf0a710>
        when       = 'call'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io....xtIOWrapper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>
item = <Function test_pickling_standard_handler>

    @hookimpl(wrapper=True)
    def pytest_runtest_call(self, item: Item) -> Generator[None]:
        with self.item_capture("call", item):
>           return (yield)
E           RuntimeError: generator raised StopIteration

item       = <Function test_pickling_standard_handler>
self       = <CaptureManager _method='fd' _global_capturing=<MultiCapture out=<FDCapture 1 oldfd=5 _state='suspended' tmpfile=<_io....xtIOWrapper name='/dev/null' mode='r' encoding='utf-8'>> _state='suspended' _in_suspended=False> _capture_fixture=None>

.venv/lib/python3.10/site-packages/_pytest/capture.py:880: RuntimeError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_standard_handler_root_logger_not_picklable">test_pickling.py::test_pickling_standard_handler_root_logger_not_picklable</h3>
<details><summary> <pre>test_pickling.py::test_pickling_standard_handler_root_logger_not_picklable</pre></summary><pre>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac082fc1c0>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac082fdfc0>

    def test_pickling_standard_handler_root_logger_not_picklable(monkeypatch, capsys):
        def reduce_protocol():
            raise TypeError("Not picklable")

        monkeypatch.setattr(logging.getLogger(), "__reduce__", reduce_protocol, raising=False)

        handler = StandardHandler(logging.NOTSET)
        logger.add(handler, format="=> {message}", catch=False)

        pickled = pickle.dumps(logger)
        pickle.loads(pickled)

        logger.info("Ok")
        out, err = capsys.readouterr()
        assert out == ""
        assert err == ""
>       assert handler.written == "=> Ok"
E       AssertionError: assert '' == '=> Ok'
E         
E         - => Ok

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac082fdfc0>
err        = ''
handler    = <StandardHandler (NOTSET)>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7fac082fc1c0>
out        = ''
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
reduce_protocol = <function test_pickling_standard_handler_root_logger_not_picklable.<locals>.reduce_protocol at 0x7fac07b881f0>

tests/test_pickling.py:149: AssertionError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_file_handler">test_pickling.py::test_pickling_file_handler</h3>
<details><summary> <pre>test_pickling.py::test_pickling_file_handler</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler0')

    def test_pickling_file_handler(tmp_path):
        file = tmp_path / "test.log"
        logger.add(file, format="{level} - {function} - {message}", delay=True)
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.debug("A message")
>       assert file.read_text() == "DEBUG - test_pickling_file_handler - A message\n"

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler0/test.log')
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler0')
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler0/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler0/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_pickling_file_handler0/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler0/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_file_handler_rotation1000">test_pickling.py::test_pickling_file_handler_rotation[1000]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_file_handler_rotation[1000]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot0')
rotation = 1000

    @pytest.mark.parametrize(
        "rotation",
        [
            1000,
            "daily",
            datetime.timedelta(minutes=60),
            datetime.time(hour=12, minute=00, second=00),
            "200 MB",
            "10:00",
            "5 hours",
            rotation_function,
        ],
    )
    def test_pickling_file_handler_rotation(tmp_path, rotation):
        file = tmp_path / "test.log"
        logger.add(file, format="{level} - {function} - {message}", delay=True, rotation=rotation)
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.debug("A message")
>       assert file.read_text() == "DEBUG - test_pickling_file_handler_rotation - A message\n"

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot0/test.log')
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
rotation   = 1000
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot0')
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot0/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot0/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot0/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot0/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_file_handler_rotationdaily">test_pickling.py::test_pickling_file_handler_rotation[daily]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_file_handler_rotation[daily]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot1')
rotation = 'daily'

    @pytest.mark.parametrize(
        "rotation",
        [
            1000,
            "daily",
            datetime.timedelta(minutes=60),
            datetime.time(hour=12, minute=00, second=00),
            "200 MB",
            "10:00",
            "5 hours",
            rotation_function,
        ],
    )
    def test_pickling_file_handler_rotation(tmp_path, rotation):
        file = tmp_path / "test.log"
        logger.add(file, format="{level} - {function} - {message}", delay=True, rotation=rotation)
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.debug("A message")
>       assert file.read_text() == "DEBUG - test_pickling_file_handler_rotation - A message\n"

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot1/test.log')
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
rotation   = 'daily'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot1')
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot1/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot1/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot1/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot1/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_file_handler_rotationrotation2">test_pickling.py::test_pickling_file_handler_rotation[rotation2]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_file_handler_rotation[rotation2]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot2')
rotation = datetime.timedelta(seconds=3600)

    @pytest.mark.parametrize(
        "rotation",
        [
            1000,
            "daily",
            datetime.timedelta(minutes=60),
            datetime.time(hour=12, minute=00, second=00),
            "200 MB",
            "10:00",
            "5 hours",
            rotation_function,
        ],
    )
    def test_pickling_file_handler_rotation(tmp_path, rotation):
        file = tmp_path / "test.log"
        logger.add(file, format="{level} - {function} - {message}", delay=True, rotation=rotation)
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.debug("A message")
>       assert file.read_text() == "DEBUG - test_pickling_file_handler_rotation - A message\n"

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot2/test.log')
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
rotation   = datetime.timedelta(seconds=3600)
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot2')
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot2/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot2/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot2/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot2/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_file_handler_rotationrotation3">test_pickling.py::test_pickling_file_handler_rotation[rotation3]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_file_handler_rotation[rotation3]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot3')
rotation = datetime.time(12, 0)

    @pytest.mark.parametrize(
        "rotation",
        [
            1000,
            "daily",
            datetime.timedelta(minutes=60),
            datetime.time(hour=12, minute=00, second=00),
            "200 MB",
            "10:00",
            "5 hours",
            rotation_function,
        ],
    )
    def test_pickling_file_handler_rotation(tmp_path, rotation):
        file = tmp_path / "test.log"
        logger.add(file, format="{level} - {function} - {message}", delay=True, rotation=rotation)
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.debug("A message")
>       assert file.read_text() == "DEBUG - test_pickling_file_handler_rotation - A message\n"

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot3/test.log')
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
rotation   = datetime.time(12, 0)
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot3')
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot3/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot3/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot3/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot3/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_file_handler_rotation200-mb">test_pickling.py::test_pickling_file_handler_rotation[200 MB]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_file_handler_rotation[200 MB]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot4')
rotation = '200 MB'

    @pytest.mark.parametrize(
        "rotation",
        [
            1000,
            "daily",
            datetime.timedelta(minutes=60),
            datetime.time(hour=12, minute=00, second=00),
            "200 MB",
            "10:00",
            "5 hours",
            rotation_function,
        ],
    )
    def test_pickling_file_handler_rotation(tmp_path, rotation):
        file = tmp_path / "test.log"
        logger.add(file, format="{level} - {function} - {message}", delay=True, rotation=rotation)
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.debug("A message")
>       assert file.read_text() == "DEBUG - test_pickling_file_handler_rotation - A message\n"

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot4/test.log')
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
rotation   = '200 MB'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot4')
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot4/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot4/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot4/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot4/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_file_handler_rotation1000_1">test_pickling.py::test_pickling_file_handler_rotation[10:00]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_file_handler_rotation[10:00]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot5')
rotation = '10:00'

    @pytest.mark.parametrize(
        "rotation",
        [
            1000,
            "daily",
            datetime.timedelta(minutes=60),
            datetime.time(hour=12, minute=00, second=00),
            "200 MB",
            "10:00",
            "5 hours",
            rotation_function,
        ],
    )
    def test_pickling_file_handler_rotation(tmp_path, rotation):
        file = tmp_path / "test.log"
        logger.add(file, format="{level} - {function} - {message}", delay=True, rotation=rotation)
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.debug("A message")
>       assert file.read_text() == "DEBUG - test_pickling_file_handler_rotation - A message\n"

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot5/test.log')
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
rotation   = '10:00'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot5')
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot5/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot5/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot5/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot5/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_file_handler_rotation5-hours">test_pickling.py::test_pickling_file_handler_rotation[5 hours]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_file_handler_rotation[5 hours]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot6')
rotation = '5 hours'

    @pytest.mark.parametrize(
        "rotation",
        [
            1000,
            "daily",
            datetime.timedelta(minutes=60),
            datetime.time(hour=12, minute=00, second=00),
            "200 MB",
            "10:00",
            "5 hours",
            rotation_function,
        ],
    )
    def test_pickling_file_handler_rotation(tmp_path, rotation):
        file = tmp_path / "test.log"
        logger.add(file, format="{level} - {function} - {message}", delay=True, rotation=rotation)
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.debug("A message")
>       assert file.read_text() == "DEBUG - test_pickling_file_handler_rotation - A message\n"

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot6/test.log')
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
rotation   = '5 hours'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot6')
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot6/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot6/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot6/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot6/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_file_handler_rotationrotation_function">test_pickling.py::test_pickling_file_handler_rotation[rotation_function]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_file_handler_rotation[rotation_function]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot7')
rotation = <function rotation_function at 0x7fac0ba71a20>

    @pytest.mark.parametrize(
        "rotation",
        [
            1000,
            "daily",
            datetime.timedelta(minutes=60),
            datetime.time(hour=12, minute=00, second=00),
            "200 MB",
            "10:00",
            "5 hours",
            rotation_function,
        ],
    )
    def test_pickling_file_handler_rotation(tmp_path, rotation):
        file = tmp_path / "test.log"
        logger.add(file, format="{level} - {function} - {message}", delay=True, rotation=rotation)
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.debug("A message")
>       assert file.read_text() == "DEBUG - test_pickling_file_handler_rotation - A message\n"

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot7/test.log')
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
rotation   = <function rotation_function at 0x7fac0ba71a20>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot7')
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:180: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot7/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot7/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot7/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_rot7/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_file_handler_retention1000">test_pickling.py::test_pickling_file_handler_retention[1000]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_file_handler_retention[1000]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret0')
retention = 1000

    @pytest.mark.parametrize(
        "retention", [1000, datetime.timedelta(hours=13), "10 days", retention_function]
    )
    def test_pickling_file_handler_retention(tmp_path, retention):
        file = tmp_path / "test.log"
        logger.add(file, format="{level} - {function} - {message}", delay=True, retention=retention)
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.debug("A message")
>       assert file.read_text() == "DEBUG - test_pickling_file_handler_retention - A message\n"

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret0/test.log')
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
retention  = 1000
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret0')
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret0/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret0/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret0/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret0/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_file_handler_retentionretention1">test_pickling.py::test_pickling_file_handler_retention[retention1]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_file_handler_retention[retention1]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret1')
retention = datetime.timedelta(seconds=46800)

    @pytest.mark.parametrize(
        "retention", [1000, datetime.timedelta(hours=13), "10 days", retention_function]
    )
    def test_pickling_file_handler_retention(tmp_path, retention):
        file = tmp_path / "test.log"
        logger.add(file, format="{level} - {function} - {message}", delay=True, retention=retention)
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.debug("A message")
>       assert file.read_text() == "DEBUG - test_pickling_file_handler_retention - A message\n"

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret1/test.log')
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
retention  = datetime.timedelta(seconds=46800)
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret1')
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret1/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret1/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret1/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret1/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_file_handler_retention10-days">test_pickling.py::test_pickling_file_handler_retention[10 days]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_file_handler_retention[10 days]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret2')
retention = '10 days'

    @pytest.mark.parametrize(
        "retention", [1000, datetime.timedelta(hours=13), "10 days", retention_function]
    )
    def test_pickling_file_handler_retention(tmp_path, retention):
        file = tmp_path / "test.log"
        logger.add(file, format="{level} - {function} - {message}", delay=True, retention=retention)
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.debug("A message")
>       assert file.read_text() == "DEBUG - test_pickling_file_handler_retention - A message\n"

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret2/test.log')
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
retention  = '10 days'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret2')
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret2/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret2/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret2/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret2/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_file_handler_retentionretention_function">test_pickling.py::test_pickling_file_handler_retention[retention_function]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_file_handler_retention[retention_function]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret3')
retention = <function retention_function at 0x7fac0ba71ab0>

    @pytest.mark.parametrize(
        "retention", [1000, datetime.timedelta(hours=13), "10 days", retention_function]
    )
    def test_pickling_file_handler_retention(tmp_path, retention):
        file = tmp_path / "test.log"
        logger.add(file, format="{level} - {function} - {message}", delay=True, retention=retention)
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.debug("A message")
>       assert file.read_text() == "DEBUG - test_pickling_file_handler_retention - A message\n"

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret3/test.log')
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
retention  = <function retention_function at 0x7fac0ba71ab0>
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret3')
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret3/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret3/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret3/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_ret3/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_file_handler_compressionzip">test_pickling.py::test_pickling_file_handler_compression[zip]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_file_handler_compression[zip]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com0')
compression = 'zip'

    @pytest.mark.parametrize("compression", ["zip", "gz", "tar", compression_function])
    def test_pickling_file_handler_compression(tmp_path, compression):
        file = tmp_path / "test.log"
        logger.add(file, format="{level} - {function} - {message}", delay=True, compression=compression)
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.debug("A message")
>       assert file.read_text() == "DEBUG - test_pickling_file_handler_compression - A message\n"

compression = 'zip'
file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com0/test.log')
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com0')
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:202: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com0/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com0/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com0/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com0/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_file_handler_compressiongz">test_pickling.py::test_pickling_file_handler_compression[gz]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_file_handler_compression[gz]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com1')
compression = 'gz'

    @pytest.mark.parametrize("compression", ["zip", "gz", "tar", compression_function])
    def test_pickling_file_handler_compression(tmp_path, compression):
        file = tmp_path / "test.log"
        logger.add(file, format="{level} - {function} - {message}", delay=True, compression=compression)
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.debug("A message")
>       assert file.read_text() == "DEBUG - test_pickling_file_handler_compression - A message\n"

compression = 'gz'
file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com1/test.log')
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com1')
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:202: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com1/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com1/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com1/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com1/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_file_handler_compressiontar">test_pickling.py::test_pickling_file_handler_compression[tar]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_file_handler_compression[tar]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com2')
compression = 'tar'

    @pytest.mark.parametrize("compression", ["zip", "gz", "tar", compression_function])
    def test_pickling_file_handler_compression(tmp_path, compression):
        file = tmp_path / "test.log"
        logger.add(file, format="{level} - {function} - {message}", delay=True, compression=compression)
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.debug("A message")
>       assert file.read_text() == "DEBUG - test_pickling_file_handler_compression - A message\n"

compression = 'tar'
file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com2/test.log')
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com2')
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:202: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com2/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com2/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com2/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com2/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_file_handler_compressioncompression_function">test_pickling.py::test_pickling_file_handler_compression[compression_function]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_file_handler_compression[compression_function]</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com3')
compression = <function compression_function at 0x7fac0ba71b40>

    @pytest.mark.parametrize("compression", ["zip", "gz", "tar", compression_function])
    def test_pickling_file_handler_compression(tmp_path, compression):
        file = tmp_path / "test.log"
        logger.add(file, format="{level} - {function} - {message}", delay=True, compression=compression)
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.debug("A message")
>       assert file.read_text() == "DEBUG - test_pickling_file_handler_compression - A message\n"

compression = <function compression_function at 0x7fac0ba71b40>
file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com3/test.log')
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com3')
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:202: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com3/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com3/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com3/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_pickling_file_handler_com3/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_no_handler">test_pickling.py::test_pickling_no_handler</h3>
<details><summary> <pre>test_pickling.py::test_pickling_no_handler</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac077edbd0>

    def test_pickling_no_handler(writer):
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.add(writer, format="{level} - {function} - {message}")
        unpickled.debug("A message")
>       assert writer.read() == "DEBUG - test_pickling_no_handler - A message\n"
E       AssertionError: assert '' == 'DEBUG - test...- A message\n'
E         
E         - DEBUG - test_pickling_no_handler - A message

pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
unpickled  = <loguru.logger handlers=[]>
writer     = <function writer.<locals>.w at 0x7fac077edbd0>

tests/test_pickling.py:210: AssertionError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_handler_not_serializable">test_pickling.py::test_pickling_handler_not_serializable</h3>
<details><summary> <pre>test_pickling.py::test_pickling_handler_not_serializable</pre></summary><pre>
def test_pickling_handler_not_serializable():
        logger.add(lambda m: None)
>       with pytest.raises((pickle.PicklingError, AttributeError), match="Can't (pickle|get local)"):
E       Failed: DID NOT RAISE (<class '_pickle.PicklingError'>, <class 'AttributeError'>)


tests/test_pickling.py:215: Failed
</pre>
</details>
<h3 id="test_picklingpytest_pickling_filter_function">test_pickling.py::test_pickling_filter_function</h3>
<details><summary> <pre>test_pickling.py::test_pickling_filter_function</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac07cface0>

    def test_pickling_filter_function(capsys):
        logger.add(print_, format="{message}", filter=filter_function)
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.info("Nope")
        unpickled.info("[PASS] Yes")
        out, err = capsys.readouterr()
>       assert out == "[PASS] Yes\n"
E       AssertionError: assert '' == '[PASS] Yes\n'
E         
E         - [PASS] Yes

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac07cface0>
err        = ''
out        = ''
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:226: AssertionError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_filter_name">test_pickling.py::test_pickling_filter_name[]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_filter_name[]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0ba867a0>, filter = ''

    @pytest.mark.parametrize("filter", ["", "tests"])
    def test_pickling_filter_name(capsys, filter):
        logger.add(print_, format="{message}", filter=filter)
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.info("A message")
        out, err = capsys.readouterr()
>       assert out == "A message\n"
E       AssertionError: assert '' == 'A message\n'
E         
E         - A message

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0ba867a0>
err        = ''
filter     = ''
out        = ''
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:237: AssertionError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_filter_nametests">test_pickling.py::test_pickling_filter_name[tests]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_filter_name[tests]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0751a860>
filter = 'tests'

    @pytest.mark.parametrize("filter", ["", "tests"])
    def test_pickling_filter_name(capsys, filter):
        logger.add(print_, format="{message}", filter=filter)
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.info("A message")
        out, err = capsys.readouterr()
>       assert out == "A message\n"
E       AssertionError: assert '' == 'A message\n'
E         
E         - A message

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0751a860>
err        = ''
filter     = 'tests'
out        = ''
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:237: AssertionError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_format_stringtrue">test_pickling.py::test_pickling_format_string[True]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_format_string[True]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac07773d90>
colorize = True

    @pytest.mark.parametrize("colorize", [True, False])
    def test_pickling_format_string(capsys, colorize):
        logger.add(print_, format="-> <red>{message}</red>", colorize=colorize)
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.info("The message")
        out, err = capsys.readouterr()
>       assert out == parse("-> <red>The message</red>\n", strip=not colorize)

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac07773d90>
colorize   = True
err        = ''
out        = ''
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:248: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac07772440>
        strict     = True
        strip      = False
        text       = '-> <red>The message</red>\n'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac07772440>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: red, red

self       = <loguru._colorizer.AnsiParser object at 0x7fac07772440>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_format_stringfalse">test_pickling.py::test_pickling_format_string[False]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_format_string[False]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac08290340>
colorize = False

    @pytest.mark.parametrize("colorize", [True, False])
    def test_pickling_format_string(capsys, colorize):
        logger.add(print_, format="-> <red>{message}</red>", colorize=colorize)
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.info("The message")
        out, err = capsys.readouterr()
>       assert out == parse("-> <red>The message</red>\n", strip=not colorize)

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac08290340>
colorize   = False
err        = ''
out        = ''
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:248: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac082924a0>
        strict     = True
        strip      = True
        text       = '-> <red>The message</red>\n'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac082924a0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: red, red

self       = <loguru._colorizer.AnsiParser object at 0x7fac082924a0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_format_functiontrue">test_pickling.py::test_pickling_format_function[True]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_format_function[True]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0820d7b0>
colorize = True

    @pytest.mark.parametrize("colorize", [True, False])
    def test_pickling_format_function(capsys, colorize):
        logger.add(print_, format=format_function, colorize=colorize)
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.info("The message")
        out, err = capsys.readouterr()
>       assert out == parse("-> <red>The message</red>", strip=not colorize)

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0820d7b0>
colorize   = True
err        = ''
out        = ''
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0820e2f0>
        strict     = True
        strip      = False
        text       = '-> <red>The message</red>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0820e2f0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: red, red

self       = <loguru._colorizer.AnsiParser object at 0x7fac0820e2f0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_format_functionfalse">test_pickling.py::test_pickling_format_function[False]</h3>
<details><summary> <pre>test_pickling.py::test_pickling_format_function[False]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac08308df0>
colorize = False

    @pytest.mark.parametrize("colorize", [True, False])
    def test_pickling_format_function(capsys, colorize):
        logger.add(print_, format=format_function, colorize=colorize)
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.info("The message")
        out, err = capsys.readouterr()
>       assert out == parse("-> <red>The message</red>", strip=not colorize)

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac08308df0>
colorize   = False
err        = ''
out        = ''
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/conftest.py:53: in parse
    tokens = parser.done(strict=strict)
        parser     = <loguru._colorizer.AnsiParser object at 0x7fac0ba87bb0>
        strict     = True
        strip      = True
        text       = '-> <red>The message</red>'
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <loguru._colorizer.AnsiParser object at 0x7fac0ba87bb0>, strict = True

    def done(self, strict=True):
        if strict and self._tags:
>           raise ValueError("Unclosed tags: %s" % ', '.join(self._tags))
E           ValueError: Unclosed tags: red, red

self       = <loguru._colorizer.AnsiParser object at 0x7fac0ba87bb0>
strict     = True

loguru/_colorizer.py:161: ValueError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_filter_function_not_serializable">test_pickling.py::test_pickling_filter_function_not_serializable</h3>
<details><summary> <pre>test_pickling.py::test_pickling_filter_function_not_serializable</pre></summary><pre>
def test_pickling_filter_function_not_serializable():
        logger.add(print, filter=lambda r: True)
>       with pytest.raises((pickle.PicklingError, AttributeError), match="Can't (pickle|get local)"):
E       Failed: DID NOT RAISE (<class '_pickle.PicklingError'>, <class 'AttributeError'>)


tests/test_pickling.py:265: Failed
</pre>
</details>
<h3 id="test_picklingpytest_pickling_format_function_not_serializable">test_pickling.py::test_pickling_format_function_not_serializable</h3>
<details><summary> <pre>test_pickling.py::test_pickling_format_function_not_serializable</pre></summary><pre>
def test_pickling_format_function_not_serializable():
        logger.add(print, format=lambda r: "{message}")
>       with pytest.raises((pickle.PicklingError, AttributeError), match="Can't (pickle|get local)"):
E       Failed: DID NOT RAISE (<class '_pickle.PicklingError'>, <class 'AttributeError'>)


tests/test_pickling.py:271: Failed
</pre>
</details>
<h3 id="test_picklingpytest_pickling_bound_logger">test_pickling.py::test_pickling_bound_logger</h3>
<details><summary> <pre>test_pickling.py::test_pickling_bound_logger</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac077ef0a0>

    def test_pickling_bound_logger(writer):
        bound_logger = logger.bind(foo="bar")
        pickled = pickle.dumps(bound_logger)
        unpickled = pickle.loads(pickled)
>       unpickled.add(writer, format="{extra[foo]}")
E       AttributeError: 'NoneType' object has no attribute 'add'

bound_logger = None
pickled    = b'\x80\x04N.'
unpickled  = None
writer     = <function writer.<locals>.w at 0x7fac077ef0a0>

tests/test_pickling.py:279: AttributeError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_patched_logger">test_pickling.py::test_pickling_patched_logger</h3>
<details><summary> <pre>test_pickling.py::test_pickling_patched_logger</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac077ee5f0>

    def test_pickling_patched_logger(writer):
        patched_logger = logger.patch(patch_function)
        pickled = pickle.dumps(patched_logger)
        unpickled = pickle.loads(pickled)
>       unpickled.add(writer, format="{extra[foo]}")
E       AttributeError: 'NoneType' object has no attribute 'add'

patched_logger = None
pickled    = b'\x80\x04N.'
unpickled  = None
writer     = <function writer.<locals>.w at 0x7fac077ee5f0>

tests/test_pickling.py:288: AttributeError
</pre>
</details>
<h3 id="test_picklingpytest_remove_after_pickling">test_pickling.py::test_remove_after_pickling</h3>
<details><summary> <pre>test_pickling.py::test_remove_after_pickling</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac071f9210>

    def test_remove_after_pickling(capsys):
        i = logger.add(print_, format="{message}")
        logger.info("A")
        pickled = pickle.dumps(logger)
        unpickled = pickle.loads(pickled)
        unpickled.remove(i)
        unpickled.info("B")
        out, err = capsys.readouterr()
>       assert out == "A\n"
E       AssertionError: assert '' == 'A\n'
E         
E         - A

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac071f9210>
err        = ''
i          = None
out        = ''
pickled    = b'\x80\x04\x95\xc8\x02\x00\x00\x00\x00\x00\x00\x8c\x0eloguru._logger\x94\x8c\x06Logger\x94\x93\x94)\x81\x94}\x94(\x8c\...x94\x8c\x0factivation_none\x94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub.'
unpickled  = <loguru.logger handlers=[]>

tests/test_pickling.py:301: AssertionError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_logging_method">test_pickling.py::test_pickling_logging_method</h3>
<details><summary> <pre>test_pickling.py::test_pickling_logging_method</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac077719f0>

    def test_pickling_logging_method(capsys):
        logger.add(print_, format="{level} - {function} - {message}")
        pickled = pickle.dumps(logger.critical)
        func = pickle.loads(pickled)
        func("A message")
        out, err = capsys.readouterr()
>       assert out == "CRITICAL - test_pickling_logging_method - A message\n"
E       AssertionError: assert '' == 'CRITICAL - t...- A message\n'
E         
E         - CRITICAL - test_pickling_logging_method - A message

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac077719f0>
err        = ''
func       = <bound method Logger.critical of <loguru.logger handlers=[]>>
out        = ''
pickled    = b'\x80\x04\x95\xee\x02\x00\x00\x00\x00\x00\x00\x8c\x08builtins\x94\x8c\x07getattr\x94\x93\x94\x8c\x0eloguru._logger\x9...8\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub\x8c\x08critical\x94\x86\x94R\x94.'

tests/test_pickling.py:311: AssertionError
</pre>
</details>
<h3 id="test_picklingpytest_pickling_log_method">test_pickling.py::test_pickling_log_method</h3>
<details><summary> <pre>test_pickling.py::test_pickling_log_method</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac071f9990>

    def test_pickling_log_method(capsys):
        logger.add(print_, format="{level} - {function} - {message}")
        pickled = pickle.dumps(logger.log)
        func = pickle.loads(pickled)
        func(19, "A message")
        out, err = capsys.readouterr()
>       assert out == "Level 19 - test_pickling_log_method - A message\n"
E       AssertionError: assert '' == 'Level 19 - t...- A message\n'
E         
E         - Level 19 - test_pickling_log_method - A message

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac071f9990>
err        = ''
func       = <bound method Logger.log of <loguru.logger handlers=[]>>
out        = ''
pickled    = b'\x80\x04\x95\xe9\x02\x00\x00\x00\x00\x00\x00\x8c\x08builtins\x94\x8c\x07getattr\x94\x93\x94\x8c\x0eloguru._logger\x9...94\x88\x8c\x04lock\x94Nub\x8c\x08_options\x94(NK\x00\x89\x89\x89\x89\x88]\x94}\x94t\x94ub\x8c\x03log\x94\x86\x94R\x94.'

tests/test_pickling.py:321: AssertionError
</pre>
</details>
<h3 id="test_propagationpytest_formatting">test_propagation.py::test_formatting</h3>
<details><summary> <pre>test_propagation.py::test_formatting</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac083c93c0>

    def test_formatting(capsys):
        fmt = (
            "%(name)s - %(filename)s - %(funcName)s - %(levelname)s - "
            "%(levelno)s - %(lineno)d - %(module)s - %(message)s"
        )

        expected = (
            "tests.test_propagation - test_propagation.py - test_formatting - DEBUG - "
            "10 - 30 - test_propagation - This is my message\n"
        )

        with make_logging_logger("tests.test_propagation", StreamHandler(sys.stderr), fmt):
            logger.add(PropagateHandler(), format="{message}")
            logger.debug("This {verb} my {}", "message", verb="is")

        out, err = capsys.readouterr()
        assert out == ""
>       assert err == expected
E       AssertionError: assert '' == 'tests.test_p... my message\n'
E         
E         - tests.test_propagation - test_propagation.py - test_formatting - DEBUG - 10 - 30 - test_propagation - This is my message

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac083c93c0>
err        = ''
expected   = 'tests.test_propagation - test_propagation.py - test_formatting - DEBUG - 10 - 30 - test_propagation - This is my message\n'
fmt        = '%(name)s - %(filename)s - %(funcName)s - %(levelname)s - %(levelno)s - %(lineno)d - %(module)s - %(message)s'
out        = ''

tests/test_propagation.py:34: AssertionError
</pre>
</details>
<h3 id="test_propagationpytest_propagate">test_propagation.py::test_propagate</h3>
<details><summary> <pre>test_propagation.py::test_propagate</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0757b0d0>

    def test_propagate(capsys):
        with make_logging_logger("tests", StreamHandler(sys.stderr)) as logging_logger:
            logging_logger.debug("1")
            logger.debug("2")

            logger.add(PropagateHandler(), format="{message}")

            logger.debug("3")
            logger.trace("4")

        out, err = capsys.readouterr()
        assert out == ""
>       assert err == "1\n3\n"
E       AssertionError: assert '1\n' == '1\n3\n'
E         
E           1
E         - 3

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0757b0d0>
err        = '1\n'
logging_logger = <Logger tests (DEBUG)>
out        = ''

tests/test_propagation.py:49: AssertionError
</pre>
</details>
<h3 id="test_propagationpytest_remove_propagation">test_propagation.py::test_remove_propagation</h3>
<details><summary> <pre>test_propagation.py::test_remove_propagation</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac082553c0>

    def test_remove_propagation(capsys):
        with make_logging_logger("tests", StreamHandler(sys.stderr)) as logging_logger:
            i = logger.add(PropagateHandler(), format="{message}")

            logger.debug("1")
            logging_logger.debug("2")

            logger.remove(i)

            logger.debug("3")
            logging_logger.debug("4")

        out, err = capsys.readouterr()
        assert out == ""
>       assert err == "1\n2\n4\n"
E       AssertionError: assert '2\n4\n' == '1\n2\n4\n'
E         
E         - 1
E           2
E           4

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac082553c0>
err        = '2\n4\n'
i          = None
logging_logger = <Logger tests (DEBUG)>
out        = ''

tests/test_propagation.py:66: AssertionError
</pre>
</details>
<h3 id="test_propagationpytest_exceptionfalse">test_propagation.py::test_exception[False]</h3>
<details><summary> <pre>test_propagation.py::test_exception[False]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0757beb0>
use_opt = False

    @pytest.mark.parametrize("use_opt", [False, True])
    def test_exception(capsys, use_opt):
        with make_logging_logger("tests", StreamHandler(sys.stderr)):
            logger.add(PropagateHandler(), format="{message}")

            try:
                1 / 0  # noqa: B018
            except Exception:
                if use_opt:
                    logger.opt(exception=True).error("Oops...")
                else:
                    logger.exception("Oops...")

        out, err = capsys.readouterr()
        lines = err.strip().splitlines()

        error = "ZeroDivisionError: division by zero"

        assert out == ""
>       assert lines[0] == "Oops..."
E       IndexError: list index out of range

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0757beb0>
err        = ''
error      = 'ZeroDivisionError: division by zero'
lines      = []
out        = ''
use_opt    = False

tests/test_propagation.py:101: IndexError
</pre>
</details>
<h3 id="test_propagationpytest_exceptiontrue">test_propagation.py::test_exception[True]</h3>
<details><summary> <pre>test_propagation.py::test_exception[True]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac071ea6e0>
use_opt = True

    @pytest.mark.parametrize("use_opt", [False, True])
    def test_exception(capsys, use_opt):
        with make_logging_logger("tests", StreamHandler(sys.stderr)):
            logger.add(PropagateHandler(), format="{message}")

            try:
>               1 / 0  # noqa: B018
E               ZeroDivisionError: division by zero

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac071ea6e0>
use_opt    = True

tests/test_propagation.py:88: ZeroDivisionError

During handling of the above exception, another exception occurred:

capsys = <_pytest.capture.CaptureFixture object at 0x7fac071ea6e0>
use_opt = True

    @pytest.mark.parametrize("use_opt", [False, True])
    def test_exception(capsys, use_opt):
        with make_logging_logger("tests", StreamHandler(sys.stderr)):
            logger.add(PropagateHandler(), format="{message}")

            try:
                1 / 0  # noqa: B018
            except Exception:
                if use_opt:
>                   logger.opt(exception=True).error("Oops...")
E                   AttributeError: 'NoneType' object has no attribute 'error'

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac071ea6e0>
use_opt    = True

tests/test_propagation.py:91: AttributeError
</pre>
</details>
<h3 id="test_recattrpytest_patch_record_file">test_recattr.py::test_patch_record_file</h3>
<details><summary> <pre>test_recattr.py::test_patch_record_file</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac077ecdc0>

    def test_patch_record_file(writer):
        def patch(record):
            record["file"].name = "456"
            record["file"].path = "123/456"

        logger.add(writer, format="{file} {file.name} {file.path}")
>       logger.patch(patch).info("Test")
E       AttributeError: 'NoneType' object has no attribute 'info'

patch      = <function test_patch_record_file.<locals>.patch at 0x7fac077ef400>
writer     = <function writer.<locals>.w at 0x7fac077ecdc0>

tests/test_recattr.py:13: AttributeError
</pre>
</details>
<h3 id="test_recattrpytest_patch_record_thread">test_recattr.py::test_patch_record_thread</h3>
<details><summary> <pre>test_recattr.py::test_patch_record_thread</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac077ef010>

    def test_patch_record_thread(writer):
        def patch(record):
            record["thread"].id = 111
            record["thread"].name = "Thread-111"

        logger.add(writer, format="{thread} {thread.name} {thread.id}")
>       logger.patch(patch).info("Test")
E       AttributeError: 'NoneType' object has no attribute 'info'

patch      = <function test_patch_record_thread.<locals>.patch at 0x7fac077ef520>
writer     = <function writer.<locals>.w at 0x7fac077ef010>

tests/test_recattr.py:24: AttributeError
</pre>
</details>
<h3 id="test_recattrpytest_patch_record_process">test_recattr.py::test_patch_record_process</h3>
<details><summary> <pre>test_recattr.py::test_patch_record_process</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac077ee9e0>

    def test_patch_record_process(writer):
        def patch(record):
            record["process"].id = 123
            record["process"].name = "Process-123"

        logger.add(writer, format="{process} {process.name} {process.id}")
>       logger.patch(patch).info("Test")
E       AttributeError: 'NoneType' object has no attribute 'info'

patch      = <function test_patch_record_process.<locals>.patch at 0x7fac077ef7f0>
writer     = <function writer.<locals>.w at 0x7fac077ee9e0>

tests/test_recattr.py:35: AttributeError
</pre>
</details>
<h3 id="test_recattrpytest_patch_record_exception">test_recattr.py::test_patch_record_exception</h3>
<details><summary> <pre>test_recattr.py::test_patch_record_exception</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac077ecf70>

    def test_patch_record_exception(writer):
        def patch(record):
            type_, value, traceback = record["exception"]
            record["exception"] = (type_, value, None)

        logger.add(writer, format="")
        try:
>           1 / 0  # noqa: B018
E           ZeroDivisionError: division by zero

patch      = <function test_patch_record_exception.<locals>.patch at 0x7fac077efb50>
writer     = <function writer.<locals>.w at 0x7fac077ecf70>

tests/test_recattr.py:47: ZeroDivisionError

During handling of the above exception, another exception occurred:

writer = <function writer.<locals>.w at 0x7fac077ecf70>

    def test_patch_record_exception(writer):
        def patch(record):
            type_, value, traceback = record["exception"]
            record["exception"] = (type_, value, None)

        logger.add(writer, format="")
        try:
            1 / 0  # noqa: B018
        except ZeroDivisionError:
>           logger.patch(patch).exception("Error")
E           AttributeError: 'NoneType' object has no attribute 'exception'

patch      = <function test_patch_record_exception.<locals>.patch at 0x7fac077efb50>
writer     = <function writer.<locals>.w at 0x7fac077ecf70>

tests/test_recattr.py:49: AttributeError
</pre>
</details>
<h3 id="test_removepytest_remove_all">test_remove.py::test_remove_all</h3>
<details><summary> <pre>test_remove.py::test_remove_all</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_remove_all0')
writer = <function writer.<locals>.w at 0x7fac077c4040>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac075786a0>

    def test_remove_all(tmp_path, writer, capsys):
        file = tmp_path / "test.log"

        logger.debug("This shouldn't be printed.")

        logger.add(file, format="{message}")
        logger.add(sys.stdout, format="{message}")
        logger.add(sys.stderr, format="{message}")
        logger.add(writer, format="{message}")

        message = "some message"
        expected = message + "\n"

        logger.debug(message)

        logger.remove()

        logger.debug("This shouldn't be printed neither.")

        out, err = capsys.readouterr()

>       assert file.read_text() == expected

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac075786a0>
err        = ''
expected   = 'some message\n'
file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_remove_all0/test.log')
message    = 'some message'
out        = ''
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_remove_all0')
writer     = <function writer.<locals>.w at 0x7fac077c4040>

tests/test_remove.py:38: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_remove_all0/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_remove_all0/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_remove_all0/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_remove_all0/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_removepytest_remove_simple">test_remove.py::test_remove_simple</h3>
<details><summary> <pre>test_remove.py::test_remove_simple</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac077efd90>

    def test_remove_simple(writer):
        i = logger.add(writer, format="{message}")
        logger.debug("1")
        logger.remove(i)
        logger.debug("2")
>       assert writer.read() == "1\n"
E       AssertionError: assert '' == '1\n'
E         
E         - 1

i          = None
writer     = <function writer.<locals>.w at 0x7fac077efd90>

tests/test_remove.py:49: AssertionError
</pre>
</details>
<h3 id="test_removepytest_remove_enqueue">test_remove.py::test_remove_enqueue</h3>
<details><summary> <pre>test_remove.py::test_remove_enqueue</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac077efa30>

    def test_remove_enqueue(writer):
        i = logger.add(writer, format="{message}", enqueue=True)
        logger.debug("1")
        time.sleep(0.1)
        logger.remove(i)
        logger.debug("2")
>       assert writer.read() == "1\n"
E       AssertionError: assert '' == '1\n'
E         
E         - 1

i          = None
writer     = <function writer.<locals>.w at 0x7fac077efa30>

tests/test_remove.py:58: AssertionError
</pre>
</details>
<h3 id="test_removepytest_remove_enqueue_filesink">test_remove.py::test_remove_enqueue_filesink</h3>
<details><summary> <pre>test_remove.py::test_remove_enqueue_filesink</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_remove_enqueue_filesink0')

    def test_remove_enqueue_filesink(tmp_path):
        file = tmp_path / "test.log"
        i = logger.add(file, format="{message}", enqueue=True)
        logger.debug("1")
        logger.remove(i)
>       assert file.read_text() == "1\n"

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_remove_enqueue_filesink0/test.log')
i          = None
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_remove_enqueue_filesink0')

tests/test_remove.py:66: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/pathlib.py:1134: in read_text
    with self.open(mode='r', encoding=encoding, errors=errors) as f:
        encoding   = 'locale'
        errors     = None
        self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_remove_enqueue_filesink0/test.log')
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = PosixPath('/tmp/pytest-of-root/pytest-0/test_remove_enqueue_filesink0/test.log')
mode = 'r', buffering = -1, encoding = 'locale', errors = None, newline = None

    def open(self, mode='r', buffering=-1, encoding=None,
             errors=None, newline=None):
        """
        Open the file pointed by this path and return a file object, as
        the built-in open() function does.
        """
        if "b" not in mode:
            encoding = io.text_encoding(encoding)
>       return self._accessor.open(self, mode, buffering, encoding, errors,
                                   newline)
E       FileNotFoundError: [Errno 2] No such file or directory: '/tmp/pytest-of-root/pytest-0/test_remove_enqueue_filesink0/test.log'

buffering  = -1
encoding   = 'locale'
errors     = None
mode       = 'r'
newline    = None
self       = PosixPath('/tmp/pytest-of-root/pytest-0/test_remove_enqueue_filesink0/test.log')

/usr/lib/python3.10/pathlib.py:1119: FileNotFoundError
</pre>
</details>
<h3 id="test_removepytest_exception_in_stop_during_remove_one">test_remove.py::test_exception_in_stop_during_remove_one</h3>
<details><summary> <pre>test_remove.py::test_exception_in_stop_during_remove_one</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac082ea860>

    def test_exception_in_stop_during_remove_one(capsys):
        i = logger.add(StopSinkError(), catch=False, format="{message}")
        logger.info("A")
>       with pytest.raises(OSError, match=r"Stop error"):
E       Failed: DID NOT RAISE <class 'OSError'>

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac082ea860>
i          = None

tests/test_remove.py:72: Failed
</pre>
</details>
<h3 id="test_removepytest_exception_in_stop_not_caught_during_remove_all">test_remove.py::test_exception_in_stop_not_caught_during_remove_all</h3>
<details><summary> <pre>test_remove.py::test_exception_in_stop_not_caught_during_remove_all</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0bb68640>

    def test_exception_in_stop_not_caught_during_remove_all(capsys):
        logger.add(StopSinkError(), catch=False, format="{message}")
        logger.add(StopSinkError(), catch=False, format="{message}")

>       with pytest.raises(OSError, match=r"Stop error"):
E       Failed: DID NOT RAISE <class 'OSError'>

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0bb68640>

tests/test_remove.py:86: Failed
</pre>
</details>
<h3 id="test_removepytest_invalid_handler_id_value">test_remove.py::test_invalid_handler_id_value</h3>
<details><summary> <pre>test_remove.py::test_invalid_handler_id_value</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac077efb50>

    def test_invalid_handler_id_value(writer):
        logger.add(writer)

>       with pytest.raises(ValueError, match=r"^There is no existing handler.*"):
E       Failed: DID NOT RAISE <class 'ValueError'>

writer     = <function writer.<locals>.w at 0x7fac077efb50>

tests/test_remove.py:105: Failed
</pre>
</details>
<h3 id="test_removepytest_invalid_handler_id_typehandler_id0">test_remove.py::test_invalid_handler_id_type[handler_id0]</h3>
<details><summary> <pre>test_remove.py::test_invalid_handler_id_type[handler_id0]</pre></summary><pre>
handler_id = <_io.TextIOWrapper name="<_io.FileIO name=8 mode='rb+' closefd=True>" mode='r+' encoding='utf-8'>

    @pytest.mark.parametrize("handler_id", [sys.stderr, sys, object(), int])
    def test_invalid_handler_id_type(handler_id):
>       with pytest.raises(TypeError, match=r"^Invalid handler id.*"):
E       Failed: DID NOT RAISE <class 'TypeError'>

handler_id = <_io.TextIOWrapper name="<_io.FileIO name=8 mode='rb+' closefd=True>" mode='r+' encoding='utf-8'>

tests/test_remove.py:111: Failed
</pre>
</details>
<h3 id="test_removepytest_invalid_handler_id_typesys">test_remove.py::test_invalid_handler_id_type[sys]</h3>
<details><summary> <pre>test_remove.py::test_invalid_handler_id_type[sys]</pre></summary><pre>
handler_id = <module 'sys' (built-in)>

    @pytest.mark.parametrize("handler_id", [sys.stderr, sys, object(), int])
    def test_invalid_handler_id_type(handler_id):
>       with pytest.raises(TypeError, match=r"^Invalid handler id.*"):
E       Failed: DID NOT RAISE <class 'TypeError'>

handler_id = <module 'sys' (built-in)>

tests/test_remove.py:111: Failed
</pre>
</details>
<h3 id="test_removepytest_invalid_handler_id_typehandler_id2">test_remove.py::test_invalid_handler_id_type[handler_id2]</h3>
<details><summary> <pre>test_remove.py::test_invalid_handler_id_type[handler_id2]</pre></summary><pre>
handler_id = <object object at 0x7fac0bb28750>

    @pytest.mark.parametrize("handler_id", [sys.stderr, sys, object(), int])
    def test_invalid_handler_id_type(handler_id):
>       with pytest.raises(TypeError, match=r"^Invalid handler id.*"):
E       Failed: DID NOT RAISE <class 'TypeError'>

handler_id = <object object at 0x7fac0bb28750>

tests/test_remove.py:111: Failed
</pre>
</details>
<h3 id="test_removepytest_invalid_handler_id_typeint">test_remove.py::test_invalid_handler_id_type[int]</h3>
<details><summary> <pre>test_remove.py::test_invalid_handler_id_type[int]</pre></summary><pre>
handler_id = <class 'int'>

    @pytest.mark.parametrize("handler_id", [sys.stderr, sys, object(), int])
    def test_invalid_handler_id_type(handler_id):
>       with pytest.raises(TypeError, match=r"^Invalid handler id.*"):
E       Failed: DID NOT RAISE <class 'TypeError'>

handler_id = <class 'int'>

tests/test_remove.py:111: Failed
</pre>
</details>
<h3 id="test_reprpytest_stderr">test_repr.py::test_stderr</h3>
<details><summary> <pre>test_repr.py::test_stderr</pre></summary><pre>
def test_stderr():
        logger.add(sys.__stderr__)
>       assert repr(logger) == "<loguru.logger handlers=[(id=0, level=10, sink=<stderr>)]>"
E       AssertionError: assert '<loguru.logger handlers=[]>' == '<loguru.logg...k=<stderr>)]>'
E         
E         - <loguru.logger handlers=[(id=0, level=10, sink=<stderr>)]>
E         + <loguru.logger handlers=[]>


tests/test_repr.py:15: AssertionError
</pre>
</details>
<h3 id="test_reprpytest_stdout">test_repr.py::test_stdout</h3>
<details><summary> <pre>test_repr.py::test_stdout</pre></summary><pre>
def test_stdout():
        logger.add(sys.__stdout__)
>       assert repr(logger) == "<loguru.logger handlers=[(id=0, level=10, sink=<stdout>)]>"
E       AssertionError: assert '<loguru.logger handlers=[]>' == '<loguru.logg...k=<stdout>)]>'
E         
E         - <loguru.logger handlers=[(id=0, level=10, sink=<stdout>)]>
E         + <loguru.logger handlers=[]>


tests/test_repr.py:20: AssertionError
</pre>
</details>
<h3 id="test_reprpytest_file_object">test_repr.py::test_file_object</h3>
<details><summary> <pre>test_repr.py::test_file_object</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_object0')

    def test_file_object(tmp_path):
        path = str(tmp_path / "test.log")
        file = open(path, "w")
        logger.add(file)
>       assert repr(logger) == "<loguru.logger handlers=[(id=0, level=10, sink=%s)]>" % path
E       AssertionError: assert '<loguru.logger handlers=[]>' == '<loguru.logg...0/test.log)]>'
E         
E         - <loguru.logger handlers=[(id=0, level=10, sink=/tmp/pytest-of-root/pytest-0/test_file_object0/test.log)]>
E         + <loguru.logger handlers=[]>

file       = <_io.TextIOWrapper name='/tmp/pytest-of-root/pytest-0/test_file_object0/test.log' mode='w' encoding='UTF-8'>
path       = '/tmp/pytest-of-root/pytest-0/test_file_object0/test.log'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_object0')

tests/test_repr.py:27: AssertionError
</pre>
</details>
<h3 id="test_reprpytest_file_str">test_repr.py::test_file_str</h3>
<details><summary> <pre>test_repr.py::test_file_str</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_str0')

    def test_file_str(tmp_path):
        path = str(tmp_path / "test.log")
        logger.add(path)
>       assert repr(logger) == "<loguru.logger handlers=[(id=0, level=10, sink='%s')]>" % path
E       assert '<loguru.logger handlers=[]>' == "<loguru.logg.../test.log')]>"
E         
E         - <loguru.logger handlers=[(id=0, level=10, sink='/tmp/pytest-of-root/pytest-0/test_file_str0/test.log')]>
E         + <loguru.logger handlers=[]>

path       = '/tmp/pytest-of-root/pytest-0/test_file_str0/test.log'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_str0')

tests/test_repr.py:33: AssertionError
</pre>
</details>
<h3 id="test_reprpytest_file_pathlib">test_repr.py::test_file_pathlib</h3>
<details><summary> <pre>test_repr.py::test_file_pathlib</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_pathlib0')

    def test_file_pathlib(tmp_path):
        path = str(tmp_path / "test.log")
        logger.add(pathlib.Path(path))
>       assert repr(logger) == "<loguru.logger handlers=[(id=0, level=10, sink='%s')]>" % path
E       assert '<loguru.logger handlers=[]>' == "<loguru.logg.../test.log')]>"
E         
E         - <loguru.logger handlers=[(id=0, level=10, sink='/tmp/pytest-of-root/pytest-0/test_file_pathlib0/test.log')]>
E         + <loguru.logger handlers=[]>

path       = '/tmp/pytest-of-root/pytest-0/test_file_pathlib0/test.log'
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_pathlib0')

tests/test_repr.py:39: AssertionError
</pre>
</details>
<h3 id="test_reprpytest_stream_object">test_repr.py::test_stream_object</h3>
<details><summary> <pre>test_repr.py::test_stream_object</pre></summary><pre>
def test_stream_object():
        class MyStream:
            def __init__(self, name):
                self.name = name

            def write(self, m):
                pass

            def __repr__(self):
                return "MyStream()"

        logger.add(MyStream("<foobar>"))
>       assert repr(logger) == "<loguru.logger handlers=[(id=0, level=10, sink=<foobar>)]>"
E       AssertionError: assert '<loguru.logger handlers=[]>' == '<loguru.logg...k=<foobar>)]>'
E         
E         - <loguru.logger handlers=[(id=0, level=10, sink=<foobar>)]>
E         + <loguru.logger handlers=[]>

MyStream   = <class 'tests.test_repr.test_stream_object.<locals>.MyStream'>

tests/test_repr.py:54: AssertionError
</pre>
</details>
<h3 id="test_reprpytest_stream_object_without_name_attr">test_repr.py::test_stream_object_without_name_attr</h3>
<details><summary> <pre>test_repr.py::test_stream_object_without_name_attr</pre></summary><pre>
def test_stream_object_without_name_attr():
        class MyStream:
            def write(self, m):
                pass

            def __repr__(self):
                return "MyStream()"

        logger.add(MyStream())
>       assert repr(logger) == "<loguru.logger handlers=[(id=0, level=10, sink=MyStream())]>"
E       AssertionError: assert '<loguru.logger handlers=[]>' == '<loguru.logg...MyStream())]>'
E         
E         - <loguru.logger handlers=[(id=0, level=10, sink=MyStream())]>
E         + <loguru.logger handlers=[]>

MyStream   = <class 'tests.test_repr.test_stream_object_without_name_attr.<locals>.MyStream'>

tests/test_repr.py:66: AssertionError
</pre>
</details>
<h3 id="test_reprpytest_stream_object_with_empty_name">test_repr.py::test_stream_object_with_empty_name</h3>
<details><summary> <pre>test_repr.py::test_stream_object_with_empty_name</pre></summary><pre>
def test_stream_object_with_empty_name():
        class MyStream2:
            def __init__(self):
                self.name = ""

            def write(self, message):
                pass

            def __repr__(self):
                return "MyStream2()"

        logger.add(MyStream2())
>       assert repr(logger) == "<loguru.logger handlers=[(id=0, level=10, sink=MyStream2())]>"
E       AssertionError: assert '<loguru.logger handlers=[]>' == '<loguru.logg...yStream2())]>'
E         
E         - <loguru.logger handlers=[(id=0, level=10, sink=MyStream2())]>
E         + <loguru.logger handlers=[]>

MyStream2  = <class 'tests.test_repr.test_stream_object_with_empty_name.<locals>.MyStream2'>

tests/test_repr.py:81: AssertionError
</pre>
</details>
<h3 id="test_reprpytest_function">test_repr.py::test_function</h3>
<details><summary> <pre>test_repr.py::test_function</pre></summary><pre>
def test_function():
        def my_function(message):
            pass

        logger.add(my_function)
>       assert repr(logger) == "<loguru.logger handlers=[(id=0, level=10, sink=my_function)]>"
E       AssertionError: assert '<loguru.logger handlers=[]>' == '<loguru.logg...y_function)]>'
E         
E         - <loguru.logger handlers=[(id=0, level=10, sink=my_function)]>
E         + <loguru.logger handlers=[]>

my_function = <function test_function.<locals>.my_function at 0x7fac077c5870>

tests/test_repr.py:89: AssertionError
</pre>
</details>
<h3 id="test_reprpytest_callable_without_name">test_repr.py::test_callable_without_name</h3>
<details><summary> <pre>test_repr.py::test_callable_without_name</pre></summary><pre>
def test_callable_without_name():
        class Function:
            def __call__(self):
                pass

            def __repr__(self):
                return "<FunctionWithout>"

        logger.add(Function())
>       assert repr(logger) == "<loguru.logger handlers=[(id=0, level=10, sink=<FunctionWithout>)]>"
E       AssertionError: assert '<loguru.logger handlers=[]>' == '<loguru.logg...onWithout>)]>'
E         
E         - <loguru.logger handlers=[(id=0, level=10, sink=<FunctionWithout>)]>
E         + <loguru.logger handlers=[]>

Function   = <class 'tests.test_repr.test_callable_without_name.<locals>.Function'>

tests/test_repr.py:101: AssertionError
</pre>
</details>
<h3 id="test_reprpytest_callable_with_empty_name">test_repr.py::test_callable_with_empty_name</h3>
<details><summary> <pre>test_repr.py::test_callable_with_empty_name</pre></summary><pre>
def test_callable_with_empty_name():
        class Function:
            __name__ = ""

            def __call__(self):
                pass

            def __repr__(self):
                return "<FunctionEmpty>"

        logger.add(Function())
>       assert repr(logger) == "<loguru.logger handlers=[(id=0, level=10, sink=<FunctionEmpty>)]>"
E       AssertionError: assert '<loguru.logger handlers=[]>' == '<loguru.logg...tionEmpty>)]>'
E         
E         - <loguru.logger handlers=[(id=0, level=10, sink=<FunctionEmpty>)]>
E         + <loguru.logger handlers=[]>

Function   = <class 'tests.test_repr.test_callable_with_empty_name.<locals>.Function'>

tests/test_repr.py:115: AssertionError
</pre>
</details>
<h3 id="test_reprpytest_coroutine_function">test_repr.py::test_coroutine_function</h3>
<details><summary> <pre>test_repr.py::test_coroutine_function</pre></summary><pre>
def test_coroutine_function():
        async def my_async_function(message):
            pass

        logger.add(my_async_function)
>       assert repr(logger) == "<loguru.logger handlers=[(id=0, level=10, sink=my_async_function)]>"
E       AssertionError: assert '<loguru.logger handlers=[]>' == '<loguru.logg...c_function)]>'
E         
E         - <loguru.logger handlers=[(id=0, level=10, sink=my_async_function)]>
E         + <loguru.logger handlers=[]>

my_async_function = <function test_coroutine_function.<locals>.my_async_function at 0x7fac077ecb80>

tests/test_repr.py:123: AssertionError
</pre>
</details>
<h3 id="test_reprpytest_coroutine_callable_without_name">test_repr.py::test_coroutine_callable_without_name</h3>
<details><summary> <pre>test_repr.py::test_coroutine_callable_without_name</pre></summary><pre>
def test_coroutine_callable_without_name():
        class CoroutineFunction:
            async def __call__(self):
                pass

            def __repr__(self):
                return "<AsyncFunctionWithout>"

        logger.add(CoroutineFunction())
>       assert (
            repr(logger) == "<loguru.logger handlers=[(id=0, level=10, sink=<AsyncFunctionWithout>)]>"
        )
E       AssertionError: assert '<loguru.logger handlers=[]>' == '<loguru.logg...onWithout>)]>'
E         
E         - <loguru.logger handlers=[(id=0, level=10, sink=<AsyncFunctionWithout>)]>
E         + <loguru.logger handlers=[]>

CoroutineFunction = <class 'tests.test_repr.test_coroutine_callable_without_name.<locals>.CoroutineFunction'>

tests/test_repr.py:135: AssertionError
</pre>
</details>
<h3 id="test_reprpytest_coroutine_function_with_empty_name">test_repr.py::test_coroutine_function_with_empty_name</h3>
<details><summary> <pre>test_repr.py::test_coroutine_function_with_empty_name</pre></summary><pre>
def test_coroutine_function_with_empty_name():
        class CoroutineFunction:
            __name__ = ""

            def __call__(self):
                pass

            def __repr__(self):
                return "<AsyncFunctionEmpty>"

        logger.add(CoroutineFunction())
>       assert repr(logger) == "<loguru.logger handlers=[(id=0, level=10, sink=<AsyncFunctionEmpty>)]>"
E       AssertionError: assert '<loguru.logger handlers=[]>' == '<loguru.logg...tionEmpty>)]>'
E         
E         - <loguru.logger handlers=[(id=0, level=10, sink=<AsyncFunctionEmpty>)]>
E         + <loguru.logger handlers=[]>

CoroutineFunction = <class 'tests.test_repr.test_coroutine_function_with_empty_name.<locals>.CoroutineFunction'>

tests/test_repr.py:151: AssertionError
</pre>
</details>
<h3 id="test_reprpytest_standard_handler">test_repr.py::test_standard_handler</h3>
<details><summary> <pre>test_repr.py::test_standard_handler</pre></summary><pre>
def test_standard_handler():
        handler = logging.StreamHandler(sys.__stderr__)
        logger.add(handler)
        if sys.version_info >= (3, 6):
            r = "<loguru.logger handlers=[(id=0, level=10, sink=<StreamHandler <stderr> (NOTSET)>)]>"
>           assert repr(logger) == r
E           AssertionError: assert '<loguru.logger handlers=[]>' == '<loguru.logg... (NOTSET)>)]>'
E             
E             - <loguru.logger handlers=[(id=0, level=10, sink=<StreamHandler <stderr> (NOTSET)>)]>
E             + <loguru.logger handlers=[]>

handler    = <StreamHandler <stderr> (NOTSET)>
r          = '<loguru.logger handlers=[(id=0, level=10, sink=<StreamHandler <stderr> (NOTSET)>)]>'

tests/test_repr.py:159: AssertionError
</pre>
</details>
<h3 id="test_reprpytest_multiple_handlers">test_repr.py::test_multiple_handlers</h3>
<details><summary> <pre>test_repr.py::test_multiple_handlers</pre></summary><pre>
def test_multiple_handlers():
        logger.add(sys.__stdout__)
        logger.add(sys.__stderr__)
        r = (
            "<loguru.logger handlers=["
            "(id=0, level=10, sink=<stdout>), "
            "(id=1, level=10, sink=<stderr>)"
            "]>"
        )
>       assert repr(logger) == r
E       AssertionError: assert '<loguru.logger handlers=[]>' == '<loguru.logg...k=<stderr>)]>'
E         
E         - <loguru.logger handlers=[(id=0, level=10, sink=<stdout>), (id=1, level=10, sink=<stderr>)]>
E         + <loguru.logger handlers=[]>

r          = '<loguru.logger handlers=[(id=0, level=10, sink=<stdout>), (id=1, level=10, sink=<stderr>)]>'

tests/test_repr.py:174: AssertionError
</pre>
</details>
<h3 id="test_reprpytest_handler_removed">test_repr.py::test_handler_removed</h3>
<details><summary> <pre>test_repr.py::test_handler_removed</pre></summary><pre>
def test_handler_removed():
        i = logger.add(sys.__stdout__)
        logger.add(sys.__stderr__)
        logger.remove(i)
>       assert repr(logger) == "<loguru.logger handlers=[(id=1, level=10, sink=<stderr>)]>"
E       AssertionError: assert '<loguru.logger handlers=[]>' == '<loguru.logg...k=<stderr>)]>'
E         
E         - <loguru.logger handlers=[(id=1, level=10, sink=<stderr>)]>
E         + <loguru.logger handlers=[]>

i          = None

tests/test_repr.py:181: AssertionError
</pre>
</details>
<h3 id="test_reprpytest_handler_level_name">test_repr.py::test_handler_level_name</h3>
<details><summary> <pre>test_repr.py::test_handler_level_name</pre></summary><pre>
def test_handler_level_name():
        logger.add(sys.__stderr__, level="TRACE")
>       assert repr(logger) == "<loguru.logger handlers=[(id=0, level=5, sink=<stderr>)]>"
E       AssertionError: assert '<loguru.logger handlers=[]>' == '<loguru.logg...k=<stderr>)]>'
E         
E         - <loguru.logger handlers=[(id=0, level=5, sink=<stderr>)]>
E         + <loguru.logger handlers=[]>


tests/test_repr.py:186: AssertionError
</pre>
</details>
<h3 id="test_reprpytest_handler_level_num">test_repr.py::test_handler_level_num</h3>
<details><summary> <pre>test_repr.py::test_handler_level_num</pre></summary><pre>
def test_handler_level_num():
        logger.add(sys.__stderr__, level=33)
>       assert repr(logger) == "<loguru.logger handlers=[(id=0, level=33, sink=<stderr>)]>"
E       AssertionError: assert '<loguru.logger handlers=[]>' == '<loguru.logg...k=<stderr>)]>'
E         
E         - <loguru.logger handlers=[(id=0, level=33, sink=<stderr>)]>
E         + <loguru.logger handlers=[]>


tests/test_repr.py:191: AssertionError
</pre>
</details>
<h3 id="test_standard_handlerpytest_stream_handler">test_standard_handler.py::test_stream_handler</h3>
<details><summary> <pre>test_standard_handler.py::test_stream_handler</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac07cf9930>

    def test_stream_handler(capsys):
        logger.add(StreamHandler(sys.stderr), format="{level} {message}")
        logger.info("test")
        logger.remove()
        logger.warning("nope")

        out, err = capsys.readouterr()
        assert out == ""
>       assert err == "INFO test\n"
E       AssertionError: assert '' == 'INFO test\n'
E         
E         - INFO test

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac07cf9930>
err        = ''
out        = ''

tests/test_standard_handler.py:17: AssertionError
</pre>
</details>
<h3 id="test_standard_handlerpytest_file_handler">test_standard_handler.py::test_file_handler</h3>
<details><summary> <pre>test_standard_handler.py::test_file_handler</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_handler0')

    def test_file_handler(tmp_path):
        file = tmp_path / "test.log"
        logger.add(FileHandler(str(file)), format="{message} {level.name}")
        logger.info("test")
        logger.remove()
        logger.warning("nope")

>       assert file.read_text() == "test INFO\n"
E       AssertionError: assert '' == 'test INFO\n'
E         
E         - test INFO

file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_handler0/test.log')
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_file_handler0')

tests/test_standard_handler.py:27: AssertionError
</pre>
</details>
<h3 id="test_standard_handlerpytest_extra_dict">test_standard_handler.py::test_extra_dict</h3>
<details><summary> <pre>test_standard_handler.py::test_extra_dict</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac07cf96c0>

    def test_extra_dict(capsys):
        handler = StreamHandler(sys.stdout)
        formatter = Formatter("%(extra)s %(message)s")
        handler.setFormatter(formatter)
        logger.add(handler, format="<{extra[abc]}> {message}", catch=False)
>       logger.bind(abc=123).info("Extra!")
E       AttributeError: 'NoneType' object has no attribute 'info'

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac07cf96c0>
formatter  = <logging.Formatter object at 0x7fac07cfb8b0>
handler    = <StreamHandler (NOTSET)>

tests/test_standard_handler.py:45: AttributeError
</pre>
</details>
<h3 id="test_standard_handlerpytest_no_conflict_with_extra_dict">test_standard_handler.py::test_no_conflict_with_extra_dict</h3>
<details><summary> <pre>test_standard_handler.py::test_no_conflict_with_extra_dict</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0820cc40>

    def test_no_conflict_with_extra_dict(capsys):
        handler = StreamHandler(sys.stdout)
        logger.add(handler, format="{message}", catch=False)
>       logger.bind(args=True, name="foobar", message="Wut?").info("OK!")
E       AttributeError: 'NoneType' object has no attribute 'info'

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0820cc40>
handler    = <StreamHandler (NOTSET)>

tests/test_standard_handler.py:54: AttributeError
</pre>
</details>
<h3 id="test_standard_handlerpytest_no_exception">test_standard_handler.py::test_no_exception</h3>
<details><summary> <pre>test_standard_handler.py::test_no_exception</pre></summary><pre>
def test_no_exception():
        result = None

        class NoExceptionHandler(Handler):
            def emit(self, record):
                nonlocal result
                result = bool(not record.exc_info)

        logger.add(NoExceptionHandler())

        try:
            1 / 0  # noqa: B018
        except ZeroDivisionError:
            logger.exception("Error")

>       assert result is False
E       assert None is False

NoExceptionHandler = <class 'tests.test_standard_handler.test_no_exception.<locals>.NoExceptionHandler'>
result     = None

tests/test_standard_handler.py:75: AssertionError
</pre>
</details>
<h3 id="test_standard_handlerpytest_exception">test_standard_handler.py::test_exception</h3>
<details><summary> <pre>test_standard_handler.py::test_exception</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac08292200>

    def test_exception(capsys):
        result = None

        class ExceptionHandler(Handler):
            def emit(self, record):
                nonlocal result
                result = bool(record.exc_info)

        logger.add(ExceptionHandler())

        try:
            1 / 0  # noqa: B018
        except ZeroDivisionError:
            logger.exception("Error")

>       assert result is True
E       assert None is True

ExceptionHandler = <class 'tests.test_standard_handler.test_exception.<locals>.ExceptionHandler'>
capsys     = <_pytest.capture.CaptureFixture object at 0x7fac08292200>
result     = None

tests/test_standard_handler.py:93: AssertionError
</pre>
</details>
<h3 id="test_standard_handlerpytest_exception_formatting">test_standard_handler.py::test_exception_formatting</h3>
<details><summary> <pre>test_standard_handler.py::test_exception_formatting</pre></summary><pre>
tmp_path = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_formatting0')

    def test_exception_formatting(tmp_path):
        file = tmp_path / "test.log"
        logger.add(FileHandler(str(file)), format="{message}")

        try:
            1 / 0  # noqa: B018
        except ZeroDivisionError:
            logger.exception("Error")

        result = file.read_text()
        lines = result.strip().splitlines()

        error = "ZeroDivisionError: division by zero"

>       assert lines[1].startswith("Traceback")
E       IndexError: list index out of range

error      = 'ZeroDivisionError: division by zero'
file       = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_formatting0/test.log')
lines      = []
result     = ''
tmp_path   = PosixPath('/tmp/pytest-of-root/pytest-0/test_exception_formatting0')

tests/test_standard_handler.py:110: IndexError
</pre>
</details>
<h3 id="test_standard_handlerpytest_standard_formatterfalse">test_standard_handler.py::test_standard_formatter[False]</h3>
<details><summary> <pre>test_standard_handler.py::test_standard_formatter[False]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac0751bbb0>
dynamic_format = False

    @pytest.mark.parametrize("dynamic_format", [False, True])
    def test_standard_formatter(capsys, dynamic_format):
        def format_(x):
            return "{level.no} {message} [Not Chopped]"

        if not dynamic_format:
            format_ = format_(None)

        handler = StreamHandler(sys.stdout)
        formatter = Formatter("%(message)s %(levelname)s")
        handler.setFormatter(formatter)
        logger.add(handler, format=format_)
        logger.info("Test")
        out, err = capsys.readouterr()
>       assert out == "20 Test [Not Chopped] INFO\n"
E       AssertionError: assert '' == '20 Test [Not Chopped] INFO\n'
E         
E         - 20 Test [Not Chopped] INFO

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac0751bbb0>
dynamic_format = False
err        = ''
format_    = '{level.no} {message} [Not Chopped]'
formatter  = <logging.Formatter object at 0x7fac0751bd00>
handler    = <StreamHandler (NOTSET)>
out        = ''

tests/test_standard_handler.py:129: AssertionError
</pre>
</details>
<h3 id="test_standard_handlerpytest_standard_formattertrue">test_standard_handler.py::test_standard_formatter[True]</h3>
<details><summary> <pre>test_standard_handler.py::test_standard_formatter[True]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac087150f0>
dynamic_format = True

    @pytest.mark.parametrize("dynamic_format", [False, True])
    def test_standard_formatter(capsys, dynamic_format):
        def format_(x):
            return "{level.no} {message} [Not Chopped]"

        if not dynamic_format:
            format_ = format_(None)

        handler = StreamHandler(sys.stdout)
        formatter = Formatter("%(message)s %(levelname)s")
        handler.setFormatter(formatter)
        logger.add(handler, format=format_)
        logger.info("Test")
        out, err = capsys.readouterr()
>       assert out == "20 Test [Not Chopped] INFO\n"
E       AssertionError: assert '' == '20 Test [Not Chopped] INFO\n'
E         
E         - 20 Test [Not Chopped] INFO

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac087150f0>
dynamic_format = True
err        = ''
format_    = <function test_standard_formatter.<locals>.format_ at 0x7fac077c5fc0>
formatter  = <logging.Formatter object at 0x7fac08717730>
handler    = <StreamHandler (NOTSET)>
out        = ''

tests/test_standard_handler.py:129: AssertionError
</pre>
</details>
<h3 id="test_standard_handlerpytest_standard_formatter_with_new_linefalse">test_standard_handler.py::test_standard_formatter_with_new_line[False]</h3>
<details><summary> <pre>test_standard_handler.py::test_standard_formatter_with_new_line[False]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac07518ca0>
dynamic_format = False

    @pytest.mark.parametrize("dynamic_format", [False, True])
    def test_standard_formatter_with_new_line(capsys, dynamic_format):
        def format_(x):
            return "{level.no} {message}\n"

        if not dynamic_format:
            format_ = format_(None)

        handler = StreamHandler(sys.stdout)
        formatter = Formatter("%(message)s %(levelname)s")
        handler.setFormatter(formatter)
        logger.add(handler, format=format_)
        logger.info("Test")
        out, err = capsys.readouterr()
>       assert out == "20 Test\n INFO\n"
E       AssertionError: assert '' == '20 Test\n INFO\n'
E         
E         - 20 Test
E         -  INFO

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac07518ca0>
dynamic_format = False
err        = ''
format_    = '{level.no} {message}\n'
formatter  = <logging.Formatter object at 0x7fac07518f70>
handler    = <StreamHandler (NOTSET)>
out        = ''

tests/test_standard_handler.py:147: AssertionError
</pre>
</details>
<h3 id="test_standard_handlerpytest_standard_formatter_with_new_linetrue">test_standard_handler.py::test_standard_formatter_with_new_line[True]</h3>
<details><summary> <pre>test_standard_handler.py::test_standard_formatter_with_new_line[True]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac07cfaf20>
dynamic_format = True

    @pytest.mark.parametrize("dynamic_format", [False, True])
    def test_standard_formatter_with_new_line(capsys, dynamic_format):
        def format_(x):
            return "{level.no} {message}\n"

        if not dynamic_format:
            format_ = format_(None)

        handler = StreamHandler(sys.stdout)
        formatter = Formatter("%(message)s %(levelname)s")
        handler.setFormatter(formatter)
        logger.add(handler, format=format_)
        logger.info("Test")
        out, err = capsys.readouterr()
>       assert out == "20 Test\n INFO\n"
E       AssertionError: assert '' == '20 Test\n INFO\n'
E         
E         - 20 Test
E         -  INFO

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac07cfaf20>
dynamic_format = True
err        = ''
format_    = <function test_standard_formatter_with_new_line.<locals>.format_ at 0x7fac077ef640>
formatter  = <logging.Formatter object at 0x7fac07cf9120>
handler    = <StreamHandler (NOTSET)>
out        = ''

tests/test_standard_handler.py:147: AssertionError
</pre>
</details>
<h3 id="test_standard_handlerpytest_raw_standard_formatterfalse">test_standard_handler.py::test_raw_standard_formatter[False]</h3>
<details><summary> <pre>test_standard_handler.py::test_raw_standard_formatter[False]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac077b0400>
dynamic_format = False

    @pytest.mark.parametrize("dynamic_format", [False, True])
    def test_raw_standard_formatter(capsys, dynamic_format):
        def format_(x):
            return "{level.no} {message} [Not Chopped]"

        if not dynamic_format:
            format_ = format_(None)

        handler = StreamHandler(sys.stdout)
        formatter = Formatter("%(message)s %(levelname)s")
        handler.setFormatter(formatter)
        logger.add(handler, format=format_)
>       logger.opt(raw=True).info("Test")
E       AttributeError: 'NoneType' object has no attribute 'info'

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac077b0400>
dynamic_format = False
format_    = '{level.no} {message} [Not Chopped]'
formatter  = <logging.Formatter object at 0x7fac077b04f0>
handler    = <StreamHandler (NOTSET)>

tests/test_standard_handler.py:163: AttributeError
</pre>
</details>
<h3 id="test_standard_handlerpytest_raw_standard_formattertrue">test_standard_handler.py::test_raw_standard_formatter[True]</h3>
<details><summary> <pre>test_standard_handler.py::test_raw_standard_formatter[True]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac087167d0>
dynamic_format = True

    @pytest.mark.parametrize("dynamic_format", [False, True])
    def test_raw_standard_formatter(capsys, dynamic_format):
        def format_(x):
            return "{level.no} {message} [Not Chopped]"

        if not dynamic_format:
            format_ = format_(None)

        handler = StreamHandler(sys.stdout)
        formatter = Formatter("%(message)s %(levelname)s")
        handler.setFormatter(formatter)
        logger.add(handler, format=format_)
>       logger.opt(raw=True).info("Test")
E       AttributeError: 'NoneType' object has no attribute 'info'

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac087167d0>
dynamic_format = True
format_    = <function test_raw_standard_formatter.<locals>.format_ at 0x7fac077c5fc0>
formatter  = <logging.Formatter object at 0x7fac08717250>
handler    = <StreamHandler (NOTSET)>

tests/test_standard_handler.py:163: AttributeError
</pre>
</details>
<h3 id="test_standard_handlerpytest_raw_standard_formatter_with_new_linefalse">test_standard_handler.py::test_raw_standard_formatter_with_new_line[False]</h3>
<details><summary> <pre>test_standard_handler.py::test_raw_standard_formatter_with_new_line[False]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac077b2530>
dynamic_format = False

    @pytest.mark.parametrize("dynamic_format", [False, True])
    def test_raw_standard_formatter_with_new_line(capsys, dynamic_format):
        def format_(x):
            return "{level.no} {message}\n"

        if not dynamic_format:
            format_ = format_(None)

        handler = StreamHandler(sys.stdout)
        formatter = Formatter("%(message)s %(levelname)s")
        handler.setFormatter(formatter)
        logger.add(handler, format=format_)
>       logger.opt(raw=True).info("Test")
E       AttributeError: 'NoneType' object has no attribute 'info'

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac077b2530>
dynamic_format = False
format_    = '{level.no} {message}\n'
formatter  = <logging.Formatter object at 0x7fac077b3880>
handler    = <StreamHandler (NOTSET)>

tests/test_standard_handler.py:181: AttributeError
</pre>
</details>
<h3 id="test_standard_handlerpytest_raw_standard_formatter_with_new_linetrue">test_standard_handler.py::test_raw_standard_formatter_with_new_line[True]</h3>
<details><summary> <pre>test_standard_handler.py::test_raw_standard_formatter_with_new_line[True]</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac07518b80>
dynamic_format = True

    @pytest.mark.parametrize("dynamic_format", [False, True])
    def test_raw_standard_formatter_with_new_line(capsys, dynamic_format):
        def format_(x):
            return "{level.no} {message}\n"

        if not dynamic_format:
            format_ = format_(None)

        handler = StreamHandler(sys.stdout)
        formatter = Formatter("%(message)s %(levelname)s")
        handler.setFormatter(formatter)
        logger.add(handler, format=format_)
>       logger.opt(raw=True).info("Test")
E       AttributeError: 'NoneType' object has no attribute 'info'

capsys     = <_pytest.capture.CaptureFixture object at 0x7fac07518b80>
dynamic_format = True
format_    = <function test_raw_standard_formatter_with_new_line.<locals>.format_ at 0x7fac077c5870>
formatter  = <logging.Formatter object at 0x7fac0751a890>
handler    = <StreamHandler (NOTSET)>

tests/test_standard_handler.py:181: AttributeError
</pre>
</details>
<h3 id="test_threadingpytest_safe_logging">test_threading.py::test_safe_logging</h3>
<details><summary> <pre>test_threading.py::test_safe_logging</pre></summary><pre>
def test_safe_logging():
        barrier = Barrier(2)
        counter = itertools.count()

        sink = NonSafeSink(1)
        logger.add(sink, format="{message}", catch=False)

        def threaded():
            barrier.wait()
            logger.info("___{}___", next(counter))

        threads = [Thread(target=threaded) for _ in range(2)]

        for thread in threads:
            thread.start()

        for thread in threads:
            thread.join()

        logger.remove()

>       assert sink.written in ("___0___\n___1___\n", "___1___\n___0___\n")
E       AssertionError: assert '' in ('___0___\n___1___\n', '___1___\n___0___\n')
E        +  where '' = <tests.test_threading.NonSafeSink object at 0x7fac077b3be0>.written

barrier    = <threading.Barrier object at 0x7fac077b1ea0>
counter    = count(2)
sink       = <tests.test_threading.NonSafeSink object at 0x7fac077b3be0>
thread     = <Thread(Thread-50 (threaded), stopped 140376283268672)>
threaded   = <function test_safe_logging.<locals>.threaded at 0x7fac077c64d0>
threads    = [<Thread(Thread-49 (threaded), stopped 140376274875968)>, <Thread(Thread-50 (threaded), stopped 140376283268672)>]

tests/test_threading.py:48: AssertionError
</pre>
</details>
<h3 id="test_threadingpytest_safe_adding_while_logging">test_threading.py::test_safe_adding_while_logging</h3>
<details><summary> <pre>test_threading.py::test_safe_adding_while_logging</pre></summary><pre>
writer = <function writer.<locals>.w at 0x7fac077c5c60>

    def test_safe_adding_while_logging(writer):
        barrier = Barrier(2)
        counter = itertools.count()

        sink_1 = NonSafeSink(1)
        sink_2 = NonSafeSink(1)
        logger.add(sink_1, format="{message}", catch=False)

        def thread_1():
            barrier.wait()
            logger.info("aaa{}bbb", next(counter))

        def thread_2():
            barrier.wait()
            time.sleep(0.5)
            logger.add(sink_2, format="{message}", catch=False)
            logger.info("ccc{}ddd", next(counter))

        threads = [Thread(target=thread_1), Thread(target=thread_2)]

        for thread in threads:
            thread.start()

        for thread in threads:
            thread.join()

        logger.remove()

>       assert sink_1.written == "aaa0bbb\nccc1ddd\n"
E       AssertionError: assert '' == 'aaa0bbb\nccc1ddd\n'
E         
E         - aaa0bbb
E         - ccc1ddd

barrier    = <threading.Barrier object at 0x7fac0b941930>
counter    = count(2)
sink_1     = <tests.test_threading.NonSafeSink object at 0x7fac0b941cc0>
sink_2     = <tests.test_threading.NonSafeSink object at 0x7fac0b941b40>
thread     = <Thread(Thread-52 (thread_2), stopped 140376283268672)>
thread_1   = <function test_safe_adding_while_logging.<locals>.thread_1 at 0x7fac077c6560>
thread_2   = <function test_safe_adding_while_logging.<locals>.thread_2 at 0x7fac077c5fc0>
threads    = [<Thread(Thread-51 (thread_1), stopped 140376274875968)>, <Thread(Thread-52 (thread_2), stopped 140376283268672)>]
writer     = <function writer.<locals>.w at 0x7fac077c5c60>

tests/test_threading.py:79: AssertionError
</pre>
</details>
<h3 id="test_threadingpytest_safe_removing_while_logging">test_threading.py::test_safe_removing_while_logging</h3>
<details><summary> <pre>test_threading.py::test_safe_removing_while_logging</pre></summary><pre>
capsys = <_pytest.capture.CaptureFixture object at 0x7fac07751f90>

    def test_safe_removing_while_logging(capsys):
        barrier = Barrier(2)
        counter = itertools.count()

        sink = NonSafeSink(1)
        i = logger.add(sink, format="{message}", catch=False)

        def thread_1():
            barrier.wait()
            logger.info("aaa{}bbb", next(counter))

        def thread_2():
            barrier.wait()
            time.sleep(0.5)
            logger.remove(i)
            logger.info("ccc{}ddd", next(counter))

        threads = [Thread(target=thread_1), Thread(target=thread_2)]

        for thread in threads:
            thread.start()

        for thread in threads:
            thread.join()

        out, err = capsys.readouterr()
        assert out == ""
        assert err == ""
>       assert sink.written == "aaa0bbb\n"
E       AssertionError: assert '' == 'aaa0bbb\n'
E         
E         - aaa0bbb

barrier    = <threading.Barrier object at 0x7fac07752200>
capsys     = <_pytest.capture.CaptureFixture object at 0x7fac07751f90>
counter    = count(2)
err        = ''
i          = None
out        = ''
sink       = <tests.test_threading.NonSafeSink object at 0x7fac077513f0>
thread     = <Thread(Thread-54 (thread_2), stopped 140376274875968)>
thread_1   = <function test_safe_removing_while_logging.<locals>.thread_1 at 0x7fac077c6950>
thread_2   = <function test_safe_removing_while_logging.<locals>.thread_2 at 0x7fac077c69e0>
threads    = [<Thread(Thread-53 (thread_1), stopped 140376283268672)>, <Thread(Thread-54 (thread_2), stopped 140376274875968)>]

tests/test_threading.py:111: AssertionError
</pre>
</details>
<h3 id="test_loggerymlbasic_logger_usagemethodtrace">test_logger.yml::basic_logger_usage[method=trace]</h3>
<details><summary> <pre>test_logger.yml::basic_logger_usage[method=trace]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:14: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:3: note: Revealed type is "Any"          (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:3: note: Revealed type is "loguru.Logger" (diff)
E     main:4: note: Revealed type is "None"         (diff)
E   Alignment of first line difference:
E     E: main:3: note: Revealed type is "loguru.Logger"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlbasic_logger_usagemethoddebug">test_logger.yml::basic_logger_usage[method=debug]</h3>
<details><summary> <pre>test_logger.yml::basic_logger_usage[method=debug]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:14: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:3: note: Revealed type is "Any"          (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:3: note: Revealed type is "loguru.Logger" (diff)
E     main:4: note: Revealed type is "None"         (diff)
E   Alignment of first line difference:
E     E: main:3: note: Revealed type is "loguru.Logger"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlbasic_logger_usagemethodinfo">test_logger.yml::basic_logger_usage[method=info]</h3>
<details><summary> <pre>test_logger.yml::basic_logger_usage[method=info]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:14: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:3: note: Revealed type is "Any"          (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:3: note: Revealed type is "loguru.Logger" (diff)
E     main:4: note: Revealed type is "None"         (diff)
E   Alignment of first line difference:
E     E: main:3: note: Revealed type is "loguru.Logger"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlbasic_logger_usagemethodsuccess">test_logger.yml::basic_logger_usage[method=success]</h3>
<details><summary> <pre>test_logger.yml::basic_logger_usage[method=success]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:14: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:3: note: Revealed type is "Any"          (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:3: note: Revealed type is "loguru.Logger" (diff)
E     main:4: note: Revealed type is "None"         (diff)
E   Alignment of first line difference:
E     E: main:3: note: Revealed type is "loguru.Logger"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlbasic_logger_usagemethodwarning">test_logger.yml::basic_logger_usage[method=warning]</h3>
<details><summary> <pre>test_logger.yml::basic_logger_usage[method=warning]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:14: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:3: note: Revealed type is "Any"          (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:3: note: Revealed type is "loguru.Logger" (diff)
E     main:4: note: Revealed type is "None"         (diff)
E   Alignment of first line difference:
E     E: main:3: note: Revealed type is "loguru.Logger"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlbasic_logger_usagemethoderror">test_logger.yml::basic_logger_usage[method=error]</h3>
<details><summary> <pre>test_logger.yml::basic_logger_usage[method=error]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:14: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:3: note: Revealed type is "Any"          (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:3: note: Revealed type is "loguru.Logger" (diff)
E     main:4: note: Revealed type is "None"         (diff)
E   Alignment of first line difference:
E     E: main:3: note: Revealed type is "loguru.Logger"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlbasic_logger_usagemethodexception">test_logger.yml::basic_logger_usage[method=exception]</h3>
<details><summary> <pre>test_logger.yml::basic_logger_usage[method=exception]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:14: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:3: note: Revealed type is "Any"          (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:3: note: Revealed type is "loguru.Logger" (diff)
E     main:4: note: Revealed type is "None"         (diff)
E   Alignment of first line difference:
E     E: main:3: note: Revealed type is "loguru.Logger"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlbasic_logger_usagemethodcritical">test_logger.yml::basic_logger_usage[method=critical]</h3>
<details><summary> <pre>test_logger.yml::basic_logger_usage[method=critical]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:14: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:3: note: Revealed type is "Any"          (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:3: note: Revealed type is "loguru.Logger" (diff)
E     main:4: note: Revealed type is "None"         (diff)
E   Alignment of first line difference:
E     E: main:3: note: Revealed type is "loguru.Logger"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlusing_log_functionlevelinfo">test_logger.yml::using_log_function[level='INFO']</h3>
<details><summary> <pre>test_logger.yml::using_log_function[level='INFO']</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:24: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Output is not expected: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     (empty)
</pre>
</details>
<h3 id="test_loggerymlusing_log_functionlevel30">test_logger.yml::using_log_function[level=30]</h3>
<details><summary> <pre>test_logger.yml::using_log_function[level=30]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:24: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Output is not expected: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     (empty)
</pre>
</details>
<h3 id="test_loggerymlusing_logging_arguments">test_logger.yml::using_logging_arguments</h3>
<details><summary> <pre>test_logger.yml::using_logging_arguments</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:29: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Output is not expected: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     (empty)
</pre>
</details>
<h3 id="test_loggerymllogging_non_stringmessage123">test_logger.yml::logging_non_string[message=123]</h3>
<details><summary> <pre>test_logger.yml::logging_non_string[message=123]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:38: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Output is not expected: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     (empty)
</pre>
</details>
<h3 id="test_loggerymllogging_non_stringmessagedictfoo456">test_logger.yml::logging_non_string[message=dict(foo=456)]</h3>
<details><summary> <pre>test_logger.yml::logging_non_string[message=dict(foo=456)]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:38: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Output is not expected: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     (empty)
</pre>
</details>
<h3 id="test_loggerymllogging_non_stringmessageobject">test_logger.yml::logging_non_string[message=object()]</h3>
<details><summary> <pre>test_logger.yml::logging_non_string[message=object()]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:38: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Output is not expected: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     (empty)
</pre>
</details>
<h3 id="test_loggerymladd_sinksinksysstderr">test_logger.yml::add_sink[sink=sys.stderr]</h3>
<details><summary> <pre>test_logger.yml::add_sink[sink=sys.stderr]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:55: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:2: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:2: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:6: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:6: note: Revealed type is "builtins.int" (diff)
E   Alignment of first line difference:
E     E: main:6: note: Revealed type is "builtins.int"...
E     A: main:2: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymladd_sinksinktesttxt">test_logger.yml::add_sink[sink='test.txt']</h3>
<details><summary> <pre>test_logger.yml::add_sink[sink='test.txt']</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:55: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:2: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:2: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:6: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:6: note: Revealed type is "builtins.int" (diff)
E   Alignment of first line difference:
E     E: main:6: note: Revealed type is "builtins.int"...
E     A: main:2: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymladd_sinksinkpathfilelog">test_logger.yml::add_sink[sink=Path('file.log')]</h3>
<details><summary> <pre>test_logger.yml::add_sink[sink=Path('file.log')]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:55: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:2: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:2: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:6: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:6: note: Revealed type is "builtins.int" (diff)
E   Alignment of first line difference:
E     E: main:6: note: Revealed type is "builtins.int"...
E     A: main:2: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymladd_sinksinklambda-m-none">test_logger.yml::add_sink[sink=lambda m: None]</h3>
<details><summary> <pre>test_logger.yml::add_sink[sink=lambda m: None]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:55: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:2: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:2: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:6: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:6: note: Revealed type is "builtins.int" (diff)
E   Alignment of first line difference:
E     E: main:6: note: Revealed type is "builtins.int"...
E     A: main:2: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymladd_sinksinkstreamhandler">test_logger.yml::add_sink[sink=StreamHandler()]</h3>
<details><summary> <pre>test_logger.yml::add_sink[sink=StreamHandler()]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:55: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:2: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:2: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:6: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:6: note: Revealed type is "builtins.int" (diff)
E   Alignment of first line difference:
E     E: main:6: note: Revealed type is "builtins.int"...
E     A: main:2: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlbasic_sink_optionsformatmessagefiltermodulecontextfork">test_logger.yml::basic_sink_options[format='{message}',filter='module',context='fork']</h3>
<details><summary> <pre>test_logger.yml::basic_sink_options[format='{message}',filter='module',context='fork']</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:67: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Output is not expected: 
E   Actual:
E     main:3: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:3: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     (empty)
</pre>
</details>
<h3 id="test_loggerymlbasic_sink_optionsformatlambda-r-messagenfilterlambda-r-truecontextget_contextfork">test_logger.yml::basic_sink_options[format=lambda r: '{message}\n',filter=lambda r: True,context=get_context('fork')]</h3>
<details><summary> <pre>test_logger.yml::basic_sink_options[format=lambda r: '{message}\n',filter=lambda r: True,context=get_context('fork')]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:67: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Output is not expected: 
E   Actual:
E     main:3: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:3: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     (empty)
</pre>
</details>
<h3 id="test_loggerymlfile_sink_options">test_logger.yml::file_sink_options</h3>
<details><summary> <pre>test_logger.yml::file_sink_options</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:85: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Output is not expected: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     (empty)
</pre>
</details>
<h3 id="test_loggerymlasync_sink_options">test_logger.yml::async_sink_options</h3>
<details><summary> <pre>test_logger.yml::async_sink_options</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:101: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Output is not expected: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     (empty)
</pre>
</details>
<h3 id="test_loggerymlremove_sink">test_logger.yml::remove_sink</h3>
<details><summary> <pre>test_logger.yml::remove_sink</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:113: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Output is not expected: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     (empty)
</pre>
</details>
<h3 id="test_loggerymlawait_completion">test_logger.yml::await_completion</h3>
<details><summary> <pre>test_logger.yml::await_completion</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:123: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:5: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:5: note: Revealed type is "typing.Awaitable[None]" (diff)
E   Alignment of first line difference:
E     E: main:5: note: Revealed type is "typing.Awaitable[None]"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlcatch_as_decorator_with_parentheses">test_logger.yml::catch_as_decorator_with_parentheses</h3>
<details><summary> <pre>test_logger.yml::catch_as_decorator_with_parentheses</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:134: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:6: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:6: note: Revealed type is "def (a: builtins.int, b: builtins.int) -> builtins.int" (diff)
E   Alignment of first line difference:
E     E: main:6: note: Revealed type is "def (a: builtins.int, b: builtins.int) -...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlcatch_as_decorator_without_parentheses">test_logger.yml::catch_as_decorator_without_parentheses</h3>
<details><summary> <pre>test_logger.yml::catch_as_decorator_without_parentheses</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:145: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:6: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:6: note: Revealed type is "def (a: builtins.int, b: builtins.int) -> builtins.int" (diff)
E   Alignment of first line difference:
E     E: main:6: note: Revealed type is "def (a: builtins.int, b: builtins.int) -...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlcatch_as_context_manager">test_logger.yml::catch_as_context_manager</h3>
<details><summary> <pre>test_logger.yml::catch_as_context_manager</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:155: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:5: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:5: note: Revealed type is "loguru.Catcher" (diff)
E   Alignment of first line difference:
E     E: main:5: note: Revealed type is "loguru.Catcher"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlopt">test_logger.yml::opt</h3>
<details><summary> <pre>test_logger.yml::opt</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:164: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:4: note: Revealed type is "loguru.Logger" (diff)
E   Alignment of first line difference:
E     E: main:4: note: Revealed type is "loguru.Logger"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlbind">test_logger.yml::bind</h3>
<details><summary> <pre>test_logger.yml::bind</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:173: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:4: note: Revealed type is "loguru.Logger" (diff)
E   Alignment of first line difference:
E     E: main:4: note: Revealed type is "loguru.Logger"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlpatch">test_logger.yml::patch</h3>
<details><summary> <pre>test_logger.yml::patch</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:182: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:4: note: Revealed type is "loguru.Logger" (diff)
E   Alignment of first line difference:
E     E: main:4: note: Revealed type is "loguru.Logger"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlcontextualize">test_logger.yml::contextualize</h3>
<details><summary> <pre>test_logger.yml::contextualize</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:192: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:5: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:5: note: Revealed type is "loguru.Contextualizer" (diff)
E   Alignment of first line difference:
E     E: main:5: note: Revealed type is "loguru.Contextualizer"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymllevel_get">test_logger.yml::level_get</h3>
<details><summary> <pre>test_logger.yml::level_get</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:202: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:4: note: Revealed type is "tuple[builtins.str, builtins.int, builtins.str, builtins.str, fallback=loguru.Level]" (diff)
E   Alignment of first line difference:
E     E: main:4: note: Revealed type is "tuple[builtins.str, builtins.int, builti...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymllevel_set">test_logger.yml::level_set</h3>
<details><summary> <pre>test_logger.yml::level_set</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:222: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:4: note: Revealed type is "tuple[builtins.str, builtins.int, builtins.str, builtins.str, fallback=loguru.Level]" (diff)
E   Alignment of first line difference:
E     E: main:4: note: Revealed type is "tuple[builtins.str, builtins.int, builti...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymllevel_update">test_logger.yml::level_update</h3>
<details><summary> <pre>test_logger.yml::level_update</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:242: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:4: note: Revealed type is "tuple[builtins.str, builtins.int, builtins.str, builtins.str, fallback=loguru.Level]" (diff)
E   Alignment of first line difference:
E     E: main:4: note: Revealed type is "tuple[builtins.str, builtins.int, builti...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlenable_and_disable_logger">test_logger.yml::enable_and_disable_logger</h3>
<details><summary> <pre>test_logger.yml::enable_and_disable_logger</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:257: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Output is not expected: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     (empty)
</pre>
</details>
<h3 id="test_loggerymlconfigure">test_logger.yml::configure</h3>
<details><summary> <pre>test_logger.yml::configure</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:272: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:9: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:9: note: Revealed type is "builtins.list[builtins.int]" (diff)
E   Alignment of first line difference:
E     E: main:9: note: Revealed type is "builtins.list[builtins.int]"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlparse">test_logger.yml::parse</h3>
<details><summary> <pre>test_logger.yml::parse</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:282: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:5: note: Revealed type is "Any"          (diff)
E     main:6: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:5: note: Revealed type is "typing.Generator[builtins.dict[builtins.str, Any], None, None]" (diff)
E     main:6: note: Revealed type is "builtins.dict[builtins.str, Any]" (diff)
E   Alignment of first line difference:
E     E: main:5: note: Revealed type is "typing.Generator[builtins.dict[builtins....
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlinvalid_add_argument">test_logger.yml::invalid_add_argument</h3>
<details><summary> <pre>test_logger.yml::invalid_add_argument</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:292: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru" (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     main:2: error: No overload variant of "add" of "Logger" matches argument types "Callable[[Any], None]", "int" (diff)
E     main:2: note: Possible overload variants:     (diff)
E     main:2: note:     def add(self, sink: TextIO | Writable | Callable[[Message], None] | Handler, *, level: str | int = ..., format: str | Callable[[Record], str] = ..., filter: str | Callable[[Record], bool] | dict[str | None, str | int | bool] | None = ..., colorize: bool | None = ..., serialize: bool = ..., backtrace: bool = ..., diagnose: bool = ..., enqueue: bool = ..., context: str | BaseContext | None = ..., catch: bool = ...) -> int (diff)
E     main:2: note:     def add(self, sink: Callable[[Message], Awaitable[None]], *, level: str | int = ..., format: str | Callable[[Record], str] = ..., filter: str | Callable[[Record], bool] | dict[str | None, str | int | bool] | None = ..., colorize: bool | None = ..., serialize: bool = ..., backtrace: bool = ..., diagnose: bool = ..., enqueue: bool = ..., context: str | BaseContext | None = ..., catch: bool = ..., loop: AbstractEventLoop | None = ...) -> int (diff)
E     main:2: note:     def add(self, sink: str | PathLike[str], *, level: str | int = ..., format: str | Callable[[Record], str] = ..., filter: str | Callable[[Record], bool] | dict[str | None, str | int | bool] | None = ..., colorize: bool | None = ..., serialize: bool = ..., backtrace: bool = ..., diagnose: bool = ..., enqueue: bool = ..., context: str | BaseContext | None = ..., catch: bool = ..., rotation: str | int | time | timedelta | Callable[[Message, TextIO], bool] | None = ..., retention: str | int | timedelta | Callable[[list[str]], None] | None = ..., compression: str | Callable[[str], None] | None = ..., delay: bool = ..., watch: bool = ..., mode: str = ..., buffering: int = ..., encoding: str = ..., **kwargs: Any) -> int (diff)
E   Alignment of first line difference:
E     E: main:2: error: No overload variant of "add" of "Logger" matches argument...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlinvalid_logged_object_formatting">test_logger.yml::invalid_logged_object_formatting</h3>
<details><summary> <pre>test_logger.yml::invalid_logged_object_formatting</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:334: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru" (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     main:2: error: No overload variant of "info" of "Logger" matches argument types "int", "int" (diff)
E     main:2: note: Possible overload variants:     (diff)
E     main:2: note:     def info(__self, str, /, *args: Any, **kwargs: Any) -> None (diff)
E     main:2: note:     def info(__self, Any, /) -> None (diff)
E   Alignment of first line difference:
E     E: main:2: error: No overload variant of "info" of "Logger" matches argumen...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlinvalid_configuration">test_logger.yml::invalid_configuration</h3>
<details><summary> <pre>test_logger.yml::invalid_configuration</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:362: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru" (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     main:4: error: Extra key "baz" for TypedDict "LevelConfig" (diff)
E     main:5: error: Argument "patcher" to "configure" of "Logger" has incompatible type "int"; expected "Callable[[Record], None] | None" (diff)
E     main:6: error: List item 0 has incompatible type "dict[str, str]"; expected "tuple[str | None, bool]" (diff)
E     main:7: error: Argument "extra" to "configure" of "Logger" has incompatible type "list[<nothing>]"; expected "dict[Any, Any] | None" (diff)
E   Alignment of first line difference:
E     E: main:4: error: Extra key "baz" for TypedDict "LevelConfig"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/loguru/_asyncio_loop.py b/loguru/_asyncio_loop.py</span>
<span class="gh">index 0cf1f06..0631efa 100644</span>
<span class="gd">--- a/loguru/_asyncio_loop.py</span>
<span class="gi">+++ b/loguru/_asyncio_loop.py</span>
<span class="gu">@@ -1,3 +1,21 @@</span>
<span class="w"> </span>import asyncio
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="gi">+def load_loop_functions():</span>
<span class="gi">+    if sys.version_info &gt;= (3, 7):</span>
<span class="gi">+        # Python 3.7+ has get_running_loop()</span>
<span class="gi">+        def get_task_loop(task):</span>
<span class="gi">+            return task.get_loop()</span>
<span class="gi">+        return get_task_loop, asyncio.get_running_loop</span>
<span class="gi">+    else:</span>
<span class="gi">+        # For Python &lt; 3.7</span>
<span class="gi">+        def get_task_loop(task):</span>
<span class="gi">+            return task._loop</span>
<span class="gi">+        def get_running_loop():</span>
<span class="gi">+            loop = asyncio._get_running_loop()</span>
<span class="gi">+            if loop is None:</span>
<span class="gi">+                raise RuntimeError(&#39;no running event loop&#39;)</span>
<span class="gi">+            return loop</span>
<span class="gi">+        return get_task_loop, get_running_loop</span>
<span class="gi">+</span>
<span class="w"> </span>get_task_loop, get_running_loop = load_loop_functions()
\ No newline at end of file
<span class="gh">diff --git a/loguru/_better_exceptions.py b/loguru/_better_exceptions.py</span>
<span class="gh">index 7a7234c..07217d5 100644</span>
<span class="gd">--- a/loguru/_better_exceptions.py</span>
<span class="gi">+++ b/loguru/_better_exceptions.py</span>
<span class="gu">@@ -10,10 +10,12 @@ import sysconfig</span>
<span class="w"> </span>import tokenize
<span class="w"> </span>import traceback
<span class="w"> </span>if sys.version_info &gt;= (3, 11):
<span class="gi">+    from builtins import ExceptionGroup</span>
<span class="w"> </span>else:
<span class="w"> </span>    try:
<span class="w"> </span>        from exceptiongroup import ExceptionGroup
<span class="w"> </span>    except ImportError:
<span class="gi">+        ExceptionGroup = None</span>

<span class="w"> </span>class SyntaxHighlighter:
<span class="w"> </span>    _default_style = {&#39;comment&#39;: &#39;\x1b[30m\x1b[1m{}\x1b[0m&#39;, &#39;keyword&#39;: &#39;\x1b[35m\x1b[1m{}\x1b[0m&#39;, &#39;builtin&#39;: &#39;\x1b[1m{}\x1b[0m&#39;, &#39;string&#39;: &#39;\x1b[36m{}\x1b[0m&#39;, &#39;number&#39;: &#39;\x1b[34m\x1b[1m{}\x1b[0m&#39;, &#39;operator&#39;: &#39;\x1b[35m\x1b[1m{}\x1b[0m&#39;, &#39;punctuation&#39;: &#39;\x1b[1m{}\x1b[0m&#39;, &#39;constant&#39;: &#39;\x1b[36m\x1b[1m{}\x1b[0m&#39;, &#39;identifier&#39;: &#39;\x1b[1m{}\x1b[0m&#39;, &#39;other&#39;: &#39;{}&#39;}
<span class="gh">diff --git a/loguru/_colorama.py b/loguru/_colorama.py</span>
<span class="gh">index ef7df8a..37d7715 100644</span>
<span class="gd">--- a/loguru/_colorama.py</span>
<span class="gi">+++ b/loguru/_colorama.py</span>
<span class="gu">@@ -1,2 +1,23 @@</span>
<span class="w"> </span>import os
<span class="gd">-import sys</span>
\ No newline at end of file
<span class="gi">+import sys</span>
<span class="gi">+</span>
<span class="gi">+def should_colorize(stream):</span>
<span class="gi">+    try:</span>
<span class="gi">+        return stream.isatty()</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+def should_wrap(stream):</span>
<span class="gi">+    if not should_colorize(stream):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;PYCHARM_HOSTED&#39; in os.environ:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if sys.platform == &#39;win32&#39;:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;TERM&#39; in os.environ and os.environ[&#39;TERM&#39;] == &#39;dumb&#39;:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    return True</span>
\ No newline at end of file
<span class="gh">diff --git a/loguru/_colorizer.py b/loguru/_colorizer.py</span>
<span class="gh">index 1f06ad9..7b032f8 100644</span>
<span class="gd">--- a/loguru/_colorizer.py</span>
<span class="gi">+++ b/loguru/_colorizer.py</span>
<span class="gu">@@ -1,6 +1,10 @@</span>
<span class="w"> </span>import re
<span class="w"> </span>from string import Formatter

<span class="gi">+def ansi_escape(codes):</span>
<span class="gi">+    pattern = &#39;|&#39;.join(re.escape(k) for k in sorted(codes, key=len, reverse=True))</span>
<span class="gi">+    return re.compile(f&#39;({pattern})&#39;)</span>
<span class="gi">+</span>
<span class="w"> </span>class Style:
<span class="w"> </span>    RESET_ALL = 0
<span class="w"> </span>    BOLD = 1
<span class="gu">@@ -64,9 +68,214 @@ class AnsiParser:</span>
<span class="w"> </span>    _regex_tag = re.compile(&#39;\\\\?&lt;/?((?:[fb]g\\s)?[^&lt;&gt;\\s]*)&gt;&#39;)

<span class="w"> </span>    def __init__(self):
<span class="gi">+        self.reset()</span>
<span class="gi">+</span>
<span class="gi">+    def reset(self):</span>
<span class="w"> </span>        self._tokens = []
<span class="w"> </span>        self._tags = []
<span class="w"> </span>        self._color_tokens = []
<span class="gi">+        self._text = []</span>
<span class="gi">+</span>
<span class="gi">+    def feed(self, text):</span>
<span class="gi">+        pos = 0</span>
<span class="gi">+        for match in self._regex_tag.finditer(text):</span>
<span class="gi">+            start, end = match.span()</span>
<span class="gi">+            if start &gt; pos:</span>
<span class="gi">+                self._tokens.append((TokenType.TEXT, text[pos:start]))</span>
<span class="gi">+            if match.group()[0] == &#39;\\&#39;:</span>
<span class="gi">+                self._tokens.append((TokenType.TEXT, match.group()[1:]))</span>
<span class="gi">+            else:</span>
<span class="gi">+                tag = match.group(1)</span>
<span class="gi">+                if tag.startswith(&#39;/&#39;):</span>
<span class="gi">+                    if not self._tags:</span>
<span class="gi">+                        raise ValueError(&quot;Closing tag &#39;%s&#39; found without corresponding opening tag&quot; % tag)</span>
<span class="gi">+                    expected_tag = self._tags.pop()</span>
<span class="gi">+                    if tag[1:] != expected_tag:</span>
<span class="gi">+                        raise ValueError(&quot;Closing tag &#39;%s&#39; does not match opening tag &#39;%s&#39;&quot; % (tag, expected_tag))</span>
<span class="gi">+                    if expected_tag in (&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;yellow&#39;, &#39;magenta&#39;, &#39;cyan&#39;, &#39;white&#39;, &#39;black&#39;):</span>
<span class="gi">+                        tag = &#39;/fg&#39;</span>
<span class="gi">+                    elif expected_tag.startswith(&#39;fg &#39;):</span>
<span class="gi">+                        tag = &#39;/fg&#39;</span>
<span class="gi">+                    elif expected_tag.startswith(&#39;bg &#39;):</span>
<span class="gi">+                        tag = &#39;/bg&#39;</span>
<span class="gi">+                    self._tokens.append((TokenType.CLOSING, tag))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if tag in (&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;yellow&#39;, &#39;magenta&#39;, &#39;cyan&#39;, &#39;white&#39;, &#39;black&#39;):</span>
<span class="gi">+                        self._tags.append(tag)</span>
<span class="gi">+                        tag = &#39;fg &#39; + tag</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        self._tags.append(tag)</span>
<span class="gi">+                    self._tokens.append((TokenType.ANSI, tag))</span>
<span class="gi">+            pos = end</span>
<span class="gi">+        if pos &lt; len(text):</span>
<span class="gi">+            self._tokens.append((TokenType.TEXT, text[pos:]))</span>
<span class="gi">+        return self._tokens</span>
<span class="gi">+</span>
<span class="gi">+    def done(self, strict=True):</span>
<span class="gi">+        if strict and self._tags:</span>
<span class="gi">+            raise ValueError(&quot;Unclosed tags: %s&quot; % &#39;, &#39;.join(self._tags))</span>
<span class="gi">+        tokens = self._tokens</span>
<span class="gi">+        self.reset()</span>
<span class="gi">+        return tokens</span>
<span class="gi">+</span>
<span class="gi">+    def strip(self, tokens):</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for token_type, text in tokens:</span>
<span class="gi">+            if token_type == TokenType.TEXT:</span>
<span class="gi">+                result.append(text)</span>
<span class="gi">+        return &#39;&#39;.join(result)</span>
<span class="gi">+</span>
<span class="gi">+    def colorize(self, tokens, style):</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for token_type, text in tokens:</span>
<span class="gi">+            if token_type == TokenType.TEXT:</span>
<span class="gi">+                result.append(text)</span>
<span class="gi">+            elif token_type == TokenType.ANSI:</span>
<span class="gi">+                if text.startswith(&#39;fg &#39;):</span>
<span class="gi">+                    color = getattr(Fore, text[3:].upper(), None)</span>
<span class="gi">+                    if color is not None:</span>
<span class="gi">+                        result.append(&#39;\033[%sm&#39; % color)</span>
<span class="gi">+                elif text.startswith(&#39;bg &#39;):</span>
<span class="gi">+                    color = getattr(Back, text[3:].upper(), None)</span>
<span class="gi">+                    if color is not None:</span>
<span class="gi">+                        result.append(&#39;\033[%sm&#39; % color)</span>
<span class="gi">+                elif text in (&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;yellow&#39;, &#39;magenta&#39;, &#39;cyan&#39;, &#39;white&#39;, &#39;black&#39;):</span>
<span class="gi">+                    color = getattr(Fore, text.upper(), None)</span>
<span class="gi">+                    if color is not None:</span>
<span class="gi">+                        result.append(&#39;\033[%sm&#39; % color)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    style_code = getattr(Style, text.upper(), None)</span>
<span class="gi">+                    if style_code is not None:</span>
<span class="gi">+                        result.append(&#39;\033[%sm&#39; % style_code)</span>
<span class="gi">+            elif token_type == TokenType.CLOSING:</span>
<span class="gi">+                if text == &#39;/fg&#39;:</span>
<span class="gi">+                    result.append(&#39;\033[%sm&#39; % Fore.RESET)</span>
<span class="gi">+                elif text == &#39;/bg&#39;:</span>
<span class="gi">+                    result.append(&#39;\033[%sm&#39; % Back.RESET)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    result.append(&#39;\033[%sm&#39; % Style.RESET_ALL)</span>
<span class="gi">+        return &#39;&#39;.join(result)</span>
<span class="gi">+</span>
<span class="gi">+    def done(self, strict=True):</span>
<span class="gi">+        if strict and self._tags:</span>
<span class="gi">+            raise ValueError(&quot;Unclosed tags: %s&quot; % &#39;, &#39;.join(self._tags))</span>
<span class="gi">+        tokens = self._tokens</span>
<span class="gi">+        self.reset()</span>
<span class="gi">+        return tokens</span>
<span class="gi">+</span>
<span class="gi">+    def strip(self, tokens):</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for token_type, text in tokens:</span>
<span class="gi">+            if token_type == TokenType.TEXT:</span>
<span class="gi">+                result.append(text)</span>
<span class="gi">+        return &#39;&#39;.join(result)</span>
<span class="gi">+</span>
<span class="gi">+    def colorize(self, tokens, style):</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for token_type, text in tokens:</span>
<span class="gi">+            if token_type == TokenType.TEXT:</span>
<span class="gi">+                result.append(text)</span>
<span class="gi">+            elif token_type == TokenType.ANSI:</span>
<span class="gi">+                if text.startswith(&#39;fg &#39;):</span>
<span class="gi">+                    color = getattr(Fore, text[3:].upper(), None)</span>
<span class="gi">+                    if color is not None:</span>
<span class="gi">+                        result.append(&#39;\033[%sm&#39; % color)</span>
<span class="gi">+                elif text.startswith(&#39;bg &#39;):</span>
<span class="gi">+                    color = getattr(Back, text[3:].upper(), None)</span>
<span class="gi">+                    if color is not None:</span>
<span class="gi">+                        result.append(&#39;\033[%sm&#39; % color)</span>
<span class="gi">+                elif text in (&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;yellow&#39;, &#39;magenta&#39;, &#39;cyan&#39;, &#39;white&#39;, &#39;black&#39;):</span>
<span class="gi">+                    color = getattr(Fore, text.upper(), None)</span>
<span class="gi">+                    if color is not None:</span>
<span class="gi">+                        result.append(&#39;\033[%sm&#39; % color)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    style_code = getattr(Style, text.upper(), None)</span>
<span class="gi">+                    if style_code is not None:</span>
<span class="gi">+                        result.append(&#39;\033[%sm&#39; % style_code)</span>
<span class="gi">+            elif token_type == TokenType.CLOSING:</span>
<span class="gi">+                if text == &#39;/fg&#39;:</span>
<span class="gi">+                    result.append(&#39;\033[%sm&#39; % Fore.RESET)</span>
<span class="gi">+                elif text == &#39;/bg&#39;:</span>
<span class="gi">+                    result.append(&#39;\033[%sm&#39; % Back.RESET)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    result.append(&#39;\033[%sm&#39; % Style.RESET_ALL)</span>
<span class="gi">+        return &#39;&#39;.join(result)</span>
<span class="gi">+</span>
<span class="gi">+    def strip(self, tokens):</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for token_type, text in tokens:</span>
<span class="gi">+            if token_type == TokenType.TEXT:</span>
<span class="gi">+                result.append(text)</span>
<span class="gi">+        return &#39;&#39;.join(result)</span>
<span class="gi">+</span>
<span class="gi">+    def colorize(self, tokens, style):</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for token_type, text in tokens:</span>
<span class="gi">+            if token_type == TokenType.TEXT:</span>
<span class="gi">+                result.append(text)</span>
<span class="gi">+            elif token_type == TokenType.ANSI:</span>
<span class="gi">+                if text.startswith(&#39;fg &#39;):</span>
<span class="gi">+                    color = getattr(Fore, text[3:].upper(), None)</span>
<span class="gi">+                    if color is not None:</span>
<span class="gi">+                        result.append(&#39;\033[%sm&#39; % color)</span>
<span class="gi">+                elif text.startswith(&#39;bg &#39;):</span>
<span class="gi">+                    color = getattr(Back, text[3:].upper(), None)</span>
<span class="gi">+                    if color is not None:</span>
<span class="gi">+                        result.append(&#39;\033[%sm&#39; % color)</span>
<span class="gi">+                elif text in (&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;yellow&#39;, &#39;magenta&#39;, &#39;cyan&#39;, &#39;white&#39;, &#39;black&#39;):</span>
<span class="gi">+                    color = getattr(Fore, text.upper(), None)</span>
<span class="gi">+                    if color is not None:</span>
<span class="gi">+                        result.append(&#39;\033[%sm&#39; % color)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    style_code = getattr(Style, text.upper(), None)</span>
<span class="gi">+                    if style_code is not None:</span>
<span class="gi">+                        result.append(&#39;\033[%sm&#39; % style_code)</span>
<span class="gi">+            elif token_type == TokenType.CLOSING:</span>
<span class="gi">+                if text == &#39;/fg&#39;:</span>
<span class="gi">+                    result.append(&#39;\033[%sm&#39; % Fore.RESET)</span>
<span class="gi">+                elif text == &#39;/bg&#39;:</span>
<span class="gi">+                    result.append(&#39;\033[%sm&#39; % Back.RESET)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    result.append(&#39;\033[%sm&#39; % Style.RESET_ALL)</span>
<span class="gi">+        return &#39;&#39;.join(result)</span>
<span class="gi">+</span>
<span class="gi">+    def strip(self, tokens):</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for token_type, text in tokens:</span>
<span class="gi">+            if token_type == TokenType.TEXT:</span>
<span class="gi">+                result.append(text)</span>
<span class="gi">+        return &#39;&#39;.join(result)</span>
<span class="gi">+</span>
<span class="gi">+    def colorize(self, tokens, style):</span>
<span class="gi">+        result = []</span>
<span class="gi">+        for token_type, text in tokens:</span>
<span class="gi">+            if token_type == TokenType.TEXT:</span>
<span class="gi">+                result.append(text)</span>
<span class="gi">+            elif token_type == TokenType.ANSI:</span>
<span class="gi">+                if text.startswith(&#39;fg &#39;):</span>
<span class="gi">+                    color = getattr(Fore, text[3:].upper(), None)</span>
<span class="gi">+                    if color is not None:</span>
<span class="gi">+                        result.append(&#39;\033[%sm&#39; % color)</span>
<span class="gi">+                elif text.startswith(&#39;bg &#39;):</span>
<span class="gi">+                    color = getattr(Back, text[3:].upper(), None)</span>
<span class="gi">+                    if color is not None:</span>
<span class="gi">+                        result.append(&#39;\033[%sm&#39; % color)</span>
<span class="gi">+                elif text in (&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;yellow&#39;, &#39;magenta&#39;, &#39;cyan&#39;, &#39;white&#39;, &#39;black&#39;):</span>
<span class="gi">+                    color = getattr(Fore, text.upper(), None)</span>
<span class="gi">+                    if color is not None:</span>
<span class="gi">+                        result.append(&#39;\033[%sm&#39; % color)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    style_code = getattr(Style, text.upper(), None)</span>
<span class="gi">+                    if style_code is not None:</span>
<span class="gi">+                        result.append(&#39;\033[%sm&#39; % style_code)</span>
<span class="gi">+            elif token_type == TokenType.CLOSING:</span>
<span class="gi">+                if text == &#39;/fg&#39;:</span>
<span class="gi">+                    result.append(&#39;\033[%sm&#39; % Fore.RESET)</span>
<span class="gi">+                elif text == &#39;/bg&#39;:</span>
<span class="gi">+                    result.append(&#39;\033[%sm&#39; % Back.RESET)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    result.append(&#39;\033[%sm&#39; % Style.RESET_ALL)</span>
<span class="gi">+        return &#39;&#39;.join(result)</span>

<span class="w"> </span>class ColoringMessage(str):
<span class="w"> </span>    __fields__ = (&#39;_messages&#39;,)
<span class="gu">@@ -87,4 +296,33 @@ class ColoredFormat:</span>
<span class="w"> </span>        self._messages_color_tokens = messages_color_tokens

<span class="w"> </span>class Colorizer:
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def ansify(code):</span>
<span class="gi">+        if not code:</span>
<span class="gi">+            return &#39;&#39;</span>
<span class="gi">+        codes = []</span>
<span class="gi">+        for part in code.split():</span>
<span class="gi">+            if part.startswith(&#39;&lt;&#39;) and part.endswith(&#39;&gt;&#39;):</span>
<span class="gi">+                part = part[1:-1]</span>
<span class="gi">+                if part.startswith(&#39;/&#39;):</span>
<span class="gi">+                    part = part[1:]</span>
<span class="gi">+                    if part == &#39;fg&#39;:</span>
<span class="gi">+                        codes.append(str(Fore.RESET))</span>
<span class="gi">+                    elif part == &#39;bg&#39;:</span>
<span class="gi">+                        codes.append(str(Back.RESET))</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        codes.append(str(Style.RESET_ALL))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if part.startswith(&#39;fg &#39;):</span>
<span class="gi">+                        color = getattr(Fore, part[3:].upper(), None)</span>
<span class="gi">+                        if color is not None:</span>
<span class="gi">+                            codes.append(str(color))</span>
<span class="gi">+                    elif part.startswith(&#39;bg &#39;):</span>
<span class="gi">+                        color = getattr(Back, part[3:].upper(), None)</span>
<span class="gi">+                        if color is not None:</span>
<span class="gi">+                            codes.append(str(color))</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        style = getattr(Style, part.upper(), None)</span>
<span class="gi">+                        if style is not None:</span>
<span class="gi">+                            codes.append(str(style))</span>
<span class="gi">+        return &#39;\033[&#39; + &#39;;&#39;.join(codes) + &#39;m&#39; if codes else &#39;&#39;</span>
\ No newline at end of file
<span class="gh">diff --git a/loguru/_contextvars.py b/loguru/_contextvars.py</span>
<span class="gh">index d7c9ac5..9186647 100644</span>
<span class="gd">--- a/loguru/_contextvars.py</span>
<span class="gi">+++ b/loguru/_contextvars.py</span>
<span class="gu">@@ -1,2 +1,28 @@</span>
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="gi">+def load_contextvar_class():</span>
<span class="gi">+    if sys.version_info &gt;= (3, 7):</span>
<span class="gi">+        from contextvars import ContextVar</span>
<span class="gi">+        return ContextVar</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            from aiocontextvars import ContextVar</span>
<span class="gi">+            return ContextVar</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            class ContextVar:</span>
<span class="gi">+                def __init__(self, name, *, default=None):</span>
<span class="gi">+                    self._name = name</span>
<span class="gi">+                    self._default = default</span>
<span class="gi">+                    self._value = default</span>
<span class="gi">+</span>
<span class="gi">+                def get(self, default=None):</span>
<span class="gi">+                    return self._value if self._value is not None else default</span>
<span class="gi">+</span>
<span class="gi">+                def set(self, value):</span>
<span class="gi">+                    old_value = self._value</span>
<span class="gi">+                    self._value = value</span>
<span class="gi">+                    return old_value</span>
<span class="gi">+</span>
<span class="gi">+            return ContextVar</span>
<span class="gi">+</span>
<span class="w"> </span>ContextVar = load_contextvar_class()
\ No newline at end of file
<span class="gh">diff --git a/loguru/_ctime_functions.py b/loguru/_ctime_functions.py</span>
<span class="gh">index 3cf79c2..13f1e4b 100644</span>
<span class="gd">--- a/loguru/_ctime_functions.py</span>
<span class="gi">+++ b/loguru/_ctime_functions.py</span>
<span class="gu">@@ -1,2 +1,29 @@</span>
<span class="w"> </span>import os
<span class="gi">+import sys</span>
<span class="gi">+import platform</span>
<span class="gi">+</span>
<span class="gi">+def load_ctime_functions():</span>
<span class="gi">+    if platform.system() == &#39;Windows&#39;:</span>
<span class="gi">+        try:</span>
<span class="gi">+            from win32_setctime import setctime</span>
<span class="gi">+            def get_ctime(filepath):</span>
<span class="gi">+                return os.path.getctime(filepath)</span>
<span class="gi">+            def set_ctime(filepath, timestamp):</span>
<span class="gi">+                setctime(filepath, timestamp)</span>
<span class="gi">+            return get_ctime, set_ctime</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    def get_ctime(filepath):</span>
<span class="gi">+        try:</span>
<span class="gi">+            stat = os.stat(filepath)</span>
<span class="gi">+            return stat.st_birthtime  # macOS</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            return stat.st_mtime  # Linux and others</span>
<span class="gi">+</span>
<span class="gi">+    def set_ctime(filepath, timestamp):</span>
<span class="gi">+        os.utime(filepath, (timestamp, os.path.getmtime(filepath)))</span>
<span class="gi">+</span>
<span class="gi">+    return get_ctime, set_ctime</span>
<span class="gi">+</span>
<span class="w"> </span>get_ctime, set_ctime = load_ctime_functions()
\ No newline at end of file
<span class="gh">diff --git a/loguru/_datetime.py b/loguru/_datetime.py</span>
<span class="gh">index 63d729a..f55149d 100644</span>
<span class="gd">--- a/loguru/_datetime.py</span>
<span class="gi">+++ b/loguru/_datetime.py</span>
<span class="gu">@@ -3,6 +3,15 @@ from calendar import day_abbr, day_name, month_abbr, month_name</span>
<span class="w"> </span>from datetime import datetime as datetime_
<span class="w"> </span>from datetime import timedelta, timezone
<span class="w"> </span>from time import localtime, strftime
<span class="gi">+</span>
<span class="gi">+def aware_now():</span>
<span class="gi">+    now = datetime_.now()</span>
<span class="gi">+    if now.tzinfo is None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            now = now.astimezone()  # Use system timezone</span>
<span class="gi">+        except ValueError:  # If system timezone is not set</span>
<span class="gi">+            now = now.replace(tzinfo=timezone.utc)</span>
<span class="gi">+    return now</span>
<span class="w"> </span>tokens = &#39;H{1,2}|h{1,2}|m{1,2}|s{1,2}|S+|YYYY|YY|M{1,4}|D{1,4}|Z{1,2}|zz|A|X|x|E|Q|dddd|ddd|d&#39;
<span class="w"> </span>pattern = re.compile(&#39;(?:{0})|\\[(?:{0}|!UTC|)\\]&#39;.format(tokens))

<span class="gh">diff --git a/loguru/_defaults.py b/loguru/_defaults.py</span>
<span class="gh">index cd2e326..35f9517 100644</span>
<span class="gd">--- a/loguru/_defaults.py</span>
<span class="gi">+++ b/loguru/_defaults.py</span>
<span class="gu">@@ -1,4 +1,13 @@</span>
<span class="w"> </span>from os import environ
<span class="gi">+</span>
<span class="gi">+def env(key, type_, default):</span>
<span class="gi">+    if key not in environ:</span>
<span class="gi">+        return default</span>
<span class="gi">+    value = environ[key]</span>
<span class="gi">+    if type_ == bool:</span>
<span class="gi">+        return value.lower() in (&#39;true&#39;, &#39;1&#39;, &#39;yes&#39;, &#39;on&#39;)</span>
<span class="gi">+    return type_(value)</span>
<span class="gi">+</span>
<span class="w"> </span>LOGURU_AUTOINIT = env(&#39;LOGURU_AUTOINIT&#39;, bool, True)
<span class="w"> </span>LOGURU_FORMAT = env(&#39;LOGURU_FORMAT&#39;, str, &#39;&lt;green&gt;{time:YYYY-MM-DD HH:mm:ss.SSS}&lt;/green&gt; | &lt;level&gt;{level: &lt;8}&lt;/level&gt; | &lt;cyan&gt;{name}&lt;/cyan&gt;:&lt;cyan&gt;{function}&lt;/cyan&gt;:&lt;cyan&gt;{line}&lt;/cyan&gt; - &lt;level&gt;{message}&lt;/level&gt;&#39;)
<span class="w"> </span>LOGURU_FILTER = env(&#39;LOGURU_FILTER&#39;, str, None)
<span class="gh">diff --git a/loguru/_get_frame.py b/loguru/_get_frame.py</span>
<span class="gh">index c6e9c4b..062e2a8 100644</span>
<span class="gd">--- a/loguru/_get_frame.py</span>
<span class="gi">+++ b/loguru/_get_frame.py</span>
<span class="gu">@@ -1,3 +1,19 @@</span>
<span class="w"> </span>import sys
<span class="w"> </span>from sys import exc_info
<span class="gi">+</span>
<span class="gi">+def load_get_frame_function():</span>
<span class="gi">+    if hasattr(sys, &#39;_getframe&#39;):</span>
<span class="gi">+        def get_frame(depth):</span>
<span class="gi">+            return sys._getframe(depth)</span>
<span class="gi">+    else:</span>
<span class="gi">+        def get_frame(depth):</span>
<span class="gi">+            try:</span>
<span class="gi">+                raise Exception</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                frame = exc_info()[2].tb_frame</span>
<span class="gi">+                for _ in range(depth):</span>
<span class="gi">+                    frame = frame.f_back</span>
<span class="gi">+                return frame</span>
<span class="gi">+    return get_frame</span>
<span class="gi">+</span>
<span class="w"> </span>get_frame = load_get_frame_function()
\ No newline at end of file
<span class="gh">diff --git a/loguru/_locks_machinery.py b/loguru/_locks_machinery.py</span>
<span class="gh">index 883c097..fd60595 100644</span>
<span class="gd">--- a/loguru/_locks_machinery.py</span>
<span class="gi">+++ b/loguru/_locks_machinery.py</span>
<span class="gu">@@ -1,8 +1,31 @@</span>
<span class="w"> </span>import os
<span class="w"> </span>import threading
<span class="w"> </span>import weakref
<span class="gd">-if not hasattr(os, &#39;register_at_fork&#39;):</span>
<span class="gd">-else:</span>
<span class="gd">-    logger_locks = weakref.WeakSet()</span>
<span class="gd">-    handler_locks = weakref.WeakSet()</span>
<span class="gi">+</span>
<span class="gi">+logger_locks = weakref.WeakSet()</span>
<span class="gi">+handler_locks = weakref.WeakSet()</span>
<span class="gi">+</span>
<span class="gi">+def acquire_locks():</span>
<span class="gi">+    for lock in logger_locks:</span>
<span class="gi">+        lock.acquire()</span>
<span class="gi">+    for lock in handler_locks:</span>
<span class="gi">+        lock.acquire()</span>
<span class="gi">+</span>
<span class="gi">+def release_locks():</span>
<span class="gi">+    for lock in reversed(list(handler_locks)):</span>
<span class="gi">+        lock.release()</span>
<span class="gi">+    for lock in reversed(list(logger_locks)):</span>
<span class="gi">+        lock.release()</span>
<span class="gi">+</span>
<span class="gi">+def create_logger_lock():</span>
<span class="gi">+    lock = threading.Lock()</span>
<span class="gi">+    logger_locks.add(lock)</span>
<span class="gi">+    return lock</span>
<span class="gi">+</span>
<span class="gi">+def create_handler_lock():</span>
<span class="gi">+    lock = threading.Lock()</span>
<span class="gi">+    handler_locks.add(lock)</span>
<span class="gi">+    return lock</span>
<span class="gi">+</span>
<span class="gi">+if hasattr(os, &#39;register_at_fork&#39;):</span>
<span class="w"> </span>    os.register_at_fork(before=acquire_locks, after_in_parent=release_locks, after_in_child=release_locks)
\ No newline at end of file
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>