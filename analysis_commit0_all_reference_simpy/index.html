
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference simpy - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-simpy" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference simpy
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-simpy"><strong>Reference (Gold)</strong>: simpy</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">140</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">140</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">150</td>
</tr>
<tr>
<td style="text-align: left;">deselected</td>
<td style="text-align: center;">10</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/src/simpy/core.py b/src/simpy/core.py</span>
<span class="gh">index 10c88fb..a479855 100644</span>
<span class="gd">--- a/src/simpy/core.py</span>
<span class="gi">+++ b/src/simpy/core.py</span>
<span class="gu">@@ -3,12 +3,37 @@ Core components for event-discrete simulation environments.</span>

<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from heapq import heappop, heappush
<span class="w"> </span>from itertools import count
<span class="w"> </span>from types import MethodType
<span class="gd">-from typing import TYPE_CHECKING, Any, Generic, Iterable, List, Optional, Tuple, Type, TypeVar, Union</span>
<span class="gd">-from simpy.events import NORMAL, URGENT, AllOf, AnyOf, Event, EventPriority, Process, ProcessGenerator, Timeout</span>
<span class="gd">-Infinity: float = float(&#39;inf&#39;)</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Generic,</span>
<span class="gi">+    Iterable,</span>
<span class="gi">+    List,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    Type,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    Union,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+from simpy.events import (</span>
<span class="gi">+    NORMAL,</span>
<span class="gi">+    URGENT,</span>
<span class="gi">+    AllOf,</span>
<span class="gi">+    AnyOf,</span>
<span class="gi">+    Event,</span>
<span class="gi">+    EventPriority,</span>
<span class="gi">+    Process,</span>
<span class="gi">+    ProcessGenerator,</span>
<span class="gi">+    Timeout,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+Infinity: float = float(&#39;inf&#39;)  #: Convenience alias for infinity</span>
<span class="gi">+</span>
<span class="w"> </span>T = TypeVar(&#39;T&#39;)


<span class="gu">@@ -24,17 +49,23 @@ class BoundClass(Generic[T]):</span>
<span class="w"> </span>    def __init__(self, cls: Type[T]):
<span class="w"> </span>        self.cls = cls

<span class="gd">-    def __get__(self, instance: Optional[BoundClass], owner: Optional[Type[</span>
<span class="gd">-        BoundClass]]=None) -&gt;Union[Type[T], MethodType]:</span>
<span class="gi">+    def __get__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        instance: Optional[BoundClass],</span>
<span class="gi">+        owner: Optional[Type[BoundClass]] = None,</span>
<span class="gi">+    ) -&gt; Union[Type[T], MethodType]:</span>
<span class="w"> </span>        if instance is None:
<span class="w"> </span>            return self.cls
<span class="w"> </span>        return MethodType(self.cls, instance)

<span class="w"> </span>    @staticmethod
<span class="gd">-    def bind_early(instance: object) -&gt;None:</span>
<span class="gi">+    def bind_early(instance: object) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Bind all :class:`BoundClass` attributes of the *instance&#39;s* class
<span class="w"> </span>        to the instance itself to increase performance.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for name, obj in instance.__class__.__dict__.items():</span>
<span class="gi">+            if type(obj) is BoundClass:</span>
<span class="gi">+                bound_class = getattr(instance, name)</span>
<span class="gi">+                setattr(instance, name, bound_class)</span>


<span class="w"> </span>class EmptySchedule(Exception):
<span class="gu">@@ -46,10 +77,13 @@ class StopSimulation(Exception):</span>
<span class="w"> </span>    &quot;&quot;&quot;Indicates that the simulation should stop now.&quot;&quot;&quot;

<span class="w"> </span>    @classmethod
<span class="gd">-    def callback(cls, event: Event) -&gt;None:</span>
<span class="gi">+    def callback(cls, event: Event) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Used as callback in :meth:`Environment.run()` to stop the simulation
<span class="w"> </span>        when the *until* event occurred.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if event.ok:</span>
<span class="gi">+            raise cls(event.value)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise event._value</span>


<span class="w"> </span>SimTime = Union[int, float]
<span class="gu">@@ -67,50 +101,59 @@ class Environment:</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, initial_time: SimTime=0):</span>
<span class="gi">+    def __init__(self, initial_time: SimTime = 0):</span>
<span class="w"> </span>        self._now = initial_time
<span class="gd">-        self._queue: List[Tuple[SimTime, EventPriority, int, Event]] = []</span>
<span class="gd">-        self._eid = count()</span>
<span class="gi">+        self._queue: List[</span>
<span class="gi">+            Tuple[SimTime, EventPriority, int, Event]</span>
<span class="gi">+        ] = []  # The list of all currently scheduled events.</span>
<span class="gi">+        self._eid = count()  # Counter for event IDs</span>
<span class="w"> </span>        self._active_proc: Optional[Process] = None
<span class="gi">+</span>
<span class="gi">+        # Bind all BoundClass instances to &quot;self&quot; to improve performance.</span>
<span class="w"> </span>        BoundClass.bind_early(self)

<span class="w"> </span>    @property
<span class="gd">-    def now(self) -&gt;SimTime:</span>
<span class="gi">+    def now(self) -&gt; SimTime:</span>
<span class="w"> </span>        &quot;&quot;&quot;The current simulation time.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._now</span>

<span class="w"> </span>    @property
<span class="gd">-    def active_process(self) -&gt;Optional[Process]:</span>
<span class="gi">+    def active_process(self) -&gt; Optional[Process]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The currently active process of the environment.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._active_proc</span>
<span class="gi">+</span>
<span class="w"> </span>    if TYPE_CHECKING:
<span class="gi">+        # This block is only evaluated when type checking with, e.g. Mypy.</span>
<span class="gi">+        # These are the effective types of the methods created with BoundClass</span>
<span class="gi">+        # magic and are thus a useful reference for SimPy users as well as for</span>
<span class="gi">+        # static type checking.</span>

<span class="gd">-        def process(self, generator: ProcessGenerator) -&gt;Process:</span>
<span class="gi">+        def process(self, generator: ProcessGenerator) -&gt; Process:</span>
<span class="w"> </span>            &quot;&quot;&quot;Create a new :class:`~simpy.events.Process` instance for
<span class="w"> </span>            *generator*.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return Process(self, generator)</span>

<span class="gd">-        def timeout(self, delay: SimTime=0, value: Optional[Any]=None</span>
<span class="gd">-            ) -&gt;Timeout:</span>
<span class="gi">+        def timeout(self, delay: SimTime = 0, value: Optional[Any] = None) -&gt; Timeout:</span>
<span class="w"> </span>            &quot;&quot;&quot;Return a new :class:`~simpy.events.Timeout` event with a *delay*
<span class="w"> </span>            and, optionally, a *value*.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return Timeout(self, delay, value)</span>

<span class="gd">-        def event(self) -&gt;Event:</span>
<span class="gi">+        def event(self) -&gt; Event:</span>
<span class="w"> </span>            &quot;&quot;&quot;Return a new :class:`~simpy.events.Event` instance.

<span class="w"> </span>            Yielding this event suspends a process until another process
<span class="w"> </span>            triggers the event.
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return Event(self)</span>

<span class="gd">-        def all_of(self, events: Iterable[Event]) -&gt;AllOf:</span>
<span class="gi">+        def all_of(self, events: Iterable[Event]) -&gt; AllOf:</span>
<span class="w"> </span>            &quot;&quot;&quot;Return a :class:`~simpy.events.AllOf` condition for *events*.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return AllOf(self, events)</span>

<span class="gd">-        def any_of(self, events: Iterable[Event]) -&gt;AnyOf:</span>
<span class="gi">+        def any_of(self, events: Iterable[Event]) -&gt; AnyOf:</span>
<span class="w"> </span>            &quot;&quot;&quot;Return a :class:`~simpy.events.AnyOf` condition for *events*.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return AnyOf(self, events)</span>
<span class="gi">+</span>
<span class="w"> </span>    else:
<span class="w"> </span>        process = BoundClass(Process)
<span class="w"> </span>        timeout = BoundClass(Timeout)
<span class="gu">@@ -118,25 +161,49 @@ class Environment:</span>
<span class="w"> </span>        all_of = BoundClass(AllOf)
<span class="w"> </span>        any_of = BoundClass(AnyOf)

<span class="gd">-    def schedule(self, event: Event, priority: EventPriority=NORMAL, delay:</span>
<span class="gd">-        SimTime=0) -&gt;None:</span>
<span class="gi">+    def schedule(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Event,</span>
<span class="gi">+        priority: EventPriority = NORMAL,</span>
<span class="gi">+        delay: SimTime = 0,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Schedule an *event* with a given *priority* and a *delay*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        heappush(self._queue, (self._now + delay, priority, next(self._eid), event))</span>

<span class="gd">-    def peek(self) -&gt;SimTime:</span>
<span class="gi">+    def peek(self) -&gt; SimTime:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the time of the next scheduled event. Return
<span class="w"> </span>        :data:`~simpy.core.Infinity` if there is no further event.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._queue[0][0]</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            return Infinity</span>

<span class="gd">-    def step(self) -&gt;None:</span>
<span class="gi">+    def step(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Process the next event.

<span class="w"> </span>        Raise an :exc:`EmptySchedule` if no further events are available.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def run(self, until: Optional[Union[SimTime, Event]]=None) -&gt;Optional[Any]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._now, _, _, event = heappop(self._queue)</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            raise EmptySchedule from None</span>
<span class="gi">+</span>
<span class="gi">+        # Process callbacks of the event. Set the events callbacks to None</span>
<span class="gi">+        # immediately to prevent concurrent modifications.</span>
<span class="gi">+        callbacks, event.callbacks = event.callbacks, None  # type: ignore</span>
<span class="gi">+        for callback in callbacks:</span>
<span class="gi">+            callback(event)</span>
<span class="gi">+</span>
<span class="gi">+        if not event._ok and not hasattr(event, &#39;_defused&#39;):</span>
<span class="gi">+            # The event has failed and has not been defused. Crash the</span>
<span class="gi">+            # environment.</span>
<span class="gi">+            # Create a copy of the failure exception with a new traceback.</span>
<span class="gi">+            exc = type(event._value)(*event._value.args)</span>
<span class="gi">+            exc.__cause__ = event._value</span>
<span class="gi">+            raise exc</span>
<span class="gi">+</span>
<span class="gi">+    def run(self, until: Optional[Union[SimTime, Event]] = None) -&gt; Optional[Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Executes :meth:`step()` until the given criterion *until* is met.

<span class="w"> </span>        - If it is ``None`` (which is the default), this method will return
<span class="gu">@@ -151,4 +218,39 @@ class Environment:</span>
<span class="w"> </span>          until the environment&#39;s time reaches *until*.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if until is not None:</span>
<span class="gi">+            if not isinstance(until, Event):</span>
<span class="gi">+                # Assume that *until* is a number if it is not None and</span>
<span class="gi">+                # not an event.  Create a Timeout(until) in this case.</span>
<span class="gi">+                at: SimTime = until if isinstance(until, int) else float(until)</span>
<span class="gi">+</span>
<span class="gi">+                if at &lt;= self.now:</span>
<span class="gi">+                    raise ValueError(</span>
<span class="gi">+                        f&#39;until ({at}) must be greater than the current simulation time&#39;</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+                # Schedule the event before all regular timeouts.</span>
<span class="gi">+                until = Event(self)</span>
<span class="gi">+                until._ok = True</span>
<span class="gi">+                until._value = None</span>
<span class="gi">+                self.schedule(until, URGENT, at - self.now)</span>
<span class="gi">+</span>
<span class="gi">+            elif until.callbacks is None:</span>
<span class="gi">+                # Until event has already been processed.</span>
<span class="gi">+                return until.value</span>
<span class="gi">+</span>
<span class="gi">+            until.callbacks.append(StopSimulation.callback)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            while True:</span>
<span class="gi">+                self.step()</span>
<span class="gi">+        except StopSimulation as exc:</span>
<span class="gi">+            return exc.args[0]  # == until.value</span>
<span class="gi">+        except EmptySchedule:</span>
<span class="gi">+            if until is not None:</span>
<span class="gi">+                assert not until.triggered</span>
<span class="gi">+                raise RuntimeError(</span>
<span class="gi">+                    f&#39;No scheduled events left but &quot;until&quot; event was not &#39;</span>
<span class="gi">+                    f&#39;triggered: {until}&#39;</span>
<span class="gi">+                ) from None</span>
<span class="gi">+        return None</span>
<span class="gh">diff --git a/src/simpy/events.py b/src/simpy/events.py</span>
<span class="gh">index 128ed75..28d4433 100644</span>
<span class="gd">--- a/src/simpy/events.py</span>
<span class="gi">+++ b/src/simpy/events.py</span>
<span class="gu">@@ -14,14 +14,34 @@ used, there are several specialized subclasses of it.</span>

<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gd">-from typing import TYPE_CHECKING, Any, Callable, Dict, Generator, Iterable, Iterator, List, NewType, Optional, Tuple, TypeVar</span>
<span class="gi">+</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    Dict,</span>
<span class="gi">+    Generator,</span>
<span class="gi">+    Iterable,</span>
<span class="gi">+    Iterator,</span>
<span class="gi">+    List,</span>
<span class="gi">+    NewType,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Tuple,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from simpy.exceptions import Interrupt
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from types import FrameType
<span class="gi">+</span>
<span class="w"> </span>    from simpy.core import Environment, SimTime
<span class="gi">+</span>
<span class="w"> </span>PENDING: object = object()
<span class="w"> </span>&quot;&quot;&quot;Unique object to identify pending values of events.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>EventPriority = NewType(&#39;EventPriority&#39;, int)
<span class="gi">+</span>
<span class="w"> </span>URGENT: EventPriority = EventPriority(0)
<span class="w"> </span>&quot;&quot;&quot;Priority of interrupts and process initialization events.&quot;&quot;&quot;
<span class="w"> </span>NORMAL: EventPriority = EventPriority(1)
<span class="gu">@@ -58,6 +78,7 @@ class Event:</span>
<span class="w"> </span>    of them.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _ok: bool
<span class="w"> </span>    _defused: bool
<span class="w"> </span>    _value: Any = PENDING
<span class="gu">@@ -68,29 +89,29 @@ class Event:</span>
<span class="w"> </span>        self.callbacks: EventCallbacks = []
<span class="w"> </span>        &quot;&quot;&quot;List of functions that are called when the event is processed.&quot;&quot;&quot;

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the description of the event (see :meth:`_desc`) with the id
<span class="w"> </span>        of the event.&quot;&quot;&quot;
<span class="w"> </span>        return f&#39;&lt;{self._desc()} object at {id(self):#x}&gt;&#39;

<span class="gd">-    def _desc(self) -&gt;str:</span>
<span class="gi">+    def _desc(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a string *Event()*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return f&#39;{self.__class__.__name__}()&#39;</span>

<span class="w"> </span>    @property
<span class="gd">-    def triggered(self) -&gt;bool:</span>
<span class="gi">+    def triggered(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Becomes ``True`` if the event has been triggered and its callbacks
<span class="w"> </span>        are about to be invoked.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._value is not PENDING</span>

<span class="w"> </span>    @property
<span class="gd">-    def processed(self) -&gt;bool:</span>
<span class="gi">+    def processed(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Becomes ``True`` if the event has been processed (e.g., its
<span class="w"> </span>        callbacks have been invoked).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.callbacks is None</span>

<span class="w"> </span>    @property
<span class="gd">-    def ok(self) -&gt;bool:</span>
<span class="gi">+    def ok(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Becomes ``True`` when the event has been triggered successfully.

<span class="w"> </span>        A &quot;successful&quot; event is one triggered with :meth:`succeed()`.
<span class="gu">@@ -98,10 +119,10 @@ class Event:</span>
<span class="w"> </span>        :raises AttributeError: if accessed before the event is triggered.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._ok</span>

<span class="w"> </span>    @property
<span class="gd">-    def defused(self) -&gt;bool:</span>
<span class="gi">+    def defused(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Becomes ``True`` when the failed event&#39;s exception is &quot;defused&quot;.

<span class="w"> </span>        When an event fails (i.e. with :meth:`fail()`), the failed event&#39;s
<span class="gu">@@ -115,10 +136,14 @@ class Event:</span>
<span class="w"> </span>        processed by the :class:`~simpy.core.Environment`.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return hasattr(self, &#39;_defused&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    @defused.setter</span>
<span class="gi">+    def defused(self, value: bool) -&gt; None:</span>
<span class="gi">+        self._defused = True</span>

<span class="w"> </span>    @property
<span class="gd">-    def value(self) -&gt;Optional[Any]:</span>
<span class="gi">+    def value(self) -&gt; Optional[Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The value of the event if it is available.

<span class="w"> </span>        The value is available when the event has been triggered.
<span class="gu">@@ -126,9 +151,11 @@ class Event:</span>
<span class="w"> </span>        Raises :exc:`AttributeError` if the value is not yet available.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._value is PENDING:</span>
<span class="gi">+            raise AttributeError(f&#39;Value of {self} is not yet available&#39;)</span>
<span class="gi">+        return self._value</span>

<span class="gd">-    def trigger(self, event: Event) -&gt;None:</span>
<span class="gi">+    def trigger(self, event: Event) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Trigger the event with the state and value of the provided *event*.
<span class="w"> </span>        Return *self* (this event instance).

<span class="gu">@@ -136,18 +163,26 @@ class Event:</span>
<span class="w"> </span>        chain reactions.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._ok = event._ok</span>
<span class="gi">+        self._value = event._value</span>
<span class="gi">+        self.env.schedule(self)</span>

<span class="gd">-    def succeed(self, value: Optional[Any]=None) -&gt;Event:</span>
<span class="gi">+    def succeed(self, value: Optional[Any] = None) -&gt; Event:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set the event&#39;s value, mark it as successful and schedule it for
<span class="w"> </span>        processing by the environment. Returns the event instance.

<span class="w"> </span>        Raises :exc:`RuntimeError` if this event has already been triggerd.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._value is not PENDING:</span>
<span class="gi">+            raise RuntimeError(f&#39;{self} has already been triggered&#39;)</span>

<span class="gd">-    def fail(self, exception: Exception) -&gt;Event:</span>
<span class="gi">+        self._ok = True</span>
<span class="gi">+        self._value = value</span>
<span class="gi">+        self.env.schedule(self)</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def fail(self, exception: Exception) -&gt; Event:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set *exception* as the events value, mark it as failed and schedule
<span class="w"> </span>        it for processing by the environment. Returns the event instance.

<span class="gu">@@ -156,14 +191,21 @@ class Event:</span>
<span class="w"> </span>        Raises :exc:`RuntimeError` if this event has already been triggered.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._value is not PENDING:</span>
<span class="gi">+            raise RuntimeError(f&#39;{self} has already been triggered&#39;)</span>
<span class="gi">+        if not isinstance(exception, BaseException):</span>
<span class="gi">+            raise TypeError(f&#39;{exception} is not an exception.&#39;)</span>
<span class="gi">+        self._ok = False</span>
<span class="gi">+        self._value = exception</span>
<span class="gi">+        self.env.schedule(self)</span>
<span class="gi">+        return self</span>

<span class="gd">-    def __and__(self, other: Event) -&gt;Condition:</span>
<span class="gi">+    def __and__(self, other: Event) -&gt; Condition:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a :class:`~simpy.events.Condition` that will be triggered if
<span class="w"> </span>        both, this event and *other*, have been processed.&quot;&quot;&quot;
<span class="w"> </span>        return Condition(self.env, Condition.all_events, [self, other])

<span class="gd">-    def __or__(self, other: Event) -&gt;Condition:</span>
<span class="gi">+    def __or__(self, other: Event) -&gt; Condition:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a :class:`~simpy.events.Condition` that will be triggered if
<span class="w"> </span>        either this event or *other* have been processed (or even both, if they
<span class="w"> </span>        happened concurrently).&quot;&quot;&quot;
<span class="gu">@@ -184,10 +226,16 @@ class Timeout(Event):</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, env: Environment, delay: SimTime, value: Optional[</span>
<span class="gd">-        Any]=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        env: Environment,</span>
<span class="gi">+        delay: SimTime,</span>
<span class="gi">+        value: Optional[Any] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        if delay &lt; 0:
<span class="w"> </span>            raise ValueError(f&#39;Negative delay {delay}&#39;)
<span class="gi">+        # NOTE: The following initialization code is inlined from</span>
<span class="gi">+        # Event.__init__() for performance reasons.</span>
<span class="w"> </span>        self.env = env
<span class="w"> </span>        self.callbacks: EventCallbacks = []
<span class="w"> </span>        self._value = value
<span class="gu">@@ -195,9 +243,10 @@ class Timeout(Event):</span>
<span class="w"> </span>        self._ok = True
<span class="w"> </span>        env.schedule(self, NORMAL, delay)

<span class="gd">-    def _desc(self) -&gt;str:</span>
<span class="gi">+    def _desc(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a string *Timeout(delay[, value=value])*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        value_str = &#39;&#39; if self._value is None else f&#39;, value={self.value}&#39;</span>
<span class="gi">+        return f&#39;{self.__class__.__name__}({self._delay}{value_str})&#39;</span>


<span class="w"> </span>class Initialize(Event):
<span class="gu">@@ -208,9 +257,15 @@ class Initialize(Event):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, env: Environment, process: Process):
<span class="gi">+        # NOTE: The following initialization code is inlined from</span>
<span class="gi">+        # Event.__init__() for performance reasons.</span>
<span class="w"> </span>        self.env = env
<span class="w"> </span>        self.callbacks: EventCallbacks = [process._resume]
<span class="w"> </span>        self._value: Any = None
<span class="gi">+</span>
<span class="gi">+        # The initialization events needs to be scheduled as urgent so that it</span>
<span class="gi">+        # will be handled before interrupts. Otherwise, a process whose</span>
<span class="gi">+        # generator has not yet been started could be interrupted.</span>
<span class="w"> </span>        self._ok = True
<span class="w"> </span>        env.schedule(self, URGENT)

<span class="gu">@@ -224,19 +279,36 @@ class Interruption(Event):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, process: Process, cause: Optional[Any]):
<span class="gi">+        # NOTE: The following initialization code is inlined from</span>
<span class="gi">+        # Event.__init__() for performance reasons.</span>
<span class="w"> </span>        self.env = process.env
<span class="w"> </span>        self.callbacks: EventCallbacks = [self._interrupt]
<span class="w"> </span>        self._value = Interrupt(cause)
<span class="w"> </span>        self._ok = False
<span class="w"> </span>        self._defused = True
<span class="gi">+</span>
<span class="w"> </span>        if process._value is not PENDING:
<span class="gd">-            raise RuntimeError(</span>
<span class="gd">-                f&#39;{process} has terminated and cannot be interrupted.&#39;)</span>
<span class="gi">+            raise RuntimeError(f&#39;{process} has terminated and cannot be interrupted.&#39;)</span>
<span class="gi">+</span>
<span class="w"> </span>        if process is self.env.active_process:
<span class="w"> </span>            raise RuntimeError(&#39;A process is not allowed to interrupt itself.&#39;)
<span class="gi">+</span>
<span class="w"> </span>        self.process = process
<span class="w"> </span>        self.env.schedule(self, URGENT)

<span class="gi">+    def _interrupt(self, event: Event) -&gt; None:</span>
<span class="gi">+        # Ignore dead processes. Multiple concurrently scheduled interrupts</span>
<span class="gi">+        # cause this situation. If the process dies while handling the first</span>
<span class="gi">+        # one, the remaining interrupts must be ignored.</span>
<span class="gi">+        if self.process._value is not PENDING:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # A process never expects an interrupt and is always waiting for a</span>
<span class="gi">+        # target event. Remove the process from the callbacks of the target.</span>
<span class="gi">+        self.process._target.callbacks.remove(self.process._resume)</span>
<span class="gi">+</span>
<span class="gi">+        self.process._resume(self)</span>
<span class="gi">+</span>

<span class="w"> </span>ProcessGenerator = Generator[Event, Any, Any]

<span class="gu">@@ -259,37 +331,50 @@ class Process(Event):</span>

<span class="w"> </span>    def __init__(self, env: Environment, generator: ProcessGenerator):
<span class="w"> </span>        if not hasattr(generator, &#39;throw&#39;):
<span class="gi">+            # Implementation note: Python implementations differ in the</span>
<span class="gi">+            # generator types they provide. Cython adds its own generator type</span>
<span class="gi">+            # in addition to the CPython type, which renders a type check</span>
<span class="gi">+            # impractical. To work around this issue, we check for attribute</span>
<span class="gi">+            # name instead of type and optimistically assume that all objects</span>
<span class="gi">+            # with a ``throw`` attribute are generators.</span>
<span class="gi">+            # Remove this workaround if it causes issues in production!</span>
<span class="w"> </span>            raise ValueError(f&#39;{generator} is not a generator.&#39;)
<span class="gi">+</span>
<span class="gi">+        # NOTE: The following initialization code is inlined from</span>
<span class="gi">+        # Event.__init__() for performance reasons.</span>
<span class="w"> </span>        self.env = env
<span class="w"> </span>        self.callbacks: EventCallbacks = []
<span class="gi">+</span>
<span class="w"> </span>        self._generator = generator
<span class="gi">+</span>
<span class="gi">+        # Schedule the start of the execution of the process.</span>
<span class="w"> </span>        self._target: Event = Initialize(env, self)

<span class="gd">-    def _desc(self) -&gt;str:</span>
<span class="gi">+    def _desc(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a string *Process(process_func_name)*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return f&#39;{self.__class__.__name__}({self.name})&#39;</span>

<span class="w"> </span>    @property
<span class="gd">-    def target(self) -&gt;Event:</span>
<span class="gi">+    def target(self) -&gt; Event:</span>
<span class="w"> </span>        &quot;&quot;&quot;The event that the process is currently waiting for.

<span class="w"> </span>        Returns ``None`` if the process is dead, or it is currently being
<span class="w"> </span>        interrupted.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._target</span>

<span class="w"> </span>    @property
<span class="gd">-    def name(self) -&gt;str:</span>
<span class="gi">+    def name(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Name of the function used to start the process.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._generator.__name__  # type: ignore</span>

<span class="w"> </span>    @property
<span class="gd">-    def is_alive(self) -&gt;bool:</span>
<span class="gi">+    def is_alive(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;``True`` until the process generator exits.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._value is PENDING</span>

<span class="gd">-    def interrupt(self, cause: Optional[Any]=None) -&gt;None:</span>
<span class="gi">+    def interrupt(self, cause: Optional[Any] = None) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Interrupt this process optionally providing a *cause*.

<span class="w"> </span>        A process cannot be interrupted if it already terminated. A process can
<span class="gu">@@ -297,13 +382,69 @@ class Process(Event):</span>
<span class="w"> </span>        cases.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        Interruption(self, cause)</span>

<span class="gd">-    def _resume(self, event: Event) -&gt;None:</span>
<span class="gi">+    def _resume(self, event: Event) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Resumes the execution of the process with the value of *event*. If
<span class="w"> </span>        the process generator exits, the process itself will get triggered with
<span class="w"> </span>        the return value or the exception of the generator.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Mark the current process as active.</span>
<span class="gi">+        self.env._active_proc = self</span>
<span class="gi">+</span>
<span class="gi">+        while True:</span>
<span class="gi">+            # Get next event from process</span>
<span class="gi">+            try:</span>
<span class="gi">+                if event._ok:</span>
<span class="gi">+                    event = self._generator.send(event._value)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # The process has no choice but to handle the failed event</span>
<span class="gi">+                    # (or fail itself).</span>
<span class="gi">+                    event._defused = True</span>
<span class="gi">+</span>
<span class="gi">+                    # Create an exclusive copy of the exception for this</span>
<span class="gi">+                    # process to prevent traceback modifications by other</span>
<span class="gi">+                    # processes.</span>
<span class="gi">+                    exc = type(event._value)(*event._value.args)</span>
<span class="gi">+                    exc.__cause__ = event._value</span>
<span class="gi">+                    event = self._generator.throw(exc)</span>
<span class="gi">+            except StopIteration as e:</span>
<span class="gi">+                # Process has terminated.</span>
<span class="gi">+                event = None  # type: ignore</span>
<span class="gi">+                self._ok = True</span>
<span class="gi">+                self._value = e.args[0] if len(e.args) else None</span>
<span class="gi">+                self.env.schedule(self)</span>
<span class="gi">+                break</span>
<span class="gi">+            except BaseException as e:</span>
<span class="gi">+                # Process has failed.</span>
<span class="gi">+                event = None  # type: ignore</span>
<span class="gi">+                self._ok = False</span>
<span class="gi">+                # Strip the frame of this function from the traceback as it</span>
<span class="gi">+                # does not add any useful information.</span>
<span class="gi">+                e.__traceback__ = e.__traceback__.tb_next  # type: ignore</span>
<span class="gi">+                self._value = e</span>
<span class="gi">+                self.env.schedule(self)</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            # Process returned another event to wait upon.</span>
<span class="gi">+            try:</span>
<span class="gi">+                # Be optimistic and blindly access the callbacks attribute.</span>
<span class="gi">+                if event.callbacks is not None:</span>
<span class="gi">+                    # The event has not yet been triggered. Register callback</span>
<span class="gi">+                    # to resume the process if that happens.</span>
<span class="gi">+                    event.callbacks.append(self._resume)</span>
<span class="gi">+                    break</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                # Our optimism didn&#39;t work out, figure out what went wrong and</span>
<span class="gi">+                # inform the user.</span>
<span class="gi">+                if hasattr(event, &#39;callbacks&#39;):</span>
<span class="gi">+                    raise</span>
<span class="gi">+</span>
<span class="gi">+                msg = f&#39;Invalid yield value &quot;{event}&quot;&#39;</span>
<span class="gi">+                descr = _describe_frame(self._generator.gi_frame)</span>
<span class="gi">+                raise RuntimeError(f&#39;\n{descr}{msg}&#39;) from None</span>
<span class="gi">+</span>
<span class="gi">+        self._target = event</span>
<span class="gi">+        self.env._active_proc = None</span>


<span class="w"> </span>class ConditionValue:
<span class="gu">@@ -311,18 +452,19 @@ class ConditionValue:</span>
<span class="w"> </span>    dict-like access to the triggered events and their values. The events are
<span class="w"> </span>    ordered by their occurrences in the condition.&quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self.events: List[Event] = []

<span class="gd">-    def __getitem__(self, key: Event) -&gt;Any:</span>
<span class="gi">+    def __getitem__(self, key: Event) -&gt; Any:</span>
<span class="w"> </span>        if key not in self.events:
<span class="w"> </span>            raise KeyError(str(key))
<span class="gi">+</span>
<span class="w"> </span>        return key._value

<span class="gd">-    def __contains__(self, key: Event) -&gt;bool:</span>
<span class="gi">+    def __contains__(self, key: Event) -&gt; bool:</span>
<span class="w"> </span>        return key in self.events

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if isinstance(other, ConditionValue):
<span class="w"> </span>            return self.events == other.events
<span class="w"> </span>        elif isinstance(other, dict):
<span class="gu">@@ -330,12 +472,24 @@ class ConditionValue:</span>
<span class="w"> </span>        else:
<span class="w"> </span>            return NotImplemented

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return f&#39;&lt;ConditionValue {self.todict()}&gt;&#39;

<span class="gd">-    def __iter__(self) -&gt;Iterator[Event]:</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[Event]:</span>
<span class="w"> </span>        return self.keys()

<span class="gi">+    def keys(self) -&gt; Iterator[Event]:</span>
<span class="gi">+        return (event for event in self.events)</span>
<span class="gi">+</span>
<span class="gi">+    def values(self) -&gt; Iterator[Any]:</span>
<span class="gi">+        return (event._value for event in self.events)</span>
<span class="gi">+</span>
<span class="gi">+    def items(self) -&gt; Iterator[Tuple[Event, Any]]:</span>
<span class="gi">+        return ((event, event._value) for event in self.events)</span>
<span class="gi">+</span>
<span class="gi">+    def todict(self) -&gt; Dict[Event, Any]:</span>
<span class="gi">+        return {event: event._value for event in self.events}</span>
<span class="gi">+</span>

<span class="w"> </span>class Condition(Event):
<span class="w"> </span>    &quot;&quot;&quot;An event that gets triggered once the condition function *evaluate*
<span class="gu">@@ -359,42 +513,64 @@ class Condition(Event):</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, env: Environment, evaluate: Callable[[Tuple[Event,</span>
<span class="gd">-        ...], int], bool], events: Iterable[Event]):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        env: Environment,</span>
<span class="gi">+        evaluate: Callable[[Tuple[Event, ...], int], bool],</span>
<span class="gi">+        events: Iterable[Event],</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        super().__init__(env)
<span class="w"> </span>        self._evaluate = evaluate
<span class="w"> </span>        self._events = tuple(events)
<span class="w"> </span>        self._count = 0
<span class="gi">+</span>
<span class="w"> </span>        if not self._events:
<span class="gi">+            # Immediately succeed if no events are provided.</span>
<span class="w"> </span>            self.succeed(ConditionValue())
<span class="w"> </span>            return
<span class="gi">+</span>
<span class="gi">+        # Check if events belong to the same environment.</span>
<span class="w"> </span>        for event in self._events:
<span class="w"> </span>            if self.env != event.env:
<span class="w"> </span>                raise ValueError(
<span class="w"> </span>                    &#39;It is not allowed to mix events from different environments&#39;
<span class="gd">-                    )</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        # Check if the condition is met for each processed event. Attach</span>
<span class="gi">+        # _check() as a callback otherwise.</span>
<span class="w"> </span>        for event in self._events:
<span class="w"> </span>            if event.callbacks is None:
<span class="w"> </span>                self._check(event)
<span class="w"> </span>            else:
<span class="w"> </span>                event.callbacks.append(self._check)
<span class="gi">+</span>
<span class="gi">+        # Register a callback which will build the value of this condition</span>
<span class="gi">+        # after it has been triggered.</span>
<span class="w"> </span>        assert isinstance(self.callbacks, list)
<span class="w"> </span>        self.callbacks.append(self._build_value)

<span class="gd">-    def _desc(self) -&gt;str:</span>
<span class="gi">+    def _desc(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a string *Condition(evaluate, [events])*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return f&#39;{self.__class__.__name__}({self._evaluate.__name__}, {self._events})&#39;</span>

<span class="gd">-    def _populate_value(self, value: ConditionValue) -&gt;None:</span>
<span class="gi">+    def _populate_value(self, value: ConditionValue) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Populate the *value* by recursively visiting all nested
<span class="w"> </span>        conditions.&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def _build_value(self, event: Event) -&gt;None:</span>
<span class="gi">+        for event in self._events:</span>
<span class="gi">+            if isinstance(event, Condition):</span>
<span class="gi">+                event._populate_value(value)</span>
<span class="gi">+            elif event.callbacks is None:</span>
<span class="gi">+                value.events.append(event)</span>
<span class="gi">+</span>
<span class="gi">+    def _build_value(self, event: Event) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Build the value of this condition.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._remove_check_callbacks()</span>
<span class="gi">+        if event._ok:</span>
<span class="gi">+            self._value = ConditionValue()</span>
<span class="gi">+            self._populate_value(self._value)</span>

<span class="gd">-    def _remove_check_callbacks(self) -&gt;None:</span>
<span class="gi">+    def _remove_check_callbacks(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Remove _check() callbacks from events recursively.

<span class="w"> </span>        Once the condition has triggered, the condition&#39;s events no longer need
<span class="gu">@@ -403,24 +579,40 @@ class Condition(Event):</span>
<span class="w"> </span>        untriggered events.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for event in self._events:</span>
<span class="gi">+            if event.callbacks and self._check in event.callbacks:</span>
<span class="gi">+                event.callbacks.remove(self._check)</span>
<span class="gi">+            if isinstance(event, Condition):</span>
<span class="gi">+                event._remove_check_callbacks()</span>

<span class="gd">-    def _check(self, event: Event) -&gt;None:</span>
<span class="gi">+    def _check(self, event: Event) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if the condition was already met and schedule the *event* if
<span class="w"> </span>        so.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._value is not PENDING:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        self._count += 1</span>
<span class="gi">+</span>
<span class="gi">+        if not event._ok:</span>
<span class="gi">+            # Abort if the event has failed.</span>
<span class="gi">+            event._defused = True</span>
<span class="gi">+            self.fail(event._value)</span>
<span class="gi">+        elif self._evaluate(self._events, self._count):</span>
<span class="gi">+            # The condition has been met. The _build_value() callback will</span>
<span class="gi">+            # populate the ConditionValue once this condition is processed.</span>
<span class="gi">+            self.succeed()</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def all_events(events: Tuple[Event, ...], count: int) -&gt;bool:</span>
<span class="gi">+    def all_events(events: Tuple[Event, ...], count: int) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;An evaluation function that returns ``True`` if all *events* have
<span class="w"> </span>        been triggered.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return len(events) == count</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def any_events(events: Tuple[Event, ...], count: int) -&gt;bool:</span>
<span class="gi">+    def any_events(events: Tuple[Event, ...], count: int) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;An evaluation function that returns ``True`` if at least one of
<span class="w"> </span>        *events* has been triggered.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return count &gt; 0 or len(events) == 0</span>


<span class="w"> </span>class AllOf(Condition):
<span class="gu">@@ -445,6 +637,16 @@ class AnyOf(Condition):</span>
<span class="w"> </span>        super().__init__(env, Condition.any_events, events)


<span class="gd">-def _describe_frame(frame: FrameType) -&gt;str:</span>
<span class="gi">+def _describe_frame(frame: FrameType) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Print filename, line number and function name of a stack frame.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    filename, name = frame.f_code.co_filename, frame.f_code.co_name</span>
<span class="gi">+    lineno = frame.f_lineno</span>
<span class="gi">+</span>
<span class="gi">+    with open(filename) as f:</span>
<span class="gi">+        for no, line in enumerate(f):</span>
<span class="gi">+            if no + 1 == lineno:</span>
<span class="gi">+                return (</span>
<span class="gi">+                    f&#39;  File &quot;{filename}&quot;, line {lineno}, in {name}\n&#39;</span>
<span class="gi">+                    f&#39;    {line.strip()}\n&#39;</span>
<span class="gi">+                )</span>
<span class="gi">+        return f&#39;  File &quot;{filename}&quot;, line {lineno}, in {name}\n&#39;</span>
<span class="gh">diff --git a/src/simpy/exceptions.py b/src/simpy/exceptions.py</span>
<span class="gh">index d45300e..5bbde43 100644</span>
<span class="gd">--- a/src/simpy/exceptions.py</span>
<span class="gi">+++ b/src/simpy/exceptions.py</span>
<span class="gu">@@ -3,6 +3,7 @@ SimPy specific exceptions.</span>

<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import Any, Optional


<span class="gu">@@ -25,10 +26,10 @@ class Interrupt(SimPyException):</span>
<span class="w"> </span>    def __init__(self, cause: Optional[Any]):
<span class="w"> </span>        super().__init__(cause)

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return f&#39;{self.__class__.__name__}({self.cause!r})&#39;

<span class="w"> </span>    @property
<span class="gd">-    def cause(self) -&gt;Optional[Any]:</span>
<span class="gi">+    def cause(self) -&gt; Optional[Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The cause of the interrupt or ``None`` if no cause was provided.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.args[0]</span>
<span class="gh">diff --git a/src/simpy/resources/base.py b/src/simpy/resources/base.py</span>
<span class="gh">index a7d0b96..4cf9ee1 100644</span>
<span class="gd">--- a/src/simpy/resources/base.py</span>
<span class="gi">+++ b/src/simpy/resources/base.py</span>
<span class="gu">@@ -7,11 +7,25 @@ These events are triggered once the request has been completed.</span>

<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gd">-from typing import TYPE_CHECKING, ClassVar, ContextManager, Generic, MutableSequence, Optional, Type, TypeVar, Union</span>
<span class="gi">+</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    ClassVar,</span>
<span class="gi">+    ContextManager,</span>
<span class="gi">+    Generic,</span>
<span class="gi">+    MutableSequence,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Type,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    Union,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from simpy.core import BoundClass, Environment
<span class="w"> </span>from simpy.events import Event, Process
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from types import TracebackType
<span class="gi">+</span>
<span class="w"> </span>ResourceType = TypeVar(&#39;ResourceType&#39;, bound=&#39;BaseResource&#39;)


<span class="gu">@@ -34,20 +48,24 @@ class Put(Event, ContextManager[&#39;Put&#39;], Generic[ResourceType]):</span>
<span class="w"> </span>        super().__init__(resource._env)
<span class="w"> </span>        self.resource = resource
<span class="w"> </span>        self.proc: Optional[Process] = self.env.active_process
<span class="gd">-        resource.put_queue.append(self)</span>
<span class="gi">+</span>
<span class="gi">+        resource.put_queue.append(self)  # pyright: ignore</span>
<span class="w"> </span>        self.callbacks.append(resource._trigger_get)
<span class="w"> </span>        resource._trigger_put(None)

<span class="gd">-    def __enter__(self) -&gt;Put:</span>
<span class="gi">+    def __enter__(self) -&gt; Put:</span>
<span class="w"> </span>        return self

<span class="gd">-    def __exit__(self, exc_type: Optional[Type[BaseException]], exc_value:</span>
<span class="gd">-        Optional[BaseException], traceback: Optional[TracebackType]</span>
<span class="gd">-        ) -&gt;Optional[bool]:</span>
<span class="gi">+    def __exit__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        exc_type: Optional[Type[BaseException]],</span>
<span class="gi">+        exc_value: Optional[BaseException],</span>
<span class="gi">+        traceback: Optional[TracebackType],</span>
<span class="gi">+    ) -&gt; Optional[bool]:</span>
<span class="w"> </span>        self.cancel()
<span class="w"> </span>        return None

<span class="gd">-    def cancel(self) -&gt;None:</span>
<span class="gi">+    def cancel(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Cancel this put request.

<span class="w"> </span>        This method has to be called if the put request must be aborted, for
<span class="gu">@@ -58,7 +76,8 @@ class Put(Event, ContextManager[&#39;Put&#39;], Generic[ResourceType]):</span>
<span class="w"> </span>        method is called automatically.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.triggered:</span>
<span class="gi">+            self.resource.put_queue.remove(self)  # pyright: ignore</span>


<span class="w"> </span>class Get(Event, ContextManager[&#39;Get&#39;], Generic[ResourceType]):
<span class="gu">@@ -80,20 +99,24 @@ class Get(Event, ContextManager[&#39;Get&#39;], Generic[ResourceType]):</span>
<span class="w"> </span>        super().__init__(resource._env)
<span class="w"> </span>        self.resource = resource
<span class="w"> </span>        self.proc = self.env.active_process
<span class="gd">-        resource.get_queue.append(self)</span>
<span class="gi">+</span>
<span class="gi">+        resource.get_queue.append(self)  # pyright: ignore</span>
<span class="w"> </span>        self.callbacks.append(resource._trigger_put)
<span class="w"> </span>        resource._trigger_get(None)

<span class="gd">-    def __enter__(self) -&gt;Get:</span>
<span class="gi">+    def __enter__(self) -&gt; Get:</span>
<span class="w"> </span>        return self

<span class="gd">-    def __exit__(self, exc_type: Optional[Type[BaseException]], exc_value:</span>
<span class="gd">-        Optional[BaseException], traceback: Optional[TracebackType]</span>
<span class="gd">-        ) -&gt;Optional[bool]:</span>
<span class="gi">+    def __exit__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        exc_type: Optional[Type[BaseException]],</span>
<span class="gi">+        exc_value: Optional[BaseException],</span>
<span class="gi">+        traceback: Optional[TracebackType],</span>
<span class="gi">+    ) -&gt; Optional[bool]:</span>
<span class="w"> </span>        self.cancel()
<span class="w"> </span>        return None

<span class="gd">-    def cancel(self) -&gt;None:</span>
<span class="gi">+    def cancel(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Cancel this get request.

<span class="w"> </span>        This method has to be called if the get request must be aborted, for
<span class="gu">@@ -104,7 +127,8 @@ class Get(Event, ContextManager[&#39;Get&#39;], Generic[ResourceType]):</span>
<span class="w"> </span>        method is called automatically.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.triggered:</span>
<span class="gi">+            self.resource.get_queue.remove(self)  # pyright: ignore</span>


<span class="w"> </span>PutType = TypeVar(&#39;PutType&#39;, bound=Put)
<span class="gu">@@ -129,11 +153,13 @@ class BaseResource(Generic[PutType, GetType]):</span>
<span class="w"> </span>      ``_do_get()`` and ``_do_put()``.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    PutQueue: ClassVar[Type[MutableSequence]] = list
<span class="w"> </span>    &quot;&quot;&quot;The type to be used for the :attr:`put_queue`. It is a plain
<span class="w"> </span>    :class:`list` by default. The type must support index access (e.g.
<span class="w"> </span>    ``__getitem__()`` and ``__len__()``) as well as provide ``append()`` and
<span class="w"> </span>    ``pop()`` operations.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    GetQueue: ClassVar[Type[MutableSequence]] = list
<span class="w"> </span>    &quot;&quot;&quot;The type to be used for the :attr:`get_queue`. It is a plain
<span class="w"> </span>    :class:`list` by default. The type must support index access (e.g.
<span class="gu">@@ -147,30 +173,34 @@ class BaseResource(Generic[PutType, GetType]):</span>
<span class="w"> </span>        &quot;&quot;&quot;Queue of pending *put* requests.&quot;&quot;&quot;
<span class="w"> </span>        self.get_queue: MutableSequence[GetType] = self.GetQueue()
<span class="w"> </span>        &quot;&quot;&quot;Queue of pending *get* requests.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+        # Bind event constructors as methods</span>
<span class="w"> </span>        BoundClass.bind_early(self)

<span class="w"> </span>    @property
<span class="gd">-    def capacity(self) -&gt;Union[float, int]:</span>
<span class="gi">+    def capacity(self) -&gt; Union[float, int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Maximum capacity of the resource.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._capacity</span>
<span class="gi">+</span>
<span class="w"> </span>    if TYPE_CHECKING:

<span class="gd">-        def put(self) -&gt;Put:</span>
<span class="gi">+        def put(self) -&gt; Put:</span>
<span class="w"> </span>            &quot;&quot;&quot;Request to put something into the resource and return a
<span class="w"> </span>            :class:`Put` event, which gets triggered once the request
<span class="w"> </span>            succeeds.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return Put(self)</span>

<span class="gd">-        def get(self) -&gt;Get:</span>
<span class="gi">+        def get(self) -&gt; Get:</span>
<span class="w"> </span>            &quot;&quot;&quot;Request to get something from the resource and return a
<span class="w"> </span>            :class:`Get` event, which gets triggered once the request
<span class="w"> </span>            succeeds.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return Get(self)</span>
<span class="gi">+</span>
<span class="w"> </span>    else:
<span class="w"> </span>        put = BoundClass(Put)
<span class="w"> </span>        get = BoundClass(Get)

<span class="gd">-    def _do_put(self, event: PutType) -&gt;Optional[bool]:</span>
<span class="gi">+    def _do_put(self, event: PutType) -&gt; Optional[bool]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Perform the *put* operation.

<span class="w"> </span>        This method needs to be implemented by subclasses. If the conditions
<span class="gu">@@ -181,9 +211,9 @@ class BaseResource(Generic[PutType, GetType]):</span>
<span class="w"> </span>        :attr:`put_queue`, as long as the return value does not evaluate
<span class="w"> </span>        ``False``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self)</span>

<span class="gd">-    def _trigger_put(self, get_event: Optional[GetType]) -&gt;None:</span>
<span class="gi">+    def _trigger_put(self, get_event: Optional[GetType]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;This method is called once a new put event has been created or a get
<span class="w"> </span>        event has been processed.

<span class="gu">@@ -191,9 +221,24 @@ class BaseResource(Generic[PutType, GetType]):</span>
<span class="w"> </span>        calls :meth:`_do_put` to check if the conditions for the event are met.
<span class="w"> </span>        If :meth:`_do_put` returns ``False``, the iteration is stopped early.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def _do_get(self, event: GetType) -&gt;Optional[bool]:</span>
<span class="gi">+        # Maintain queue invariant: All put requests must be untriggered.</span>
<span class="gi">+        # This code is not very pythonic because the queue interface should be</span>
<span class="gi">+        # simple (only append(), pop(), __getitem__() and __len__() are</span>
<span class="gi">+        # required).</span>
<span class="gi">+        idx = 0</span>
<span class="gi">+        while idx &lt; len(self.put_queue):</span>
<span class="gi">+            put_event = self.put_queue[idx]</span>
<span class="gi">+            proceed = self._do_put(put_event)</span>
<span class="gi">+            if not put_event.triggered:</span>
<span class="gi">+                idx += 1</span>
<span class="gi">+            elif self.put_queue.pop(idx) != put_event:</span>
<span class="gi">+                raise RuntimeError(&#39;Put queue invariant violated&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            if not proceed:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+    def _do_get(self, event: GetType) -&gt; Optional[bool]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Perform the *get* operation.

<span class="w"> </span>        This method needs to be implemented by subclasses. If the conditions
<span class="gu">@@ -204,9 +249,9 @@ class BaseResource(Generic[PutType, GetType]):</span>
<span class="w"> </span>        :attr:`get_queue`, as long as the return value does not evaluate
<span class="w"> </span>        ``False``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(self)</span>

<span class="gd">-    def _trigger_get(self, put_event: Optional[PutType]) -&gt;None:</span>
<span class="gi">+    def _trigger_get(self, put_event: Optional[PutType]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Trigger get events.

<span class="w"> </span>        This method is called once a new get event has been created or a put
<span class="gu">@@ -216,4 +261,19 @@ class BaseResource(Generic[PutType, GetType]):</span>
<span class="w"> </span>        calls :meth:`_do_get` to check if the conditions for the event are met.
<span class="w"> </span>        If :meth:`_do_get` returns ``False``, the iteration is stopped early.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # Maintain queue invariant: All get requests must be untriggered.</span>
<span class="gi">+        # This code is not very pythonic because the queue interface should be</span>
<span class="gi">+        # simple (only append(), pop(), __getitem__() and __len__() are</span>
<span class="gi">+        # required).</span>
<span class="gi">+        idx = 0</span>
<span class="gi">+        while idx &lt; len(self.get_queue):</span>
<span class="gi">+            get_event = self.get_queue[idx]</span>
<span class="gi">+            proceed = self._do_get(get_event)</span>
<span class="gi">+            if not get_event.triggered:</span>
<span class="gi">+                idx += 1</span>
<span class="gi">+            elif self.get_queue.pop(idx) != get_event:</span>
<span class="gi">+                raise RuntimeError(&#39;Get queue invariant violated&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            if not proceed:</span>
<span class="gi">+                break</span>
<span class="gh">diff --git a/src/simpy/resources/container.py b/src/simpy/resources/container.py</span>
<span class="gh">index 00aa6de..8fb6a2a 100644</span>
<span class="gd">--- a/src/simpy/resources/container.py</span>
<span class="gi">+++ b/src/simpy/resources/container.py</span>
<span class="gu">@@ -8,9 +8,12 @@ fuel tanks.</span>

<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Optional, Union
<span class="gi">+</span>
<span class="w"> </span>from simpy.core import BoundClass, Environment
<span class="w"> </span>from simpy.resources import base
<span class="gi">+</span>
<span class="w"> </span>ContainerAmount = Union[int, float]


<span class="gu">@@ -27,6 +30,7 @@ class ContainerPut(base.Put):</span>
<span class="w"> </span>            raise ValueError(f&#39;amount(={amount}) must be &gt; 0.&#39;)
<span class="w"> </span>        self.amount = amount
<span class="w"> </span>        &quot;&quot;&quot;The amount of matter to be put into the container.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(container)


<span class="gu">@@ -43,6 +47,7 @@ class ContainerGet(base.Get):</span>
<span class="w"> </span>            raise ValueError(f&#39;amount(={amount}) must be &gt; 0.&#39;)
<span class="w"> </span>        self.amount = amount
<span class="w"> </span>        &quot;&quot;&quot;The amount of matter to be taken out of the container.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(container)


<span class="gu">@@ -63,30 +68,58 @@ class Container(base.BaseResource):</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, env: Environment, capacity: ContainerAmount=float(</span>
<span class="gd">-        &#39;inf&#39;), init: ContainerAmount=0):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        env: Environment,</span>
<span class="gi">+        capacity: ContainerAmount = float(&#39;inf&#39;),</span>
<span class="gi">+        init: ContainerAmount = 0,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        if capacity &lt;= 0:
<span class="w"> </span>            raise ValueError(&#39;&quot;capacity&quot; must be &gt; 0.&#39;)
<span class="w"> </span>        if init &lt; 0:
<span class="w"> </span>            raise ValueError(&#39;&quot;init&quot; must be &gt;= 0.&#39;)
<span class="w"> </span>        if init &gt; capacity:
<span class="w"> </span>            raise ValueError(&#39;&quot;init&quot; must be &lt;= &quot;capacity&quot;.&#39;)
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(env, capacity)
<span class="gi">+</span>
<span class="w"> </span>        self._level = init

<span class="w"> </span>    @property
<span class="gd">-    def level(self) -&gt;ContainerAmount:</span>
<span class="gi">+    def level(self) -&gt; ContainerAmount:</span>
<span class="w"> </span>        &quot;&quot;&quot;The current amount of the matter in the container.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._level</span>
<span class="gi">+</span>
<span class="w"> </span>    if TYPE_CHECKING:

<span class="gd">-        def put(self, amount: ContainerAmount) -&gt;ContainerPut:</span>
<span class="gi">+        def put(  # type: ignore[override]</span>
<span class="gi">+            self, amount: ContainerAmount</span>
<span class="gi">+        ) -&gt; ContainerPut:</span>
<span class="w"> </span>            &quot;&quot;&quot;Request to put *amount* of matter into the container.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return ContainerPut(self, amount)</span>

<span class="gd">-        def get(self, amount: ContainerAmount) -&gt;ContainerGet:</span>
<span class="gi">+        def get(  # type: ignore[override]</span>
<span class="gi">+            self, amount: ContainerAmount</span>
<span class="gi">+        ) -&gt; ContainerGet:</span>
<span class="w"> </span>            &quot;&quot;&quot;Request to get *amount* of matter out of the container.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return ContainerGet(self, amount)</span>
<span class="gi">+</span>
<span class="w"> </span>    else:
<span class="w"> </span>        put = BoundClass(ContainerPut)
<span class="w"> </span>        get = BoundClass(ContainerGet)
<span class="gi">+</span>
<span class="gi">+    def _do_put(self, event: ContainerPut) -&gt; Optional[bool]:</span>
<span class="gi">+        if self._capacity - self._level &gt;= event.amount:</span>
<span class="gi">+            self._level += event.amount</span>
<span class="gi">+            event.succeed()</span>
<span class="gi">+            return True</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    def _do_get(self, event: ContainerGet) -&gt; Optional[bool]:</span>
<span class="gi">+        if self._level &gt;= event.amount:</span>
<span class="gi">+            self._level -= event.amount</span>
<span class="gi">+            event.succeed()</span>
<span class="gi">+            return True</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gh">diff --git a/src/simpy/resources/resource.py b/src/simpy/resources/resource.py</span>
<span class="gh">index 2c4f6dd..d48eb1c 100644</span>
<span class="gd">--- a/src/simpy/resources/resource.py</span>
<span class="gi">+++ b/src/simpy/resources/resource.py</span>
<span class="gu">@@ -29,11 +29,15 @@ whose resource users can be preempted by requests with a higher priority.</span>

<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any, List, Optional, Type
<span class="gi">+</span>
<span class="w"> </span>from simpy.core import BoundClass, Environment, SimTime
<span class="w"> </span>from simpy.resources import base
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from types import TracebackType
<span class="gi">+</span>
<span class="w"> </span>    from simpy.events import Process


<span class="gu">@@ -43,8 +47,12 @@ class Preempted:</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, by: Optional[Process], usage_since: Optional[SimTime</span>
<span class="gd">-        ], resource: Resource):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        by: Optional[Process],</span>
<span class="gi">+        usage_since: Optional[SimTime],</span>
<span class="gi">+        resource: Resource,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.by = by
<span class="w"> </span>        &quot;&quot;&quot;The preempting :class:`simpy.events.Process`.&quot;&quot;&quot;
<span class="w"> </span>        self.usage_since = usage_since
<span class="gu">@@ -67,13 +75,21 @@ class Request(base.Put):</span>
<span class="w"> </span>    a :keyword:`with` statement.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    resource: Resource
<span class="gi">+</span>
<span class="gi">+    #: The time at which the request succeeded.</span>
<span class="w"> </span>    usage_since: Optional[SimTime] = None

<span class="gd">-    def __exit__(self, exc_type: Optional[Type[BaseException]], exc_value:</span>
<span class="gd">-        Optional[BaseException], traceback: Optional[TracebackType]</span>
<span class="gd">-        ) -&gt;Optional[bool]:</span>
<span class="gi">+    def __exit__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        exc_type: Optional[Type[BaseException]],</span>
<span class="gi">+        exc_value: Optional[BaseException],</span>
<span class="gi">+        traceback: Optional[TracebackType],</span>
<span class="gi">+    ) -&gt; Optional[bool]:</span>
<span class="w"> </span>        super().__exit__(exc_type, exc_value, traceback)
<span class="gi">+        # Don&#39;t release the resource on generator cleanups. This seems to</span>
<span class="gi">+        # create un-claimable circular references otherwise.</span>
<span class="w"> </span>        if exc_type is not GeneratorExit:
<span class="w"> </span>            self.resource.release(self)
<span class="w"> </span>        return None
<span class="gu">@@ -103,21 +119,24 @@ class PriorityRequest(Request):</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, resource: Resource, priority: int=0, preempt: bool=True</span>
<span class="gd">-        ):</span>
<span class="gi">+    def __init__(self, resource: Resource, priority: int = 0, preempt: bool = True):</span>
<span class="w"> </span>        self.priority = priority
<span class="w"> </span>        &quot;&quot;&quot;The priority of this request. A smaller number means higher
<span class="w"> </span>        priority.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self.preempt = preempt
<span class="w"> </span>        &quot;&quot;&quot;Indicates whether the request should preempt a resource user or not
<span class="w"> </span>        (:class:`PriorityResource` ignores this flag).&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        self.time = resource._env.now
<span class="w"> </span>        &quot;&quot;&quot;The time at which the request was made.&quot;&quot;&quot;
<span class="gd">-        self.key = self.priority, self.time, not self.preempt</span>
<span class="gi">+</span>
<span class="gi">+        self.key = (self.priority, self.time, not self.preempt)</span>
<span class="w"> </span>        &quot;&quot;&quot;Key for sorting events. Consists of the priority (lower value is
<span class="w"> </span>        more important), the time at which the request was made (earlier
<span class="w"> </span>        requests are more important) and finally the preemption flag (preempt
<span class="w"> </span>        requests are more important).&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(resource)


<span class="gu">@@ -127,18 +146,22 @@ class SortedQueue(list):</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, maxlen: Optional[int]=None):</span>
<span class="gi">+    def __init__(self, maxlen: Optional[int] = None):</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.maxlen = maxlen
<span class="w"> </span>        &quot;&quot;&quot;Maximum length of the queue.&quot;&quot;&quot;

<span class="gd">-    def append(self, item: Any) -&gt;None:</span>
<span class="gi">+    def append(self, item: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sort *item* into the queue.

<span class="w"> </span>        Raise a :exc:`RuntimeError` if the queue is full.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.maxlen is not None and len(self) &gt;= self.maxlen:</span>
<span class="gi">+            raise RuntimeError(&#39;Cannot append event. Queue is full.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        super().append(item)</span>
<span class="gi">+        super().sort(key=lambda e: e.key)</span>


<span class="w"> </span>class Resource(base.BaseResource):
<span class="gu">@@ -153,10 +176,12 @@ class Resource(base.BaseResource):</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, env: Environment, capacity: int=1):</span>
<span class="gi">+    def __init__(self, env: Environment, capacity: int = 1):</span>
<span class="w"> </span>        if capacity &lt;= 0:
<span class="w"> </span>            raise ValueError(&#39;&quot;capacity&quot; must be &gt; 0.&#39;)
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(env, capacity)
<span class="gi">+</span>
<span class="w"> </span>        self.users: List[Request] = []
<span class="w"> </span>        &quot;&quot;&quot;List of :class:`Request` events for the processes that are currently
<span class="w"> </span>        using the resource.&quot;&quot;&quot;
<span class="gu">@@ -166,22 +191,37 @@ class Resource(base.BaseResource):</span>
<span class="w"> </span>        &quot;&quot;&quot;

<span class="w"> </span>    @property
<span class="gd">-    def count(self) -&gt;int:</span>
<span class="gi">+    def count(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Number of users currently using the resource.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return len(self.users)</span>
<span class="gi">+</span>
<span class="w"> </span>    if TYPE_CHECKING:

<span class="gd">-        def request(self) -&gt;Request:</span>
<span class="gi">+        def request(self) -&gt; Request:</span>
<span class="w"> </span>            &quot;&quot;&quot;Request a usage slot.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return Request(self)</span>

<span class="gd">-        def release(self, request: Request) -&gt;Release:</span>
<span class="gi">+        def release(self, request: Request) -&gt; Release:</span>
<span class="w"> </span>            &quot;&quot;&quot;Release a usage slot.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return Release(self, request)</span>
<span class="gi">+</span>
<span class="w"> </span>    else:
<span class="w"> </span>        request = BoundClass(Request)
<span class="w"> </span>        release = BoundClass(Release)

<span class="gi">+    def _do_put(self, event: Request) -&gt; None:</span>
<span class="gi">+        if len(self.users) &lt; self.capacity:</span>
<span class="gi">+            self.users.append(event)</span>
<span class="gi">+            event.usage_since = self._env.now</span>
<span class="gi">+            event.succeed()</span>
<span class="gi">+</span>
<span class="gi">+    def _do_get(self, event: Release) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.users.remove(event.request)  # type: ignore</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        event.succeed()</span>
<span class="gi">+</span>

<span class="w"> </span>class PriorityResource(Resource):
<span class="w"> </span>    &quot;&quot;&quot;A :class:`~simpy.resources.resource.Resource` supporting prioritized
<span class="gu">@@ -191,25 +231,30 @@ class PriorityResource(Resource):</span>
<span class="w"> </span>    order by their *priority* (that means lower values are more important).

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    PutQueue = SortedQueue
<span class="w"> </span>    &quot;&quot;&quot;Type of the put queue. See
<span class="w"> </span>    :attr:`~simpy.resources.base.BaseResource.put_queue` for details.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    GetQueue = list
<span class="w"> </span>    &quot;&quot;&quot;Type of the get queue. See
<span class="w"> </span>    :attr:`~simpy.resources.base.BaseResource.get_queue` for details.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, env: Environment, capacity: int=1):</span>
<span class="gi">+    def __init__(self, env: Environment, capacity: int = 1):</span>
<span class="w"> </span>        super().__init__(env, capacity)
<span class="gi">+</span>
<span class="w"> </span>    if TYPE_CHECKING:

<span class="gd">-        def request(self, priority: int=0, preempt: bool=True</span>
<span class="gd">-            ) -&gt;PriorityRequest:</span>
<span class="gi">+        def request(self, priority: int = 0, preempt: bool = True) -&gt; PriorityRequest:</span>
<span class="w"> </span>            &quot;&quot;&quot;Request a usage slot with the given *priority*.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return PriorityRequest(self, priority, preempt)</span>

<span class="gd">-        def release(self, request: PriorityRequest) -&gt;Release:</span>
<span class="gi">+        def release(  # type: ignore[override]</span>
<span class="gi">+            self, request: PriorityRequest</span>
<span class="gi">+        ) -&gt; Release:</span>
<span class="w"> </span>            &quot;&quot;&quot;Release a usage slot.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return Release(self, request)</span>
<span class="gi">+</span>
<span class="w"> </span>    else:
<span class="w"> </span>        request = BoundClass(PriorityRequest)
<span class="w"> </span>        release = BoundClass(Release)
<span class="gu">@@ -223,4 +268,23 @@ class PreemptiveResource(PriorityResource):</span>
<span class="w"> </span>    cause.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    users: List[PriorityRequest]</span>
<span class="gi">+</span>
<span class="gi">+    users: List[PriorityRequest]  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    def _do_put(  # type: ignore[override]</span>
<span class="gi">+        self, event: PriorityRequest</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if len(self.users) &gt;= self.capacity and event.preempt:</span>
<span class="gi">+            # Check if we can preempt another process</span>
<span class="gi">+            preempt = sorted(self.users, key=lambda e: e.key)[-1]</span>
<span class="gi">+            if preempt.key &gt; event.key:</span>
<span class="gi">+                self.users.remove(preempt)</span>
<span class="gi">+                preempt.proc.interrupt(  # type: ignore</span>
<span class="gi">+                    Preempted(</span>
<span class="gi">+                        by=event.proc,</span>
<span class="gi">+                        usage_since=preempt.usage_since,</span>
<span class="gi">+                        resource=self,</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        return super()._do_put(event)</span>
<span class="gh">diff --git a/src/simpy/resources/store.py b/src/simpy/resources/store.py</span>
<span class="gh">index 5875e6d..13ac1ca 100644</span>
<span class="gd">--- a/src/simpy/resources/store.py</span>
<span class="gi">+++ b/src/simpy/resources/store.py</span>
<span class="gu">@@ -9,8 +9,18 @@ matching a given criterion.</span>

<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from heapq import heappop, heappush
<span class="gd">-from typing import TYPE_CHECKING, Any, Callable, List, NamedTuple, Optional, Union</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    List,</span>
<span class="gi">+    NamedTuple,</span>
<span class="gi">+    Optional,</span>
<span class="gi">+    Union,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from simpy.core import BoundClass, Environment
<span class="w"> </span>from simpy.resources import base

<span class="gu">@@ -45,8 +55,11 @@ class FilterStoreGet(StoreGet):</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, resource: FilterStore, filter: Callable[[Any], bool]</span>
<span class="gd">-        =lambda item: True):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        resource: FilterStore,</span>
<span class="gi">+        filter: Callable[[Any], bool] = lambda item: True,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.filter = filter
<span class="w"> </span>        &quot;&quot;&quot;The filter function to filter items in the store.&quot;&quot;&quot;
<span class="w"> </span>        super().__init__(resource)
<span class="gu">@@ -62,26 +75,42 @@ class Store(base.BaseResource):</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, env: Environment, capacity: Union[float, int]=float(</span>
<span class="gd">-        &#39;inf&#39;)):</span>
<span class="gi">+    def __init__(self, env: Environment, capacity: Union[float, int] = float(&#39;inf&#39;)):</span>
<span class="w"> </span>        if capacity &lt;= 0:
<span class="w"> </span>            raise ValueError(&#39;&quot;capacity&quot; must be &gt; 0.&#39;)
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(env, capacity)
<span class="gi">+</span>
<span class="w"> </span>        self.items: List[Any] = []
<span class="w"> </span>        &quot;&quot;&quot;List of the items available in the store.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    if TYPE_CHECKING:

<span class="gd">-        def put(self, item: Any) -&gt;StorePut:</span>
<span class="gi">+        def put(  # type: ignore[override]</span>
<span class="gi">+            self, item: Any</span>
<span class="gi">+        ) -&gt; StorePut:</span>
<span class="w"> </span>            &quot;&quot;&quot;Request to put *item* into the store.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return StorePut(self, item)</span>

<span class="gd">-        def get(self) -&gt;StoreGet:</span>
<span class="gi">+        def get(self) -&gt; StoreGet:  # type: ignore[override]</span>
<span class="w"> </span>            &quot;&quot;&quot;Request to get an *item* out of the store.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return StoreGet(self)</span>
<span class="gi">+</span>
<span class="w"> </span>    else:
<span class="w"> </span>        put = BoundClass(StorePut)
<span class="w"> </span>        get = BoundClass(StoreGet)

<span class="gi">+    def _do_put(self, event: StorePut) -&gt; Optional[bool]:</span>
<span class="gi">+        if len(self.items) &lt; self._capacity:</span>
<span class="gi">+            self.items.append(event.item)</span>
<span class="gi">+            event.succeed()</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _do_get(self, event: StoreGet) -&gt; Optional[bool]:</span>
<span class="gi">+        if self.items:</span>
<span class="gi">+            event.succeed(self.items.pop(0))</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>

<span class="w"> </span>class PriorityItem(NamedTuple):
<span class="w"> </span>    &quot;&quot;&quot;Wrap an arbitrary *item* with an order-able *priority*.
<span class="gu">@@ -91,10 +120,16 @@ class PriorityItem(NamedTuple):</span>
<span class="w"> </span>    unorderable items in a :class:`PriorityStore` instance.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    #: Priority of the item.</span>
<span class="w"> </span>    priority: Any
<span class="gi">+</span>
<span class="gi">+    #: The item to be stored.</span>
<span class="w"> </span>    item: Any

<span class="gd">-    def __lt__(self, other: PriorityItem) -&gt;bool:</span>
<span class="gi">+    def __lt__(  # type: ignore[override]</span>
<span class="gi">+        self, other: PriorityItem</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        return self.priority &lt; other.priority


<span class="gu">@@ -111,6 +146,17 @@ class PriorityStore(Store):</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def _do_put(self, event: StorePut) -&gt; Optional[bool]:</span>
<span class="gi">+        if len(self.items) &lt; self._capacity:</span>
<span class="gi">+            heappush(self.items, event.item)</span>
<span class="gi">+            event.succeed()</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _do_get(self, event: StoreGet) -&gt; Optional[bool]:</span>
<span class="gi">+        if self.items:</span>
<span class="gi">+            event.succeed(heappop(self.items))</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>

<span class="w"> </span>class FilterStore(Store):
<span class="w"> </span>    &quot;&quot;&quot;Resource with *capacity* slots for storing arbitrary objects supporting
<span class="gu">@@ -133,12 +179,25 @@ class FilterStore(Store):</span>
<span class="w"> </span>        want it.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    if TYPE_CHECKING:

<span class="gd">-        def get(self, filter: Callable[[Any], bool]=lambda item: True</span>
<span class="gd">-            ) -&gt;FilterStoreGet:</span>
<span class="gi">+        def get(</span>
<span class="gi">+            self, filter: Callable[[Any], bool] = lambda item: True</span>
<span class="gi">+        ) -&gt; FilterStoreGet:</span>
<span class="w"> </span>            &quot;&quot;&quot;Request to get an *item*, for which *filter* returns ``True``,
<span class="w"> </span>            out of the store.&quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return FilterStoreGet(self, filter)</span>
<span class="gi">+</span>
<span class="w"> </span>    else:
<span class="w"> </span>        get = BoundClass(FilterStoreGet)
<span class="gi">+</span>
<span class="gi">+    def _do_get(  # type: ignore[override]</span>
<span class="gi">+        self, event: FilterStoreGet</span>
<span class="gi">+    ) -&gt; Optional[bool]:</span>
<span class="gi">+        for item in self.items:</span>
<span class="gi">+            if event.filter(item):</span>
<span class="gi">+                self.items.remove(item)</span>
<span class="gi">+                event.succeed(item)</span>
<span class="gi">+                break</span>
<span class="gi">+        return True</span>
<span class="gh">diff --git a/src/simpy/rt.py b/src/simpy/rt.py</span>
<span class="gh">index 9d99392..284cb45 100644</span>
<span class="gd">--- a/src/simpy/rt.py</span>
<span class="gi">+++ b/src/simpy/rt.py</span>
<span class="gu">@@ -3,6 +3,7 @@ with the real-time (aka *wall-clock time*).</span>

<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from time import monotonic, sleep
<span class="gi">+</span>
<span class="w"> </span>from simpy.core import EmptySchedule, Environment, Infinity, SimTime


<span class="gu">@@ -20,27 +21,32 @@ class RealtimeEnvironment(Environment):</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, initial_time: SimTime=0, factor: float=1.0, strict:</span>
<span class="gd">-        bool=True):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        initial_time: SimTime = 0,</span>
<span class="gi">+        factor: float = 1.0,</span>
<span class="gi">+        strict: bool = True,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        Environment.__init__(self, initial_time)
<span class="gi">+</span>
<span class="w"> </span>        self.env_start = initial_time
<span class="w"> </span>        self.real_start = monotonic()
<span class="w"> </span>        self._factor = factor
<span class="w"> </span>        self._strict = strict

<span class="w"> </span>    @property
<span class="gd">-    def factor(self) -&gt;float:</span>
<span class="gi">+    def factor(self) -&gt; float:</span>
<span class="w"> </span>        &quot;&quot;&quot;Scaling factor of the real-time.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._factor</span>

<span class="w"> </span>    @property
<span class="gd">-    def strict(self) -&gt;bool:</span>
<span class="gi">+    def strict(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Running mode of the environment. :meth:`step()` will raise a
<span class="w"> </span>        :exc:`RuntimeError` if this is set to ``True`` and the processing of
<span class="w"> </span>        events takes too long.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._strict</span>

<span class="gd">-    def sync(self) -&gt;None:</span>
<span class="gi">+    def sync(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Synchronize the internal time with the current wall-clock time.

<span class="w"> </span>        This can be useful to prevent :meth:`step()` from raising an error if
<span class="gu">@@ -48,9 +54,9 @@ class RealtimeEnvironment(Environment):</span>
<span class="w"> </span>        calling :meth:`run()` or :meth:`step()`.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.real_start = monotonic()</span>

<span class="gd">-    def step(self) -&gt;None:</span>
<span class="gi">+    def step(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Process the next event after enough real-time has passed for the
<span class="w"> </span>        event to happen.

<span class="gu">@@ -59,4 +65,26 @@ class RealtimeEnvironment(Environment):</span>
<span class="w"> </span>        the event is processed too slowly.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        evt_time = self.peek()</span>
<span class="gi">+</span>
<span class="gi">+        if evt_time is Infinity:</span>
<span class="gi">+            raise EmptySchedule</span>
<span class="gi">+</span>
<span class="gi">+        real_time = self.real_start + (evt_time - self.env_start) * self.factor</span>
<span class="gi">+</span>
<span class="gi">+        if self.strict and monotonic() - real_time &gt; self.factor:</span>
<span class="gi">+            # Events scheduled for time *t* may take just up to *t+1*</span>
<span class="gi">+            # for their computation, before an error is raised.</span>
<span class="gi">+            delta = monotonic() - real_time</span>
<span class="gi">+            raise RuntimeError(f&#39;Simulation too slow for real time ({delta:.3f}s).&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        # Sleep in a loop to fix inaccuracies of windows (see</span>
<span class="gi">+        # http://stackoverflow.com/a/15967564 for details) and to ignore</span>
<span class="gi">+        # interrupts.</span>
<span class="gi">+        while True:</span>
<span class="gi">+            delta = real_time - monotonic()</span>
<span class="gi">+            if delta &lt;= 0:</span>
<span class="gi">+                break</span>
<span class="gi">+            sleep(delta)</span>
<span class="gi">+</span>
<span class="gi">+        Environment.step(self)</span>
<span class="gh">diff --git a/src/simpy/util.py b/src/simpy/util.py</span>
<span class="gh">index 5e3a81a..7bb5d27 100644</span>
<span class="gd">--- a/src/simpy/util.py</span>
<span class="gi">+++ b/src/simpy/util.py</span>
<span class="gu">@@ -6,12 +6,14 @@ A collection of utility functions:</span>

<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from typing import Generator
<span class="gi">+</span>
<span class="w"> </span>from simpy.core import Environment, SimTime
<span class="w"> </span>from simpy.events import Event, Process, ProcessGenerator


<span class="gd">-def start_delayed(env: Environment, generator: ProcessGenerator, delay: SimTime</span>
<span class="gd">-    ) -&gt;Process:</span>
<span class="gi">+def start_delayed(</span>
<span class="gi">+    env: Environment, generator: ProcessGenerator, delay: SimTime</span>
<span class="gi">+) -&gt; Process:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a helper process that starts another process for *generator*
<span class="w"> </span>    after a certain *delay*.

<span class="gu">@@ -33,10 +35,18 @@ def start_delayed(env: Environment, generator: ProcessGenerator, delay: SimTime</span>
<span class="w"> </span>    Raise a :exc:`ValueError` if ``delay &lt;= 0``.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if delay &lt;= 0:</span>
<span class="gi">+        raise ValueError(f&#39;delay(={delay}) must be &gt; 0.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def starter() -&gt; Generator[Event, None, Process]:</span>
<span class="gi">+        yield env.timeout(delay)</span>
<span class="gi">+        proc = env.process(generator)</span>
<span class="gi">+        return proc</span>
<span class="gi">+</span>
<span class="gi">+    return env.process(starter())</span>


<span class="gd">-def subscribe_at(event: Event) -&gt;None:</span>
<span class="gi">+def subscribe_at(event: Event) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Register at the *event* to receive an interrupt when it occurs.

<span class="w"> </span>    The most common use case for this is to pass
<span class="gu">@@ -45,4 +55,16 @@ def subscribe_at(event: Event) -&gt;None:</span>
<span class="w"> </span>    Raise a :exc:`RuntimeError` if ``event`` has already occurred.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    env = event.env</span>
<span class="gi">+    assert env.active_process is not None</span>
<span class="gi">+    subscriber = env.active_process</span>
<span class="gi">+</span>
<span class="gi">+    def signaller(signaller: Event, receiver: Process) -&gt; ProcessGenerator:</span>
<span class="gi">+        result = yield signaller</span>
<span class="gi">+        if receiver.is_alive:</span>
<span class="gi">+            receiver.interrupt((signaller, result))</span>
<span class="gi">+</span>
<span class="gi">+    if event.callbacks is not None:</span>
<span class="gi">+        env.process(signaller(event, subscriber))</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise RuntimeError(f&#39;{event} has already terminated.&#39;)</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>