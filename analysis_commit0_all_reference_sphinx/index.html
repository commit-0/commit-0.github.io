
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference sphinx - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-sphinx" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference sphinx
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_command_linepytest_build_main_parse_arguments_filenames_last" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_line.py::test_build_main_parse_arguments_filenames_last
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_command_linepytest_make_mode_parse_arguments_filenames_last" class="md-nav__link">
    <span class="md-ellipsis">
      test_command_line.py::test_make_mode_parse_arguments_filenames_last
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-sphinx"><strong>Reference (Gold)</strong>: sphinx</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">2187</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">22</td>
</tr>
<tr>
<td style="text-align: left;">xfailed</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">2211</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">2211</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_command_linepytest_build_main_parse_arguments_filenames_last">test_command_line.py::test_build_main_parse_arguments_filenames_last</h3>
<details><summary> <pre>test_command_line.py::test_build_main_parse_arguments_filenames_last</pre></summary><pre>
@pytest.mark.xfail(reason='sphinx-build does not yet support filenames after options')
    def test_build_main_parse_arguments_filenames_last() -> None:
        args = [
            *POSITIONAL_DIRS,
            *OPTS,
            *POSITIONAL_FILENAMES,
        ]
>       assert parse_arguments(args) == EXPECTED_BUILD_MAIN

tests/test_command_line.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests/test_command_line.py:86: in parse_arguments
    parsed = vars(get_parser().parse_args(args))
/usr/lib/python3.10/argparse.py:1848: in parse_args
    self.error(msg % ' '.join(argv))
/usr/lib/python3.10/argparse.py:2606: in error
    self.exit(2, _('%(prog)s: error: %(message)s\n') % args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = ArgumentParser(prog='pytest', usage='%(prog)s [OPTIONS] SOURCEDIR OUTPUTDIR [FILENAMES...]', description=i"\nGenerate ...ng individual filenames.\n", formatter_class=<class 'argparse.HelpFormatter'>, conflict_handler='error', add_help=True)
status = 2
message = 'pytest: error: unrecognized arguments: filename1 filename2\n'

    def exit(self, status=0, message=None):
        if message:
            self._print_message(message, _sys.stderr)
>       _sys.exit(status)
E       SystemExit: 2

/usr/lib/python3.10/argparse.py:2593: SystemExit
</pre>
</details>
<h3 id="test_command_linepytest_make_mode_parse_arguments_filenames_last">test_command_line.py::test_make_mode_parse_arguments_filenames_last</h3>
<details><summary> <pre>test_command_line.py::test_make_mode_parse_arguments_filenames_last</pre></summary><pre>
monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7ff2a4766140>

    @pytest.mark.xfail(reason='sphinx-build does not yet support filenames after options')
    def test_make_mode_parse_arguments_filenames_last(
        monkeypatch: pytest.MonkeyPatch,
    ) -> None:
        monkeypatch.setattr(make_mode, 'build_main', parse_arguments)
        args = [
            *BUILDER_MAKE_MODE,
            *POSITIONAL_DIRS,
            *OPTS,
            *POSITIONAL_FILENAMES,
        ]
>       assert run_make_mode(args) == EXPECTED_MAKE_MODE

tests/test_command_line.py:199: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
sphinx/cmd/make_mode.py:206: in run_make_mode
    return make.run_generic_build(builder_name)
sphinx/cmd/make_mode.py:192: in run_generic_build
    return build_main(args + self.opts)
tests/test_command_line.py:86: in parse_arguments
    parsed = vars(get_parser().parse_args(args))
/usr/lib/python3.10/argparse.py:1848: in parse_args
    self.error(msg % ' '.join(argv))
/usr/lib/python3.10/argparse.py:2606: in error
    self.exit(2, _('%(prog)s: error: %(message)s\n') % args)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = ArgumentParser(prog='pytest', usage='%(prog)s [OPTIONS] SOURCEDIR OUTPUTDIR [FILENAMES...]', description=i"\nGenerate ...ng individual filenames.\n", formatter_class=<class 'argparse.HelpFormatter'>, conflict_handler='error', add_help=True)
status = 2
message = 'pytest: error: unrecognized arguments: filename1 filename2\n'

    def exit(self, status=0, message=None):
        if message:
            self._print_message(message, _sys.stderr)
>       _sys.exit(status)
E       SystemExit: 2

/usr/lib/python3.10/argparse.py:2593: SystemExit
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/sphinx/_cli/util/colour.py b/sphinx/_cli/util/colour.py</span>
<span class="gh">index 4ae735270..a89d04ec5 100644</span>
<span class="gd">--- a/sphinx/_cli/util/colour.py</span>
<span class="gi">+++ b/sphinx/_cli/util/colour.py</span>
<span class="gu">@@ -1,26 +1,89 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Format coloured console output.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="gd">-from collections.abc import Callable</span>
<span class="gi">+from collections.abc import Callable  # NoQA: TCH003</span>
<span class="gi">+</span>
<span class="w"> </span>if sys.platform == &#39;win32&#39;:
<span class="w"> </span>    import colorama
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>_COLOURING_DISABLED = True


<span class="gd">-def terminal_supports_colour() -&gt;bool:</span>
<span class="gi">+def terminal_supports_colour() -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return True if coloured terminal output is supported.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &#39;NO_COLOUR&#39; in os.environ or &#39;NO_COLOR&#39; in os.environ:</span>
<span class="gi">+        return False</span>
<span class="gi">+    if &#39;FORCE_COLOUR&#39; in os.environ or &#39;FORCE_COLOR&#39; in os.environ:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        if not sys.stdout.isatty():</span>
<span class="gi">+            return False</span>
<span class="gi">+    except (AttributeError, ValueError):</span>
<span class="gi">+        # Handle cases where .isatty() is not defined, or where e.g.</span>
<span class="gi">+        # &quot;ValueError: I/O operation on closed file&quot; is raised</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # Do not colour output if on a dumb terminal</span>
<span class="gi">+    return os.environ.get(&#39;TERM&#39;, &#39;unknown&#39;).lower() not in {&#39;dumb&#39;, &#39;unknown&#39;}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def disable_colour() -&gt; None:</span>
<span class="gi">+    global _COLOURING_DISABLED</span>
<span class="gi">+    _COLOURING_DISABLED = True</span>
<span class="gi">+    if sys.platform == &#39;win32&#39;:</span>
<span class="gi">+        colorama.deinit()</span>
<span class="gi">+</span>

<span class="gi">+def enable_colour() -&gt; None:</span>
<span class="gi">+    global _COLOURING_DISABLED</span>
<span class="gi">+    _COLOURING_DISABLED = False</span>
<span class="gi">+    if sys.platform == &#39;win32&#39;:</span>
<span class="gi">+        colorama.init()</span>

<span class="gi">+</span>
<span class="gi">+def colourise(colour_name: str, text: str, /) -&gt; str:</span>
<span class="gi">+    if _COLOURING_DISABLED:</span>
<span class="gi">+        return text</span>
<span class="gi">+    return globals()[colour_name](text)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _create_colour_func(escape_code: str, /) -&gt; Callable[[str], str]:</span>
<span class="gi">+    def inner(text: str) -&gt; str:</span>
<span class="gi">+        if _COLOURING_DISABLED:</span>
<span class="gi">+            return text</span>
<span class="gi">+        return f&#39;\x1b[{escape_code}m{text}\x1b[39;49;00m&#39;</span>
<span class="gi">+    return inner</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Wrap escape sequence with ``\1`` and ``\2`` to let readline know</span>
<span class="gi">+# that the colour escape codes are non-printable characters</span>
<span class="gi">+# [ https://tiswww.case.edu/php/chet/readline/readline.html ]</span>
<span class="gi">+#</span>
<span class="gi">+# Note: This does not work well in Windows</span>
<span class="gi">+# (see https://github.com/sphinx-doc/sphinx/pull/5059)</span>
<span class="w"> </span>if sys.platform == &#39;win32&#39;:
<span class="w"> </span>    _create_input_mode_colour_func = _create_colour_func
<span class="gi">+else:</span>
<span class="gi">+    def _create_input_mode_colour_func(escape_code: str, /) -&gt; Callable[[str], str]:</span>
<span class="gi">+        def inner(text: str) -&gt; str:</span>
<span class="gi">+            if _COLOURING_DISABLED:</span>
<span class="gi">+                return text</span>
<span class="gi">+            return f&#39;\x01\x1b[{escape_code}m\x02{text}\x01\x1b[39;49;00m\x02&#39;</span>
<span class="gi">+        return inner</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>reset = _create_colour_func(&#39;39;49;00&#39;)
<span class="w"> </span>bold = _create_colour_func(&#39;01&#39;)
<span class="w"> </span>faint = _create_colour_func(&#39;02&#39;)
<span class="w"> </span>standout = _create_colour_func(&#39;03&#39;)
<span class="w"> </span>underline = _create_colour_func(&#39;04&#39;)
<span class="w"> </span>blink = _create_colour_func(&#39;05&#39;)
<span class="gi">+</span>
<span class="w"> </span>black = _create_colour_func(&#39;30&#39;)
<span class="w"> </span>darkred = _create_colour_func(&#39;31&#39;)
<span class="w"> </span>darkgreen = _create_colour_func(&#39;32&#39;)
<span class="gu">@@ -29,6 +92,7 @@ darkblue = _create_colour_func(&#39;34&#39;)</span>
<span class="w"> </span>purple = _create_colour_func(&#39;35&#39;)
<span class="w"> </span>turquoise = _create_colour_func(&#39;36&#39;)
<span class="w"> </span>lightgray = _create_colour_func(&#39;37&#39;)
<span class="gi">+</span>
<span class="w"> </span>darkgray = _create_colour_func(&#39;90&#39;)
<span class="w"> </span>red = _create_colour_func(&#39;91&#39;)
<span class="w"> </span>green = _create_colour_func(&#39;92&#39;)
<span class="gh">diff --git a/sphinx/_cli/util/errors.py b/sphinx/_cli/util/errors.py</span>
<span class="gh">index c3e0cc08b..dac0fb83c 100644</span>
<span class="gd">--- a/sphinx/_cli/util/errors.py</span>
<span class="gi">+++ b/sphinx/_cli/util/errors.py</span>
<span class="gu">@@ -1,19 +1,165 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>import sys
<span class="w"> </span>import tempfile
<span class="w"> </span>from typing import TYPE_CHECKING, TextIO
<span class="gi">+</span>
<span class="w"> </span>from sphinx.errors import SphinxParallelError
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="gi">+</span>
<span class="w"> </span>_ANSI_COLOUR_CODES: re.Pattern[str] = re.compile(&#39;\x1b.*?m&#39;)


<span class="gd">-def terminal_safe(s: str, /) -&gt;str:</span>
<span class="gi">+def terminal_safe(s: str, /) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Safely encode a string for printing to the terminal.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return s.encode(&#39;ascii&#39;, &#39;backslashreplace&#39;).decode(&#39;ascii&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def strip_colors(s: str, /) -&gt; str:</span>
<span class="gi">+    return _ANSI_COLOUR_CODES.sub(&#39;&#39;, s).strip()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def error_info(messages: str, extensions: str, traceback: str) -&gt; str:</span>
<span class="gi">+    import platform</span>
<span class="gi">+</span>
<span class="gi">+    import docutils</span>
<span class="gi">+    import jinja2</span>
<span class="gi">+    import pygments</span>
<span class="gi">+</span>
<span class="gi">+    import sphinx</span>

<span class="gi">+    return f&quot;&quot;&quot;\</span>
<span class="gi">+Versions</span>
<span class="gi">+========</span>

<span class="gd">-def save_traceback(app: (Sphinx | None), exc: BaseException) -&gt;str:</span>
<span class="gi">+* Platform:         {sys.platform}; ({platform.platform()})</span>
<span class="gi">+* Python version:   {platform.python_version()} ({platform.python_implementation()})</span>
<span class="gi">+* Sphinx version:   {sphinx.__display_version__}</span>
<span class="gi">+* Docutils version: {docutils.__version__}</span>
<span class="gi">+* Jinja2 version:   {jinja2.__version__}</span>
<span class="gi">+* Pygments version: {pygments.__version__}</span>
<span class="gi">+</span>
<span class="gi">+Last Messages</span>
<span class="gi">+=============</span>
<span class="gi">+</span>
<span class="gi">+{messages}</span>
<span class="gi">+</span>
<span class="gi">+Loaded Extensions</span>
<span class="gi">+=================</span>
<span class="gi">+</span>
<span class="gi">+{extensions}</span>
<span class="gi">+</span>
<span class="gi">+Traceback</span>
<span class="gi">+=========</span>
<span class="gi">+</span>
<span class="gi">+{traceback}</span>
<span class="gi">+&quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def save_traceback(app: Sphinx | None, exc: BaseException) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Save the given exception&#39;s traceback in a temporary file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(exc, SphinxParallelError):</span>
<span class="gi">+        exc_format = &#39;(Error in parallel process)\n&#39; + exc.traceback</span>
<span class="gi">+    else:</span>
<span class="gi">+        import traceback</span>
<span class="gi">+</span>
<span class="gi">+        exc_format = traceback.format_exc()</span>
<span class="gi">+</span>
<span class="gi">+    last_msgs = exts_list = &#39;&#39;</span>
<span class="gi">+    if app is not None:</span>
<span class="gi">+        extensions = app.extensions.values()</span>
<span class="gi">+        last_msgs = &#39;\n&#39;.join(f&#39;* {strip_colors(s)}&#39; for s in app.messagelog)</span>
<span class="gi">+        exts_list = &#39;\n&#39;.join(f&#39;* {ext.name} ({ext.version})&#39; for ext in extensions</span>
<span class="gi">+                              if ext.version != &#39;builtin&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    with tempfile.NamedTemporaryFile(suffix=&#39;.log&#39;, prefix=&#39;sphinx-err-&#39;, delete=False) as f:</span>
<span class="gi">+        f.write(error_info(last_msgs, exts_list, exc_format).encode(&#39;utf-8&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    return f.name</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def handle_exception(</span>
<span class="gi">+    exception: BaseException,</span>
<span class="gi">+    /,</span>
<span class="gi">+    *,</span>
<span class="gi">+    stderr: TextIO = sys.stderr,</span>
<span class="gi">+    use_pdb: bool = False,</span>
<span class="gi">+    print_traceback: bool = False,</span>
<span class="gi">+    app: Sphinx | None = None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="gi">+    from bdb import BdbQuit</span>
<span class="gi">+    from traceback import TracebackException, print_exc</span>
<span class="gi">+</span>
<span class="gi">+    from docutils.utils import SystemMessage</span>
<span class="gi">+</span>
<span class="gi">+    from sphinx._cli.util.colour import red</span>
<span class="gi">+    from sphinx.errors import SphinxError</span>
<span class="gi">+    from sphinx.locale import __</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(exception, BdbQuit):</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    def print_err(*values: str) -&gt; None:</span>
<span class="gi">+        print(*values, file=stderr)</span>
<span class="gi">+</span>
<span class="gi">+    def print_red(*values: str) -&gt; None:</span>
<span class="gi">+        print_err(*map(red, values))</span>
<span class="gi">+</span>
<span class="gi">+    print_err()</span>
<span class="gi">+    if print_traceback or use_pdb:</span>
<span class="gi">+        print_exc(file=stderr)</span>
<span class="gi">+        print_err()</span>
<span class="gi">+</span>
<span class="gi">+    if use_pdb:</span>
<span class="gi">+        from pdb import post_mortem</span>
<span class="gi">+</span>
<span class="gi">+        print_red(__(&#39;Exception occurred, starting debugger:&#39;))</span>
<span class="gi">+        post_mortem()</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(exception, KeyboardInterrupt):</span>
<span class="gi">+        print_err(__(&#39;Interrupted!&#39;))</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(exception, SystemMessage):</span>
<span class="gi">+        print_red(__(&#39;reStructuredText markup error:&#39;))</span>
<span class="gi">+        print_err(str(exception))</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(exception, SphinxError):</span>
<span class="gi">+        print_red(f&#39;{exception.category}:&#39;)</span>
<span class="gi">+        print_err(str(exception))</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(exception, UnicodeError):</span>
<span class="gi">+        print_red(__(&#39;Encoding error:&#39;))</span>
<span class="gi">+        print_err(str(exception))</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(exception, RecursionError):</span>
<span class="gi">+        print_red(__(&#39;Recursion error:&#39;))</span>
<span class="gi">+        print_err(str(exception))</span>
<span class="gi">+        print_err()</span>
<span class="gi">+        print_err(__(&#39;This can happen with very large or deeply nested source &#39;</span>
<span class="gi">+                     &#39;files. You can carefully increase the default Python &#39;</span>
<span class="gi">+                     &#39;recursion limit of 1000 in conf.py with e.g.:&#39;))</span>
<span class="gi">+        print_err(&#39;\n    import sys\n    sys.setrecursionlimit(1_500)\n&#39;)</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    # format an exception with traceback, but only the last frame.</span>
<span class="gi">+    te = TracebackException.from_exception(exception, limit=-1)</span>
<span class="gi">+    formatted_tb = te.stack.format()[-1] + &#39;&#39;.join(te.format_exception_only()).rstrip()</span>
<span class="gi">+</span>
<span class="gi">+    print_red(__(&#39;Exception occurred:&#39;))</span>
<span class="gi">+    print_err(formatted_tb)</span>
<span class="gi">+    traceback_info_path = save_traceback(app, exception)</span>
<span class="gi">+    print_err(__(&#39;The full traceback has been saved in:&#39;))</span>
<span class="gi">+    print_err(traceback_info_path)</span>
<span class="gi">+    print_err()</span>
<span class="gi">+    print_err(__(&#39;To report this error to the developers, please open an issue &#39;</span>
<span class="gi">+                 &#39;at &lt;https://github.com/sphinx-doc/sphinx/issues/&gt;. Thanks!&#39;))</span>
<span class="gi">+    print_err(__(&#39;Please also report this if it was a user error, so &#39;</span>
<span class="gi">+                 &#39;that a better error message can be provided next time.&#39;))</span>
<span class="gh">diff --git a/sphinx/addnodes.py b/sphinx/addnodes.py</span>
<span class="gh">index a277c8408..2a318aea7 100644</span>
<span class="gd">--- a/sphinx/addnodes.py</span>
<span class="gi">+++ b/sphinx/addnodes.py</span>
<span class="gu">@@ -1,10 +1,16 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Document tree nodes that Sphinx defines on top of those in Docutils.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Sequence
<span class="gi">+</span>
<span class="w"> </span>    from docutils.nodes import Element
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata

<span class="gu">@@ -19,6 +25,10 @@ class document(nodes.document):</span>
<span class="w"> </span>                   in your extensions.  It will be removed without deprecation period.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def set_id(self, node: Element, msgnode: Element | None = None,</span>
<span class="gi">+               suggested_prefix: str = &#39;&#39;) -&gt; str:</span>
<span class="gi">+        return super().set_id(node, msgnode, suggested_prefix)</span>
<span class="gi">+</span>

<span class="w"> </span>class translatable(nodes.Node):
<span class="w"> </span>    &quot;&quot;&quot;Node which supports translation.
<span class="gu">@@ -34,44 +44,84 @@ class translatable(nodes.Node):</span>
<span class="w"> </span>    Because they are used at final step; extraction.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def preserve_original_messages(self) -&gt;None:</span>
<span class="gi">+    def preserve_original_messages(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Preserve original translatable messages.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-    def apply_translated_message(self, original_message: str,</span>
<span class="gd">-        translated_message: str) -&gt;None:</span>
<span class="gi">+    def apply_translated_message(self, original_message: str, translated_message: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Apply translated message.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="gd">-    def extract_original_messages(self) -&gt;Sequence[str]:</span>
<span class="gi">+    def extract_original_messages(self) -&gt; Sequence[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Extract translation messages.

<span class="w"> </span>        :returns: list of extracted messages or messages generator
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>


<span class="w"> </span>class not_smartquotable:
<span class="w"> </span>    &quot;&quot;&quot;A node which does not support smart-quotes.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    support_smartquotes = False


<span class="w"> </span>class toctree(nodes.General, nodes.Element, translatable):
<span class="w"> </span>    &quot;&quot;&quot;Node for inserting a &quot;TOC tree&quot;.&quot;&quot;&quot;

<span class="gi">+    def preserve_original_messages(self) -&gt; None:</span>
<span class="gi">+        # toctree entries</span>
<span class="gi">+        rawentries: list[str] = self.setdefault(&#39;rawentries&#39;, [])</span>
<span class="gi">+        for title, _docname in self[&#39;entries&#39;]:</span>
<span class="gi">+            if title:</span>
<span class="gi">+                rawentries.append(title)</span>
<span class="gi">+</span>
<span class="gi">+        # :caption: option</span>
<span class="gi">+        if self.get(&#39;caption&#39;):</span>
<span class="gi">+            self[&#39;rawcaption&#39;] = self[&#39;caption&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    def apply_translated_message(self, original_message: str, translated_message: str) -&gt; None:</span>
<span class="gi">+        # toctree entries</span>
<span class="gi">+        for i, (title, docname) in enumerate(self[&#39;entries&#39;]):</span>
<span class="gi">+            if title == original_message:</span>
<span class="gi">+                self[&#39;entries&#39;][i] = (translated_message, docname)</span>
<span class="gi">+</span>
<span class="gi">+        # :caption: option</span>
<span class="gi">+        if self.get(&#39;rawcaption&#39;) == original_message:</span>
<span class="gi">+            self[&#39;caption&#39;] = translated_message</span>
<span class="gi">+</span>
<span class="gi">+    def extract_original_messages(self) -&gt; list[str]:</span>
<span class="gi">+        messages: list[str] = []</span>
<span class="gi">+</span>
<span class="gi">+        # toctree entries</span>
<span class="gi">+        messages.extend(self.get(&#39;rawentries&#39;, []))</span>
<span class="gi">+</span>
<span class="gi">+        # :caption: option</span>
<span class="gi">+        if &#39;rawcaption&#39; in self:</span>
<span class="gi">+            messages.append(self[&#39;rawcaption&#39;])</span>
<span class="gi">+        return messages</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+#############################################################</span>
<span class="gi">+# Domain-specific object descriptions (class, function etc.)</span>
<span class="gi">+#############################################################</span>

<span class="w"> </span>class _desc_classes_injector(nodes.Element, not_smartquotable):
<span class="w"> </span>    &quot;&quot;&quot;Helper base class for injecting a fixed list of classes.

<span class="w"> </span>    Use as the first base class.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    classes: list[str] = []

<span class="gd">-    def __init__(self, *args: Any, **kwargs: Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        super().__init__(*args, **kwargs)
<span class="w"> </span>        self[&#39;classes&#39;].extend(self.classes)


<span class="gi">+# Top-level nodes</span>
<span class="gi">+#################</span>
<span class="gi">+</span>
<span class="w"> </span>class desc(nodes.Admonition, nodes.Element):
<span class="w"> </span>    &quot;&quot;&quot;Node for a list of object signatures and a common description of them.

<span class="gu">@@ -84,9 +134,11 @@ class desc(nodes.Admonition, nodes.Element):</span>
<span class="w"> </span>    - The name of the object type in the domain, e.g., ``function``.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    # TODO: can we introduce a constructor</span>
<span class="gi">+    #  that forces the specification of the domain and objtyp?</span>

<span class="gd">-class desc_signature(_desc_classes_injector, nodes.Part, nodes.Inline,</span>
<span class="gd">-    nodes.TextElement):</span>
<span class="gi">+</span>
<span class="gi">+class desc_signature(_desc_classes_injector, nodes.Part, nodes.Inline, nodes.TextElement):</span>
<span class="w"> </span>    &quot;&quot;&quot;Node for a single object signature.

<span class="w"> </span>    As default the signature is a single-line signature.
<span class="gu">@@ -95,8 +147,17 @@ class desc_signature(_desc_classes_injector, nodes.Part, nodes.Inline,</span>

<span class="w"> </span>    This node always has the classes ``sig``, ``sig-object``, and the domain it belongs to.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # Note: the domain name is being added through a post-transform DescSigAddDomainAsClass</span>
<span class="w"> </span>    classes = [&#39;sig&#39;, &#39;sig-object&#39;]

<span class="gi">+    @property</span>
<span class="gi">+    def child_text_separator(self) -&gt; str:  # type: ignore[override]</span>
<span class="gi">+        if self.get(&#39;is_multiline&#39;):</span>
<span class="gi">+            return &#39; &#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return super().child_text_separator</span>
<span class="gi">+</span>

<span class="w"> </span>class desc_signature_line(nodes.Part, nodes.Inline, nodes.FixedTextElement):
<span class="w"> </span>    &quot;&quot;&quot;Node for a line in a multi-line object signature.
<span class="gu">@@ -105,6 +166,7 @@ class desc_signature_line(nodes.Part, nodes.Inline, nodes.FixedTextElement):</span>
<span class="w"> </span>    with ``is_multiline`` set to ``True``.
<span class="w"> </span>    Set ``add_permalink = True`` for the line that should get the permalink.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    sphinx_line_type = &#39;&#39;


<span class="gu">@@ -123,15 +185,20 @@ class desc_inline(_desc_classes_injector, nodes.Inline, nodes.TextElement):</span>
<span class="w"> </span>    This node always has the classes ``sig``, ``sig-inline``,
<span class="w"> </span>    and the name of the domain it belongs to.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    classes = [&#39;sig&#39;, &#39;sig-inline&#39;]

<span class="gd">-    def __init__(self, domain: str, *args: Any, **kwargs: Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, domain: str, *args: Any, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        super().__init__(*args, **kwargs, domain=domain)
<span class="w"> </span>        self[&#39;classes&#39;].append(domain)


<span class="gd">-class desc_name(_desc_classes_injector, nodes.Part, nodes.Inline, nodes.</span>
<span class="gd">-    FixedTextElement):</span>
<span class="gi">+# Nodes for high-level structure in signatures</span>
<span class="gi">+##############################################</span>
<span class="gi">+</span>
<span class="gi">+# nodes to use within a desc_signature or desc_signature_line</span>
<span class="gi">+</span>
<span class="gi">+class desc_name(_desc_classes_injector, nodes.Part, nodes.Inline, nodes.FixedTextElement):</span>
<span class="w"> </span>    &quot;&quot;&quot;Node for the main object name.

<span class="w"> </span>    For example, in the declaration of a Python class ``MyModule.MyClass``,
<span class="gu">@@ -139,11 +206,11 @@ class desc_name(_desc_classes_injector, nodes.Part, nodes.Inline, nodes.</span>

<span class="w"> </span>    This node always has the class ``sig-name``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    classes = [&#39;sig-name&#39;, &#39;descname&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    classes = [&#39;sig-name&#39;, &#39;descname&#39;]  # &#39;descname&#39; is for backwards compatibility</span>


<span class="gd">-class desc_addname(_desc_classes_injector, nodes.Part, nodes.Inline, nodes.</span>
<span class="gd">-    FixedTextElement):</span>
<span class="gi">+class desc_addname(_desc_classes_injector, nodes.Part, nodes.Inline, nodes.FixedTextElement):</span>
<span class="w"> </span>    &quot;&quot;&quot;Node for additional name parts for an object.

<span class="w"> </span>    For example, in the declaration of a Python class ``MyModule.MyClass``,
<span class="gu">@@ -151,9 +218,12 @@ class desc_addname(_desc_classes_injector, nodes.Part, nodes.Inline, nodes.</span>

<span class="w"> </span>    This node always has the class ``sig-prename``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # &#39;descclassname&#39; is for backwards compatibility</span>
<span class="w"> </span>    classes = [&#39;sig-prename&#39;, &#39;descclassname&#39;]


<span class="gi">+# compatibility alias</span>
<span class="w"> </span>desc_classname = desc_addname


<span class="gu">@@ -164,6 +234,9 @@ class desc_type(nodes.Part, nodes.Inline, nodes.FixedTextElement):</span>
<span class="w"> </span>class desc_returns(desc_type):
<span class="w"> </span>    &quot;&quot;&quot;Node for a &quot;returns&quot; annotation (a la -&gt; in Python).&quot;&quot;&quot;

<span class="gi">+    def astext(self) -&gt; str:</span>
<span class="gi">+        return &#39; -&gt; &#39; + super().astext()</span>
<span class="gi">+</span>

<span class="w"> </span>class desc_parameterlist(nodes.Part, nodes.Inline, nodes.FixedTextElement):
<span class="w"> </span>    &quot;&quot;&quot;Node for a general parameter list.
<span class="gu">@@ -172,19 +245,26 @@ class desc_parameterlist(nodes.Part, nodes.Inline, nodes.FixedTextElement):</span>
<span class="w"> </span>    Set ``multi_line_parameter_list = True`` to describe a multi-line parameter list.
<span class="w"> </span>    In that case each parameter will then be written on its own, indented line.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    child_text_separator = &#39;, &#39;

<span class="gi">+    def astext(self) -&gt; str:</span>
<span class="gi">+        return f&#39;({super().astext()})&#39;</span>

<span class="gd">-class desc_type_parameter_list(nodes.Part, nodes.Inline, nodes.FixedTextElement</span>
<span class="gd">-    ):</span>
<span class="gi">+</span>
<span class="gi">+class desc_type_parameter_list(nodes.Part, nodes.Inline, nodes.FixedTextElement):</span>
<span class="w"> </span>    &quot;&quot;&quot;Node for a general type parameter list.

<span class="w"> </span>    As default the type parameters list is written in line with the rest of the signature.
<span class="w"> </span>    Set ``multi_line_parameter_list = True`` to describe a multi-line type parameters list.
<span class="w"> </span>    In that case each type parameter will then be written on its own, indented line.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    child_text_separator = &#39;, &#39;

<span class="gi">+    def astext(self) -&gt; str:</span>
<span class="gi">+        return f&#39;[{super().astext()}]&#39;</span>
<span class="gi">+</span>

<span class="w"> </span>class desc_parameter(nodes.Part, nodes.Inline, nodes.FixedTextElement):
<span class="w"> </span>    &quot;&quot;&quot;Node for a single parameter.&quot;&quot;&quot;
<span class="gu">@@ -196,80 +276,115 @@ class desc_type_parameter(nodes.Part, nodes.Inline, nodes.FixedTextElement):</span>

<span class="w"> </span>class desc_optional(nodes.Part, nodes.Inline, nodes.FixedTextElement):
<span class="w"> </span>    &quot;&quot;&quot;Node for marking optional parts of the parameter list.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    child_text_separator = &#39;, &#39;

<span class="gi">+    def astext(self) -&gt; str:</span>
<span class="gi">+        return &#39;[&#39; + super().astext() + &#39;]&#39;</span>
<span class="gi">+</span>

<span class="w"> </span>class desc_annotation(nodes.Part, nodes.Inline, nodes.FixedTextElement):
<span class="w"> </span>    &quot;&quot;&quot;Node for signature annotations (not Python 3-style annotations).&quot;&quot;&quot;


<span class="gi">+# Leaf nodes for markup of text fragments</span>
<span class="gi">+#########################################</span>
<span class="gi">+</span>
<span class="gi">+#: A set of classes inheriting :class:`desc_sig_element`. Each node class</span>
<span class="gi">+#: is expected to be handled by the builder&#39;s translator class if the latter</span>
<span class="gi">+#: does not inherit from SphinxTranslator.</span>
<span class="gi">+#:</span>
<span class="gi">+#: This set can be extended manually by third-party extensions or</span>
<span class="gi">+#: by subclassing :class:`desc_sig_element` and using the class</span>
<span class="gi">+#: keyword argument `_sig_element=True`.</span>
<span class="w"> </span>SIG_ELEMENTS: set[type[desc_sig_element]] = set()


<span class="gi">+# Signature text elements, generally translated to node.inline</span>
<span class="gi">+# in SigElementFallbackTransform.</span>
<span class="gi">+# When adding a new one, add it to SIG_ELEMENTS via the class</span>
<span class="gi">+# keyword argument `_sig_element=True` (e.g., see `desc_sig_space`).</span>
<span class="gi">+</span>
<span class="w"> </span>class desc_sig_element(nodes.inline, _desc_classes_injector):
<span class="w"> </span>    &quot;&quot;&quot;Common parent class of nodes for inline text of a signature.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    classes: list[str] = []

<span class="gd">-    def __init__(self, rawsource: str=&#39;&#39;, text: str=&#39;&#39;, *children: Element,</span>
<span class="gd">-        **attributes: Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, rawsource: str = &#39;&#39;, text: str = &#39;&#39;,</span>
<span class="gi">+                 *children: Element, **attributes: Any) -&gt; None:</span>
<span class="w"> </span>        super().__init__(rawsource, text, *children, **attributes)
<span class="w"> </span>        self[&#39;classes&#39;].extend(self.classes)

<span class="gd">-    def __init_subclass__(cls, *, _sig_element: bool=False, **kwargs: Any</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init_subclass__(cls, *, _sig_element: bool = False, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        super().__init_subclass__(**kwargs)
<span class="w"> </span>        if _sig_element:
<span class="gi">+            # add the class to the SIG_ELEMENTS set if asked</span>
<span class="w"> </span>            SIG_ELEMENTS.add(cls)


<span class="gd">-class desc_sig_space(desc_sig_element, _sig_element=(True)):</span>
<span class="gi">+# to not reinvent the wheel, the classes in the following desc_sig classes</span>
<span class="gi">+# are based on those used in Pygments</span>
<span class="gi">+</span>
<span class="gi">+class desc_sig_space(desc_sig_element, _sig_element=True):</span>
<span class="w"> </span>    &quot;&quot;&quot;Node for a space in a signature.&quot;&quot;&quot;
<span class="gd">-    classes = [&#39;w&#39;]</span>

<span class="gd">-    def __init__(self, rawsource: str=&#39;&#39;, text: str=&#39; &#39;, *children: Element,</span>
<span class="gd">-        **attributes: Any) -&gt;None:</span>
<span class="gi">+    classes = [&quot;w&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, rawsource: str = &#39;&#39;, text: str = &#39; &#39;,</span>
<span class="gi">+                 *children: Element, **attributes: Any) -&gt; None:</span>
<span class="w"> </span>        super().__init__(rawsource, text, *children, **attributes)


<span class="gd">-class desc_sig_name(desc_sig_element, _sig_element=(True)):</span>
<span class="gi">+class desc_sig_name(desc_sig_element, _sig_element=True):</span>
<span class="w"> </span>    &quot;&quot;&quot;Node for an identifier in a signature.&quot;&quot;&quot;
<span class="gd">-    classes = [&#39;n&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    classes = [&quot;n&quot;]</span>


<span class="gd">-class desc_sig_operator(desc_sig_element, _sig_element=(True)):</span>
<span class="gi">+class desc_sig_operator(desc_sig_element, _sig_element=True):</span>
<span class="w"> </span>    &quot;&quot;&quot;Node for an operator in a signature.&quot;&quot;&quot;
<span class="gd">-    classes = [&#39;o&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    classes = [&quot;o&quot;]</span>


<span class="gd">-class desc_sig_punctuation(desc_sig_element, _sig_element=(True)):</span>
<span class="gi">+class desc_sig_punctuation(desc_sig_element, _sig_element=True):</span>
<span class="w"> </span>    &quot;&quot;&quot;Node for punctuation in a signature.&quot;&quot;&quot;
<span class="gd">-    classes = [&#39;p&#39;]</span>

<span class="gi">+    classes = [&quot;p&quot;]</span>

<span class="gd">-class desc_sig_keyword(desc_sig_element, _sig_element=(True)):</span>
<span class="gi">+</span>
<span class="gi">+class desc_sig_keyword(desc_sig_element, _sig_element=True):</span>
<span class="w"> </span>    &quot;&quot;&quot;Node for a general keyword in a signature.&quot;&quot;&quot;
<span class="gd">-    classes = [&#39;k&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    classes = [&quot;k&quot;]</span>


<span class="gd">-class desc_sig_keyword_type(desc_sig_element, _sig_element=(True)):</span>
<span class="gi">+class desc_sig_keyword_type(desc_sig_element, _sig_element=True):</span>
<span class="w"> </span>    &quot;&quot;&quot;Node for a keyword which is a built-in type in a signature.&quot;&quot;&quot;
<span class="gd">-    classes = [&#39;kt&#39;]</span>

<span class="gi">+    classes = [&quot;kt&quot;]</span>

<span class="gd">-class desc_sig_literal_number(desc_sig_element, _sig_element=(True)):</span>
<span class="gi">+</span>
<span class="gi">+class desc_sig_literal_number(desc_sig_element, _sig_element=True):</span>
<span class="w"> </span>    &quot;&quot;&quot;Node for a numeric literal in a signature.&quot;&quot;&quot;
<span class="gd">-    classes = [&#39;m&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    classes = [&quot;m&quot;]</span>


<span class="gd">-class desc_sig_literal_string(desc_sig_element, _sig_element=(True)):</span>
<span class="gi">+class desc_sig_literal_string(desc_sig_element, _sig_element=True):</span>
<span class="w"> </span>    &quot;&quot;&quot;Node for a string literal in a signature.&quot;&quot;&quot;
<span class="gd">-    classes = [&#39;s&#39;]</span>

<span class="gi">+    classes = [&quot;s&quot;]</span>

<span class="gd">-class desc_sig_literal_char(desc_sig_element, _sig_element=(True)):</span>
<span class="gi">+</span>
<span class="gi">+class desc_sig_literal_char(desc_sig_element, _sig_element=True):</span>
<span class="w"> </span>    &quot;&quot;&quot;Node for a character literal in a signature.&quot;&quot;&quot;
<span class="gd">-    classes = [&#39;sc&#39;]</span>

<span class="gi">+    classes = [&quot;sc&quot;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+###############################################################</span>
<span class="gi">+# new admonition-like constructs</span>

<span class="w"> </span>class versionmodified(nodes.Admonition, nodes.TextElement):
<span class="w"> </span>    &quot;&quot;&quot;Node for version change entries.
<span class="gu">@@ -294,6 +409,8 @@ class production(nodes.Part, nodes.Inline, nodes.FixedTextElement):</span>
<span class="w"> </span>    &quot;&quot;&quot;Node for a single grammar production rule.&quot;&quot;&quot;


<span class="gi">+# other directive-level nodes</span>
<span class="gi">+</span>
<span class="w"> </span>class index(nodes.Invisible, nodes.Inline, nodes.TextElement):
<span class="w"> </span>    &quot;&quot;&quot;Node for index entries.

<span class="gu">@@ -339,6 +456,8 @@ class only(nodes.Element):</span>
<span class="w"> </span>    &quot;&quot;&quot;Node for &quot;only&quot; directives (conditional inclusion based on tags).&quot;&quot;&quot;


<span class="gi">+# meta-information nodes</span>
<span class="gi">+</span>
<span class="w"> </span>class start_of_file(nodes.Element):
<span class="w"> </span>    &quot;&quot;&quot;Node to mark start of a new file, used in the LaTeX builder only.&quot;&quot;&quot;

<span class="gu">@@ -353,6 +472,8 @@ class tabular_col_spec(nodes.Element):</span>
<span class="w"> </span>    &quot;&quot;&quot;Node for specifying tabular columns, used for LaTeX output.&quot;&quot;&quot;


<span class="gi">+# inline nodes</span>
<span class="gi">+</span>
<span class="w"> </span>class pending_xref(nodes.Inline, nodes.Element):
<span class="w"> </span>    &quot;&quot;&quot;Node for cross-references that cannot be resolved without complete
<span class="w"> </span>    information about all documents.
<span class="gu">@@ -360,6 +481,7 @@ class pending_xref(nodes.Inline, nodes.Element):</span>
<span class="w"> </span>    These nodes are resolved before writing output, in
<span class="w"> </span>    BuildEnvironment.resolve_references.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    child_text_separator = &#39;&#39;


<span class="gu">@@ -432,3 +554,55 @@ class literal_strong(nodes.strong, not_smartquotable):</span>

<span class="w"> </span>class manpage(nodes.Inline, nodes.FixedTextElement):
<span class="w"> </span>    &quot;&quot;&quot;Node for references to manpages.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_node(toctree)</span>
<span class="gi">+</span>
<span class="gi">+    app.add_node(desc)</span>
<span class="gi">+    app.add_node(desc_signature)</span>
<span class="gi">+    app.add_node(desc_signature_line)</span>
<span class="gi">+    app.add_node(desc_content)</span>
<span class="gi">+    app.add_node(desc_inline)</span>
<span class="gi">+</span>
<span class="gi">+    app.add_node(desc_name)</span>
<span class="gi">+    app.add_node(desc_addname)</span>
<span class="gi">+    app.add_node(desc_type)</span>
<span class="gi">+    app.add_node(desc_returns)</span>
<span class="gi">+    app.add_node(desc_parameterlist)</span>
<span class="gi">+    app.add_node(desc_type_parameter_list)</span>
<span class="gi">+    app.add_node(desc_parameter)</span>
<span class="gi">+    app.add_node(desc_type_parameter)</span>
<span class="gi">+    app.add_node(desc_optional)</span>
<span class="gi">+    app.add_node(desc_annotation)</span>
<span class="gi">+</span>
<span class="gi">+    for n in SIG_ELEMENTS:</span>
<span class="gi">+        app.add_node(n)</span>
<span class="gi">+</span>
<span class="gi">+    app.add_node(versionmodified)</span>
<span class="gi">+    app.add_node(seealso)</span>
<span class="gi">+    app.add_node(productionlist)</span>
<span class="gi">+    app.add_node(production)</span>
<span class="gi">+    app.add_node(index)</span>
<span class="gi">+    app.add_node(centered)</span>
<span class="gi">+    app.add_node(acks)</span>
<span class="gi">+    app.add_node(hlist)</span>
<span class="gi">+    app.add_node(hlistcol)</span>
<span class="gi">+    app.add_node(compact_paragraph)</span>
<span class="gi">+    app.add_node(glossary)</span>
<span class="gi">+    app.add_node(only)</span>
<span class="gi">+    app.add_node(start_of_file)</span>
<span class="gi">+    app.add_node(highlightlang)</span>
<span class="gi">+    app.add_node(tabular_col_spec)</span>
<span class="gi">+    app.add_node(pending_xref)</span>
<span class="gi">+    app.add_node(number_reference)</span>
<span class="gi">+    app.add_node(download_reference)</span>
<span class="gi">+    app.add_node(literal_emphasis)</span>
<span class="gi">+    app.add_node(literal_strong)</span>
<span class="gi">+    app.add_node(manpage)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/application.py b/sphinx/application.py</span>
<span class="gh">index c0830a77e..ea1f79ba7 100644</span>
<span class="gd">--- a/sphinx/application.py</span>
<span class="gi">+++ b/sphinx/application.py</span>
<span class="gu">@@ -2,7 +2,9 @@</span>

<span class="w"> </span>Gracefully adapted from the TextPress system by Armin.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import contextlib
<span class="w"> </span>import os
<span class="w"> </span>import pickle
<span class="gu">@@ -11,7 +13,9 @@ from collections import deque</span>
<span class="w"> </span>from io import StringIO
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING, overload
<span class="gi">+</span>
<span class="w"> </span>from docutils.parsers.rst import Directive, roles
<span class="gi">+</span>
<span class="w"> </span>import sphinx
<span class="w"> </span>from sphinx import locale, package_dir
<span class="w"> </span>from sphinx.config import ENUM, Config, _ConfigRebuild
<span class="gu">@@ -31,15 +35,18 @@ from sphinx.util.i18n import CatalogRepository</span>
<span class="w"> </span>from sphinx.util.logging import prefixed_warnings
<span class="w"> </span>from sphinx.util.osutil import ensuredir, relpath
<span class="w"> </span>from sphinx.util.tags import Tags
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Callable, Collection, Iterable, Sequence, Set
<span class="w"> </span>    from pathlib import Path
<span class="w"> </span>    from typing import IO, Any, Final, Literal
<span class="gi">+</span>
<span class="w"> </span>    from docutils import nodes
<span class="w"> </span>    from docutils.nodes import Element, Node
<span class="w"> </span>    from docutils.parsers import Parser
<span class="w"> </span>    from docutils.transforms import Transform
<span class="w"> </span>    from pygments.lexer import Lexer
<span class="gi">+</span>
<span class="w"> </span>    from sphinx import addnodes
<span class="w"> </span>    from sphinx.builders import Builder
<span class="w"> </span>    from sphinx.domains import Domain, Index
<span class="gu">@@ -51,38 +58,74 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>    from sphinx.search import SearchLanguage
<span class="w"> </span>    from sphinx.theming import Theme
<span class="w"> </span>    from sphinx.util.typing import RoleFunction, TitleGetter
<span class="gd">-builtin_extensions: tuple[str, ...] = (&#39;sphinx.addnodes&#39;,</span>
<span class="gd">-    &#39;sphinx.builders.changes&#39;, &#39;sphinx.builders.epub3&#39;,</span>
<span class="gd">-    &#39;sphinx.builders.dirhtml&#39;, &#39;sphinx.builders.dummy&#39;,</span>
<span class="gd">-    &#39;sphinx.builders.gettext&#39;, &#39;sphinx.builders.html&#39;,</span>
<span class="gd">-    &#39;sphinx.builders.latex&#39;, &#39;sphinx.builders.linkcheck&#39;,</span>
<span class="gd">-    &#39;sphinx.builders.manpage&#39;, &#39;sphinx.builders.singlehtml&#39;,</span>
<span class="gd">-    &#39;sphinx.builders.texinfo&#39;, &#39;sphinx.builders.text&#39;,</span>
<span class="gd">-    &#39;sphinx.builders.xml&#39;, &#39;sphinx.config&#39;, &#39;sphinx.domains.c&#39;,</span>
<span class="gd">-    &#39;sphinx.domains.changeset&#39;, &#39;sphinx.domains.citation&#39;,</span>
<span class="gd">-    &#39;sphinx.domains.cpp&#39;, &#39;sphinx.domains.index&#39;,</span>
<span class="gd">-    &#39;sphinx.domains.javascript&#39;, &#39;sphinx.domains.math&#39;,</span>
<span class="gd">-    &#39;sphinx.domains.python&#39;, &#39;sphinx.domains.rst&#39;, &#39;sphinx.domains.std&#39;,</span>
<span class="gd">-    &#39;sphinx.directives&#39;, &#39;sphinx.directives.code&#39;,</span>
<span class="gd">-    &#39;sphinx.directives.other&#39;, &#39;sphinx.directives.patches&#39;,</span>
<span class="gd">-    &#39;sphinx.extension&#39;, &#39;sphinx.parsers&#39;, &#39;sphinx.registry&#39;, &#39;sphinx.roles&#39;,</span>
<span class="gd">-    &#39;sphinx.transforms&#39;, &#39;sphinx.transforms.compact_bullet_list&#39;,</span>
<span class="gd">-    &#39;sphinx.transforms.i18n&#39;, &#39;sphinx.transforms.references&#39;,</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+builtin_extensions: tuple[str, ...] = (</span>
<span class="gi">+    &#39;sphinx.addnodes&#39;,</span>
<span class="gi">+    &#39;sphinx.builders.changes&#39;,</span>
<span class="gi">+    &#39;sphinx.builders.epub3&#39;,</span>
<span class="gi">+    &#39;sphinx.builders.dirhtml&#39;,</span>
<span class="gi">+    &#39;sphinx.builders.dummy&#39;,</span>
<span class="gi">+    &#39;sphinx.builders.gettext&#39;,</span>
<span class="gi">+    &#39;sphinx.builders.html&#39;,</span>
<span class="gi">+    &#39;sphinx.builders.latex&#39;,</span>
<span class="gi">+    &#39;sphinx.builders.linkcheck&#39;,</span>
<span class="gi">+    &#39;sphinx.builders.manpage&#39;,</span>
<span class="gi">+    &#39;sphinx.builders.singlehtml&#39;,</span>
<span class="gi">+    &#39;sphinx.builders.texinfo&#39;,</span>
<span class="gi">+    &#39;sphinx.builders.text&#39;,</span>
<span class="gi">+    &#39;sphinx.builders.xml&#39;,</span>
<span class="gi">+    &#39;sphinx.config&#39;,</span>
<span class="gi">+    &#39;sphinx.domains.c&#39;,</span>
<span class="gi">+    &#39;sphinx.domains.changeset&#39;,</span>
<span class="gi">+    &#39;sphinx.domains.citation&#39;,</span>
<span class="gi">+    &#39;sphinx.domains.cpp&#39;,</span>
<span class="gi">+    &#39;sphinx.domains.index&#39;,</span>
<span class="gi">+    &#39;sphinx.domains.javascript&#39;,</span>
<span class="gi">+    &#39;sphinx.domains.math&#39;,</span>
<span class="gi">+    &#39;sphinx.domains.python&#39;,</span>
<span class="gi">+    &#39;sphinx.domains.rst&#39;,</span>
<span class="gi">+    &#39;sphinx.domains.std&#39;,</span>
<span class="gi">+    &#39;sphinx.directives&#39;,</span>
<span class="gi">+    &#39;sphinx.directives.code&#39;,</span>
<span class="gi">+    &#39;sphinx.directives.other&#39;,</span>
<span class="gi">+    &#39;sphinx.directives.patches&#39;,</span>
<span class="gi">+    &#39;sphinx.extension&#39;,</span>
<span class="gi">+    &#39;sphinx.parsers&#39;,</span>
<span class="gi">+    &#39;sphinx.registry&#39;,</span>
<span class="gi">+    &#39;sphinx.roles&#39;,</span>
<span class="gi">+    &#39;sphinx.transforms&#39;,</span>
<span class="gi">+    &#39;sphinx.transforms.compact_bullet_list&#39;,</span>
<span class="gi">+    &#39;sphinx.transforms.i18n&#39;,</span>
<span class="gi">+    &#39;sphinx.transforms.references&#39;,</span>
<span class="w"> </span>    &#39;sphinx.transforms.post_transforms&#39;,
<span class="w"> </span>    &#39;sphinx.transforms.post_transforms.code&#39;,
<span class="gd">-    &#39;sphinx.transforms.post_transforms.images&#39;, &#39;sphinx.versioning&#39;,</span>
<span class="gi">+    &#39;sphinx.transforms.post_transforms.images&#39;,</span>
<span class="gi">+    &#39;sphinx.versioning&#39;,</span>
<span class="gi">+    # collectors should be loaded by specific order</span>
<span class="w"> </span>    &#39;sphinx.environment.collectors.dependencies&#39;,
<span class="w"> </span>    &#39;sphinx.environment.collectors.asset&#39;,
<span class="w"> </span>    &#39;sphinx.environment.collectors.metadata&#39;,
<span class="w"> </span>    &#39;sphinx.environment.collectors.title&#39;,
<span class="gd">-    &#39;sphinx.environment.collectors.toctree&#39;)</span>
<span class="gd">-_first_party_extensions = (&#39;sphinxcontrib.applehelp&#39;,</span>
<span class="gd">-    &#39;sphinxcontrib.devhelp&#39;, &#39;sphinxcontrib.htmlhelp&#39;,</span>
<span class="gd">-    &#39;sphinxcontrib.serializinghtml&#39;, &#39;sphinxcontrib.qthelp&#39;)</span>
<span class="gd">-_first_party_themes = &#39;alabaster&#39;,</span>
<span class="gi">+    &#39;sphinx.environment.collectors.toctree&#39;,</span>
<span class="gi">+)</span>
<span class="gi">+_first_party_extensions = (</span>
<span class="gi">+    # 1st party extensions</span>
<span class="gi">+    &#39;sphinxcontrib.applehelp&#39;,</span>
<span class="gi">+    &#39;sphinxcontrib.devhelp&#39;,</span>
<span class="gi">+    &#39;sphinxcontrib.htmlhelp&#39;,</span>
<span class="gi">+    &#39;sphinxcontrib.serializinghtml&#39;,</span>
<span class="gi">+    &#39;sphinxcontrib.qthelp&#39;,</span>
<span class="gi">+)</span>
<span class="gi">+_first_party_themes = (</span>
<span class="gi">+    # Alabaster is loaded automatically to be used as the default theme</span>
<span class="gi">+    &#39;alabaster&#39;,</span>
<span class="gi">+)</span>
<span class="w"> </span>builtin_extensions += _first_party_themes
<span class="w"> </span>builtin_extensions += _first_party_extensions
<span class="gi">+</span>
<span class="w"> </span>ENV_PICKLE_FILENAME = &#39;environment.pickle&#39;
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="gu">@@ -94,17 +137,18 @@ class Sphinx:</span>
<span class="w"> </span>    :ivar doctreedir: Directory for storing pickled doctrees.
<span class="w"> </span>    :ivar outdir: Directory for storing build documents.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    warningiserror: Final = False
<span class="w"> </span>    _warncount: int

<span class="gd">-    def __init__(self, srcdir: (str | os.PathLike[str]), confdir: (str | os</span>
<span class="gd">-        .PathLike[str] | None), outdir: (str | os.PathLike[str]),</span>
<span class="gd">-        doctreedir: (str | os.PathLike[str]), buildername: str,</span>
<span class="gd">-        confoverrides: (dict | None)=None, status: (IO[str] | None)=sys.</span>
<span class="gd">-        stdout, warning: (IO[str] | None)=sys.stderr, freshenv: bool=False,</span>
<span class="gd">-        warningiserror: bool=False, tags: Sequence[str]=(), verbosity: int=</span>
<span class="gd">-        0, parallel: int=0, keep_going: bool=False, pdb: bool=False,</span>
<span class="gd">-        exception_on_warning: bool=False) -&gt;None:</span>
<span class="gi">+    def __init__(self, srcdir: str | os.PathLike[str], confdir: str | os.PathLike[str] | None,</span>
<span class="gi">+                 outdir: str | os.PathLike[str], doctreedir: str | os.PathLike[str],</span>
<span class="gi">+                 buildername: str, confoverrides: dict | None = None,</span>
<span class="gi">+                 status: IO[str] | None = sys.stdout, warning: IO[str] | None = sys.stderr,</span>
<span class="gi">+                 freshenv: bool = False, warningiserror: bool = False,</span>
<span class="gi">+                 tags: Sequence[str] = (),</span>
<span class="gi">+                 verbosity: int = 0, parallel: int = 0, keep_going: bool = False,</span>
<span class="gi">+                 pdb: bool = False, exception_on_warning: bool = False) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Initialize the Sphinx application.

<span class="w"> </span>        :param srcdir: The path to the source directory.
<span class="gu">@@ -132,103 +176,268 @@ class Sphinx:</span>
<span class="w"> </span>        self._fresh_env_used: bool | None = None
<span class="w"> </span>        self.extensions: dict[str, Extension] = {}
<span class="w"> </span>        self.registry = SphinxComponentRegistry()
<span class="gi">+</span>
<span class="gi">+        # validate provided directories</span>
<span class="w"> </span>        self.srcdir = _StrPath(srcdir).resolve()
<span class="w"> </span>        self.outdir = _StrPath(outdir).resolve()
<span class="w"> </span>        self.doctreedir = _StrPath(doctreedir).resolve()
<span class="gi">+</span>
<span class="w"> </span>        if not path.isdir(self.srcdir):
<span class="w"> </span>            raise ApplicationError(__(&#39;Cannot find source directory (%s)&#39;) %
<span class="gd">-                self.srcdir)</span>
<span class="gi">+                                   self.srcdir)</span>
<span class="gi">+</span>
<span class="w"> </span>        if path.exists(self.outdir) and not path.isdir(self.outdir):
<span class="gd">-            raise ApplicationError(__(</span>
<span class="gd">-                &#39;Output directory (%s) is not a directory&#39;) % self.outdir)</span>
<span class="gi">+            raise ApplicationError(__(&#39;Output directory (%s) is not a directory&#39;) %</span>
<span class="gi">+                                   self.outdir)</span>
<span class="gi">+</span>
<span class="w"> </span>        if self.srcdir == self.outdir:
<span class="gd">-            raise ApplicationError(__(</span>
<span class="gd">-                &#39;Source directory and destination directory cannot be identical&#39;</span>
<span class="gd">-                ))</span>
<span class="gi">+            raise ApplicationError(__(&#39;Source directory and destination &#39;</span>
<span class="gi">+                                      &#39;directory cannot be identical&#39;))</span>
<span class="gi">+</span>
<span class="w"> </span>        self.parallel = parallel
<span class="gi">+</span>
<span class="w"> </span>        if status is None:
<span class="w"> </span>            self._status: IO[str] = StringIO()
<span class="w"> </span>            self.quiet: bool = True
<span class="w"> </span>        else:
<span class="w"> </span>            self._status = status
<span class="w"> </span>            self.quiet = False
<span class="gi">+</span>
<span class="w"> </span>        if warning is None:
<span class="w"> </span>            self._warning: IO[str] = StringIO()
<span class="w"> </span>        else:
<span class="w"> </span>            self._warning = warning
<span class="w"> </span>        self._warncount = 0
<span class="gd">-        self.keep_going = bool(warningiserror)</span>
<span class="gi">+        self.keep_going = bool(warningiserror)  # Unused</span>
<span class="w"> </span>        self._fail_on_warnings = bool(warningiserror)
<span class="w"> </span>        self.pdb = pdb
<span class="w"> </span>        self._exception_on_warning = exception_on_warning
<span class="w"> </span>        logging.setup(self, self._status, self._warning)
<span class="gi">+</span>
<span class="w"> </span>        self.events = EventManager(self)
<span class="gi">+</span>
<span class="gi">+        # keep last few messages for traceback</span>
<span class="gi">+        # This will be filled by sphinx.util.logging.LastMessagesWriter</span>
<span class="w"> </span>        self.messagelog: deque = deque(maxlen=10)
<span class="gi">+</span>
<span class="gi">+        # say hello to the world</span>
<span class="w"> </span>        logger.info(bold(__(&#39;Running Sphinx v%s&#39;)), sphinx.__display_version__)
<span class="gi">+</span>
<span class="gi">+        # status code for command-line application</span>
<span class="w"> </span>        self.statuscode = 0
<span class="gi">+</span>
<span class="gi">+        # read config</span>
<span class="w"> </span>        self.tags = Tags(tags)
<span class="w"> </span>        if confdir is None:
<span class="gi">+            # set confdir to srcdir if -C given (!= no confdir); a few pieces</span>
<span class="gi">+            # of code expect a confdir to be set</span>
<span class="w"> </span>            self.confdir = self.srcdir
<span class="w"> </span>            self.config = Config({}, confoverrides or {})
<span class="w"> </span>        else:
<span class="w"> </span>            self.confdir = _StrPath(confdir).resolve()
<span class="gd">-            self.config = Config.read(self.confdir, confoverrides or {},</span>
<span class="gd">-                self.tags)</span>
<span class="gi">+            self.config = Config.read(self.confdir, confoverrides or {}, self.tags)</span>
<span class="gi">+</span>
<span class="gi">+        # set up translation infrastructure</span>
<span class="w"> </span>        self._init_i18n()
<span class="gd">-        if (self.config.needs_sphinx and self.config.needs_sphinx &gt; sphinx.</span>
<span class="gd">-            __display_version__):</span>
<span class="gd">-            raise VersionRequirementError(__(</span>
<span class="gd">-                &#39;This project needs at least Sphinx v%s and therefore cannot be built with this version.&#39;</span>
<span class="gd">-                ) % self.config.needs_sphinx)</span>
<span class="gi">+</span>
<span class="gi">+        # check the Sphinx version if requested</span>
<span class="gi">+        if self.config.needs_sphinx and self.config.needs_sphinx &gt; sphinx.__display_version__:</span>
<span class="gi">+            raise VersionRequirementError(</span>
<span class="gi">+                __(&#39;This project needs at least Sphinx v%s and therefore cannot &#39;</span>
<span class="gi">+                   &#39;be built with this version.&#39;) % self.config.needs_sphinx)</span>
<span class="gi">+</span>
<span class="gi">+        # load all built-in extension modules, first-party extension modules,</span>
<span class="gi">+        # and first-party themes</span>
<span class="w"> </span>        for extension in builtin_extensions:
<span class="w"> </span>            self.setup_extension(extension)
<span class="gi">+</span>
<span class="gi">+        # load all user-given extension modules</span>
<span class="w"> </span>        for extension in self.config.extensions:
<span class="w"> </span>            self.setup_extension(extension)
<span class="gi">+</span>
<span class="gi">+        # preload builder module (before init config values)</span>
<span class="w"> </span>        self.preload_builder(buildername)
<span class="gi">+</span>
<span class="w"> </span>        if not path.isdir(outdir):
<span class="w"> </span>            with progress_message(__(&#39;making output directory&#39;)):
<span class="w"> </span>                ensuredir(outdir)
<span class="gi">+</span>
<span class="gi">+        # the config file itself can be an extension</span>
<span class="w"> </span>        if self.config.setup:
<span class="gd">-            prefix = __(&#39;while setting up extension %s:&#39;) % &#39;conf.py&#39;</span>
<span class="gi">+            prefix = __(&#39;while setting up extension %s:&#39;) % &quot;conf.py&quot;</span>
<span class="w"> </span>            with prefixed_warnings(prefix):
<span class="w"> </span>                if callable(self.config.setup):
<span class="w"> </span>                    self.config.setup(self)
<span class="w"> </span>                else:
<span class="gd">-                    raise ConfigError(__(</span>
<span class="gd">-                        &quot;&#39;setup&#39; as currently defined in conf.py isn&#39;t a Python callable. Please modify its definition to make it a callable function. This is needed for conf.py to behave as a Sphinx extension.&quot;</span>
<span class="gd">-                        ))</span>
<span class="gi">+                    raise ConfigError(</span>
<span class="gi">+                        __(&quot;&#39;setup&#39; as currently defined in conf.py isn&#39;t a Python callable. &quot;</span>
<span class="gi">+                           &quot;Please modify its definition to make it a callable function. &quot;</span>
<span class="gi">+                           &quot;This is needed for conf.py to behave as a Sphinx extension.&quot;),</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+        # Report any warnings for overrides.</span>
<span class="w"> </span>        self.config._report_override_warnings()
<span class="w"> </span>        self.events.emit(&#39;config-inited&#39;, self.config)
<span class="gi">+</span>
<span class="gi">+        # create the project</span>
<span class="w"> </span>        self.project = Project(self.srcdir, self.config.source_suffix)
<span class="gi">+</span>
<span class="gi">+        # set up the build environment</span>
<span class="w"> </span>        self.env = self._init_env(freshenv)
<span class="gi">+</span>
<span class="gi">+        # create the builder</span>
<span class="w"> </span>        self.builder = self.create_builder(buildername)
<span class="gi">+</span>
<span class="gi">+        # build environment post-initialisation, after creating the builder</span>
<span class="w"> </span>        self._post_init_env()
<span class="gi">+</span>
<span class="gi">+        # set up the builder</span>
<span class="w"> </span>        self._init_builder()

<span class="w"> </span>    @property
<span class="gd">-    def fresh_env_used(self) -&gt;(bool | None):</span>
<span class="gi">+    def fresh_env_used(self) -&gt; bool | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;True/False as to whether a new environment was created for this build,
<span class="w"> </span>        or None if the environment has not been initialised yet.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._fresh_env_used</span>

<span class="gd">-    def _init_i18n(self) -&gt;None:</span>
<span class="gi">+    def _init_i18n(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Load translated strings from the configured localedirs if enabled in
<span class="w"> </span>        the configuration.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.info(bold(__(&#39;loading translations [%s]... &#39;)), self.config.language,</span>
<span class="gi">+                    nonl=True)</span>
<span class="gi">+</span>
<span class="gi">+        # compile mo files if sphinx.po file in user locale directories are updated</span>
<span class="gi">+        repo = CatalogRepository(self.srcdir, self.config.locale_dirs,</span>
<span class="gi">+                                 self.config.language, self.config.source_encoding)</span>
<span class="gi">+        for catalog in repo.catalogs:</span>
<span class="gi">+            if catalog.domain == &#39;sphinx&#39; and catalog.is_outdated():</span>
<span class="gi">+                catalog.write_mo(self.config.language,</span>
<span class="gi">+                                 self.config.gettext_allow_fuzzy_translations)</span>
<span class="gi">+</span>
<span class="gi">+        locale_dirs: list[str | None] = list(repo.locale_dirs)</span>
<span class="gi">+        locale_dirs += [None]</span>
<span class="gi">+        locale_dirs += [path.join(package_dir, &#39;locale&#39;)]</span>
<span class="gi">+</span>
<span class="gi">+        self.translator, has_translation = locale.init(locale_dirs, self.config.language)</span>
<span class="gi">+        if has_translation or self.config.language == &#39;en&#39;:</span>
<span class="gi">+            logger.info(__(&#39;done&#39;))</span>
<span class="gi">+        else:</span>
<span class="gi">+            logger.info(__(&#39;not available for built-in messages&#39;))</span>

<span class="gd">-    def setup_extension(self, extname: str) -&gt;None:</span>
<span class="gi">+    def _init_env(self, freshenv: bool) -&gt; BuildEnvironment:</span>
<span class="gi">+        filename = path.join(self.doctreedir, ENV_PICKLE_FILENAME)</span>
<span class="gi">+        if freshenv or not os.path.exists(filename):</span>
<span class="gi">+            return self._create_fresh_env()</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self._load_existing_env(filename)</span>
<span class="gi">+</span>
<span class="gi">+    def _create_fresh_env(self) -&gt; BuildEnvironment:</span>
<span class="gi">+        env = BuildEnvironment(self)</span>
<span class="gi">+        self._fresh_env_used = True</span>
<span class="gi">+        return env</span>
<span class="gi">+</span>
<span class="gi">+    @progress_message(__(&#39;loading pickled environment&#39;))</span>
<span class="gi">+    def _load_existing_env(self, filename: str) -&gt; BuildEnvironment:</span>
<span class="gi">+        try:</span>
<span class="gi">+            with open(filename, &#39;rb&#39;) as f:</span>
<span class="gi">+                env = pickle.load(f)</span>
<span class="gi">+                env.setup(self)</span>
<span class="gi">+                self._fresh_env_used = False</span>
<span class="gi">+        except Exception as err:</span>
<span class="gi">+            logger.info(__(&#39;failed: %s&#39;), err)</span>
<span class="gi">+            env = self._create_fresh_env()</span>
<span class="gi">+        return env</span>
<span class="gi">+</span>
<span class="gi">+    def _post_init_env(self) -&gt; None:</span>
<span class="gi">+        if self._fresh_env_used:</span>
<span class="gi">+            self.env.find_files(self.config, self.builder)</span>
<span class="gi">+</span>
<span class="gi">+    def preload_builder(self, name: str) -&gt; None:</span>
<span class="gi">+        self.registry.preload_builder(self, name)</span>
<span class="gi">+</span>
<span class="gi">+    def create_builder(self, name: str) -&gt; Builder:</span>
<span class="gi">+        if name is None:</span>
<span class="gi">+            logger.info(__(&#39;No builder selected, using default: html&#39;))</span>
<span class="gi">+            name = &#39;html&#39;</span>
<span class="gi">+</span>
<span class="gi">+        return self.registry.create_builder(self, name, self.env)</span>
<span class="gi">+</span>
<span class="gi">+    def _init_builder(self) -&gt; None:</span>
<span class="gi">+        self.builder.init()</span>
<span class="gi">+        self.events.emit(&#39;builder-inited&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # ---- main &quot;build&quot; method -------------------------------------------------</span>
<span class="gi">+</span>
<span class="gi">+    def build(self, force_all: bool = False, filenames: list[str] | None = None) -&gt; None:</span>
<span class="gi">+        self.phase = BuildPhase.READING</span>
<span class="gi">+        try:</span>
<span class="gi">+            if force_all:</span>
<span class="gi">+                self.builder.build_all()</span>
<span class="gi">+            elif filenames:</span>
<span class="gi">+                self.builder.build_specific(filenames)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.builder.build_update()</span>
<span class="gi">+</span>
<span class="gi">+            self.events.emit(&#39;build-finished&#39;, None)</span>
<span class="gi">+        except Exception as err:</span>
<span class="gi">+            # delete the saved env to force a fresh build next time</span>
<span class="gi">+            envfile = path.join(self.doctreedir, ENV_PICKLE_FILENAME)</span>
<span class="gi">+            if path.isfile(envfile):</span>
<span class="gi">+                os.unlink(envfile)</span>
<span class="gi">+            self.events.emit(&#39;build-finished&#39;, err)</span>
<span class="gi">+            raise</span>
<span class="gi">+</span>
<span class="gi">+        if self._warncount == 0:</span>
<span class="gi">+            if self.statuscode != 0:</span>
<span class="gi">+                logger.info(bold(__(&#39;build finished with problems.&#39;)))</span>
<span class="gi">+            else:</span>
<span class="gi">+                logger.info(bold(__(&#39;build succeeded.&#39;)))</span>
<span class="gi">+        elif self._warncount == 1:</span>
<span class="gi">+            if self._fail_on_warnings:</span>
<span class="gi">+                self.statuscode = 1</span>
<span class="gi">+                msg = __(&#39;build finished with problems, 1 warning &#39;</span>
<span class="gi">+                         &#39;(with warnings treated as errors).&#39;)</span>
<span class="gi">+            elif self.statuscode != 0:</span>
<span class="gi">+                msg = __(&#39;build finished with problems, 1 warning.&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                msg = __(&#39;build succeeded, 1 warning.&#39;)</span>
<span class="gi">+            logger.info(bold(msg))</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self._fail_on_warnings:</span>
<span class="gi">+                self.statuscode = 1</span>
<span class="gi">+                msg = __(&#39;build finished with problems, %s warnings &#39;</span>
<span class="gi">+                         &#39;(with warnings treated as errors).&#39;)</span>
<span class="gi">+            elif self.statuscode != 0:</span>
<span class="gi">+                msg = __(&#39;build finished with problems, %s warnings.&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                msg = __(&#39;build succeeded, %s warnings.&#39;)</span>
<span class="gi">+            logger.info(bold(msg), self._warncount)</span>
<span class="gi">+</span>
<span class="gi">+        if self.statuscode == 0 and self.builder.epilog:</span>
<span class="gi">+            logger.info(&#39;&#39;)</span>
<span class="gi">+            logger.info(self.builder.epilog, {</span>
<span class="gi">+                &#39;outdir&#39;: relpath(self.outdir),</span>
<span class="gi">+                &#39;project&#39;: self.config.project,</span>
<span class="gi">+            })</span>
<span class="gi">+</span>
<span class="gi">+        self.builder.cleanup()</span>
<span class="gi">+</span>
<span class="gi">+    # ---- general extensibility interface -------------------------------------</span>
<span class="gi">+</span>
<span class="gi">+    def setup_extension(self, extname: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Import and setup a Sphinx extension module.

<span class="w"> </span>        Load the extension given by the module *name*.  Use this if your
<span class="w"> </span>        extension needs the features provided by another extension.  No-op if
<span class="w"> </span>        called twice.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.debug(&#39;[app] setting up extension: %r&#39;, extname)</span>
<span class="gi">+        self.registry.load_extension(self, extname)</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def require_sphinx(version: (tuple[int, int] | str)) -&gt;None:</span>
<span class="gi">+    def require_sphinx(version: tuple[int, int] | str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check the Sphinx version if requested.

<span class="w"> </span>        Compare *version* with the version of the running Sphinx, and abort the
<span class="gu">@@ -241,9 +450,339 @@ class Sphinx:</span>
<span class="w"> </span>        .. versionchanged:: 7.1
<span class="w"> </span>           Type of *version* now allows ``(major, minor)`` form.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def connect(self, event: str, callback: Callable, priority: int=500) -&gt;int:</span>
<span class="gi">+        if isinstance(version, tuple):</span>
<span class="gi">+            major, minor = version</span>
<span class="gi">+        else:</span>
<span class="gi">+            major, minor = map(int, version.split(&#39;.&#39;)[:2])</span>
<span class="gi">+        if (major, minor) &gt; sphinx.version_info[:2]:</span>
<span class="gi">+            req = f&#39;{major}.{minor}&#39;</span>
<span class="gi">+            raise VersionRequirementError(req)</span>
<span class="gi">+</span>
<span class="gi">+    # ---- Core events -------------------------------------------------------</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;config-inited&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, Config], None],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;builder-inited&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx], None],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;env-get-outdated&#39;],</span>
<span class="gi">+        callback: Callable[</span>
<span class="gi">+            [Sphinx, BuildEnvironment, Set[str], Set[str], Set[str]], Sequence[str]</span>
<span class="gi">+        ],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;env-before-read-docs&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, BuildEnvironment, list[str]], None],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;env-purge-doc&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, BuildEnvironment, str], None],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;source-read&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, str, list[str]], None],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;include-read&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, Path, str, list[str]], None],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;doctree-read&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, nodes.document], None],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;env-merge-info&#39;],</span>
<span class="gi">+        callback: Callable[</span>
<span class="gi">+            [Sphinx, BuildEnvironment, list[str], BuildEnvironment], None</span>
<span class="gi">+        ],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;env-updated&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, BuildEnvironment], str],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;env-get-updated&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, BuildEnvironment], Iterable[str]],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;env-check-consistency&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, BuildEnvironment], None],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;write-started&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, Builder], None],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;doctree-resolved&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, nodes.document, str], None],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;missing-reference&#39;],</span>
<span class="gi">+        callback: Callable[</span>
<span class="gi">+            [Sphinx, BuildEnvironment, addnodes.pending_xref, nodes.TextElement],</span>
<span class="gi">+            nodes.reference | None,</span>
<span class="gi">+        ],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;warn-missing-reference&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, Domain, addnodes.pending_xref], bool | None],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;build-finished&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, Exception | None], None],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    # ---- Events from builtin builders --------------------------------------</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;html-collect-pages&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx], Iterable[tuple[str, dict[str, Any], str]]],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;html-page-context&#39;],</span>
<span class="gi">+        callback: Callable[</span>
<span class="gi">+            [Sphinx, str, str, dict[str, Any], nodes.document], str | None</span>
<span class="gi">+        ],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;linkcheck-process-uri&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, str], str | None],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    # ---- Events from builtin extensions-- ----------------------------------</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;object-description-transform&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, str, str, addnodes.desc_content], None],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    # ---- Events from first-party extensions --------------------------------</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;autodoc-process-docstring&#39;],</span>
<span class="gi">+        callback: Callable[</span>
<span class="gi">+            [</span>
<span class="gi">+                Sphinx,</span>
<span class="gi">+                Literal[&#39;module&#39;, &#39;class&#39;, &#39;exception&#39;, &#39;function&#39;, &#39;method&#39;, &#39;attribute&#39;],</span>
<span class="gi">+                str,</span>
<span class="gi">+                Any,</span>
<span class="gi">+                dict[str, bool],</span>
<span class="gi">+                Sequence[str],</span>
<span class="gi">+            ],</span>
<span class="gi">+            None,</span>
<span class="gi">+        ],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;autodoc-before-process-signature&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, Any, bool], None],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;autodoc-process-signature&#39;],</span>
<span class="gi">+        callback: Callable[</span>
<span class="gi">+            [</span>
<span class="gi">+                Sphinx,</span>
<span class="gi">+                Literal[&#39;module&#39;, &#39;class&#39;, &#39;exception&#39;, &#39;function&#39;, &#39;method&#39;, &#39;attribute&#39;],</span>
<span class="gi">+                str,</span>
<span class="gi">+                Any,</span>
<span class="gi">+                dict[str, bool],</span>
<span class="gi">+                str | None,</span>
<span class="gi">+                str | None,</span>
<span class="gi">+            ],</span>
<span class="gi">+            tuple[str | None, str | None] | None,</span>
<span class="gi">+        ],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;autodoc-process-bases&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, str, Any, dict[str, bool], list[str]], None],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;autodoc-skip-member&#39;],</span>
<span class="gi">+        callback: Callable[</span>
<span class="gi">+            [</span>
<span class="gi">+                Sphinx,</span>
<span class="gi">+                Literal[&#39;module&#39;, &#39;class&#39;, &#39;exception&#39;, &#39;function&#39;, &#39;method&#39;, &#39;attribute&#39;],</span>
<span class="gi">+                str,</span>
<span class="gi">+                Any,</span>
<span class="gi">+                bool,</span>
<span class="gi">+                dict[str, bool],</span>
<span class="gi">+            ],</span>
<span class="gi">+            bool,</span>
<span class="gi">+        ],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;todo-defined&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, todo_node], None],</span>
<span class="gi">+        priority: int = 500,</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;viewcode-find-source&#39;],</span>
<span class="gi">+        callback: Callable[</span>
<span class="gi">+            [Sphinx, str],</span>
<span class="gi">+            tuple[str, dict[str, tuple[Literal[&#39;class&#39;, &#39;def&#39;, &#39;other&#39;], int, int]]],</span>
<span class="gi">+        ],</span>
<span class="gi">+        priority: int = 500,</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: Literal[&#39;viewcode-follow-imported&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, str, str], str | None],</span>
<span class="gi">+        priority: int = 500,</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    # ---- Catch-all ---------------------------------------------------------</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        event: str,</span>
<span class="gi">+        callback: Callable[..., Any],</span>
<span class="gi">+        priority: int = 500</span>
<span class="gi">+    ) -&gt; int:</span>
<span class="gi">+        ...</span>
<span class="gi">+</span>
<span class="gi">+    # event interface</span>
<span class="gi">+    def connect(self, event: str, callback: Callable, priority: int = 500) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register *callback* to be called when *event* is emitted.

<span class="w"> </span>        For details on available core events and the arguments of callback
<span class="gu">@@ -259,17 +798,21 @@ class Sphinx:</span>

<span class="w"> </span>           Support *priority*
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        listener_id = self.events.connect(event, callback, priority)</span>
<span class="gi">+        logger.debug(&#39;[app] connecting event %r (%d): %r [id=%s]&#39;,</span>
<span class="gi">+                     event, priority, callback, listener_id)</span>
<span class="gi">+        return listener_id</span>

<span class="gd">-    def disconnect(self, listener_id: int) -&gt;None:</span>
<span class="gi">+    def disconnect(self, listener_id: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Unregister callback by *listener_id*.

<span class="w"> </span>        :param listener_id: A listener_id that :meth:`connect` returns
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.debug(&#39;[app] disconnecting event: [id=%s]&#39;, listener_id)</span>
<span class="gi">+        self.events.disconnect(listener_id)</span>

<span class="gd">-    def emit(self, event: str, *args: Any, allowed_exceptions: tuple[type[</span>
<span class="gd">-        Exception], ...]=()) -&gt;list:</span>
<span class="gi">+    def emit(self, event: str, *args: Any,</span>
<span class="gi">+             allowed_exceptions: tuple[type[Exception], ...] = ()) -&gt; list:</span>
<span class="w"> </span>        &quot;&quot;&quot;Emit *event* and pass *arguments* to the callback functions.

<span class="w"> </span>        Return the return values of all callbacks as a list.  Do not emit core
<span class="gu">@@ -283,10 +826,10 @@ class Sphinx:</span>

<span class="w"> </span>           Added *allowed_exceptions* to specify path-through exceptions
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.events.emit(event, *args, allowed_exceptions=allowed_exceptions)</span>

<span class="gd">-    def emit_firstresult(self, event: str, *args: Any, allowed_exceptions:</span>
<span class="gd">-        tuple[type[Exception], ...]=()) -&gt;Any:</span>
<span class="gi">+    def emit_firstresult(self, event: str, *args: Any,</span>
<span class="gi">+                         allowed_exceptions: tuple[type[Exception], ...] = ()) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Emit *event* and pass *arguments* to the callback functions.

<span class="w"> </span>        Return the result of the first callback that doesn&#39;t return ``None``.
<span class="gu">@@ -300,9 +843,12 @@ class Sphinx:</span>

<span class="w"> </span>           Added *allowed_exceptions* to specify path-through exceptions
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.events.emit_firstresult(event, *args,</span>
<span class="gi">+                                            allowed_exceptions=allowed_exceptions)</span>

<span class="gd">-    def add_builder(self, builder: type[Builder], override: bool=False) -&gt;None:</span>
<span class="gi">+    # registering addon parts</span>
<span class="gi">+</span>
<span class="gi">+    def add_builder(self, builder: type[Builder], override: bool = False) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a new builder.

<span class="w"> </span>        :param builder: A builder class
<span class="gu">@@ -312,11 +858,13 @@ class Sphinx:</span>
<span class="w"> </span>        .. versionchanged:: 1.8
<span class="w"> </span>           Add *override* keyword.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.registry.add_builder(builder, override=override)</span>

<span class="gd">-    def add_config_value(self, name: str, default: Any, rebuild:</span>
<span class="gd">-        _ConfigRebuild, types: (type | Collection[type] | ENUM)=(),</span>
<span class="gd">-        description: str=&#39;&#39;) -&gt;None:</span>
<span class="gi">+    def add_config_value(</span>
<span class="gi">+        self, name: str, default: Any, rebuild: _ConfigRebuild,</span>
<span class="gi">+        types: type | Collection[type] | ENUM = (),</span>
<span class="gi">+        description: str = &#39;&#39;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a configuration value.

<span class="w"> </span>        This is necessary for Sphinx to recognize new values and set default
<span class="gu">@@ -353,19 +901,21 @@ class Sphinx:</span>
<span class="w"> </span>        .. versionadded:: 7.4
<span class="w"> </span>           The *description* parameter.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.debug(&#39;[app] adding config value: %r&#39;, (name, default, rebuild, types))</span>
<span class="gi">+        self.config.add(name, default, rebuild, types, description)</span>

<span class="gd">-    def add_event(self, name: str) -&gt;None:</span>
<span class="gi">+    def add_event(self, name: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register an event called *name*.

<span class="w"> </span>        This is needed to be able to emit it.

<span class="w"> </span>        :param name: The name of the event
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.debug(&#39;[app] adding event: %r&#39;, name)</span>
<span class="gi">+        self.events.add(name)</span>

<span class="gd">-    def set_translator(self, name: str, translator_class: type[nodes.</span>
<span class="gd">-        NodeVisitor], override: bool=False) -&gt;None:</span>
<span class="gi">+    def set_translator(self, name: str, translator_class: type[nodes.NodeVisitor],</span>
<span class="gi">+                       override: bool = False) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register or override a Docutils translator class.

<span class="w"> </span>        This is used to register a custom output translator or to replace a
<span class="gu">@@ -381,10 +931,10 @@ class Sphinx:</span>
<span class="w"> </span>        .. versionchanged:: 1.8
<span class="w"> </span>           Add *override* keyword.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.registry.add_translator(name, translator_class, override=override)</span>

<span class="gd">-    def add_node(self, node: type[Element], override: bool=False, **kwargs:</span>
<span class="gd">-        tuple[Callable, Callable | None]) -&gt;None:</span>
<span class="gi">+    def add_node(self, node: type[Element], override: bool = False,</span>
<span class="gi">+                 **kwargs: tuple[Callable, Callable | None]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a Docutils node class.

<span class="w"> </span>        This is necessary for Docutils internals.  It may also be used in the
<span class="gu">@@ -419,11 +969,17 @@ class Sphinx:</span>
<span class="w"> </span>        .. versionchanged:: 0.5
<span class="w"> </span>           Added the support for keyword arguments giving visit functions.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.debug(&#39;[app] adding node: %r&#39;, (node, kwargs))</span>
<span class="gi">+        if not override and docutils.is_node_registered(node):</span>
<span class="gi">+            logger.warning(__(&#39;node class %r is already registered, &#39;</span>
<span class="gi">+                              &#39;its visitors will be overridden&#39;),</span>
<span class="gi">+                           node.__name__, type=&#39;app&#39;, subtype=&#39;add_node&#39;)</span>
<span class="gi">+        docutils.register_node(node)</span>
<span class="gi">+        self.registry.add_translation_handlers(node, **kwargs)</span>

<span class="w"> </span>    def add_enumerable_node(self, node: type[Element], figtype: str,
<span class="gd">-        title_getter: (TitleGetter | None)=None, override: bool=False, **</span>
<span class="gd">-        kwargs: tuple[Callable, Callable]) -&gt;None:</span>
<span class="gi">+                            title_getter: TitleGetter | None = None, override: bool = False,</span>
<span class="gi">+                            **kwargs: tuple[Callable, Callable]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a Docutils node class as a numfig target.

<span class="w"> </span>        Sphinx numbers the node automatically. And then the users can refer it
<span class="gu">@@ -447,10 +1003,10 @@ class Sphinx:</span>

<span class="w"> </span>        .. versionadded:: 1.4
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.registry.add_enumerable_node(node, figtype, title_getter, override=override)</span>
<span class="gi">+        self.add_node(node, override=override, **kwargs)</span>

<span class="gd">-    def add_directive(self, name: str, cls: type[Directive], override: bool</span>
<span class="gd">-        =False) -&gt;None:</span>
<span class="gi">+    def add_directive(self, name: str, cls: type[Directive], override: bool = False) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a Docutils directive.

<span class="w"> </span>        :param name: The name of the directive
<span class="gu">@@ -492,9 +1048,14 @@ class Sphinx:</span>
<span class="w"> </span>        .. versionchanged:: 1.8
<span class="w"> </span>           Add *override* keyword.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.debug(&#39;[app] adding directive: %r&#39;, (name, cls))</span>
<span class="gi">+        if not override and docutils.is_directive_registered(name):</span>
<span class="gi">+            logger.warning(__(&#39;directive %r is already registered, it will be overridden&#39;),</span>
<span class="gi">+                           name, type=&#39;app&#39;, subtype=&#39;add_directive&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        docutils.register_directive(name, cls)</span>

<span class="gd">-    def add_role(self, name: str, role: Any, override: bool=False) -&gt;None:</span>
<span class="gi">+    def add_role(self, name: str, role: Any, override: bool = False) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a Docutils role.

<span class="w"> </span>        :param name: The name of role
<span class="gu">@@ -509,10 +1070,16 @@ class Sphinx:</span>
<span class="w"> </span>        .. versionchanged:: 1.8
<span class="w"> </span>           Add *override* keyword.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.debug(&#39;[app] adding role: %r&#39;, (name, role))</span>
<span class="gi">+        if not override and docutils.is_role_registered(name):</span>
<span class="gi">+            logger.warning(__(&#39;role %r is already registered, it will be overridden&#39;),</span>
<span class="gi">+                           name, type=&#39;app&#39;, subtype=&#39;add_role&#39;)</span>
<span class="gi">+        docutils.register_role(name, role)</span>

<span class="gd">-    def add_generic_role(self, name: str, nodeclass: type[Node], override:</span>
<span class="gd">-        bool=False) -&gt;None:</span>
<span class="gi">+    def add_generic_role(</span>
<span class="gi">+        self, name: str, nodeclass: type[Node], override: bool = False</span>
<span class="gi">+</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a generic Docutils role.

<span class="w"> </span>        Register a Docutils role that does nothing but wrap its contents in the
<span class="gu">@@ -526,9 +1093,16 @@ class Sphinx:</span>
<span class="w"> </span>        .. versionchanged:: 1.8
<span class="w"> </span>           Add *override* keyword.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def add_domain(self, domain: type[Domain], override: bool=False) -&gt;None:</span>
<span class="gi">+        # Don&#39;t use ``roles.register_generic_role`` because it uses</span>
<span class="gi">+        # ``register_canonical_role``.</span>
<span class="gi">+        logger.debug(&#39;[app] adding generic role: %r&#39;, (name, nodeclass))</span>
<span class="gi">+        if not override and docutils.is_role_registered(name):</span>
<span class="gi">+            logger.warning(__(&#39;role %r is already registered, it will be overridden&#39;),</span>
<span class="gi">+                           name, type=&#39;app&#39;, subtype=&#39;add_generic_role&#39;)</span>
<span class="gi">+        role = roles.GenericRole(name, nodeclass)</span>
<span class="gi">+        docutils.register_role(name, role)</span>
<span class="gi">+</span>
<span class="gi">+    def add_domain(self, domain: type[Domain], override: bool = False) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a domain.

<span class="w"> </span>        :param domain: A domain class
<span class="gu">@@ -540,10 +1114,10 @@ class Sphinx:</span>
<span class="w"> </span>        .. versionchanged:: 1.8
<span class="w"> </span>           Add *override* keyword.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.registry.add_domain(domain, override=override)</span>

<span class="gd">-    def add_directive_to_domain(self, domain: str, name: str, cls: type[</span>
<span class="gd">-        Directive], override: bool=False) -&gt;None:</span>
<span class="gi">+    def add_directive_to_domain(self, domain: str, name: str,</span>
<span class="gi">+                                cls: type[Directive], override: bool = False) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a Docutils directive in a domain.

<span class="w"> </span>        Like :meth:`add_directive`, but the directive is added to the domain
<span class="gu">@@ -560,10 +1134,10 @@ class Sphinx:</span>
<span class="w"> </span>        .. versionchanged:: 1.8
<span class="w"> </span>           Add *override* keyword.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.registry.add_directive_to_domain(domain, name, cls, override=override)</span>

<span class="gd">-    def add_role_to_domain(self, domain: str, name: str, role: (</span>
<span class="gd">-        RoleFunction | XRefRole), override: bool=False) -&gt;None:</span>
<span class="gi">+    def add_role_to_domain(self, domain: str, name: str, role: RoleFunction | XRefRole,</span>
<span class="gi">+                           override: bool = False) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a Docutils role in a domain.

<span class="w"> </span>        Like :meth:`add_role`, but the role is added to the domain named
<span class="gu">@@ -580,10 +1154,10 @@ class Sphinx:</span>
<span class="w"> </span>        .. versionchanged:: 1.8
<span class="w"> </span>           Add *override* keyword.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.registry.add_role_to_domain(domain, name, role, override=override)</span>

<span class="gd">-    def add_index_to_domain(self, domain: str, index: type[Index],</span>
<span class="gd">-        _override: bool=False) -&gt;None:</span>
<span class="gi">+    def add_index_to_domain(self, domain: str, index: type[Index], _override: bool = False,</span>
<span class="gi">+                            ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a custom index for a domain.

<span class="w"> </span>        Add a custom *index* class to the domain named *domain*.
<span class="gu">@@ -598,12 +1172,14 @@ class Sphinx:</span>
<span class="w"> </span>        .. versionchanged:: 1.8
<span class="w"> </span>           Add *override* keyword.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def add_object_type(self, directivename: str, rolename: str,</span>
<span class="gd">-        indextemplate: str=&#39;&#39;, parse_node: (Callable | None)=None,</span>
<span class="gd">-        ref_nodeclass: (type[nodes.TextElement] | None)=None, objname: str=</span>
<span class="gd">-        &#39;&#39;, doc_field_types: Sequence=(), override: bool=False) -&gt;None:</span>
<span class="gi">+        self.registry.add_index_to_domain(domain, index)</span>
<span class="gi">+</span>
<span class="gi">+    def add_object_type(self, directivename: str, rolename: str, indextemplate: str = &#39;&#39;,</span>
<span class="gi">+                        parse_node: Callable | None = None,</span>
<span class="gi">+                        ref_nodeclass: type[nodes.TextElement] | None = None,</span>
<span class="gi">+                        objname: str = &#39;&#39;, doc_field_types: Sequence = (),</span>
<span class="gi">+                        override: bool = False,</span>
<span class="gi">+                        ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a new object type.

<span class="w"> </span>        This method is a very convenient way to add a new :term:`object` type
<span class="gu">@@ -663,11 +1239,15 @@ class Sphinx:</span>
<span class="w"> </span>        .. versionchanged:: 1.8
<span class="w"> </span>           Add *override* keyword.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def add_crossref_type(self, directivename: str, rolename: str,</span>
<span class="gd">-        indextemplate: str=&#39;&#39;, ref_nodeclass: (type[nodes.TextElement] |</span>
<span class="gd">-        None)=None, objname: str=&#39;&#39;, override: bool=False) -&gt;None:</span>
<span class="gi">+        self.registry.add_object_type(directivename, rolename, indextemplate, parse_node,</span>
<span class="gi">+                                      ref_nodeclass, objname, doc_field_types,</span>
<span class="gi">+                                      override=override)</span>
<span class="gi">+</span>
<span class="gi">+    def add_crossref_type(</span>
<span class="gi">+        self, directivename: str, rolename: str, indextemplate: str = &#39;&#39;,</span>
<span class="gi">+        ref_nodeclass: type[nodes.TextElement] | None = None, objname: str = &#39;&#39;,</span>
<span class="gi">+        override: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a new crossref object type.

<span class="w"> </span>        This method is very similar to :meth:`~Sphinx.add_object_type` except that the
<span class="gu">@@ -702,9 +1282,11 @@ class Sphinx:</span>
<span class="w"> </span>        .. versionchanged:: 1.8
<span class="w"> </span>           Add *override* keyword.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.registry.add_crossref_type(directivename, rolename,</span>
<span class="gi">+                                        indextemplate, ref_nodeclass, objname,</span>
<span class="gi">+                                        override=override)</span>

<span class="gd">-    def add_transform(self, transform: type[Transform]) -&gt;None:</span>
<span class="gi">+    def add_transform(self, transform: type[Transform]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a Docutils transform to be applied after parsing.

<span class="w"> </span>        Add the standard docutils :class:`~docutils.transforms.Transform`
<span class="gu">@@ -736,10 +1318,10 @@ class Sphinx:</span>
<span class="w"> </span>        refs: `Transform Priority Range Categories`__

<span class="w"> </span>        __ https://docutils.sourceforge.io/docs/ref/transforms.html#transform-priority-range-categories
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &quot;&quot;&quot;  # NoQA: E501,RUF100  # Flake8 thinks the URL is too long, Ruff special cases URLs.</span>
<span class="gi">+        self.registry.add_transform(transform)</span>

<span class="gd">-    def add_post_transform(self, transform: type[Transform]) -&gt;None:</span>
<span class="gi">+    def add_post_transform(self, transform: type[Transform]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a Docutils transform to be applied before writing.

<span class="w"> </span>        Add the standard docutils :class:`~docutils.transforms.Transform`
<span class="gu">@@ -748,10 +1330,10 @@ class Sphinx:</span>

<span class="w"> </span>        :param transform: A transform class
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.registry.add_post_transform(transform)</span>

<span class="gd">-    def add_js_file(self, filename: (str | None), priority: int=500,</span>
<span class="gd">-        loading_method: (str | None)=None, **kwargs: Any) -&gt;None:</span>
<span class="gi">+    def add_js_file(self, filename: str | None, priority: int = 500,</span>
<span class="gi">+                    loading_method: str | None = None, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a JavaScript file to include in the HTML output.

<span class="w"> </span>        :param filename: The name of a JavaScript file that the default HTML
<span class="gu">@@ -809,10 +1391,18 @@ class Sphinx:</span>
<span class="w"> </span>           Take loading_method argument.  Allow to change the loading method of the
<span class="w"> </span>           JavaScript file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def add_css_file(self, filename: str, priority: int=500, **kwargs: Any</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        if loading_method == &#39;async&#39;:</span>
<span class="gi">+            kwargs[&#39;async&#39;] = &#39;async&#39;</span>
<span class="gi">+        elif loading_method == &#39;defer&#39;:</span>
<span class="gi">+            kwargs[&#39;defer&#39;] = &#39;defer&#39;</span>
<span class="gi">+</span>
<span class="gi">+        self.registry.add_js_file(filename, priority=priority, **kwargs)</span>
<span class="gi">+        with contextlib.suppress(AttributeError):</span>
<span class="gi">+            self.builder.add_js_file(  # type: ignore[attr-defined]</span>
<span class="gi">+                filename, priority=priority, **kwargs,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def add_css_file(self, filename: str, priority: int = 500, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a stylesheet to include in the HTML output.

<span class="w"> </span>        :param filename: The name of a CSS file that the default HTML
<span class="gu">@@ -869,32 +1459,37 @@ class Sphinx:</span>
<span class="w"> </span>        .. versionchanged:: 3.5
<span class="w"> </span>           Take priority argument.  Allow to add a CSS file to the specific page.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.debug(&#39;[app] adding stylesheet: %r&#39;, filename)</span>
<span class="gi">+        self.registry.add_css_files(filename, priority=priority, **kwargs)</span>
<span class="gi">+        with contextlib.suppress(AttributeError):</span>
<span class="gi">+            self.builder.add_css_file(  # type: ignore[attr-defined]</span>
<span class="gi">+                filename, priority=priority, **kwargs,</span>
<span class="gi">+            )</span>

<span class="gd">-    def add_latex_package(self, packagename: str, options: (str | None)=</span>
<span class="gd">-        None, after_hyperref: bool=False) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Register a package to include in the LaTeX source code.</span>
<span class="gi">+    def add_latex_package(self, packagename: str, options: str | None = None,</span>
<span class="gi">+                          after_hyperref: bool = False) -&gt; None:</span>
<span class="gi">+        r&quot;&quot;&quot;Register a package to include in the LaTeX source code.</span>

<span class="w"> </span>        Add *packagename* to the list of packages that LaTeX source code will
<span class="gd">-        include.  If you provide *options*, it will be taken to the `\\usepackage`</span>
<span class="gi">+        include.  If you provide *options*, it will be taken to the `\usepackage`</span>
<span class="w"> </span>        declaration.  If you set *after_hyperref* truthy, the package will be
<span class="w"> </span>        loaded after ``hyperref`` package.

<span class="w"> </span>        .. code-block:: python

<span class="w"> </span>           app.add_latex_package(&#39;mypackage&#39;)
<span class="gd">-           # =&gt; \\usepackage{mypackage}</span>
<span class="gi">+           # =&gt; \usepackage{mypackage}</span>
<span class="w"> </span>           app.add_latex_package(&#39;mypackage&#39;, &#39;foo,bar&#39;)
<span class="gd">-           # =&gt; \\usepackage[foo,bar]{mypackage}</span>
<span class="gi">+           # =&gt; \usepackage[foo,bar]{mypackage}</span>

<span class="w"> </span>        .. versionadded:: 1.3
<span class="w"> </span>        .. versionadded:: 3.1

<span class="w"> </span>           *after_hyperref* option.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.registry.add_latex_package(packagename, options, after_hyperref)</span>

<span class="gd">-    def add_lexer(self, alias: str, lexer: type[Lexer]) -&gt;None:</span>
<span class="gi">+    def add_lexer(self, alias: str, lexer: type[Lexer]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a new lexer for source code.

<span class="w"> </span>        Use *lexer* to highlight code blocks with the given language *alias*.
<span class="gu">@@ -905,10 +1500,10 @@ class Sphinx:</span>
<span class="w"> </span>        .. versionchanged:: 4.0
<span class="w"> </span>           Removed support for lexer instances as an argument.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.debug(&#39;[app] adding lexer: %r&#39;, (alias, lexer))</span>
<span class="gi">+        lexer_classes[alias] = lexer</span>

<span class="gd">-    def add_autodocumenter(self, cls: type[Documenter], override: bool=False</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def add_autodocumenter(self, cls: type[Documenter], override: bool = False) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a new documenter class for the autodoc extension.

<span class="w"> </span>        Add *cls* as a new documenter class for the :mod:`sphinx.ext.autodoc`
<span class="gu">@@ -926,10 +1521,13 @@ class Sphinx:</span>
<span class="w"> </span>        .. versionchanged:: 2.2
<span class="w"> </span>           Add *override* keyword.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.debug(&#39;[app] adding autodocumenter: %r&#39;, cls)</span>
<span class="gi">+        from sphinx.ext.autodoc.directive import AutodocDirective</span>
<span class="gi">+        self.registry.add_documenter(cls.objtype, cls)</span>
<span class="gi">+        self.add_directive(&#39;auto&#39; + cls.objtype, AutodocDirective, override=override)</span>

<span class="gd">-    def add_autodoc_attrgetter(self, typ: type, getter: Callable[[Any, str,</span>
<span class="gd">-        Any], Any]) -&gt;None:</span>
<span class="gi">+    def add_autodoc_attrgetter(self, typ: type, getter: Callable[[Any, str, Any], Any],</span>
<span class="gi">+                               ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a new ``getattr``-like function for the autodoc extension.

<span class="w"> </span>        Add *getter*, which must be a function with an interface compatible to
<span class="gu">@@ -940,9 +1538,10 @@ class Sphinx:</span>

<span class="w"> </span>        .. versionadded:: 0.6
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.debug(&#39;[app] adding autodoc attrgetter: %r&#39;, (typ, getter))</span>
<span class="gi">+        self.registry.add_autodoc_attrgetter(typ, getter)</span>

<span class="gd">-    def add_search_language(self, cls: type[SearchLanguage]) -&gt;None:</span>
<span class="gi">+    def add_search_language(self, cls: type[SearchLanguage]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a new language for the HTML search index.

<span class="w"> </span>        Add *cls*, which must be a subclass of
<span class="gu">@@ -953,10 +1552,11 @@ class Sphinx:</span>

<span class="w"> </span>        .. versionadded:: 1.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.debug(&#39;[app] adding search language: %r&#39;, cls)</span>
<span class="gi">+        from sphinx.search import languages</span>
<span class="gi">+        languages[cls.lang] = cls</span>

<span class="gd">-    def add_source_suffix(self, suffix: str, filetype: str, override: bool=</span>
<span class="gd">-        False) -&gt;None:</span>
<span class="gi">+    def add_source_suffix(self, suffix: str, filetype: str, override: bool = False) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a suffix of source files.

<span class="w"> </span>        Same as :confval:`source_suffix`.  The users can override this
<span class="gu">@@ -968,10 +1568,9 @@ class Sphinx:</span>

<span class="w"> </span>        .. versionadded:: 1.8
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.registry.add_source_suffix(suffix, filetype, override=override)</span>

<span class="gd">-    def add_source_parser(self, parser: type[Parser], override: bool=False</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def add_source_parser(self, parser: type[Parser], override: bool = False) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a parser class.

<span class="w"> </span>        :param override: If false, do not install it if another parser
<span class="gu">@@ -985,18 +1584,19 @@ class Sphinx:</span>
<span class="w"> </span>        .. versionchanged:: 1.8
<span class="w"> </span>           Add *override* keyword.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.registry.add_source_parser(parser, override=override)</span>

<span class="gd">-    def add_env_collector(self, collector: type[EnvironmentCollector]) -&gt;None:</span>
<span class="gi">+    def add_env_collector(self, collector: type[EnvironmentCollector]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register an environment collector class.

<span class="w"> </span>        Refer to :ref:`collector-api`.

<span class="w"> </span>        .. versionadded:: 1.6
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.debug(&#39;[app] adding environment collector: %r&#39;, collector)</span>
<span class="gi">+        collector().enable(self)</span>

<span class="gd">-    def add_html_theme(self, name: str, theme_path: str) -&gt;None:</span>
<span class="gi">+    def add_html_theme(self, name: str, theme_path: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a HTML Theme.

<span class="w"> </span>        The *name* is a name of theme, and *theme_path* is a full path to the
<span class="gu">@@ -1004,11 +1604,15 @@ class Sphinx:</span>

<span class="w"> </span>        .. versionadded:: 1.6
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def add_html_math_renderer(self, name: str, inline_renderers: (tuple[</span>
<span class="gd">-        Callable, Callable | None] | None)=None, block_renderers: (tuple[</span>
<span class="gd">-        Callable, Callable | None] | None)=None) -&gt;None:</span>
<span class="gi">+        logger.debug(&#39;[app] adding HTML theme: %r, %r&#39;, name, theme_path)</span>
<span class="gi">+        self.registry.add_html_theme(name, theme_path)</span>
<span class="gi">+</span>
<span class="gi">+    def add_html_math_renderer(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        inline_renderers: tuple[Callable, Callable | None] | None = None,</span>
<span class="gi">+        block_renderers: tuple[Callable, Callable | None] | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a math renderer for HTML.

<span class="w"> </span>        The *name* is a name of math renderer.  Both *inline_renderers* and
<span class="gu">@@ -1020,9 +1624,9 @@ class Sphinx:</span>
<span class="w"> </span>        .. versionadded:: 1.8

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.registry.add_html_math_renderer(name, inline_renderers, block_renderers)</span>

<span class="gd">-    def add_message_catalog(self, catalog: str, locale_dir: str) -&gt;None:</span>
<span class="gi">+    def add_message_catalog(self, catalog: str, locale_dir: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a message catalog.

<span class="w"> </span>        :param catalog: The name of the catalog
<span class="gu">@@ -1032,17 +1636,46 @@ class Sphinx:</span>

<span class="w"> </span>        .. versionadded:: 1.8
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        locale.init([locale_dir], self.config.language, catalog)</span>
<span class="gi">+        locale.init_console(locale_dir, catalog)</span>

<span class="gd">-    def is_parallel_allowed(self, typ: str) -&gt;bool:</span>
<span class="gi">+    # ---- other methods -------------------------------------------------</span>
<span class="gi">+    def is_parallel_allowed(self, typ: str) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check whether parallel processing is allowed or not.

<span class="w"> </span>        :param typ: A type of processing; ``&#39;read&#39;`` or ``&#39;write&#39;``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def set_html_assets_policy(self, policy: Literal[&#39;always&#39;, &#39;per_page&#39;]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        if typ == &#39;read&#39;:</span>
<span class="gi">+            attrname = &#39;parallel_read_safe&#39;</span>
<span class="gi">+            message_not_declared = __(&quot;the %s extension does not declare if it &quot;</span>
<span class="gi">+                                      &quot;is safe for parallel reading, assuming &quot;</span>
<span class="gi">+                                      &quot;it isn&#39;t - please ask the extension author &quot;</span>
<span class="gi">+                                      &quot;to check and make it explicit&quot;)</span>
<span class="gi">+            message_not_safe = __(&quot;the %s extension is not safe for parallel reading&quot;)</span>
<span class="gi">+        elif typ == &#39;write&#39;:</span>
<span class="gi">+            attrname = &#39;parallel_write_safe&#39;</span>
<span class="gi">+            message_not_declared = __(&quot;the %s extension does not declare if it &quot;</span>
<span class="gi">+                                      &quot;is safe for parallel writing, assuming &quot;</span>
<span class="gi">+                                      &quot;it isn&#39;t - please ask the extension author &quot;</span>
<span class="gi">+                                      &quot;to check and make it explicit&quot;)</span>
<span class="gi">+            message_not_safe = __(&quot;the %s extension is not safe for parallel writing&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&#39;parallel type %s is not supported&#39; % typ)</span>
<span class="gi">+</span>
<span class="gi">+        for ext in self.extensions.values():</span>
<span class="gi">+            allowed = getattr(ext, attrname, None)</span>
<span class="gi">+            if allowed is None:</span>
<span class="gi">+                logger.warning(message_not_declared, ext.name)</span>
<span class="gi">+                logger.warning(__(&#39;doing serial %s&#39;), typ)</span>
<span class="gi">+                return False</span>
<span class="gi">+            elif not allowed:</span>
<span class="gi">+                logger.warning(message_not_safe, ext.name)</span>
<span class="gi">+                logger.warning(__(&#39;doing serial %s&#39;), typ)</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def set_html_assets_policy(self, policy: Literal[&#39;always&#39;, &#39;per_page&#39;]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set the policy to include assets in HTML pages.

<span class="w"> </span>        - always: include the assets in all the pages
<span class="gu">@@ -1050,7 +1683,9 @@ class Sphinx:</span>

<span class="w"> </span>        .. versionadded: 4.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if policy not in (&#39;always&#39;, &#39;per_page&#39;):</span>
<span class="gi">+            raise ValueError(&#39;policy %s is not supported&#39; % policy)</span>
<span class="gi">+        self.registry.html_assets_policy = policy</span>


<span class="w"> </span>class TemplateBridge:
<span class="gu">@@ -1059,8 +1694,12 @@ class TemplateBridge:</span>
<span class="w"> </span>    that renders templates given a template name and a context.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def init(self, builder: Builder, theme: (Theme | None)=None, dirs: (</span>
<span class="gd">-        list[str] | None)=None) -&gt;None:</span>
<span class="gi">+    def init(</span>
<span class="gi">+        self,</span>
<span class="gi">+        builder: Builder,</span>
<span class="gi">+        theme: Theme | None = None,</span>
<span class="gi">+        dirs: list[str] | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called by the builder to initialize the template system.

<span class="w"> </span>        *builder* is the builder object; you&#39;ll probably want to look at the
<span class="gu">@@ -1069,23 +1708,26 @@ class TemplateBridge:</span>
<span class="w"> </span>        *theme* is a :class:`sphinx.theming.Theme` object or None; in the latter
<span class="w"> </span>        case, *dirs* can be list of fixed directories to look for templates.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        msg = &#39;must be implemented in subclasses&#39;</span>
<span class="gi">+        raise NotImplementedError(msg)</span>

<span class="gd">-    def newest_template_mtime(self) -&gt;float:</span>
<span class="gi">+    def newest_template_mtime(self) -&gt; float:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called by the builder to determine if output files are outdated
<span class="w"> </span>        because of template changes.  Return the mtime of the newest template
<span class="w"> </span>        file that was changed.  The default implementation returns ``0``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return 0</span>

<span class="gd">-    def render(self, template: str, context: dict) -&gt;None:</span>
<span class="gi">+    def render(self, template: str, context: dict) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called by the builder to render a template given as a filename with
<span class="w"> </span>        a specified context (a Python dictionary).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        msg = &#39;must be implemented in subclasses&#39;</span>
<span class="gi">+        raise NotImplementedError(msg)</span>

<span class="gd">-    def render_string(self, template: str, context: dict) -&gt;str:</span>
<span class="gi">+    def render_string(self, template: str, context: dict) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called by the builder to render a template given as a string with a
<span class="w"> </span>        specified context (a Python dictionary).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        msg = &#39;must be implemented in subclasses&#39;</span>
<span class="gi">+        raise NotImplementedError(msg)</span>
<span class="gh">diff --git a/sphinx/builders/_epub_base.py b/sphinx/builders/_epub_base.py</span>
<span class="gh">index aa543c3e3..15c4bd80b 100644</span>
<span class="gd">--- a/sphinx/builders/_epub_base.py</span>
<span class="gi">+++ b/sphinx/builders/_epub_base.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Base class of epub2/epub3 builders.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import html
<span class="w"> </span>import os
<span class="w"> </span>import re
<span class="gu">@@ -8,8 +10,10 @@ from os import path</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any, NamedTuple
<span class="w"> </span>from urllib.parse import quote
<span class="w"> </span>from zipfile import ZIP_DEFLATED, ZIP_STORED, ZipFile
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.utils import smartquotes
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.builders.html import StandaloneHTMLBuilder
<span class="w"> </span>from sphinx.builders.html._build_info import BuildInfo
<span class="gu">@@ -18,27 +22,64 @@ from sphinx.util import logging</span>
<span class="w"> </span>from sphinx.util.display import status_iterator
<span class="w"> </span>from sphinx.util.fileutil import copy_asset_file
<span class="w"> </span>from sphinx.util.osutil import copyfile, ensuredir, relpath
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.nodes import Element, Node
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    from PIL import Image
<span class="w"> </span>    PILLOW_AVAILABLE = True
<span class="w"> </span>except ImportError:
<span class="w"> </span>    PILLOW_AVAILABLE = False
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# (Fragment) templates from which the metainfo files content.opf and</span>
<span class="gi">+# toc.ncx are created.</span>
<span class="gi">+# This template section also defines strings that are embedded in the html</span>
<span class="gi">+# output but that may be customized by (re-)setting module attributes,</span>
<span class="gi">+# e.g. from conf.py.</span>
<span class="gi">+</span>
<span class="w"> </span>COVERPAGE_NAME = &#39;epub-cover.xhtml&#39;
<span class="gi">+</span>
<span class="w"> </span>TOCTREE_TEMPLATE = &#39;toctree-l%d&#39;
<span class="gi">+</span>
<span class="w"> </span>LINK_TARGET_TEMPLATE = &#39; [%(uri)s]&#39;
<span class="gi">+</span>
<span class="w"> </span>FOOTNOTE_LABEL_TEMPLATE = &#39;#%d&#39;
<span class="gi">+</span>
<span class="w"> </span>FOOTNOTES_RUBRIC_NAME = &#39;Footnotes&#39;
<span class="gi">+</span>
<span class="w"> </span>CSS_LINK_TARGET_CLASS = &#39;link-target&#39;
<span class="gd">-GUIDE_TITLES = {&#39;toc&#39;: &#39;Table of Contents&#39;, &#39;cover&#39;: &#39;Cover&#39;}</span>
<span class="gd">-MEDIA_TYPES = {&#39;.xhtml&#39;: &#39;application/xhtml+xml&#39;, &#39;.css&#39;: &#39;text/css&#39;,</span>
<span class="gd">-    &#39;.png&#39;: &#39;image/png&#39;, &#39;.webp&#39;: &#39;image/webp&#39;, &#39;.gif&#39;: &#39;image/gif&#39;, &#39;.svg&#39;:</span>
<span class="gd">-    &#39;image/svg+xml&#39;, &#39;.jpg&#39;: &#39;image/jpeg&#39;, &#39;.jpeg&#39;: &#39;image/jpeg&#39;, &#39;.otf&#39;:</span>
<span class="gd">-    &#39;font/otf&#39;, &#39;.ttf&#39;: &#39;font/ttf&#39;, &#39;.woff&#39;: &#39;font/woff&#39;}</span>
<span class="gd">-VECTOR_GRAPHICS_EXTENSIONS = &#39;.svg&#39;,</span>
<span class="gd">-REFURI_RE = re.compile(&#39;([^#:]*#)(.*)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+# XXX These strings should be localized according to epub_language</span>
<span class="gi">+GUIDE_TITLES = {</span>
<span class="gi">+    &#39;toc&#39;: &#39;Table of Contents&#39;,</span>
<span class="gi">+    &#39;cover&#39;: &#39;Cover&#39;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+MEDIA_TYPES = {</span>
<span class="gi">+    &#39;.xhtml&#39;: &#39;application/xhtml+xml&#39;,</span>
<span class="gi">+    &#39;.css&#39;: &#39;text/css&#39;,</span>
<span class="gi">+    &#39;.png&#39;: &#39;image/png&#39;,</span>
<span class="gi">+    &#39;.webp&#39;: &#39;image/webp&#39;,</span>
<span class="gi">+    &#39;.gif&#39;: &#39;image/gif&#39;,</span>
<span class="gi">+    &#39;.svg&#39;: &#39;image/svg+xml&#39;,</span>
<span class="gi">+    &#39;.jpg&#39;: &#39;image/jpeg&#39;,</span>
<span class="gi">+    &#39;.jpeg&#39;: &#39;image/jpeg&#39;,</span>
<span class="gi">+    &#39;.otf&#39;: &#39;font/otf&#39;,</span>
<span class="gi">+    &#39;.ttf&#39;: &#39;font/ttf&#39;,</span>
<span class="gi">+    &#39;.woff&#39;: &#39;font/woff&#39;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+VECTOR_GRAPHICS_EXTENSIONS = (&#39;.svg&#39;,)</span>
<span class="gi">+</span>
<span class="gi">+# Regular expression to match colons only in local fragment identifiers.</span>
<span class="gi">+# If the URI contains a colon before the #,</span>
<span class="gi">+# it is an external link that should not change.</span>
<span class="gi">+REFURI_RE = re.compile(&quot;([^#:]*#)(.*)&quot;)</span>


<span class="w"> </span>class ManifestItem(NamedTuple):
<span class="gu">@@ -66,9 +107,19 @@ class NavPoint(NamedTuple):</span>
<span class="w"> </span>    children: list[NavPoint]


<span class="gi">+def sphinx_smarty_pants(t: str, language: str = &#39;en&#39;) -&gt; str:</span>
<span class="gi">+    t = t.replace(&#39;&amp;quot;&#39;, &#39;&quot;&#39;)</span>
<span class="gi">+    t = smartquotes.educateDashesOldSchool(t)  # type: ignore[no-untyped-call]</span>
<span class="gi">+    t = smartquotes.educateQuotes(t, language)  # type: ignore[no-untyped-call]</span>
<span class="gi">+    t = t.replace(&#39;&quot;&#39;, &#39;&amp;quot;&#39;)</span>
<span class="gi">+    return t</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>ssp = sphinx_smarty_pants


<span class="gi">+# The epub publisher</span>
<span class="gi">+</span>
<span class="w"> </span>class EpubBuilder(StandaloneHTMLBuilder):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Builder that outputs epub files.
<span class="gu">@@ -77,16 +128,26 @@ class EpubBuilder(StandaloneHTMLBuilder):</span>
<span class="w"> </span>    META-INF/container.xml.  Afterwards, all necessary files are zipped to an
<span class="w"> </span>    epub file.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # don&#39;t copy the reST source</span>
<span class="w"> </span>    copysource = False
<span class="w"> </span>    supported_image_types = [&#39;image/svg+xml&#39;, &#39;image/png&#39;, &#39;image/gif&#39;,
<span class="gd">-        &#39;image/jpeg&#39;]</span>
<span class="gi">+                             &#39;image/jpeg&#39;]</span>
<span class="w"> </span>    supported_remote_images = False
<span class="gi">+</span>
<span class="gi">+    # don&#39;t add links</span>
<span class="w"> </span>    add_permalinks = False
<span class="gi">+    # don&#39;t use # as current path. ePub check reject it.</span>
<span class="w"> </span>    allow_sharp_as_current_path = False
<span class="gi">+    # don&#39;t add sidebar etc.</span>
<span class="w"> </span>    embedded = True
<span class="gi">+    # disable download role</span>
<span class="w"> </span>    download_support = False
<span class="gi">+    # don&#39;t create links to original images from images</span>
<span class="w"> </span>    html_scaled_image_link = False
<span class="gi">+    # don&#39;t generate search index or include search page</span>
<span class="w"> </span>    search = False
<span class="gi">+</span>
<span class="w"> </span>    coverpage_name = COVERPAGE_NAME
<span class="w"> </span>    toctree_template = TOCTREE_TEMPLATE
<span class="w"> </span>    link_target_template = LINK_TARGET_TEMPLATE
<span class="gu">@@ -94,134 +155,592 @@ class EpubBuilder(StandaloneHTMLBuilder):</span>
<span class="w"> </span>    guide_titles = GUIDE_TITLES
<span class="w"> </span>    media_types = MEDIA_TYPES
<span class="w"> </span>    refuri_re = REFURI_RE
<span class="gd">-    template_dir = &#39;&#39;</span>
<span class="gd">-    doctype = &#39;&#39;</span>
<span class="gd">-</span>
<span class="gd">-    def make_id(self, name: str) -&gt;str:</span>
<span class="gi">+    template_dir = &quot;&quot;</span>
<span class="gi">+    doctype = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def init(self) -&gt; None:</span>
<span class="gi">+        super().init()</span>
<span class="gi">+        # the output files for epub must be .html only</span>
<span class="gi">+        self.out_suffix = &#39;.xhtml&#39;</span>
<span class="gi">+        self.link_suffix = &#39;.xhtml&#39;</span>
<span class="gi">+        self.playorder = 0</span>
<span class="gi">+        self.tocid = 0</span>
<span class="gi">+        self.id_cache: dict[str, str] = {}</span>
<span class="gi">+        self.use_index = self.get_builder_config(&#39;use_index&#39;, &#39;epub&#39;)</span>
<span class="gi">+        self.refnodes: list[dict[str, Any]] = []</span>
<span class="gi">+</span>
<span class="gi">+    def create_build_info(self) -&gt; BuildInfo:</span>
<span class="gi">+        return BuildInfo(self.config, self.tags, frozenset({&#39;html&#39;, &#39;epub&#39;}))</span>
<span class="gi">+</span>
<span class="gi">+    def get_theme_config(self) -&gt; tuple[str, dict[str, str | int | bool]]:</span>
<span class="gi">+        return self.config.epub_theme, self.config.epub_theme_options</span>
<span class="gi">+</span>
<span class="gi">+    # generic support functions</span>
<span class="gi">+    def make_id(self, name: str) -&gt; str:</span>
<span class="gi">+        # id_cache is intentionally mutable</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a unique id for name.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_refnodes(self, doctree: Node, result: list[dict[str, Any]]) -&gt;list[</span>
<span class="gd">-        dict[str, Any]]:</span>
<span class="gi">+        id = self.id_cache.get(name)</span>
<span class="gi">+        if not id:</span>
<span class="gi">+            id = &#39;epub-%d&#39; % self.env.new_serialno(&#39;epub&#39;)</span>
<span class="gi">+            self.id_cache[name] = id</span>
<span class="gi">+        return id</span>
<span class="gi">+</span>
<span class="gi">+    def get_refnodes(</span>
<span class="gi">+        self, doctree: Node, result: list[dict[str, Any]],</span>
<span class="gi">+    ) -&gt; list[dict[str, Any]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Collect section titles, their depth in the toc and the refuri.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_toc(self) -&gt;None:</span>
<span class="gi">+        # XXX: is there a better way than checking the attribute</span>
<span class="gi">+        # toctree-l[1-8] on the parent node?</span>
<span class="gi">+        if isinstance(doctree, nodes.reference) and doctree.get(&#39;refuri&#39;):</span>
<span class="gi">+            refuri = doctree[&#39;refuri&#39;]</span>
<span class="gi">+            if refuri.startswith((&#39;http://&#39;, &#39;https://&#39;, &#39;irc:&#39;, &#39;mailto:&#39;)):</span>
<span class="gi">+                return result</span>
<span class="gi">+            classes = doctree.parent.attributes[&#39;classes&#39;]</span>
<span class="gi">+            for level in range(8, 0, -1):  # or range(1, 8)?</span>
<span class="gi">+                if (self.toctree_template % level) in classes:</span>
<span class="gi">+                    result.append({</span>
<span class="gi">+                        &#39;level&#39;: level,</span>
<span class="gi">+                        &#39;refuri&#39;: html.escape(refuri),</span>
<span class="gi">+                        &#39;text&#39;: ssp(html.escape(doctree.astext())),</span>
<span class="gi">+                    })</span>
<span class="gi">+                    break</span>
<span class="gi">+        elif isinstance(doctree, nodes.Element):</span>
<span class="gi">+            for elem in doctree:</span>
<span class="gi">+                result = self.get_refnodes(elem, result)</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def check_refnodes(self, nodes: list[dict[str, Any]]) -&gt; None:</span>
<span class="gi">+        appeared: set[str] = set()</span>
<span class="gi">+        for node in nodes:</span>
<span class="gi">+            if node[&#39;refuri&#39;] in appeared:</span>
<span class="gi">+                logger.warning(</span>
<span class="gi">+                    __(&#39;duplicated ToC entry found: %s&#39;),</span>
<span class="gi">+                    node[&#39;refuri&#39;],</span>
<span class="gi">+                    type=&quot;epub&quot;,</span>
<span class="gi">+                    subtype=&quot;duplicated_toc_entry&quot;,</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                appeared.add(node[&#39;refuri&#39;])</span>
<span class="gi">+</span>
<span class="gi">+    def get_toc(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the total table of contents, containing the root_doc
<span class="w"> </span>        and pre and post files not managed by sphinx.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def toc_add_files(self, refnodes: list[dict[str, Any]]) -&gt;None:</span>
<span class="gi">+        doctree = self.env.get_and_resolve_doctree(self.config.root_doc,</span>
<span class="gi">+                                                   self, prune_toctrees=False,</span>
<span class="gi">+                                                   includehidden=True)</span>
<span class="gi">+        self.refnodes = self.get_refnodes(doctree, [])</span>
<span class="gi">+        master_dir = path.dirname(self.config.root_doc)</span>
<span class="gi">+        if master_dir:</span>
<span class="gi">+            master_dir += &#39;/&#39;  # XXX or os.sep?</span>
<span class="gi">+            for item in self.refnodes:</span>
<span class="gi">+                item[&#39;refuri&#39;] = master_dir + item[&#39;refuri&#39;]</span>
<span class="gi">+        self.toc_add_files(self.refnodes)</span>
<span class="gi">+</span>
<span class="gi">+    def toc_add_files(self, refnodes: list[dict[str, Any]]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add the root_doc, pre and post files to a list of refnodes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def fix_fragment(self, prefix: str, fragment: str) -&gt;str:</span>
<span class="gi">+        refnodes.insert(0, {</span>
<span class="gi">+            &#39;level&#39;: 1,</span>
<span class="gi">+            &#39;refuri&#39;: html.escape(self.config.root_doc + self.out_suffix),</span>
<span class="gi">+            &#39;text&#39;: ssp(html.escape(</span>
<span class="gi">+                self.env.titles[self.config.root_doc].astext())),</span>
<span class="gi">+        })</span>
<span class="gi">+        for file, text in reversed(self.config.epub_pre_files):</span>
<span class="gi">+            refnodes.insert(0, {</span>
<span class="gi">+                &#39;level&#39;: 1,</span>
<span class="gi">+                &#39;refuri&#39;: html.escape(file),</span>
<span class="gi">+                &#39;text&#39;: ssp(html.escape(text)),</span>
<span class="gi">+            })</span>
<span class="gi">+        for file, text in self.config.epub_post_files:</span>
<span class="gi">+            refnodes.append({</span>
<span class="gi">+                &#39;level&#39;: 1,</span>
<span class="gi">+                &#39;refuri&#39;: html.escape(file),</span>
<span class="gi">+                &#39;text&#39;: ssp(html.escape(text)),</span>
<span class="gi">+            })</span>
<span class="gi">+</span>
<span class="gi">+    def fix_fragment(self, prefix: str, fragment: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a href/id attribute with colons replaced by hyphens.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return prefix + fragment.replace(&#39;:&#39;, &#39;-&#39;)</span>

<span class="gd">-    def fix_ids(self, tree: nodes.document) -&gt;None:</span>
<span class="gi">+    def fix_ids(self, tree: nodes.document) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Replace colons with hyphens in href and id attributes.

<span class="w"> </span>        Some readers crash because they interpret the part as a
<span class="w"> </span>        transport protocol specification.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def add_visible_links(self, tree: nodes.document, show_urls: str=&#39;inline&#39;</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+        def update_node_id(node: Element) -&gt; None:</span>
<span class="gi">+            &quot;&quot;&quot;Update IDs of given *node*.&quot;&quot;&quot;</span>
<span class="gi">+            new_ids: list[str] = []</span>
<span class="gi">+            for node_id in node[&#39;ids&#39;]:</span>
<span class="gi">+                new_id = self.fix_fragment(&#39;&#39;, node_id)</span>
<span class="gi">+                if new_id not in new_ids:</span>
<span class="gi">+                    new_ids.append(new_id)</span>
<span class="gi">+            node[&#39;ids&#39;] = new_ids</span>
<span class="gi">+</span>
<span class="gi">+        for reference in tree.findall(nodes.reference):</span>
<span class="gi">+            if &#39;refuri&#39; in reference:</span>
<span class="gi">+                m = self.refuri_re.match(reference[&#39;refuri&#39;])</span>
<span class="gi">+                if m:</span>
<span class="gi">+                    reference[&#39;refuri&#39;] = self.fix_fragment(m.group(1), m.group(2))</span>
<span class="gi">+            if &#39;refid&#39; in reference:</span>
<span class="gi">+                reference[&#39;refid&#39;] = self.fix_fragment(&#39;&#39;, reference[&#39;refid&#39;])</span>
<span class="gi">+</span>
<span class="gi">+        for target in tree.findall(nodes.target):</span>
<span class="gi">+            update_node_id(target)</span>
<span class="gi">+</span>
<span class="gi">+            next_node: Node = target.next_node(ascend=True)</span>
<span class="gi">+            if isinstance(next_node, nodes.Element):</span>
<span class="gi">+                update_node_id(next_node)</span>
<span class="gi">+</span>
<span class="gi">+        for desc_signature in tree.findall(addnodes.desc_signature):</span>
<span class="gi">+            update_node_id(desc_signature)</span>
<span class="gi">+</span>
<span class="gi">+    def add_visible_links(self, tree: nodes.document, show_urls: str = &#39;inline&#39;) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add visible link targets for external links&quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def write_doc(self, docname: str, doctree: nodes.document) -&gt;None:</span>
<span class="gi">+        def make_footnote_ref(doc: nodes.document, label: str) -&gt; nodes.footnote_reference:</span>
<span class="gi">+            &quot;&quot;&quot;Create a footnote_reference node with children&quot;&quot;&quot;</span>
<span class="gi">+            footnote_ref = nodes.footnote_reference(&#39;[#]_&#39;)</span>
<span class="gi">+            footnote_ref.append(nodes.Text(label))</span>
<span class="gi">+            doc.note_autofootnote_ref(footnote_ref)</span>
<span class="gi">+            return footnote_ref</span>
<span class="gi">+</span>
<span class="gi">+        def make_footnote(doc: nodes.document, label: str, uri: str) -&gt; nodes.footnote:</span>
<span class="gi">+            &quot;&quot;&quot;Create a footnote node with children&quot;&quot;&quot;</span>
<span class="gi">+            footnote = nodes.footnote(uri)</span>
<span class="gi">+            para = nodes.paragraph()</span>
<span class="gi">+            para.append(nodes.Text(uri))</span>
<span class="gi">+            footnote.append(para)</span>
<span class="gi">+            footnote.insert(0, nodes.label(&#39;&#39;, label))</span>
<span class="gi">+            doc.note_autofootnote(footnote)</span>
<span class="gi">+            return footnote</span>
<span class="gi">+</span>
<span class="gi">+        def footnote_spot(tree: nodes.document) -&gt; tuple[Element, int]:</span>
<span class="gi">+            &quot;&quot;&quot;Find or create a spot to place footnotes.</span>
<span class="gi">+</span>
<span class="gi">+            The function returns the tuple (parent, index).</span>
<span class="gi">+            &quot;&quot;&quot;</span>
<span class="gi">+            # The code uses the following heuristic:</span>
<span class="gi">+            # a) place them after the last existing footnote</span>
<span class="gi">+            # b) place them after an (empty) Footnotes rubric</span>
<span class="gi">+            # c) create an empty Footnotes rubric at the end of the document</span>
<span class="gi">+            fns = list(tree.findall(nodes.footnote))</span>
<span class="gi">+            if fns:</span>
<span class="gi">+                fn = fns[-1]</span>
<span class="gi">+                return fn.parent, fn.parent.index(fn) + 1</span>
<span class="gi">+            for node in tree.findall(nodes.rubric):</span>
<span class="gi">+                if len(node) == 1 and node.astext() == FOOTNOTES_RUBRIC_NAME:</span>
<span class="gi">+                    return node.parent, node.parent.index(node) + 1</span>
<span class="gi">+            doc = next(tree.findall(nodes.document))</span>
<span class="gi">+            rub = nodes.rubric()</span>
<span class="gi">+            rub.append(nodes.Text(FOOTNOTES_RUBRIC_NAME))</span>
<span class="gi">+            doc.append(rub)</span>
<span class="gi">+            return doc, doc.index(rub) + 1</span>
<span class="gi">+</span>
<span class="gi">+        if show_urls == &#39;no&#39;:</span>
<span class="gi">+            return</span>
<span class="gi">+        if show_urls == &#39;footnote&#39;:</span>
<span class="gi">+            doc = next(tree.findall(nodes.document))</span>
<span class="gi">+            fn_spot, fn_idx = footnote_spot(tree)</span>
<span class="gi">+            nr = 1</span>
<span class="gi">+        for node in list(tree.findall(nodes.reference)):</span>
<span class="gi">+            uri = node.get(&#39;refuri&#39;, &#39;&#39;)</span>
<span class="gi">+            if uri.startswith((&#39;http:&#39;, &#39;https:&#39;, &#39;ftp:&#39;)) and uri not in node.astext():</span>
<span class="gi">+                idx = node.parent.index(node) + 1</span>
<span class="gi">+                if show_urls == &#39;inline&#39;:</span>
<span class="gi">+                    uri = self.link_target_template % {&#39;uri&#39;: uri}</span>
<span class="gi">+                    link = nodes.inline(uri, uri)</span>
<span class="gi">+                    link[&#39;classes&#39;].append(self.css_link_target_class)</span>
<span class="gi">+                    node.parent.insert(idx, link)</span>
<span class="gi">+                elif show_urls == &#39;footnote&#39;:</span>
<span class="gi">+                    label = FOOTNOTE_LABEL_TEMPLATE % nr</span>
<span class="gi">+                    nr += 1</span>
<span class="gi">+                    footnote_ref = make_footnote_ref(doc, label)</span>
<span class="gi">+                    node.parent.insert(idx, footnote_ref)</span>
<span class="gi">+                    footnote = make_footnote(doc, label, uri)</span>
<span class="gi">+                    fn_spot.insert(fn_idx, footnote)</span>
<span class="gi">+                    footnote_ref[&#39;refid&#39;] = footnote[&#39;ids&#39;][0]</span>
<span class="gi">+                    footnote.add_backref(footnote_ref[&#39;ids&#39;][0])</span>
<span class="gi">+                    fn_idx += 1</span>
<span class="gi">+</span>
<span class="gi">+    def write_doc(self, docname: str, doctree: nodes.document) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write one document file.

<span class="w"> </span>        This method is overwritten in order to fix fragment identifiers
<span class="w"> </span>        and to add visible external links.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.fix_ids(doctree)</span>
<span class="gi">+        self.add_visible_links(doctree, self.config.epub_show_urls)</span>
<span class="gi">+        super().write_doc(docname, doctree)</span>

<span class="gd">-    def fix_genindex(self, tree: list[tuple[str, list[tuple[str, Any]]]]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def fix_genindex(self, tree: list[tuple[str, list[tuple[str, Any]]]]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Fix href attributes for genindex pages.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def is_vector_graphics(self, filename: str) -&gt;bool:</span>
<span class="gi">+        # XXX: modifies tree inline</span>
<span class="gi">+        # Logic modeled from themes/basic/genindex.html</span>
<span class="gi">+        for _key, columns in tree:</span>
<span class="gi">+            for _entryname, (links, subitems, _key) in columns:</span>
<span class="gi">+                for (i, (ismain, link)) in enumerate(links):</span>
<span class="gi">+                    m = self.refuri_re.match(link)</span>
<span class="gi">+                    if m:</span>
<span class="gi">+                        links[i] = (ismain,</span>
<span class="gi">+                                    self.fix_fragment(m.group(1), m.group(2)))</span>
<span class="gi">+                for _subentryname, subentrylinks in subitems:</span>
<span class="gi">+                    for (i, (ismain, link)) in enumerate(subentrylinks):</span>
<span class="gi">+                        m = self.refuri_re.match(link)</span>
<span class="gi">+                        if m:</span>
<span class="gi">+                            subentrylinks[i] = (ismain,</span>
<span class="gi">+                                                self.fix_fragment(m.group(1), m.group(2)))</span>
<span class="gi">+</span>
<span class="gi">+    def is_vector_graphics(self, filename: str) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Does the filename extension indicate a vector graphic format?&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ext = path.splitext(filename)[-1]</span>
<span class="gi">+        return ext in VECTOR_GRAPHICS_EXTENSIONS</span>

<span class="gd">-    def copy_image_files_pil(self) -&gt;None:</span>
<span class="gi">+    def copy_image_files_pil(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Copy images using Pillow, the Python Imaging Library.
<span class="w"> </span>        The method tries to read and write the files with Pillow, converting
<span class="w"> </span>        the format and resizing the image if necessary/possible.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def copy_image_files(self) -&gt;None:</span>
<span class="gi">+        ensuredir(path.join(self.outdir, self.imagedir))</span>
<span class="gi">+        for src in status_iterator(self.images, __(&#39;copying images... &#39;), &quot;brown&quot;,</span>
<span class="gi">+                                   len(self.images), self.app.verbosity):</span>
<span class="gi">+            dest = self.images[src]</span>
<span class="gi">+            try:</span>
<span class="gi">+                img = Image.open(path.join(self.srcdir, src))</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                if not self.is_vector_graphics(src):</span>
<span class="gi">+                    logger.warning(__(&#39;cannot read image file %r: copying it instead&#39;),</span>
<span class="gi">+                                   path.join(self.srcdir, src))</span>
<span class="gi">+                try:</span>
<span class="gi">+                    copyfile(</span>
<span class="gi">+                        self.srcdir / src,</span>
<span class="gi">+                        self.outdir / self.imagedir / dest,</span>
<span class="gi">+                        force=True,</span>
<span class="gi">+                    )</span>
<span class="gi">+                except OSError as err:</span>
<span class="gi">+                    logger.warning(__(&#39;cannot copy image file %r: %s&#39;),</span>
<span class="gi">+                                   path.join(self.srcdir, src), err)</span>
<span class="gi">+                continue</span>
<span class="gi">+            if self.config.epub_fix_images:</span>
<span class="gi">+                if img.mode == &#39;P&#39;:</span>
<span class="gi">+                    # See the Pillow documentation for Image.convert()</span>
<span class="gi">+                    # https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.convert</span>
<span class="gi">+                    img = img.convert()</span>
<span class="gi">+            if self.config.epub_max_image_width &gt; 0:</span>
<span class="gi">+                (width, height) = img.size</span>
<span class="gi">+                nw = self.config.epub_max_image_width</span>
<span class="gi">+                if width &gt; nw:</span>
<span class="gi">+                    nh = round((height * nw) / width)</span>
<span class="gi">+                    img = img.resize((nw, nh), Image.BICUBIC)</span>
<span class="gi">+            try:</span>
<span class="gi">+                img.save(path.join(self.outdir, self.imagedir, dest))</span>
<span class="gi">+            except OSError as err:</span>
<span class="gi">+                logger.warning(__(&#39;cannot write image file %r: %s&#39;),</span>
<span class="gi">+                               path.join(self.srcdir, src), err)</span>
<span class="gi">+</span>
<span class="gi">+    def copy_image_files(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Copy image files to destination directory.
<span class="w"> </span>        This overwritten method can use Pillow to convert image files.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        if self.images:</span>
<span class="gi">+            if self.config.epub_fix_images or self.config.epub_max_image_width:</span>
<span class="gi">+                if not PILLOW_AVAILABLE:</span>
<span class="gi">+                    logger.warning(__(&#39;Pillow not found - copying image files&#39;))</span>
<span class="gi">+                    super().copy_image_files()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.copy_image_files_pil()</span>
<span class="gi">+            else:</span>
<span class="gi">+                super().copy_image_files()</span>
<span class="gi">+</span>
<span class="gi">+    def copy_download_files(self) -&gt; None:</span>
<span class="w"> </span>        pass

<span class="gd">-    def handle_page(self, pagename: str, addctx: dict[str, Any],</span>
<span class="gd">-        templatename: str=&#39;page.html&#39;, outfilename: (str | None)=None,</span>
<span class="gd">-        event_arg: Any=None) -&gt;None:</span>
<span class="gi">+    def handle_page(</span>
<span class="gi">+        self,</span>
<span class="gi">+        pagename: str,</span>
<span class="gi">+        addctx: dict[str, Any],</span>
<span class="gi">+        templatename: str = &#39;page.html&#39;,</span>
<span class="gi">+        outfilename: str | None = None,</span>
<span class="gi">+        event_arg: Any = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a rendered page.

<span class="w"> </span>        This method is overwritten for genindex pages in order to fix href link
<span class="w"> </span>        attributes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def build_mimetype(self) -&gt;None:</span>
<span class="gi">+        if pagename.startswith(&#39;genindex&#39;) and &#39;genindexentries&#39; in addctx:</span>
<span class="gi">+            if not self.use_index:</span>
<span class="gi">+                return</span>
<span class="gi">+            self.fix_genindex(addctx[&#39;genindexentries&#39;])</span>
<span class="gi">+        addctx[&#39;doctype&#39;] = self.doctype</span>
<span class="gi">+        super().handle_page(pagename, addctx, templatename, outfilename, event_arg)</span>
<span class="gi">+</span>
<span class="gi">+    def build_mimetype(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write the metainfo file mimetype.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def build_container(self, outname: str=&#39;META-INF/container.xml&#39;) -&gt;None:</span>
<span class="gi">+        logger.info(__(&#39;writing mimetype file...&#39;))</span>
<span class="gi">+        copyfile(</span>
<span class="gi">+            path.join(self.template_dir, &#39;mimetype&#39;),</span>
<span class="gi">+            self.outdir / &#39;mimetype&#39;,</span>
<span class="gi">+            force=True,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def build_container(self, outname: str = &#39;META-INF/container.xml&#39;) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write the metainfo file META-INF/container.xml.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def content_metadata(self) -&gt;dict[str, Any]:</span>
<span class="gi">+        logger.info(__(&#39;writing META-INF/container.xml file...&#39;))</span>
<span class="gi">+        outdir = self.outdir / &#39;META-INF&#39;</span>
<span class="gi">+        ensuredir(outdir)</span>
<span class="gi">+        copyfile(</span>
<span class="gi">+            path.join(self.template_dir, &#39;container.xml&#39;),</span>
<span class="gi">+            outdir / &#39;container.xml&#39;,</span>
<span class="gi">+            force=True,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def content_metadata(self) -&gt; dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a dictionary with all metadata for the content.opf
<span class="w"> </span>        file properly escaped.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def build_content(self) -&gt;None:</span>
<span class="gi">+        if (source_date_epoch := os.getenv(&#39;SOURCE_DATE_EPOCH&#39;)) is not None:</span>
<span class="gi">+            time_tuple = time.gmtime(int(source_date_epoch))</span>
<span class="gi">+        else:</span>
<span class="gi">+            time_tuple = time.gmtime()</span>
<span class="gi">+</span>
<span class="gi">+        metadata: dict[str, Any] = {}</span>
<span class="gi">+        metadata[&#39;title&#39;] = html.escape(self.config.epub_title)</span>
<span class="gi">+        metadata[&#39;author&#39;] = html.escape(self.config.epub_author)</span>
<span class="gi">+        metadata[&#39;uid&#39;] = html.escape(self.config.epub_uid)</span>
<span class="gi">+        metadata[&#39;lang&#39;] = html.escape(self.config.epub_language)</span>
<span class="gi">+        metadata[&#39;publisher&#39;] = html.escape(self.config.epub_publisher)</span>
<span class="gi">+        metadata[&#39;copyright&#39;] = html.escape(self.config.epub_copyright)</span>
<span class="gi">+        metadata[&#39;scheme&#39;] = html.escape(self.config.epub_scheme)</span>
<span class="gi">+        metadata[&#39;id&#39;] = html.escape(self.config.epub_identifier)</span>
<span class="gi">+        metadata[&#39;date&#39;] = html.escape(time.strftime(&#39;%Y-%m-%d&#39;, time_tuple))</span>
<span class="gi">+        metadata[&#39;manifest_items&#39;] = []</span>
<span class="gi">+        metadata[&#39;spines&#39;] = []</span>
<span class="gi">+        metadata[&#39;guides&#39;] = []</span>
<span class="gi">+        return metadata</span>
<span class="gi">+</span>
<span class="gi">+    def build_content(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write the metainfo file content.opf It contains bibliographic data,
<span class="w"> </span>        a file list and the spine (the reading order).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def new_navpoint(self, node: dict[str, Any], level: int, incr: bool=True</span>
<span class="gd">-        ) -&gt;NavPoint:</span>
<span class="gi">+        logger.info(__(&#39;writing content.opf file...&#39;))</span>
<span class="gi">+        metadata = self.content_metadata()</span>
<span class="gi">+</span>
<span class="gi">+        # files</span>
<span class="gi">+        self.files: list[str] = []</span>
<span class="gi">+        self.ignored_files = [</span>
<span class="gi">+            &#39;.buildinfo&#39;,</span>
<span class="gi">+            &#39;mimetype&#39;,</span>
<span class="gi">+            &#39;content.opf&#39;,</span>
<span class="gi">+            &#39;toc.ncx&#39;,</span>
<span class="gi">+            &#39;META-INF/container.xml&#39;,</span>
<span class="gi">+            &#39;Thumbs.db&#39;,</span>
<span class="gi">+            &#39;ehthumbs.db&#39;,</span>
<span class="gi">+            &#39;.DS_Store&#39;,</span>
<span class="gi">+            &#39;nav.xhtml&#39;,</span>
<span class="gi">+            self.config.epub_basename + &#39;.epub&#39;,</span>
<span class="gi">+            *self.config.epub_exclude_files,</span>
<span class="gi">+        ]</span>
<span class="gi">+        if not self.use_index:</span>
<span class="gi">+            self.ignored_files.append(&#39;genindex&#39; + self.out_suffix)</span>
<span class="gi">+        for root, dirs, files in os.walk(self.outdir):</span>
<span class="gi">+            dirs.sort()</span>
<span class="gi">+            for fn in sorted(files):</span>
<span class="gi">+                filename = relpath(path.join(root, fn), self.outdir)</span>
<span class="gi">+                if filename in self.ignored_files:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                ext = path.splitext(filename)[-1]</span>
<span class="gi">+                if ext not in self.media_types:</span>
<span class="gi">+                    # we always have JS and potentially OpenSearch files, don&#39;t</span>
<span class="gi">+                    # always warn about them</span>
<span class="gi">+                    if ext not in (&#39;.js&#39;, &#39;.xml&#39;):</span>
<span class="gi">+                        logger.warning(__(&#39;unknown mimetype for %s, ignoring&#39;), filename,</span>
<span class="gi">+                                       type=&#39;epub&#39;, subtype=&#39;unknown_project_files&#39;)</span>
<span class="gi">+                    continue</span>
<span class="gi">+                filename = filename.replace(os.sep, &#39;/&#39;)</span>
<span class="gi">+                item = ManifestItem(html.escape(quote(filename)),</span>
<span class="gi">+                                    html.escape(self.make_id(filename)),</span>
<span class="gi">+                                    html.escape(self.media_types[ext]))</span>
<span class="gi">+                metadata[&#39;manifest_items&#39;].append(item)</span>
<span class="gi">+                self.files.append(filename)</span>
<span class="gi">+</span>
<span class="gi">+        # spine</span>
<span class="gi">+        spinefiles = set()</span>
<span class="gi">+        for refnode in self.refnodes:</span>
<span class="gi">+            if &#39;#&#39; in refnode[&#39;refuri&#39;]:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if refnode[&#39;refuri&#39;] in self.ignored_files:</span>
<span class="gi">+                continue</span>
<span class="gi">+            spine = Spine(html.escape(self.make_id(refnode[&#39;refuri&#39;])), True)</span>
<span class="gi">+            metadata[&#39;spines&#39;].append(spine)</span>
<span class="gi">+            spinefiles.add(refnode[&#39;refuri&#39;])</span>
<span class="gi">+        for info in self.domain_indices:</span>
<span class="gi">+            spine = Spine(html.escape(self.make_id(info[0] + self.out_suffix)), True)</span>
<span class="gi">+            metadata[&#39;spines&#39;].append(spine)</span>
<span class="gi">+            spinefiles.add(info[0] + self.out_suffix)</span>
<span class="gi">+        if self.use_index:</span>
<span class="gi">+            spine = Spine(html.escape(self.make_id(&#39;genindex&#39; + self.out_suffix)), True)</span>
<span class="gi">+            metadata[&#39;spines&#39;].append(spine)</span>
<span class="gi">+            spinefiles.add(&#39;genindex&#39; + self.out_suffix)</span>
<span class="gi">+        # add auto generated files</span>
<span class="gi">+        for name in self.files:</span>
<span class="gi">+            if name not in spinefiles and name.endswith(self.out_suffix):</span>
<span class="gi">+                spine = Spine(html.escape(self.make_id(name)), False)</span>
<span class="gi">+                metadata[&#39;spines&#39;].append(spine)</span>
<span class="gi">+</span>
<span class="gi">+        # add the optional cover</span>
<span class="gi">+        html_tmpl = None</span>
<span class="gi">+        if self.config.epub_cover:</span>
<span class="gi">+            image, html_tmpl = self.config.epub_cover</span>
<span class="gi">+            image = image.replace(os.sep, &#39;/&#39;)</span>
<span class="gi">+            metadata[&#39;cover&#39;] = html.escape(self.make_id(image))</span>
<span class="gi">+            if html_tmpl:</span>
<span class="gi">+                spine = Spine(html.escape(self.make_id(self.coverpage_name)), True)</span>
<span class="gi">+                metadata[&#39;spines&#39;].insert(0, spine)</span>
<span class="gi">+                if self.coverpage_name not in self.files:</span>
<span class="gi">+                    ext = path.splitext(self.coverpage_name)[-1]</span>
<span class="gi">+                    self.files.append(self.coverpage_name)</span>
<span class="gi">+                    item = ManifestItem(html.escape(self.coverpage_name),</span>
<span class="gi">+                                        html.escape(self.make_id(self.coverpage_name)),</span>
<span class="gi">+                                        html.escape(self.media_types[ext]))</span>
<span class="gi">+                    metadata[&#39;manifest_items&#39;].append(item)</span>
<span class="gi">+                ctx = {&#39;image&#39;: html.escape(image), &#39;title&#39;: self.config.project}</span>
<span class="gi">+                self.handle_page(</span>
<span class="gi">+                    path.splitext(self.coverpage_name)[0], ctx, html_tmpl)</span>
<span class="gi">+                spinefiles.add(self.coverpage_name)</span>
<span class="gi">+</span>
<span class="gi">+        auto_add_cover = True</span>
<span class="gi">+        auto_add_toc = True</span>
<span class="gi">+        if self.config.epub_guide:</span>
<span class="gi">+            for type, uri, title in self.config.epub_guide:</span>
<span class="gi">+                file = uri.split(&#39;#&#39;)[0]</span>
<span class="gi">+                if file not in self.files:</span>
<span class="gi">+                    self.files.append(file)</span>
<span class="gi">+                if type == &#39;cover&#39;:</span>
<span class="gi">+                    auto_add_cover = False</span>
<span class="gi">+                if type == &#39;toc&#39;:</span>
<span class="gi">+                    auto_add_toc = False</span>
<span class="gi">+                metadata[&#39;guides&#39;].append(Guide(html.escape(type),</span>
<span class="gi">+                                                html.escape(title),</span>
<span class="gi">+                                                html.escape(uri)))</span>
<span class="gi">+        if auto_add_cover and html_tmpl:</span>
<span class="gi">+            metadata[&#39;guides&#39;].append(Guide(&#39;cover&#39;,</span>
<span class="gi">+                                            self.guide_titles[&#39;cover&#39;],</span>
<span class="gi">+                                            html.escape(self.coverpage_name)))</span>
<span class="gi">+        if auto_add_toc and self.refnodes:</span>
<span class="gi">+            metadata[&#39;guides&#39;].append(Guide(&#39;toc&#39;,</span>
<span class="gi">+                                            self.guide_titles[&#39;toc&#39;],</span>
<span class="gi">+                                            html.escape(self.refnodes[0][&#39;refuri&#39;])))</span>
<span class="gi">+</span>
<span class="gi">+        # write the project file</span>
<span class="gi">+        copy_asset_file(</span>
<span class="gi">+            path.join(self.template_dir, &#39;content.opf.jinja&#39;),</span>
<span class="gi">+            self.outdir,</span>
<span class="gi">+            context=metadata,</span>
<span class="gi">+            force=True,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def new_navpoint(self, node: dict[str, Any], level: int, incr: bool = True) -&gt; NavPoint:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a new entry in the toc from the node at given level.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def build_navpoints(self, nodes: list[dict[str, Any]]) -&gt;list[NavPoint]:</span>
<span class="gi">+        # XXX Modifies the node</span>
<span class="gi">+        if incr:</span>
<span class="gi">+            self.playorder += 1</span>
<span class="gi">+        self.tocid += 1</span>
<span class="gi">+        return NavPoint(&#39;navPoint%d&#39; % self.tocid, self.playorder,</span>
<span class="gi">+                        node[&#39;text&#39;], node[&#39;refuri&#39;], [])</span>
<span class="gi">+</span>
<span class="gi">+    def build_navpoints(self, nodes: list[dict[str, Any]]) -&gt; list[NavPoint]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create the toc navigation structure.

<span class="w"> </span>        Subelements of a node are nested inside the navpoint.  For nested nodes
<span class="w"> </span>        the parent node is reinserted in the subnav.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def toc_metadata(self, level: int, navpoints: list[NavPoint]) -&gt;dict[</span>
<span class="gd">-        str, Any]:</span>
<span class="gi">+        navstack: list[NavPoint] = []</span>
<span class="gi">+        navstack.append(NavPoint(&#39;dummy&#39;, 0, &#39;&#39;, &#39;&#39;, []))</span>
<span class="gi">+        level = 0</span>
<span class="gi">+        lastnode = None</span>
<span class="gi">+        for node in nodes:</span>
<span class="gi">+            if not node[&#39;text&#39;]:</span>
<span class="gi">+                continue</span>
<span class="gi">+            file = node[&#39;refuri&#39;].split(&#39;#&#39;)[0]</span>
<span class="gi">+            if file in self.ignored_files:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if node[&#39;level&#39;] &gt; self.config.epub_tocdepth:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if node[&#39;level&#39;] == level:</span>
<span class="gi">+                navpoint = self.new_navpoint(node, level)</span>
<span class="gi">+                navstack.pop()</span>
<span class="gi">+                navstack[-1].children.append(navpoint)</span>
<span class="gi">+                navstack.append(navpoint)</span>
<span class="gi">+            elif node[&#39;level&#39;] == level + 1:</span>
<span class="gi">+                level += 1</span>
<span class="gi">+                if lastnode and self.config.epub_tocdup:</span>
<span class="gi">+                    # Insert starting point in subtoc with same playOrder</span>
<span class="gi">+                    navstack[-1].children.append(self.new_navpoint(lastnode, level, False))</span>
<span class="gi">+                navpoint = self.new_navpoint(node, level)</span>
<span class="gi">+                navstack[-1].children.append(navpoint)</span>
<span class="gi">+                navstack.append(navpoint)</span>
<span class="gi">+            elif node[&#39;level&#39;] &lt; level:</span>
<span class="gi">+                while node[&#39;level&#39;] &lt; len(navstack):</span>
<span class="gi">+                    navstack.pop()</span>
<span class="gi">+                level = node[&#39;level&#39;]</span>
<span class="gi">+                navpoint = self.new_navpoint(node, level)</span>
<span class="gi">+                navstack[-1].children.append(navpoint)</span>
<span class="gi">+                navstack.append(navpoint)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise</span>
<span class="gi">+            lastnode = node</span>
<span class="gi">+</span>
<span class="gi">+        return navstack[0].children</span>
<span class="gi">+</span>
<span class="gi">+    def toc_metadata(self, level: int, navpoints: list[NavPoint]) -&gt; dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a dictionary with all metadata for the toc.ncx file
<span class="w"> </span>        properly escaped.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def build_toc(self) -&gt;None:</span>
<span class="gi">+        metadata: dict[str, Any] = {}</span>
<span class="gi">+        metadata[&#39;uid&#39;] = self.config.epub_uid</span>
<span class="gi">+        metadata[&#39;title&#39;] = html.escape(self.config.epub_title)</span>
<span class="gi">+        metadata[&#39;level&#39;] = level</span>
<span class="gi">+        metadata[&#39;navpoints&#39;] = navpoints</span>
<span class="gi">+        return metadata</span>
<span class="gi">+</span>
<span class="gi">+    def build_toc(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write the metainfo file toc.ncx.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def build_epub(self) -&gt;None:</span>
<span class="gi">+        logger.info(__(&#39;writing toc.ncx file...&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        if self.config.epub_tocscope == &#39;default&#39;:</span>
<span class="gi">+            doctree = self.env.get_and_resolve_doctree(self.config.root_doc,</span>
<span class="gi">+                                                       self, prune_toctrees=False,</span>
<span class="gi">+                                                       includehidden=False)</span>
<span class="gi">+            refnodes = self.get_refnodes(doctree, [])</span>
<span class="gi">+            self.toc_add_files(refnodes)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # &#39;includehidden&#39;</span>
<span class="gi">+            refnodes = self.refnodes</span>
<span class="gi">+        self.check_refnodes(refnodes)</span>
<span class="gi">+        navpoints = self.build_navpoints(refnodes)</span>
<span class="gi">+        level = max(item[&#39;level&#39;] for item in self.refnodes)</span>
<span class="gi">+        level = min(level, self.config.epub_tocdepth)</span>
<span class="gi">+        copy_asset_file(</span>
<span class="gi">+            path.join(self.template_dir, &#39;toc.ncx.jinja&#39;),</span>
<span class="gi">+            self.outdir,</span>
<span class="gi">+            context=self.toc_metadata(level, navpoints),</span>
<span class="gi">+            force=True,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def build_epub(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write the epub file.

<span class="w"> </span>        It is a zip file with the mimetype file stored uncompressed as the first
<span class="w"> </span>        entry.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        outname = self.config.epub_basename + &#39;.epub&#39;</span>
<span class="gi">+        logger.info(__(&#39;writing %s file...&#39;), outname)</span>
<span class="gi">+        epub_filename = path.join(self.outdir, outname)</span>
<span class="gi">+        with ZipFile(epub_filename, &#39;w&#39;, ZIP_DEFLATED) as epub:</span>
<span class="gi">+            epub.write(path.join(self.outdir, &#39;mimetype&#39;), &#39;mimetype&#39;, ZIP_STORED)</span>
<span class="gi">+            for filename in (&#39;META-INF/container.xml&#39;, &#39;content.opf&#39;, &#39;toc.ncx&#39;):</span>
<span class="gi">+                epub.write(path.join(self.outdir, filename), filename, ZIP_DEFLATED)</span>
<span class="gi">+            for filename in self.files:</span>
<span class="gi">+                epub.write(path.join(self.outdir, filename), filename, ZIP_DEFLATED)</span>
<span class="gh">diff --git a/sphinx/builders/changes.py b/sphinx/builders/changes.py</span>
<span class="gh">index 978bdc95a..afc5f064b 100644</span>
<span class="gd">--- a/sphinx/builders/changes.py</span>
<span class="gi">+++ b/sphinx/builders/changes.py</span>
<span class="gu">@@ -1,8 +1,11 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Changelog builder.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import html
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING, Any, cast
<span class="gi">+</span>
<span class="w"> </span>from sphinx import package_dir
<span class="w"> </span>from sphinx.builders import Builder
<span class="w"> </span>from sphinx.domains.changeset import ChangeSetDomain
<span class="gu">@@ -12,9 +15,11 @@ from sphinx.util import logging</span>
<span class="w"> </span>from sphinx.util.console import bold
<span class="w"> </span>from sphinx.util.fileutil import copy_asset_file
<span class="w"> </span>from sphinx.util.osutil import ensuredir, os_path
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="gu">@@ -22,7 +27,148 @@ class ChangesBuilder(Builder):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Write a summary with all versionadded/changed/deprecated/removed directives.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name = &#39;changes&#39;
<span class="w"> </span>    epilog = __(&#39;The overview file is in %(outdir)s.&#39;)
<span class="gd">-    typemap = {&#39;versionadded&#39;: &#39;added&#39;, &#39;versionchanged&#39;: &#39;changed&#39;,</span>
<span class="gd">-        &#39;deprecated&#39;: &#39;deprecated&#39;, &#39;versionremoved&#39;: &#39;removed&#39;}</span>
<span class="gi">+</span>
<span class="gi">+    def init(self) -&gt; None:</span>
<span class="gi">+        self.create_template_bridge()</span>
<span class="gi">+        theme_factory = HTMLThemeFactory(self.app)</span>
<span class="gi">+        self.theme = theme_factory.create(&#39;default&#39;)</span>
<span class="gi">+        self.templates.init(self, self.theme)</span>
<span class="gi">+</span>
<span class="gi">+    def get_outdated_docs(self) -&gt; str:</span>
<span class="gi">+        return str(self.outdir)</span>
<span class="gi">+</span>
<span class="gi">+    typemap = {</span>
<span class="gi">+        &#39;versionadded&#39;: &#39;added&#39;,</span>
<span class="gi">+        &#39;versionchanged&#39;: &#39;changed&#39;,</span>
<span class="gi">+        &#39;deprecated&#39;: &#39;deprecated&#39;,</span>
<span class="gi">+        &#39;versionremoved&#39;: &#39;removed&#39;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def write(self, *ignored: Any) -&gt; None:</span>
<span class="gi">+        version = self.config.version</span>
<span class="gi">+        domain = cast(ChangeSetDomain, self.env.get_domain(&#39;changeset&#39;))</span>
<span class="gi">+        libchanges: dict[str, list[tuple[str, str, int]]] = {}</span>
<span class="gi">+        apichanges: list[tuple[str, str, int]] = []</span>
<span class="gi">+        otherchanges: dict[tuple[str, str], list[tuple[str, str, int]]] = {}</span>
<span class="gi">+</span>
<span class="gi">+        changesets = domain.get_changesets_for(version)</span>
<span class="gi">+        if not changesets:</span>
<span class="gi">+            logger.info(bold(__(&#39;no changes in version %s.&#39;)), version)</span>
<span class="gi">+            return</span>
<span class="gi">+        logger.info(bold(__(&#39;writing summary file...&#39;)))</span>
<span class="gi">+        for changeset in changesets:</span>
<span class="gi">+            if isinstance(changeset.descname, tuple):</span>
<span class="gi">+                descname = changeset.descname[0]</span>
<span class="gi">+            else:</span>
<span class="gi">+                descname = changeset.descname</span>
<span class="gi">+            ttext = self.typemap[changeset.type]</span>
<span class="gi">+            context = changeset.content.replace(&#39;\n&#39;, &#39; &#39;)</span>
<span class="gi">+            if descname and changeset.docname.startswith(&#39;c-api&#39;):</span>
<span class="gi">+                if context:</span>
<span class="gi">+                    entry = f&#39;&lt;b&gt;{descname}&lt;/b&gt;: &lt;i&gt;{ttext}:&lt;/i&gt; {context}&#39;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    entry = f&#39;&lt;b&gt;{descname}&lt;/b&gt;: &lt;i&gt;{ttext}&lt;/i&gt;.&#39;</span>
<span class="gi">+                apichanges.append((entry, changeset.docname, changeset.lineno))</span>
<span class="gi">+            elif descname or changeset.module:</span>
<span class="gi">+                module = changeset.module or _(&#39;Builtins&#39;)</span>
<span class="gi">+                if not descname:</span>
<span class="gi">+                    descname = _(&#39;Module level&#39;)</span>
<span class="gi">+                if context:</span>
<span class="gi">+                    entry = f&#39;&lt;b&gt;{descname}&lt;/b&gt;: &lt;i&gt;{ttext}:&lt;/i&gt; {context}&#39;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    entry = f&#39;&lt;b&gt;{descname}&lt;/b&gt;: &lt;i&gt;{ttext}&lt;/i&gt;.&#39;</span>
<span class="gi">+                libchanges.setdefault(module, []).append((entry, changeset.docname,</span>
<span class="gi">+                                                          changeset.lineno))</span>
<span class="gi">+            else:</span>
<span class="gi">+                if not context:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                entry = f&#39;&lt;i&gt;{ttext.capitalize()}:&lt;/i&gt; {context}&#39;</span>
<span class="gi">+                title = self.env.titles[changeset.docname].astext()</span>
<span class="gi">+                otherchanges.setdefault((changeset.docname, title), []).append(</span>
<span class="gi">+                    (entry, changeset.docname, changeset.lineno))</span>
<span class="gi">+</span>
<span class="gi">+        ctx = {</span>
<span class="gi">+            &#39;project&#39;: self.config.project,</span>
<span class="gi">+            &#39;version&#39;: version,</span>
<span class="gi">+            &#39;docstitle&#39;: self.config.html_title,</span>
<span class="gi">+            &#39;shorttitle&#39;: self.config.html_short_title,</span>
<span class="gi">+            &#39;libchanges&#39;: sorted(libchanges.items()),</span>
<span class="gi">+            &#39;apichanges&#39;: sorted(apichanges),</span>
<span class="gi">+            &#39;otherchanges&#39;: sorted(otherchanges.items()),</span>
<span class="gi">+            &#39;show_copyright&#39;: self.config.html_show_copyright,</span>
<span class="gi">+            &#39;show_sphinx&#39;: self.config.html_show_sphinx,</span>
<span class="gi">+        }</span>
<span class="gi">+        with open(path.join(self.outdir, &#39;index.html&#39;), &#39;w&#39;, encoding=&#39;utf8&#39;) as f:</span>
<span class="gi">+            f.write(self.templates.render(&#39;changes/frameset.html&#39;, ctx))</span>
<span class="gi">+        with open(path.join(self.outdir, &#39;changes.html&#39;), &#39;w&#39;, encoding=&#39;utf8&#39;) as f:</span>
<span class="gi">+            f.write(self.templates.render(&#39;changes/versionchanges.html&#39;, ctx))</span>
<span class="gi">+</span>
<span class="gi">+        hltext = [&#39;.. versionadded:: %s&#39; % version,</span>
<span class="gi">+                  &#39;.. versionchanged:: %s&#39; % version,</span>
<span class="gi">+                  &#39;.. deprecated:: %s&#39; % version,</span>
<span class="gi">+                  &#39;.. versionremoved:: %s&#39; % version,</span>
<span class="gi">+                  ]</span>
<span class="gi">+</span>
<span class="gi">+        def hl(no: int, line: str) -&gt; str:</span>
<span class="gi">+            line = &#39;&lt;a name=&quot;L%s&quot;&gt; &lt;/a&gt;&#39; % no + html.escape(line)</span>
<span class="gi">+            for x in hltext:</span>
<span class="gi">+                if x in line:</span>
<span class="gi">+                    line = &#39;&lt;span class=&quot;hl&quot;&gt;%s&lt;/span&gt;&#39; % line</span>
<span class="gi">+                    break</span>
<span class="gi">+            return line</span>
<span class="gi">+</span>
<span class="gi">+        logger.info(bold(__(&#39;copying source files...&#39;)))</span>
<span class="gi">+        for docname in self.env.all_docs:</span>
<span class="gi">+            with open(self.env.doc2path(docname),</span>
<span class="gi">+                      encoding=self.env.config.source_encoding) as f:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    lines = f.readlines()</span>
<span class="gi">+                except UnicodeDecodeError:</span>
<span class="gi">+                    logger.warning(__(&#39;could not read %r for changelog creation&#39;), docname)</span>
<span class="gi">+                    continue</span>
<span class="gi">+            targetfn = path.join(self.outdir, &#39;rst&#39;, os_path(docname)) + &#39;.html&#39;</span>
<span class="gi">+            ensuredir(path.dirname(targetfn))</span>
<span class="gi">+            with open(targetfn, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:</span>
<span class="gi">+                text = &#39;&#39;.join(hl(i + 1, line) for (i, line) in enumerate(lines))</span>
<span class="gi">+                ctx = {</span>
<span class="gi">+                    &#39;filename&#39;: str(self.env.doc2path(docname, False)),</span>
<span class="gi">+                    &#39;text&#39;: text,</span>
<span class="gi">+                }</span>
<span class="gi">+                f.write(self.templates.render(&#39;changes/rstsource.html&#39;, ctx))</span>
<span class="gi">+        themectx = {&#39;theme_&#39; + key: val for (key, val) in</span>
<span class="gi">+                    self.theme.get_options({}).items()}</span>
<span class="gi">+        copy_asset_file(</span>
<span class="gi">+            path.join(package_dir, &#39;themes&#39;, &#39;default&#39;, &#39;static&#39;, &#39;default.css.jinja&#39;),</span>
<span class="gi">+            self.outdir,</span>
<span class="gi">+            context=themectx,</span>
<span class="gi">+            renderer=self.templates,</span>
<span class="gi">+            force=True,</span>
<span class="gi">+        )</span>
<span class="gi">+        copy_asset_file(</span>
<span class="gi">+            path.join(package_dir, &#39;themes&#39;, &#39;basic&#39;, &#39;static&#39;, &#39;basic.css&#39;),</span>
<span class="gi">+            self.outdir / &#39;basic.css&#39;,</span>
<span class="gi">+            force=True,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def hl(self, text: str, version: str) -&gt; str:</span>
<span class="gi">+        text = html.escape(text)</span>
<span class="gi">+        for directive in (&#39;versionchanged&#39;, &#39;versionadded&#39;, &#39;deprecated&#39;, &#39;versionremoved&#39;):</span>
<span class="gi">+            text = text.replace(f&#39;.. {directive}:: {version}&#39;,</span>
<span class="gi">+                                f&#39;&lt;b&gt;.. {directive}:: {version}&lt;/b&gt;&#39;)</span>
<span class="gi">+        return text</span>
<span class="gi">+</span>
<span class="gi">+    def finish(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_builder(ChangesBuilder)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/builders/dirhtml.py b/sphinx/builders/dirhtml.py</span>
<span class="gh">index b59f4ec82..dbfced3a7 100644</span>
<span class="gd">--- a/sphinx/builders/dirhtml.py</span>
<span class="gi">+++ b/sphinx/builders/dirhtml.py</span>
<span class="gu">@@ -1,13 +1,18 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Directory HTML builders.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from sphinx.builders.html import StandaloneHTMLBuilder
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.osutil import SEP, os_path
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="gu">@@ -17,4 +22,34 @@ class DirectoryHTMLBuilder(StandaloneHTMLBuilder):</span>
<span class="w"> </span>    a directory given by their pagename, so that generated URLs don&#39;t have
<span class="w"> </span>    ``.html`` in them.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name = &#39;dirhtml&#39;
<span class="gi">+</span>
<span class="gi">+    def get_target_uri(self, docname: str, typ: str | None = None) -&gt; str:</span>
<span class="gi">+        if docname == &#39;index&#39;:</span>
<span class="gi">+            return &#39;&#39;</span>
<span class="gi">+        if docname.endswith(SEP + &#39;index&#39;):</span>
<span class="gi">+            return docname[:-5]  # up to sep</span>
<span class="gi">+        return docname + SEP</span>
<span class="gi">+</span>
<span class="gi">+    def get_outfilename(self, pagename: str) -&gt; str:</span>
<span class="gi">+        if pagename == &#39;index&#39; or pagename.endswith(SEP + &#39;index&#39;):</span>
<span class="gi">+            outfilename = path.join(self.outdir, os_path(pagename) +</span>
<span class="gi">+                                    self.out_suffix)</span>
<span class="gi">+        else:</span>
<span class="gi">+            outfilename = path.join(self.outdir, os_path(pagename),</span>
<span class="gi">+                                    &#39;index&#39; + self.out_suffix)</span>
<span class="gi">+</span>
<span class="gi">+        return outfilename</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.setup_extension(&#39;sphinx.builders.html&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    app.add_builder(DirectoryHTMLBuilder)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/builders/dummy.py b/sphinx/builders/dummy.py</span>
<span class="gh">index f7d1fb7c5..05b7e5687 100644</span>
<span class="gd">--- a/sphinx/builders/dummy.py</span>
<span class="gi">+++ b/sphinx/builders/dummy.py</span>
<span class="gu">@@ -1,10 +1,15 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Do syntax checks, but no writing.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from sphinx.builders import Builder
<span class="w"> </span>from sphinx.locale import __
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata

<span class="gu">@@ -12,4 +17,33 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>class DummyBuilder(Builder):
<span class="w"> </span>    name = &#39;dummy&#39;
<span class="w"> </span>    epilog = __(&#39;The dummy builder generates no files.&#39;)
<span class="gi">+</span>
<span class="w"> </span>    allow_parallel = True
<span class="gi">+</span>
<span class="gi">+    def init(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def get_outdated_docs(self) -&gt; set[str]:</span>
<span class="gi">+        return self.env.found_docs</span>
<span class="gi">+</span>
<span class="gi">+    def get_target_uri(self, docname: str, typ: str | None = None) -&gt; str:</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def prepare_writing(self, docnames: set[str]) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def write_doc(self, docname: str, doctree: nodes.document) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def finish(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_builder(DummyBuilder)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/builders/epub3.py b/sphinx/builders/epub3.py</span>
<span class="gh">index aecaf3dbc..004821b6e 100644</span>
<span class="gd">--- a/sphinx/builders/epub3.py</span>
<span class="gi">+++ b/sphinx/builders/epub3.py</span>
<span class="gu">@@ -2,13 +2,16 @@</span>

<span class="w"> </span>Originally derived from epub.py.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import html
<span class="w"> </span>import os
<span class="w"> </span>import re
<span class="w"> </span>import time
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING, Any, NamedTuple
<span class="gi">+</span>
<span class="w"> </span>from sphinx import package_dir
<span class="w"> </span>from sphinx.builders import _epub_base
<span class="w"> </span>from sphinx.config import ENUM, Config
<span class="gu">@@ -16,9 +19,11 @@ from sphinx.locale import __</span>
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.fileutil import copy_asset_file
<span class="w"> </span>from sphinx.util.osutil import make_filename
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="gu">@@ -28,18 +33,38 @@ class NavPoint(NamedTuple):</span>
<span class="w"> </span>    children: list[NavPoint]


<span class="gd">-PAGE_PROGRESSION_DIRECTIONS = {&#39;horizontal&#39;: &#39;ltr&#39;, &#39;vertical&#39;: &#39;rtl&#39;}</span>
<span class="gd">-IBOOK_SCROLL_AXIS = {&#39;horizontal&#39;: &#39;vertical&#39;, &#39;vertical&#39;: &#39;horizontal&#39;}</span>
<span class="gd">-THEME_WRITING_MODES = {&#39;vertical&#39;: &#39;vertical-rl&#39;, &#39;horizontal&#39;: &#39;horizontal-tb&#39;</span>
<span class="gd">-    }</span>
<span class="gd">-DOCTYPE = &#39;&lt;!DOCTYPE html&gt;&#39;</span>
<span class="gi">+# writing modes</span>
<span class="gi">+PAGE_PROGRESSION_DIRECTIONS = {</span>
<span class="gi">+    &#39;horizontal&#39;: &#39;ltr&#39;,</span>
<span class="gi">+    &#39;vertical&#39;: &#39;rtl&#39;,</span>
<span class="gi">+}</span>
<span class="gi">+IBOOK_SCROLL_AXIS = {</span>
<span class="gi">+    &#39;horizontal&#39;: &#39;vertical&#39;,</span>
<span class="gi">+    &#39;vertical&#39;: &#39;horizontal&#39;,</span>
<span class="gi">+}</span>
<span class="gi">+THEME_WRITING_MODES = {</span>
<span class="gi">+    &#39;vertical&#39;: &#39;vertical-rl&#39;,</span>
<span class="gi">+    &#39;horizontal&#39;: &#39;horizontal-tb&#39;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+DOCTYPE = &#39;&#39;&#39;&lt;!DOCTYPE html&gt;&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>HTML_TAG = (
<span class="gd">-    &#39;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:epub=&quot;http://www.idpf.org/2007/ops&quot;&gt;&#39;</span>
<span class="gd">-    )</span>
<span class="gi">+    &#39;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; &#39;</span>
<span class="gi">+    &#39;xmlns:epub=&quot;http://www.idpf.org/2007/ops&quot;&gt;&#39;</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+# https://www.w3.org/TR/REC-xml/#NT-Name</span>
<span class="w"> </span>_xml_name_start_char = (
<span class="gd">-    &#39;:|[A-Z]|_|[a-z]|[-]|[-]|[-]|[-]|[-\u1fff]|[\u200c-\u200d]|[-\u218f]|[-\u2fef]|[-\ud7ff]|[-]|[-]|[-\U000effff]&#39;</span>
<span class="gd">-    )</span>
<span class="gd">-_xml_name_char = _xml_name_start_char + &#39;\\-|\\.|[0-9]||[-]|[-]&#39;</span>
<span class="gi">+    &#39;:|[A-Z]|_|[a-z]|[\u00C0-\u00D6]&#39;</span>
<span class="gi">+    &#39;|[\u00D8-\u00F6]|[\u00F8-\u02FF]|[\u0370-\u037D]&#39;</span>
<span class="gi">+    &#39;|[\u037F-\u1FFF]|[\u200C-\u200D]|[\u2070-\u218F]&#39;</span>
<span class="gi">+    &#39;|[\u2C00-\u2FEF]|[\u3001-\uD7FF]|[\uF900-\uFDCF]&#39;</span>
<span class="gi">+    &#39;|[\uFDF0-\uFFFD]|[\U00010000-\U000EFFFF]&#39;</span>
<span class="gi">+)</span>
<span class="gi">+_xml_name_char = (</span>
<span class="gi">+    _xml_name_start_char + r&#39;\-|\.&#39; &#39;|[0-9]|\u00B7|[\u0300-\u036F]|[\u203F-\u2040]&#39;</span>
<span class="gi">+)</span>
<span class="w"> </span>_XML_NAME_PATTERN = re.compile(f&#39;({_xml_name_start_char})({_xml_name_char})*&#39;)


<span class="gu">@@ -51,25 +76,58 @@ class Epub3Builder(_epub_base.EpubBuilder):</span>
<span class="w"> </span>    and META-INF/container.xml. Afterwards, all necessary files are zipped to
<span class="w"> </span>    an epub file.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name = &#39;epub&#39;
<span class="w"> </span>    epilog = __(&#39;The ePub file is in %(outdir)s.&#39;)
<span class="gi">+</span>
<span class="w"> </span>    supported_remote_images = False
<span class="w"> </span>    template_dir = path.join(package_dir, &#39;templates&#39;, &#39;epub3&#39;)
<span class="w"> </span>    doctype = DOCTYPE
<span class="w"> </span>    html_tag = HTML_TAG
<span class="w"> </span>    use_meta_charset = True

<span class="gd">-    def handle_finish(self) -&gt;None:</span>
<span class="gi">+    # Finish by building the epub file</span>
<span class="gi">+    def handle_finish(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create the metainfo files and finally the epub.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.get_toc()</span>
<span class="gi">+        self.build_mimetype()</span>
<span class="gi">+        self.build_container()</span>
<span class="gi">+        self.build_content()</span>
<span class="gi">+        self.build_navigation_doc()</span>
<span class="gi">+        self.build_toc()</span>
<span class="gi">+        self.build_epub()</span>

<span class="gd">-    def content_metadata(self) -&gt;dict[str, Any]:</span>
<span class="gi">+    def content_metadata(self) -&gt; dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a dictionary with all metadata for the content.opf
<span class="w"> </span>        file properly escaped.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        writing_mode = self.config.epub_writing_mode</span>
<span class="gi">+</span>
<span class="gi">+        if (source_date_epoch := os.getenv(&#39;SOURCE_DATE_EPOCH&#39;)) is not None:</span>
<span class="gi">+            time_tuple = time.gmtime(int(source_date_epoch))</span>
<span class="gi">+        else:</span>
<span class="gi">+            time_tuple = time.gmtime()</span>
<span class="gi">+</span>
<span class="gi">+        metadata = super().content_metadata()</span>
<span class="gi">+        metadata[&#39;description&#39;] = html.escape(self.config.epub_description)</span>
<span class="gi">+        metadata[&#39;contributor&#39;] = html.escape(self.config.epub_contributor)</span>
<span class="gi">+        metadata[&#39;page_progression_direction&#39;] = PAGE_PROGRESSION_DIRECTIONS.get(writing_mode)</span>
<span class="gi">+        metadata[&#39;ibook_scroll_axis&#39;] = IBOOK_SCROLL_AXIS.get(writing_mode)</span>
<span class="gi">+        metadata[&#39;date&#39;] = html.escape(time.strftime(&quot;%Y-%m-%dT%H:%M:%SZ&quot;, time_tuple))</span>
<span class="gi">+        metadata[&#39;version&#39;] = html.escape(self.config.version)</span>
<span class="gi">+        metadata[&#39;epub_version&#39;] = self.config.epub_version</span>
<span class="gi">+        return metadata</span>
<span class="gi">+</span>
<span class="gi">+    def prepare_writing(self, docnames: set[str]) -&gt; None:</span>
<span class="gi">+        super().prepare_writing(docnames)</span>
<span class="gi">+</span>
<span class="gi">+        writing_mode = self.config.epub_writing_mode</span>
<span class="gi">+        self.globalcontext[&#39;theme_writing_mode&#39;] = THEME_WRITING_MODES.get(writing_mode)</span>
<span class="gi">+        self.globalcontext[&#39;html_tag&#39;] = self.html_tag</span>
<span class="gi">+        self.globalcontext[&#39;use_meta_charset&#39;] = self.use_meta_charset</span>
<span class="gi">+        self.globalcontext[&#39;skip_ua_compatible&#39;] = True</span>

<span class="gd">-    def build_navlist(self, navnodes: list[dict[str, Any]]) -&gt;list[NavPoint]:</span>
<span class="gi">+    def build_navlist(self, navnodes: list[dict[str, Any]]) -&gt; list[NavPoint]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create the toc navigation structure.

<span class="w"> </span>        This method is almost same as build_navpoints method in epub.py.
<span class="gu">@@ -79,20 +137,171 @@ class Epub3Builder(_epub_base.EpubBuilder):</span>
<span class="w"> </span>        The difference from build_navpoints method is templates which are used
<span class="w"> </span>        when generating navigation documents.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        navstack: list[NavPoint] = []</span>
<span class="gi">+        navstack.append(NavPoint(&#39;&#39;, &#39;&#39;, []))</span>
<span class="gi">+        level = 0</span>
<span class="gi">+        for node in navnodes:</span>
<span class="gi">+            if not node[&#39;text&#39;]:</span>
<span class="gi">+                continue</span>
<span class="gi">+            file = node[&#39;refuri&#39;].split(&#39;#&#39;)[0]</span>
<span class="gi">+            if file in self.ignored_files:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if node[&#39;level&#39;] &gt; self.config.epub_tocdepth:</span>
<span class="gi">+                continue</span>

<span class="gd">-    def navigation_doc_metadata(self, navlist: list[NavPoint]) -&gt;dict[str, Any</span>
<span class="gd">-        ]:</span>
<span class="gi">+            navpoint = NavPoint(node[&#39;text&#39;], node[&#39;refuri&#39;], [])</span>
<span class="gi">+            if node[&#39;level&#39;] == level:</span>
<span class="gi">+                navstack.pop()</span>
<span class="gi">+                navstack[-1].children.append(navpoint)</span>
<span class="gi">+                navstack.append(navpoint)</span>
<span class="gi">+            elif node[&#39;level&#39;] == level + 1:</span>
<span class="gi">+                level += 1</span>
<span class="gi">+                navstack[-1].children.append(navpoint)</span>
<span class="gi">+                navstack.append(navpoint)</span>
<span class="gi">+            elif node[&#39;level&#39;] &lt; level:</span>
<span class="gi">+                while node[&#39;level&#39;] &lt; len(navstack):</span>
<span class="gi">+                    navstack.pop()</span>
<span class="gi">+                level = node[&#39;level&#39;]</span>
<span class="gi">+                navstack[-1].children.append(navpoint)</span>
<span class="gi">+                navstack.append(navpoint)</span>
<span class="gi">+            else:</span>
<span class="gi">+                unreachable = &#39;Should never reach here. It might be a bug.&#39;</span>
<span class="gi">+                raise RuntimeError(unreachable)</span>
<span class="gi">+</span>
<span class="gi">+        return navstack[0].children</span>
<span class="gi">+</span>
<span class="gi">+    def navigation_doc_metadata(self, navlist: list[NavPoint]) -&gt; dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a dictionary with all metadata for the nav.xhtml file
<span class="w"> </span>        properly escaped.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {</span>
<span class="gi">+            &#39;lang&#39;: html.escape(self.config.epub_language),</span>
<span class="gi">+            &#39;toc_locale&#39;: html.escape(self.guide_titles[&#39;toc&#39;]),</span>
<span class="gi">+            &#39;navlist&#39;: navlist,</span>
<span class="gi">+        }</span>

<span class="gd">-    def build_navigation_doc(self) -&gt;None:</span>
<span class="gi">+    def build_navigation_doc(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Write the metainfo file nav.xhtml.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        logger.info(__(&#39;writing nav.xhtml file...&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        if self.config.epub_tocscope == &#39;default&#39;:</span>
<span class="gi">+            doctree = self.env.get_and_resolve_doctree(</span>
<span class="gi">+                self.config.root_doc, self,</span>
<span class="gi">+                prune_toctrees=False, includehidden=False)</span>
<span class="gi">+            refnodes = self.get_refnodes(doctree, [])</span>
<span class="gi">+            self.toc_add_files(refnodes)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # &#39;includehidden&#39;</span>
<span class="gi">+            refnodes = self.refnodes</span>
<span class="gi">+        navlist = self.build_navlist(refnodes)</span>
<span class="gi">+        copy_asset_file(</span>
<span class="gi">+            path.join(self.template_dir, &#39;nav.xhtml.jinja&#39;),</span>
<span class="gi">+            self.outdir,</span>
<span class="gi">+            context=self.navigation_doc_metadata(navlist),</span>
<span class="gi">+            force=True,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Add nav.xhtml to epub file</span>
<span class="gi">+        if &#39;nav.xhtml&#39; not in self.files:</span>
<span class="gi">+            self.files.append(&#39;nav.xhtml&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def validate_config_values(app: Sphinx) -&gt; None:</span>
<span class="gi">+    if app.builder.name != &#39;epub&#39;:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    # &lt;package&gt; lang attribute, dc:language</span>
<span class="gi">+    if not app.config.epub_language:</span>
<span class="gi">+        logger.warning(__(&#39;conf value &quot;epub_language&quot; (or &quot;language&quot;) &#39;</span>
<span class="gi">+                          &#39;should not be empty for EPUB3&#39;))</span>
<span class="gi">+    # &lt;package&gt; unique-identifier attribute</span>
<span class="gi">+    if not _XML_NAME_PATTERN.match(app.config.epub_uid):</span>
<span class="gi">+        logger.warning(__(&#39;conf value &quot;epub_uid&quot; should be XML NAME for EPUB3&#39;))</span>
<span class="gi">+    # dc:title</span>
<span class="gi">+    if not app.config.epub_title:</span>
<span class="gi">+        logger.warning(__(&#39;conf value &quot;epub_title&quot; (or &quot;html_title&quot;) &#39;</span>
<span class="gi">+                          &#39;should not be empty for EPUB3&#39;))</span>
<span class="gi">+    # dc:creator</span>
<span class="gi">+    if not app.config.epub_author:</span>
<span class="gi">+        logger.warning(__(&#39;conf value &quot;epub_author&quot; should not be empty for EPUB3&#39;))</span>
<span class="gi">+    # dc:contributor</span>
<span class="gi">+    if not app.config.epub_contributor:</span>
<span class="gi">+        logger.warning(__(&#39;conf value &quot;epub_contributor&quot; should not be empty for EPUB3&#39;))</span>
<span class="gi">+    # dc:description</span>
<span class="gi">+    if not app.config.epub_description:</span>
<span class="gi">+        logger.warning(__(&#39;conf value &quot;epub_description&quot; should not be empty for EPUB3&#39;))</span>
<span class="gi">+    # dc:publisher</span>
<span class="gi">+    if not app.config.epub_publisher:</span>
<span class="gi">+        logger.warning(__(&#39;conf value &quot;epub_publisher&quot; should not be empty for EPUB3&#39;))</span>
<span class="gi">+    # dc:rights</span>
<span class="gi">+    if not app.config.epub_copyright:</span>
<span class="gi">+        logger.warning(__(&#39;conf value &quot;epub_copyright&quot; (or &quot;copyright&quot;)&#39;</span>
<span class="gi">+                          &#39;should not be empty for EPUB3&#39;))</span>
<span class="gi">+    # dc:identifier</span>
<span class="gi">+    if not app.config.epub_identifier:</span>
<span class="gi">+        logger.warning(__(&#39;conf value &quot;epub_identifier&quot; should not be empty for EPUB3&#39;))</span>
<span class="gi">+    # meta ibooks:version</span>
<span class="gi">+    if not app.config.version:</span>
<span class="gi">+        logger.warning(__(&#39;conf value &quot;version&quot; should not be empty for EPUB3&#39;))</span>


<span class="gd">-def convert_epub_css_files(app: Sphinx, config: Config) -&gt;None:</span>
<span class="gi">+def convert_epub_css_files(app: Sphinx, config: Config) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert string styled epub_css_files to tuple styled one.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    epub_css_files: list[tuple[str, dict[str, Any]]] = []</span>
<span class="gi">+    for entry in config.epub_css_files:</span>
<span class="gi">+        if isinstance(entry, str):</span>
<span class="gi">+            epub_css_files.append((entry, {}))</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                filename, attrs = entry</span>
<span class="gi">+                epub_css_files.append((filename, attrs))</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                logger.warning(__(&#39;invalid css_file: %r, ignored&#39;), entry)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+    config.epub_css_files = epub_css_files</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_builder(Epub3Builder)</span>
<span class="gi">+</span>
<span class="gi">+    # config values</span>
<span class="gi">+    app.add_config_value(&#39;epub_basename&#39;, lambda self: make_filename(self.project), &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_version&#39;, 3.0, &#39;epub&#39;)  # experimental</span>
<span class="gi">+    app.add_config_value(&#39;epub_theme&#39;, &#39;epub&#39;, &#39;epub&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_theme_options&#39;, {}, &#39;epub&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_title&#39;, lambda self: self.project, &#39;epub&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_author&#39;, lambda self: self.author, &#39;epub&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_language&#39;, lambda self: self.language or &#39;en&#39;, &#39;epub&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_publisher&#39;, lambda self: self.author, &#39;epub&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_copyright&#39;, lambda self: self.copyright, &#39;epub&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_identifier&#39;, &#39;unknown&#39;, &#39;epub&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_scheme&#39;, &#39;unknown&#39;, &#39;epub&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_uid&#39;, &#39;unknown&#39;, &#39;env&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_cover&#39;, (), &#39;env&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_guide&#39;, (), &#39;env&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_pre_files&#39;, [], &#39;env&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_post_files&#39;, [], &#39;env&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_css_files&#39;, lambda config: config.html_css_files, &#39;epub&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_exclude_files&#39;, [], &#39;env&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_tocdepth&#39;, 3, &#39;env&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_tocdup&#39;, True, &#39;env&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_tocscope&#39;, &#39;default&#39;, &#39;env&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_fix_images&#39;, False, &#39;env&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_max_image_width&#39;, 0, &#39;env&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_show_urls&#39;, &#39;inline&#39;, &#39;epub&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_use_index&#39;, lambda self: self.html_use_index, &#39;epub&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_description&#39;, &#39;unknown&#39;, &#39;epub&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_contributor&#39;, &#39;unknown&#39;, &#39;epub&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;epub_writing_mode&#39;, &#39;horizontal&#39;, &#39;epub&#39;,</span>
<span class="gi">+                         ENUM(&#39;horizontal&#39;, &#39;vertical&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    # event handlers</span>
<span class="gi">+    app.connect(&#39;config-inited&#39;, convert_epub_css_files, priority=800)</span>
<span class="gi">+    app.connect(&#39;builder-inited&#39;, validate_config_values)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/builders/gettext.py b/sphinx/builders/gettext.py</span>
<span class="gh">index 4b4b24de7..8427fcbb4 100644</span>
<span class="gd">--- a/sphinx/builders/gettext.py</span>
<span class="gi">+++ b/sphinx/builders/gettext.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The MessageCatalogBuilder class.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import operator
<span class="w"> </span>import time
<span class="w"> </span>from codecs import open
<span class="gu">@@ -8,7 +10,9 @@ from os import getenv, path, walk</span>
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Literal
<span class="w"> </span>from uuid import uuid4
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes, package_dir
<span class="w"> </span>from sphinx.builders import Builder
<span class="w"> </span>from sphinx.errors import ThemeError
<span class="gu">@@ -22,22 +26,26 @@ from sphinx.util.nodes import extract_messages, traverse_translatable_index</span>
<span class="w"> </span>from sphinx.util.osutil import canon_path, ensuredir, relpath
<span class="w"> </span>from sphinx.util.tags import Tags
<span class="w"> </span>from sphinx.util.template import SphinxRenderer
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    import os
<span class="w"> </span>    from collections.abc import Iterable, Iterator, Sequence
<span class="gi">+</span>
<span class="w"> </span>    from docutils.nodes import Element
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.config import Config
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gi">+</span>
<span class="w"> </span>DEFAULT_TEMPLATE_PATH = Path(package_dir, &#39;templates&#39;, &#39;gettext&#39;)
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="w"> </span>class Message:
<span class="w"> </span>    &quot;&quot;&quot;An entry of translatable message.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, text: str, locations: list[tuple[str, int]], uuids:</span>
<span class="gd">-        list[str]) -&gt;None:</span>
<span class="gi">+    def __init__(self, text: str, locations: list[tuple[str, int]], uuids: list[str]) -&gt; None:</span>
<span class="w"> </span>        self.text = text
<span class="w"> </span>        self.locations = locations
<span class="w"> </span>        self.uuids = uuids
<span class="gu">@@ -46,14 +54,29 @@ class Message:</span>
<span class="w"> </span>class Catalog:
<span class="w"> </span>    &quot;&quot;&quot;Catalog of translatable messages.&quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gd">-        self.messages: list[str] = []</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        self.messages: list[str] = []  # retain insertion order</span>
<span class="gi">+</span>
<span class="gi">+        # msgid -&gt; file, line, uid</span>
<span class="w"> </span>        self.metadata: dict[str, list[tuple[str, int, str]]] = {}

<span class="gd">-    def __iter__(self) -&gt;Iterator[Message]:</span>
<span class="gi">+    def add(self, msg: str, origin: Element | MsgOrigin) -&gt; None:</span>
<span class="gi">+        if not hasattr(origin, &#39;uid&#39;):</span>
<span class="gi">+            # Nodes that are replicated like todo don&#39;t have a uid,</span>
<span class="gi">+            # however i18n is also unnecessary.</span>
<span class="gi">+            return</span>
<span class="gi">+        if msg not in self.metadata:  # faster lookup in hash</span>
<span class="gi">+            self.messages.append(msg)</span>
<span class="gi">+            self.metadata[msg] = []</span>
<span class="gi">+        line = origin.line</span>
<span class="gi">+        if line is None:</span>
<span class="gi">+            line = -1</span>
<span class="gi">+        self.metadata[msg].append((origin.source, line, origin.uid))  # type: ignore[arg-type]</span>
<span class="gi">+</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[Message]:</span>
<span class="w"> </span>        for message in self.messages:
<span class="gd">-            positions = sorted({(source, line) for source, line, uuid in</span>
<span class="gd">-                self.metadata[message]})</span>
<span class="gi">+            positions = sorted({(source, line) for source, line, uuid</span>
<span class="gi">+                               in self.metadata[message]})</span>
<span class="w"> </span>            uuids = [uuid for source, line, uuid in self.metadata[message]]
<span class="w"> </span>            yield Message(message, positions, uuids)

<span class="gu">@@ -63,29 +86,39 @@ class MsgOrigin:</span>
<span class="w"> </span>    Origin holder for Catalog message origin.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, source: str, line: int) -&gt;None:</span>
<span class="gi">+    def __init__(self, source: str, line: int) -&gt; None:</span>
<span class="w"> </span>        self.source = source
<span class="w"> </span>        self.line = line
<span class="w"> </span>        self.uid = uuid4().hex


<span class="w"> </span>class GettextRenderer(SphinxRenderer):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, template_path: (Sequence[str | os.PathLike[str]] |</span>
<span class="gd">-        None)=None, outdir: (str | os.PathLike[str] | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, template_path: Sequence[str | os.PathLike[str]] | None = None,</span>
<span class="gi">+            outdir: str | os.PathLike[str] | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.outdir = outdir
<span class="w"> </span>        if template_path is None:
<span class="w"> </span>            super().__init__([DEFAULT_TEMPLATE_PATH])
<span class="w"> </span>        else:
<span class="w"> </span>            super().__init__([*template_path, DEFAULT_TEMPLATE_PATH])

<span class="gd">-        def escape(s: str) -&gt;str:</span>
<span class="gd">-            s = s.replace(&#39;\\&#39;, &#39;\\\\&#39;)</span>
<span class="gd">-            s = s.replace(&#39;&quot;&#39;, &#39;\\&quot;&#39;)</span>
<span class="gi">+        def escape(s: str) -&gt; str:</span>
<span class="gi">+            s = s.replace(&#39;\\&#39;, r&#39;\\&#39;)</span>
<span class="gi">+            s = s.replace(&#39;&quot;&#39;, r&#39;\&quot;&#39;)</span>
<span class="w"> </span>            return s.replace(&#39;\n&#39;, &#39;\\n&quot;\n&quot;&#39;)
<span class="gi">+</span>
<span class="gi">+        # use texescape as escape filter</span>
<span class="w"> </span>        self.env.filters[&#39;e&#39;] = escape
<span class="w"> </span>        self.env.filters[&#39;escape&#39;] = escape

<span class="gi">+    def render(self, filename: str, context: dict[str, Any]) -&gt; str:</span>
<span class="gi">+        def _relpath(s: str) -&gt; str:</span>
<span class="gi">+            return canon_path(relpath(s, self.outdir))</span>
<span class="gi">+</span>
<span class="gi">+        context[&#39;relpath&#39;] = _relpath</span>
<span class="gi">+        return super().render(filename, context)</span>
<span class="gi">+</span>

<span class="w"> </span>class I18nTags(Tags):
<span class="w"> </span>    &quot;&quot;&quot;Dummy tags module for I18nBuilder.
<span class="gu">@@ -94,31 +127,206 @@ class I18nTags(Tags):</span>
<span class="w"> </span>    this class always returns ``True`` regardless the defined tags.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def eval_condition(self, condition: Any) -&gt; bool:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>

<span class="w"> </span>class I18nBuilder(Builder):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    General i18n builder.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name = &#39;i18n&#39;
<span class="w"> </span>    versioning_method = &#39;text&#39;
<span class="w"> </span>    use_message_catalog = False

<span class="gi">+    def init(self) -&gt; None:</span>
<span class="gi">+        super().init()</span>
<span class="gi">+        self.env.set_versioning_method(self.versioning_method,</span>
<span class="gi">+                                       self.env.config.gettext_uuid)</span>
<span class="gi">+        self.tags = I18nTags()</span>
<span class="gi">+        self.catalogs: defaultdict[str, Catalog] = defaultdict(Catalog)</span>
<span class="gi">+</span>
<span class="gi">+    def get_target_uri(self, docname: str, typ: str | None = None) -&gt; str:</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def get_outdated_docs(self) -&gt; set[str]:</span>
<span class="gi">+        return self.env.found_docs</span>
<span class="gi">+</span>
<span class="gi">+    def prepare_writing(self, docnames: set[str]) -&gt; None:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    def compile_catalogs(self, catalogs: set[CatalogInfo], message: str) -&gt; None:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    def write_doc(self, docname: str, doctree: nodes.document) -&gt; None:</span>
<span class="gi">+        catalog = self.catalogs[docname_to_domain(docname, self.config.gettext_compact)]</span>
<span class="gi">+</span>
<span class="gi">+        for toctree in self.env.tocs[docname].findall(addnodes.toctree):</span>
<span class="gi">+            for node, msg in extract_messages(toctree):</span>
<span class="gi">+                node.uid = &#39;&#39;  # type: ignore[attr-defined]  # Hack UUID model</span>
<span class="gi">+                catalog.add(msg, node)</span>

<span class="gi">+        for node, msg in extract_messages(doctree):</span>
<span class="gi">+            # Do not extract messages from within substitution definitions.</span>
<span class="gi">+            if not _is_node_in_substitution_definition(node):</span>
<span class="gi">+                catalog.add(msg, node)</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;index&#39; in self.env.config.gettext_additional_targets:</span>
<span class="gi">+            # Extract translatable messages from index entries.</span>
<span class="gi">+            for node, entries in traverse_translatable_index(doctree):</span>
<span class="gi">+                for entry_type, value, _target_id, _main, _category_key in entries:</span>
<span class="gi">+                    for m in split_index_msg(entry_type, value):</span>
<span class="gi">+                        catalog.add(m, node)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# If set, use the timestamp from SOURCE_DATE_EPOCH</span>
<span class="gi">+# https://reproducible-builds.org/specs/source-date-epoch/</span>
<span class="w"> </span>if (source_date_epoch := getenv(&#39;SOURCE_DATE_EPOCH&#39;)) is not None:
<span class="w"> </span>    timestamp = time.gmtime(float(source_date_epoch))
<span class="w"> </span>else:
<span class="gi">+    # determine timestamp once to remain unaffected by DST changes during build</span>
<span class="w"> </span>    timestamp = time.localtime()
<span class="w"> </span>ctime = time.strftime(&#39;%Y-%m-%d %H:%M%z&#39;, timestamp)


<span class="gd">-def _is_node_in_substitution_definition(node: nodes.Node) -&gt;bool:</span>
<span class="gi">+def should_write(filepath: str, new_content: str) -&gt; bool:</span>
<span class="gi">+    if not path.exists(filepath):</span>
<span class="gi">+        return True</span>
<span class="gi">+    try:</span>
<span class="gi">+        with open(filepath, encoding=&#39;utf-8&#39;) as oldpot:</span>
<span class="gi">+            old_content = oldpot.read()</span>
<span class="gi">+            old_header_index = old_content.index(&#39;&quot;POT-Creation-Date:&#39;)</span>
<span class="gi">+            new_header_index = new_content.index(&#39;&quot;POT-Creation-Date:&#39;)</span>
<span class="gi">+            old_body_index = old_content.index(&#39;&quot;PO-Revision-Date:&#39;)</span>
<span class="gi">+            new_body_index = new_content.index(&#39;&quot;PO-Revision-Date:&#39;)</span>
<span class="gi">+            return ((old_content[:old_header_index] != new_content[:new_header_index]) or</span>
<span class="gi">+                    (new_content[new_body_index:] != old_content[old_body_index:]))</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_node_in_substitution_definition(node: nodes.Node) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check &quot;node&quot; to test if it is in a substitution definition.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    while node.parent:</span>
<span class="gi">+        if isinstance(node, nodes.substitution_definition):</span>
<span class="gi">+            return True</span>
<span class="gi">+        node = node.parent</span>
<span class="gi">+    return False</span>


<span class="w"> </span>class MessageCatalogBuilder(I18nBuilder):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Builds gettext-style message catalogs (.pot files).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name = &#39;gettext&#39;
<span class="w"> </span>    epilog = __(&#39;The message catalogs are in %(outdir)s.&#39;)
<span class="gi">+</span>
<span class="gi">+    def init(self) -&gt; None:</span>
<span class="gi">+        super().init()</span>
<span class="gi">+        self.create_template_bridge()</span>
<span class="gi">+        self.templates.init(self)</span>
<span class="gi">+</span>
<span class="gi">+    def _collect_templates(self) -&gt; set[str]:</span>
<span class="gi">+        template_files = set()</span>
<span class="gi">+        for template_path in self.config.templates_path:</span>
<span class="gi">+            tmpl_abs_path = path.join(self.app.srcdir, template_path)</span>
<span class="gi">+            for dirpath, _dirs, files in walk(tmpl_abs_path):</span>
<span class="gi">+                for fn in files:</span>
<span class="gi">+                    if fn.endswith(&#39;.html&#39;):</span>
<span class="gi">+                        filename = canon_path(path.join(dirpath, fn))</span>
<span class="gi">+                        template_files.add(filename)</span>
<span class="gi">+        return template_files</span>
<span class="gi">+</span>
<span class="gi">+    def _extract_from_template(self) -&gt; None:</span>
<span class="gi">+        files = list(self._collect_templates())</span>
<span class="gi">+        files.sort()</span>
<span class="gi">+        logger.info(bold(__(&#39;building [%s]: &#39;)), self.name,  nonl=True)</span>
<span class="gi">+        logger.info(__(&#39;targets for %d template files&#39;), len(files))</span>
<span class="gi">+</span>
<span class="gi">+        extract_translations = self.templates.environment.extract_translations</span>
<span class="gi">+</span>
<span class="gi">+        for template in status_iterator(files, __(&#39;reading templates... &#39;), &quot;purple&quot;,</span>
<span class="gi">+                                        len(files), self.app.verbosity):</span>
<span class="gi">+            try:</span>
<span class="gi">+                with open(template, encoding=&#39;utf-8&#39;) as f:</span>
<span class="gi">+                    context = f.read()</span>
<span class="gi">+                for line, _meth, msg in extract_translations(context):</span>
<span class="gi">+                    origin = MsgOrigin(template, line)</span>
<span class="gi">+                    self.catalogs[&#39;sphinx&#39;].add(msg, origin)</span>
<span class="gi">+            except Exception as exc:</span>
<span class="gi">+                msg = f&#39;{template}: {exc!r}&#39;</span>
<span class="gi">+                raise ThemeError(msg) from exc</span>
<span class="gi">+</span>
<span class="gi">+    def build(  # type: ignore[misc]</span>
<span class="gi">+        self,</span>
<span class="gi">+        docnames: Iterable[str] | None,</span>
<span class="gi">+        summary: str | None = None,</span>
<span class="gi">+        method: Literal[&#39;all&#39;, &#39;specific&#39;, &#39;update&#39;] = &#39;update&#39;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        self._extract_from_template()</span>
<span class="gi">+        super().build(docnames, summary, method)</span>
<span class="gi">+</span>
<span class="gi">+    def finish(self) -&gt; None:</span>
<span class="gi">+        super().finish()</span>
<span class="gi">+        context = {</span>
<span class="gi">+            &#39;version&#39;: self.config.version,</span>
<span class="gi">+            &#39;copyright&#39;: self.config.copyright,</span>
<span class="gi">+            &#39;project&#39;: self.config.project,</span>
<span class="gi">+            &#39;last_translator&#39;: self.config.gettext_last_translator,</span>
<span class="gi">+            &#39;language_team&#39;: self.config.gettext_language_team,</span>
<span class="gi">+            &#39;ctime&#39;: ctime,</span>
<span class="gi">+            &#39;display_location&#39;: self.config.gettext_location,</span>
<span class="gi">+            &#39;display_uuid&#39;: self.config.gettext_uuid,</span>
<span class="gi">+        }</span>
<span class="gi">+        for textdomain, catalog in status_iterator(self.catalogs.items(),</span>
<span class="gi">+                                                   __(&quot;writing message catalogs... &quot;),</span>
<span class="gi">+                                                   &quot;darkgreen&quot;, len(self.catalogs),</span>
<span class="gi">+                                                   self.app.verbosity,</span>
<span class="gi">+                                                   operator.itemgetter(0)):</span>
<span class="gi">+            # noop if config.gettext_compact is set</span>
<span class="gi">+            ensuredir(path.join(self.outdir, path.dirname(textdomain)))</span>
<span class="gi">+</span>
<span class="gi">+            context[&#39;messages&#39;] = list(catalog)</span>
<span class="gi">+            template_path = [</span>
<span class="gi">+                self.app.srcdir / rel_path</span>
<span class="gi">+                for rel_path in self.config.templates_path</span>
<span class="gi">+            ]</span>
<span class="gi">+            renderer = GettextRenderer(template_path, outdir=self.outdir)</span>
<span class="gi">+            content = renderer.render(&#39;message.pot.jinja&#39;, context)</span>
<span class="gi">+</span>
<span class="gi">+            pofn = path.join(self.outdir, textdomain + &#39;.pot&#39;)</span>
<span class="gi">+            if should_write(pofn, content):</span>
<span class="gi">+                with open(pofn, &#39;w&#39;, encoding=&#39;utf-8&#39;) as pofile:</span>
<span class="gi">+                    pofile.write(content)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _gettext_compact_validator(app: Sphinx, config: Config) -&gt; None:</span>
<span class="gi">+    gettext_compact = config.gettext_compact</span>
<span class="gi">+    # Convert 0/1 from the command line to ``bool`` types</span>
<span class="gi">+    if gettext_compact == &#39;0&#39;:</span>
<span class="gi">+        config.gettext_compact = False</span>
<span class="gi">+    elif gettext_compact == &#39;1&#39;:</span>
<span class="gi">+        config.gettext_compact = True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_builder(MessageCatalogBuilder)</span>
<span class="gi">+</span>
<span class="gi">+    app.add_config_value(&#39;gettext_compact&#39;, True, &#39;gettext&#39;, {bool, str})</span>
<span class="gi">+    app.add_config_value(&#39;gettext_location&#39;, True, &#39;gettext&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;gettext_uuid&#39;, False, &#39;gettext&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;gettext_auto_build&#39;, True, &#39;env&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;gettext_additional_targets&#39;, [], &#39;env&#39;, types={set, list})</span>
<span class="gi">+    app.add_config_value(&#39;gettext_last_translator&#39;, &#39;FULL NAME &lt;EMAIL@ADDRESS&gt;&#39;, &#39;gettext&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;gettext_language_team&#39;, &#39;LANGUAGE &lt;LL@li.org&gt;&#39;, &#39;gettext&#39;)</span>
<span class="gi">+    app.connect(&#39;config-inited&#39;, _gettext_compact_validator, priority=800)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/builders/html/_assets.py b/sphinx/builders/html/_assets.py</span>
<span class="gh">index 084435e0e..699a160ee 100644</span>
<span class="gd">--- a/sphinx/builders/html/_assets.py</span>
<span class="gi">+++ b/sphinx/builders/html/_assets.py</span>
<span class="gu">@@ -1,10 +1,13 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import warnings
<span class="w"> </span>import zlib
<span class="w"> </span>from typing import TYPE_CHECKING, Any, NoReturn
<span class="gi">+</span>
<span class="w"> </span>from sphinx.deprecation import RemovedInSphinx90Warning
<span class="w"> </span>from sphinx.errors import ThemeError
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pathlib import Path

<span class="gu">@@ -14,53 +17,54 @@ class _CascadingStyleSheet:</span>
<span class="w"> </span>    priority: int
<span class="w"> </span>    attributes: dict[str, str]

<span class="gd">-    def __init__(self, filename: (str | os.PathLike[str]), /, *, priority:</span>
<span class="gd">-        int=500, rel: str=&#39;stylesheet&#39;, type: str=&#39;text/css&#39;, **attributes: str</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        filename: str | os.PathLike[str], /, *,</span>
<span class="gi">+        priority: int = 500,</span>
<span class="gi">+        rel: str = &#39;stylesheet&#39;,</span>
<span class="gi">+        type: str = &#39;text/css&#39;,</span>
<span class="gi">+        **attributes: str,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        object.__setattr__(self, &#39;filename&#39;, filename)
<span class="w"> </span>        object.__setattr__(self, &#39;priority&#39;, priority)
<span class="gd">-        object.__setattr__(self, &#39;attributes&#39;, {&#39;rel&#39;: rel, &#39;type&#39;: type} |</span>
<span class="gd">-            attributes)</span>
<span class="gi">+        object.__setattr__(self, &#39;attributes&#39;, {&#39;rel&#39;: rel, &#39;type&#39;: type} | attributes)</span>

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        attr = &#39;, &#39;.join(f&#39;{k}={v!r}&#39; for k, v in self.attributes.items())
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;{self.__class__.__name__}({self.filename!r}, priority={self.priority}, {attr})&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+        return (f&#39;{self.__class__.__name__}({self.filename!r}, &#39;</span>
<span class="gi">+                f&#39;priority={self.priority}, &#39;</span>
<span class="gi">+                f&#39;{attr})&#39;)</span>

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if isinstance(other, str):
<span class="gd">-            warnings.warn(</span>
<span class="gd">-                &#39;The str interface for _CascadingStyleSheet objects is deprecated. Use css.filename instead.&#39;</span>
<span class="gd">-                , RemovedInSphinx90Warning, stacklevel=2)</span>
<span class="gi">+            warnings.warn(&#39;The str interface for _CascadingStyleSheet objects is deprecated. &#39;</span>
<span class="gi">+                          &#39;Use css.filename instead.&#39;, RemovedInSphinx90Warning, stacklevel=2)</span>
<span class="w"> </span>            return self.filename == other
<span class="w"> </span>        if not isinstance(other, _CascadingStyleSheet):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.filename == other.filename and self.priority == other.</span>
<span class="gd">-            priority and self.attributes == other.attributes)</span>
<span class="gi">+        return (self.filename == other.filename</span>
<span class="gi">+                and self.priority == other.priority</span>
<span class="gi">+                and self.attributes == other.attributes)</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gd">-        return hash((self.filename, self.priority, *sorted(self.attributes.</span>
<span class="gd">-            items())))</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="gi">+        return hash((self.filename, self.priority, *sorted(self.attributes.items())))</span>

<span class="gd">-    def __setattr__(self, key: str, value: Any) -&gt;NoReturn:</span>
<span class="gi">+    def __setattr__(self, key: str, value: Any) -&gt; NoReturn:</span>
<span class="w"> </span>        msg = f&#39;{self.__class__.__name__} is immutable&#39;
<span class="w"> </span>        raise AttributeError(msg)

<span class="gd">-    def __delattr__(self, key: str) -&gt;NoReturn:</span>
<span class="gi">+    def __delattr__(self, key: str) -&gt; NoReturn:</span>
<span class="w"> </span>        msg = f&#39;{self.__class__.__name__} is immutable&#39;
<span class="w"> </span>        raise AttributeError(msg)

<span class="gd">-    def __getattr__(self, key: str) -&gt;str:</span>
<span class="gd">-        warnings.warn(</span>
<span class="gd">-            &#39;The str interface for _CascadingStyleSheet objects is deprecated. Use css.filename instead.&#39;</span>
<span class="gd">-            , RemovedInSphinx90Warning, stacklevel=2)</span>
<span class="gi">+    def __getattr__(self, key: str) -&gt; str:</span>
<span class="gi">+        warnings.warn(&#39;The str interface for _CascadingStyleSheet objects is deprecated. &#39;</span>
<span class="gi">+                      &#39;Use css.filename instead.&#39;, RemovedInSphinx90Warning, stacklevel=2)</span>
<span class="w"> </span>        return getattr(os.fspath(self.filename), key)

<span class="gd">-    def __getitem__(self, key: (int | slice)) -&gt;str:</span>
<span class="gd">-        warnings.warn(</span>
<span class="gd">-            &#39;The str interface for _CascadingStyleSheet objects is deprecated. Use css.filename instead.&#39;</span>
<span class="gd">-            , RemovedInSphinx90Warning, stacklevel=2)</span>
<span class="gi">+    def __getitem__(self, key: int | slice) -&gt; str:</span>
<span class="gi">+        warnings.warn(&#39;The str interface for _CascadingStyleSheet objects is deprecated. &#39;</span>
<span class="gi">+                      &#39;Use css.filename instead.&#39;, RemovedInSphinx90Warning, stacklevel=2)</span>
<span class="w"> </span>        return os.fspath(self.filename)[key]


<span class="gu">@@ -69,52 +73,74 @@ class _JavaScript:</span>
<span class="w"> </span>    priority: int
<span class="w"> </span>    attributes: dict[str, str]

<span class="gd">-    def __init__(self, filename: (str | os.PathLike[str]), /, *, priority:</span>
<span class="gd">-        int=500, **attributes: str) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        filename: str | os.PathLike[str], /, *,</span>
<span class="gi">+        priority: int = 500,</span>
<span class="gi">+        **attributes: str,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        object.__setattr__(self, &#39;filename&#39;, filename)
<span class="w"> </span>        object.__setattr__(self, &#39;priority&#39;, priority)
<span class="w"> </span>        object.__setattr__(self, &#39;attributes&#39;, attributes)

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        attr = &#39;&#39;
<span class="w"> </span>        if self.attributes:
<span class="gd">-            attr = &#39;, &#39; + &#39;, &#39;.join(f&#39;{k}={v!r}&#39; for k, v in self.</span>
<span class="gd">-                attributes.items())</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;{self.__class__.__name__}({self.filename!r}, priority={self.priority}{attr})&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+            attr = &#39;, &#39; + &#39;, &#39;.join(f&#39;{k}={v!r}&#39; for k, v in self.attributes.items())</span>
<span class="gi">+        return (f&#39;{self.__class__.__name__}({self.filename!r}, &#39;</span>
<span class="gi">+                f&#39;priority={self.priority}&#39;</span>
<span class="gi">+                f&#39;{attr})&#39;)</span>

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if isinstance(other, str):
<span class="gd">-            warnings.warn(</span>
<span class="gd">-                &#39;The str interface for _JavaScript objects is deprecated. Use js.filename instead.&#39;</span>
<span class="gd">-                , RemovedInSphinx90Warning, stacklevel=2)</span>
<span class="gi">+            warnings.warn(&#39;The str interface for _JavaScript objects is deprecated. &#39;</span>
<span class="gi">+                          &#39;Use js.filename instead.&#39;, RemovedInSphinx90Warning, stacklevel=2)</span>
<span class="w"> </span>            return self.filename == other
<span class="w"> </span>        if not isinstance(other, _JavaScript):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.filename == other.filename and self.priority == other.</span>
<span class="gd">-            priority and self.attributes == other.attributes)</span>
<span class="gi">+        return (self.filename == other.filename</span>
<span class="gi">+                and self.priority == other.priority</span>
<span class="gi">+                and self.attributes == other.attributes)</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gd">-        return hash((self.filename, self.priority, *sorted(self.attributes.</span>
<span class="gd">-            items())))</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="gi">+        return hash((self.filename, self.priority, *sorted(self.attributes.items())))</span>

<span class="gd">-    def __setattr__(self, key: str, value: Any) -&gt;NoReturn:</span>
<span class="gi">+    def __setattr__(self, key: str, value: Any) -&gt; NoReturn:</span>
<span class="w"> </span>        msg = f&#39;{self.__class__.__name__} is immutable&#39;
<span class="w"> </span>        raise AttributeError(msg)

<span class="gd">-    def __delattr__(self, key: str) -&gt;NoReturn:</span>
<span class="gi">+    def __delattr__(self, key: str) -&gt; NoReturn:</span>
<span class="w"> </span>        msg = f&#39;{self.__class__.__name__} is immutable&#39;
<span class="w"> </span>        raise AttributeError(msg)

<span class="gd">-    def __getattr__(self, key: str) -&gt;str:</span>
<span class="gd">-        warnings.warn(</span>
<span class="gd">-            &#39;The str interface for _JavaScript objects is deprecated. Use js.filename instead.&#39;</span>
<span class="gd">-            , RemovedInSphinx90Warning, stacklevel=2)</span>
<span class="gi">+    def __getattr__(self, key: str) -&gt; str:</span>
<span class="gi">+        warnings.warn(&#39;The str interface for _JavaScript objects is deprecated. &#39;</span>
<span class="gi">+                      &#39;Use js.filename instead.&#39;, RemovedInSphinx90Warning, stacklevel=2)</span>
<span class="w"> </span>        return getattr(os.fspath(self.filename), key)

<span class="gd">-    def __getitem__(self, key: (int | slice)) -&gt;str:</span>
<span class="gd">-        warnings.warn(</span>
<span class="gd">-            &#39;The str interface for _JavaScript objects is deprecated. Use js.filename instead.&#39;</span>
<span class="gd">-            , RemovedInSphinx90Warning, stacklevel=2)</span>
<span class="gi">+    def __getitem__(self, key: int | slice) -&gt; str:</span>
<span class="gi">+        warnings.warn(&#39;The str interface for _JavaScript objects is deprecated. &#39;</span>
<span class="gi">+                      &#39;Use js.filename instead.&#39;, RemovedInSphinx90Warning, stacklevel=2)</span>
<span class="w"> </span>        return os.fspath(self.filename)[key]
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _file_checksum(outdir: Path, filename: str | os.PathLike[str]) -&gt; str:</span>
<span class="gi">+    filename = os.fspath(filename)</span>
<span class="gi">+    # Don&#39;t generate checksums for HTTP URIs</span>
<span class="gi">+    if &#39;://&#39; in filename:</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+    # Some themes and extensions have used query strings</span>
<span class="gi">+    # for a similar asset checksum feature.</span>
<span class="gi">+    # As we cannot safely strip the query string,</span>
<span class="gi">+    # raise an error to the user.</span>
<span class="gi">+    if &#39;?&#39; in filename:</span>
<span class="gi">+        msg = f&#39;Local asset file paths must not contain query strings: {filename!r}&#39;</span>
<span class="gi">+        raise ThemeError(msg)</span>
<span class="gi">+    try:</span>
<span class="gi">+        # Remove all carriage returns to avoid checksum differences</span>
<span class="gi">+        content = outdir.joinpath(filename).read_bytes().translate(None, b&#39;\r&#39;)</span>
<span class="gi">+    except FileNotFoundError:</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+    if not content:</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+    return f&#39;{zlib.crc32(content):08x}&#39;</span>
<span class="gh">diff --git a/sphinx/builders/html/_build_info.py b/sphinx/builders/html/_build_info.py</span>
<span class="gh">index 124c16e83..5b364c0d9 100644</span>
<span class="gd">--- a/sphinx/builders/html/_build_info.py</span>
<span class="gi">+++ b/sphinx/builders/html/_build_info.py</span>
<span class="gu">@@ -1,13 +1,18 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Record metadata for the build process.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import hashlib
<span class="w"> </span>import types
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from sphinx.locale import __
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Set
<span class="w"> </span>    from pathlib import Path
<span class="w"> </span>    from typing import Any
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.config import Config, _ConfigRebuild
<span class="w"> </span>    from sphinx.util.tags import Tags

<span class="gu">@@ -19,26 +24,71 @@ class BuildInfo:</span>
<span class="w"> </span>    This class is a manipulator for the file.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, config: (Config | None)=None, tags: (Tags | None)=</span>
<span class="gd">-        None, config_categories: Set[_ConfigRebuild]=frozenset()) -&gt;None:</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def load(cls: type[BuildInfo], filename: Path, /) -&gt; BuildInfo:</span>
<span class="gi">+        content = filename.read_text(encoding=&quot;utf-8&quot;)</span>
<span class="gi">+        lines = content.splitlines()</span>
<span class="gi">+</span>
<span class="gi">+        version = lines[0].rstrip()</span>
<span class="gi">+        if version != &#39;# Sphinx build info version 1&#39;:</span>
<span class="gi">+            msg = __(&#39;failed to read broken build info file (unknown version)&#39;)</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        if not lines[2].startswith(&#39;config: &#39;):</span>
<span class="gi">+            msg = __(&#39;failed to read broken build info file (missing config entry)&#39;)</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gi">+        if not lines[3].startswith(&#39;tags: &#39;):</span>
<span class="gi">+            msg = __(&#39;failed to read broken build info file (missing tags entry)&#39;)</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        build_info = BuildInfo()</span>
<span class="gi">+        build_info.config_hash = lines[2].removeprefix(&#39;config: &#39;).strip()</span>
<span class="gi">+        build_info.tags_hash = lines[3].removeprefix(&#39;tags: &#39;).strip()</span>
<span class="gi">+        return build_info</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        config: Config | None = None,</span>
<span class="gi">+        tags: Tags | None = None,</span>
<span class="gi">+        config_categories: Set[_ConfigRebuild] = frozenset(),</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.config_hash = &#39;&#39;
<span class="w"> </span>        self.tags_hash = &#39;&#39;
<span class="gi">+</span>
<span class="w"> </span>        if config:
<span class="gd">-            values = {c.name: c.value for c in config.filter(config_categories)</span>
<span class="gd">-                }</span>
<span class="gi">+            values = {c.name: c.value for c in config.filter(config_categories)}</span>
<span class="w"> </span>            self.config_hash = _stable_hash(values)
<span class="gi">+</span>
<span class="w"> </span>        if tags:
<span class="w"> </span>            self.tags_hash = _stable_hash(sorted(tags))

<span class="gd">-    def __eq__(self, other: BuildInfo) -&gt;bool:</span>
<span class="gd">-        return (self.config_hash == other.config_hash and self.tags_hash ==</span>
<span class="gd">-            other.tags_hash)</span>
<span class="gi">+    def __eq__(self, other: BuildInfo) -&gt; bool:  # type: ignore[override]</span>
<span class="gi">+        return (self.config_hash == other.config_hash and</span>
<span class="gi">+                self.tags_hash == other.tags_hash)</span>
<span class="gi">+</span>
<span class="gi">+    def dump(self, filename: Path, /) -&gt; None:</span>
<span class="gi">+        build_info = (</span>
<span class="gi">+            &#39;# Sphinx build info version 1\n&#39;</span>
<span class="gi">+            &#39;# This file records the configuration used when building these files. &#39;</span>
<span class="gi">+            &#39;When it is not found, a full rebuild will be done.\n&#39;</span>
<span class="gi">+            f&#39;config: {self.config_hash}\n&#39;</span>
<span class="gi">+            f&#39;tags: {self.tags_hash}\n&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+        filename.write_text(build_info, encoding=&quot;utf-8&quot;)</span>


<span class="gd">-def _stable_hash(obj: Any) -&gt;str:</span>
<span class="gi">+def _stable_hash(obj: Any) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a stable hash for a Python data structure.

<span class="w"> </span>    We can&#39;t just use the md5 of str(obj) as the order of collections
<span class="w"> </span>    may be random.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(obj, dict):</span>
<span class="gi">+        obj = sorted(map(_stable_hash, obj.items()))</span>
<span class="gi">+    if isinstance(obj, list | tuple | set | frozenset):</span>
<span class="gi">+        obj = sorted(map(_stable_hash, obj))</span>
<span class="gi">+    elif isinstance(obj, type | types.FunctionType):</span>
<span class="gi">+        # The default repr() of functions includes the ID, which is not ideal.</span>
<span class="gi">+        # We use the fully qualified name instead.</span>
<span class="gi">+        obj = f&#39;{obj.__module__}.{obj.__qualname__}&#39;</span>
<span class="gi">+    return hashlib.md5(str(obj).encode(), usedforsecurity=False).hexdigest()</span>
<span class="gh">diff --git a/sphinx/builders/html/transforms.py b/sphinx/builders/html/transforms.py</span>
<span class="gh">index 261a2a96d..a36588c7b 100644</span>
<span class="gd">--- a/sphinx/builders/html/transforms.py</span>
<span class="gi">+++ b/sphinx/builders/html/transforms.py</span>
<span class="gu">@@ -1,10 +1,15 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Transforms for HTML builder.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>from sphinx.transforms.post_transforms import SphinxPostTransform
<span class="w"> </span>from sphinx.util.nodes import NodeMatcher
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gu">@@ -27,8 +32,57 @@ class KeyboardTransform(SphinxPostTransform):</span>
<span class="w"> </span>            &lt;literal class=&quot;kbd&quot;&gt;
<span class="w"> </span>                x
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    default_priority = 400
<span class="gd">-    formats = &#39;html&#39;,</span>
<span class="gd">-    pattern = re.compile(&#39;(?&lt;=.)(-|\\+|\\^|\\s+)(?=.)&#39;)</span>
<span class="gd">-    multiwords_keys = (&#39;caps&#39;, &#39;lock&#39;), (&#39;page&#39;, &#39;down&#39;), (&#39;page&#39;, &#39;up&#39;), (</span>
<span class="gd">-        &#39;scroll&#39;, &#39;lock&#39;), (&#39;num&#39;, &#39;lock&#39;), (&#39;sys&#39;, &#39;rq&#39;), (&#39;back&#39;, &#39;space&#39;)</span>
<span class="gi">+    formats = (&#39;html&#39;,)</span>
<span class="gi">+    pattern = re.compile(r&#39;(?&lt;=.)(-|\+|\^|\s+)(?=.)&#39;)</span>
<span class="gi">+    multiwords_keys = ((&#39;caps&#39;, &#39;lock&#39;),</span>
<span class="gi">+                       (&#39;page&#39;, &#39;down&#39;),</span>
<span class="gi">+                       (&#39;page&#39;, &#39;up&#39;),</span>
<span class="gi">+                       (&#39;scroll&#39;, &#39;lock&#39;),</span>
<span class="gi">+                       (&#39;num&#39;, &#39;lock&#39;),</span>
<span class="gi">+                       (&#39;sys&#39;, &#39;rq&#39;),</span>
<span class="gi">+                       (&#39;back&#39;, &#39;space&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    def run(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        matcher = NodeMatcher(nodes.literal, classes=[&quot;kbd&quot;])</span>
<span class="gi">+        # this list must be pre-created as during iteration new nodes</span>
<span class="gi">+        # are added which match the condition in the NodeMatcher.</span>
<span class="gi">+        for node in list(matcher.findall(self.document)):</span>
<span class="gi">+            parts = self.pattern.split(node[-1].astext())</span>
<span class="gi">+            if len(parts) == 1 or self.is_multiwords_key(parts):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            node[&#39;classes&#39;].append(&#39;compound&#39;)</span>
<span class="gi">+            node.pop()</span>
<span class="gi">+            while parts:</span>
<span class="gi">+                if self.is_multiwords_key(parts):</span>
<span class="gi">+                    key = &#39;&#39;.join(parts[:3])</span>
<span class="gi">+                    parts[:3] = []</span>
<span class="gi">+                else:</span>
<span class="gi">+                    key = parts.pop(0)</span>
<span class="gi">+                node += nodes.literal(&#39;&#39;, key, classes=[&quot;kbd&quot;])</span>
<span class="gi">+</span>
<span class="gi">+                try:</span>
<span class="gi">+                    # key separator (ex. -, +, ^)</span>
<span class="gi">+                    sep = parts.pop(0)</span>
<span class="gi">+                    node += nodes.Text(sep)</span>
<span class="gi">+                except IndexError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+</span>
<span class="gi">+    def is_multiwords_key(self, parts: list[str]) -&gt; bool:</span>
<span class="gi">+        if len(parts) &gt;= 3 and parts[1].strip() == &#39;&#39;:</span>
<span class="gi">+            name = parts[0].lower(), parts[2].lower()</span>
<span class="gi">+            return name in self.multiwords_keys</span>
<span class="gi">+        else:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_post_transform(KeyboardTransform)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/builders/latex/constants.py b/sphinx/builders/latex/constants.py</span>
<span class="gh">index 7d8f9fe64..9da66e826 100644</span>
<span class="gd">--- a/sphinx/builders/latex/constants.py</span>
<span class="gi">+++ b/sphinx/builders/latex/constants.py</span>
<span class="gu">@@ -1,140 +1,215 @@</span>
<span class="w"> </span>&quot;&quot;&quot;constants for LaTeX builder.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import Any
<span class="gd">-PDFLATEX_DEFAULT_FONTPKG = &quot;&quot;&quot;</span>
<span class="gd">-\\usepackage{tgtermes}</span>
<span class="gd">-\\usepackage{tgheros}</span>
<span class="gd">-\\renewcommand{\\ttdefault}{txtt}</span>
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-PDFLATEX_DEFAULT_FONTSUBSTITUTION = &quot;&quot;&quot;</span>
<span class="gd">-\\expandafter\\ifx\\csname T@LGR\\endcsname\\relax</span>
<span class="gd">-\\else</span>
<span class="gi">+</span>
<span class="gi">+PDFLATEX_DEFAULT_FONTPKG = r&#39;&#39;&#39;</span>
<span class="gi">+\usepackage{tgtermes}</span>
<span class="gi">+\usepackage{tgheros}</span>
<span class="gi">+\renewcommand{\ttdefault}{txtt}</span>
<span class="gi">+&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+PDFLATEX_DEFAULT_FONTSUBSTITUTION = r&#39;&#39;&#39;</span>
<span class="gi">+\expandafter\ifx\csname T@LGR\endcsname\relax</span>
<span class="gi">+\else</span>
<span class="w"> </span>% LGR was declared as font encoding
<span class="gd">-  \\substitutefont{LGR}{\\rmdefault}{cmr}</span>
<span class="gd">-  \\substitutefont{LGR}{\\sfdefault}{cmss}</span>
<span class="gd">-  \\substitutefont{LGR}{\\ttdefault}{cmtt}</span>
<span class="gd">-\\fi</span>
<span class="gd">-\\expandafter\\ifx\\csname T@X2\\endcsname\\relax</span>
<span class="gd">-  \\expandafter\\ifx\\csname T@T2A\\endcsname\\relax</span>
<span class="gd">-  \\else</span>
<span class="gi">+  \substitutefont{LGR}{\rmdefault}{cmr}</span>
<span class="gi">+  \substitutefont{LGR}{\sfdefault}{cmss}</span>
<span class="gi">+  \substitutefont{LGR}{\ttdefault}{cmtt}</span>
<span class="gi">+\fi</span>
<span class="gi">+\expandafter\ifx\csname T@X2\endcsname\relax</span>
<span class="gi">+  \expandafter\ifx\csname T@T2A\endcsname\relax</span>
<span class="gi">+  \else</span>
<span class="w"> </span>  % T2A was declared as font encoding
<span class="gd">-    \\substitutefont{T2A}{\\rmdefault}{cmr}</span>
<span class="gd">-    \\substitutefont{T2A}{\\sfdefault}{cmss}</span>
<span class="gd">-    \\substitutefont{T2A}{\\ttdefault}{cmtt}</span>
<span class="gd">-  \\fi</span>
<span class="gd">-\\else</span>
<span class="gi">+    \substitutefont{T2A}{\rmdefault}{cmr}</span>
<span class="gi">+    \substitutefont{T2A}{\sfdefault}{cmss}</span>
<span class="gi">+    \substitutefont{T2A}{\ttdefault}{cmtt}</span>
<span class="gi">+  \fi</span>
<span class="gi">+\else</span>
<span class="w"> </span>% X2 was declared as font encoding
<span class="gd">-  \\substitutefont{X2}{\\rmdefault}{cmr}</span>
<span class="gd">-  \\substitutefont{X2}{\\sfdefault}{cmss}</span>
<span class="gd">-  \\substitutefont{X2}{\\ttdefault}{cmtt}</span>
<span class="gd">-\\fi</span>
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-XELATEX_DEFAULT_FONTPKG = &quot;&quot;&quot;</span>
<span class="gd">-\\setmainfont{FreeSerif}[</span>
<span class="gi">+  \substitutefont{X2}{\rmdefault}{cmr}</span>
<span class="gi">+  \substitutefont{X2}{\sfdefault}{cmss}</span>
<span class="gi">+  \substitutefont{X2}{\ttdefault}{cmtt}</span>
<span class="gi">+\fi</span>
<span class="gi">+&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+XELATEX_DEFAULT_FONTPKG = r&#39;&#39;&#39;</span>
<span class="gi">+\setmainfont{FreeSerif}[</span>
<span class="w"> </span>  Extension      = .otf,
<span class="w"> </span>  UprightFont    = *,
<span class="w"> </span>  ItalicFont     = *Italic,
<span class="w"> </span>  BoldFont       = *Bold,
<span class="w"> </span>  BoldItalicFont = *BoldItalic
<span class="w"> </span>]
<span class="gd">-\\setsansfont{FreeSans}[</span>
<span class="gi">+\setsansfont{FreeSans}[</span>
<span class="w"> </span>  Extension      = .otf,
<span class="w"> </span>  UprightFont    = *,
<span class="w"> </span>  ItalicFont     = *Oblique,
<span class="w"> </span>  BoldFont       = *Bold,
<span class="w"> </span>  BoldItalicFont = *BoldOblique,
<span class="w"> </span>]
<span class="gd">-\\setmonofont{FreeMono}[</span>
<span class="gi">+\setmonofont{FreeMono}[</span>
<span class="w"> </span>  Extension      = .otf,
<span class="w"> </span>  UprightFont    = *,
<span class="w"> </span>  ItalicFont     = *Oblique,
<span class="w"> </span>  BoldFont       = *Bold,
<span class="w"> </span>  BoldItalicFont = *BoldOblique,
<span class="w"> </span>]
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-XELATEX_GREEK_DEFAULT_FONTPKG = XELATEX_DEFAULT_FONTPKG + &quot;&quot;&quot;</span>
<span class="gd">-\\newfontfamily\\greekfont{FreeSerif}&quot;&quot;&quot; + &quot;&quot;&quot;</span>
<span class="gd">-\\newfontfamily\\greekfontsf{FreeSans}&quot;&quot;&quot; + &quot;&quot;&quot;</span>
<span class="gd">-\\newfontfamily\\greekfonttt{FreeMono}&quot;&quot;&quot;</span>
<span class="gi">+&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+XELATEX_GREEK_DEFAULT_FONTPKG = (XELATEX_DEFAULT_FONTPKG +</span>
<span class="gi">+                                 &#39;\n\\newfontfamily\\greekfont{FreeSerif}&#39; +</span>
<span class="gi">+                                 &#39;\n\\newfontfamily\\greekfontsf{FreeSans}&#39; +</span>
<span class="gi">+                                 &#39;\n\\newfontfamily\\greekfonttt{FreeMono}&#39;)</span>
<span class="gi">+</span>
<span class="w"> </span>LUALATEX_DEFAULT_FONTPKG = XELATEX_DEFAULT_FONTPKG
<span class="gd">-DEFAULT_SETTINGS: dict[str, Any] = {&#39;latex_engine&#39;: &#39;pdflatex&#39;, &#39;papersize&#39;:</span>
<span class="gd">-    &#39;&#39;, &#39;pointsize&#39;: &#39;&#39;, &#39;pxunit&#39;: &#39;.75bp&#39;, &#39;classoptions&#39;: &#39;&#39;,</span>
<span class="gd">-    &#39;extraclassoptions&#39;: &#39;&#39;, &#39;maxlistdepth&#39;: &#39;&#39;, &#39;sphinxpkgoptions&#39;: &#39;&#39;,</span>
<span class="gd">-    &#39;sphinxsetup&#39;: &#39;&#39;, &#39;fvset&#39;: &#39;\\fvset{fontsize=auto}&#39;,</span>
<span class="gd">-    &#39;passoptionstopackages&#39;: &#39;&#39;, &#39;geometry&#39;: &#39;\\usepackage{geometry}&#39;,</span>
<span class="gd">-    &#39;inputenc&#39;: &#39;&#39;, &#39;utf8extra&#39;: &#39;&#39;, &#39;cmappkg&#39;: &#39;\\usepackage{cmap}&#39;,</span>
<span class="gd">-    &#39;fontenc&#39;: &#39;\\usepackage[T1]{fontenc}&#39;, &#39;amsmath&#39;:</span>
<span class="gd">-    &#39;\\usepackage{amsmath,amssymb,amstext}&#39;, &#39;multilingual&#39;: &#39;&#39;, &#39;babel&#39;:</span>
<span class="gd">-    &#39;\\usepackage{babel}&#39;, &#39;polyglossia&#39;: &#39;&#39;, &#39;fontpkg&#39;:</span>
<span class="gd">-    PDFLATEX_DEFAULT_FONTPKG, &#39;fontsubstitution&#39;:</span>
<span class="gd">-    PDFLATEX_DEFAULT_FONTSUBSTITUTION, &#39;substitutefont&#39;: &#39;&#39;, &#39;textcyrillic&#39;:</span>
<span class="gd">-    &#39;&#39;, &#39;textgreek&#39;: &#39;\\usepackage{textalpha}&#39;, &#39;fncychap&#39;:</span>
<span class="gd">-    &#39;\\usepackage[Bjarne]{fncychap}&#39;, &#39;hyperref&#39;:</span>
<span class="gd">-    &quot;&quot;&quot;% Include hyperref last.</span>
<span class="gd">-\\usepackage{hyperref}</span>
<span class="gd">-% Fix anchor placement for figures with captions.</span>
<span class="gd">-\\usepackage{hypcap}% it must be loaded after hyperref.</span>
<span class="gd">-% Set up styles of URL: it should be placed after hyperref.</span>
<span class="gd">-\\urlstyle{same}&quot;&quot;&quot;</span>
<span class="gd">-    , &#39;contentsname&#39;: &#39;&#39;, &#39;extrapackages&#39;: &#39;&#39;, &#39;preamble&#39;: &#39;&#39;, &#39;title&#39;: &#39;&#39;,</span>
<span class="gd">-    &#39;release&#39;: &#39;&#39;, &#39;author&#39;: &#39;&#39;, &#39;releasename&#39;: &#39;&#39;, &#39;makeindex&#39;:</span>
<span class="gd">-    &#39;\\makeindex&#39;, &#39;shorthandoff&#39;: &#39;&#39;, &#39;maketitle&#39;: &#39;\\sphinxmaketitle&#39;,</span>
<span class="gd">-    &#39;tableofcontents&#39;: &#39;\\sphinxtableofcontents&#39;, &#39;atendofbody&#39;: &#39;&#39;,</span>
<span class="gd">-    &#39;printindex&#39;: &#39;\\printindex&#39;, &#39;transition&#39;:</span>
<span class="gd">-    &quot;&quot;&quot;</span>

<span class="gd">-\\bigskip\\hrule\\bigskip</span>
<span class="gi">+DEFAULT_SETTINGS: dict[str, Any] = {</span>
<span class="gi">+    &#39;latex_engine&#39;:    &#39;pdflatex&#39;,</span>
<span class="gi">+    &#39;papersize&#39;:       &#39;&#39;,</span>
<span class="gi">+    &#39;pointsize&#39;:       &#39;&#39;,</span>
<span class="gi">+    &#39;pxunit&#39;:          &#39;.75bp&#39;,</span>
<span class="gi">+    &#39;classoptions&#39;:    &#39;&#39;,</span>
<span class="gi">+    &#39;extraclassoptions&#39;: &#39;&#39;,</span>
<span class="gi">+    &#39;maxlistdepth&#39;:    &#39;&#39;,</span>
<span class="gi">+    &#39;sphinxpkgoptions&#39;:     &#39;&#39;,</span>
<span class="gi">+    &#39;sphinxsetup&#39;:     &#39;&#39;,</span>
<span class="gi">+    &#39;fvset&#39;:           &#39;\\fvset{fontsize=auto}&#39;,</span>
<span class="gi">+    &#39;passoptionstopackages&#39;: &#39;&#39;,</span>
<span class="gi">+    &#39;geometry&#39;:        &#39;\\usepackage{geometry}&#39;,</span>
<span class="gi">+    &#39;inputenc&#39;:        &#39;&#39;,</span>
<span class="gi">+    &#39;utf8extra&#39;:       &#39;&#39;,</span>
<span class="gi">+    &#39;cmappkg&#39;:         &#39;\\usepackage{cmap}&#39;,</span>
<span class="gi">+    &#39;fontenc&#39;:         &#39;\\usepackage[T1]{fontenc}&#39;,</span>
<span class="gi">+    &#39;amsmath&#39;:         &#39;\\usepackage{amsmath,amssymb,amstext}&#39;,</span>
<span class="gi">+    &#39;multilingual&#39;:    &#39;&#39;,</span>
<span class="gi">+    &#39;babel&#39;:           &#39;\\usepackage{babel}&#39;,</span>
<span class="gi">+    &#39;polyglossia&#39;:     &#39;&#39;,</span>
<span class="gi">+    &#39;fontpkg&#39;:         PDFLATEX_DEFAULT_FONTPKG,</span>
<span class="gi">+    &#39;fontsubstitution&#39;: PDFLATEX_DEFAULT_FONTSUBSTITUTION,</span>
<span class="gi">+    &#39;substitutefont&#39;:  &#39;&#39;,</span>
<span class="gi">+    &#39;textcyrillic&#39;:    &#39;&#39;,</span>
<span class="gi">+    &#39;textgreek&#39;:       &#39;\\usepackage{textalpha}&#39;,</span>
<span class="gi">+    &#39;fncychap&#39;:        &#39;\\usepackage[Bjarne]{fncychap}&#39;,</span>
<span class="gi">+    &#39;hyperref&#39;:        (&#39;% Include hyperref last.\n&#39;</span>
<span class="gi">+                        &#39;\\usepackage{hyperref}\n&#39;</span>
<span class="gi">+                        &#39;% Fix anchor placement for figures with captions.\n&#39;</span>
<span class="gi">+                        &#39;\\usepackage{hypcap}% it must be loaded after hyperref.\n&#39;</span>
<span class="gi">+                        &#39;% Set up styles of URL: it should be placed after hyperref.\n&#39;</span>
<span class="gi">+                        &#39;\\urlstyle{same}&#39;),</span>
<span class="gi">+    &#39;contentsname&#39;:    &#39;&#39;,</span>
<span class="gi">+    &#39;extrapackages&#39;:   &#39;&#39;,</span>
<span class="gi">+    &#39;preamble&#39;:        &#39;&#39;,</span>
<span class="gi">+    &#39;title&#39;:           &#39;&#39;,</span>
<span class="gi">+    &#39;release&#39;:         &#39;&#39;,</span>
<span class="gi">+    &#39;author&#39;:          &#39;&#39;,</span>
<span class="gi">+    &#39;releasename&#39;:     &#39;&#39;,</span>
<span class="gi">+    &#39;makeindex&#39;:       &#39;\\makeindex&#39;,</span>
<span class="gi">+    &#39;shorthandoff&#39;:    &#39;&#39;,</span>
<span class="gi">+    &#39;maketitle&#39;:       &#39;\\sphinxmaketitle&#39;,</span>
<span class="gi">+    &#39;tableofcontents&#39;: &#39;\\sphinxtableofcontents&#39;,</span>
<span class="gi">+    &#39;atendofbody&#39;:     &#39;&#39;,</span>
<span class="gi">+    &#39;printindex&#39;:      &#39;\\printindex&#39;,</span>
<span class="gi">+    &#39;transition&#39;:      &#39;\n\n\\bigskip\\hrule\\bigskip\n\n&#39;,</span>
<span class="gi">+    &#39;figure_align&#39;:    &#39;htbp&#39;,</span>
<span class="gi">+    &#39;tocdepth&#39;:        &#39;&#39;,</span>
<span class="gi">+    &#39;secnumdepth&#39;:     &#39;&#39;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+ADDITIONAL_SETTINGS: dict[Any, dict[str, Any]] = {</span>
<span class="gi">+    &#39;pdflatex&#39;: {</span>
<span class="gi">+        &#39;inputenc&#39;:     &#39;\\usepackage[utf8]{inputenc}&#39;,</span>
<span class="gi">+        &#39;utf8extra&#39;:   (&#39;\\ifdefined\\DeclareUnicodeCharacter\n&#39;</span>
<span class="gi">+                        &#39;% support both utf8 and utf8x syntaxes\n&#39;</span>
<span class="gi">+                        &#39;  \\ifdefined\\DeclareUnicodeCharacterAsOptional\n&#39;</span>
<span class="gi">+                        &#39;    \\def\\sphinxDUC#1{\\DeclareUnicodeCharacter{&quot;#1}}\n&#39;</span>
<span class="gi">+                        &#39;  \\else\n&#39;</span>
<span class="gi">+                        &#39;    \\let\\sphinxDUC\\DeclareUnicodeCharacter\n&#39;</span>
<span class="gi">+                        &#39;  \\fi\n&#39;</span>
<span class="gi">+                        &#39;  \\sphinxDUC{00A0}{\\nobreakspace}\n&#39;</span>
<span class="gi">+                        &#39;  \\sphinxDUC{2500}{\\sphinxunichar{2500}}\n&#39;</span>
<span class="gi">+                        &#39;  \\sphinxDUC{2502}{\\sphinxunichar{2502}}\n&#39;</span>
<span class="gi">+                        &#39;  \\sphinxDUC{2514}{\\sphinxunichar{2514}}\n&#39;</span>
<span class="gi">+                        &#39;  \\sphinxDUC{251C}{\\sphinxunichar{251C}}\n&#39;</span>
<span class="gi">+                        &#39;  \\sphinxDUC{2572}{\\textbackslash}\n&#39;</span>
<span class="gi">+                        &#39;\\fi&#39;),</span>
<span class="gi">+    },</span>
<span class="gi">+    &#39;xelatex&#39;: {</span>
<span class="gi">+        &#39;latex_engine&#39;: &#39;xelatex&#39;,</span>
<span class="gi">+        &#39;polyglossia&#39;:  &#39;\\usepackage{polyglossia}&#39;,</span>
<span class="gi">+        &#39;babel&#39;:        &#39;&#39;,</span>
<span class="gi">+        &#39;fontenc&#39;:     (&#39;\\usepackage{fontspec}\n&#39;</span>
<span class="gi">+                        &#39;\\defaultfontfeatures[\\rmfamily,\\sffamily,\\ttfamily]{}&#39;),</span>
<span class="gi">+        &#39;fontpkg&#39;:      XELATEX_DEFAULT_FONTPKG,</span>
<span class="gi">+        &#39;fvset&#39;:        &#39;\\fvset{fontsize=\\small}&#39;,</span>
<span class="gi">+        &#39;fontsubstitution&#39;: &#39;&#39;,</span>
<span class="gi">+        &#39;textgreek&#39;:    &#39;&#39;,</span>
<span class="gi">+        &#39;utf8extra&#39;:   (&#39;\\catcode`^^^^00a0\\active\\protected\\def^^^^00a0&#39;</span>
<span class="gi">+                        &#39;{\\leavevmode\\nobreak\\ }&#39;),</span>
<span class="gi">+    },</span>
<span class="gi">+    &#39;lualatex&#39;: {</span>
<span class="gi">+        &#39;latex_engine&#39;: &#39;lualatex&#39;,</span>
<span class="gi">+        &#39;polyglossia&#39;:  &#39;\\usepackage{polyglossia}&#39;,</span>
<span class="gi">+        &#39;babel&#39;:        &#39;&#39;,</span>
<span class="gi">+        &#39;fontenc&#39;:     (&#39;\\usepackage{fontspec}\n&#39;</span>
<span class="gi">+                        &#39;\\defaultfontfeatures[\\rmfamily,\\sffamily,\\ttfamily]{}&#39;),</span>
<span class="gi">+        &#39;fontpkg&#39;:      LUALATEX_DEFAULT_FONTPKG,</span>
<span class="gi">+        &#39;fvset&#39;:        &#39;\\fvset{fontsize=\\small}&#39;,</span>
<span class="gi">+        &#39;fontsubstitution&#39;: &#39;&#39;,</span>
<span class="gi">+        &#39;textgreek&#39;:    &#39;&#39;,</span>
<span class="gi">+        &#39;utf8extra&#39;:   (&#39;\\catcode`^^^^00a0\\active\\protected\\def^^^^00a0&#39;</span>
<span class="gi">+                        &#39;{\\leavevmode\\nobreak\\ }&#39;),</span>
<span class="gi">+    },</span>
<span class="gi">+    &#39;platex&#39;: {</span>
<span class="gi">+        &#39;latex_engine&#39;: &#39;platex&#39;,</span>
<span class="gi">+        &#39;babel&#39;:        &#39;&#39;,</span>
<span class="gi">+        &#39;classoptions&#39;: &#39;,dvipdfmx&#39;,</span>
<span class="gi">+        &#39;fontpkg&#39;:      PDFLATEX_DEFAULT_FONTPKG,</span>
<span class="gi">+        &#39;fontsubstitution&#39;: &#39;&#39;,</span>
<span class="gi">+        &#39;textgreek&#39;:    &#39;&#39;,</span>
<span class="gi">+        &#39;fncychap&#39;:     &#39;&#39;,</span>
<span class="gi">+        &#39;geometry&#39;:     &#39;\\usepackage[dvipdfm]{geometry}&#39;,</span>
<span class="gi">+    },</span>
<span class="gi">+    &#39;uplatex&#39;: {</span>
<span class="gi">+        &#39;latex_engine&#39;: &#39;uplatex&#39;,</span>
<span class="gi">+        &#39;babel&#39;:        &#39;&#39;,</span>
<span class="gi">+        &#39;classoptions&#39;: &#39;,dvipdfmx&#39;,</span>
<span class="gi">+        &#39;fontpkg&#39;:      PDFLATEX_DEFAULT_FONTPKG,</span>
<span class="gi">+        &#39;fontsubstitution&#39;: &#39;&#39;,</span>
<span class="gi">+        &#39;textgreek&#39;:    &#39;&#39;,</span>
<span class="gi">+        &#39;fncychap&#39;:     &#39;&#39;,</span>
<span class="gi">+        &#39;geometry&#39;:     &#39;\\usepackage[dvipdfm]{geometry}&#39;,</span>
<span class="gi">+    },</span>
<span class="gi">+</span>
<span class="gi">+    # special settings for latex_engine + language_code</span>
<span class="gi">+    (&#39;lualatex&#39;, &#39;fr&#39;): {</span>
<span class="gi">+        # use babel instead of polyglossia by default</span>
<span class="gi">+        &#39;polyglossia&#39;:  &#39;&#39;,</span>
<span class="gi">+        &#39;babel&#39;:        &#39;\\usepackage{babel}&#39;,</span>
<span class="gi">+    },</span>
<span class="gi">+    (&#39;xelatex&#39;, &#39;fr&#39;): {</span>
<span class="gi">+        # use babel instead of polyglossia by default</span>
<span class="gi">+        &#39;polyglossia&#39;:  &#39;&#39;,</span>
<span class="gi">+        &#39;babel&#39;:        &#39;\\usepackage{babel}&#39;,</span>
<span class="gi">+    },</span>
<span class="gi">+    (&#39;xelatex&#39;, &#39;zh&#39;): {</span>
<span class="gi">+        &#39;polyglossia&#39;:  &#39;&#39;,</span>
<span class="gi">+        &#39;babel&#39;:        &#39;\\usepackage{babel}&#39;,</span>
<span class="gi">+        &#39;fontenc&#39;:      &#39;\\usepackage{xeCJK}&#39;,</span>
<span class="gi">+        # set formatcom=\xeCJKVerbAddon to prevent xeCJK from adding extra spaces in</span>
<span class="gi">+        # fancyvrb Verbatim environment.</span>
<span class="gi">+        &#39;fvset&#39;:        &#39;\\fvset{fontsize=\\small,formatcom=\\xeCJKVerbAddon}&#39;,</span>
<span class="gi">+    },</span>
<span class="gi">+    (&#39;xelatex&#39;, &#39;el&#39;): {</span>
<span class="gi">+        &#39;fontpkg&#39;:      XELATEX_GREEK_DEFAULT_FONTPKG,</span>
<span class="gi">+    },</span>
<span class="gi">+}</span>
<span class="gi">+</span>

<span class="gd">-&quot;&quot;&quot;, &#39;figure_align&#39;: &#39;htbp&#39;, &#39;tocdepth&#39;:</span>
<span class="gd">-    &#39;&#39;, &#39;secnumdepth&#39;: &#39;&#39;}</span>
<span class="gd">-ADDITIONAL_SETTINGS: dict[Any, dict[str, Any]] = {&#39;pdflatex&#39;: {&#39;inputenc&#39;:</span>
<span class="gd">-    &#39;\\usepackage[utf8]{inputenc}&#39;, &#39;utf8extra&#39;:</span>
<span class="gd">-    &quot;&quot;&quot;\\ifdefined\\DeclareUnicodeCharacter</span>
<span class="gd">-% support both utf8 and utf8x syntaxes</span>
<span class="gd">-  \\ifdefined\\DeclareUnicodeCharacterAsOptional</span>
<span class="gd">-    \\def\\sphinxDUC#1{\\DeclareUnicodeCharacter{&quot;#1}}</span>
<span class="gd">-  \\else</span>
<span class="gd">-    \\let\\sphinxDUC\\DeclareUnicodeCharacter</span>
<span class="gd">-  \\fi</span>
<span class="gd">-  \\sphinxDUC{00A0}{\\nobreakspace}</span>
<span class="gd">-  \\sphinxDUC{2500}{\\sphinxunichar{2500}}</span>
<span class="gd">-  \\sphinxDUC{2502}{\\sphinxunichar{2502}}</span>
<span class="gd">-  \\sphinxDUC{2514}{\\sphinxunichar{2514}}</span>
<span class="gd">-  \\sphinxDUC{251C}{\\sphinxunichar{251C}}</span>
<span class="gd">-  \\sphinxDUC{2572}{\\textbackslash}</span>
<span class="gd">-\\fi&quot;&quot;&quot;</span>
<span class="gd">-    }, &#39;xelatex&#39;: {&#39;latex_engine&#39;: &#39;xelatex&#39;, &#39;polyglossia&#39;:</span>
<span class="gd">-    &#39;\\usepackage{polyglossia}&#39;, &#39;babel&#39;: &#39;&#39;, &#39;fontenc&#39;:</span>
<span class="gd">-    &quot;&quot;&quot;\\usepackage{fontspec}</span>
<span class="gd">-\\defaultfontfeatures[\\rmfamily,\\sffamily,\\ttfamily]{}&quot;&quot;&quot;</span>
<span class="gd">-    , &#39;fontpkg&#39;: XELATEX_DEFAULT_FONTPKG, &#39;fvset&#39;:</span>
<span class="gd">-    &#39;\\fvset{fontsize=\\small}&#39;, &#39;fontsubstitution&#39;: &#39;&#39;, &#39;textgreek&#39;: &#39;&#39;,</span>
<span class="gd">-    &#39;utf8extra&#39;:</span>
<span class="gd">-    &#39;\\catcode`^^^^00a0\\active\\protected\\def^^^^00a0{\\leavevmode\\nobreak\\ }&#39;</span>
<span class="gd">-    }, &#39;lualatex&#39;: {&#39;latex_engine&#39;: &#39;lualatex&#39;, &#39;polyglossia&#39;:</span>
<span class="gd">-    &#39;\\usepackage{polyglossia}&#39;, &#39;babel&#39;: &#39;&#39;, &#39;fontenc&#39;:</span>
<span class="gd">-    &quot;&quot;&quot;\\usepackage{fontspec}</span>
<span class="gd">-\\defaultfontfeatures[\\rmfamily,\\sffamily,\\ttfamily]{}&quot;&quot;&quot;</span>
<span class="gd">-    , &#39;fontpkg&#39;: LUALATEX_DEFAULT_FONTPKG, &#39;fvset&#39;:</span>
<span class="gd">-    &#39;\\fvset{fontsize=\\small}&#39;, &#39;fontsubstitution&#39;: &#39;&#39;, &#39;textgreek&#39;: &#39;&#39;,</span>
<span class="gd">-    &#39;utf8extra&#39;:</span>
<span class="gd">-    &#39;\\catcode`^^^^00a0\\active\\protected\\def^^^^00a0{\\leavevmode\\nobreak\\ }&#39;</span>
<span class="gd">-    }, &#39;platex&#39;: {&#39;latex_engine&#39;: &#39;platex&#39;, &#39;babel&#39;: &#39;&#39;, &#39;classoptions&#39;:</span>
<span class="gd">-    &#39;,dvipdfmx&#39;, &#39;fontpkg&#39;: PDFLATEX_DEFAULT_FONTPKG, &#39;fontsubstitution&#39;:</span>
<span class="gd">-    &#39;&#39;, &#39;textgreek&#39;: &#39;&#39;, &#39;fncychap&#39;: &#39;&#39;, &#39;geometry&#39;:</span>
<span class="gd">-    &#39;\\usepackage[dvipdfm]{geometry}&#39;}, &#39;uplatex&#39;: {&#39;latex_engine&#39;:</span>
<span class="gd">-    &#39;uplatex&#39;, &#39;babel&#39;: &#39;&#39;, &#39;classoptions&#39;: &#39;,dvipdfmx&#39;, &#39;fontpkg&#39;:</span>
<span class="gd">-    PDFLATEX_DEFAULT_FONTPKG, &#39;fontsubstitution&#39;: &#39;&#39;, &#39;textgreek&#39;: &#39;&#39;,</span>
<span class="gd">-    &#39;fncychap&#39;: &#39;&#39;, &#39;geometry&#39;: &#39;\\usepackage[dvipdfm]{geometry}&#39;}, (</span>
<span class="gd">-    &#39;lualatex&#39;, &#39;fr&#39;): {&#39;polyglossia&#39;: &#39;&#39;, &#39;babel&#39;: &#39;\\usepackage{babel}&#39;},</span>
<span class="gd">-    (&#39;xelatex&#39;, &#39;fr&#39;): {&#39;polyglossia&#39;: &#39;&#39;, &#39;babel&#39;: &#39;\\usepackage{babel}&#39;},</span>
<span class="gd">-    (&#39;xelatex&#39;, &#39;zh&#39;): {&#39;polyglossia&#39;: &#39;&#39;, &#39;babel&#39;: &#39;\\usepackage{babel}&#39;,</span>
<span class="gd">-    &#39;fontenc&#39;: &#39;\\usepackage{xeCJK}&#39;, &#39;fvset&#39;:</span>
<span class="gd">-    &#39;\\fvset{fontsize=\\small,formatcom=\\xeCJKVerbAddon}&#39;}, (&#39;xelatex&#39;,</span>
<span class="gd">-    &#39;el&#39;): {&#39;fontpkg&#39;: XELATEX_GREEK_DEFAULT_FONTPKG}}</span>
<span class="gd">-SHORTHANDOFF = &quot;&quot;&quot;</span>
<span class="gd">-\\ifdefined\\shorthandoff</span>
<span class="gd">-  \\ifnum\\catcode`\\=\\string=\\active\\shorthandoff{=}\\fi</span>
<span class="gd">-  \\ifnum\\catcode`\\&quot;=\\active\\shorthandoff{&quot;}\\fi</span>
<span class="gd">-\\fi</span>
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gi">+SHORTHANDOFF = r&#39;&#39;&#39;</span>
<span class="gi">+\ifdefined\shorthandoff</span>
<span class="gi">+  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi</span>
<span class="gi">+  \ifnum\catcode`\&quot;=\active\shorthandoff{&quot;}\fi</span>
<span class="gi">+\fi</span>
<span class="gi">+&#39;&#39;&#39;</span>
<span class="gh">diff --git a/sphinx/builders/latex/nodes.py b/sphinx/builders/latex/nodes.py</span>
<span class="gh">index cdf9949a3..68b743d40 100644</span>
<span class="gd">--- a/sphinx/builders/latex/nodes.py</span>
<span class="gi">+++ b/sphinx/builders/latex/nodes.py</span>
<span class="gu">@@ -1,31 +1,41 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Additional nodes for LaTeX writer.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes


<span class="w"> </span>class captioned_literal_block(nodes.container):
<span class="w"> </span>    &quot;&quot;&quot;A node for a container of literal_block having a caption.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class footnotemark(nodes.Inline, nodes.Referential, nodes.TextElement):
<span class="gd">-    &quot;&quot;&quot;A node represents ``\\footnotemark``.&quot;&quot;&quot;</span>
<span class="gi">+    r&quot;&quot;&quot;A node represents ``\footnotemark``.&quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="gd">-class footnotetext(nodes.General, nodes.BackLinkable, nodes.Element, nodes.</span>
<span class="gd">-    Labeled, nodes.Targetable):</span>
<span class="gd">-    &quot;&quot;&quot;A node represents ``\\footnotetext``.&quot;&quot;&quot;</span>
<span class="gi">+class footnotetext(nodes.General, nodes.BackLinkable, nodes.Element,</span>
<span class="gi">+                   nodes.Labeled, nodes.Targetable):</span>
<span class="gi">+    r&quot;&quot;&quot;A node represents ``\footnotetext``.&quot;&quot;&quot;</span>


<span class="w"> </span>class math_reference(nodes.Inline, nodes.Referential, nodes.TextElement):
<span class="w"> </span>    &quot;&quot;&quot;A node for a reference for equation.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class thebibliography(nodes.container):
<span class="w"> </span>    &quot;&quot;&quot;A node for wrapping bibliographies.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="gd">-HYPERLINK_SUPPORT_NODES = (nodes.figure, nodes.literal_block, nodes.table,</span>
<span class="gd">-    nodes.section, captioned_literal_block)</span>
<span class="gi">+HYPERLINK_SUPPORT_NODES = (</span>
<span class="gi">+    nodes.figure,</span>
<span class="gi">+    nodes.literal_block,</span>
<span class="gi">+    nodes.table,</span>
<span class="gi">+    nodes.section,</span>
<span class="gi">+    captioned_literal_block,</span>
<span class="gi">+)</span>
<span class="gh">diff --git a/sphinx/builders/latex/theming.py b/sphinx/builders/latex/theming.py</span>
<span class="gh">index 671dc8ff2..21b49e8ab 100644</span>
<span class="gd">--- a/sphinx/builders/latex/theming.py</span>
<span class="gi">+++ b/sphinx/builders/latex/theming.py</span>
<span class="gu">@@ -1,23 +1,29 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Theming support for LaTeX builder.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import configparser
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from sphinx.errors import ThemeError
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.util import logging
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.config import Config
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="w"> </span>class Theme:
<span class="w"> </span>    &quot;&quot;&quot;A set of LaTeX configurations.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    LATEX_ELEMENTS_KEYS = [&#39;papersize&#39;, &#39;pointsize&#39;]
<span class="w"> </span>    UPDATABLE_KEYS = [&#39;papersize&#39;, &#39;pointsize&#39;]

<span class="gd">-    def __init__(self, name: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, name: str) -&gt; None:</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.docclass = name
<span class="w"> </span>        self.wrapperclass = name
<span class="gu">@@ -25,24 +31,37 @@ class Theme:</span>
<span class="w"> </span>        self.pointsize = &#39;10pt&#39;
<span class="w"> </span>        self.toplevel_sectioning = &#39;chapter&#39;

<span class="gd">-    def update(self, config: Config) -&gt;None:</span>
<span class="gi">+    def update(self, config: Config) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override theme settings by user&#39;s configuration.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for key in self.LATEX_ELEMENTS_KEYS:</span>
<span class="gi">+            if config.latex_elements.get(key):</span>
<span class="gi">+                value = config.latex_elements[key]</span>
<span class="gi">+                setattr(self, key, value)</span>
<span class="gi">+</span>
<span class="gi">+        for key in self.UPDATABLE_KEYS:</span>
<span class="gi">+            if key in config.latex_theme_options:</span>
<span class="gi">+                value = config.latex_theme_options[key]</span>
<span class="gi">+                setattr(self, key, value)</span>


<span class="w"> </span>class BuiltInTheme(Theme):
<span class="w"> </span>    &quot;&quot;&quot;A built-in LaTeX theme.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, name: str, config: Config) -&gt;None:</span>
<span class="gi">+    def __init__(self, name: str, config: Config) -&gt; None:</span>
<span class="w"> </span>        super().__init__(name)
<span class="gi">+</span>
<span class="w"> </span>        if name == &#39;howto&#39;:
<span class="w"> </span>            self.docclass = config.latex_docclass.get(&#39;howto&#39;, &#39;article&#39;)
<span class="w"> </span>        else:
<span class="w"> </span>            self.docclass = config.latex_docclass.get(&#39;manual&#39;, &#39;report&#39;)
<span class="gi">+</span>
<span class="w"> </span>        if name in (&#39;manual&#39;, &#39;howto&#39;):
<span class="w"> </span>            self.wrapperclass = &#39;sphinx&#39; + name
<span class="w"> </span>        else:
<span class="w"> </span>            self.wrapperclass = name
<span class="gi">+</span>
<span class="gi">+        # we assume LaTeX class provides \chapter command except in case</span>
<span class="gi">+        # of non-Japanese &#39;howto&#39; case</span>
<span class="w"> </span>        if name == &#39;howto&#39; and not self.docclass.startswith(&#39;j&#39;):
<span class="w"> </span>            self.toplevel_sectioning = &#39;section&#39;
<span class="w"> </span>        else:
<span class="gu">@@ -51,23 +70,26 @@ class BuiltInTheme(Theme):</span>

<span class="w"> </span>class UserTheme(Theme):
<span class="w"> </span>    &quot;&quot;&quot;A user defined LaTeX theme.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    REQUIRED_CONFIG_KEYS = [&#39;docclass&#39;, &#39;wrapperclass&#39;]
<span class="w"> </span>    OPTIONAL_CONFIG_KEYS = [&#39;papersize&#39;, &#39;pointsize&#39;, &#39;toplevel_sectioning&#39;]

<span class="gd">-    def __init__(self, name: str, filename: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, name: str, filename: str) -&gt; None:</span>
<span class="w"> </span>        super().__init__(name)
<span class="w"> </span>        self.config = configparser.RawConfigParser()
<span class="w"> </span>        self.config.read(path.join(filename), encoding=&#39;utf-8&#39;)
<span class="gi">+</span>
<span class="w"> </span>        for key in self.REQUIRED_CONFIG_KEYS:
<span class="w"> </span>            try:
<span class="w"> </span>                value = self.config.get(&#39;theme&#39;, key)
<span class="w"> </span>                setattr(self, key, value)
<span class="w"> </span>            except configparser.NoSectionError as exc:
<span class="w"> </span>                raise ThemeError(__(&#39;%r doesn\&#39;t have &quot;theme&quot; setting&#39;) %
<span class="gd">-                    filename) from exc</span>
<span class="gi">+                                 filename) from exc</span>
<span class="w"> </span>            except configparser.NoOptionError as exc:
<span class="gd">-                raise ThemeError(__(&#39;%r doesn\&#39;t have &quot;%s&quot; setting&#39;) % (</span>
<span class="gd">-                    filename, exc.args[0])) from exc</span>
<span class="gi">+                raise ThemeError(__(&#39;%r doesn\&#39;t have &quot;%s&quot; setting&#39;) %</span>
<span class="gi">+                                 (filename, exc.args[0])) from exc</span>
<span class="gi">+</span>
<span class="w"> </span>        for key in self.OPTIONAL_CONFIG_KEYS:
<span class="w"> </span>            try:
<span class="w"> </span>                value = self.config.get(&#39;theme&#39;, key)
<span class="gu">@@ -79,21 +101,35 @@ class UserTheme(Theme):</span>
<span class="w"> </span>class ThemeFactory:
<span class="w"> </span>    &quot;&quot;&quot;A factory class for LaTeX Themes.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, app: Sphinx) -&gt;None:</span>
<span class="gi">+    def __init__(self, app: Sphinx) -&gt; None:</span>
<span class="w"> </span>        self.themes: dict[str, Theme] = {}
<span class="gd">-        self.theme_paths = [path.join(app.srcdir, p) for p in app.config.</span>
<span class="gd">-            latex_theme_path]</span>
<span class="gi">+        self.theme_paths = [path.join(app.srcdir, p) for p in app.config.latex_theme_path]</span>
<span class="w"> </span>        self.config = app.config
<span class="w"> </span>        self.load_builtin_themes(app.config)

<span class="gd">-    def load_builtin_themes(self, config: Config) -&gt;None:</span>
<span class="gi">+    def load_builtin_themes(self, config: Config) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Load built-in themes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.themes[&#39;manual&#39;] = BuiltInTheme(&#39;manual&#39;, config)</span>
<span class="gi">+        self.themes[&#39;howto&#39;] = BuiltInTheme(&#39;howto&#39;, config)</span>

<span class="gd">-    def get(self, name: str) -&gt;Theme:</span>
<span class="gi">+    def get(self, name: str) -&gt; Theme:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get a theme for given *name*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if name in self.themes:</span>
<span class="gi">+            theme = self.themes[name]</span>
<span class="gi">+        else:</span>
<span class="gi">+            theme = self.find_user_theme(name) or Theme(name)</span>
<span class="gi">+</span>
<span class="gi">+        theme.update(self.config)</span>
<span class="gi">+        return theme</span>

<span class="gd">-    def find_user_theme(self, name: str) -&gt;(Theme | None):</span>
<span class="gi">+    def find_user_theme(self, name: str) -&gt; Theme | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Find a theme named as *name* from latex_theme_path.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for theme_path in self.theme_paths:</span>
<span class="gi">+            config_path = path.join(theme_path, name, &#39;theme.conf&#39;)</span>
<span class="gi">+            if path.isfile(config_path):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return UserTheme(name, config_path)</span>
<span class="gi">+                except ThemeError as exc:</span>
<span class="gi">+                    logger.warning(exc)</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gh">diff --git a/sphinx/builders/latex/transforms.py b/sphinx/builders/latex/transforms.py</span>
<span class="gh">index 434115b93..c85dce530 100644</span>
<span class="gd">--- a/sphinx/builders/latex/transforms.py</span>
<span class="gi">+++ b/sphinx/builders/latex/transforms.py</span>
<span class="gu">@@ -1,32 +1,57 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Transforms for LaTeX builder.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.transforms.references import Substitutions
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="gd">-from sphinx.builders.latex.nodes import captioned_literal_block, footnotemark, footnotetext, math_reference, thebibliography</span>
<span class="gi">+from sphinx.builders.latex.nodes import (</span>
<span class="gi">+    captioned_literal_block,</span>
<span class="gi">+    footnotemark,</span>
<span class="gi">+    footnotetext,</span>
<span class="gi">+    math_reference,</span>
<span class="gi">+    thebibliography,</span>
<span class="gi">+)</span>
<span class="w"> </span>from sphinx.domains.citation import CitationDomain
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.transforms import SphinxTransform
<span class="w"> </span>from sphinx.transforms.post_transforms import SphinxPostTransform
<span class="w"> </span>from sphinx.util.nodes import NodeMatcher
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.nodes import Element, Node
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gd">-URI_SCHEMES = &#39;mailto:&#39;, &#39;http:&#39;, &#39;https:&#39;, &#39;ftp:&#39;</span>
<span class="gi">+</span>
<span class="gi">+URI_SCHEMES = (&#39;mailto:&#39;, &#39;http:&#39;, &#39;https:&#39;, &#39;ftp:&#39;)</span>


<span class="w"> </span>class FootnoteDocnameUpdater(SphinxTransform):
<span class="w"> </span>    &quot;&quot;&quot;Add docname to footnote and footnote_reference nodes.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    default_priority = 700
<span class="gd">-    TARGET_NODES = nodes.footnote, nodes.footnote_reference</span>
<span class="gi">+    TARGET_NODES = (nodes.footnote, nodes.footnote_reference)</span>
<span class="gi">+</span>
<span class="gi">+    def apply(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        matcher = NodeMatcher(*self.TARGET_NODES)</span>
<span class="gi">+        for node in matcher.findall(self.document):</span>
<span class="gi">+            node[&#39;docname&#39;] = self.env.docname</span>


<span class="w"> </span>class SubstitutionDefinitionsRemover(SphinxPostTransform):
<span class="w"> </span>    &quot;&quot;&quot;Remove ``substitution_definition`` nodes from doctrees.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # should be invoked after Substitutions process</span>
<span class="w"> </span>    default_priority = Substitutions.default_priority + 1
<span class="gd">-    formats = &#39;latex&#39;,</span>
<span class="gi">+    formats = (&#39;latex&#39;,)</span>
<span class="gi">+</span>
<span class="gi">+    def run(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        for node in list(self.document.findall(nodes.substitution_definition)):</span>
<span class="gi">+            node.parent.remove(node)</span>


<span class="w"> </span>class ShowUrlsTransform(SphinxPostTransform):
<span class="gu">@@ -36,20 +61,136 @@ class ShowUrlsTransform(SphinxPostTransform):</span>

<span class="w"> </span>    .. note:: This transform is used for integrated doctree
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    default_priority = 400
<span class="gd">-    formats = &#39;latex&#39;,</span>
<span class="gi">+    formats = (&#39;latex&#39;,)</span>
<span class="gi">+</span>
<span class="gi">+    # references are expanded to footnotes (or not)</span>
<span class="w"> </span>    expanded = False

<span class="gi">+    def run(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            # replace id_prefix temporarily</span>
<span class="gi">+            settings: Any = self.document.settings</span>
<span class="gi">+            id_prefix = settings.id_prefix</span>
<span class="gi">+            settings.id_prefix = &#39;show_urls&#39;</span>
<span class="gi">+</span>
<span class="gi">+            self.expand_show_urls()</span>
<span class="gi">+            if self.expanded:</span>
<span class="gi">+                self.renumber_footnotes()</span>
<span class="gi">+        finally:</span>
<span class="gi">+            # restore id_prefix</span>
<span class="gi">+            settings.id_prefix = id_prefix</span>
<span class="gi">+</span>
<span class="gi">+    def expand_show_urls(self) -&gt; None:</span>
<span class="gi">+        show_urls = self.config.latex_show_urls</span>
<span class="gi">+        if show_urls is False or show_urls == &#39;no&#39;:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        for node in list(self.document.findall(nodes.reference)):</span>
<span class="gi">+            uri = node.get(&#39;refuri&#39;, &#39;&#39;)</span>
<span class="gi">+            if uri.startswith(URI_SCHEMES):</span>
<span class="gi">+                if uri.startswith(&#39;mailto:&#39;):</span>
<span class="gi">+                    uri = uri[7:]</span>
<span class="gi">+                if node.astext() != uri:</span>
<span class="gi">+                    index = node.parent.index(node)</span>
<span class="gi">+                    docname = self.get_docname_for_node(node)</span>
<span class="gi">+                    if show_urls == &#39;footnote&#39;:</span>
<span class="gi">+                        fn, fnref = self.create_footnote(uri, docname)</span>
<span class="gi">+                        node.parent.insert(index + 1, fn)</span>
<span class="gi">+                        node.parent.insert(index + 2, fnref)</span>
<span class="gi">+</span>
<span class="gi">+                        self.expanded = True</span>
<span class="gi">+                    else:  # all other true values (b/w compat)</span>
<span class="gi">+                        textnode = nodes.Text(&quot; (%s)&quot; % uri)</span>
<span class="gi">+                        node.parent.insert(index + 1, textnode)</span>
<span class="gi">+</span>
<span class="gi">+    def get_docname_for_node(self, node: Node) -&gt; str:</span>
<span class="gi">+        while node:</span>
<span class="gi">+            if isinstance(node, nodes.document):</span>
<span class="gi">+                return self.env.path2doc(node[&#39;source&#39;]) or &#39;&#39;</span>
<span class="gi">+            elif isinstance(node, addnodes.start_of_file):</span>
<span class="gi">+                return node[&#39;docname&#39;]</span>
<span class="gi">+            else:</span>
<span class="gi">+                node = node.parent</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            source = node[&#39;source&#39;]</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            raise ValueError(__(&#39;Failed to get a docname!&#39;)) from None</span>
<span class="gi">+        raise ValueError(__(&#39;Failed to get a docname &#39;</span>
<span class="gi">+                            &#39;for source {source!r}!&#39;).format(source=source))</span>
<span class="gi">+</span>
<span class="gi">+    def create_footnote(</span>
<span class="gi">+        self, uri: str, docname: str,</span>
<span class="gi">+    ) -&gt; tuple[nodes.footnote, nodes.footnote_reference]:</span>
<span class="gi">+        reference = nodes.reference(&#39;&#39;, nodes.Text(uri), refuri=uri, nolinkurl=True)</span>
<span class="gi">+        footnote = nodes.footnote(uri, auto=1, docname=docname)</span>
<span class="gi">+        footnote[&#39;names&#39;].append(&#39;#&#39;)</span>
<span class="gi">+        footnote += nodes.label(&#39;&#39;, &#39;#&#39;)</span>
<span class="gi">+        footnote += nodes.paragraph(&#39;&#39;, &#39;&#39;, reference)</span>
<span class="gi">+        self.document.note_autofootnote(footnote)</span>
<span class="gi">+</span>
<span class="gi">+        footnote_ref = nodes.footnote_reference(&#39;[#]_&#39;, auto=1,</span>
<span class="gi">+                                                refid=footnote[&#39;ids&#39;][0], docname=docname)</span>
<span class="gi">+        footnote_ref += nodes.Text(&#39;#&#39;)</span>
<span class="gi">+        self.document.note_autofootnote_ref(footnote_ref)</span>
<span class="gi">+        footnote.add_backref(footnote_ref[&#39;ids&#39;][0])</span>
<span class="gi">+</span>
<span class="gi">+        return footnote, footnote_ref</span>
<span class="gi">+</span>
<span class="gi">+    def renumber_footnotes(self) -&gt; None:</span>
<span class="gi">+        collector = FootnoteCollector(self.document)</span>
<span class="gi">+        self.document.walkabout(collector)</span>
<span class="gi">+</span>
<span class="gi">+        num = 0</span>
<span class="gi">+        for footnote in collector.auto_footnotes:</span>
<span class="gi">+            # search unused footnote number</span>
<span class="gi">+            while True:</span>
<span class="gi">+                num += 1</span>
<span class="gi">+                if str(num) not in collector.used_footnote_numbers:</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+            # assign new footnote number</span>
<span class="gi">+            old_label = cast(nodes.label, footnote[0])</span>
<span class="gi">+            old_label.replace_self(nodes.label(&#39;&#39;, str(num)))</span>
<span class="gi">+            if old_label in footnote[&#39;names&#39;]:</span>
<span class="gi">+                footnote[&#39;names&#39;].remove(old_label.astext())</span>
<span class="gi">+            footnote[&#39;names&#39;].append(str(num))</span>
<span class="gi">+</span>
<span class="gi">+            # update footnote_references by new footnote number</span>
<span class="gi">+            docname = footnote[&#39;docname&#39;]</span>
<span class="gi">+            for ref in collector.footnote_refs:</span>
<span class="gi">+                if docname == ref[&#39;docname&#39;] and footnote[&#39;ids&#39;][0] == ref[&#39;refid&#39;]:</span>
<span class="gi">+                    ref.remove(ref[0])</span>
<span class="gi">+                    ref += nodes.Text(str(num))</span>
<span class="gi">+</span>

<span class="w"> </span>class FootnoteCollector(nodes.NodeVisitor):
<span class="w"> </span>    &quot;&quot;&quot;Collect footnotes and footnote references on the document&quot;&quot;&quot;

<span class="gd">-    def __init__(self, document: nodes.document) -&gt;None:</span>
<span class="gi">+    def __init__(self, document: nodes.document) -&gt; None:</span>
<span class="w"> </span>        self.auto_footnotes: list[nodes.footnote] = []
<span class="w"> </span>        self.used_footnote_numbers: set[str] = set()
<span class="w"> </span>        self.footnote_refs: list[nodes.footnote_reference] = []
<span class="w"> </span>        super().__init__(document)

<span class="gi">+    def unknown_visit(self, node: Node) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def unknown_departure(self, node: Node) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_footnote(self, node: nodes.footnote) -&gt; None:</span>
<span class="gi">+        if node.get(&#39;auto&#39;):</span>
<span class="gi">+            self.auto_footnotes.append(node)</span>
<span class="gi">+        else:</span>
<span class="gi">+            for name in node[&#39;names&#39;]:</span>
<span class="gi">+                self.used_footnote_numbers.add(name)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_footnote_reference(self, node: nodes.footnote_reference) -&gt; None:</span>
<span class="gi">+        self.footnote_refs.append(node)</span>
<span class="gi">+</span>

<span class="w"> </span>class LaTeXFootnoteTransform(SphinxPostTransform):
<span class="w"> </span>    &quot;&quot;&quot;Convert footnote definitions and references to appropriate form to LaTeX.
<span class="gu">@@ -216,14 +357,21 @@ class LaTeXFootnoteTransform(SphinxPostTransform):</span>
<span class="w"> </span>                      &lt;row&gt;
<span class="w"> </span>                      ...
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    default_priority = 600
<span class="gd">-    formats = &#39;latex&#39;,</span>
<span class="gi">+    formats = (&#39;latex&#39;,)</span>

<span class="gi">+    def run(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        footnotes = list(self.document.findall(nodes.footnote))</span>
<span class="gi">+        for node in footnotes:</span>
<span class="gi">+            node.parent.remove(node)</span>
<span class="gi">+</span>
<span class="gi">+        visitor = LaTeXFootnoteVisitor(self.document, footnotes)</span>
<span class="gi">+        self.document.walkabout(visitor)</span>

<span class="gd">-class LaTeXFootnoteVisitor(nodes.NodeVisitor):</span>

<span class="gd">-    def __init__(self, document: nodes.document, footnotes: list[nodes.</span>
<span class="gd">-        footnote]) -&gt;None:</span>
<span class="gi">+class LaTeXFootnoteVisitor(nodes.NodeVisitor):</span>
<span class="gi">+    def __init__(self, document: nodes.document, footnotes: list[nodes.footnote]) -&gt; None:</span>
<span class="w"> </span>        self.appeared: dict[tuple[str, str], nodes.footnote] = {}
<span class="w"> </span>        self.footnotes: list[nodes.footnote] = footnotes
<span class="w"> </span>        self.pendings: list[nodes.footnote] = []
<span class="gu">@@ -231,6 +379,108 @@ class LaTeXFootnoteVisitor(nodes.NodeVisitor):</span>
<span class="w"> </span>        self.restricted: Element | None = None
<span class="w"> </span>        super().__init__(document)

<span class="gi">+    def unknown_visit(self, node: Node) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def unknown_departure(self, node: Node) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def restrict(self, node: Element) -&gt; None:</span>
<span class="gi">+        if self.restricted is None:</span>
<span class="gi">+            self.restricted = node</span>
<span class="gi">+</span>
<span class="gi">+    def unrestrict(self, node: Element) -&gt; None:</span>
<span class="gi">+        if self.restricted == node:</span>
<span class="gi">+            self.restricted = None</span>
<span class="gi">+            pos = node.parent.index(node)</span>
<span class="gi">+            for i, footnote, in enumerate(self.pendings):</span>
<span class="gi">+                fntext = footnotetext(&#39;&#39;, *footnote.children, ids=footnote[&#39;ids&#39;])</span>
<span class="gi">+                node.parent.insert(pos + i + 1, fntext)</span>
<span class="gi">+            self.pendings = []</span>
<span class="gi">+</span>
<span class="gi">+    def visit_figure(self, node: nodes.figure) -&gt; None:</span>
<span class="gi">+        self.restrict(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_figure(self, node: nodes.figure) -&gt; None:</span>
<span class="gi">+        self.unrestrict(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_term(self, node: nodes.term) -&gt; None:</span>
<span class="gi">+        self.restrict(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_term(self, node: nodes.term) -&gt; None:</span>
<span class="gi">+        self.unrestrict(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_caption(self, node: nodes.caption) -&gt; None:</span>
<span class="gi">+        self.restrict(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_caption(self, node: nodes.caption) -&gt; None:</span>
<span class="gi">+        self.unrestrict(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_title(self, node: nodes.title) -&gt; None:</span>
<span class="gi">+        if isinstance(node.parent, nodes.section | nodes.table):</span>
<span class="gi">+            self.restrict(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_title(self, node: nodes.title) -&gt; None:</span>
<span class="gi">+        if isinstance(node.parent, nodes.section):</span>
<span class="gi">+            self.unrestrict(node)</span>
<span class="gi">+        elif isinstance(node.parent, nodes.table):</span>
<span class="gi">+            self.table_footnotes += self.pendings</span>
<span class="gi">+            self.pendings = []</span>
<span class="gi">+            self.unrestrict(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_thead(self, node: nodes.thead) -&gt; None:</span>
<span class="gi">+        self.restrict(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_thead(self, node: nodes.thead) -&gt; None:</span>
<span class="gi">+        self.table_footnotes += self.pendings</span>
<span class="gi">+        self.pendings = []</span>
<span class="gi">+        self.unrestrict(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_table(self, node: nodes.table) -&gt; None:</span>
<span class="gi">+        tbody = next(node.findall(nodes.tbody))</span>
<span class="gi">+        for footnote in reversed(self.table_footnotes):</span>
<span class="gi">+            fntext = footnotetext(&#39;&#39;, *footnote.children, ids=footnote[&#39;ids&#39;])</span>
<span class="gi">+            tbody.insert(0, fntext)</span>
<span class="gi">+</span>
<span class="gi">+        self.table_footnotes = []</span>
<span class="gi">+</span>
<span class="gi">+    def visit_footnote(self, node: nodes.footnote) -&gt; None:</span>
<span class="gi">+        self.restrict(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_footnote(self, node: nodes.footnote) -&gt; None:</span>
<span class="gi">+        self.unrestrict(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_footnote_reference(self, node: nodes.footnote_reference) -&gt; None:</span>
<span class="gi">+        number = node.astext().strip()</span>
<span class="gi">+        docname = node[&#39;docname&#39;]</span>
<span class="gi">+        if (docname, number) in self.appeared:</span>
<span class="gi">+            footnote = self.appeared[(docname, number)]</span>
<span class="gi">+            footnote[&quot;referred&quot;] = True</span>
<span class="gi">+</span>
<span class="gi">+            mark = footnotemark(&#39;&#39;, number, refid=node[&#39;refid&#39;])</span>
<span class="gi">+            node.replace_self(mark)</span>
<span class="gi">+        else:</span>
<span class="gi">+            footnote = self.get_footnote_by_reference(node)</span>
<span class="gi">+            if self.restricted:</span>
<span class="gi">+                mark = footnotemark(&#39;&#39;, number, refid=node[&#39;refid&#39;])</span>
<span class="gi">+                node.replace_self(mark)</span>
<span class="gi">+                self.pendings.append(footnote)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.footnotes.remove(footnote)</span>
<span class="gi">+                node.replace_self(footnote)</span>
<span class="gi">+                footnote.walkabout(self)</span>
<span class="gi">+</span>
<span class="gi">+            self.appeared[(docname, number)] = footnote</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def get_footnote_by_reference(self, node: nodes.footnote_reference) -&gt; nodes.footnote:</span>
<span class="gi">+        docname = node[&#39;docname&#39;]</span>
<span class="gi">+        for footnote in self.footnotes:</span>
<span class="gi">+            if docname == footnote[&#39;docname&#39;] and footnote[&#39;ids&#39;][0] == node[&#39;refid&#39;]:</span>
<span class="gi">+                return footnote</span>
<span class="gi">+</span>
<span class="gi">+        raise ValueError(__(&#39;No footnote was found for given reference node %r&#39;) % node)</span>
<span class="gi">+</span>

<span class="w"> </span>class BibliographyTransform(SphinxPostTransform):
<span class="w"> </span>    &quot;&quot;&quot;Gather bibliography entries to tail of document.
<span class="gu">@@ -262,8 +512,18 @@ class BibliographyTransform(SphinxPostTransform):</span>
<span class="w"> </span>                &lt;citation&gt;
<span class="w"> </span>                    ...
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    default_priority = 750
<span class="gd">-    formats = &#39;latex&#39;,</span>
<span class="gi">+    formats = (&#39;latex&#39;,)</span>
<span class="gi">+</span>
<span class="gi">+    def run(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        citations = thebibliography()</span>
<span class="gi">+        for node in list(self.document.findall(nodes.citation)):</span>
<span class="gi">+            node.parent.remove(node)</span>
<span class="gi">+            citations += node</span>
<span class="gi">+</span>
<span class="gi">+        if len(citations) &gt; 0:</span>
<span class="gi">+            self.document += citations  # type: ignore[attr-defined]</span>


<span class="w"> </span>class CitationReferenceTransform(SphinxPostTransform):
<span class="gu">@@ -272,8 +532,19 @@ class CitationReferenceTransform(SphinxPostTransform):</span>
<span class="w"> </span>    To handle citation reference easily on LaTeX writer, this converts
<span class="w"> </span>    pending_xref nodes to citation_reference.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_priority = 5</span>
<span class="gd">-    formats = &#39;latex&#39;,</span>
<span class="gi">+</span>
<span class="gi">+    default_priority = 5  # before ReferencesResolver</span>
<span class="gi">+    formats = (&#39;latex&#39;,)</span>
<span class="gi">+</span>
<span class="gi">+    def run(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        domain = cast(CitationDomain, self.env.get_domain(&#39;citation&#39;))</span>
<span class="gi">+        matcher = NodeMatcher(addnodes.pending_xref, refdomain=&#39;citation&#39;, reftype=&#39;ref&#39;)</span>
<span class="gi">+        for node in matcher.findall(self.document):</span>
<span class="gi">+            docname, labelid, _ = domain.citations.get(node[&#39;reftarget&#39;], (&#39;&#39;, &#39;&#39;, 0))</span>
<span class="gi">+            if docname:</span>
<span class="gi">+                citation_ref = nodes.citation_reference(&#39;&#39;, &#39;&#39;, *node.children,</span>
<span class="gi">+                                                        docname=docname, refname=labelid)</span>
<span class="gi">+                node.replace_self(citation_ref)</span>


<span class="w"> </span>class MathReferenceTransform(SphinxPostTransform):
<span class="gu">@@ -282,27 +553,51 @@ class MathReferenceTransform(SphinxPostTransform):</span>
<span class="w"> </span>    To handle math reference easily on LaTeX writer, this converts pending_xref
<span class="w"> </span>    nodes to math_reference.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_priority = 5</span>
<span class="gd">-    formats = &#39;latex&#39;,</span>
<span class="gi">+</span>
<span class="gi">+    default_priority = 5  # before ReferencesResolver</span>
<span class="gi">+    formats = (&#39;latex&#39;,)</span>
<span class="gi">+</span>
<span class="gi">+    def run(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        equations = self.env.get_domain(&#39;math&#39;).data[&#39;objects&#39;]</span>
<span class="gi">+        for node in self.document.findall(addnodes.pending_xref):</span>
<span class="gi">+            if node[&#39;refdomain&#39;] == &#39;math&#39; and node[&#39;reftype&#39;] in (&#39;eq&#39;, &#39;numref&#39;):</span>
<span class="gi">+                docname, _ = equations.get(node[&#39;reftarget&#39;], (None, None))</span>
<span class="gi">+                if docname:</span>
<span class="gi">+                    refnode = math_reference(&#39;&#39;, docname=docname, target=node[&#39;reftarget&#39;])</span>
<span class="gi">+                    node.replace_self(refnode)</span>


<span class="w"> </span>class LiteralBlockTransform(SphinxPostTransform):
<span class="w"> </span>    &quot;&quot;&quot;Replace container nodes for literal_block by captioned_literal_block.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    default_priority = 400
<span class="gd">-    formats = &#39;latex&#39;,</span>
<span class="gi">+    formats = (&#39;latex&#39;,)</span>
<span class="gi">+</span>
<span class="gi">+    def run(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        matcher = NodeMatcher(nodes.container, literal_block=True)</span>
<span class="gi">+        for node in matcher.findall(self.document):</span>
<span class="gi">+            newnode = captioned_literal_block(&#39;&#39;, *node.children, **node.attributes)</span>
<span class="gi">+            node.replace_self(newnode)</span>


<span class="w"> </span>class DocumentTargetTransform(SphinxPostTransform):
<span class="w"> </span>    &quot;&quot;&quot;Add :doc label to the first section of each document.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    default_priority = 400
<span class="gd">-    formats = &#39;latex&#39;,</span>
<span class="gi">+    formats = (&#39;latex&#39;,)</span>
<span class="gi">+</span>
<span class="gi">+    def run(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        for node in self.document.findall(addnodes.start_of_file):</span>
<span class="gi">+            section = node.next_node(nodes.section)</span>
<span class="gi">+            if section:</span>
<span class="gi">+                section[&#39;ids&#39;].append(&#39;:doc&#39;)  # special label for :doc:</span>


<span class="w"> </span>class IndexInSectionTitleTransform(SphinxPostTransform):
<span class="gd">-    &quot;&quot;&quot;Move index nodes in section title to outside of the title.</span>
<span class="gi">+    r&quot;&quot;&quot;Move index nodes in section title to outside of the title.</span>

<span class="w"> </span>    LaTeX index macro is not compatible with some handling of section titles
<span class="gd">-    such as uppercasing done on LaTeX side (cf. fncychap handling of ``\\chapter``).</span>
<span class="gi">+    such as uppercasing done on LaTeX side (cf. fncychap handling of ``\chapter``).</span>
<span class="w"> </span>    Moving the index node to after the title node fixes that.

<span class="w"> </span>    Before::
<span class="gu">@@ -324,5 +619,33 @@ class IndexInSectionTitleTransform(SphinxPostTransform):</span>
<span class="w"> </span>                blah blah blah
<span class="w"> </span>            ...
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    default_priority = 400
<span class="gd">-    formats = &#39;latex&#39;,</span>
<span class="gi">+    formats = (&#39;latex&#39;,)</span>
<span class="gi">+</span>
<span class="gi">+    def run(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        for node in list(self.document.findall(nodes.title)):</span>
<span class="gi">+            if isinstance(node.parent, nodes.section):</span>
<span class="gi">+                for i, index in enumerate(node.findall(addnodes.index)):</span>
<span class="gi">+                    # move the index node next to the section title</span>
<span class="gi">+                    node.remove(index)</span>
<span class="gi">+                    node.parent.insert(i + 1, index)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_transform(FootnoteDocnameUpdater)</span>
<span class="gi">+    app.add_post_transform(SubstitutionDefinitionsRemover)</span>
<span class="gi">+    app.add_post_transform(BibliographyTransform)</span>
<span class="gi">+    app.add_post_transform(CitationReferenceTransform)</span>
<span class="gi">+    app.add_post_transform(DocumentTargetTransform)</span>
<span class="gi">+    app.add_post_transform(IndexInSectionTitleTransform)</span>
<span class="gi">+    app.add_post_transform(LaTeXFootnoteTransform)</span>
<span class="gi">+    app.add_post_transform(LiteralBlockTransform)</span>
<span class="gi">+    app.add_post_transform(MathReferenceTransform)</span>
<span class="gi">+    app.add_post_transform(ShowUrlsTransform)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/builders/latex/util.py b/sphinx/builders/latex/util.py</span>
<span class="gh">index b909a8426..aeef26014 100644</span>
<span class="gd">--- a/sphinx/builders/latex/util.py</span>
<span class="gi">+++ b/sphinx/builders/latex/util.py</span>
<span class="gu">@@ -1,18 +1,48 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Utilities for LaTeX builder.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from docutils.writers.latex2e import Babel


<span class="w"> </span>class ExtBabel(Babel):
<span class="gd">-    cyrillic_languages = (&#39;bulgarian&#39;, &#39;kazakh&#39;, &#39;mongolian&#39;, &#39;russian&#39;,</span>
<span class="gd">-        &#39;ukrainian&#39;)</span>
<span class="gi">+    cyrillic_languages = (&#39;bulgarian&#39;, &#39;kazakh&#39;, &#39;mongolian&#39;, &#39;russian&#39;, &#39;ukrainian&#39;)</span>

<span class="gd">-    def __init__(self, language_code: str, use_polyglossia: bool=False) -&gt;None:</span>
<span class="gi">+    def __init__(self, language_code: str, use_polyglossia: bool = False) -&gt; None:</span>
<span class="w"> </span>        self.language_code = language_code
<span class="w"> </span>        self.use_polyglossia = use_polyglossia
<span class="w"> </span>        self.supported = True
<span class="w"> </span>        super().__init__(language_code)

<span class="gd">-    def get_mainlanguage_options(self) -&gt;(str | None):</span>
<span class="gd">-        &quot;&quot;&quot;Return options for polyglossia&#39;s ``\\setmainlanguage``.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def uses_cyrillic(self) -&gt; bool:</span>
<span class="gi">+        return self.language in self.cyrillic_languages</span>
<span class="gi">+</span>
<span class="gi">+    def is_supported_language(self) -&gt; bool:</span>
<span class="gi">+        return self.supported</span>
<span class="gi">+</span>
<span class="gi">+    def language_name(self, language_code: str) -&gt; str:</span>
<span class="gi">+        language = super().language_name(language_code)</span>
<span class="gi">+        if language == &#39;ngerman&#39; and self.use_polyglossia:</span>
<span class="gi">+            # polyglossia calls new orthography (Neue Rechtschreibung) as</span>
<span class="gi">+            # german (with new spelling option).</span>
<span class="gi">+            return &#39;german&#39;</span>
<span class="gi">+        elif language:</span>
<span class="gi">+            return language</span>
<span class="gi">+        elif language_code.startswith(&#39;zh&#39;):</span>
<span class="gi">+            return &#39;english&#39;  # fallback to english (behaves like supported)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.supported = False</span>
<span class="gi">+            return &#39;english&#39;  # fallback to english</span>
<span class="gi">+</span>
<span class="gi">+    def get_mainlanguage_options(self) -&gt; str | None:</span>
<span class="gi">+        r&quot;&quot;&quot;Return options for polyglossia&#39;s ``\setmainlanguage``.&quot;&quot;&quot;</span>
<span class="gi">+        if self.use_polyglossia is False:</span>
<span class="gi">+            return None</span>
<span class="gi">+        elif self.language == &#39;german&#39;:</span>
<span class="gi">+            language = super().language_name(self.language_code)</span>
<span class="gi">+            if language == &#39;ngerman&#39;:</span>
<span class="gi">+                return &#39;spelling=new&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                return &#39;spelling=old&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gh">diff --git a/sphinx/builders/linkcheck.py b/sphinx/builders/linkcheck.py</span>
<span class="gh">index 14686b733..e9b07164e 100644</span>
<span class="gd">--- a/sphinx/builders/linkcheck.py</span>
<span class="gi">+++ b/sphinx/builders/linkcheck.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The CheckExternalLinksBuilder class.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import contextlib
<span class="w"> </span>import json
<span class="w"> </span>import re
<span class="gu">@@ -11,9 +13,11 @@ from queue import PriorityQueue, Queue</span>
<span class="w"> </span>from threading import Thread
<span class="w"> </span>from typing import TYPE_CHECKING, NamedTuple, cast
<span class="w"> </span>from urllib.parse import quote, unquote, urlparse, urlsplit, urlunparse
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from requests.exceptions import ConnectionError, HTTPError, SSLError, TooManyRedirects
<span class="w"> </span>from requests.exceptions import Timeout as RequestTimeout
<span class="gi">+</span>
<span class="w"> </span>from sphinx.builders.dummy import DummyBuilder
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.transforms.post_transforms import SphinxPostTransform
<span class="gu">@@ -21,18 +25,25 @@ from sphinx.util import encode_uri, logging, requests</span>
<span class="w"> </span>from sphinx.util.console import darkgray, darkgreen, purple, red, turquoise
<span class="w"> </span>from sphinx.util.http_date import rfc1123_to_epoch
<span class="w"> </span>from sphinx.util.nodes import get_node_line
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Callable, Iterator
<span class="w"> </span>    from typing import Any
<span class="gi">+</span>
<span class="w"> </span>    from requests import Response
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.config import Config
<span class="w"> </span>    from sphinx.util._pathlib import _StrPath
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gd">-uri_re = re.compile(&#39;([a-z]+:)?//&#39;)</span>
<span class="gd">-DEFAULT_REQUEST_HEADERS = {&#39;Accept&#39;:</span>
<span class="gd">-    &#39;text/html,application/xhtml+xml;q=0.9,*/*;q=0.8&#39;}</span>
<span class="gi">+</span>
<span class="gi">+uri_re = re.compile(&#39;([a-z]+:)?//&#39;)  # matches to foo:// and // (a protocol relative URL)</span>
<span class="gi">+</span>
<span class="gi">+DEFAULT_REQUEST_HEADERS = {</span>
<span class="gi">+    &#39;Accept&#39;: &#39;text/html,application/xhtml+xml;q=0.9,*/*;q=0.8&#39;,</span>
<span class="gi">+}</span>
<span class="w"> </span>CHECK_IMMEDIATELY = 0
<span class="w"> </span>QUEUE_POLL_SECS = 1
<span class="w"> </span>DEFAULT_DELAY = 60.0
<span class="gu">@@ -42,16 +53,118 @@ class CheckExternalLinksBuilder(DummyBuilder):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Checks for broken external links.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name = &#39;linkcheck&#39;
<span class="gd">-    epilog = __(</span>
<span class="gd">-        &#39;Look for any errors in the above output or in %(outdir)s/output.txt&#39;)</span>
<span class="gi">+    epilog = __(&#39;Look for any errors in the above output or in &#39;</span>
<span class="gi">+                &#39;%(outdir)s/output.txt&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def init(self) -&gt; None:</span>
<span class="gi">+        self.broken_hyperlinks = 0</span>
<span class="gi">+        self.timed_out_hyperlinks = 0</span>
<span class="gi">+        self.hyperlinks: dict[str, Hyperlink] = {}</span>
<span class="gi">+        # set a timeout for non-responding servers</span>
<span class="gi">+        socket.setdefaulttimeout(5.0)</span>
<span class="gi">+</span>
<span class="gi">+    def finish(self) -&gt; None:</span>
<span class="gi">+        checker = HyperlinkAvailabilityChecker(self.config)</span>
<span class="gi">+        logger.info(&#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        output_text = path.join(self.outdir, &#39;output.txt&#39;)</span>
<span class="gi">+        output_json = path.join(self.outdir, &#39;output.json&#39;)</span>
<span class="gi">+        with open(output_text, &#39;w&#39;, encoding=&#39;utf-8&#39;) as self.txt_outfile, \</span>
<span class="gi">+             open(output_json, &#39;w&#39;, encoding=&#39;utf-8&#39;) as self.json_outfile:</span>
<span class="gi">+            for result in checker.check(self.hyperlinks):</span>
<span class="gi">+                self.process_result(result)</span>
<span class="gi">+</span>
<span class="gi">+        if self.broken_hyperlinks or self.timed_out_hyperlinks:</span>
<span class="gi">+            self.app.statuscode = 1</span>
<span class="gi">+</span>
<span class="gi">+    def process_result(self, result: CheckResult) -&gt; None:</span>
<span class="gi">+        filename = self.env.doc2path(result.docname, False)</span>
<span class="gi">+</span>
<span class="gi">+        linkstat: dict[str, str | int] = {</span>
<span class="gi">+            &#39;filename&#39;: str(filename), &#39;lineno&#39;: result.lineno,</span>
<span class="gi">+            &#39;status&#39;: result.status, &#39;code&#39;: result.code,</span>
<span class="gi">+            &#39;uri&#39;: result.uri, &#39;info&#39;: result.message,</span>
<span class="gi">+        }</span>
<span class="gi">+        self.write_linkstat(linkstat)</span>
<span class="gi">+</span>
<span class="gi">+        if result.status == &#39;unchecked&#39;:</span>
<span class="gi">+            return</span>
<span class="gi">+        if result.status == &#39;working&#39; and result.message == &#39;old&#39;:</span>
<span class="gi">+            return</span>
<span class="gi">+        if result.lineno:</span>
<span class="gi">+            logger.info(&#39;(%16s: line %4d) &#39;, result.docname, result.lineno, nonl=True)</span>
<span class="gi">+        if result.status == &#39;ignored&#39;:</span>
<span class="gi">+            if result.message:</span>
<span class="gi">+                logger.info(darkgray(&#39;-ignored- &#39;) + result.uri + &#39;: &#39; + result.message)</span>
<span class="gi">+            else:</span>
<span class="gi">+                logger.info(darkgray(&#39;-ignored- &#39;) + result.uri)</span>
<span class="gi">+        elif result.status == &#39;local&#39;:</span>
<span class="gi">+            logger.info(darkgray(&#39;-local-   &#39;) + result.uri)</span>
<span class="gi">+            self.write_entry(&#39;local&#39;, result.docname, filename, result.lineno, result.uri)</span>
<span class="gi">+        elif result.status == &#39;working&#39;:</span>
<span class="gi">+            logger.info(darkgreen(&#39;ok        &#39;) + result.uri + result.message)</span>
<span class="gi">+        elif result.status == &#39;timeout&#39;:</span>
<span class="gi">+            if self.app.quiet:</span>
<span class="gi">+                logger.warning(&#39;timeout   &#39; + result.uri + result.message,</span>
<span class="gi">+                               location=(result.docname, result.lineno))</span>
<span class="gi">+            else:</span>
<span class="gi">+                logger.info(red(&#39;timeout   &#39;) + result.uri + red(&#39; - &#39; + result.message))</span>
<span class="gi">+            self.write_entry(&#39;timeout&#39;, result.docname, filename, result.lineno,</span>
<span class="gi">+                             result.uri + &#39;: &#39; + result.message)</span>
<span class="gi">+            self.timed_out_hyperlinks += 1</span>
<span class="gi">+        elif result.status == &#39;broken&#39;:</span>
<span class="gi">+            if self.app.quiet:</span>
<span class="gi">+                logger.warning(__(&#39;broken link: %s (%s)&#39;), result.uri, result.message,</span>
<span class="gi">+                               location=(result.docname, result.lineno))</span>
<span class="gi">+            else:</span>
<span class="gi">+                logger.info(red(&#39;broken    &#39;) + result.uri + red(&#39; - &#39; + result.message))</span>
<span class="gi">+            self.write_entry(&#39;broken&#39;, result.docname, filename, result.lineno,</span>
<span class="gi">+                             result.uri + &#39;: &#39; + result.message)</span>
<span class="gi">+            self.broken_hyperlinks += 1</span>
<span class="gi">+        elif result.status == &#39;redirected&#39;:</span>
<span class="gi">+            try:</span>
<span class="gi">+                text, color = {</span>
<span class="gi">+                    301: (&#39;permanently&#39;, purple),</span>
<span class="gi">+                    302: (&#39;with Found&#39;, purple),</span>
<span class="gi">+                    303: (&#39;with See Other&#39;, purple),</span>
<span class="gi">+                    307: (&#39;temporarily&#39;, turquoise),</span>
<span class="gi">+                    308: (&#39;permanently&#39;, purple),</span>
<span class="gi">+                }[result.code]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                text, color = (&#39;with unknown code&#39;, purple)</span>
<span class="gi">+            linkstat[&#39;text&#39;] = text</span>
<span class="gi">+            if self.config.linkcheck_allowed_redirects:</span>
<span class="gi">+                logger.warning(&#39;redirect  &#39; + result.uri + &#39; - &#39; + text + &#39; to &#39; +</span>
<span class="gi">+                               result.message, location=(result.docname, result.lineno))</span>
<span class="gi">+            else:</span>
<span class="gi">+                logger.info(color(&#39;redirect  &#39;) + result.uri +</span>
<span class="gi">+                            color(&#39; - &#39; + text + &#39; to &#39; + result.message))</span>
<span class="gi">+            self.write_entry(&#39;redirected &#39; + text, result.docname, filename,</span>
<span class="gi">+                             result.lineno, result.uri + &#39; to &#39; + result.message)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&#39;Unknown status %s.&#39; % result.status)</span>
<span class="gi">+</span>
<span class="gi">+    def write_linkstat(self, data: dict[str, str | int]) -&gt; None:</span>
<span class="gi">+        self.json_outfile.write(json.dumps(data))</span>
<span class="gi">+        self.json_outfile.write(&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def write_entry(self, what: str, docname: str, filename: _StrPath, line: int,</span>
<span class="gi">+                    uri: str) -&gt; None:</span>
<span class="gi">+        self.txt_outfile.write(f&#39;{filename}:{line}: [{what}] {uri}\n&#39;)</span>


<span class="w"> </span>class HyperlinkCollector(SphinxPostTransform):
<span class="gd">-    builders = &#39;linkcheck&#39;,</span>
<span class="gi">+    builders = (&#39;linkcheck&#39;,)</span>
<span class="w"> </span>    default_priority = 800

<span class="gd">-    def find_uri(self, node: nodes.Element) -&gt;(str | None):</span>
<span class="gi">+    def run(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        for node in self.document.findall():</span>
<span class="gi">+            if uri := self.find_uri(node):</span>
<span class="gi">+                self._add_uri(uri, node)</span>
<span class="gi">+</span>
<span class="gi">+    def find_uri(self, node: nodes.Element) -&gt; str | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Find a URI for a given node.

<span class="w"> </span>        This call can be used to retrieve a URI from a provided node. If no
<span class="gu">@@ -64,9 +177,26 @@ class HyperlinkCollector(SphinxPostTransform):</span>
<span class="w"> </span>        :param node: A node class
<span class="w"> </span>        :returns: URI of the node
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _add_uri(self, uri: str, node: nodes.Element) -&gt;None:</span>
<span class="gi">+        # reference nodes</span>
<span class="gi">+        if isinstance(node, nodes.reference):</span>
<span class="gi">+            if &#39;refuri&#39; in node:</span>
<span class="gi">+                return node[&#39;refuri&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        # image nodes</span>
<span class="gi">+        if isinstance(node, nodes.image):</span>
<span class="gi">+            uri = node[&#39;candidates&#39;].get(&#39;?&#39;)</span>
<span class="gi">+            if uri and &#39;://&#39; in uri:</span>
<span class="gi">+                return uri</span>
<span class="gi">+</span>
<span class="gi">+        # raw nodes</span>
<span class="gi">+        if isinstance(node, nodes.raw):</span>
<span class="gi">+            uri = node.get(&#39;source&#39;)</span>
<span class="gi">+            if uri and &#39;://&#39; in uri:</span>
<span class="gi">+                return uri</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _add_uri(self, uri: str, node: nodes.Element) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Registers a node&#39;s URI into a builder&#39;s collection of hyperlinks.

<span class="w"> </span>        Provides the ability to register a URI value determined from a node
<span class="gu">@@ -77,7 +207,20 @@ class HyperlinkCollector(SphinxPostTransform):</span>
<span class="w"> </span>        :param uri: URI to add
<span class="w"> </span>        :param node: A node class where the URI was found
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        builder = cast(CheckExternalLinksBuilder, self.app.builder)</span>
<span class="gi">+        hyperlinks = builder.hyperlinks</span>
<span class="gi">+        docname = self.env.docname</span>
<span class="gi">+</span>
<span class="gi">+        if newuri := self.app.emit_firstresult(&#39;linkcheck-process-uri&#39;, uri):</span>
<span class="gi">+            uri = newuri</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            lineno = get_node_line(node)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            lineno = -1</span>
<span class="gi">+</span>
<span class="gi">+        if uri not in hyperlinks:</span>
<span class="gi">+            hyperlinks[uri] = Hyperlink(uri, docname, self.env.doc2path(docname), lineno)</span>


<span class="w"> </span>class Hyperlink(NamedTuple):
<span class="gu">@@ -88,16 +231,51 @@ class Hyperlink(NamedTuple):</span>


<span class="w"> </span>class HyperlinkAvailabilityChecker:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, config: Config) -&gt;None:</span>
<span class="gi">+    def __init__(self, config: Config) -&gt; None:</span>
<span class="w"> </span>        self.config = config
<span class="w"> </span>        self.rate_limits: dict[str, RateLimit] = {}
<span class="w"> </span>        self.rqueue: Queue[CheckResult] = Queue()
<span class="w"> </span>        self.workers: list[Thread] = []
<span class="w"> </span>        self.wqueue: PriorityQueue[CheckRequest] = PriorityQueue()
<span class="w"> </span>        self.num_workers: int = config.linkcheck_workers
<span class="gd">-        self.to_ignore: list[re.Pattern[str]] = list(map(re.compile, self.</span>
<span class="gd">-            config.linkcheck_ignore))</span>
<span class="gi">+</span>
<span class="gi">+        self.to_ignore: list[re.Pattern[str]] = list(map(re.compile,</span>
<span class="gi">+                                                         self.config.linkcheck_ignore))</span>
<span class="gi">+</span>
<span class="gi">+    def check(self, hyperlinks: dict[str, Hyperlink]) -&gt; Iterator[CheckResult]:</span>
<span class="gi">+        self.invoke_threads()</span>
<span class="gi">+</span>
<span class="gi">+        total_links = 0</span>
<span class="gi">+        for hyperlink in hyperlinks.values():</span>
<span class="gi">+            if self.is_ignored_uri(hyperlink.uri):</span>
<span class="gi">+                yield CheckResult(hyperlink.uri, hyperlink.docname, hyperlink.lineno,</span>
<span class="gi">+                                  &#39;ignored&#39;, &#39;&#39;, 0)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.wqueue.put(CheckRequest(CHECK_IMMEDIATELY, hyperlink), False)</span>
<span class="gi">+                total_links += 1</span>
<span class="gi">+</span>
<span class="gi">+        done = 0</span>
<span class="gi">+        while done &lt; total_links:</span>
<span class="gi">+            yield self.rqueue.get()</span>
<span class="gi">+            done += 1</span>
<span class="gi">+</span>
<span class="gi">+        self.shutdown_threads()</span>
<span class="gi">+</span>
<span class="gi">+    def invoke_threads(self) -&gt; None:</span>
<span class="gi">+        for _i in range(self.num_workers):</span>
<span class="gi">+            thread = HyperlinkAvailabilityCheckWorker(self.config,</span>
<span class="gi">+                                                      self.rqueue, self.wqueue,</span>
<span class="gi">+                                                      self.rate_limits)</span>
<span class="gi">+            thread.start()</span>
<span class="gi">+            self.workers.append(thread)</span>
<span class="gi">+</span>
<span class="gi">+    def shutdown_threads(self) -&gt; None:</span>
<span class="gi">+        self.wqueue.join()</span>
<span class="gi">+        for _worker in self.workers:</span>
<span class="gi">+            self.wqueue.put(CheckRequest(CHECK_IMMEDIATELY, None), False)</span>
<span class="gi">+</span>
<span class="gi">+    def is_ignored_uri(self, uri: str) -&gt; bool:</span>
<span class="gi">+        return any(pat.match(uri) for pat in self.to_ignore)</span>


<span class="w"> </span>class CheckRequest(NamedTuple):
<span class="gu">@@ -117,22 +295,25 @@ class CheckResult(NamedTuple):</span>
<span class="w"> </span>class HyperlinkAvailabilityCheckWorker(Thread):
<span class="w"> </span>    &quot;&quot;&quot;A worker class for checking the availability of hyperlinks.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, config: Config, rqueue: Queue[CheckResult], wqueue:</span>
<span class="gd">-        Queue[CheckRequest], rate_limits: dict[str, RateLimit]) -&gt;None:</span>
<span class="gi">+    def __init__(self, config: Config,</span>
<span class="gi">+                 rqueue: Queue[CheckResult],</span>
<span class="gi">+                 wqueue: Queue[CheckRequest],</span>
<span class="gi">+                 rate_limits: dict[str, RateLimit]) -&gt; None:</span>
<span class="w"> </span>        self.rate_limits = rate_limits
<span class="w"> </span>        self.rqueue = rqueue
<span class="w"> </span>        self.wqueue = wqueue
<span class="gd">-        self.anchors_ignore: list[re.Pattern[str]] = list(map(re.compile,</span>
<span class="gd">-            config.linkcheck_anchors_ignore))</span>
<span class="gd">-        self.anchors_ignore_for_url: list[re.Pattern[str]] = list(map(re.</span>
<span class="gd">-            compile, config.linkcheck_anchors_ignore_for_url))</span>
<span class="gd">-        self.documents_exclude: list[re.Pattern[str]] = list(map(re.compile,</span>
<span class="gd">-            config.linkcheck_exclude_documents))</span>
<span class="gd">-        self.auth = [(re.compile(pattern), auth_info) for pattern,</span>
<span class="gd">-            auth_info in config.linkcheck_auth]</span>
<span class="gi">+</span>
<span class="gi">+        self.anchors_ignore: list[re.Pattern[str]] = list(</span>
<span class="gi">+            map(re.compile, config.linkcheck_anchors_ignore))</span>
<span class="gi">+        self.anchors_ignore_for_url: list[re.Pattern[str]] = list(</span>
<span class="gi">+            map(re.compile, config.linkcheck_anchors_ignore_for_url))</span>
<span class="gi">+        self.documents_exclude: list[re.Pattern[str]] = list(</span>
<span class="gi">+            map(re.compile, config.linkcheck_exclude_documents))</span>
<span class="gi">+        self.auth = [(re.compile(pattern), auth_info) for pattern, auth_info</span>
<span class="gi">+                     in config.linkcheck_auth]</span>
<span class="gi">+</span>
<span class="w"> </span>        self.timeout: int | float | None = config.linkcheck_timeout
<span class="gd">-        self.request_headers: dict[str, dict[str, str]</span>
<span class="gd">-            ] = config.linkcheck_request_headers</span>
<span class="gi">+        self.request_headers: dict[str, dict[str, str]] = config.linkcheck_request_headers</span>
<span class="w"> </span>        self.check_anchors: bool = config.linkcheck_anchors
<span class="w"> </span>        self.allowed_redirects: dict[re.Pattern[str], re.Pattern[str]]
<span class="w"> </span>        self.allowed_redirects = config.linkcheck_allowed_redirects
<span class="gu">@@ -143,41 +324,371 @@ class HyperlinkAvailabilityCheckWorker(Thread):</span>
<span class="w"> </span>            self._timeout_status = &#39;broken&#39;
<span class="w"> </span>        else:
<span class="w"> </span>            self._timeout_status = &#39;timeout&#39;
<span class="gi">+</span>
<span class="w"> </span>        self.user_agent = config.user_agent
<span class="w"> </span>        self.tls_verify = config.tls_verify
<span class="w"> </span>        self.tls_cacerts = config.tls_cacerts
<span class="gi">+</span>
<span class="w"> </span>        self._session = requests._Session()
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(daemon=True)

<span class="gi">+    def run(self) -&gt; None:</span>
<span class="gi">+        while True:</span>
<span class="gi">+            next_check, hyperlink = self.wqueue.get()</span>
<span class="gi">+            if hyperlink is None:</span>
<span class="gi">+                # An empty hyperlink is a signal to shutdown the worker; cleanup resources here</span>
<span class="gi">+                self._session.close()</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            uri, docname, _docpath, lineno = hyperlink</span>
<span class="gi">+            if uri is None:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            netloc = urlsplit(uri).netloc</span>
<span class="gi">+            with contextlib.suppress(KeyError):</span>
<span class="gi">+                # Refresh rate limit.</span>
<span class="gi">+                # When there are many links in the queue, workers are all stuck waiting</span>
<span class="gi">+                # for responses, but the builder keeps queuing. Links in the queue may</span>
<span class="gi">+                # have been queued before rate limits were discovered.</span>
<span class="gi">+                next_check = self.rate_limits[netloc].next_check</span>
<span class="gi">+            if next_check &gt; time.time():</span>
<span class="gi">+                # Sleep before putting message back in the queue to avoid</span>
<span class="gi">+                # waking up other threads.</span>
<span class="gi">+                time.sleep(QUEUE_POLL_SECS)</span>
<span class="gi">+                self.wqueue.put(CheckRequest(next_check, hyperlink), False)</span>
<span class="gi">+                self.wqueue.task_done()</span>
<span class="gi">+                continue</span>
<span class="gi">+            status, info, code = self._check(docname, uri, hyperlink)</span>
<span class="gi">+            if status == &#39;rate-limited&#39;:</span>
<span class="gi">+                logger.info(darkgray(&#39;-rate limited-   &#39;) + uri + darkgray(&#39; | sleeping...&#39;))</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.rqueue.put(CheckResult(uri, docname, lineno, status, info, code))</span>
<span class="gi">+            self.wqueue.task_done()</span>
<span class="gi">+</span>
<span class="gi">+    def _check(self, docname: str, uri: str, hyperlink: Hyperlink) -&gt; tuple[str, str, int]:</span>
<span class="gi">+        # check for various conditions without bothering the network</span>
<span class="gi">+</span>
<span class="gi">+        for doc_matcher in self.documents_exclude:</span>
<span class="gi">+            if doc_matcher.match(docname):</span>
<span class="gi">+                info = (</span>
<span class="gi">+                    f&#39;{docname} matched {doc_matcher.pattern} from &#39;</span>
<span class="gi">+                    &#39;linkcheck_exclude_documents&#39;</span>
<span class="gi">+                )</span>
<span class="gi">+                return &#39;ignored&#39;, info, 0</span>
<span class="gi">+</span>
<span class="gi">+        if len(uri) == 0 or uri.startswith((&#39;#&#39;, &#39;mailto:&#39;, &#39;tel:&#39;)):</span>
<span class="gi">+            return &#39;unchecked&#39;, &#39;&#39;, 0</span>
<span class="gi">+        if not uri.startswith((&#39;http:&#39;, &#39;https:&#39;)):</span>
<span class="gi">+            if uri_re.match(uri):</span>
<span class="gi">+                # Non-supported URI schemes (ex. ftp)</span>
<span class="gi">+                return &#39;unchecked&#39;, &#39;&#39;, 0</span>
<span class="gi">+</span>
<span class="gi">+            src_dir = path.dirname(hyperlink.docpath)</span>
<span class="gi">+            if path.exists(path.join(src_dir, uri)):</span>
<span class="gi">+                return &#39;working&#39;, &#39;&#39;, 0</span>
<span class="gi">+            return &#39;broken&#39;, &#39;&#39;, 0</span>
<span class="gi">+</span>
<span class="gi">+        # need to actually check the URI</span>
<span class="gi">+        status, info, code = &#39;&#39;, &#39;&#39;, 0</span>
<span class="gi">+        for _ in range(self.retries):</span>
<span class="gi">+            status, info, code = self._check_uri(uri, hyperlink)</span>
<span class="gi">+            if status != &#39;broken&#39;:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        return status, info, code</span>
<span class="gi">+</span>
<span class="gi">+    def _retrieval_methods(</span>
<span class="gi">+        self,</span>
<span class="gi">+        check_anchors: bool,</span>
<span class="gi">+        anchor: str,</span>
<span class="gi">+    ) -&gt; Iterator[tuple[Callable[..., Response], dict[str, bool]]]:</span>
<span class="gi">+        if not check_anchors or not anchor:</span>
<span class="gi">+            yield self._session.head, {&#39;allow_redirects&#39;: True}</span>
<span class="gi">+        yield self._session.get, {&#39;stream&#39;: True}</span>
<span class="gi">+</span>
<span class="gi">+    def _check_uri(self, uri: str, hyperlink: Hyperlink) -&gt; tuple[str, str, int]:</span>
<span class="gi">+        req_url, delimiter, anchor = uri.partition(&#39;#&#39;)</span>
<span class="gi">+        if delimiter and anchor:</span>
<span class="gi">+            for rex in self.anchors_ignore:</span>
<span class="gi">+                if rex.match(anchor):</span>
<span class="gi">+                    anchor = &#39;&#39;</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                for rex in self.anchors_ignore_for_url:</span>
<span class="gi">+                    if rex.match(req_url):</span>
<span class="gi">+                        anchor = &#39;&#39;</span>
<span class="gi">+                        break</span>
<span class="gi">+            anchor = unquote(anchor)</span>
<span class="gi">+</span>
<span class="gi">+        # handle non-ASCII URIs</span>
<span class="gi">+        try:</span>
<span class="gi">+            req_url.encode(&#39;ascii&#39;)</span>
<span class="gi">+        except UnicodeError:</span>
<span class="gi">+            req_url = encode_uri(req_url)</span>
<span class="gi">+</span>
<span class="gi">+        # Get auth info, if any</span>
<span class="gi">+        for pattern, auth_info in self.auth:  # NoQA: B007 (false positive)</span>
<span class="gi">+            if pattern.match(uri):</span>
<span class="gi">+                break</span>
<span class="gi">+        else:</span>
<span class="gi">+            auth_info = None</span>
<span class="gi">+</span>
<span class="gi">+        # update request headers for the URL</span>
<span class="gi">+        headers = _get_request_headers(uri, self.request_headers)</span>
<span class="gi">+</span>
<span class="gi">+        # Linkcheck HTTP request logic:</span>
<span class="gi">+        #</span>
<span class="gi">+        # - Attempt HTTP HEAD before HTTP GET unless page content is required.</span>
<span class="gi">+        # - Follow server-issued HTTP redirects.</span>
<span class="gi">+        # - Respect server-issued HTTP 429 back-offs.</span>
<span class="gi">+        error_message = &#39;&#39;</span>
<span class="gi">+        status_code = -1</span>
<span class="gi">+        response_url = retry_after = &#39;&#39;</span>
<span class="gi">+        for retrieval_method, kwargs in self._retrieval_methods(self.check_anchors, anchor):</span>
<span class="gi">+            try:</span>
<span class="gi">+                with retrieval_method(</span>
<span class="gi">+                    url=req_url, auth=auth_info,</span>
<span class="gi">+                    headers=headers,</span>
<span class="gi">+                    timeout=self.timeout,</span>
<span class="gi">+                    **kwargs,</span>
<span class="gi">+                    _user_agent=self.user_agent,</span>
<span class="gi">+                    _tls_info=(self.tls_verify, self.tls_cacerts),</span>
<span class="gi">+                ) as response:</span>
<span class="gi">+                    if anchor and self.check_anchors and response.ok:</span>
<span class="gi">+                        try:</span>
<span class="gi">+                            found = contains_anchor(response, anchor)</span>
<span class="gi">+                        except UnicodeDecodeError:</span>
<span class="gi">+                            return &#39;ignored&#39;, &#39;unable to decode response content&#39;, 0</span>
<span class="gi">+                        if not found:</span>
<span class="gi">+                            return &#39;broken&#39;, __(&quot;Anchor &#39;%s&#39; not found&quot;) % quote(anchor), 0</span>
<span class="gi">+</span>
<span class="gi">+                # Copy data we need from the (closed) response</span>
<span class="gi">+                status_code = response.status_code</span>
<span class="gi">+                redirect_status_code = response.history[-1].status_code if response.history else None  # NoQA: E501</span>
<span class="gi">+                retry_after = response.headers.get(&#39;Retry-After&#39;, &#39;&#39;)</span>
<span class="gi">+                response_url = f&#39;{response.url}&#39;</span>
<span class="gi">+                response.raise_for_status()</span>
<span class="gi">+                del response</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            except RequestTimeout as err:</span>
<span class="gi">+                return self._timeout_status, str(err), 0</span>
<span class="gi">+</span>
<span class="gi">+            except SSLError as err:</span>
<span class="gi">+                # SSL failure; report that the link is broken.</span>
<span class="gi">+                return &#39;broken&#39;, str(err), 0</span>
<span class="gi">+</span>
<span class="gi">+            except (ConnectionError, TooManyRedirects) as err:</span>
<span class="gi">+                # Servers drop the connection on HEAD requests, causing</span>
<span class="gi">+                # ConnectionError.</span>
<span class="gi">+                error_message = str(err)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            except HTTPError as err:</span>
<span class="gi">+                error_message = str(err)</span>
<span class="gi">+</span>
<span class="gi">+                # Unauthorized: the client did not provide required credentials</span>
<span class="gi">+                if status_code == 401:</span>
<span class="gi">+                    status = &#39;working&#39; if self._allow_unauthorized else &#39;broken&#39;</span>
<span class="gi">+                    return status, &#39;unauthorized&#39;, 0</span>
<span class="gi">+</span>
<span class="gi">+                # Rate limiting; back-off if allowed, or report failure otherwise</span>
<span class="gi">+                if status_code == 429:</span>
<span class="gi">+                    if next_check := self.limit_rate(response_url, retry_after):</span>
<span class="gi">+                        self.wqueue.put(CheckRequest(next_check, hyperlink), False)</span>
<span class="gi">+                        return &#39;rate-limited&#39;, &#39;&#39;, 0</span>
<span class="gi">+                    return &#39;broken&#39;, error_message, 0</span>
<span class="gi">+</span>
<span class="gi">+                # Don&#39;t claim success/failure during server-side outages</span>
<span class="gi">+                if status_code == 503:</span>
<span class="gi">+                    return &#39;ignored&#39;, &#39;service unavailable&#39;, 0</span>
<span class="gi">+</span>
<span class="gi">+                # For most HTTP failures, continue attempting alternate retrieval methods</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            except Exception as err:</span>
<span class="gi">+                # Unhandled exception (intermittent or permanent); report that</span>
<span class="gi">+                # the link is broken.</span>
<span class="gi">+                return &#39;broken&#39;, str(err), 0</span>

<span class="gd">-def contains_anchor(response: Response, anchor: str) -&gt;bool:</span>
<span class="gi">+        else:</span>
<span class="gi">+            # All available retrieval methods have been exhausted; report</span>
<span class="gi">+            # that the link is broken.</span>
<span class="gi">+            return &#39;broken&#39;, error_message, 0</span>
<span class="gi">+</span>
<span class="gi">+        # Success; clear rate limits for the origin</span>
<span class="gi">+        netloc = urlsplit(req_url).netloc</span>
<span class="gi">+        self.rate_limits.pop(netloc, None)</span>
<span class="gi">+</span>
<span class="gi">+        if ((response_url.rstrip(&#39;/&#39;) == req_url.rstrip(&#39;/&#39;))</span>
<span class="gi">+                or _allowed_redirect(req_url, response_url,</span>
<span class="gi">+                                     self.allowed_redirects)):</span>
<span class="gi">+            return &#39;working&#39;, &#39;&#39;, 0</span>
<span class="gi">+        elif redirect_status_code is not None:</span>
<span class="gi">+            return &#39;redirected&#39;, response_url, redirect_status_code</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;redirected&#39;, response_url, 0</span>
<span class="gi">+</span>
<span class="gi">+    def limit_rate(self, response_url: str, retry_after: str | None) -&gt; float | None:</span>
<span class="gi">+        delay = DEFAULT_DELAY</span>
<span class="gi">+        next_check = None</span>
<span class="gi">+        if retry_after:</span>
<span class="gi">+            try:</span>
<span class="gi">+                # Integer: time to wait before next attempt.</span>
<span class="gi">+                delay = float(retry_after)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    # An HTTP-date: time of next attempt.</span>
<span class="gi">+                    next_check = rfc1123_to_epoch(retry_after)</span>
<span class="gi">+                except (ValueError, TypeError):</span>
<span class="gi">+                    # TypeError: Invalid date format.</span>
<span class="gi">+                    # ValueError: Invalid date, e.g. Oct 52th.</span>
<span class="gi">+                    pass</span>
<span class="gi">+                else:</span>
<span class="gi">+                    delay = next_check - time.time()</span>
<span class="gi">+            else:</span>
<span class="gi">+                next_check = time.time() + delay</span>
<span class="gi">+        netloc = urlsplit(response_url).netloc</span>
<span class="gi">+        if next_check is None:</span>
<span class="gi">+            max_delay = self.rate_limit_timeout</span>
<span class="gi">+            try:</span>
<span class="gi">+                rate_limit = self.rate_limits[netloc]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                delay = DEFAULT_DELAY</span>
<span class="gi">+            else:</span>
<span class="gi">+                last_wait_time = rate_limit.delay</span>
<span class="gi">+                delay = 2.0 * last_wait_time</span>
<span class="gi">+                if delay &gt; max_delay &gt; last_wait_time:</span>
<span class="gi">+                    delay = max_delay</span>
<span class="gi">+            if delay &gt; max_delay:</span>
<span class="gi">+                return None</span>
<span class="gi">+            next_check = time.time() + delay</span>
<span class="gi">+        self.rate_limits[netloc] = RateLimit(delay, next_check)</span>
<span class="gi">+        return next_check</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_request_headers(</span>
<span class="gi">+    uri: str,</span>
<span class="gi">+    request_headers: dict[str, dict[str, str]],</span>
<span class="gi">+) -&gt; dict[str, str]:</span>
<span class="gi">+    url = urlsplit(uri)</span>
<span class="gi">+    candidates = (f&#39;{url.scheme}://{url.netloc}&#39;,</span>
<span class="gi">+                  f&#39;{url.scheme}://{url.netloc}/&#39;,</span>
<span class="gi">+                  uri,</span>
<span class="gi">+                  &#39;*&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    for u in candidates:</span>
<span class="gi">+        if u in request_headers:</span>
<span class="gi">+            return {**DEFAULT_REQUEST_HEADERS, **request_headers[u]}</span>
<span class="gi">+    return {}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def contains_anchor(response: Response, anchor: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Determine if an anchor is contained within an HTTP response.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parser = AnchorCheckParser(anchor)</span>
<span class="gi">+    # Read file in chunks. If we find a matching anchor, we break</span>
<span class="gi">+    # the loop early in hopes not to have to download the whole thing.</span>
<span class="gi">+    for chunk in response.iter_content(chunk_size=4096, decode_unicode=True):</span>
<span class="gi">+        if isinstance(chunk, bytes):    # requests failed to decode</span>
<span class="gi">+            chunk = chunk.decode()      # manually try to decode it</span>
<span class="gi">+</span>
<span class="gi">+        parser.feed(chunk)</span>
<span class="gi">+        if parser.found:</span>
<span class="gi">+            break</span>
<span class="gi">+    parser.close()</span>
<span class="gi">+    return parser.found</span>


<span class="w"> </span>class AnchorCheckParser(HTMLParser):
<span class="w"> </span>    &quot;&quot;&quot;Specialised HTML parser that looks for a specific anchor.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, search_anchor: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, search_anchor: str) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="gi">+</span>
<span class="w"> </span>        self.search_anchor = search_anchor
<span class="w"> </span>        self.found = False

<span class="gi">+    def handle_starttag(self, tag: Any, attrs: Any) -&gt; None:</span>
<span class="gi">+        for key, value in attrs:</span>
<span class="gi">+            if key in (&#39;id&#39;, &#39;name&#39;) and value == self.search_anchor:</span>
<span class="gi">+                self.found = True</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _allowed_redirect(url: str, new_url: str,</span>
<span class="gi">+                      allowed_redirects: dict[re.Pattern[str], re.Pattern[str]]) -&gt; bool:</span>
<span class="gi">+    return any(</span>
<span class="gi">+        from_url.match(url) and to_url.match(new_url)</span>
<span class="gi">+        for from_url, to_url</span>
<span class="gi">+        in allowed_redirects.items()</span>
<span class="gi">+    )</span>
<span class="gi">+</span>

<span class="w"> </span>class RateLimit(NamedTuple):
<span class="w"> </span>    delay: float
<span class="w"> </span>    next_check: float


<span class="gd">-def rewrite_github_anchor(app: Sphinx, uri: str) -&gt;(str | None):</span>
<span class="gi">+def rewrite_github_anchor(app: Sphinx, uri: str) -&gt; str | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Rewrite anchor name of the hyperlink to github.com

<span class="w"> </span>    The hyperlink anchors in github.com are dynamically generated.  This rewrites
<span class="w"> </span>    them before checking and makes them comparable.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parsed = urlparse(uri)</span>
<span class="gi">+    if parsed.hostname == &#39;github.com&#39; and parsed.fragment:</span>
<span class="gi">+        prefixed = parsed.fragment.startswith(&#39;user-content-&#39;)</span>
<span class="gi">+        if not prefixed:</span>
<span class="gi">+            fragment = f&#39;user-content-{parsed.fragment}&#39;</span>
<span class="gi">+            return urlunparse(parsed._replace(fragment=fragment))</span>
<span class="gi">+    return None</span>


<span class="gd">-def compile_linkcheck_allowed_redirects(app: Sphinx, config: Config) -&gt;None:</span>
<span class="gi">+def compile_linkcheck_allowed_redirects(app: Sphinx, config: Config) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Compile patterns in linkcheck_allowed_redirects to the regexp objects.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for url, pattern in list(app.config.linkcheck_allowed_redirects.items()):</span>
<span class="gi">+        try:</span>
<span class="gi">+            app.config.linkcheck_allowed_redirects[re.compile(url)] = re.compile(pattern)</span>
<span class="gi">+        except re.error as exc:</span>
<span class="gi">+            logger.warning(__(&#39;Failed to compile regex in linkcheck_allowed_redirects: %r %s&#39;),</span>
<span class="gi">+                           exc.pattern, exc.msg)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            # Remove the original regexp-string</span>
<span class="gi">+            app.config.linkcheck_allowed_redirects.pop(url)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_builder(CheckExternalLinksBuilder)</span>
<span class="gi">+    app.add_post_transform(HyperlinkCollector)</span>
<span class="gi">+</span>
<span class="gi">+    app.add_config_value(&#39;linkcheck_ignore&#39;, [], &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;linkcheck_exclude_documents&#39;, [], &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;linkcheck_allowed_redirects&#39;, {}, &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;linkcheck_auth&#39;, [], &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;linkcheck_request_headers&#39;, {}, &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;linkcheck_retries&#39;, 1, &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;linkcheck_timeout&#39;, 30, &#39;&#39;, (int, float))</span>
<span class="gi">+    app.add_config_value(&#39;linkcheck_workers&#39;, 5, &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;linkcheck_anchors&#39;, True, &#39;&#39;)</span>
<span class="gi">+    # Anchors starting with ! are ignored since they are</span>
<span class="gi">+    # commonly used for dynamic pages</span>
<span class="gi">+    app.add_config_value(&#39;linkcheck_anchors_ignore&#39;, [&#39;^!&#39;], &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;linkcheck_anchors_ignore_for_url&#39;, (), &#39;&#39;, (tuple, list))</span>
<span class="gi">+    app.add_config_value(&#39;linkcheck_rate_limit_timeout&#39;, 300.0, &#39;&#39;, (int, float))</span>
<span class="gi">+    app.add_config_value(&#39;linkcheck_allow_unauthorized&#39;, False, &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;linkcheck_report_timeouts_as_broken&#39;, False, &#39;&#39;, bool)</span>
<span class="gi">+</span>
<span class="gi">+    app.add_event(&#39;linkcheck-process-uri&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    app.connect(&#39;config-inited&#39;, compile_linkcheck_allowed_redirects, priority=800)</span>
<span class="gi">+</span>
<span class="gi">+    # FIXME: Disable URL rewrite handler for github.com temporarily.</span>
<span class="gi">+    # ref: https://github.com/sphinx-doc/sphinx/issues/9435</span>
<span class="gi">+    # app.connect(&#39;linkcheck-process-uri&#39;, rewrite_github_anchor)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/builders/manpage.py b/sphinx/builders/manpage.py</span>
<span class="gh">index 20bdcc04a..0070b043f 100644</span>
<span class="gd">--- a/sphinx/builders/manpage.py</span>
<span class="gi">+++ b/sphinx/builders/manpage.py</span>
<span class="gu">@@ -1,10 +1,14 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Manual pages builder.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import warnings
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from docutils.frontend import OptionParser
<span class="w"> </span>from docutils.io import FileOutput
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.builders import Builder
<span class="w"> </span>from sphinx.locale import __
<span class="gu">@@ -14,10 +18,12 @@ from sphinx.util.display import progress_message</span>
<span class="w"> </span>from sphinx.util.nodes import inline_all_toctrees
<span class="w"> </span>from sphinx.util.osutil import ensuredir, make_filename_from_project
<span class="w"> </span>from sphinx.writers.manpage import ManualPageTranslator, ManualPageWriter
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.config import Config
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="gu">@@ -25,14 +31,99 @@ class ManualPageBuilder(Builder):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Builds groff output in manual page format.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name = &#39;man&#39;
<span class="w"> </span>    format = &#39;man&#39;
<span class="w"> </span>    epilog = __(&#39;The manual pages are in %(outdir)s.&#39;)
<span class="gi">+</span>
<span class="w"> </span>    default_translator_class = ManualPageTranslator
<span class="w"> </span>    supported_image_types: list[str] = []

<span class="gi">+    def init(self) -&gt; None:</span>
<span class="gi">+        if not self.config.man_pages:</span>
<span class="gi">+            logger.warning(__(&#39;no &quot;man_pages&quot; config value found; no manual pages &#39;</span>
<span class="gi">+                              &#39;will be written&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    def get_outdated_docs(self) -&gt; str | list[str]:</span>
<span class="gi">+        return &#39;all manpages&#39;  # for now</span>
<span class="gi">+</span>
<span class="gi">+    def get_target_uri(self, docname: str, typ: str | None = None) -&gt; str:</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    @progress_message(__(&#39;writing&#39;))</span>
<span class="gi">+    def write(self, *ignored: Any) -&gt; None:</span>
<span class="gi">+        docwriter = ManualPageWriter(self)</span>
<span class="gi">+        with warnings.catch_warnings():</span>
<span class="gi">+            warnings.filterwarnings(&#39;ignore&#39;, category=DeprecationWarning)</span>
<span class="gi">+            # DeprecationWarning: The frontend.OptionParser class will be replaced</span>
<span class="gi">+            # by a subclass of argparse.ArgumentParser in Docutils 0.21 or later.</span>
<span class="gi">+            docsettings: Any = OptionParser(</span>
<span class="gi">+                defaults=self.env.settings,</span>
<span class="gi">+                components=(docwriter,),</span>
<span class="gi">+                read_config_files=True).get_default_values()</span>
<span class="gi">+</span>
<span class="gi">+        for info in self.config.man_pages:</span>
<span class="gi">+            docname, name, description, authors, section = info</span>
<span class="gi">+            if docname not in self.env.all_docs:</span>
<span class="gi">+                logger.warning(__(&#39;&quot;man_pages&quot; config value references unknown &#39;</span>
<span class="gi">+                                  &#39;document %s&#39;), docname)</span>
<span class="gi">+                continue</span>
<span class="gi">+            if isinstance(authors, str):</span>
<span class="gi">+                if authors:</span>
<span class="gi">+                    authors = [authors]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    authors = []</span>

<span class="gd">-def default_man_pages(config: Config) -&gt;list[tuple[str, str, str, list[str],</span>
<span class="gd">-    int]]:</span>
<span class="gi">+            docsettings.title = name</span>
<span class="gi">+            docsettings.subtitle = description</span>
<span class="gi">+            docsettings.authors = authors</span>
<span class="gi">+            docsettings.section = section</span>
<span class="gi">+</span>
<span class="gi">+            if self.config.man_make_section_directory:</span>
<span class="gi">+                dirname = &#39;man%s&#39; % section</span>
<span class="gi">+                ensuredir(path.join(self.outdir, dirname))</span>
<span class="gi">+                targetname = f&#39;{dirname}/{name}.{section}&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                targetname = f&#39;{name}.{section}&#39;</span>
<span class="gi">+</span>
<span class="gi">+            logger.info(darkgreen(targetname) + &#39; { &#39;)</span>
<span class="gi">+            destination = FileOutput(</span>
<span class="gi">+                destination_path=path.join(self.outdir, targetname),</span>
<span class="gi">+                encoding=&#39;utf-8&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            tree = self.env.get_doctree(docname)</span>
<span class="gi">+            docnames: set[str] = set()</span>
<span class="gi">+            largetree = inline_all_toctrees(self, docnames, docname, tree,</span>
<span class="gi">+                                            darkgreen, [docname])</span>
<span class="gi">+            largetree.settings = docsettings</span>
<span class="gi">+            logger.info(&#39;} &#39;, nonl=True)</span>
<span class="gi">+            self.env.resolve_references(largetree, docname, self)</span>
<span class="gi">+            # remove pending_xref nodes</span>
<span class="gi">+            for pendingnode in largetree.findall(addnodes.pending_xref):</span>
<span class="gi">+                pendingnode.replace_self(pendingnode.children)</span>
<span class="gi">+</span>
<span class="gi">+            docwriter.write(largetree, destination)</span>
<span class="gi">+</span>
<span class="gi">+    def finish(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def default_man_pages(config: Config) -&gt; list[tuple[str, str, str, list[str], int]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Better default man_pages settings.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    filename = make_filename_from_project(config.project)</span>
<span class="gi">+    return [(config.root_doc, filename, f&#39;{config.project} {config.release}&#39;,</span>
<span class="gi">+             [config.author], 1)]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_builder(ManualPageBuilder)</span>
<span class="gi">+</span>
<span class="gi">+    app.add_config_value(&#39;man_pages&#39;, default_man_pages, &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;man_show_urls&#39;, False, &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;man_make_section_directory&#39;, False, &#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/builders/singlehtml.py b/sphinx/builders/singlehtml.py</span>
<span class="gh">index 91dcbb65b..4d58d554c 100644</span>
<span class="gd">--- a/sphinx/builders/singlehtml.py</span>
<span class="gi">+++ b/sphinx/builders/singlehtml.py</span>
<span class="gu">@@ -1,8 +1,12 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Single HTML builders.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>from sphinx.builders.html import StandaloneHTMLBuilder
<span class="w"> </span>from sphinx.environment.adapters.toctree import global_toctree_for_doc
<span class="w"> </span>from sphinx.locale import __
<span class="gu">@@ -10,10 +14,13 @@ from sphinx.util import logging</span>
<span class="w"> </span>from sphinx.util.console import darkgreen
<span class="w"> </span>from sphinx.util.display import progress_message
<span class="w"> </span>from sphinx.util.nodes import inline_all_toctrees
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.nodes import Node
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="gu">@@ -22,6 +29,176 @@ class SingleFileHTMLBuilder(StandaloneHTMLBuilder):</span>
<span class="w"> </span>    A StandaloneHTMLBuilder subclass that puts the whole document tree on one
<span class="w"> </span>    HTML page.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name = &#39;singlehtml&#39;
<span class="w"> </span>    epilog = __(&#39;The HTML page is in %(outdir)s.&#39;)
<span class="gi">+</span>
<span class="w"> </span>    copysource = False
<span class="gi">+</span>
<span class="gi">+    def get_outdated_docs(self) -&gt; str | list[str]:  # type: ignore[override]</span>
<span class="gi">+        return &#39;all documents&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def get_target_uri(self, docname: str, typ: str | None = None) -&gt; str:</span>
<span class="gi">+        if docname in self.env.all_docs:</span>
<span class="gi">+            # all references are on the same page...</span>
<span class="gi">+            return &#39;#document-&#39; + docname</span>
<span class="gi">+        else:</span>
<span class="gi">+            # chances are this is a html_additional_page</span>
<span class="gi">+            return docname + self.out_suffix</span>
<span class="gi">+</span>
<span class="gi">+    def get_relative_uri(self, from_: str, to: str, typ: str | None = None) -&gt; str:</span>
<span class="gi">+        # ignore source</span>
<span class="gi">+        return self.get_target_uri(to, typ)</span>
<span class="gi">+</span>
<span class="gi">+    def fix_refuris(self, tree: Node) -&gt; None:</span>
<span class="gi">+        # fix refuris with double anchor</span>
<span class="gi">+        for refnode in tree.findall(nodes.reference):</span>
<span class="gi">+            if &#39;refuri&#39; not in refnode:</span>
<span class="gi">+                continue</span>
<span class="gi">+            refuri = refnode[&#39;refuri&#39;]</span>
<span class="gi">+            hashindex = refuri.find(&#39;#&#39;)</span>
<span class="gi">+            if hashindex &lt; 0:</span>
<span class="gi">+                continue</span>
<span class="gi">+            hashindex = refuri.find(&#39;#&#39;, hashindex + 1)</span>
<span class="gi">+            if hashindex &gt;= 0:</span>
<span class="gi">+                # all references are on the same page...</span>
<span class="gi">+                refnode[&#39;refuri&#39;] = refuri[hashindex:]</span>
<span class="gi">+</span>
<span class="gi">+    def _get_local_toctree(self, docname: str, collapse: bool = True, **kwargs: Any) -&gt; str:</span>
<span class="gi">+        if isinstance(includehidden := kwargs.get(&#39;includehidden&#39;), str):</span>
<span class="gi">+            if includehidden.lower() == &#39;false&#39;:</span>
<span class="gi">+                kwargs[&#39;includehidden&#39;] = False</span>
<span class="gi">+            elif includehidden.lower() == &#39;true&#39;:</span>
<span class="gi">+                kwargs[&#39;includehidden&#39;] = True</span>
<span class="gi">+        if kwargs.get(&#39;maxdepth&#39;) == &#39;&#39;:</span>
<span class="gi">+            kwargs.pop(&#39;maxdepth&#39;)</span>
<span class="gi">+        toctree = global_toctree_for_doc(self.env, docname, self, collapse=collapse, **kwargs)</span>
<span class="gi">+        if toctree is not None:</span>
<span class="gi">+            self.fix_refuris(toctree)</span>
<span class="gi">+        return self.render_partial(toctree)[&#39;fragment&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    def assemble_doctree(self) -&gt; nodes.document:</span>
<span class="gi">+        master = self.config.root_doc</span>
<span class="gi">+        tree = self.env.get_doctree(master)</span>
<span class="gi">+        logger.info(darkgreen(master))</span>
<span class="gi">+        tree = inline_all_toctrees(self, set(), master, tree, darkgreen, [master])</span>
<span class="gi">+        tree[&#39;docname&#39;] = master</span>
<span class="gi">+        self.env.resolve_references(tree, master, self)</span>
<span class="gi">+        self.fix_refuris(tree)</span>
<span class="gi">+        return tree</span>
<span class="gi">+</span>
<span class="gi">+    def assemble_toc_secnumbers(self) -&gt; dict[str, dict[str, tuple[int, ...]]]:</span>
<span class="gi">+        # Assemble toc_secnumbers to resolve section numbers on SingleHTML.</span>
<span class="gi">+        # Merge all secnumbers to single secnumber.</span>
<span class="gi">+        #</span>
<span class="gi">+        # Note: current Sphinx has refid confliction in singlehtml mode.</span>
<span class="gi">+        #       To avoid the problem, it replaces key of secnumbers to</span>
<span class="gi">+        #       tuple of docname and refid.</span>
<span class="gi">+        #</span>
<span class="gi">+        #       There are related codes in inline_all_toctres() and</span>
<span class="gi">+        #       HTMLTranslter#add_secnumber().</span>
<span class="gi">+        new_secnumbers: dict[str, tuple[int, ...]] = {}</span>
<span class="gi">+        for docname, secnums in self.env.toc_secnumbers.items():</span>
<span class="gi">+            for id, secnum in secnums.items():</span>
<span class="gi">+                alias = f&quot;{docname}/{id}&quot;</span>
<span class="gi">+                new_secnumbers[alias] = secnum</span>
<span class="gi">+</span>
<span class="gi">+        return {self.config.root_doc: new_secnumbers}</span>
<span class="gi">+</span>
<span class="gi">+    def assemble_toc_fignumbers(self) -&gt; dict[str, dict[str, dict[str, tuple[int, ...]]]]:</span>
<span class="gi">+        # Assemble toc_fignumbers to resolve figure numbers on SingleHTML.</span>
<span class="gi">+        # Merge all fignumbers to single fignumber.</span>
<span class="gi">+        #</span>
<span class="gi">+        # Note: current Sphinx has refid confliction in singlehtml mode.</span>
<span class="gi">+        #       To avoid the problem, it replaces key of secnumbers to</span>
<span class="gi">+        #       tuple of docname and refid.</span>
<span class="gi">+        #</span>
<span class="gi">+        #       There are related codes in inline_all_toctres() and</span>
<span class="gi">+        #       HTMLTranslter#add_fignumber().</span>
<span class="gi">+        new_fignumbers: dict[str, dict[str, tuple[int, ...]]] = {}</span>
<span class="gi">+        # {&#39;foo&#39;: {&#39;figure&#39;: {&#39;id2&#39;: (2,), &#39;id1&#39;: (1,)}}, &#39;bar&#39;: {&#39;figure&#39;: {&#39;id1&#39;: (3,)}}}</span>
<span class="gi">+        for docname, fignumlist in self.env.toc_fignumbers.items():</span>
<span class="gi">+            for figtype, fignums in fignumlist.items():</span>
<span class="gi">+                alias = f&quot;{docname}/{figtype}&quot;</span>
<span class="gi">+                new_fignumbers.setdefault(alias, {})</span>
<span class="gi">+                for id, fignum in fignums.items():</span>
<span class="gi">+                    new_fignumbers[alias][id] = fignum</span>
<span class="gi">+</span>
<span class="gi">+        return {self.config.root_doc: new_fignumbers}</span>
<span class="gi">+</span>
<span class="gi">+    def get_doc_context(self, docname: str, body: str, metatags: str) -&gt; dict[str, Any]:</span>
<span class="gi">+        # no relation links...</span>
<span class="gi">+        toctree = global_toctree_for_doc(self.env, self.config.root_doc, self, collapse=False)</span>
<span class="gi">+        # if there is no toctree, toc is None</span>
<span class="gi">+        if toctree:</span>
<span class="gi">+            self.fix_refuris(toctree)</span>
<span class="gi">+            toc = self.render_partial(toctree)[&#39;fragment&#39;]</span>
<span class="gi">+            display_toc = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            toc = &#39;&#39;</span>
<span class="gi">+            display_toc = False</span>
<span class="gi">+        return {</span>
<span class="gi">+            &#39;parents&#39;: [],</span>
<span class="gi">+            &#39;prev&#39;: None,</span>
<span class="gi">+            &#39;next&#39;: None,</span>
<span class="gi">+            &#39;docstitle&#39;: None,</span>
<span class="gi">+            &#39;title&#39;: self.config.html_title,</span>
<span class="gi">+            &#39;meta&#39;: None,</span>
<span class="gi">+            &#39;body&#39;: body,</span>
<span class="gi">+            &#39;metatags&#39;: metatags,</span>
<span class="gi">+            &#39;rellinks&#39;: [],</span>
<span class="gi">+            &#39;sourcename&#39;: &#39;&#39;,</span>
<span class="gi">+            &#39;toc&#39;: toc,</span>
<span class="gi">+            &#39;display_toc&#39;: display_toc,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    def write(self, *ignored: Any) -&gt; None:</span>
<span class="gi">+        docnames = self.env.all_docs</span>
<span class="gi">+</span>
<span class="gi">+        with progress_message(__(&#39;preparing documents&#39;)):</span>
<span class="gi">+            self.prepare_writing(docnames)  # type: ignore[arg-type]</span>
<span class="gi">+</span>
<span class="gi">+        with progress_message(__(&#39;assembling single document&#39;), nonl=False):</span>
<span class="gi">+            doctree = self.assemble_doctree()</span>
<span class="gi">+            self.env.toc_secnumbers = self.assemble_toc_secnumbers()</span>
<span class="gi">+            self.env.toc_fignumbers = self.assemble_toc_fignumbers()</span>
<span class="gi">+</span>
<span class="gi">+        with progress_message(__(&#39;writing&#39;)):</span>
<span class="gi">+            self.write_doc_serialized(self.config.root_doc, doctree)</span>
<span class="gi">+            self.write_doc(self.config.root_doc, doctree)</span>
<span class="gi">+</span>
<span class="gi">+    def finish(self) -&gt; None:</span>
<span class="gi">+        self.write_additional_files()</span>
<span class="gi">+        self.copy_image_files()</span>
<span class="gi">+        self.copy_download_files()</span>
<span class="gi">+        self.copy_static_files()</span>
<span class="gi">+        self.copy_extra_files()</span>
<span class="gi">+        self.write_buildinfo()</span>
<span class="gi">+        self.dump_inventory()</span>
<span class="gi">+</span>
<span class="gi">+    @progress_message(__(&#39;writing additional files&#39;))</span>
<span class="gi">+    def write_additional_files(self) -&gt; None:</span>
<span class="gi">+        # no indices or search pages are supported</span>
<span class="gi">+</span>
<span class="gi">+        # additional pages from conf.py</span>
<span class="gi">+        for pagename, template in self.config.html_additional_pages.items():</span>
<span class="gi">+            logger.info(&#39; &#39; + pagename, nonl=True)</span>
<span class="gi">+            self.handle_page(pagename, {}, template)</span>
<span class="gi">+</span>
<span class="gi">+        if self.config.html_use_opensearch:</span>
<span class="gi">+            logger.info(&#39; opensearch&#39;, nonl=True)</span>
<span class="gi">+            fn = path.join(self.outdir, &#39;_static&#39;, &#39;opensearch.xml&#39;)</span>
<span class="gi">+            self.handle_page(&#39;opensearch&#39;, {}, &#39;opensearch.xml&#39;, outfilename=fn)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.setup_extension(&#39;sphinx.builders.html&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    app.add_builder(SingleFileHTMLBuilder)</span>
<span class="gi">+    app.add_config_value(&#39;singlehtml_sidebars&#39;, lambda self: self.html_sidebars, &#39;html&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/builders/texinfo.py b/sphinx/builders/texinfo.py</span>
<span class="gh">index e7442b2f8..b62160f8e 100644</span>
<span class="gd">--- a/sphinx/builders/texinfo.py</span>
<span class="gi">+++ b/sphinx/builders/texinfo.py</span>
<span class="gu">@@ -1,12 +1,16 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Texinfo builder.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import warnings
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.frontend import OptionParser
<span class="w"> </span>from docutils.io import FileOutput
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes, package_dir
<span class="w"> </span>from sphinx.builders import Builder
<span class="w"> </span>from sphinx.environment.adapters.asset import ImageAdapter
<span class="gu">@@ -19,12 +23,16 @@ from sphinx.util.docutils import new_document</span>
<span class="w"> </span>from sphinx.util.nodes import inline_all_toctrees
<span class="w"> </span>from sphinx.util.osutil import SEP, copyfile, ensuredir, make_filename_from_project
<span class="w"> </span>from sphinx.writers.texinfo import TexinfoTranslator, TexinfoWriter
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Iterable
<span class="gi">+</span>
<span class="w"> </span>    from docutils.nodes import Node
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.config import Config
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="w"> </span>template_dir = os.path.join(package_dir, &#39;templates&#39;, &#39;texinfo&#39;)

<span class="gu">@@ -33,20 +41,199 @@ class TexinfoBuilder(Builder):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Builds Texinfo output to create Info documentation.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name = &#39;texinfo&#39;
<span class="w"> </span>    format = &#39;texinfo&#39;
<span class="w"> </span>    epilog = __(&#39;The Texinfo files are in %(outdir)s.&#39;)
<span class="w"> </span>    if os.name == &#39;posix&#39;:
<span class="gd">-        epilog += __(</span>
<span class="gd">-            &quot;&quot;&quot;</span>
<span class="gd">-Run &#39;make&#39; in that directory to run these through makeinfo</span>
<span class="gd">-(use &#39;make info&#39; here to do that automatically).&quot;&quot;&quot;</span>
<span class="gd">-            )</span>
<span class="gd">-    supported_image_types = [&#39;image/png&#39;, &#39;image/jpeg&#39;, &#39;image/gif&#39;]</span>
<span class="gi">+        epilog += __(&quot;\nRun &#39;make&#39; in that directory to run these through &quot;</span>
<span class="gi">+                     &quot;makeinfo\n&quot;</span>
<span class="gi">+                     &quot;(use &#39;make info&#39; here to do that automatically).&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    supported_image_types = [&#39;image/png&#39;, &#39;image/jpeg&#39;,</span>
<span class="gi">+                             &#39;image/gif&#39;]</span>
<span class="w"> </span>    default_translator_class = TexinfoTranslator

<span class="gi">+    def init(self) -&gt; None:</span>
<span class="gi">+        self.docnames: Iterable[str] = []</span>
<span class="gi">+        self.document_data: list[tuple[str, str, str, str, str, str, str, bool]] = []</span>
<span class="gi">+</span>
<span class="gi">+    def get_outdated_docs(self) -&gt; str | list[str]:</span>
<span class="gi">+        return &#39;all documents&#39;  # for now</span>
<span class="gi">+</span>
<span class="gi">+    def get_target_uri(self, docname: str, typ: str | None = None) -&gt; str:</span>
<span class="gi">+        if docname not in self.docnames:</span>
<span class="gi">+            raise NoUri(docname, typ)</span>
<span class="gi">+        return &#39;%&#39; + docname</span>
<span class="gi">+</span>
<span class="gi">+    def get_relative_uri(self, from_: str, to: str, typ: str | None = None) -&gt; str:</span>
<span class="gi">+        # ignore source path</span>
<span class="gi">+        return self.get_target_uri(to, typ)</span>

<span class="gd">-def default_texinfo_documents(config: Config) -&gt;list[tuple[str, str, str,</span>
<span class="gd">-    str, str, str, str]]:</span>
<span class="gi">+    def init_document_data(self) -&gt; None:</span>
<span class="gi">+        preliminary_document_data = [list(x) for x in self.config.texinfo_documents]</span>
<span class="gi">+        if not preliminary_document_data:</span>
<span class="gi">+            logger.warning(__(&#39;no &quot;texinfo_documents&quot; config value found; no documents &#39;</span>
<span class="gi">+                              &#39;will be written&#39;))</span>
<span class="gi">+            return</span>
<span class="gi">+        # assign subdirs to titles</span>
<span class="gi">+        self.titles: list[tuple[str, str]] = []</span>
<span class="gi">+        for entry in preliminary_document_data:</span>
<span class="gi">+            docname = entry[0]</span>
<span class="gi">+            if docname not in self.env.all_docs:</span>
<span class="gi">+                logger.warning(__(&#39;&quot;texinfo_documents&quot; config value references unknown &#39;</span>
<span class="gi">+                                  &#39;document %s&#39;), docname)</span>
<span class="gi">+                continue</span>
<span class="gi">+            self.document_data.append(entry)  # type: ignore[arg-type]</span>
<span class="gi">+            if docname.endswith(SEP + &#39;index&#39;):</span>
<span class="gi">+                docname = docname[:-5]</span>
<span class="gi">+            self.titles.append((docname, entry[2]))</span>
<span class="gi">+</span>
<span class="gi">+    def write(self, *ignored: Any) -&gt; None:</span>
<span class="gi">+        self.init_document_data()</span>
<span class="gi">+        self.copy_assets()</span>
<span class="gi">+        for entry in self.document_data:</span>
<span class="gi">+            docname, targetname, title, author = entry[:4]</span>
<span class="gi">+            targetname += &#39;.texi&#39;</span>
<span class="gi">+            direntry = description = category = &#39;&#39;</span>
<span class="gi">+            if len(entry) &gt; 6:</span>
<span class="gi">+                direntry, description, category = entry[4:7]</span>
<span class="gi">+            toctree_only = False</span>
<span class="gi">+            if len(entry) &gt; 7:</span>
<span class="gi">+                toctree_only = entry[7]</span>
<span class="gi">+            destination = FileOutput(</span>
<span class="gi">+                destination_path=path.join(self.outdir, targetname),</span>
<span class="gi">+                encoding=&#39;utf-8&#39;)</span>
<span class="gi">+            with progress_message(__(&quot;processing %s&quot;) % targetname, nonl=False):</span>
<span class="gi">+                appendices = self.config.texinfo_appendices or []</span>
<span class="gi">+                doctree = self.assemble_doctree(docname, toctree_only, appendices=appendices)</span>
<span class="gi">+</span>
<span class="gi">+            with progress_message(__(&quot;writing&quot;)):</span>
<span class="gi">+                self.post_process_images(doctree)</span>
<span class="gi">+                docwriter = TexinfoWriter(self)</span>
<span class="gi">+                with warnings.catch_warnings():</span>
<span class="gi">+                    warnings.filterwarnings(&#39;ignore&#39;, category=DeprecationWarning)</span>
<span class="gi">+                    # DeprecationWarning: The frontend.OptionParser class will be replaced</span>
<span class="gi">+                    # by a subclass of argparse.ArgumentParser in Docutils 0.21 or later.</span>
<span class="gi">+                    settings: Any = OptionParser(</span>
<span class="gi">+                        defaults=self.env.settings,</span>
<span class="gi">+                        components=(docwriter,),</span>
<span class="gi">+                        read_config_files=True).get_default_values()</span>
<span class="gi">+                settings.author = author</span>
<span class="gi">+                settings.title = title</span>
<span class="gi">+                settings.texinfo_filename = targetname[:-5] + &#39;.info&#39;</span>
<span class="gi">+                settings.texinfo_elements = self.config.texinfo_elements</span>
<span class="gi">+                settings.texinfo_dir_entry = direntry or &#39;&#39;</span>
<span class="gi">+                settings.texinfo_dir_category = category or &#39;&#39;</span>
<span class="gi">+                settings.texinfo_dir_description = description or &#39;&#39;</span>
<span class="gi">+                settings.docname = docname</span>
<span class="gi">+                doctree.settings = settings</span>
<span class="gi">+                docwriter.write(doctree, destination)</span>
<span class="gi">+                self.copy_image_files(targetname[:-5])</span>
<span class="gi">+</span>
<span class="gi">+    def assemble_doctree(</span>
<span class="gi">+        self, indexfile: str, toctree_only: bool, appendices: list[str],</span>
<span class="gi">+    ) -&gt; nodes.document:</span>
<span class="gi">+        self.docnames = {indexfile, *appendices}</span>
<span class="gi">+        logger.info(darkgreen(indexfile))</span>
<span class="gi">+        tree = self.env.get_doctree(indexfile)</span>
<span class="gi">+        tree[&#39;docname&#39;] = indexfile</span>
<span class="gi">+        if toctree_only:</span>
<span class="gi">+            # extract toctree nodes from the tree and put them in a</span>
<span class="gi">+            # fresh document</span>
<span class="gi">+            new_tree = new_document(&#39;&lt;texinfo output&gt;&#39;)</span>
<span class="gi">+            new_sect = nodes.section()</span>
<span class="gi">+            new_sect += nodes.title(&#39;&lt;Set title in conf.py&gt;&#39;,</span>
<span class="gi">+                                    &#39;&lt;Set title in conf.py&gt;&#39;)</span>
<span class="gi">+            new_tree += new_sect</span>
<span class="gi">+            for node in tree.findall(addnodes.toctree):</span>
<span class="gi">+                new_sect += node</span>
<span class="gi">+            tree = new_tree</span>
<span class="gi">+        largetree = inline_all_toctrees(self, self.docnames, indexfile, tree,</span>
<span class="gi">+                                        darkgreen, [indexfile])</span>
<span class="gi">+        largetree[&#39;docname&#39;] = indexfile</span>
<span class="gi">+        for docname in appendices:</span>
<span class="gi">+            appendix = self.env.get_doctree(docname)</span>
<span class="gi">+            appendix[&#39;docname&#39;] = docname</span>
<span class="gi">+            largetree.append(appendix)</span>
<span class="gi">+        logger.info(&#39;&#39;)</span>
<span class="gi">+        logger.info(__(&quot;resolving references...&quot;))</span>
<span class="gi">+        self.env.resolve_references(largetree, indexfile, self)</span>
<span class="gi">+        # TODO: add support for external :ref:s</span>
<span class="gi">+        for pendingnode in largetree.findall(addnodes.pending_xref):</span>
<span class="gi">+            docname = pendingnode[&#39;refdocname&#39;]</span>
<span class="gi">+            sectname = pendingnode[&#39;refsectname&#39;]</span>
<span class="gi">+            newnodes: list[Node] = [nodes.emphasis(sectname, sectname)]</span>
<span class="gi">+            for subdir, title in self.titles:</span>
<span class="gi">+                if docname.startswith(subdir):</span>
<span class="gi">+                    newnodes.extend((</span>
<span class="gi">+                        nodes.Text(_(&#39; (in &#39;)),</span>
<span class="gi">+                        nodes.emphasis(title, title),</span>
<span class="gi">+                        nodes.Text(&#39;)&#39;),</span>
<span class="gi">+                    ))</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                pass</span>
<span class="gi">+            pendingnode.replace_self(newnodes)</span>
<span class="gi">+        return largetree</span>
<span class="gi">+</span>
<span class="gi">+    def copy_assets(self) -&gt; None:</span>
<span class="gi">+        self.copy_support_files()</span>
<span class="gi">+</span>
<span class="gi">+    def copy_image_files(self, targetname: str) -&gt; None:</span>
<span class="gi">+        if self.images:</span>
<span class="gi">+            stringify_func = ImageAdapter(self.app.env).get_original_image_uri</span>
<span class="gi">+            for src in status_iterator(self.images, __(&#39;copying images... &#39;), &quot;brown&quot;,</span>
<span class="gi">+                                       len(self.images), self.app.verbosity,</span>
<span class="gi">+                                       stringify_func=stringify_func):</span>
<span class="gi">+                dest = self.images[src]</span>
<span class="gi">+                try:</span>
<span class="gi">+                    imagedir = self.outdir / f&#39;{targetname}-figures&#39;</span>
<span class="gi">+                    ensuredir(imagedir)</span>
<span class="gi">+                    copyfile(</span>
<span class="gi">+                        self.srcdir / src,</span>
<span class="gi">+                        imagedir / dest,</span>
<span class="gi">+                        force=True,</span>
<span class="gi">+                    )</span>
<span class="gi">+                except Exception as err:</span>
<span class="gi">+                    logger.warning(__(&#39;cannot copy image file %r: %s&#39;),</span>
<span class="gi">+                                   path.join(self.srcdir, src), err)</span>
<span class="gi">+</span>
<span class="gi">+    def copy_support_files(self) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            with progress_message(__(&#39;copying Texinfo support files&#39;)):</span>
<span class="gi">+                logger.info(&#39;Makefile &#39;, nonl=True)</span>
<span class="gi">+                copyfile(</span>
<span class="gi">+                    os.path.join(template_dir, &#39;Makefile&#39;),</span>
<span class="gi">+                    self.outdir / &#39;Makefile&#39;,</span>
<span class="gi">+                    force=True,</span>
<span class="gi">+                )</span>
<span class="gi">+        except OSError as err:</span>
<span class="gi">+            logger.warning(__(&quot;error writing file Makefile: %s&quot;), err)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def default_texinfo_documents(</span>
<span class="gi">+    config: Config,</span>
<span class="gi">+) -&gt; list[tuple[str, str, str, str, str, str, str]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Better default texinfo_documents settings.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    filename = make_filename_from_project(config.project)</span>
<span class="gi">+    return [(config.root_doc, filename, config.project, config.author, filename,</span>
<span class="gi">+             &#39;One line description of project&#39;, &#39;Miscellaneous&#39;)]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_builder(TexinfoBuilder)</span>
<span class="gi">+</span>
<span class="gi">+    app.add_config_value(&#39;texinfo_documents&#39;, default_texinfo_documents, &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;texinfo_appendices&#39;, [], &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;texinfo_elements&#39;, {}, &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;texinfo_domain_indices&#39;, True, &#39;&#39;, types={set, list})</span>
<span class="gi">+    app.add_config_value(&#39;texinfo_show_urls&#39;, &#39;footnote&#39;, &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;texinfo_no_detailmenu&#39;, False, &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;texinfo_cross_references&#39;, True, &#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/builders/text.py b/sphinx/builders/text.py</span>
<span class="gh">index 04593d223..92544034c 100644</span>
<span class="gd">--- a/sphinx/builders/text.py</span>
<span class="gi">+++ b/sphinx/builders/text.py</span>
<span class="gu">@@ -1,18 +1,30 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Plain-text Sphinx builder.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from docutils.io import StringOutput
<span class="gi">+</span>
<span class="w"> </span>from sphinx.builders import Builder
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.util import logging
<span class="gd">-from sphinx.util.osutil import _last_modified_time, ensuredir, os_path</span>
<span class="gi">+from sphinx.util.osutil import (</span>
<span class="gi">+    _last_modified_time,</span>
<span class="gi">+    ensuredir,</span>
<span class="gi">+    os_path,</span>
<span class="gi">+)</span>
<span class="w"> </span>from sphinx.writers.text import TextTranslator, TextWriter
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Iterator
<span class="gi">+</span>
<span class="w"> </span>    from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="gu">@@ -20,7 +32,68 @@ class TextBuilder(Builder):</span>
<span class="w"> </span>    name = &#39;text&#39;
<span class="w"> </span>    format = &#39;text&#39;
<span class="w"> </span>    epilog = __(&#39;The text files are in %(outdir)s.&#39;)
<span class="gi">+</span>
<span class="w"> </span>    out_suffix = &#39;.txt&#39;
<span class="w"> </span>    allow_parallel = True
<span class="w"> </span>    default_translator_class = TextTranslator
<span class="gi">+</span>
<span class="w"> </span>    current_docname: str | None = None
<span class="gi">+</span>
<span class="gi">+    def init(self) -&gt; None:</span>
<span class="gi">+        # section numbers for headings in the currently visited document</span>
<span class="gi">+        self.secnumbers: dict[str, tuple[int, ...]] = {}</span>
<span class="gi">+</span>
<span class="gi">+    def get_outdated_docs(self) -&gt; Iterator[str]:</span>
<span class="gi">+        for docname in self.env.found_docs:</span>
<span class="gi">+            if docname not in self.env.all_docs:</span>
<span class="gi">+                yield docname</span>
<span class="gi">+                continue</span>
<span class="gi">+            targetname = path.join(self.outdir, docname + self.out_suffix)</span>
<span class="gi">+            try:</span>
<span class="gi">+                targetmtime = _last_modified_time(targetname)</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                targetmtime = 0</span>
<span class="gi">+            try:</span>
<span class="gi">+                srcmtime = _last_modified_time(self.env.doc2path(docname))</span>
<span class="gi">+                if srcmtime &gt; targetmtime:</span>
<span class="gi">+                    yield docname</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                # source doesn&#39;t exist anymore</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+    def get_target_uri(self, docname: str, typ: str | None = None) -&gt; str:</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def prepare_writing(self, docnames: set[str]) -&gt; None:</span>
<span class="gi">+        self.writer = TextWriter(self)</span>
<span class="gi">+</span>
<span class="gi">+    def write_doc(self, docname: str, doctree: nodes.document) -&gt; None:</span>
<span class="gi">+        self.current_docname = docname</span>
<span class="gi">+        self.secnumbers = self.env.toc_secnumbers.get(docname, {})</span>
<span class="gi">+        destination = StringOutput(encoding=&#39;utf-8&#39;)</span>
<span class="gi">+        self.writer.write(doctree, destination)</span>
<span class="gi">+        outfilename = path.join(self.outdir, os_path(docname) + self.out_suffix)</span>
<span class="gi">+        ensuredir(path.dirname(outfilename))</span>
<span class="gi">+        try:</span>
<span class="gi">+            with open(outfilename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:</span>
<span class="gi">+                f.write(self.writer.output)</span>
<span class="gi">+        except OSError as err:</span>
<span class="gi">+            logger.warning(__(&quot;error writing file %s: %s&quot;), outfilename, err)</span>
<span class="gi">+</span>
<span class="gi">+    def finish(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_builder(TextBuilder)</span>
<span class="gi">+</span>
<span class="gi">+    app.add_config_value(&#39;text_sectionchars&#39;, &#39;*=-~&quot;+`&#39;, &#39;env&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;text_newlines&#39;, &#39;unix&#39;, &#39;env&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;text_add_secnumbers&#39;, True, &#39;env&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;text_secnumber_suffix&#39;, &#39;. &#39;, &#39;env&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/builders/xml.py b/sphinx/builders/xml.py</span>
<span class="gh">index 3a70cad78..6be0ff8d6 100644</span>
<span class="gd">--- a/sphinx/builders/xml.py</span>
<span class="gi">+++ b/sphinx/builders/xml.py</span>
<span class="gu">@@ -1,19 +1,30 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Docutils-native XML and pseudo-XML builders.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.io import StringOutput
<span class="w"> </span>from docutils.writers.docutils_xml import XMLTranslator
<span class="gi">+</span>
<span class="w"> </span>from sphinx.builders import Builder
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.util import logging
<span class="gd">-from sphinx.util.osutil import _last_modified_time, ensuredir, os_path</span>
<span class="gi">+from sphinx.util.osutil import (</span>
<span class="gi">+    _last_modified_time,</span>
<span class="gi">+    ensuredir,</span>
<span class="gi">+    os_path,</span>
<span class="gi">+)</span>
<span class="w"> </span>from sphinx.writers.xml import PseudoXMLWriter, XMLWriter
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Iterator
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="gu">@@ -21,22 +32,97 @@ class XMLBuilder(Builder):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Builds Docutils-native XML.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name = &#39;xml&#39;
<span class="w"> </span>    format = &#39;xml&#39;
<span class="w"> </span>    epilog = __(&#39;The XML files are in %(outdir)s.&#39;)
<span class="gi">+</span>
<span class="w"> </span>    out_suffix = &#39;.xml&#39;
<span class="w"> </span>    allow_parallel = True
<span class="gi">+</span>
<span class="w"> </span>    _writer_class: type[XMLWriter] | type[PseudoXMLWriter] = XMLWriter
<span class="w"> </span>    writer: XMLWriter | PseudoXMLWriter
<span class="w"> </span>    default_translator_class = XMLTranslator

<span class="gi">+    def init(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def get_outdated_docs(self) -&gt; Iterator[str]:</span>
<span class="gi">+        for docname in self.env.found_docs:</span>
<span class="gi">+            if docname not in self.env.all_docs:</span>
<span class="gi">+                yield docname</span>
<span class="gi">+                continue</span>
<span class="gi">+            targetname = path.join(self.outdir, docname + self.out_suffix)</span>
<span class="gi">+            try:</span>
<span class="gi">+                targetmtime = _last_modified_time(targetname)</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                targetmtime = 0</span>
<span class="gi">+            try:</span>
<span class="gi">+                srcmtime = _last_modified_time(self.env.doc2path(docname))</span>
<span class="gi">+                if srcmtime &gt; targetmtime:</span>
<span class="gi">+                    yield docname</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                # source doesn&#39;t exist anymore</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+    def get_target_uri(self, docname: str, typ: str | None = None) -&gt; str:</span>
<span class="gi">+        return docname</span>
<span class="gi">+</span>
<span class="gi">+    def prepare_writing(self, docnames: set[str]) -&gt; None:</span>
<span class="gi">+        self.writer = self._writer_class(self)</span>
<span class="gi">+</span>
<span class="gi">+    def write_doc(self, docname: str, doctree: nodes.document) -&gt; None:</span>
<span class="gi">+        # work around multiple string % tuple issues in docutils;</span>
<span class="gi">+        # replace tuples in attribute values with lists</span>
<span class="gi">+        doctree = doctree.deepcopy()</span>
<span class="gi">+        for domain in self.env.domains.values():</span>
<span class="gi">+            xmlns = &quot;xmlns:&quot; + domain.name</span>
<span class="gi">+            doctree[xmlns] = &quot;https://www.sphinx-doc.org/&quot;</span>
<span class="gi">+        for node in doctree.findall(nodes.Element):</span>
<span class="gi">+            for att, value in node.attributes.items():</span>
<span class="gi">+                if isinstance(value, tuple):</span>
<span class="gi">+                    node.attributes[att] = list(value)</span>
<span class="gi">+                value = node.attributes[att]</span>
<span class="gi">+                if isinstance(value, list):</span>
<span class="gi">+                    for i, val in enumerate(value):</span>
<span class="gi">+                        if isinstance(val, tuple):</span>
<span class="gi">+                            value[i] = list(val)</span>
<span class="gi">+        destination = StringOutput(encoding=&#39;utf-8&#39;)</span>
<span class="gi">+        self.writer.write(doctree, destination)</span>
<span class="gi">+        outfilename = path.join(self.outdir, os_path(docname) + self.out_suffix)</span>
<span class="gi">+        ensuredir(path.dirname(outfilename))</span>
<span class="gi">+        try:</span>
<span class="gi">+            with open(outfilename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:</span>
<span class="gi">+                f.write(self.writer.output)</span>
<span class="gi">+        except OSError as err:</span>
<span class="gi">+            logger.warning(__(&quot;error writing file %s: %s&quot;), outfilename, err)</span>
<span class="gi">+</span>
<span class="gi">+    def finish(self) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>

<span class="w"> </span>class PseudoXMLBuilder(XMLBuilder):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Builds pseudo-XML for display purposes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name = &#39;pseudoxml&#39;
<span class="w"> </span>    format = &#39;pseudoxml&#39;
<span class="w"> </span>    epilog = __(&#39;The pseudo-XML files are in %(outdir)s.&#39;)
<span class="gi">+</span>
<span class="w"> </span>    out_suffix = &#39;.pseudoxml&#39;
<span class="gi">+</span>
<span class="w"> </span>    _writer_class = PseudoXMLWriter
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_builder(XMLBuilder)</span>
<span class="gi">+    app.add_builder(PseudoXMLBuilder)</span>
<span class="gi">+</span>
<span class="gi">+    app.add_config_value(&#39;xml_pretty&#39;, True, &#39;env&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/cmd/build.py b/sphinx/cmd/build.py</span>
<span class="gh">index a2aa5c5f4..9f6cf2a33 100644</span>
<span class="gd">--- a/sphinx/cmd/build.py</span>
<span class="gi">+++ b/sphinx/cmd/build.py</span>
<span class="gu">@@ -1,17 +1,21 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Build documentation from a provided source.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import argparse
<span class="w"> </span>import bdb
<span class="w"> </span>import contextlib
<span class="w"> </span>import locale
<span class="w"> </span>import multiprocessing
<span class="w"> </span>import os
<span class="gd">-import pdb</span>
<span class="gi">+import pdb  # NoQA: T100</span>
<span class="w"> </span>import sys
<span class="w"> </span>import traceback
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING, Any, TextIO
<span class="gi">+</span>
<span class="w"> </span>from docutils.utils import SystemMessage
<span class="gi">+</span>
<span class="w"> </span>import sphinx.locale
<span class="w"> </span>from sphinx import __display_version__
<span class="w"> </span>from sphinx.application import Sphinx
<span class="gu">@@ -22,32 +26,373 @@ from sphinx.util.console import color_terminal, nocolor, red, terminal_safe</span>
<span class="w"> </span>from sphinx.util.docutils import docutils_namespace, patch_docutils
<span class="w"> </span>from sphinx.util.exceptions import format_exception_cut_frames, save_traceback
<span class="w"> </span>from sphinx.util.osutil import ensuredir
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Sequence
<span class="w"> </span>    from typing import Protocol

<span class="gd">-</span>
<span class="w"> </span>    class SupportsWrite(Protocol):
<span class="gd">-        pass</span>
<span class="gi">+        def write(self, text: str, /) -&gt; int | None:</span>
<span class="gi">+            ...</span>
<span class="gi">+</span>

<span class="gi">+def handle_exception(</span>
<span class="gi">+    app: Sphinx | None, args: Any, exception: BaseException, stderr: TextIO = sys.stderr,</span>
<span class="gi">+) -&gt; None:</span>
<span class="gi">+    if isinstance(exception, bdb.BdbQuit):</span>
<span class="gi">+        return</span>

<span class="gd">-def jobs_argument(value: str) -&gt;int:</span>
<span class="gi">+    if args.pdb:</span>
<span class="gi">+        print(red(__(&#39;Exception occurred while building, starting debugger:&#39;)),</span>
<span class="gi">+              file=stderr)</span>
<span class="gi">+        traceback.print_exc()</span>
<span class="gi">+        pdb.post_mortem(sys.exc_info()[2])</span>
<span class="gi">+    else:</span>
<span class="gi">+        print(file=stderr)</span>
<span class="gi">+        if args.verbosity or args.traceback:</span>
<span class="gi">+            exc = sys.exc_info()[1]</span>
<span class="gi">+            if isinstance(exc, SphinxParallelError):</span>
<span class="gi">+                exc_format = &#39;(Error in parallel process)\n&#39; + exc.traceback</span>
<span class="gi">+                print(exc_format, file=stderr)</span>
<span class="gi">+            else:</span>
<span class="gi">+                traceback.print_exc(None, stderr)</span>
<span class="gi">+                print(file=stderr)</span>
<span class="gi">+        if isinstance(exception, KeyboardInterrupt):</span>
<span class="gi">+            print(__(&#39;Interrupted!&#39;), file=stderr)</span>
<span class="gi">+        elif isinstance(exception, SystemMessage):</span>
<span class="gi">+            print(red(__(&#39;reST markup error:&#39;)), file=stderr)</span>
<span class="gi">+            print(terminal_safe(exception.args[0]), file=stderr)</span>
<span class="gi">+        elif isinstance(exception, SphinxError):</span>
<span class="gi">+            print(red(&#39;%s:&#39; % exception.category), file=stderr)</span>
<span class="gi">+            print(str(exception), file=stderr)</span>
<span class="gi">+        elif isinstance(exception, UnicodeError):</span>
<span class="gi">+            print(red(__(&#39;Encoding error:&#39;)), file=stderr)</span>
<span class="gi">+            print(terminal_safe(str(exception)), file=stderr)</span>
<span class="gi">+            tbpath = save_traceback(app, exception)</span>
<span class="gi">+            print(red(__(&#39;The full traceback has been saved in %s, if you want &#39;</span>
<span class="gi">+                         &#39;to report the issue to the developers.&#39;) % tbpath),</span>
<span class="gi">+                  file=stderr)</span>
<span class="gi">+        elif isinstance(exception, RuntimeError) and &#39;recursion depth&#39; in str(exception):</span>
<span class="gi">+            print(red(__(&#39;Recursion error:&#39;)), file=stderr)</span>
<span class="gi">+            print(terminal_safe(str(exception)), file=stderr)</span>
<span class="gi">+            print(file=stderr)</span>
<span class="gi">+            print(__(&#39;This can happen with very large or deeply nested source &#39;</span>
<span class="gi">+                     &#39;files. You can carefully increase the default Python &#39;</span>
<span class="gi">+                     &#39;recursion limit of 1000 in conf.py with e.g.:&#39;), file=stderr)</span>
<span class="gi">+            print(&#39;    import sys; sys.setrecursionlimit(1500)&#39;, file=stderr)</span>
<span class="gi">+        else:</span>
<span class="gi">+            print(red(__(&#39;Exception occurred:&#39;)), file=stderr)</span>
<span class="gi">+            print(format_exception_cut_frames().rstrip(), file=stderr)</span>
<span class="gi">+            tbpath = save_traceback(app, exception)</span>
<span class="gi">+            print(red(__(&#39;The full traceback has been saved in %s, if you &#39;</span>
<span class="gi">+                         &#39;want to report the issue to the developers.&#39;) % tbpath),</span>
<span class="gi">+                  file=stderr)</span>
<span class="gi">+            print(__(&#39;Please also report this if it was a user error, so &#39;</span>
<span class="gi">+                     &#39;that a better error message can be provided next time.&#39;),</span>
<span class="gi">+                  file=stderr)</span>
<span class="gi">+            print(__(&#39;A bug report can be filed in the tracker at &#39;</span>
<span class="gi">+                     &#39;&lt;https://github.com/sphinx-doc/sphinx/issues&gt;. Thanks!&#39;),</span>
<span class="gi">+                  file=stderr)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def jobs_argument(value: str) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Special type to handle &#39;auto&#39; flags passed to &#39;sphinx-build&#39; via -j flag. Can
<span class="w"> </span>    be expanded to handle other special scaling requests, such as setting job count
<span class="w"> </span>    to cpu_count.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value == &#39;auto&#39;:</span>
<span class="gi">+        return multiprocessing.cpu_count()</span>
<span class="gi">+    else:</span>
<span class="gi">+        jobs = int(value)</span>
<span class="gi">+        if jobs &lt;= 0:</span>
<span class="gi">+            raise argparse.ArgumentTypeError(__(&#39;job number should be a positive number&#39;))</span>
<span class="gi">+        else:</span>
<span class="gi">+            return jobs</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_parser() -&gt; argparse.ArgumentParser:</span>
<span class="gi">+    parser = argparse.ArgumentParser(</span>
<span class="gi">+        usage=&#39;%(prog)s [OPTIONS] SOURCEDIR OUTPUTDIR [FILENAMES...]&#39;,</span>
<span class="gi">+        epilog=__(&#39;For more information, visit &lt;https://www.sphinx-doc.org/&gt;.&#39;),</span>
<span class="gi">+        description=__(&quot;&quot;&quot;</span>
<span class="gi">+Generate documentation from source files.</span>
<span class="gi">+</span>
<span class="gi">+sphinx-build generates documentation from the files in SOURCEDIR and places it</span>
<span class="gi">+in OUTPUTDIR. It looks for &#39;conf.py&#39; in SOURCEDIR for the configuration</span>
<span class="gi">+settings. The &#39;sphinx-quickstart&#39; tool may be used to generate template files,</span>
<span class="gi">+including &#39;conf.py&#39;</span>
<span class="gi">+</span>
<span class="gi">+sphinx-build can create documentation in different formats. A format is</span>
<span class="gi">+selected by specifying the builder name on the command line; it defaults to</span>
<span class="gi">+HTML. Builders can also perform other tasks related to documentation</span>
<span class="gi">+processing.</span>
<span class="gi">+</span>
<span class="gi">+By default, everything that is outdated is built. Output only for selected</span>
<span class="gi">+files can be built by specifying individual filenames.</span>
<span class="gi">+&quot;&quot;&quot;))</span>

<span class="gi">+    parser.add_argument(&#39;--version&#39;, action=&#39;version&#39;, dest=&#39;show_version&#39;,</span>
<span class="gi">+                        version=f&#39;%(prog)s {__display_version__}&#39;)</span>

<span class="gd">-def make_main(argv: Sequence[str]) -&gt;int:</span>
<span class="gi">+    parser.add_argument(&#39;sourcedir&#39;, metavar=&#39;SOURCE_DIR&#39;,</span>
<span class="gi">+                        help=__(&#39;path to documentation source files&#39;))</span>
<span class="gi">+    parser.add_argument(&#39;outputdir&#39;, metavar=&#39;OUTPUT_DIR&#39;,</span>
<span class="gi">+                        help=__(&#39;path to output directory&#39;))</span>
<span class="gi">+    parser.add_argument(&#39;filenames&#39;, nargs=&#39;*&#39;,</span>
<span class="gi">+                        help=__(&#39;(optional) a list of specific files to rebuild. &#39;</span>
<span class="gi">+                                &#39;Ignored if --write-all is specified&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    group = parser.add_argument_group(__(&#39;general options&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--builder&#39;, &#39;-b&#39;, metavar=&#39;BUILDER&#39;, dest=&#39;builder&#39;,</span>
<span class="gi">+                       default=&#39;html&#39;,</span>
<span class="gi">+                       help=__(&quot;builder to use (default: &#39;html&#39;)&quot;))</span>
<span class="gi">+    group.add_argument(&#39;--jobs&#39;, &#39;-j&#39;, metavar=&#39;N&#39;, default=1, type=jobs_argument,</span>
<span class="gi">+                       dest=&#39;jobs&#39;,</span>
<span class="gi">+                       help=__(&#39;run in parallel with N processes, when possible. &#39;</span>
<span class="gi">+                               &quot;&#39;auto&#39; uses the number of CPU cores&quot;))</span>
<span class="gi">+    group.add_argument(&#39;--write-all&#39;, &#39;-a&#39;, action=&#39;store_true&#39;, dest=&#39;force_all&#39;,</span>
<span class="gi">+                       help=__(&#39;write all files (default: only write new and &#39;</span>
<span class="gi">+                               &#39;changed files)&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--fresh-env&#39;, &#39;-E&#39;, action=&#39;store_true&#39;, dest=&#39;freshenv&#39;,</span>
<span class="gi">+                       help=__(&quot;don&#39;t use a saved environment, always read &quot;</span>
<span class="gi">+                               &#39;all files&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    group = parser.add_argument_group(__(&#39;path options&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--doctree-dir&#39;, &#39;-d&#39;, metavar=&#39;PATH&#39;, dest=&#39;doctreedir&#39;,</span>
<span class="gi">+                       help=__(&#39;directory for doctree and environment files &#39;</span>
<span class="gi">+                               &#39;(default: OUTPUT_DIR/.doctrees)&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--conf-dir&#39;, &#39;-c&#39;, metavar=&#39;PATH&#39;, dest=&#39;confdir&#39;,</span>
<span class="gi">+                       help=__(&#39;directory for the configuration file (conf.py) &#39;</span>
<span class="gi">+                               &#39;(default: SOURCE_DIR)&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    group = parser.add_argument_group(&#39;build configuration options&#39;)</span>
<span class="gi">+    group.add_argument(&#39;--isolated&#39;, &#39;-C&#39;, action=&#39;store_true&#39;, dest=&#39;noconfig&#39;,</span>
<span class="gi">+                       help=__(&#39;use no configuration file, only use settings from -D options&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--define&#39;, &#39;-D&#39;, metavar=&#39;setting=value&#39;, action=&#39;append&#39;,</span>
<span class="gi">+                       dest=&#39;define&#39;, default=[],</span>
<span class="gi">+                       help=__(&#39;override a setting in configuration file&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--html-define&#39;, &#39;-A&#39;, metavar=&#39;name=value&#39;, action=&#39;append&#39;,</span>
<span class="gi">+                       dest=&#39;htmldefine&#39;, default=[],</span>
<span class="gi">+                       help=__(&#39;pass a value into HTML templates&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--tag&#39;, &#39;-t&#39;, metavar=&#39;TAG&#39;, action=&#39;append&#39;,</span>
<span class="gi">+                       dest=&#39;tags&#39;, default=[],</span>
<span class="gi">+                       help=__(&#39;define tag: include &quot;only&quot; blocks with TAG&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--nitpicky&#39;, &#39;-n&#39;, action=&#39;store_true&#39;, dest=&#39;nitpicky&#39;,</span>
<span class="gi">+                       help=__(&#39;nitpicky mode: warn about all missing references&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    group = parser.add_argument_group(__(&#39;console output options&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--verbose&#39;, &#39;-v&#39;, action=&#39;count&#39;, dest=&#39;verbosity&#39;,</span>
<span class="gi">+                       default=0,</span>
<span class="gi">+                       help=__(&#39;increase verbosity (can be repeated)&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--quiet&#39;, &#39;-q&#39;, action=&#39;store_true&#39;, dest=&#39;quiet&#39;,</span>
<span class="gi">+                       help=__(&#39;no output on stdout, just warnings on stderr&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--silent&#39;, &#39;-Q&#39;, action=&#39;store_true&#39;, dest=&#39;really_quiet&#39;,</span>
<span class="gi">+                       help=__(&#39;no output at all, not even warnings&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--color&#39;, action=&#39;store_const&#39;, dest=&#39;color&#39;,</span>
<span class="gi">+                       const=&#39;yes&#39;, default=&#39;auto&#39;,</span>
<span class="gi">+                       help=__(&#39;do emit colored output (default: auto-detect)&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--no-color&#39;, &#39;-N&#39;, action=&#39;store_const&#39;, dest=&#39;color&#39;,</span>
<span class="gi">+                       const=&#39;no&#39;,</span>
<span class="gi">+                       help=__(&#39;do not emit colored output (default: auto-detect)&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    group = parser.add_argument_group(__(&#39;warning control options&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--warning-file&#39;, &#39;-w&#39;, metavar=&#39;FILE&#39;, dest=&#39;warnfile&#39;,</span>
<span class="gi">+                       help=__(&#39;write warnings (and errors) to given file&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--fail-on-warning&#39;, &#39;-W&#39;, action=&#39;store_true&#39;, dest=&#39;warningiserror&#39;,</span>
<span class="gi">+                       help=__(&#39;turn warnings into errors&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--keep-going&#39;, action=&#39;store_true&#39;, help=argparse.SUPPRESS)</span>
<span class="gi">+    group.add_argument(&#39;--show-traceback&#39;, &#39;-T&#39;, action=&#39;store_true&#39;, dest=&#39;traceback&#39;,</span>
<span class="gi">+                       help=__(&#39;show full traceback on exception&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--pdb&#39;, &#39;-P&#39;, action=&#39;store_true&#39;, dest=&#39;pdb&#39;,</span>
<span class="gi">+                       help=__(&#39;run Pdb on exception&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--exception-on-warning&#39;, action=&#39;store_true&#39;,</span>
<span class="gi">+                       dest=&#39;exception_on_warning&#39;,</span>
<span class="gi">+                       help=__(&#39;raise an exception on warnings&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    if parser.prog == &#39;__main__.py&#39;:</span>
<span class="gi">+        parser.prog = &#39;sphinx-build&#39;</span>
<span class="gi">+</span>
<span class="gi">+    return parser</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make_main(argv: Sequence[str]) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Sphinx build &quot;make mode&quot; entry.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from sphinx.cmd import make_mode</span>
<span class="gi">+    return make_mode.run_make_mode(argv[1:])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _parse_arguments(parser: argparse.ArgumentParser,</span>
<span class="gi">+                     argv: Sequence[str]) -&gt; argparse.Namespace:</span>
<span class="gi">+    args = parser.parse_args(argv)</span>
<span class="gi">+    return args</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _parse_confdir(noconfig: bool, confdir: str, sourcedir: str) -&gt; str | None:</span>
<span class="gi">+    if noconfig:</span>
<span class="gi">+        return None</span>
<span class="gi">+    elif not confdir:</span>
<span class="gi">+        return sourcedir</span>
<span class="gi">+    return confdir</span>
<span class="gi">+</span>

<span class="gi">+def _parse_doctreedir(doctreedir: str, outputdir: str) -&gt; str:</span>
<span class="gi">+    if doctreedir:</span>
<span class="gi">+        return doctreedir</span>
<span class="gi">+    return os.path.join(outputdir, &#39;.doctrees&#39;)</span>

<span class="gd">-def build_main(argv: Sequence[str]) -&gt;int:</span>
<span class="gi">+</span>
<span class="gi">+def _validate_filenames(</span>
<span class="gi">+    parser: argparse.ArgumentParser, force_all: bool, filenames: list[str],</span>
<span class="gi">+) -&gt; None:</span>
<span class="gi">+    if force_all and filenames:</span>
<span class="gi">+        parser.error(__(&#39;cannot combine -a option and filenames&#39;))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _validate_colour_support(colour: str) -&gt; None:</span>
<span class="gi">+    if colour == &#39;no&#39; or (colour == &#39;auto&#39; and not color_terminal()):</span>
<span class="gi">+        nocolor()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _parse_logging(</span>
<span class="gi">+    parser: argparse.ArgumentParser,</span>
<span class="gi">+    quiet: bool,</span>
<span class="gi">+    really_quiet: bool,</span>
<span class="gi">+    warnfile: str | None,</span>
<span class="gi">+) -&gt; tuple[TextIO | None, TextIO | None, TextIO, TextIO | None]:</span>
<span class="gi">+    status: TextIO | None = sys.stdout</span>
<span class="gi">+    warning: TextIO | None = sys.stderr</span>
<span class="gi">+    error = sys.stderr</span>
<span class="gi">+</span>
<span class="gi">+    if quiet:</span>
<span class="gi">+        status = None</span>
<span class="gi">+</span>
<span class="gi">+    if really_quiet:</span>
<span class="gi">+        status = warning = None</span>
<span class="gi">+</span>
<span class="gi">+    warnfp = None</span>
<span class="gi">+    if warning and warnfile:</span>
<span class="gi">+        try:</span>
<span class="gi">+            warnfile = path.abspath(warnfile)</span>
<span class="gi">+            ensuredir(path.dirname(warnfile))</span>
<span class="gi">+            # the caller is responsible for closing this file descriptor</span>
<span class="gi">+            warnfp = open(warnfile, &#39;w&#39;, encoding=&quot;utf-8&quot;)  # NoQA: SIM115</span>
<span class="gi">+        except Exception as exc:</span>
<span class="gi">+            parser.error(__(&#39;cannot open warning file %r: %s&#39;) % (</span>
<span class="gi">+                warnfile, exc))</span>
<span class="gi">+        warning = TeeStripANSI(warning, warnfp)  # type: ignore[assignment]</span>
<span class="gi">+        error = warning</span>
<span class="gi">+</span>
<span class="gi">+    return status, warning, error, warnfp</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _parse_confoverrides(</span>
<span class="gi">+    parser: argparse.ArgumentParser,</span>
<span class="gi">+    define: list[str],</span>
<span class="gi">+    htmldefine: list[str],</span>
<span class="gi">+    nitpicky: bool,</span>
<span class="gi">+) -&gt; dict[str, Any]:</span>
<span class="gi">+    confoverrides: dict[str, Any] = {}</span>
<span class="gi">+    val: Any</span>
<span class="gi">+    for val in define:</span>
<span class="gi">+        try:</span>
<span class="gi">+            key, val = val.split(&#39;=&#39;, 1)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            parser.error(__(&#39;-D option argument must be in the form name=value&#39;))</span>
<span class="gi">+        confoverrides[key] = val</span>
<span class="gi">+</span>
<span class="gi">+    for val in htmldefine:</span>
<span class="gi">+        try:</span>
<span class="gi">+            key, val = val.split(&#39;=&#39;)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            parser.error(__(&#39;-A option argument must be in the form name=value&#39;))</span>
<span class="gi">+        with contextlib.suppress(ValueError):</span>
<span class="gi">+            val = int(val)</span>
<span class="gi">+</span>
<span class="gi">+        confoverrides[f&#39;html_context.{key}&#39;] = val</span>
<span class="gi">+</span>
<span class="gi">+    if nitpicky:</span>
<span class="gi">+        confoverrides[&#39;nitpicky&#39;] = True</span>
<span class="gi">+</span>
<span class="gi">+    return confoverrides</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def build_main(argv: Sequence[str]) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Sphinx build &quot;main&quot; command-line entry.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parser = get_parser()</span>
<span class="gi">+    args = _parse_arguments(parser, argv)</span>
<span class="gi">+    args.confdir = _parse_confdir(args.noconfig, args.confdir, args.sourcedir)</span>
<span class="gi">+    args.doctreedir = _parse_doctreedir(args.doctreedir, args.outputdir)</span>
<span class="gi">+    _validate_filenames(parser, args.force_all, args.filenames)</span>
<span class="gi">+    _validate_colour_support(args.color)</span>
<span class="gi">+    args.status, args.warning, args.error, warnfp = _parse_logging(</span>
<span class="gi">+        parser, args.quiet, args.really_quiet, args.warnfile)</span>
<span class="gi">+    args.confoverrides = _parse_confoverrides(</span>
<span class="gi">+        parser, args.define, args.htmldefine, args.nitpicky)</span>
<span class="gi">+</span>
<span class="gi">+    app = None</span>
<span class="gi">+    try:</span>
<span class="gi">+        confdir = args.confdir or args.sourcedir</span>
<span class="gi">+        with patch_docutils(confdir), docutils_namespace():</span>
<span class="gi">+            app = Sphinx(</span>
<span class="gi">+                srcdir=args.sourcedir, confdir=args.confdir,</span>
<span class="gi">+                outdir=args.outputdir, doctreedir=args.doctreedir,</span>
<span class="gi">+                buildername=args.builder, confoverrides=args.confoverrides,</span>
<span class="gi">+                status=args.status, warning=args.warning,</span>
<span class="gi">+                freshenv=args.freshenv, warningiserror=args.warningiserror,</span>
<span class="gi">+                tags=args.tags,</span>
<span class="gi">+                verbosity=args.verbosity, parallel=args.jobs, keep_going=False,</span>
<span class="gi">+                pdb=args.pdb, exception_on_warning=args.exception_on_warning,</span>
<span class="gi">+            )</span>
<span class="gi">+            app.build(args.force_all, args.filenames)</span>
<span class="gi">+            return app.statuscode</span>
<span class="gi">+    except (Exception, KeyboardInterrupt) as exc:</span>
<span class="gi">+        handle_exception(app, args, exc, args.error)</span>
<span class="gi">+        return 2</span>
<span class="gi">+    finally:</span>
<span class="gi">+        if warnfp is not None:</span>
<span class="gi">+            # close the file descriptor for the warnings file opened by Sphinx</span>
<span class="gi">+            warnfp.close()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _bug_report_info() -&gt; int:</span>
<span class="gi">+    from platform import platform, python_implementation</span>
<span class="gi">+</span>
<span class="gi">+    import docutils</span>
<span class="gi">+    import jinja2</span>
<span class="gi">+    import pygments</span>
<span class="gi">+</span>
<span class="gi">+    print(&#39;Please paste all output below into the bug report template\n\n&#39;)</span>
<span class="gi">+    print(&#39;```text&#39;)</span>
<span class="gi">+    print(f&#39;Platform:              {sys.platform}; ({platform()})&#39;)</span>
<span class="gi">+    print(f&#39;Python version:        {sys.version})&#39;)</span>
<span class="gi">+    print(f&#39;Python implementation: {python_implementation()}&#39;)</span>
<span class="gi">+    print(f&#39;Sphinx version:        {sphinx.__display_version__}&#39;)</span>
<span class="gi">+    print(f&#39;Docutils version:      {docutils.__version__}&#39;)</span>
<span class="gi">+    print(f&#39;Jinja2 version:        {jinja2.__version__}&#39;)</span>
<span class="gi">+    print(f&#39;Pygments version:      {pygments.__version__}&#39;)</span>
<span class="gi">+    print(&#39;```&#39;)</span>
<span class="gi">+    return 0</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def main(argv: Sequence[str] = (), /) -&gt; int:</span>
<span class="gi">+    locale.setlocale(locale.LC_ALL, &#39;&#39;)</span>
<span class="gi">+    sphinx.locale.init_console()</span>
<span class="gi">+</span>
<span class="gi">+    if not argv:</span>
<span class="gi">+        argv = sys.argv[1:]</span>
<span class="gi">+</span>
<span class="gi">+    # Allow calling as &#39;python -m sphinx build &#39;</span>
<span class="gi">+    if argv[:1] == [&#39;build&#39;]:</span>
<span class="gi">+        argv = argv[1:]</span>
<span class="gi">+</span>
<span class="gi">+    if argv[:1] == [&#39;--bug-report&#39;]:</span>
<span class="gi">+        return _bug_report_info()</span>
<span class="gi">+    if argv[:1] == [&#39;-M&#39;]:</span>
<span class="gi">+        from sphinx.cmd import make_mode</span>
<span class="gi">+        return make_mode.run_make_mode(argv[1:])</span>
<span class="gi">+    else:</span>
<span class="gi">+        return build_main(argv)</span>


<span class="w"> </span>if __name__ == &#39;__main__&#39;:
<span class="gh">diff --git a/sphinx/cmd/make_mode.py b/sphinx/cmd/make_mode.py</span>
<span class="gh">index f817e7f32..d1ba3fccf 100644</span>
<span class="gd">--- a/sphinx/cmd/make_mode.py</span>
<span class="gi">+++ b/sphinx/cmd/make_mode.py</span>
<span class="gu">@@ -6,51 +6,201 @@ of Makefile / make.bat.</span>
<span class="w"> </span>This is in its own module so that importing it is fast.  It should not
<span class="w"> </span>import the main Sphinx modules (like sphinx.applications, sphinx.builders).
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import subprocess
<span class="w"> </span>import sys
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>import sphinx
<span class="w"> </span>from sphinx.cmd.build import build_main
<span class="w"> </span>from sphinx.util.console import blue, bold, color_terminal, nocolor
<span class="w"> </span>from sphinx.util.osutil import rmtree
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &gt;= (3, 11):
<span class="w"> </span>    from contextlib import chdir
<span class="w"> </span>else:
<span class="w"> </span>    from sphinx.util.osutil import _chdir as chdir
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Sequence
<span class="gd">-BUILDERS = [(&#39;&#39;, &#39;html&#39;, &#39;to make standalone HTML files&#39;), (&#39;&#39;, &#39;dirhtml&#39;,</span>
<span class="gd">-    &#39;to make HTML files named index.html in directories&#39;), (&#39;&#39;,</span>
<span class="gd">-    &#39;singlehtml&#39;, &#39;to make a single large HTML file&#39;), (&#39;&#39;, &#39;pickle&#39;,</span>
<span class="gd">-    &#39;to make pickle files&#39;), (&#39;&#39;, &#39;json&#39;, &#39;to make JSON files&#39;), (&#39;&#39;,</span>
<span class="gd">-    &#39;htmlhelp&#39;, &#39;to make HTML files and an HTML help project&#39;), (&#39;&#39;,</span>
<span class="gd">-    &#39;qthelp&#39;, &#39;to make HTML files and a qthelp project&#39;), (&#39;&#39;, &#39;devhelp&#39;,</span>
<span class="gd">-    &#39;to make HTML files and a Devhelp project&#39;), (&#39;&#39;, &#39;epub&#39;,</span>
<span class="gd">-    &#39;to make an epub&#39;), (&#39;&#39;, &#39;latex&#39;,</span>
<span class="gd">-    &#39;to make LaTeX files, you can set PAPER=a4 or PAPER=letter&#39;), (&#39;posix&#39;,</span>
<span class="gd">-    &#39;latexpdf&#39;, &#39;to make LaTeX and PDF files (default pdflatex)&#39;), (&#39;posix&#39;,</span>
<span class="gd">-    &#39;latexpdfja&#39;,</span>
<span class="gd">-    &#39;to make LaTeX files and run them through platex/dvipdfmx&#39;), (&#39;&#39;,</span>
<span class="gd">-    &#39;text&#39;, &#39;to make text files&#39;), (&#39;&#39;, &#39;man&#39;, &#39;to make manual pages&#39;), (&#39;&#39;,</span>
<span class="gd">-    &#39;texinfo&#39;, &#39;to make Texinfo files&#39;), (&#39;posix&#39;, &#39;info&#39;,</span>
<span class="gd">-    &#39;to make Texinfo files and run them through makeinfo&#39;), (&#39;&#39;, &#39;gettext&#39;,</span>
<span class="gd">-    &#39;to make PO message catalogs&#39;), (&#39;&#39;, &#39;changes&#39;,</span>
<span class="gd">-    &#39;to make an overview of all changed/added/deprecated items&#39;), (&#39;&#39;,</span>
<span class="gd">-    &#39;xml&#39;, &#39;to make Docutils-native XML files&#39;), (&#39;&#39;, &#39;pseudoxml&#39;,</span>
<span class="gd">-    &#39;to make pseudoxml-XML files for display purposes&#39;), (&#39;&#39;, &#39;linkcheck&#39;,</span>
<span class="gd">-    &#39;to check all external links for integrity&#39;), (&#39;&#39;, &#39;doctest&#39;,</span>
<span class="gd">-    &#39;to run all doctests embedded in the documentation (if enabled)&#39;), (&#39;&#39;,</span>
<span class="gd">-    &#39;coverage&#39;, &#39;to run coverage check of the documentation (if enabled)&#39;),</span>
<span class="gd">-    (&#39;&#39;, &#39;clean&#39;, &#39;to remove everything in the build directory&#39;)]</span>

<span class="gi">+BUILDERS = [</span>
<span class="gi">+    (&quot;&quot;,      &quot;html&quot;,        &quot;to make standalone HTML files&quot;),</span>
<span class="gi">+    (&quot;&quot;,      &quot;dirhtml&quot;,     &quot;to make HTML files named index.html in directories&quot;),</span>
<span class="gi">+    (&quot;&quot;,      &quot;singlehtml&quot;,  &quot;to make a single large HTML file&quot;),</span>
<span class="gi">+    (&quot;&quot;,      &quot;pickle&quot;,      &quot;to make pickle files&quot;),</span>
<span class="gi">+    (&quot;&quot;,      &quot;json&quot;,        &quot;to make JSON files&quot;),</span>
<span class="gi">+    (&quot;&quot;,      &quot;htmlhelp&quot;,    &quot;to make HTML files and an HTML help project&quot;),</span>
<span class="gi">+    (&quot;&quot;,      &quot;qthelp&quot;,      &quot;to make HTML files and a qthelp project&quot;),</span>
<span class="gi">+    (&quot;&quot;,      &quot;devhelp&quot;,     &quot;to make HTML files and a Devhelp project&quot;),</span>
<span class="gi">+    (&quot;&quot;,      &quot;epub&quot;,        &quot;to make an epub&quot;),</span>
<span class="gi">+    (&quot;&quot;,      &quot;latex&quot;,       &quot;to make LaTeX files, you can set PAPER=a4 or PAPER=letter&quot;),</span>
<span class="gi">+    (&quot;posix&quot;, &quot;latexpdf&quot;,    &quot;to make LaTeX and PDF files (default pdflatex)&quot;),</span>
<span class="gi">+    (&quot;posix&quot;, &quot;latexpdfja&quot;,  &quot;to make LaTeX files and run them through platex/dvipdfmx&quot;),</span>
<span class="gi">+    (&quot;&quot;,      &quot;text&quot;,        &quot;to make text files&quot;),</span>
<span class="gi">+    (&quot;&quot;,      &quot;man&quot;,         &quot;to make manual pages&quot;),</span>
<span class="gi">+    (&quot;&quot;,      &quot;texinfo&quot;,     &quot;to make Texinfo files&quot;),</span>
<span class="gi">+    (&quot;posix&quot;, &quot;info&quot;,        &quot;to make Texinfo files and run them through makeinfo&quot;),</span>
<span class="gi">+    (&quot;&quot;,      &quot;gettext&quot;,     &quot;to make PO message catalogs&quot;),</span>
<span class="gi">+    (&quot;&quot;,      &quot;changes&quot;,     &quot;to make an overview of all changed/added/deprecated items&quot;),</span>
<span class="gi">+    (&quot;&quot;,      &quot;xml&quot;,         &quot;to make Docutils-native XML files&quot;),</span>
<span class="gi">+    (&quot;&quot;,      &quot;pseudoxml&quot;,   &quot;to make pseudoxml-XML files for display purposes&quot;),</span>
<span class="gi">+    (&quot;&quot;,      &quot;linkcheck&quot;,   &quot;to check all external links for integrity&quot;),</span>
<span class="gi">+    (&quot;&quot;,      &quot;doctest&quot;,     &quot;to run all doctests embedded in the documentation &quot;</span>
<span class="gi">+                             &quot;(if enabled)&quot;),</span>
<span class="gi">+    (&quot;&quot;,      &quot;coverage&quot;,    &quot;to run coverage check of the documentation (if enabled)&quot;),</span>
<span class="gi">+    (&quot;&quot;,      &quot;clean&quot;,       &quot;to remove everything in the build directory&quot;),</span>
<span class="gi">+]</span>

<span class="gd">-class Make:</span>

<span class="gd">-    def __init__(self, *, source_dir: str, build_dir: str, opts: Sequence[str]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+class Make:</span>
<span class="gi">+    def __init__(self, *, source_dir: str, build_dir: str, opts: Sequence[str]) -&gt; None:</span>
<span class="w"> </span>        self.source_dir = source_dir
<span class="w"> </span>        self.build_dir = build_dir
<span class="w"> </span>        self.opts = [*opts]
<span class="gi">+</span>
<span class="gi">+    def build_dir_join(self, *comps: str) -&gt; str:</span>
<span class="gi">+        return path.join(self.build_dir, *comps)</span>
<span class="gi">+</span>
<span class="gi">+    def build_clean(self) -&gt; int:</span>
<span class="gi">+        source_dir = path.abspath(self.source_dir)</span>
<span class="gi">+        build_dir = path.abspath(self.build_dir)</span>
<span class="gi">+        if not path.exists(self.build_dir):</span>
<span class="gi">+            return 0</span>
<span class="gi">+        elif not path.isdir(self.build_dir):</span>
<span class="gi">+            print(&quot;Error: %r is not a directory!&quot; % self.build_dir)</span>
<span class="gi">+            return 1</span>
<span class="gi">+        elif source_dir == build_dir:</span>
<span class="gi">+            print(&quot;Error: %r is same as source directory!&quot; % self.build_dir)</span>
<span class="gi">+            return 1</span>
<span class="gi">+        elif path.commonpath([source_dir, build_dir]) == build_dir:</span>
<span class="gi">+            print(&quot;Error: %r directory contains source directory!&quot; % self.build_dir)</span>
<span class="gi">+            return 1</span>
<span class="gi">+        print(&quot;Removing everything under %r...&quot; % self.build_dir)</span>
<span class="gi">+        for item in os.listdir(self.build_dir):</span>
<span class="gi">+            rmtree(self.build_dir_join(item))</span>
<span class="gi">+        return 0</span>
<span class="gi">+</span>
<span class="gi">+    def build_help(self) -&gt; None:</span>
<span class="gi">+        if not color_terminal():</span>
<span class="gi">+            nocolor()</span>
<span class="gi">+</span>
<span class="gi">+        print(bold(&quot;Sphinx v%s&quot; % sphinx.__display_version__))</span>
<span class="gi">+        print(&quot;Please use `make %s&#39; where %s is one of&quot; % ((blue(&#39;target&#39;),) * 2))</span>
<span class="gi">+        for osname, bname, description in BUILDERS:</span>
<span class="gi">+            if not osname or os.name == osname:</span>
<span class="gi">+                print(f&#39;  {blue(bname.ljust(10))}  {description}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def build_latexpdf(self) -&gt; int:</span>
<span class="gi">+        if self.run_generic_build(&#39;latex&#39;) &gt; 0:</span>
<span class="gi">+            return 1</span>
<span class="gi">+</span>
<span class="gi">+        # Use $MAKE to determine the make command</span>
<span class="gi">+        make_fallback = &#39;make.bat&#39; if sys.platform == &#39;win32&#39; else &#39;make&#39;</span>
<span class="gi">+        makecmd = os.environ.get(&#39;MAKE&#39;, make_fallback)</span>
<span class="gi">+        if not makecmd.lower().startswith(&#39;make&#39;):</span>
<span class="gi">+            raise RuntimeError(&#39;Invalid $MAKE command: %r&#39; % makecmd)</span>
<span class="gi">+        try:</span>
<span class="gi">+            with chdir(self.build_dir_join(&#39;latex&#39;)):</span>
<span class="gi">+                if &#39;-Q&#39; in self.opts:</span>
<span class="gi">+                    with open(&#39;__LATEXSTDOUT__&#39;, &#39;w&#39;) as outfile:</span>
<span class="gi">+                        returncode = subprocess.call([makecmd,</span>
<span class="gi">+                                                      &#39;all-pdf&#39;,</span>
<span class="gi">+                                                      &#39;LATEXOPTS=-halt-on-error&#39;,</span>
<span class="gi">+                                                      ],</span>
<span class="gi">+                                                     stdout=outfile,</span>
<span class="gi">+                                                     stderr=subprocess.STDOUT,</span>
<span class="gi">+                                                     )</span>
<span class="gi">+                    if returncode:</span>
<span class="gi">+                        print(&#39;Latex error: check %s&#39; %</span>
<span class="gi">+                              self.build_dir_join(&#39;latex&#39;, &#39;__LATEXSTDOUT__&#39;)</span>
<span class="gi">+                              )</span>
<span class="gi">+                elif &#39;-q&#39; in self.opts:</span>
<span class="gi">+                    returncode = subprocess.call(</span>
<span class="gi">+                        [makecmd,</span>
<span class="gi">+                         &#39;all-pdf&#39;,</span>
<span class="gi">+                         &#39;LATEXOPTS=-halt-on-error&#39;,</span>
<span class="gi">+                         &#39;LATEXMKOPTS=-silent&#39;,</span>
<span class="gi">+                         ],</span>
<span class="gi">+                    )</span>
<span class="gi">+                    if returncode:</span>
<span class="gi">+                        print(&#39;Latex error: check .log file in %s&#39; %</span>
<span class="gi">+                              self.build_dir_join(&#39;latex&#39;)</span>
<span class="gi">+                              )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    returncode = subprocess.call([makecmd, &#39;all-pdf&#39;])</span>
<span class="gi">+                return returncode</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            print(&#39;Error: Failed to run: %s&#39; % makecmd)</span>
<span class="gi">+            return 1</span>
<span class="gi">+</span>
<span class="gi">+    def build_latexpdfja(self) -&gt; int:</span>
<span class="gi">+        if self.run_generic_build(&#39;latex&#39;) &gt; 0:</span>
<span class="gi">+            return 1</span>
<span class="gi">+</span>
<span class="gi">+        # Use $MAKE to determine the make command</span>
<span class="gi">+        make_fallback = &#39;make.bat&#39; if sys.platform == &#39;win32&#39; else &#39;make&#39;</span>
<span class="gi">+        makecmd = os.environ.get(&#39;MAKE&#39;, make_fallback)</span>
<span class="gi">+        if not makecmd.lower().startswith(&#39;make&#39;):</span>
<span class="gi">+            raise RuntimeError(&#39;Invalid $MAKE command: %r&#39; % makecmd)</span>
<span class="gi">+        try:</span>
<span class="gi">+            with chdir(self.build_dir_join(&#39;latex&#39;)):</span>
<span class="gi">+                return subprocess.call([makecmd, &#39;all-pdf&#39;])</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            print(&#39;Error: Failed to run: %s&#39; % makecmd)</span>
<span class="gi">+            return 1</span>
<span class="gi">+</span>
<span class="gi">+    def build_info(self) -&gt; int:</span>
<span class="gi">+        if self.run_generic_build(&#39;texinfo&#39;) &gt; 0:</span>
<span class="gi">+            return 1</span>
<span class="gi">+</span>
<span class="gi">+        # Use $MAKE to determine the make command</span>
<span class="gi">+        makecmd = os.environ.get(&#39;MAKE&#39;, &#39;make&#39;)</span>
<span class="gi">+        if not makecmd.lower().startswith(&#39;make&#39;):</span>
<span class="gi">+            raise RuntimeError(&#39;Invalid $MAKE command: %r&#39; % makecmd)</span>
<span class="gi">+        try:</span>
<span class="gi">+            with chdir(self.build_dir_join(&#39;texinfo&#39;)):</span>
<span class="gi">+                return subprocess.call([makecmd, &#39;info&#39;])</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            print(&#39;Error: Failed to run: %s&#39; % makecmd)</span>
<span class="gi">+            return 1</span>
<span class="gi">+</span>
<span class="gi">+    def build_gettext(self) -&gt; int:</span>
<span class="gi">+        dtdir = self.build_dir_join(&#39;gettext&#39;, &#39;.doctrees&#39;)</span>
<span class="gi">+        if self.run_generic_build(&#39;gettext&#39;, doctreedir=dtdir) &gt; 0:</span>
<span class="gi">+            return 1</span>
<span class="gi">+        return 0</span>
<span class="gi">+</span>
<span class="gi">+    def run_generic_build(self, builder: str, doctreedir: str | None = None) -&gt; int:</span>
<span class="gi">+        # compatibility with old Makefile</span>
<span class="gi">+        paper_size = os.getenv(&#39;PAPER&#39;, &#39;&#39;)</span>
<span class="gi">+        if paper_size in {&#39;a4&#39;, &#39;letter&#39;}:</span>
<span class="gi">+            self.opts.extend([&#39;-D&#39;, f&#39;latex_elements.papersize={paper_size}paper&#39;])</span>
<span class="gi">+        if doctreedir is None:</span>
<span class="gi">+            doctreedir = self.build_dir_join(&#39;doctrees&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        args = [</span>
<span class="gi">+            &#39;--builder&#39;, builder,</span>
<span class="gi">+            &#39;--doctree-dir&#39;, doctreedir,</span>
<span class="gi">+            self.source_dir,</span>
<span class="gi">+            self.build_dir_join(builder),</span>
<span class="gi">+        ]</span>
<span class="gi">+        return build_main(args + self.opts)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def run_make_mode(args: Sequence[str]) -&gt; int:</span>
<span class="gi">+    if len(args) &lt; 3:</span>
<span class="gi">+        print(&#39;Error: at least 3 arguments (builder, source &#39;</span>
<span class="gi">+              &#39;dir, build dir) are required.&#39;, file=sys.stderr)</span>
<span class="gi">+        return 1</span>
<span class="gi">+</span>
<span class="gi">+    builder_name = args[0]</span>
<span class="gi">+    make = Make(source_dir=args[1], build_dir=args[2], opts=args[3:])</span>
<span class="gi">+    run_method = f&#39;build_{builder_name}&#39;</span>
<span class="gi">+    if hasattr(make, run_method):</span>
<span class="gi">+        return getattr(make, run_method)()</span>
<span class="gi">+    return make.run_generic_build(builder_name)</span>
<span class="gh">diff --git a/sphinx/cmd/quickstart.py b/sphinx/cmd/quickstart.py</span>
<span class="gh">index c9bb73784..4ae4556ca 100644</span>
<span class="gd">--- a/sphinx/cmd/quickstart.py</span>
<span class="gi">+++ b/sphinx/cmd/quickstart.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Quickly setup documentation source to work with Sphinx.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import argparse
<span class="w"> </span>import locale
<span class="w"> </span>import os
<span class="gu">@@ -7,70 +9,184 @@ import sys</span>
<span class="w"> </span>import time
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="gi">+# try to import readline, unix specific enhancement</span>
<span class="w"> </span>try:
<span class="w"> </span>    import readline
<span class="gd">-    if TYPE_CHECKING and sys.platform == &#39;win32&#39;:</span>
<span class="gi">+    if TYPE_CHECKING and sys.platform == &quot;win32&quot;:  # always false, for type checking</span>
<span class="w"> </span>        raise ImportError
<span class="w"> </span>    READLINE_AVAILABLE = True
<span class="w"> </span>    if readline.__doc__ and &#39;libedit&#39; in readline.__doc__:
<span class="gd">-        readline.parse_and_bind(&#39;bind ^I rl_complete&#39;)</span>
<span class="gi">+        readline.parse_and_bind(&quot;bind ^I rl_complete&quot;)</span>
<span class="w"> </span>        USE_LIBEDIT = True
<span class="w"> </span>    else:
<span class="gd">-        readline.parse_and_bind(&#39;tab: complete&#39;)</span>
<span class="gi">+        readline.parse_and_bind(&quot;tab: complete&quot;)</span>
<span class="w"> </span>        USE_LIBEDIT = False
<span class="w"> </span>except ImportError:
<span class="w"> </span>    READLINE_AVAILABLE = False
<span class="w"> </span>    USE_LIBEDIT = False
<span class="gi">+</span>
<span class="w"> </span>from docutils.utils import column_width
<span class="gi">+</span>
<span class="w"> </span>import sphinx.locale
<span class="w"> </span>from sphinx import __display_version__, package_dir
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.util.console import bold, color_terminal, colorize, nocolor, red
<span class="w"> </span>from sphinx.util.osutil import ensuredir
<span class="w"> </span>from sphinx.util.template import SphinxRenderer
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Callable, Sequence
<span class="gd">-EXTENSIONS = {&#39;autodoc&#39;: __(&#39;automatically insert docstrings from modules&#39;),</span>
<span class="gi">+</span>
<span class="gi">+EXTENSIONS = {</span>
<span class="gi">+    &#39;autodoc&#39;: __(&#39;automatically insert docstrings from modules&#39;),</span>
<span class="w"> </span>    &#39;doctest&#39;: __(&#39;automatically test code snippets in doctest blocks&#39;),
<span class="gd">-    &#39;intersphinx&#39;: __(</span>
<span class="gd">-    &#39;link between Sphinx documentation of different projects&#39;), &#39;todo&#39;: __(</span>
<span class="gd">-    &#39;write &quot;todo&quot; entries that can be shown or hidden on build&#39;),</span>
<span class="gd">-    &#39;coverage&#39;: __(&#39;checks for documentation coverage&#39;), &#39;imgmath&#39;: __(</span>
<span class="gd">-    &#39;include math, rendered as PNG or SVG images&#39;), &#39;mathjax&#39;: __(</span>
<span class="gd">-    &#39;include math, rendered in the browser by MathJax&#39;), &#39;ifconfig&#39;: __(</span>
<span class="gd">-    &#39;conditional inclusion of content based on config values&#39;), &#39;viewcode&#39;:</span>
<span class="gd">-    __(&#39;include links to the source code of documented Python objects&#39;),</span>
<span class="gd">-    &#39;githubpages&#39;: __(</span>
<span class="gd">-    &#39;create .nojekyll file to publish the document on GitHub pages&#39;)}</span>
<span class="gd">-DEFAULTS = {&#39;path&#39;: &#39;.&#39;, &#39;sep&#39;: False, &#39;dot&#39;: &#39;_&#39;, &#39;language&#39;: None,</span>
<span class="gd">-    &#39;suffix&#39;: &#39;.rst&#39;, &#39;master&#39;: &#39;index&#39;, &#39;makefile&#39;: True, &#39;batchfile&#39;: True}</span>
<span class="gi">+    &#39;intersphinx&#39;: __(&#39;link between Sphinx documentation of different projects&#39;),</span>
<span class="gi">+    &#39;todo&#39;: __(&#39;write &quot;todo&quot; entries that can be shown or hidden on build&#39;),</span>
<span class="gi">+    &#39;coverage&#39;: __(&#39;checks for documentation coverage&#39;),</span>
<span class="gi">+    &#39;imgmath&#39;: __(&#39;include math, rendered as PNG or SVG images&#39;),</span>
<span class="gi">+    &#39;mathjax&#39;: __(&#39;include math, rendered in the browser by MathJax&#39;),</span>
<span class="gi">+    &#39;ifconfig&#39;: __(&#39;conditional inclusion of content based on config values&#39;),</span>
<span class="gi">+    &#39;viewcode&#39;: __(&#39;include links to the source code of documented Python objects&#39;),</span>
<span class="gi">+    &#39;githubpages&#39;: __(&#39;create .nojekyll file to publish the document on GitHub pages&#39;),</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+DEFAULTS = {</span>
<span class="gi">+    &#39;path&#39;: &#39;.&#39;,</span>
<span class="gi">+    &#39;sep&#39;: False,</span>
<span class="gi">+    &#39;dot&#39;: &#39;_&#39;,</span>
<span class="gi">+    &#39;language&#39;: None,</span>
<span class="gi">+    &#39;suffix&#39;: &#39;.rst&#39;,</span>
<span class="gi">+    &#39;master&#39;: &#39;index&#39;,</span>
<span class="gi">+    &#39;makefile&#39;: True,</span>
<span class="gi">+    &#39;batchfile&#39;: True,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="w"> </span>PROMPT_PREFIX = &#39;&gt; &#39;
<span class="gi">+</span>
<span class="w"> </span>if sys.platform == &#39;win32&#39;:
<span class="gi">+    # On Windows, show questions as bold because of color scheme of PowerShell (refs: #5294).</span>
<span class="w"> </span>    COLOR_QUESTION = &#39;bold&#39;
<span class="w"> </span>else:
<span class="w"> </span>    COLOR_QUESTION = &#39;purple&#39;


<span class="gi">+# function to get input from terminal -- overridden by the test suite</span>
<span class="gi">+def term_input(prompt: str) -&gt; str:</span>
<span class="gi">+    if sys.platform == &#39;win32&#39;:</span>
<span class="gi">+        # Important: On windows, readline is not enabled by default.  In these</span>
<span class="gi">+        #            environment, escape sequences have been broken.  To avoid the</span>
<span class="gi">+        #            problem, quickstart uses ``print()`` to show prompt.</span>
<span class="gi">+        print(prompt, end=&#39;&#39;)</span>
<span class="gi">+        return input(&#39;&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return input(prompt)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class ValidationError(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Raised for validation errors.&quot;&quot;&quot;


<span class="gd">-class QuickstartRenderer(SphinxRenderer):</span>
<span class="gi">+def is_path(x: str) -&gt; str:</span>
<span class="gi">+    x = path.expanduser(x)</span>
<span class="gi">+    if not path.isdir(x):</span>
<span class="gi">+        raise ValidationError(__(&quot;Please enter a valid path name.&quot;))</span>
<span class="gi">+    return x</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_path_or_empty(x: str) -&gt; str:</span>
<span class="gi">+    if x == &#39;&#39;:</span>
<span class="gi">+        return x</span>
<span class="gi">+    return is_path(x)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def allow_empty(x: str) -&gt; str:</span>
<span class="gi">+    return x</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def nonempty(x: str) -&gt; str:</span>
<span class="gi">+    if not x:</span>
<span class="gi">+        raise ValidationError(__(&quot;Please enter some text.&quot;))</span>
<span class="gi">+    return x</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def choice(*l: str) -&gt; Callable[[str], str]:</span>
<span class="gi">+    def val(x: str) -&gt; str:</span>
<span class="gi">+        if x not in l:</span>
<span class="gi">+            raise ValidationError(__(&#39;Please enter one of %s.&#39;) % &#39;, &#39;.join(l))</span>
<span class="gi">+        return x</span>
<span class="gi">+    return val</span>
<span class="gi">+</span>

<span class="gd">-    def __init__(self, templatedir: str=&#39;&#39;) -&gt;None:</span>
<span class="gi">+def boolean(x: str) -&gt; bool:</span>
<span class="gi">+    if x.upper() not in (&#39;Y&#39;, &#39;YES&#39;, &#39;N&#39;, &#39;NO&#39;):</span>
<span class="gi">+        raise ValidationError(__(&quot;Please enter either &#39;y&#39; or &#39;n&#39;.&quot;))</span>
<span class="gi">+    return x.upper() in (&#39;Y&#39;, &#39;YES&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def suffix(x: str) -&gt; str:</span>
<span class="gi">+    if not (x[0:1] == &#39;.&#39; and len(x) &gt; 1):</span>
<span class="gi">+        raise ValidationError(__(&quot;Please enter a file suffix, e.g. &#39;.rst&#39; or &#39;.txt&#39;.&quot;))</span>
<span class="gi">+    return x</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ok(x: str) -&gt; str:</span>
<span class="gi">+    return x</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def do_prompt(</span>
<span class="gi">+    text: str, default: str | None = None, validator: Callable[[str], Any] = nonempty,</span>
<span class="gi">+) -&gt; str | bool:</span>
<span class="gi">+    while True:</span>
<span class="gi">+        if default is not None:</span>
<span class="gi">+            prompt = PROMPT_PREFIX + f&#39;{text} [{default}]: &#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            prompt = PROMPT_PREFIX + text + &#39;: &#39;</span>
<span class="gi">+        if USE_LIBEDIT:</span>
<span class="gi">+            # Note: libedit has a problem for combination of ``input()`` and escape</span>
<span class="gi">+            # sequence (see #5335).  To avoid the problem, all prompts are not colored</span>
<span class="gi">+            # on libedit.</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif READLINE_AVAILABLE:</span>
<span class="gi">+            # pass input_mode=True if readline available</span>
<span class="gi">+            prompt = colorize(COLOR_QUESTION, prompt, input_mode=True)</span>
<span class="gi">+        else:</span>
<span class="gi">+            prompt = colorize(COLOR_QUESTION, prompt, input_mode=False)</span>
<span class="gi">+        x = term_input(prompt).strip()</span>
<span class="gi">+        if default and not x:</span>
<span class="gi">+            x = default</span>
<span class="gi">+        try:</span>
<span class="gi">+            x = validator(x)</span>
<span class="gi">+        except ValidationError as err:</span>
<span class="gi">+            print(red(&#39;* &#39; + str(err)))</span>
<span class="gi">+            continue</span>
<span class="gi">+        break</span>
<span class="gi">+    return x</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class QuickstartRenderer(SphinxRenderer):</span>
<span class="gi">+    def __init__(self, templatedir: str = &#39;&#39;) -&gt; None:</span>
<span class="w"> </span>        self.templatedir = templatedir
<span class="w"> </span>        super().__init__()

<span class="gd">-    def _has_custom_template(self, template_name: str) -&gt;bool:</span>
<span class="gi">+    def _has_custom_template(self, template_name: str) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check if custom template file exists.

<span class="w"> </span>        Note: Please don&#39;t use this function from extensions.
<span class="w"> </span>              It will be removed in the future without deprecation period.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        template = path.join(self.templatedir, path.basename(template_name))</span>
<span class="gi">+        return bool(self.templatedir) and path.exists(template)</span>

<span class="gi">+    def render(self, template_name: str, context: dict[str, Any]) -&gt; str:</span>
<span class="gi">+        if self._has_custom_template(template_name):</span>
<span class="gi">+            custom_template = path.join(self.templatedir, path.basename(template_name))</span>
<span class="gi">+            return self.render_from_file(custom_template, context)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return super().render(template_name, context)</span>

<span class="gd">-def ask_user(d: dict[str, Any]) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+def ask_user(d: dict[str, Any]) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Ask the user for quickstart values missing from *d*.

<span class="w"> </span>    Values are:
<span class="gu">@@ -89,13 +205,399 @@ def ask_user(d: dict[str, Any]) -&gt;None:</span>
<span class="w"> </span>    * makefile:  make Makefile
<span class="w"> </span>    * batchfile: make command file
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    print(bold(__(&#39;Welcome to the Sphinx %s quickstart utility.&#39;)) % __display_version__)</span>
<span class="gi">+    print()</span>
<span class="gi">+    print(__(&#39;Please enter values for the following settings (just press Enter to\n&#39;</span>
<span class="gi">+             &#39;accept a default value, if one is given in brackets).&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;path&#39; in d:</span>
<span class="gi">+        print()</span>
<span class="gi">+        print(bold(__(&#39;Selected root path: %s&#39;)) % d[&#39;path&#39;])</span>
<span class="gi">+    else:</span>
<span class="gi">+        print()</span>
<span class="gi">+        print(__(&#39;Enter the root path for documentation.&#39;))</span>
<span class="gi">+        d[&#39;path&#39;] = do_prompt(__(&#39;Root path for the documentation&#39;), &#39;.&#39;, is_path)</span>
<span class="gi">+</span>
<span class="gi">+    while path.isfile(path.join(d[&#39;path&#39;], &#39;conf.py&#39;)) or \</span>
<span class="gi">+            path.isfile(path.join(d[&#39;path&#39;], &#39;source&#39;, &#39;conf.py&#39;)):</span>
<span class="gi">+        print()</span>
<span class="gi">+        print(bold(__(&#39;Error: an existing conf.py has been found in the &#39;</span>
<span class="gi">+                      &#39;selected root path.&#39;)))</span>
<span class="gi">+        print(__(&#39;sphinx-quickstart will not overwrite existing Sphinx projects.&#39;))</span>
<span class="gi">+        print()</span>
<span class="gi">+        d[&#39;path&#39;] = do_prompt(__(&#39;Please enter a new root path (or just Enter to exit)&#39;),</span>
<span class="gi">+                              &#39;&#39;, is_path_or_empty)</span>
<span class="gi">+        if not d[&#39;path&#39;]:</span>
<span class="gi">+            raise SystemExit(1)</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;sep&#39; not in d:</span>
<span class="gi">+        print()</span>
<span class="gi">+        print(__(&#39;You have two options for placing the build directory for Sphinx output.\n&#39;</span>
<span class="gi">+                 &#39;Either, you use a directory &quot;_build&quot; within the root path, or you separate\n&#39;</span>
<span class="gi">+                 &#39;&quot;source&quot; and &quot;build&quot; directories within the root path.&#39;))</span>
<span class="gi">+        d[&#39;sep&#39;] = do_prompt(__(&#39;Separate source and build directories (y/n)&#39;), &#39;n&#39;, boolean)</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;dot&#39; not in d:</span>
<span class="gi">+        print()</span>
<span class="gi">+        print(__(&#39;Inside the root directory, two more directories will be created; &quot;_templates&quot;\n&#39;      # NoQA: E501</span>
<span class="gi">+                 &#39;for custom HTML templates and &quot;_static&quot; for custom stylesheets and other static\n&#39;    # NoQA: E501</span>
<span class="gi">+                 &#39;files. You can enter another prefix (such as &quot;.&quot;) to replace the underscore.&#39;))       # NoQA: E501</span>
<span class="gi">+        d[&#39;dot&#39;] = do_prompt(__(&#39;Name prefix for templates and static dir&#39;), &#39;_&#39;, ok)</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;project&#39; not in d:</span>
<span class="gi">+        print()</span>
<span class="gi">+        print(__(&#39;The project name will occur in several places in the built documentation.&#39;))</span>
<span class="gi">+        d[&#39;project&#39;] = do_prompt(__(&#39;Project name&#39;))</span>
<span class="gi">+    if &#39;author&#39; not in d:</span>
<span class="gi">+        d[&#39;author&#39;] = do_prompt(__(&#39;Author name(s)&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;version&#39; not in d:</span>
<span class="gi">+        print()</span>
<span class="gi">+        print(__(&#39;Sphinx has the notion of a &quot;version&quot; and a &quot;release&quot; for the\n&#39;</span>
<span class="gi">+                 &#39;software. Each version can have multiple releases. For example, for\n&#39;</span>
<span class="gi">+                 &#39;Python the version is something like 2.5 or 3.0, while the release is\n&#39;</span>
<span class="gi">+                 &quot;something like 2.5.1 or 3.0a1. If you don&#39;t need this dual structure,\n&quot;</span>
<span class="gi">+                 &#39;just set both to the same value.&#39;))</span>
<span class="gi">+        d[&#39;version&#39;] = do_prompt(__(&#39;Project version&#39;), &#39;&#39;, allow_empty)</span>
<span class="gi">+    if &#39;release&#39; not in d:</span>
<span class="gi">+        d[&#39;release&#39;] = do_prompt(__(&#39;Project release&#39;), d[&#39;version&#39;], allow_empty)</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;language&#39; not in d:</span>
<span class="gi">+        print()</span>
<span class="gi">+        print(__(</span>
<span class="gi">+            &#39;If the documents are to be written in a language other than English,\n&#39;</span>
<span class="gi">+            &#39;you can select a language here by its language code. Sphinx will then\n&#39;</span>
<span class="gi">+            &#39;translate text that it generates into that language.\n&#39;</span>
<span class="gi">+            &#39;\n&#39;</span>
<span class="gi">+            &#39;For a list of supported codes, see\n&#39;</span>
<span class="gi">+            &#39;https://www.sphinx-doc.org/en/master/usage/configuration.html#confval-language.&#39;,</span>
<span class="gi">+        ))</span>
<span class="gi">+        d[&#39;language&#39;] = do_prompt(__(&#39;Project language&#39;), &#39;en&#39;)</span>
<span class="gi">+        if d[&#39;language&#39;] == &#39;en&#39;:</span>
<span class="gi">+            d[&#39;language&#39;] = None</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;suffix&#39; not in d:</span>
<span class="gi">+        print()</span>
<span class="gi">+        print(__(&#39;The file name suffix for source files. Commonly, this is either &quot;.txt&quot;\n&#39;</span>
<span class="gi">+                 &#39;or &quot;.rst&quot;. Only files with this suffix are considered documents.&#39;))</span>
<span class="gi">+        d[&#39;suffix&#39;] = do_prompt(__(&#39;Source file suffix&#39;), &#39;.rst&#39;, suffix)</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;master&#39; not in d:</span>
<span class="gi">+        print()</span>
<span class="gi">+        print(__(&#39;One document is special in that it is considered the top node of the\n&#39;</span>
<span class="gi">+                 &#39;&quot;contents tree&quot;, that is, it is the root of the hierarchical structure\n&#39;</span>
<span class="gi">+                 &#39;of the documents. Normally, this is &quot;index&quot;, but if your &quot;index&quot;\n&#39;</span>
<span class="gi">+                 &#39;document is a custom template, you can also set this to another filename.&#39;))</span>
<span class="gi">+        d[&#39;master&#39;] = do_prompt(__(&#39;Name of your master document (without suffix)&#39;), &#39;index&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    while path.isfile(path.join(d[&#39;path&#39;], d[&#39;master&#39;] + d[&#39;suffix&#39;])) or \</span>
<span class="gi">+            path.isfile(path.join(d[&#39;path&#39;], &#39;source&#39;, d[&#39;master&#39;] + d[&#39;suffix&#39;])):</span>
<span class="gi">+        print()</span>
<span class="gi">+        print(bold(__(&#39;Error: the master file %s has already been found in the &#39;</span>
<span class="gi">+                      &#39;selected root path.&#39;) % (d[&#39;master&#39;] + d[&#39;suffix&#39;])))</span>
<span class="gi">+        print(__(&#39;sphinx-quickstart will not overwrite the existing file.&#39;))</span>
<span class="gi">+        print()</span>
<span class="gi">+        d[&#39;master&#39;] = do_prompt(__(&#39;Please enter a new file name, or rename the &#39;</span>
<span class="gi">+                                   &#39;existing file and press Enter&#39;), d[&#39;master&#39;])</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;extensions&#39; not in d:</span>
<span class="gi">+        print(__(&#39;Indicate which of the following Sphinx extensions should be enabled:&#39;))</span>
<span class="gi">+        d[&#39;extensions&#39;] = []</span>
<span class="gi">+        for name, description in EXTENSIONS.items():</span>
<span class="gi">+            if do_prompt(f&#39;{name}: {description} (y/n)&#39;, &#39;n&#39;, boolean):</span>
<span class="gi">+                d[&#39;extensions&#39;].append(&#39;sphinx.ext.%s&#39; % name)</span>

<span class="gi">+        # Handle conflicting options</span>
<span class="gi">+        if {&#39;sphinx.ext.imgmath&#39;, &#39;sphinx.ext.mathjax&#39;}.issubset(d[&#39;extensions&#39;]):</span>
<span class="gi">+            print(__(&#39;Note: imgmath and mathjax cannot be enabled at the same time. &#39;</span>
<span class="gi">+                     &#39;imgmath has been deselected.&#39;))</span>
<span class="gi">+            d[&#39;extensions&#39;].remove(&#39;sphinx.ext.imgmath&#39;)</span>

<span class="gd">-def generate(d: dict[str, Any], overwrite: bool=True, silent: bool=False,</span>
<span class="gd">-    templatedir: (str | None)=None) -&gt;None:</span>
<span class="gi">+    if &#39;makefile&#39; not in d:</span>
<span class="gi">+        print()</span>
<span class="gi">+        print(__(&#39;A Makefile and a Windows command file can be generated for you so that you\n&#39;</span>
<span class="gi">+                 &quot;only have to run e.g. `make html&#39; instead of invoking sphinx-build\n&quot;</span>
<span class="gi">+                 &#39;directly.&#39;))</span>
<span class="gi">+        d[&#39;makefile&#39;] = do_prompt(__(&#39;Create Makefile? (y/n)&#39;), &#39;y&#39;, boolean)</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;batchfile&#39; not in d:</span>
<span class="gi">+        d[&#39;batchfile&#39;] = do_prompt(__(&#39;Create Windows command file? (y/n)&#39;), &#39;y&#39;, boolean)</span>
<span class="gi">+    print()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def generate(</span>
<span class="gi">+    d: dict[str, Any],</span>
<span class="gi">+    overwrite: bool = True,</span>
<span class="gi">+    silent: bool = False,</span>
<span class="gi">+    templatedir: str | None = None,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate project based on values in *d*.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    template = QuickstartRenderer(templatedir or &#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;mastertoctree&#39; not in d:</span>
<span class="gi">+        d[&#39;mastertoctree&#39;] = &#39;&#39;</span>
<span class="gi">+    if &#39;mastertocmaxdepth&#39; not in d:</span>
<span class="gi">+        d[&#39;mastertocmaxdepth&#39;] = 2</span>
<span class="gi">+</span>
<span class="gi">+    d[&#39;root_doc&#39;] = d[&#39;master&#39;]</span>
<span class="gi">+    d[&#39;now&#39;] = time.asctime()</span>
<span class="gi">+    d[&#39;project_underline&#39;] = column_width(d[&#39;project&#39;]) * &#39;=&#39;</span>
<span class="gi">+    d.setdefault(&#39;extensions&#39;, [])</span>
<span class="gi">+    d[&#39;copyright&#39;] = time.strftime(&#39;%Y&#39;) + &#39;, &#39; + d[&#39;author&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    d[&quot;path&quot;] = os.path.abspath(d[&#39;path&#39;])</span>
<span class="gi">+    ensuredir(d[&#39;path&#39;])</span>
<span class="gi">+</span>
<span class="gi">+    srcdir = path.join(d[&#39;path&#39;], &#39;source&#39;) if d[&#39;sep&#39;] else d[&#39;path&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    ensuredir(srcdir)</span>
<span class="gi">+    if d[&#39;sep&#39;]:</span>
<span class="gi">+        builddir = path.join(d[&#39;path&#39;], &#39;build&#39;)</span>
<span class="gi">+        d[&#39;exclude_patterns&#39;] = &#39;&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        builddir = path.join(srcdir, d[&#39;dot&#39;] + &#39;build&#39;)</span>
<span class="gi">+        exclude_patterns = map(repr, [</span>
<span class="gi">+            d[&#39;dot&#39;] + &#39;build&#39;,</span>
<span class="gi">+            &#39;Thumbs.db&#39;, &#39;.DS_Store&#39;,</span>
<span class="gi">+        ])</span>
<span class="gi">+        d[&#39;exclude_patterns&#39;] = &#39;, &#39;.join(exclude_patterns)</span>
<span class="gi">+    ensuredir(builddir)</span>
<span class="gi">+    ensuredir(path.join(srcdir, d[&#39;dot&#39;] + &#39;templates&#39;))</span>
<span class="gi">+    ensuredir(path.join(srcdir, d[&#39;dot&#39;] + &#39;static&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    def write_file(fpath: str, content: str, newline: str | None = None) -&gt; None:</span>
<span class="gi">+        if overwrite or not path.isfile(fpath):</span>
<span class="gi">+            if &#39;quiet&#39; not in d:</span>
<span class="gi">+                print(__(&#39;Creating file %s.&#39;) % fpath)</span>
<span class="gi">+            with open(fpath, &#39;w&#39;, encoding=&#39;utf-8&#39;, newline=newline) as f:</span>
<span class="gi">+                f.write(content)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if &#39;quiet&#39; not in d:</span>
<span class="gi">+                print(__(&#39;File %s already exists, skipping.&#39;) % fpath)</span>
<span class="gi">+</span>
<span class="gi">+    conf_path = os.path.join(templatedir, &#39;conf.py.jinja&#39;) if templatedir else None</span>
<span class="gi">+    if not conf_path or not path.isfile(conf_path):</span>
<span class="gi">+        conf_path = os.path.join(package_dir, &#39;templates&#39;, &#39;quickstart&#39;, &#39;conf.py.jinja&#39;)</span>
<span class="gi">+    with open(conf_path, encoding=&quot;utf-8&quot;) as f:</span>
<span class="gi">+        conf_text = f.read()</span>
<span class="gi">+</span>
<span class="gi">+    write_file(path.join(srcdir, &#39;conf.py&#39;), template.render_string(conf_text, d))</span>
<span class="gi">+</span>
<span class="gi">+    masterfile = path.join(srcdir, d[&#39;master&#39;] + d[&#39;suffix&#39;])</span>
<span class="gi">+    if template._has_custom_template(&#39;quickstart/master_doc.rst.jinja&#39;):</span>
<span class="gi">+        msg = (&#39;A custom template `master_doc.rst.jinja` found. It has been renamed to &#39;</span>
<span class="gi">+               &#39;`root_doc.rst.jinja`.  Please rename it on your project too.&#39;)</span>
<span class="gi">+        print(colorize(&#39;red&#39;, msg))</span>
<span class="gi">+        write_file(masterfile, template.render(&#39;quickstart/master_doc.rst.jinja&#39;, d))</span>
<span class="gi">+    else:</span>
<span class="gi">+        write_file(masterfile, template.render(&#39;quickstart/root_doc.rst.jinja&#39;, d))</span>
<span class="gi">+</span>
<span class="gi">+    makefile_template = &#39;quickstart/Makefile.new.jinja&#39;</span>
<span class="gi">+    batchfile_template = &#39;quickstart/make.bat.new.jinja&#39;</span>
<span class="gi">+</span>
<span class="gi">+    if d[&#39;makefile&#39;] is True:</span>
<span class="gi">+        d[&#39;rsrcdir&#39;] = &#39;source&#39; if d[&#39;sep&#39;] else &#39;.&#39;</span>
<span class="gi">+        d[&#39;rbuilddir&#39;] = &#39;build&#39; if d[&#39;sep&#39;] else d[&#39;dot&#39;] + &#39;build&#39;</span>
<span class="gi">+        # use binary mode, to avoid writing \r\n on Windows</span>
<span class="gi">+        write_file(path.join(d[&#39;path&#39;], &#39;Makefile&#39;),</span>
<span class="gi">+                   template.render(makefile_template, d), &#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if d[&#39;batchfile&#39;] is True:</span>
<span class="gi">+        d[&#39;rsrcdir&#39;] = &#39;source&#39; if d[&#39;sep&#39;] else &#39;.&#39;</span>
<span class="gi">+        d[&#39;rbuilddir&#39;] = &#39;build&#39; if d[&#39;sep&#39;] else d[&#39;dot&#39;] + &#39;build&#39;</span>
<span class="gi">+        write_file(path.join(d[&#39;path&#39;], &#39;make.bat&#39;),</span>
<span class="gi">+                   template.render(batchfile_template, d), &#39;\r\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if silent:</span>
<span class="gi">+        return</span>
<span class="gi">+    print()</span>
<span class="gi">+    print(bold(__(&#39;Finished: An initial directory structure has been created.&#39;)))</span>
<span class="gi">+    print()</span>
<span class="gi">+    print(__(&#39;You should now populate your master file %s and create other documentation\n&#39;</span>
<span class="gi">+             &#39;source files. &#39;) % masterfile, end=&#39;&#39;)</span>
<span class="gi">+    if d[&#39;makefile&#39;] or d[&#39;batchfile&#39;]:</span>
<span class="gi">+        print(__(&#39;Use the Makefile to build the docs, like so:\n&#39;</span>
<span class="gi">+                 &#39;   make builder&#39;))</span>
<span class="gi">+    else:</span>
<span class="gi">+        print(__(&#39;Use the sphinx-build command to build the docs, like so:\n&#39;</span>
<span class="gi">+                 &#39;   sphinx-build -b builder %s %s&#39;) % (srcdir, builddir))</span>
<span class="gi">+    print(__(&#39;where &quot;builder&quot; is one of the supported builders, &#39;</span>
<span class="gi">+             &#39;e.g. html, latex or linkcheck.&#39;))</span>
<span class="gi">+    print()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def valid_dir(d: dict[str, Any]) -&gt; bool:</span>
<span class="gi">+    dir = d[&#39;path&#39;]</span>
<span class="gi">+    if not path.exists(dir):</span>
<span class="gi">+        return True</span>
<span class="gi">+    if not path.isdir(dir):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if {&#39;Makefile&#39;, &#39;make.bat&#39;} &amp; set(os.listdir(dir)):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if d[&#39;sep&#39;]:</span>
<span class="gi">+        dir = os.path.join(&#39;source&#39;, dir)</span>
<span class="gi">+        if not path.exists(dir):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if not path.isdir(dir):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    reserved_names = [</span>
<span class="gi">+        &#39;conf.py&#39;,</span>
<span class="gi">+        d[&#39;dot&#39;] + &#39;static&#39;,</span>
<span class="gi">+        d[&#39;dot&#39;] + &#39;templates&#39;,</span>
<span class="gi">+        d[&#39;master&#39;] + d[&#39;suffix&#39;],</span>
<span class="gi">+    ]</span>
<span class="gi">+    return not set(reserved_names) &amp; set(os.listdir(dir))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_parser() -&gt; argparse.ArgumentParser:</span>
<span class="gi">+    description = __(</span>
<span class="gi">+        &quot;\n&quot;</span>
<span class="gi">+        &quot;Generate required files for a Sphinx project.\n&quot;</span>
<span class="gi">+        &quot;\n&quot;</span>
<span class="gi">+        &quot;sphinx-quickstart is an interactive tool that asks some questions about your\n&quot;</span>
<span class="gi">+        &quot;project and then generates a complete documentation directory and sample\n&quot;</span>
<span class="gi">+        &quot;Makefile to be used with sphinx-build.\n&quot;,</span>
<span class="gi">+    )</span>
<span class="gi">+    parser = argparse.ArgumentParser(</span>
<span class="gi">+        usage=&#39;%(prog)s [OPTIONS] &lt;PROJECT_DIR&gt;&#39;,</span>
<span class="gi">+        epilog=__(&quot;For more information, visit &lt;https://www.sphinx-doc.org/&gt;.&quot;),</span>
<span class="gi">+        description=description)</span>
<span class="gi">+</span>
<span class="gi">+    parser.add_argument(&#39;-q&#39;, &#39;--quiet&#39;, action=&#39;store_true&#39;, dest=&#39;quiet&#39;,</span>
<span class="gi">+                        default=None,</span>
<span class="gi">+                        help=__(&#39;quiet mode&#39;))</span>
<span class="gi">+    parser.add_argument(&#39;--version&#39;, action=&#39;version&#39;, dest=&#39;show_version&#39;,</span>
<span class="gi">+                        version=&#39;%%(prog)s %s&#39; % __display_version__)</span>
<span class="gi">+</span>
<span class="gi">+    parser.add_argument(&#39;path&#39;, metavar=&#39;PROJECT_DIR&#39;, default=&#39;.&#39;, nargs=&#39;?&#39;,</span>
<span class="gi">+                        help=__(&#39;project root&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    group = parser.add_argument_group(__(&#39;Structure options&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--sep&#39;, action=&#39;store_true&#39;, dest=&#39;sep&#39;, default=None,</span>
<span class="gi">+                       help=__(&#39;if specified, separate source and build dirs&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--no-sep&#39;, action=&#39;store_false&#39;, dest=&#39;sep&#39;,</span>
<span class="gi">+                       help=__(&#39;if specified, create build dir under source dir&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--dot&#39;, metavar=&#39;DOT&#39;, default=&#39;_&#39;,</span>
<span class="gi">+                       help=__(&#39;replacement for dot in _templates etc.&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    group = parser.add_argument_group(__(&#39;Project basic options&#39;))</span>
<span class="gi">+    group.add_argument(&#39;-p&#39;, &#39;--project&#39;, metavar=&#39;PROJECT&#39;, dest=&#39;project&#39;,</span>
<span class="gi">+                       help=__(&#39;project name&#39;))</span>
<span class="gi">+    group.add_argument(&#39;-a&#39;, &#39;--author&#39;, metavar=&#39;AUTHOR&#39;, dest=&#39;author&#39;,</span>
<span class="gi">+                       help=__(&#39;author names&#39;))</span>
<span class="gi">+    group.add_argument(&#39;-v&#39;, metavar=&#39;VERSION&#39;, dest=&#39;version&#39;, default=&#39;&#39;,</span>
<span class="gi">+                       help=__(&#39;version of project&#39;))</span>
<span class="gi">+    group.add_argument(&#39;-r&#39;, &#39;--release&#39;, metavar=&#39;RELEASE&#39;, dest=&#39;release&#39;,</span>
<span class="gi">+                       help=__(&#39;release of project&#39;))</span>
<span class="gi">+    group.add_argument(&#39;-l&#39;, &#39;--language&#39;, metavar=&#39;LANGUAGE&#39;, dest=&#39;language&#39;,</span>
<span class="gi">+                       help=__(&#39;document language&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--suffix&#39;, metavar=&#39;SUFFIX&#39;, default=&#39;.rst&#39;,</span>
<span class="gi">+                       help=__(&#39;source file suffix&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--master&#39;, metavar=&#39;MASTER&#39;, default=&#39;index&#39;,</span>
<span class="gi">+                       help=__(&#39;master document name&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--epub&#39;, action=&#39;store_true&#39;, default=False,</span>
<span class="gi">+                       help=__(&#39;use epub&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    group = parser.add_argument_group(__(&#39;Extension options&#39;))</span>
<span class="gi">+    for ext in EXTENSIONS:</span>
<span class="gi">+        group.add_argument(&#39;--ext-%s&#39; % ext, action=&#39;append_const&#39;,</span>
<span class="gi">+                           const=&#39;sphinx.ext.%s&#39; % ext, dest=&#39;extensions&#39;,</span>
<span class="gi">+                           help=__(&#39;enable %s extension&#39;) % ext)</span>
<span class="gi">+    group.add_argument(&#39;--extensions&#39;, metavar=&#39;EXTENSIONS&#39;, dest=&#39;extensions&#39;,</span>
<span class="gi">+                       action=&#39;append&#39;, help=__(&#39;enable arbitrary extensions&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    group = parser.add_argument_group(__(&#39;Makefile and Batchfile creation&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--makefile&#39;, action=&#39;store_true&#39;, dest=&#39;makefile&#39;, default=True,</span>
<span class="gi">+                       help=__(&#39;create makefile&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--no-makefile&#39;, action=&#39;store_false&#39;, dest=&#39;makefile&#39;,</span>
<span class="gi">+                       help=__(&#39;do not create makefile&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--batchfile&#39;, action=&#39;store_true&#39;, dest=&#39;batchfile&#39;, default=True,</span>
<span class="gi">+                       help=__(&#39;create batchfile&#39;))</span>
<span class="gi">+    group.add_argument(&#39;--no-batchfile&#39;, action=&#39;store_false&#39;,</span>
<span class="gi">+                       dest=&#39;batchfile&#39;,</span>
<span class="gi">+                       help=__(&#39;do not create batchfile&#39;))</span>
<span class="gi">+    # --use-make-mode is a no-op from Sphinx 8.</span>
<span class="gi">+    group.add_argument(&#39;-m&#39;, &#39;--use-make-mode&#39;, action=&#39;store_true&#39;,</span>
<span class="gi">+                       dest=&#39;make_mode&#39;, default=True,</span>
<span class="gi">+                       help=__(&#39;use make-mode for Makefile/make.bat&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    group = parser.add_argument_group(__(&#39;Project templating&#39;))</span>
<span class="gi">+    group.add_argument(&#39;-t&#39;, &#39;--templatedir&#39;, metavar=&#39;TEMPLATEDIR&#39;,</span>
<span class="gi">+                       dest=&#39;templatedir&#39;,</span>
<span class="gi">+                       help=__(&#39;template directory for template files&#39;))</span>
<span class="gi">+    group.add_argument(&#39;-d&#39;, metavar=&#39;NAME=VALUE&#39;, action=&#39;append&#39;,</span>
<span class="gi">+                       dest=&#39;variables&#39;,</span>
<span class="gi">+                       help=__(&#39;define a template variable&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    return parser</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def main(argv: Sequence[str] = (), /) -&gt; int:</span>
<span class="gi">+    locale.setlocale(locale.LC_ALL, &#39;&#39;)</span>
<span class="gi">+    sphinx.locale.init_console()</span>
<span class="gi">+</span>
<span class="gi">+    if not color_terminal():</span>
<span class="gi">+        nocolor()</span>
<span class="gi">+</span>
<span class="gi">+    # parse options</span>
<span class="gi">+    parser = get_parser()</span>
<span class="gi">+    try:</span>
<span class="gi">+        args = parser.parse_args(argv or sys.argv[1:])</span>
<span class="gi">+    except SystemExit as err:</span>
<span class="gi">+        return err.code  # type: ignore[return-value]</span>
<span class="gi">+</span>
<span class="gi">+    d = vars(args)</span>
<span class="gi">+    # delete None or False value</span>
<span class="gi">+    d = {k: v for k, v in d.items() if v is not None}</span>
<span class="gi">+</span>
<span class="gi">+    # handle use of CSV-style extension values</span>
<span class="gi">+    d.setdefault(&#39;extensions&#39;, [])</span>
<span class="gi">+    for ext in d[&#39;extensions&#39;][:]:</span>
<span class="gi">+        if &#39;,&#39; in ext:</span>
<span class="gi">+            d[&#39;extensions&#39;].remove(ext)</span>
<span class="gi">+            d[&#39;extensions&#39;].extend(ext.split(&#39;,&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        if &#39;quiet&#39; in d:</span>
<span class="gi">+            if not {&#39;project&#39;, &#39;author&#39;}.issubset(d):</span>
<span class="gi">+                print(__(&#39;&quot;quiet&quot; is specified, but any of &quot;project&quot; or &#39;</span>
<span class="gi">+                         &#39;&quot;author&quot; is not specified.&#39;))</span>
<span class="gi">+                return 1</span>
<span class="gi">+</span>
<span class="gi">+        if {&#39;quiet&#39;, &#39;project&#39;, &#39;author&#39;}.issubset(d):</span>
<span class="gi">+            # quiet mode with all required params satisfied, use default</span>
<span class="gi">+            d.setdefault(&#39;version&#39;, &#39;&#39;)</span>
<span class="gi">+            d.setdefault(&#39;release&#39;, d[&#39;version&#39;])</span>
<span class="gi">+            d2 = DEFAULTS.copy()</span>
<span class="gi">+            d2.update(d)</span>
<span class="gi">+            d = d2</span>
<span class="gi">+</span>
<span class="gi">+            if not valid_dir(d):</span>
<span class="gi">+                print()</span>
<span class="gi">+                print(bold(__(&#39;Error: specified path is not a directory, or sphinx&#39;</span>
<span class="gi">+                              &#39; files already exist.&#39;)))</span>
<span class="gi">+                print(__(&#39;sphinx-quickstart only generate into a empty directory.&#39;</span>
<span class="gi">+                         &#39; Please specify a new root path.&#39;))</span>
<span class="gi">+                return 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            ask_user(d)</span>
<span class="gi">+    except (KeyboardInterrupt, EOFError):</span>
<span class="gi">+        print()</span>
<span class="gi">+        print(&#39;[Interrupted.]&#39;)</span>
<span class="gi">+        return 130  # 128 + SIGINT</span>
<span class="gi">+</span>
<span class="gi">+    for variable in d.get(&#39;variables&#39;, []):</span>
<span class="gi">+        try:</span>
<span class="gi">+            name, value = variable.split(&#39;=&#39;)</span>
<span class="gi">+            d[name] = value</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            print(__(&#39;Invalid template variable: %s&#39;) % variable)</span>
<span class="gi">+</span>
<span class="gi">+    generate(d, overwrite=False, templatedir=args.templatedir)</span>
<span class="gi">+    return 0</span>


<span class="w"> </span>if __name__ == &#39;__main__&#39;:
<span class="gh">diff --git a/sphinx/config.py b/sphinx/config.py</span>
<span class="gh">index 035734a48..bae92140d 100644</span>
<span class="gd">--- a/sphinx/config.py</span>
<span class="gi">+++ b/sphinx/config.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Build configuration file handling.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>import time
<span class="w"> </span>import traceback
<span class="gu">@@ -7,28 +9,40 @@ import types</span>
<span class="w"> </span>import warnings
<span class="w"> </span>from os import getenv, path
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Literal, NamedTuple
<span class="gi">+</span>
<span class="w"> </span>from sphinx.deprecation import RemovedInSphinx90Warning
<span class="w"> </span>from sphinx.errors import ConfigError, ExtensionError
<span class="w"> </span>from sphinx.locale import _, __
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.osutil import fs_encoding
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &gt;= (3, 11):
<span class="w"> </span>    from contextlib import chdir
<span class="w"> </span>else:
<span class="w"> </span>    from sphinx.util.osutil import _chdir as chdir
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    import os
<span class="w"> </span>    from collections.abc import Collection, Iterable, Iterator, Sequence, Set
<span class="w"> </span>    from typing import TypeAlias
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="w"> </span>    from sphinx.util.tags import Tags
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata, _ExtensionSetupFunc
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gd">-_ConfigRebuild: TypeAlias = Literal[&#39;&#39;, &#39;env&#39;, &#39;epub&#39;, &#39;gettext&#39;, &#39;html&#39;,</span>
<span class="gd">-    &#39;applehelp&#39;, &#39;devhelp&#39;]</span>
<span class="gi">+</span>
<span class="gi">+_ConfigRebuild: TypeAlias = Literal[</span>
<span class="gi">+    &#39;&#39;, &#39;env&#39;, &#39;epub&#39;, &#39;gettext&#39;, &#39;html&#39;,</span>
<span class="gi">+    # sphinxcontrib-applehelp</span>
<span class="gi">+    &#39;applehelp&#39;,</span>
<span class="gi">+    # sphinxcontrib-devhelp</span>
<span class="gi">+    &#39;devhelp&#39;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>CONFIG_FILENAME = &#39;conf.py&#39;
<span class="gd">-UNSERIALIZABLE_TYPES = type, types.ModuleType, types.FunctionType</span>
<span class="gi">+UNSERIALIZABLE_TYPES = (type, types.ModuleType, types.FunctionType)</span>


<span class="w"> </span>class ConfigValue(NamedTuple):
<span class="gu">@@ -37,9 +51,29 @@ class ConfigValue(NamedTuple):</span>
<span class="w"> </span>    rebuild: _ConfigRebuild


<span class="gd">-def is_serializable(obj: object, *, _seen: frozenset[int]=frozenset()) -&gt;bool:</span>
<span class="gi">+def is_serializable(obj: object, *, _seen: frozenset[int] = frozenset()) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if an object is serializable or not.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(obj, UNSERIALIZABLE_TYPES):</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # use id() to handle un-hashable objects</span>
<span class="gi">+    if id(obj) in _seen:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(obj, dict):</span>
<span class="gi">+        seen = _seen | {id(obj)}</span>
<span class="gi">+        return all(</span>
<span class="gi">+            is_serializable(key, _seen=seen) and is_serializable(value, _seen=seen)</span>
<span class="gi">+            for key, value in obj.items()</span>
<span class="gi">+        )</span>
<span class="gi">+    elif isinstance(obj, list | tuple | set | frozenset):</span>
<span class="gi">+        seen = _seen | {id(obj)}</span>
<span class="gi">+        return all(is_serializable(item, _seen=seen) for item in obj)</span>
<span class="gi">+</span>
<span class="gi">+    # if an issue occurs for a non-serializable type, pickle will complain</span>
<span class="gi">+    # since the object is likely coming from a third-party extension</span>
<span class="gi">+    # (we natively expect &#39;simple&#39; types and not weird ones)</span>
<span class="gi">+    return True</span>


<span class="w"> </span>class ENUM:
<span class="gu">@@ -49,23 +83,34 @@ class ENUM:</span>
<span class="w"> </span>        app.add_config_value(&#39;latex_show_urls&#39;, &#39;no&#39;, None, ENUM(&#39;no&#39;, &#39;footnote&#39;, &#39;inline&#39;))
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, *candidates: (str | bool | None)) -&gt;None:</span>
<span class="gi">+    def __init__(self, *candidates: str | bool | None) -&gt; None:</span>
<span class="w"> </span>        self.candidates = candidates

<span class="gi">+    def match(self, value: str | list | tuple) -&gt; bool:</span>
<span class="gi">+        if isinstance(value, list | tuple):</span>
<span class="gi">+            return all(item in self.candidates for item in value)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return value in self.candidates</span>
<span class="gi">+</span>

<span class="gd">-_OptValidTypes: TypeAlias = tuple[()] | tuple[type, ...] | frozenset[type</span>
<span class="gd">-    ] | ENUM</span>
<span class="gi">+_OptValidTypes: TypeAlias = tuple[()] | tuple[type, ...] | frozenset[type] | ENUM</span>


<span class="w"> </span>class _Opt:
<span class="w"> </span>    __slots__ = &#39;default&#39;, &#39;rebuild&#39;, &#39;valid_types&#39;, &#39;description&#39;
<span class="gi">+</span>
<span class="w"> </span>    default: Any
<span class="w"> </span>    rebuild: _ConfigRebuild
<span class="w"> </span>    valid_types: _OptValidTypes
<span class="w"> </span>    description: str

<span class="gd">-    def __init__(self, default: Any, rebuild: _ConfigRebuild, valid_types:</span>
<span class="gd">-        _OptValidTypes, description: str=&#39;&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        default: Any,</span>
<span class="gi">+        rebuild: _ConfigRebuild,</span>
<span class="gi">+        valid_types: _OptValidTypes,</span>
<span class="gi">+        description: str = &#39;&#39;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Configuration option type for Sphinx.

<span class="w"> </span>        The type is intended to be immutable; changing the field values
<span class="gu">@@ -79,144 +124,171 @@ class _Opt:</span>
<span class="w"> </span>        super().__setattr__(&#39;valid_types&#39;, valid_types)
<span class="w"> </span>        super().__setattr__(&#39;description&#39;, description)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return (
<span class="gd">-            f&#39;{self.__class__.__qualname__}(default={self.default!r}, rebuild={self.rebuild!r}, valid_types={self.rebuild!r}, description={self.description!r})&#39;</span>
<span class="gd">-            )</span>
<span class="gd">-</span>
<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+            f&#39;{self.__class__.__qualname__}(&#39;</span>
<span class="gi">+            f&#39;default={self.default!r}, &#39;</span>
<span class="gi">+            f&#39;rebuild={self.rebuild!r}, &#39;</span>
<span class="gi">+            f&#39;valid_types={self.rebuild!r}, &#39;</span>
<span class="gi">+            f&#39;description={self.description!r})&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if isinstance(other, _Opt):
<span class="gd">-            self_tpl = (self.default, self.rebuild, self.valid_types, self.</span>
<span class="gd">-                description)</span>
<span class="gd">-            other_tpl = (other.default, other.rebuild, other.valid_types,</span>
<span class="gd">-                self.description)</span>
<span class="gi">+            self_tpl = (self.default, self.rebuild, self.valid_types, self.description)</span>
<span class="gi">+            other_tpl = (other.default, other.rebuild, other.valid_types, self.description)</span>
<span class="w"> </span>            return self_tpl == other_tpl
<span class="w"> </span>        return NotImplemented

<span class="gd">-    def __lt__(self, other: _Opt) -&gt;bool:</span>
<span class="gi">+    def __lt__(self, other: _Opt) -&gt; bool:</span>
<span class="w"> </span>        if self.__class__ is other.__class__:
<span class="gd">-            self_tpl = (self.default, self.rebuild, self.valid_types, self.</span>
<span class="gd">-                description)</span>
<span class="gd">-            other_tpl = (other.default, other.rebuild, other.valid_types,</span>
<span class="gd">-                self.description)</span>
<span class="gi">+            self_tpl = (self.default, self.rebuild, self.valid_types, self.description)</span>
<span class="gi">+            other_tpl = (other.default, other.rebuild, other.valid_types, self.description)</span>
<span class="w"> </span>            return self_tpl &gt; other_tpl
<span class="w"> </span>        return NotImplemented

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gd">-        return hash((self.default, self.rebuild, self.valid_types, self.</span>
<span class="gd">-            description))</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="gi">+        return hash((self.default, self.rebuild, self.valid_types, self.description))</span>

<span class="gd">-    def __setattr__(self, key: str, value: Any) -&gt;None:</span>
<span class="gi">+    def __setattr__(self, key: str, value: Any) -&gt; None:</span>
<span class="w"> </span>        if key in {&#39;default&#39;, &#39;rebuild&#39;, &#39;valid_types&#39;, &#39;description&#39;}:
<span class="gd">-            msg = (</span>
<span class="gd">-                f&#39;{self.__class__.__name__!r} object does not support assignment to {key!r}&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+            msg = f&#39;{self.__class__.__name__!r} object does not support assignment to {key!r}&#39;</span>
<span class="w"> </span>            raise TypeError(msg)
<span class="w"> </span>        super().__setattr__(key, value)

<span class="gd">-    def __delattr__(self, key: str) -&gt;None:</span>
<span class="gi">+    def __delattr__(self, key: str) -&gt; None:</span>
<span class="w"> </span>        if key in {&#39;default&#39;, &#39;rebuild&#39;, &#39;valid_types&#39;, &#39;description&#39;}:
<span class="gd">-            msg = (</span>
<span class="gd">-                f&#39;{self.__class__.__name__!r} object does not support deletion of {key!r}&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+            msg = f&#39;{self.__class__.__name__!r} object does not support deletion of {key!r}&#39;</span>
<span class="w"> </span>            raise TypeError(msg)
<span class="w"> </span>        super().__delattr__(key)

<span class="gd">-    def __getstate__(self) -&gt;tuple[Any, _ConfigRebuild, _OptValidTypes, str]:</span>
<span class="gi">+    def __getstate__(self) -&gt; tuple[Any, _ConfigRebuild, _OptValidTypes, str]:</span>
<span class="w"> </span>        return self.default, self.rebuild, self.valid_types, self.description

<span class="gd">-    def __setstate__(self, state: tuple[Any, _ConfigRebuild, _OptValidTypes,</span>
<span class="gd">-        str]) -&gt;None:</span>
<span class="gi">+    def __setstate__(</span>
<span class="gi">+            self, state: tuple[Any, _ConfigRebuild, _OptValidTypes, str]) -&gt; None:</span>
<span class="w"> </span>        default, rebuild, valid_types, description = state
<span class="w"> </span>        super().__setattr__(&#39;default&#39;, default)
<span class="w"> </span>        super().__setattr__(&#39;rebuild&#39;, rebuild)
<span class="w"> </span>        super().__setattr__(&#39;valid_types&#39;, valid_types)
<span class="w"> </span>        super().__setattr__(&#39;description&#39;, description)

<span class="gd">-    def __getitem__(self, item: (int | slice)) -&gt;Any:</span>
<span class="gi">+    def __getitem__(self, item: int | slice) -&gt; Any:</span>
<span class="w"> </span>        warnings.warn(
<span class="gd">-            f&quot;The {self.__class__.__name__!r} object tuple interface is deprecated, use attribute access instead for &#39;default&#39;, &#39;rebuild&#39;, and &#39;valid_types&#39;.&quot;</span>
<span class="gd">-            , RemovedInSphinx90Warning, stacklevel=2)</span>
<span class="gi">+            f&#39;The {self.__class__.__name__!r} object tuple interface is deprecated, &#39;</span>
<span class="gi">+            &quot;use attribute access instead for &#39;default&#39;, &#39;rebuild&#39;, and &#39;valid_types&#39;.&quot;,</span>
<span class="gi">+            RemovedInSphinx90Warning, stacklevel=2)</span>
<span class="w"> </span>        return (self.default, self.rebuild, self.valid_types)[item]


<span class="w"> </span>class Config:
<span class="gd">-    &quot;&quot;&quot;Configuration file abstraction.</span>
<span class="gi">+    r&quot;&quot;&quot;Configuration file abstraction.</span>

<span class="w"> </span>    The Config object makes the values of all config options available as
<span class="w"> </span>    attributes.

<span class="gd">-    It is exposed via the :py:class:`~sphinx.application.Sphinx`\\ ``.config``</span>
<span class="gd">-    and :py:class:`sphinx.environment.BuildEnvironment`\\ ``.config`` attributes.</span>
<span class="gi">+    It is exposed via the :py:class:`~sphinx.application.Sphinx`\ ``.config``</span>
<span class="gi">+    and :py:class:`sphinx.environment.BuildEnvironment`\ ``.config`` attributes.</span>
<span class="w"> </span>    For example, to get the value of :confval:`language`, use either
<span class="w"> </span>    ``app.config.language`` or ``env.config.language``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    config_values: dict[str, _Opt] = {&#39;project&#39;: _Opt(</span>
<span class="gd">-        &#39;Project name not set&#39;, &#39;env&#39;, ()), &#39;author&#39;: _Opt(</span>
<span class="gd">-        &#39;Author name not set&#39;, &#39;env&#39;, ()), &#39;project_copyright&#39;: _Opt(&#39;&#39;,</span>
<span class="gd">-        &#39;html&#39;, frozenset((str, tuple, list))), &#39;copyright&#39;: _Opt(lambda</span>
<span class="gd">-        config: config.project_copyright, &#39;html&#39;, frozenset((str, tuple,</span>
<span class="gd">-        list))), &#39;version&#39;: _Opt(&#39;&#39;, &#39;env&#39;, ()), &#39;release&#39;: _Opt(&#39;&#39;, &#39;env&#39;,</span>
<span class="gd">-        ()), &#39;today&#39;: _Opt(&#39;&#39;, &#39;env&#39;, ()), &#39;today_fmt&#39;: _Opt(None, &#39;env&#39;,</span>
<span class="gd">-        frozenset((str,))), &#39;language&#39;: _Opt(&#39;en&#39;, &#39;env&#39;, frozenset((str,))</span>
<span class="gd">-        ), &#39;locale_dirs&#39;: _Opt([&#39;locales&#39;], &#39;env&#39;, ()),</span>
<span class="gd">-        &#39;figure_language_filename&#39;: _Opt(&#39;{root}.{language}{ext}&#39;, &#39;env&#39;,</span>
<span class="gd">-        frozenset((str,))), &#39;gettext_allow_fuzzy_translations&#39;: _Opt(False,</span>
<span class="gd">-        &#39;gettext&#39;, ()), &#39;translation_progress_classes&#39;: _Opt(False, &#39;env&#39;,</span>
<span class="gd">-        ENUM(True, False, &#39;translated&#39;, &#39;untranslated&#39;)), &#39;master_doc&#39;:</span>
<span class="gd">-        _Opt(&#39;index&#39;, &#39;env&#39;, ()), &#39;root_doc&#39;: _Opt(lambda config: config.</span>
<span class="gd">-        master_doc, &#39;env&#39;, ()), &#39;source_suffix&#39;: _Opt({&#39;.rst&#39;:</span>
<span class="gd">-        &#39;restructuredtext&#39;}, &#39;env&#39;, Any), &#39;source_encoding&#39;: _Opt(</span>
<span class="gd">-        &#39;utf-8-sig&#39;, &#39;env&#39;, ()), &#39;exclude_patterns&#39;: _Opt([], &#39;env&#39;,</span>
<span class="gd">-        frozenset((str,))), &#39;include_patterns&#39;: _Opt([&#39;**&#39;], &#39;env&#39;,</span>
<span class="gd">-        frozenset((str,))), &#39;default_role&#39;: _Opt(None, &#39;env&#39;, frozenset((</span>
<span class="gd">-        str,))), &#39;add_function_parentheses&#39;: _Opt(True, &#39;env&#39;, ()),</span>
<span class="gd">-        &#39;add_module_names&#39;: _Opt(True, &#39;env&#39;, ()), &#39;toc_object_entries&#39;:</span>
<span class="gd">-        _Opt(True, &#39;env&#39;, frozenset((bool,))),</span>
<span class="gd">-        &#39;toc_object_entries_show_parents&#39;: _Opt(&#39;domain&#39;, &#39;env&#39;, ENUM(</span>
<span class="gd">-        &#39;domain&#39;, &#39;all&#39;, &#39;hide&#39;)), &#39;trim_footnote_reference_space&#39;: _Opt(</span>
<span class="gd">-        False, &#39;env&#39;, ()), &#39;show_authors&#39;: _Opt(False, &#39;env&#39;, ()),</span>
<span class="gi">+</span>
<span class="gi">+    # The values are:</span>
<span class="gi">+    # 1. Default</span>
<span class="gi">+    # 2. What needs to be rebuilt if changed</span>
<span class="gi">+    # 3. Valid types</span>
<span class="gi">+</span>
<span class="gi">+    # If you add a value here, remember to include it in the docs!</span>
<span class="gi">+</span>
<span class="gi">+    config_values: dict[str, _Opt] = {</span>
<span class="gi">+        # general options</span>
<span class="gi">+        &#39;project&#39;: _Opt(&#39;Project name not set&#39;, &#39;env&#39;, ()),</span>
<span class="gi">+        &#39;author&#39;: _Opt(&#39;Author name not set&#39;, &#39;env&#39;, ()),</span>
<span class="gi">+        &#39;project_copyright&#39;: _Opt(&#39;&#39;, &#39;html&#39;, frozenset((str, tuple, list))),</span>
<span class="gi">+        &#39;copyright&#39;: _Opt(</span>
<span class="gi">+            lambda config: config.project_copyright, &#39;html&#39;, frozenset((str, tuple, list))),</span>
<span class="gi">+        &#39;version&#39;: _Opt(&#39;&#39;, &#39;env&#39;, ()),</span>
<span class="gi">+        &#39;release&#39;: _Opt(&#39;&#39;, &#39;env&#39;, ()),</span>
<span class="gi">+        &#39;today&#39;: _Opt(&#39;&#39;, &#39;env&#39;, ()),</span>
<span class="gi">+        # the real default is locale-dependent</span>
<span class="gi">+        &#39;today_fmt&#39;: _Opt(None, &#39;env&#39;, frozenset((str,))),</span>
<span class="gi">+</span>
<span class="gi">+        &#39;language&#39;: _Opt(&#39;en&#39;, &#39;env&#39;, frozenset((str,))),</span>
<span class="gi">+        &#39;locale_dirs&#39;: _Opt([&#39;locales&#39;], &#39;env&#39;, ()),</span>
<span class="gi">+        &#39;figure_language_filename&#39;: _Opt(&#39;{root}.{language}{ext}&#39;, &#39;env&#39;, frozenset((str,))),</span>
<span class="gi">+        &#39;gettext_allow_fuzzy_translations&#39;: _Opt(False, &#39;gettext&#39;, ()),</span>
<span class="gi">+        &#39;translation_progress_classes&#39;: _Opt(</span>
<span class="gi">+            False, &#39;env&#39;, ENUM(True, False, &#39;translated&#39;, &#39;untranslated&#39;)),</span>
<span class="gi">+</span>
<span class="gi">+        &#39;master_doc&#39;: _Opt(&#39;index&#39;, &#39;env&#39;, ()),</span>
<span class="gi">+        &#39;root_doc&#39;: _Opt(lambda config: config.master_doc, &#39;env&#39;, ()),</span>
<span class="gi">+        # ``source_suffix`` type is actually ``dict[str, str | None]``:</span>
<span class="gi">+        # see ``convert_source_suffix()`` below.</span>
<span class="gi">+        &#39;source_suffix&#39;: _Opt(</span>
<span class="gi">+            {&#39;.rst&#39;: &#39;restructuredtext&#39;}, &#39;env&#39;, Any),  # type: ignore[arg-type]</span>
<span class="gi">+        &#39;source_encoding&#39;: _Opt(&#39;utf-8-sig&#39;, &#39;env&#39;, ()),</span>
<span class="gi">+        &#39;exclude_patterns&#39;: _Opt([], &#39;env&#39;, frozenset((str,))),</span>
<span class="gi">+        &#39;include_patterns&#39;: _Opt([&quot;**&quot;], &#39;env&#39;, frozenset((str,))),</span>
<span class="gi">+        &#39;default_role&#39;: _Opt(None, &#39;env&#39;, frozenset((str,))),</span>
<span class="gi">+        &#39;add_function_parentheses&#39;: _Opt(True, &#39;env&#39;, ()),</span>
<span class="gi">+        &#39;add_module_names&#39;: _Opt(True, &#39;env&#39;, ()),</span>
<span class="gi">+        &#39;toc_object_entries&#39;: _Opt(True, &#39;env&#39;, frozenset((bool,))),</span>
<span class="gi">+        &#39;toc_object_entries_show_parents&#39;: _Opt(</span>
<span class="gi">+            &#39;domain&#39;, &#39;env&#39;, ENUM(&#39;domain&#39;, &#39;all&#39;, &#39;hide&#39;)),</span>
<span class="gi">+        &#39;trim_footnote_reference_space&#39;: _Opt(False, &#39;env&#39;, ()),</span>
<span class="gi">+        &#39;show_authors&#39;: _Opt(False, &#39;env&#39;, ()),</span>
<span class="w"> </span>        &#39;pygments_style&#39;: _Opt(None, &#39;html&#39;, frozenset((str,))),
<span class="w"> </span>        &#39;highlight_language&#39;: _Opt(&#39;default&#39;, &#39;env&#39;, ()),
<span class="gd">-        &#39;highlight_options&#39;: _Opt({}, &#39;env&#39;, ()), &#39;templates_path&#39;: _Opt([],</span>
<span class="gd">-        &#39;html&#39;, ()), &#39;template_bridge&#39;: _Opt(None, &#39;html&#39;, frozenset((str,)</span>
<span class="gd">-        )), &#39;keep_warnings&#39;: _Opt(False, &#39;env&#39;, ()), &#39;suppress_warnings&#39;:</span>
<span class="gd">-        _Opt([], &#39;env&#39;, ()), &#39;show_warning_types&#39;: _Opt(True, &#39;env&#39;,</span>
<span class="gd">-        frozenset((bool,))), &#39;modindex_common_prefix&#39;: _Opt([], &#39;html&#39;, ()),</span>
<span class="gd">-        &#39;rst_epilog&#39;: _Opt(None, &#39;env&#39;, frozenset((str,))), &#39;rst_prolog&#39;:</span>
<span class="gd">-        _Opt(None, &#39;env&#39;, frozenset((str,))), &#39;trim_doctest_flags&#39;: _Opt(</span>
<span class="gd">-        True, &#39;env&#39;, ()), &#39;primary_domain&#39;: _Opt(&#39;py&#39;, &#39;env&#39;, frozenset((</span>
<span class="gd">-        types.NoneType,))), &#39;needs_sphinx&#39;: _Opt(None, &#39;&#39;, frozenset((str,)</span>
<span class="gd">-        )), &#39;needs_extensions&#39;: _Opt({}, &#39;&#39;, ()), &#39;manpages_url&#39;: _Opt(None,</span>
<span class="gd">-        &#39;env&#39;, ()), &#39;nitpicky&#39;: _Opt(False, &#39;&#39;, ()), &#39;nitpick_ignore&#39;: _Opt</span>
<span class="gd">-        ([], &#39;&#39;, frozenset((set, list, tuple))), &#39;nitpick_ignore_regex&#39;:</span>
<span class="gd">-        _Opt([], &#39;&#39;, frozenset((set, list, tuple))), &#39;numfig&#39;: _Opt(False,</span>
<span class="gd">-        &#39;env&#39;, ()), &#39;numfig_secnum_depth&#39;: _Opt(1, &#39;env&#39;, ()),</span>
<span class="gd">-        &#39;numfig_format&#39;: _Opt({}, &#39;env&#39;, ()),</span>
<span class="gd">-        &#39;maximum_signature_line_length&#39;: _Opt(None, &#39;env&#39;, frozenset((int,</span>
<span class="gd">-        types.NoneType))), &#39;math_number_all&#39;: _Opt(False, &#39;env&#39;, ()),</span>
<span class="gi">+        &#39;highlight_options&#39;: _Opt({}, &#39;env&#39;, ()),</span>
<span class="gi">+        &#39;templates_path&#39;: _Opt([], &#39;html&#39;, ()),</span>
<span class="gi">+        &#39;template_bridge&#39;: _Opt(None, &#39;html&#39;, frozenset((str,))),</span>
<span class="gi">+        &#39;keep_warnings&#39;: _Opt(False, &#39;env&#39;, ()),</span>
<span class="gi">+        &#39;suppress_warnings&#39;: _Opt([], &#39;env&#39;, ()),</span>
<span class="gi">+        &#39;show_warning_types&#39;: _Opt(True, &#39;env&#39;, frozenset((bool,))),</span>
<span class="gi">+        &#39;modindex_common_prefix&#39;: _Opt([], &#39;html&#39;, ()),</span>
<span class="gi">+        &#39;rst_epilog&#39;: _Opt(None, &#39;env&#39;, frozenset((str,))),</span>
<span class="gi">+        &#39;rst_prolog&#39;: _Opt(None, &#39;env&#39;, frozenset((str,))),</span>
<span class="gi">+        &#39;trim_doctest_flags&#39;: _Opt(True, &#39;env&#39;, ()),</span>
<span class="gi">+        &#39;primary_domain&#39;: _Opt(&#39;py&#39;, &#39;env&#39;, frozenset((types.NoneType,))),</span>
<span class="gi">+        &#39;needs_sphinx&#39;: _Opt(None, &#39;&#39;, frozenset((str,))),</span>
<span class="gi">+        &#39;needs_extensions&#39;: _Opt({}, &#39;&#39;, ()),</span>
<span class="gi">+        &#39;manpages_url&#39;: _Opt(None, &#39;env&#39;, ()),</span>
<span class="gi">+        &#39;nitpicky&#39;: _Opt(False, &#39;&#39;, ()),</span>
<span class="gi">+        &#39;nitpick_ignore&#39;: _Opt([], &#39;&#39;, frozenset((set, list, tuple))),</span>
<span class="gi">+        &#39;nitpick_ignore_regex&#39;: _Opt([], &#39;&#39;, frozenset((set, list, tuple))),</span>
<span class="gi">+        &#39;numfig&#39;: _Opt(False, &#39;env&#39;, ()),</span>
<span class="gi">+        &#39;numfig_secnum_depth&#39;: _Opt(1, &#39;env&#39;, ()),</span>
<span class="gi">+        &#39;numfig_format&#39;: _Opt({}, &#39;env&#39;, ()),  # will be initialized in init_numfig_format()</span>
<span class="gi">+        &#39;maximum_signature_line_length&#39;: _Opt(</span>
<span class="gi">+            None, &#39;env&#39;, frozenset((int, types.NoneType))),</span>
<span class="gi">+        &#39;math_number_all&#39;: _Opt(False, &#39;env&#39;, ()),</span>
<span class="w"> </span>        &#39;math_eqref_format&#39;: _Opt(None, &#39;env&#39;, frozenset((str,))),
<span class="gd">-        &#39;math_numfig&#39;: _Opt(True, &#39;env&#39;, ()), &#39;math_numsep&#39;: _Opt(&#39;.&#39;,</span>
<span class="gd">-        &#39;env&#39;, frozenset((str,))), &#39;tls_verify&#39;: _Opt(True, &#39;env&#39;, ()),</span>
<span class="gd">-        &#39;tls_cacerts&#39;: _Opt(None, &#39;env&#39;, ()), &#39;user_agent&#39;: _Opt(None,</span>
<span class="gd">-        &#39;env&#39;, frozenset((str,))), &#39;smartquotes&#39;: _Opt(True, &#39;env&#39;, ()),</span>
<span class="gi">+        &#39;math_numfig&#39;: _Opt(True, &#39;env&#39;, ()),</span>
<span class="gi">+        &#39;math_numsep&#39;: _Opt(&#39;.&#39;, &#39;env&#39;, frozenset((str,))),</span>
<span class="gi">+        &#39;tls_verify&#39;: _Opt(True, &#39;env&#39;, ()),</span>
<span class="gi">+        &#39;tls_cacerts&#39;: _Opt(None, &#39;env&#39;, ()),</span>
<span class="gi">+        &#39;user_agent&#39;: _Opt(None, &#39;env&#39;, frozenset((str,))),</span>
<span class="gi">+        &#39;smartquotes&#39;: _Opt(True, &#39;env&#39;, ()),</span>
<span class="w"> </span>        &#39;smartquotes_action&#39;: _Opt(&#39;qDe&#39;, &#39;env&#39;, ()),
<span class="gd">-        &#39;smartquotes_excludes&#39;: _Opt({&#39;languages&#39;: [&#39;ja&#39;], &#39;builders&#39;: [</span>
<span class="gd">-        &#39;man&#39;, &#39;text&#39;]}, &#39;env&#39;, ()), &#39;option_emphasise_placeholders&#39;: _Opt(</span>
<span class="gd">-        False, &#39;env&#39;, ())}</span>
<span class="gi">+        &#39;smartquotes_excludes&#39;: _Opt(</span>
<span class="gi">+            {&#39;languages&#39;: [&#39;ja&#39;], &#39;builders&#39;: [&#39;man&#39;, &#39;text&#39;]}, &#39;env&#39;, ()),</span>
<span class="gi">+        &#39;option_emphasise_placeholders&#39;: _Opt(False, &#39;env&#39;, ()),</span>
<span class="gi">+    }</span>

<span class="gd">-    def __init__(self, config: (dict[str, Any] | None)=None, overrides: (</span>
<span class="gd">-        dict[str, Any] | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, config: dict[str, Any] | None = None,</span>
<span class="gi">+                 overrides: dict[str, Any] | None = None) -&gt; None:</span>
<span class="w"> </span>        raw_config: dict[str, Any] = config or {}
<span class="w"> </span>        self._overrides = dict(overrides) if overrides is not None else {}
<span class="w"> </span>        self._options = Config.config_values.copy()
<span class="w"> </span>        self._raw_config = raw_config
<span class="gi">+</span>
<span class="w"> </span>        for name in list(self._overrides.keys()):
<span class="w"> </span>            if &#39;.&#39; in name:
<span class="w"> </span>                real_name, key = name.split(&#39;.&#39;, 1)
<span class="gd">-                raw_config.setdefault(real_name, {})[key</span>
<span class="gd">-                    ] = self._overrides.pop(name)</span>
<span class="gi">+                raw_config.setdefault(real_name, {})[key] = self._overrides.pop(name)</span>
<span class="gi">+</span>
<span class="w"> </span>        self.setup: _ExtensionSetupFunc | None = raw_config.get(&#39;setup&#39;)
<span class="gi">+</span>
<span class="w"> </span>        if &#39;extensions&#39; in self._overrides:
<span class="w"> </span>            extensions = self._overrides.pop(&#39;extensions&#39;)
<span class="w"> </span>            if isinstance(extensions, str):
<span class="gu">@@ -225,23 +297,102 @@ class Config:</span>
<span class="w"> </span>                raw_config[&#39;extensions&#39;] = extensions
<span class="w"> </span>        self.extensions: list[str] = raw_config.get(&#39;extensions&#39;, [])

<span class="gi">+    @property</span>
<span class="gi">+    def values(self) -&gt; dict[str, _Opt]:</span>
<span class="gi">+        return self._options</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def overrides(self) -&gt; dict[str, Any]:</span>
<span class="gi">+        return self._overrides</span>
<span class="gi">+</span>
<span class="w"> </span>    @classmethod
<span class="gd">-    def read(cls: type[Config], confdir: (str | os.PathLike[str]),</span>
<span class="gd">-        overrides: (dict | None)=None, tags: (Tags | None)=None) -&gt;Config:</span>
<span class="gi">+    def read(cls: type[Config], confdir: str | os.PathLike[str], overrides: dict | None = None,</span>
<span class="gi">+             tags: Tags | None = None) -&gt; Config:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a Config object from configuration file.&quot;&quot;&quot;
<span class="gi">+        filename = path.join(confdir, CONFIG_FILENAME)</span>
<span class="gi">+        if not path.isfile(filename):</span>
<span class="gi">+            raise ConfigError(__(&quot;config directory doesn&#39;t contain a conf.py file (%s)&quot;) %</span>
<span class="gi">+                              confdir)</span>
<span class="gi">+        namespace = eval_config_file(filename, tags)</span>
<span class="gi">+</span>
<span class="gi">+        # Note: Old sphinx projects have been configured as &quot;language = None&quot; because</span>
<span class="gi">+        #       sphinx-quickstart previously generated this by default.</span>
<span class="gi">+        #       To keep compatibility, they should be fallback to &#39;en&#39; for a while</span>
<span class="gi">+        #       (This conversion should not be removed before 2025-01-01).</span>
<span class="gi">+        if namespace.get(&quot;language&quot;, ...) is None:</span>
<span class="gi">+            logger.warning(__(&quot;Invalid configuration value found: &#39;language = None&#39;. &quot;</span>
<span class="gi">+                              &quot;Update your configuration to a valid language code. &quot;</span>
<span class="gi">+                              &quot;Falling back to &#39;en&#39; (English).&quot;))</span>
<span class="gi">+            namespace[&quot;language&quot;] = &quot;en&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return cls(namespace, overrides)</span>
<span class="gi">+</span>
<span class="gi">+    def convert_overrides(self, name: str, value: str) -&gt; Any:</span>
<span class="gi">+        opt = self._options[name]</span>
<span class="gi">+        default = opt.default</span>
<span class="gi">+        valid_types = opt.valid_types</span>
<span class="gi">+        if valid_types == Any:</span>
<span class="gi">+            return value</span>
<span class="gi">+        if (type(default) is bool</span>
<span class="gi">+            or (not isinstance(valid_types, ENUM)</span>
<span class="gi">+                and len(valid_types) == 1 and bool in valid_types)):</span>
<span class="gi">+            if isinstance(valid_types, ENUM) or len(valid_types) &gt; 1:</span>
<span class="gi">+                # if valid_types are given, and non-bool valid types exist,</span>
<span class="gi">+                # return the value without coercing to a Boolean.</span>
<span class="gi">+                return value</span>
<span class="gi">+            # given falsy string from a command line option</span>
<span class="gi">+            return value not in {&#39;0&#39;, &#39;&#39;}</span>
<span class="gi">+        if isinstance(default, dict):</span>
<span class="gi">+            raise ValueError(__(&#39;cannot override dictionary config setting %r, &#39;</span>
<span class="gi">+                                &#39;ignoring (use %r to set individual elements)&#39;) %</span>
<span class="gi">+                             (name, f&#39;{name}.key=value&#39;))</span>
<span class="gi">+        if isinstance(default, list):</span>
<span class="gi">+            return value.split(&#39;,&#39;)</span>
<span class="gi">+        if isinstance(default, int):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return int(value)</span>
<span class="gi">+            except ValueError as exc:</span>
<span class="gi">+                raise ValueError(__(&#39;invalid number %r for config value %r, ignoring&#39;) %</span>
<span class="gi">+                                 (value, name)) from exc</span>
<span class="gi">+        if callable(default):</span>
<span class="gi">+            return value</span>
<span class="gi">+        if isinstance(default, str) or default is None:</span>
<span class="gi">+            return value</span>
<span class="gi">+        raise ValueError(__(&#39;cannot override config setting %r with unsupported &#39;</span>
<span class="gi">+                            &#39;type, ignoring&#39;) % name)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def pre_init_values() -&gt; None:</span>
<span class="gi">+        # method only retained for compatibility</span>
<span class="w"> </span>        pass
<span class="gd">-</span>
<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+        # warnings.warn(</span>
<span class="gi">+        #     &#39;Config.pre_init_values() will be removed in Sphinx 9.0 or later&#39;,</span>
<span class="gi">+        #     RemovedInSphinx90Warning, stacklevel=2)</span>
<span class="gi">+</span>
<span class="gi">+    def init_values(self) -&gt; None:</span>
<span class="gi">+        # method only retained for compatibility</span>
<span class="gi">+        self._report_override_warnings()</span>
<span class="gi">+        # warnings.warn(</span>
<span class="gi">+        #     &#39;Config.init_values() will be removed in Sphinx 9.0 or later&#39;,</span>
<span class="gi">+        #     RemovedInSphinx90Warning, stacklevel=2)</span>
<span class="gi">+</span>
<span class="gi">+    def _report_override_warnings(self) -&gt; None:</span>
<span class="gi">+        for name in self._overrides:</span>
<span class="gi">+            if name not in self._options:</span>
<span class="gi">+                logger.warning(__(&#39;unknown config value %r in override, ignoring&#39;), name)</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        values = []
<span class="w"> </span>        for opt_name in self._options:
<span class="w"> </span>            try:
<span class="w"> </span>                opt_value = getattr(self, opt_name)
<span class="w"> </span>            except Exception:
<span class="w"> </span>                opt_value = &#39;&lt;error!&gt;&#39;
<span class="gd">-            values.append(f&#39;{opt_name}={opt_value!r}&#39;)</span>
<span class="gi">+            values.append(f&quot;{opt_name}={opt_value!r}&quot;)</span>
<span class="w"> </span>        return self.__class__.__qualname__ + &#39;(&#39; + &#39;, &#39;.join(values) + &#39;)&#39;

<span class="gd">-    def __setattr__(self, key: str, value: object) -&gt;None:</span>
<span class="gi">+    def __setattr__(self, key: str, value: object) -&gt; None:</span>
<span class="gi">+        # Ensure aliases update their counterpart.</span>
<span class="w"> </span>        if key == &#39;master_doc&#39;:
<span class="w"> </span>            super().__setattr__(&#39;root_doc&#39;, value)
<span class="w"> </span>        elif key == &#39;root_doc&#39;:
<span class="gu">@@ -252,8 +403,9 @@ class Config:</span>
<span class="w"> </span>            super().__setattr__(&#39;copyright&#39;, value)
<span class="w"> </span>        super().__setattr__(key, value)

<span class="gd">-    def __getattr__(self, name: str) -&gt;Any:</span>
<span class="gi">+    def __getattr__(self, name: str) -&gt; Any:</span>
<span class="w"> </span>        if name in self._options:
<span class="gi">+            # first check command-line overrides</span>
<span class="w"> </span>            if name in self._overrides:
<span class="w"> </span>                value = self._overrides[name]
<span class="w"> </span>                if not isinstance(value, str):
<span class="gu">@@ -262,108 +414,233 @@ class Config:</span>
<span class="w"> </span>                try:
<span class="w"> </span>                    value = self.convert_overrides(name, value)
<span class="w"> </span>                except ValueError as exc:
<span class="gd">-                    logger.warning(&#39;%s&#39;, exc)</span>
<span class="gi">+                    logger.warning(&quot;%s&quot;, exc)</span>
<span class="w"> </span>                else:
<span class="w"> </span>                    self.__setattr__(name, value)
<span class="w"> </span>                    return value
<span class="gi">+            # then check values from &#39;conf.py&#39;</span>
<span class="w"> </span>            if name in self._raw_config:
<span class="w"> </span>                value = self._raw_config[name]
<span class="w"> </span>                self.__setattr__(name, value)
<span class="w"> </span>                return value
<span class="gi">+            # finally, fall back to the default value</span>
<span class="w"> </span>            default = self._options[name].default
<span class="w"> </span>            if callable(default):
<span class="w"> </span>                return default(self)
<span class="w"> </span>            self.__dict__[name] = default
<span class="w"> </span>            return default
<span class="w"> </span>        if name.startswith(&#39;_&#39;):
<span class="gd">-            msg = (</span>
<span class="gd">-                f&#39;{self.__class__.__name__!r} object has no attribute {name!r}&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+            msg = f&#39;{self.__class__.__name__!r} object has no attribute {name!r}&#39;</span>
<span class="w"> </span>            raise AttributeError(msg)
<span class="w"> </span>        msg = __(&#39;No such config value: %r&#39;) % name
<span class="w"> </span>        raise AttributeError(msg)

<span class="gd">-    def __getitem__(self, name: str) -&gt;Any:</span>
<span class="gi">+    def __getitem__(self, name: str) -&gt; Any:</span>
<span class="w"> </span>        return getattr(self, name)

<span class="gd">-    def __setitem__(self, name: str, value: Any) -&gt;None:</span>
<span class="gi">+    def __setitem__(self, name: str, value: Any) -&gt; None:</span>
<span class="w"> </span>        setattr(self, name, value)

<span class="gd">-    def __delitem__(self, name: str) -&gt;None:</span>
<span class="gi">+    def __delitem__(self, name: str) -&gt; None:</span>
<span class="w"> </span>        delattr(self, name)

<span class="gd">-    def __contains__(self, name: str) -&gt;bool:</span>
<span class="gi">+    def __contains__(self, name: str) -&gt; bool:</span>
<span class="w"> </span>        return name in self._options

<span class="gd">-    def __iter__(self) -&gt;Iterator[ConfigValue]:</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[ConfigValue]:</span>
<span class="w"> </span>        for name, opt in self._options.items():
<span class="w"> </span>            yield ConfigValue(name, getattr(self, name), opt.rebuild)

<span class="gd">-    def __getstate__(self) -&gt;dict:</span>
<span class="gi">+    def add(self, name: str, default: Any, rebuild: _ConfigRebuild,</span>
<span class="gi">+            types: type | Collection[type] | ENUM,</span>
<span class="gi">+            description: str = &#39;&#39;) -&gt; None:</span>
<span class="gi">+        if name in self._options:</span>
<span class="gi">+            raise ExtensionError(__(&#39;Config value %r already present&#39;) % name)</span>
<span class="gi">+</span>
<span class="gi">+        # standardise rebuild</span>
<span class="gi">+        if isinstance(rebuild, bool):</span>
<span class="gi">+            rebuild = &#39;env&#39; if rebuild else &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        # standardise valid_types</span>
<span class="gi">+        valid_types = _validate_valid_types(types)</span>
<span class="gi">+        self._options[name] = _Opt(default, rebuild, valid_types, description)</span>
<span class="gi">+</span>
<span class="gi">+    def filter(self, rebuild: Set[_ConfigRebuild]) -&gt; Iterator[ConfigValue]:</span>
<span class="gi">+        if isinstance(rebuild, str):</span>
<span class="gi">+            return (value for value in self if value.rebuild == rebuild)</span>
<span class="gi">+        return (value for value in self if value.rebuild in rebuild)</span>
<span class="gi">+</span>
<span class="gi">+    def __getstate__(self) -&gt; dict:</span>
<span class="w"> </span>        &quot;&quot;&quot;Obtains serializable data for pickling.&quot;&quot;&quot;
<span class="gd">-        __dict__ = {key: value for key, value in self.__dict__.items() if </span>
<span class="gd">-            not key.startswith(&#39;_&#39;) and is_serializable(value)}</span>
<span class="gi">+        # remove potentially pickling-problematic values from config</span>
<span class="gi">+        __dict__ = {</span>
<span class="gi">+            key: value</span>
<span class="gi">+            for key, value in self.__dict__.items()</span>
<span class="gi">+            if not key.startswith(&#39;_&#39;) and is_serializable(value)</span>
<span class="gi">+        }</span>
<span class="gi">+        # create a picklable copy of ``self._options``</span>
<span class="w"> </span>        __dict__[&#39;_options&#39;] = _options = {}
<span class="w"> </span>        for name, opt in self._options.items():
<span class="gd">-            if not isinstance(opt, _Opt) and isinstance(opt, tuple) and len(opt</span>
<span class="gd">-                ) &lt;= 3:</span>
<span class="gi">+            if not isinstance(opt, _Opt) and isinstance(opt, tuple) and len(opt) &lt;= 3:</span>
<span class="gi">+                # Fix for Furo&#39;s ``_update_default``.</span>
<span class="w"> </span>                self._options[name] = opt = _Opt(*opt)
<span class="w"> </span>            real_value = getattr(self, name)
<span class="w"> </span>            if not is_serializable(real_value):
<span class="w"> </span>                if opt.rebuild:
<span class="gd">-                    logger.warning(__(</span>
<span class="gd">-                        &#39;cannot cache unpickable configuration value: %r (because it contains a function, class, or module object)&#39;</span>
<span class="gd">-                        ), name, type=&#39;config&#39;, subtype=&#39;cache&#39;, once=True)</span>
<span class="gi">+                    # if the value is not cached, then any build that utilises this cache</span>
<span class="gi">+                    # will always mark the config value as changed,</span>
<span class="gi">+                    # and thus always invalidate the cache and perform a rebuild.</span>
<span class="gi">+                    logger.warning(</span>
<span class="gi">+                        __(&#39;cannot cache unpickable configuration value: %r &#39;</span>
<span class="gi">+                           &#39;(because it contains a function, class, or module object)&#39;),</span>
<span class="gi">+                        name,</span>
<span class="gi">+                        type=&#39;config&#39;,</span>
<span class="gi">+                        subtype=&#39;cache&#39;,</span>
<span class="gi">+                        once=True,</span>
<span class="gi">+                    )</span>
<span class="gi">+                # omit unserializable value</span>
<span class="w"> </span>                real_value = None
<span class="gi">+            # valid_types is also omitted</span>
<span class="w"> </span>            _options[name] = real_value, opt.rebuild
<span class="gi">+</span>
<span class="w"> </span>        return __dict__

<span class="gd">-    def __setstate__(self, state: dict) -&gt;None:</span>
<span class="gi">+    def __setstate__(self, state: dict) -&gt; None:</span>
<span class="w"> </span>        self._overrides = {}
<span class="gd">-        self._options = {name: _Opt(real_value, rebuild, ()) for name, (</span>
<span class="gd">-            real_value, rebuild) in state.pop(&#39;_options&#39;).items()}</span>
<span class="gi">+        self._options = {</span>
<span class="gi">+            name: _Opt(real_value, rebuild, ())</span>
<span class="gi">+            for name, (real_value, rebuild) in state.pop(&#39;_options&#39;).items()</span>
<span class="gi">+        }</span>
<span class="w"> </span>        self._raw_config = {}
<span class="w"> </span>        self.__dict__.update(state)


<span class="gd">-def eval_config_file(filename: str, tags: (Tags | None)) -&gt;dict[str, Any]:</span>
<span class="gi">+def eval_config_file(filename: str, tags: Tags | None) -&gt; dict[str, Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Evaluate a config file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def convert_source_suffix(app: Sphinx, config: Config) -&gt;None:</span>
<span class="gi">+    namespace: dict[str, Any] = {}</span>
<span class="gi">+    namespace[&#39;__file__&#39;] = filename</span>
<span class="gi">+    namespace[&#39;tags&#39;] = tags</span>
<span class="gi">+</span>
<span class="gi">+    with chdir(path.dirname(filename)):</span>
<span class="gi">+        # during executing config file, current dir is changed to ``confdir``.</span>
<span class="gi">+        try:</span>
<span class="gi">+            with open(filename, &#39;rb&#39;) as f:</span>
<span class="gi">+                code = compile(f.read(), filename.encode(fs_encoding), &#39;exec&#39;)</span>
<span class="gi">+                exec(code, namespace)  # NoQA: S102</span>
<span class="gi">+        except SyntaxError as err:</span>
<span class="gi">+            msg = __(&quot;There is a syntax error in your configuration file: %s\n&quot;)</span>
<span class="gi">+            raise ConfigError(msg % err) from err</span>
<span class="gi">+        except SystemExit as exc:</span>
<span class="gi">+            msg = __(&quot;The configuration file (or one of the modules it imports) &quot;</span>
<span class="gi">+                     &quot;called sys.exit()&quot;)</span>
<span class="gi">+            raise ConfigError(msg) from exc</span>
<span class="gi">+        except ConfigError:</span>
<span class="gi">+            # pass through ConfigError from conf.py as is.  It will be shown in console.</span>
<span class="gi">+            raise</span>
<span class="gi">+        except Exception as exc:</span>
<span class="gi">+            msg = __(&quot;There is a programmable error in your configuration file:\n\n%s&quot;)</span>
<span class="gi">+            raise ConfigError(msg % traceback.format_exc()) from exc</span>
<span class="gi">+</span>
<span class="gi">+    return namespace</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _validate_valid_types(</span>
<span class="gi">+    valid_types: type | Collection[type] | ENUM, /,</span>
<span class="gi">+) -&gt; tuple[()] | tuple[type, ...] | frozenset[type] | ENUM:</span>
<span class="gi">+    if not valid_types:</span>
<span class="gi">+        return ()</span>
<span class="gi">+    if isinstance(valid_types, frozenset | ENUM):</span>
<span class="gi">+        return valid_types</span>
<span class="gi">+    if isinstance(valid_types, type):</span>
<span class="gi">+        return frozenset((valid_types,))</span>
<span class="gi">+    if valid_types is Any:</span>
<span class="gi">+        return frozenset({Any})  # type: ignore[arg-type]</span>
<span class="gi">+    if isinstance(valid_types, set):</span>
<span class="gi">+        return frozenset(valid_types)</span>
<span class="gi">+    if not isinstance(valid_types, tuple):</span>
<span class="gi">+        try:</span>
<span class="gi">+            valid_types = tuple(valid_types)</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            logger.warning(__(&#39;Failed to convert %r to a set or tuple&#39;), valid_types)</span>
<span class="gi">+            return valid_types  # type: ignore[return-value]</span>
<span class="gi">+    try:</span>
<span class="gi">+        return frozenset(valid_types)</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        return valid_types</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def convert_source_suffix(app: Sphinx, config: Config) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert old styled source_suffix to new styled one.

<span class="w"> </span>    * old style: str or list
<span class="w"> </span>    * new style: a dict which maps from fileext to filetype
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def convert_highlight_options(app: Sphinx, config: Config) -&gt;None:</span>
<span class="gi">+    source_suffix = config.source_suffix</span>
<span class="gi">+    if isinstance(source_suffix, str):</span>
<span class="gi">+        # if str, considers as default filetype (None)</span>
<span class="gi">+        #</span>
<span class="gi">+        # The default filetype is determined on later step.</span>
<span class="gi">+        # By default, it is considered as restructuredtext.</span>
<span class="gi">+        config.source_suffix = {source_suffix: &#39;restructuredtext&#39;}</span>
<span class="gi">+        logger.info(__(&quot;Converting `source_suffix = %r` to `source_suffix = %r`.&quot;),</span>
<span class="gi">+                    source_suffix, config.source_suffix)</span>
<span class="gi">+    elif isinstance(source_suffix, list | tuple):</span>
<span class="gi">+        # if list, considers as all of them are default filetype</span>
<span class="gi">+        config.source_suffix = dict.fromkeys(source_suffix, &#39;restructuredtext&#39;)</span>
<span class="gi">+        logger.info(__(&quot;Converting `source_suffix = %r` to `source_suffix = %r`.&quot;),</span>
<span class="gi">+                    source_suffix, config.source_suffix)</span>
<span class="gi">+    elif not isinstance(source_suffix, dict):</span>
<span class="gi">+        msg = __(&quot;The config value `source_suffix&#39; expects a dictionary, &quot;</span>
<span class="gi">+                 &quot;a string, or a list of strings. Got `%r&#39; instead (type %s).&quot;)</span>
<span class="gi">+        raise ConfigError(msg % (source_suffix, type(source_suffix)))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def convert_highlight_options(app: Sphinx, config: Config) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert old styled highlight_options to new styled one.

<span class="w"> </span>    * old style: options
<span class="w"> </span>    * new style: a dict which maps from language name to options
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    options = config.highlight_options</span>
<span class="gi">+    if options and not all(isinstance(v, dict) for v in options.values()):</span>
<span class="gi">+        # old styled option detected because all values are not dictionary.</span>
<span class="gi">+        config.highlight_options = {config.highlight_language: options}</span>


<span class="gd">-def init_numfig_format(app: Sphinx, config: Config) -&gt;None:</span>
<span class="gi">+def init_numfig_format(app: Sphinx, config: Config) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Initialize :confval:`numfig_format`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    numfig_format = {&#39;section&#39;: _(&#39;Section %s&#39;),</span>
<span class="gi">+                     &#39;figure&#39;: _(&#39;Fig. %s&#39;),</span>
<span class="gi">+                     &#39;table&#39;: _(&#39;Table %s&#39;),</span>
<span class="gi">+                     &#39;code-block&#39;: _(&#39;Listing %s&#39;)}</span>
<span class="gi">+</span>
<span class="gi">+    # override default labels by configuration</span>
<span class="gi">+    numfig_format.update(config.numfig_format)</span>
<span class="gi">+    config.numfig_format = numfig_format</span>


<span class="gd">-def correct_copyright_year(_app: Sphinx, config: Config) -&gt;None:</span>
<span class="gi">+def correct_copyright_year(_app: Sphinx, config: Config) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Correct values of copyright year that are not coherent with
<span class="w"> </span>    the SOURCE_DATE_EPOCH environment variable (if set)

<span class="w"> </span>    See https://reproducible-builds.org/specs/source-date-epoch/
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if (source_date_epoch := getenv(&#39;SOURCE_DATE_EPOCH&#39;)) is None:</span>
<span class="gi">+        return</span>

<span class="gi">+    source_date_epoch_year = str(time.gmtime(int(source_date_epoch)).tm_year)</span>

<span class="gd">-def _substitute_copyright_year(copyright_line: str, replace_year: str) -&gt;str:</span>
<span class="gi">+    for k in (&#39;copyright&#39;, &#39;epub_copyright&#39;):</span>
<span class="gi">+        if k in config:</span>
<span class="gi">+            value: str | Sequence[str] = config[k]</span>
<span class="gi">+            if isinstance(value, str):</span>
<span class="gi">+                config[k] = _substitute_copyright_year(value, source_date_epoch_year)</span>
<span class="gi">+            else:</span>
<span class="gi">+                items = (_substitute_copyright_year(x, source_date_epoch_year) for x in value)</span>
<span class="gi">+                config[k] = type(value)(items)  # type: ignore[call-arg]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _substitute_copyright_year(copyright_line: str, replace_year: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Replace the year in a single copyright line.

<span class="w"> </span>    Legal formats are:
<span class="gu">@@ -376,19 +653,118 @@ def _substitute_copyright_year(copyright_line: str, replace_year: str) -&gt;str:</span>

<span class="w"> </span>    The final year in the string is replaced with ``replace_year``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(copyright_line) &lt; 4 or not copyright_line[:4].isdigit():</span>
<span class="gi">+        return copyright_line</span>
<span class="gi">+</span>
<span class="gi">+    if copyright_line[4:5] in {&#39;&#39;, &#39; &#39;, &#39;,&#39;}:</span>
<span class="gi">+        return replace_year + copyright_line[4:]</span>
<span class="gi">+</span>
<span class="gi">+    if copyright_line[4] != &#39;-&#39;:</span>
<span class="gi">+        return copyright_line</span>
<span class="gi">+</span>
<span class="gi">+    if copyright_line[5:9].isdigit() and copyright_line[9:10] in {&#39;&#39;, &#39; &#39;, &#39;,&#39;}:</span>
<span class="gi">+        return copyright_line[:5] + replace_year + copyright_line[9:]</span>
<span class="gi">+</span>
<span class="gi">+    return copyright_line</span>


<span class="gd">-def check_confval_types(app: (Sphinx | None), config: Config) -&gt;None:</span>
<span class="gi">+def check_confval_types(app: Sphinx | None, config: Config) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check all values for deviation from the default value&#39;s type, since
<span class="w"> </span>    that can result in TypeErrors all over the place NB.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for name, opt in config._options.items():</span>
<span class="gi">+        default = opt.default</span>
<span class="gi">+        valid_types = opt.valid_types</span>
<span class="gi">+        value = getattr(config, name)</span>
<span class="gi">+</span>
<span class="gi">+        if callable(default):</span>
<span class="gi">+            default = default(config)  # evaluate default value</span>
<span class="gi">+        if default is None and not valid_types:</span>
<span class="gi">+            continue  # neither inferable nor explicitly annotated types</span>
<span class="gi">+</span>
<span class="gi">+        if valid_types == frozenset({Any}):  # any type of value is accepted</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(valid_types, ENUM):</span>
<span class="gi">+            if not valid_types.match(value):</span>
<span class="gi">+                msg = __(&quot;The config value `{name}` has to be a one of {candidates}, &quot;</span>
<span class="gi">+                         &quot;but `{current}` is given.&quot;)</span>
<span class="gi">+                logger.warning(</span>
<span class="gi">+                    msg.format(name=name, current=value, candidates=valid_types.candidates),</span>
<span class="gi">+                    once=True,</span>
<span class="gi">+                )</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        type_value = type(value)</span>
<span class="gi">+        type_default = type(default)</span>
<span class="gi">+</span>
<span class="gi">+        if type_value is type_default:  # attempt to infer the type</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if type_value in valid_types:  # check explicitly listed types</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        common_bases = ({*type_value.__bases__, type_value}</span>
<span class="gi">+                        &amp; set(type_default.__bases__))</span>
<span class="gi">+        common_bases.discard(object)</span>
<span class="gi">+        if common_bases:</span>
<span class="gi">+            continue  # at least we share a non-trivial base class</span>
<span class="gi">+</span>
<span class="gi">+        if valid_types:</span>
<span class="gi">+            msg = __(&quot;The config value `{name}&#39; has type `{current.__name__}&#39;; &quot;</span>
<span class="gi">+                     &quot;expected {permitted}.&quot;)</span>
<span class="gi">+            wrapped_valid_types = sorted(f&quot;`{c.__name__}&#39;&quot; for c in valid_types)</span>
<span class="gi">+            if len(wrapped_valid_types) &gt; 2:</span>
<span class="gi">+                permitted = (&quot;, &quot;.join(wrapped_valid_types[:-1])</span>
<span class="gi">+                             + f&quot;, or {wrapped_valid_types[-1]}&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                permitted = &quot; or &quot;.join(wrapped_valid_types)</span>
<span class="gi">+            logger.warning(</span>
<span class="gi">+                msg.format(name=name, current=type_value, permitted=permitted),</span>
<span class="gi">+                once=True,</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            msg = __(&quot;The config value `{name}&#39; has type `{current.__name__}&#39;, &quot;</span>
<span class="gi">+                     &quot;defaults to `{default.__name__}&#39;.&quot;)</span>
<span class="gi">+            logger.warning(</span>
<span class="gi">+                msg.format(name=name, current=type_value, default=type_default),</span>
<span class="gi">+                once=True,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def check_primary_domain(app: Sphinx, config: Config) -&gt; None:</span>
<span class="gi">+    primary_domain = config.primary_domain</span>
<span class="gi">+    if primary_domain and not app.registry.has_domain(primary_domain):</span>
<span class="gi">+        logger.warning(__(&#39;primary_domain %r not found, ignored.&#39;), primary_domain)</span>
<span class="gi">+        config.primary_domain = None</span>


<span class="w"> </span>def check_root_doc(app: Sphinx, env: BuildEnvironment, added: Set[str],
<span class="gd">-    changed: Set[str], removed: Set[str]) -&gt;Iterable[str]:</span>
<span class="gi">+                   changed: Set[str], removed: Set[str]) -&gt; Iterable[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Adjust root_doc to &#39;contents&#39; to support an old project which does not have
<span class="w"> </span>    any root_doc setting.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if (app.config.root_doc == &#39;index&#39; and</span>
<span class="gi">+            &#39;index&#39; not in app.project.docnames and</span>
<span class="gi">+            &#39;contents&#39; in app.project.docnames):</span>
<span class="gi">+        logger.warning(__(&#39;Since v2.0, Sphinx uses &quot;index&quot; as root_doc by default. &#39;</span>
<span class="gi">+                          &#39;Please add &quot;root_doc = \&#39;contents\&#39;&quot; to your conf.py.&#39;))</span>
<span class="gi">+        app.config.root_doc = &quot;contents&quot;</span>
<span class="gi">+</span>
<span class="gi">+    return changed</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.connect(&#39;config-inited&#39;, convert_source_suffix, priority=800)</span>
<span class="gi">+    app.connect(&#39;config-inited&#39;, convert_highlight_options, priority=800)</span>
<span class="gi">+    app.connect(&#39;config-inited&#39;, init_numfig_format, priority=800)</span>
<span class="gi">+    app.connect(&#39;config-inited&#39;, correct_copyright_year, priority=800)</span>
<span class="gi">+    app.connect(&#39;config-inited&#39;, check_confval_types, priority=800)</span>
<span class="gi">+    app.connect(&#39;config-inited&#39;, check_primary_domain, priority=800)</span>
<span class="gi">+    app.connect(&#39;env-get-outdated&#39;, check_root_doc)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/deprecation.py b/sphinx/deprecation.py</span>
<span class="gh">index ee68dfa87..1baec85bf 100644</span>
<span class="gd">--- a/sphinx/deprecation.py</span>
<span class="gi">+++ b/sphinx/deprecation.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Sphinx deprecation classes and utilities.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import warnings


<span class="gu">@@ -14,8 +16,14 @@ class RemovedInSphinx10Warning(PendingDeprecationWarning):</span>
<span class="w"> </span>RemovedInNextVersionWarning = RemovedInSphinx90Warning


<span class="gd">-def _deprecation_warning(module: str, attribute: str, canonical_name: str=</span>
<span class="gd">-    &#39;&#39;, *, remove: tuple[int, int], raises: bool=False) -&gt;None:</span>
<span class="gi">+def _deprecation_warning(</span>
<span class="gi">+    module: str,</span>
<span class="gi">+    attribute: str,</span>
<span class="gi">+    canonical_name: str = &#39;&#39;,</span>
<span class="gi">+    *,</span>
<span class="gi">+    remove: tuple[int, int],</span>
<span class="gi">+    raises: bool = False,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Helper function for module-level deprecations using ``__getattr__``.

<span class="w"> </span>    :param module: The module containing a deprecated object.
<span class="gu">@@ -51,4 +59,24 @@ def _deprecation_warning(module: str, attribute: str, canonical_name: str=</span>
<span class="w"> </span>           _deprecation_warning(__name__, name, canonical_name, remove=remove)
<span class="w"> </span>           return deprecated_object
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if remove == (9, 0):</span>
<span class="gi">+        warning_class: type[Warning] = RemovedInSphinx90Warning</span>
<span class="gi">+    elif remove == (10, 0):</span>
<span class="gi">+        warning_class = RemovedInSphinx10Warning</span>
<span class="gi">+    else:</span>
<span class="gi">+        msg = f&#39;removal version {remove!r} is invalid!&#39;</span>
<span class="gi">+        raise RuntimeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    qualname = f&#39;{module}.{attribute}&#39;</span>
<span class="gi">+    if canonical_name:</span>
<span class="gi">+        message = (</span>
<span class="gi">+            f&#39;The alias {qualname!r} is deprecated, use {canonical_name!r} instead.&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        message = f&#39;{qualname!r} is deprecated.&#39;</span>
<span class="gi">+</span>
<span class="gi">+    if raises:</span>
<span class="gi">+        raise AttributeError(message)</span>
<span class="gi">+</span>
<span class="gi">+    message = f&#39;{message} Check CHANGES for Sphinx API modifications.&#39;</span>
<span class="gi">+    warnings.warn(message, warning_class, stacklevel=3)</span>
<span class="gh">diff --git a/sphinx/directives/code.py b/sphinx/directives/code.py</span>
<span class="gh">index 5e6e9c131..5dc42e5b7 100644</span>
<span class="gd">--- a/sphinx/directives/code.py</span>
<span class="gi">+++ b/sphinx/directives/code.py</span>
<span class="gu">@@ -1,20 +1,26 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>import textwrap
<span class="w"> </span>from difflib import unified_diff
<span class="w"> </span>from typing import TYPE_CHECKING, Any, ClassVar
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.parsers.rst import directives
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.directives import optional_int
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.util import logging, parselinenos
<span class="w"> </span>from sphinx.util.docutils import SphinxDirective
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.nodes import Element, Node
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.config import Config
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata, OptionSpec
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="gu">@@ -23,12 +29,64 @@ class Highlight(SphinxDirective):</span>
<span class="w"> </span>    Directive to set the highlighting language for code blocks, as well
<span class="w"> </span>    as the threshold for line numbers.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    has_content = False
<span class="w"> </span>    required_arguments = 1
<span class="w"> </span>    optional_arguments = 0
<span class="w"> </span>    final_argument_whitespace = False
<span class="gd">-    option_spec: ClassVar[OptionSpec] = {&#39;force&#39;: directives.flag,</span>
<span class="gd">-        &#39;linenothreshold&#39;: directives.positive_int}</span>
<span class="gi">+    option_spec: ClassVar[OptionSpec] = {</span>
<span class="gi">+        &#39;force&#39;: directives.flag,</span>
<span class="gi">+        &#39;linenothreshold&#39;: directives.positive_int,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        language = self.arguments[0].strip()</span>
<span class="gi">+        linenothreshold = self.options.get(&#39;linenothreshold&#39;, sys.maxsize)</span>
<span class="gi">+        force = &#39;force&#39; in self.options</span>
<span class="gi">+</span>
<span class="gi">+        self.env.temp_data[&#39;highlight_language&#39;] = language</span>
<span class="gi">+        return [addnodes.highlightlang(lang=language,</span>
<span class="gi">+                                       force=force,</span>
<span class="gi">+                                       linenothreshold=linenothreshold)]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def dedent_lines(</span>
<span class="gi">+    lines: list[str], dedent: int | None, location: tuple[str, int] | None = None,</span>
<span class="gi">+) -&gt; list[str]:</span>
<span class="gi">+    if dedent is None:</span>
<span class="gi">+        return textwrap.dedent(&#39;&#39;.join(lines)).splitlines(True)</span>
<span class="gi">+</span>
<span class="gi">+    if any(s[:dedent].strip() for s in lines):</span>
<span class="gi">+        logger.warning(__(&#39;non-whitespace stripped by dedent&#39;), location=location)</span>
<span class="gi">+</span>
<span class="gi">+    new_lines = []</span>
<span class="gi">+    for line in lines:</span>
<span class="gi">+        new_line = line[dedent:]</span>
<span class="gi">+        if line.endswith(&#39;\n&#39;) and not new_line:</span>
<span class="gi">+            new_line = &#39;\n&#39;  # keep CRLF</span>
<span class="gi">+        new_lines.append(new_line)</span>
<span class="gi">+</span>
<span class="gi">+    return new_lines</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def container_wrapper(</span>
<span class="gi">+    directive: SphinxDirective, literal_node: Node, caption: str,</span>
<span class="gi">+) -&gt; nodes.container:</span>
<span class="gi">+    container_node = nodes.container(&#39;&#39;, literal_block=True,</span>
<span class="gi">+                                     classes=[&#39;literal-block-wrapper&#39;])</span>
<span class="gi">+    parsed = directive.parse_text_to_nodes(caption, offset=directive.content_offset)</span>
<span class="gi">+    node = parsed[0]</span>
<span class="gi">+    if isinstance(node, nodes.system_message):</span>
<span class="gi">+        msg = __(&#39;Invalid caption: %s&#39;) % node.astext()</span>
<span class="gi">+        raise ValueError(msg)</span>
<span class="gi">+    if isinstance(node, nodes.Element):</span>
<span class="gi">+        caption_node = nodes.caption(node.rawsource, &#39;&#39;, *node.children)</span>
<span class="gi">+        caption_node.source = literal_node.source</span>
<span class="gi">+        caption_node.line = literal_node.line</span>
<span class="gi">+        container_node += caption_node</span>
<span class="gi">+        container_node += literal_node</span>
<span class="gi">+        return container_node</span>
<span class="gi">+    raise RuntimeError  # never reached</span>


<span class="w"> </span>class CodeBlock(SphinxDirective):
<span class="gu">@@ -36,33 +94,290 @@ class CodeBlock(SphinxDirective):</span>
<span class="w"> </span>    Directive for a code block with special highlighting or line numbering
<span class="w"> </span>    settings.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    has_content = True
<span class="w"> </span>    required_arguments = 0
<span class="w"> </span>    optional_arguments = 1
<span class="w"> </span>    final_argument_whitespace = False
<span class="gd">-    option_spec: ClassVar[OptionSpec] = {&#39;force&#39;: directives.flag,</span>
<span class="gd">-        &#39;linenos&#39;: directives.flag, &#39;dedent&#39;: optional_int, &#39;lineno-start&#39;:</span>
<span class="gd">-        int, &#39;emphasize-lines&#39;: directives.unchanged_required, &#39;caption&#39;:</span>
<span class="gd">-        directives.unchanged_required, &#39;class&#39;: directives.class_option,</span>
<span class="gd">-        &#39;name&#39;: directives.unchanged}</span>
<span class="gi">+    option_spec: ClassVar[OptionSpec] = {</span>
<span class="gi">+        &#39;force&#39;: directives.flag,</span>
<span class="gi">+        &#39;linenos&#39;: directives.flag,</span>
<span class="gi">+        &#39;dedent&#39;: optional_int,</span>
<span class="gi">+        &#39;lineno-start&#39;: int,</span>
<span class="gi">+        &#39;emphasize-lines&#39;: directives.unchanged_required,</span>
<span class="gi">+        &#39;caption&#39;: directives.unchanged_required,</span>
<span class="gi">+        &#39;class&#39;: directives.class_option,</span>
<span class="gi">+        &#39;name&#39;: directives.unchanged,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        document = self.state.document</span>
<span class="gi">+        code = &#39;\n&#39;.join(self.content)</span>
<span class="gi">+        location = self.state_machine.get_source_and_line(self.lineno)</span>
<span class="gi">+</span>
<span class="gi">+        linespec = self.options.get(&#39;emphasize-lines&#39;)</span>
<span class="gi">+        if linespec:</span>
<span class="gi">+            try:</span>
<span class="gi">+                nlines = len(self.content)</span>
<span class="gi">+                hl_lines = parselinenos(linespec, nlines)</span>
<span class="gi">+                if any(i &gt;= nlines for i in hl_lines):</span>
<span class="gi">+                    logger.warning(__(&#39;line number spec is out of range(1-%d): %r&#39;),</span>
<span class="gi">+                                   nlines, self.options[&#39;emphasize-lines&#39;],</span>
<span class="gi">+                                   location=location)</span>
<span class="gi">+</span>
<span class="gi">+                hl_lines = [x + 1 for x in hl_lines if x &lt; nlines]</span>
<span class="gi">+            except ValueError as err:</span>
<span class="gi">+                return [document.reporter.warning(err, line=self.lineno)]</span>
<span class="gi">+        else:</span>
<span class="gi">+            hl_lines = None</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;dedent&#39; in self.options:</span>
<span class="gi">+            location = self.state_machine.get_source_and_line(self.lineno)</span>
<span class="gi">+            lines = code.splitlines(True)</span>
<span class="gi">+            lines = dedent_lines(lines, self.options[&#39;dedent&#39;], location=location)</span>
<span class="gi">+            code = &#39;&#39;.join(lines)</span>
<span class="gi">+</span>
<span class="gi">+        literal: Element = nodes.literal_block(code, code)</span>
<span class="gi">+        if &#39;linenos&#39; in self.options or &#39;lineno-start&#39; in self.options:</span>
<span class="gi">+            literal[&#39;linenos&#39;] = True</span>
<span class="gi">+        literal[&#39;classes&#39;] += self.options.get(&#39;class&#39;, [])</span>
<span class="gi">+        literal[&#39;force&#39;] = &#39;force&#39; in self.options</span>
<span class="gi">+        if self.arguments:</span>
<span class="gi">+            # highlight language specified</span>
<span class="gi">+            literal[&#39;language&#39;] = self.arguments[0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            # no highlight language specified.  Then this directive refers the current</span>
<span class="gi">+            # highlight setting via ``highlight`` directive or ``highlight_language``</span>
<span class="gi">+            # configuration.</span>
<span class="gi">+            literal[&#39;language&#39;] = self.env.temp_data.get(&#39;highlight_language&#39;,</span>
<span class="gi">+                                                         self.config.highlight_language)</span>
<span class="gi">+        extra_args = literal[&#39;highlight_args&#39;] = {}</span>
<span class="gi">+        if hl_lines is not None:</span>
<span class="gi">+            extra_args[&#39;hl_lines&#39;] = hl_lines</span>
<span class="gi">+        if &#39;lineno-start&#39; in self.options:</span>
<span class="gi">+            extra_args[&#39;linenostart&#39;] = self.options[&#39;lineno-start&#39;]</span>
<span class="gi">+        self.set_source_info(literal)</span>
<span class="gi">+</span>
<span class="gi">+        caption = self.options.get(&#39;caption&#39;)</span>
<span class="gi">+        if caption:</span>
<span class="gi">+            try:</span>
<span class="gi">+                literal = container_wrapper(self, literal, caption)</span>
<span class="gi">+            except ValueError as exc:</span>
<span class="gi">+                return [document.reporter.warning(exc, line=self.lineno)]</span>
<span class="gi">+</span>
<span class="gi">+        # literal will be note_implicit_target that is linked from caption and numref.</span>
<span class="gi">+        # when options[&#39;name&#39;] is provided, it should be primary ID.</span>
<span class="gi">+        self.add_name(literal)</span>
<span class="gi">+</span>
<span class="gi">+        return [literal]</span>


<span class="w"> </span>class LiteralIncludeReader:
<span class="gd">-    INVALID_OPTIONS_PAIR = [(&#39;lineno-match&#39;, &#39;lineno-start&#39;), (</span>
<span class="gd">-        &#39;lineno-match&#39;, &#39;append&#39;), (&#39;lineno-match&#39;, &#39;prepend&#39;), (</span>
<span class="gd">-        &#39;start-after&#39;, &#39;start-at&#39;), (&#39;end-before&#39;, &#39;end-at&#39;), (&#39;diff&#39;,</span>
<span class="gd">-        &#39;pyobject&#39;), (&#39;diff&#39;, &#39;lineno-start&#39;), (&#39;diff&#39;, &#39;lineno-match&#39;), (</span>
<span class="gd">-        &#39;diff&#39;, &#39;lines&#39;), (&#39;diff&#39;, &#39;start-after&#39;), (&#39;diff&#39;, &#39;end-before&#39;),</span>
<span class="gd">-        (&#39;diff&#39;, &#39;start-at&#39;), (&#39;diff&#39;, &#39;end-at&#39;)]</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, filename: str, options: dict[str, Any], config: Config</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    INVALID_OPTIONS_PAIR = [</span>
<span class="gi">+        (&#39;lineno-match&#39;, &#39;lineno-start&#39;),</span>
<span class="gi">+        (&#39;lineno-match&#39;, &#39;append&#39;),</span>
<span class="gi">+        (&#39;lineno-match&#39;, &#39;prepend&#39;),</span>
<span class="gi">+        (&#39;start-after&#39;, &#39;start-at&#39;),</span>
<span class="gi">+        (&#39;end-before&#39;, &#39;end-at&#39;),</span>
<span class="gi">+        (&#39;diff&#39;, &#39;pyobject&#39;),</span>
<span class="gi">+        (&#39;diff&#39;, &#39;lineno-start&#39;),</span>
<span class="gi">+        (&#39;diff&#39;, &#39;lineno-match&#39;),</span>
<span class="gi">+        (&#39;diff&#39;, &#39;lines&#39;),</span>
<span class="gi">+        (&#39;diff&#39;, &#39;start-after&#39;),</span>
<span class="gi">+        (&#39;diff&#39;, &#39;end-before&#39;),</span>
<span class="gi">+        (&#39;diff&#39;, &#39;start-at&#39;),</span>
<span class="gi">+        (&#39;diff&#39;, &#39;end-at&#39;),</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, filename: str, options: dict[str, Any], config: Config) -&gt; None:</span>
<span class="w"> </span>        self.filename = filename
<span class="w"> </span>        self.options = options
<span class="w"> </span>        self.encoding = options.get(&#39;encoding&#39;, config.source_encoding)
<span class="w"> </span>        self.lineno_start = self.options.get(&#39;lineno-start&#39;, 1)
<span class="gi">+</span>
<span class="w"> </span>        self.parse_options()

<span class="gi">+    def parse_options(self) -&gt; None:</span>
<span class="gi">+        for option1, option2 in self.INVALID_OPTIONS_PAIR:</span>
<span class="gi">+            if option1 in self.options and option2 in self.options:</span>
<span class="gi">+                raise ValueError(__(&#39;Cannot use both &quot;%s&quot; and &quot;%s&quot; options&#39;) %</span>
<span class="gi">+                                 (option1, option2))</span>
<span class="gi">+</span>
<span class="gi">+    def read_file(</span>
<span class="gi">+        self, filename: str, location: tuple[str, int] | None = None,</span>
<span class="gi">+    ) -&gt; list[str]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            with open(filename, encoding=self.encoding, errors=&#39;strict&#39;) as f:</span>
<span class="gi">+                text = f.read()</span>
<span class="gi">+                if &#39;tab-width&#39; in self.options:</span>
<span class="gi">+                    text = text.expandtabs(self.options[&#39;tab-width&#39;])</span>
<span class="gi">+</span>
<span class="gi">+                return text.splitlines(True)</span>
<span class="gi">+        except OSError as exc:</span>
<span class="gi">+            raise OSError(__(&#39;Include file %r not found or reading it failed&#39;) %</span>
<span class="gi">+                          filename) from exc</span>
<span class="gi">+        except UnicodeError as exc:</span>
<span class="gi">+            raise UnicodeError(__(&#39;Encoding %r used for reading included file %r seems to &#39;</span>
<span class="gi">+                                  &#39;be wrong, try giving an :encoding: option&#39;) %</span>
<span class="gi">+                               (self.encoding, filename)) from exc</span>
<span class="gi">+</span>
<span class="gi">+    def read(self, location: tuple[str, int] | None = None) -&gt; tuple[str, int]:</span>
<span class="gi">+        if &#39;diff&#39; in self.options:</span>
<span class="gi">+            lines = self.show_diff()</span>
<span class="gi">+        else:</span>
<span class="gi">+            filters = [self.pyobject_filter,</span>
<span class="gi">+                       self.start_filter,</span>
<span class="gi">+                       self.end_filter,</span>
<span class="gi">+                       self.lines_filter,</span>
<span class="gi">+                       self.dedent_filter,</span>
<span class="gi">+                       self.prepend_filter,</span>
<span class="gi">+                       self.append_filter]</span>
<span class="gi">+            lines = self.read_file(self.filename, location=location)</span>
<span class="gi">+            for func in filters:</span>
<span class="gi">+                lines = func(lines, location=location)</span>
<span class="gi">+</span>
<span class="gi">+        return &#39;&#39;.join(lines), len(lines)</span>
<span class="gi">+</span>
<span class="gi">+    def show_diff(self, location: tuple[str, int] | None = None) -&gt; list[str]:</span>
<span class="gi">+        new_lines = self.read_file(self.filename)</span>
<span class="gi">+        old_filename = self.options[&#39;diff&#39;]</span>
<span class="gi">+        old_lines = self.read_file(old_filename)</span>
<span class="gi">+        diff = unified_diff(old_lines, new_lines, str(old_filename), str(self.filename))</span>
<span class="gi">+        return list(diff)</span>
<span class="gi">+</span>
<span class="gi">+    def pyobject_filter(</span>
<span class="gi">+        self, lines: list[str], location: tuple[str, int] | None = None,</span>
<span class="gi">+    ) -&gt; list[str]:</span>
<span class="gi">+        pyobject = self.options.get(&#39;pyobject&#39;)</span>
<span class="gi">+        if pyobject:</span>
<span class="gi">+            from sphinx.pycode import ModuleAnalyzer</span>
<span class="gi">+            analyzer = ModuleAnalyzer.for_file(self.filename, &#39;&#39;)</span>
<span class="gi">+            tags = analyzer.find_tags()</span>
<span class="gi">+            if pyobject not in tags:</span>
<span class="gi">+                raise ValueError(__(&#39;Object named %r not found in include file %r&#39;) %</span>
<span class="gi">+                                 (pyobject, self.filename))</span>
<span class="gi">+            start = tags[pyobject][1]</span>
<span class="gi">+            end = tags[pyobject][2]</span>
<span class="gi">+            lines = lines[start - 1:end]</span>
<span class="gi">+            if &#39;lineno-match&#39; in self.options:</span>
<span class="gi">+                self.lineno_start = start</span>
<span class="gi">+</span>
<span class="gi">+        return lines</span>
<span class="gi">+</span>
<span class="gi">+    def lines_filter(</span>
<span class="gi">+        self, lines: list[str], location: tuple[str, int] | None = None,</span>
<span class="gi">+    ) -&gt; list[str]:</span>
<span class="gi">+        linespec = self.options.get(&#39;lines&#39;)</span>
<span class="gi">+        if linespec:</span>
<span class="gi">+            linelist = parselinenos(linespec, len(lines))</span>
<span class="gi">+            if any(i &gt;= len(lines) for i in linelist):</span>
<span class="gi">+                logger.warning(__(&#39;line number spec is out of range(1-%d): %r&#39;),</span>
<span class="gi">+                               len(lines), linespec, location=location)</span>
<span class="gi">+</span>
<span class="gi">+            if &#39;lineno-match&#39; in self.options:</span>
<span class="gi">+                # make sure the line list is not &quot;disjoint&quot;.</span>
<span class="gi">+                first = linelist[0]</span>
<span class="gi">+                if all(first + i == n for i, n in enumerate(linelist)):</span>
<span class="gi">+                    self.lineno_start += linelist[0]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise ValueError(__(&#39;Cannot use &quot;lineno-match&quot; with a disjoint &#39;</span>
<span class="gi">+                                        &#39;set of &quot;lines&quot;&#39;))</span>
<span class="gi">+</span>
<span class="gi">+            lines = [lines[n] for n in linelist if n &lt; len(lines)]</span>
<span class="gi">+            if not lines:</span>
<span class="gi">+                raise ValueError(__(&#39;Line spec %r: no lines pulled from include file %r&#39;) %</span>
<span class="gi">+                                 (linespec, self.filename))</span>
<span class="gi">+</span>
<span class="gi">+        return lines</span>
<span class="gi">+</span>
<span class="gi">+    def start_filter(</span>
<span class="gi">+        self, lines: list[str], location: tuple[str, int] | None = None,</span>
<span class="gi">+    ) -&gt; list[str]:</span>
<span class="gi">+        if &#39;start-at&#39; in self.options:</span>
<span class="gi">+            start = self.options.get(&#39;start-at&#39;)</span>
<span class="gi">+            inclusive = False</span>
<span class="gi">+        elif &#39;start-after&#39; in self.options:</span>
<span class="gi">+            start = self.options.get(&#39;start-after&#39;)</span>
<span class="gi">+            inclusive = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            start = None</span>
<span class="gi">+</span>
<span class="gi">+        if start:</span>
<span class="gi">+            for lineno, line in enumerate(lines):</span>
<span class="gi">+                if start in line:</span>
<span class="gi">+                    if inclusive:</span>
<span class="gi">+                        if &#39;lineno-match&#39; in self.options:</span>
<span class="gi">+                            self.lineno_start += lineno + 1</span>
<span class="gi">+</span>
<span class="gi">+                        return lines[lineno + 1:]</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        if &#39;lineno-match&#39; in self.options:</span>
<span class="gi">+                            self.lineno_start += lineno</span>
<span class="gi">+</span>
<span class="gi">+                        return lines[lineno:]</span>
<span class="gi">+</span>
<span class="gi">+            if inclusive is True:</span>
<span class="gi">+                raise ValueError(&#39;start-after pattern not found: %s&#39; % start)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ValueError(&#39;start-at pattern not found: %s&#39; % start)</span>
<span class="gi">+</span>
<span class="gi">+        return lines</span>
<span class="gi">+</span>
<span class="gi">+    def end_filter(</span>
<span class="gi">+        self, lines: list[str], location: tuple[str, int] | None = None,</span>
<span class="gi">+    ) -&gt; list[str]:</span>
<span class="gi">+        if &#39;end-at&#39; in self.options:</span>
<span class="gi">+            end = self.options.get(&#39;end-at&#39;)</span>
<span class="gi">+            inclusive = True</span>
<span class="gi">+        elif &#39;end-before&#39; in self.options:</span>
<span class="gi">+            end = self.options.get(&#39;end-before&#39;)</span>
<span class="gi">+            inclusive = False</span>
<span class="gi">+        else:</span>
<span class="gi">+            end = None</span>
<span class="gi">+</span>
<span class="gi">+        if end:</span>
<span class="gi">+            for lineno, line in enumerate(lines):</span>
<span class="gi">+                if end in line:</span>
<span class="gi">+                    if inclusive:</span>
<span class="gi">+                        return lines[:lineno + 1]</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        if lineno == 0:</span>
<span class="gi">+                            pass  # end-before ignores first line</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            return lines[:lineno]</span>
<span class="gi">+            if inclusive is True:</span>
<span class="gi">+                raise ValueError(&#39;end-at pattern not found: %s&#39; % end)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ValueError(&#39;end-before pattern not found: %s&#39; % end)</span>
<span class="gi">+</span>
<span class="gi">+        return lines</span>
<span class="gi">+</span>
<span class="gi">+    def prepend_filter(</span>
<span class="gi">+        self, lines: list[str], location: tuple[str, int] | None = None,</span>
<span class="gi">+    ) -&gt; list[str]:</span>
<span class="gi">+        prepend = self.options.get(&#39;prepend&#39;)</span>
<span class="gi">+        if prepend:</span>
<span class="gi">+            lines.insert(0, prepend + &#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        return lines</span>
<span class="gi">+</span>
<span class="gi">+    def append_filter(</span>
<span class="gi">+        self, lines: list[str], location: tuple[str, int] | None = None,</span>
<span class="gi">+    ) -&gt; list[str]:</span>
<span class="gi">+        append = self.options.get(&#39;append&#39;)</span>
<span class="gi">+        if append:</span>
<span class="gi">+            lines.append(append + &#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        return lines</span>
<span class="gi">+</span>
<span class="gi">+    def dedent_filter(</span>
<span class="gi">+        self, lines: list[str], location: tuple[str, int] | None = None,</span>
<span class="gi">+    ) -&gt; list[str]:</span>
<span class="gi">+        if &#39;dedent&#39; in self.options:</span>
<span class="gi">+            return dedent_lines(lines, self.options.get(&#39;dedent&#39;), location=location)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return lines</span>
<span class="gi">+</span>

<span class="w"> </span>class LiteralInclude(SphinxDirective):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -70,20 +385,95 @@ class LiteralInclude(SphinxDirective):</span>
<span class="w"> </span>    not found, and does not raise errors.  Also has several options for
<span class="w"> </span>    selecting what to include.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    has_content = False
<span class="w"> </span>    required_arguments = 1
<span class="w"> </span>    optional_arguments = 0
<span class="w"> </span>    final_argument_whitespace = True
<span class="gd">-    option_spec: ClassVar[OptionSpec] = {&#39;dedent&#39;: optional_int, &#39;linenos&#39;:</span>
<span class="gd">-        directives.flag, &#39;lineno-start&#39;: int, &#39;lineno-match&#39;: directives.</span>
<span class="gd">-        flag, &#39;tab-width&#39;: int, &#39;language&#39;: directives.unchanged_required,</span>
<span class="gd">-        &#39;force&#39;: directives.flag, &#39;encoding&#39;: directives.encoding,</span>
<span class="gd">-        &#39;pyobject&#39;: directives.unchanged_required, &#39;lines&#39;: directives.</span>
<span class="gd">-        unchanged_required, &#39;start-after&#39;: directives.unchanged_required,</span>
<span class="gd">-        &#39;end-before&#39;: directives.unchanged_required, &#39;start-at&#39;: directives</span>
<span class="gd">-        .unchanged_required, &#39;end-at&#39;: directives.unchanged_required,</span>
<span class="gd">-        &#39;prepend&#39;: directives.unchanged_required, &#39;append&#39;: directives.</span>
<span class="gd">-        unchanged_required, &#39;emphasize-lines&#39;: directives.</span>
<span class="gd">-        unchanged_required, &#39;caption&#39;: directives.unchanged, &#39;class&#39;:</span>
<span class="gd">-        directives.class_option, &#39;name&#39;: directives.unchanged, &#39;diff&#39;:</span>
<span class="gd">-        directives.unchanged_required}</span>
<span class="gi">+    option_spec: ClassVar[OptionSpec] = {</span>
<span class="gi">+        &#39;dedent&#39;: optional_int,</span>
<span class="gi">+        &#39;linenos&#39;: directives.flag,</span>
<span class="gi">+        &#39;lineno-start&#39;: int,</span>
<span class="gi">+        &#39;lineno-match&#39;: directives.flag,</span>
<span class="gi">+        &#39;tab-width&#39;: int,</span>
<span class="gi">+        &#39;language&#39;: directives.unchanged_required,</span>
<span class="gi">+        &#39;force&#39;: directives.flag,</span>
<span class="gi">+        &#39;encoding&#39;: directives.encoding,</span>
<span class="gi">+        &#39;pyobject&#39;: directives.unchanged_required,</span>
<span class="gi">+        &#39;lines&#39;: directives.unchanged_required,</span>
<span class="gi">+        &#39;start-after&#39;: directives.unchanged_required,</span>
<span class="gi">+        &#39;end-before&#39;: directives.unchanged_required,</span>
<span class="gi">+        &#39;start-at&#39;: directives.unchanged_required,</span>
<span class="gi">+        &#39;end-at&#39;: directives.unchanged_required,</span>
<span class="gi">+        &#39;prepend&#39;: directives.unchanged_required,</span>
<span class="gi">+        &#39;append&#39;: directives.unchanged_required,</span>
<span class="gi">+        &#39;emphasize-lines&#39;: directives.unchanged_required,</span>
<span class="gi">+        &#39;caption&#39;: directives.unchanged,</span>
<span class="gi">+        &#39;class&#39;: directives.class_option,</span>
<span class="gi">+        &#39;name&#39;: directives.unchanged,</span>
<span class="gi">+        &#39;diff&#39;: directives.unchanged_required,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        document = self.state.document</span>
<span class="gi">+        if not document.settings.file_insertion_enabled:</span>
<span class="gi">+            return [document.reporter.warning(&#39;File insertion disabled&#39;,</span>
<span class="gi">+                                              line=self.lineno)]</span>
<span class="gi">+        # convert options[&#39;diff&#39;] to absolute path</span>
<span class="gi">+        if &#39;diff&#39; in self.options:</span>
<span class="gi">+            _, path = self.env.relfn2path(self.options[&#39;diff&#39;])</span>
<span class="gi">+            self.options[&#39;diff&#39;] = path</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            location = self.state_machine.get_source_and_line(self.lineno)</span>
<span class="gi">+            rel_filename, filename = self.env.relfn2path(self.arguments[0])</span>
<span class="gi">+            self.env.note_dependency(rel_filename)</span>
<span class="gi">+</span>
<span class="gi">+            reader = LiteralIncludeReader(filename, self.options, self.config)</span>
<span class="gi">+            text, lines = reader.read(location=location)</span>
<span class="gi">+</span>
<span class="gi">+            retnode: Element = nodes.literal_block(text, text, source=filename)</span>
<span class="gi">+            retnode[&#39;force&#39;] = &#39;force&#39; in self.options</span>
<span class="gi">+            self.set_source_info(retnode)</span>
<span class="gi">+            if self.options.get(&#39;diff&#39;):  # if diff is set, set udiff</span>
<span class="gi">+                retnode[&#39;language&#39;] = &#39;udiff&#39;</span>
<span class="gi">+            elif &#39;language&#39; in self.options:</span>
<span class="gi">+                retnode[&#39;language&#39;] = self.options[&#39;language&#39;]</span>
<span class="gi">+            if (&#39;linenos&#39; in self.options or &#39;lineno-start&#39; in self.options or</span>
<span class="gi">+                    &#39;lineno-match&#39; in self.options):</span>
<span class="gi">+                retnode[&#39;linenos&#39;] = True</span>
<span class="gi">+            retnode[&#39;classes&#39;] += self.options.get(&#39;class&#39;, [])</span>
<span class="gi">+            extra_args = retnode[&#39;highlight_args&#39;] = {}</span>
<span class="gi">+            if &#39;emphasize-lines&#39; in self.options:</span>
<span class="gi">+                hl_lines = parselinenos(self.options[&#39;emphasize-lines&#39;], lines)</span>
<span class="gi">+                if any(i &gt;= lines for i in hl_lines):</span>
<span class="gi">+                    logger.warning(__(&#39;line number spec is out of range(1-%d): %r&#39;),</span>
<span class="gi">+                                   lines, self.options[&#39;emphasize-lines&#39;],</span>
<span class="gi">+                                   location=location)</span>
<span class="gi">+                extra_args[&#39;hl_lines&#39;] = [x + 1 for x in hl_lines if x &lt; lines]</span>
<span class="gi">+            extra_args[&#39;linenostart&#39;] = reader.lineno_start</span>
<span class="gi">+</span>
<span class="gi">+            if &#39;caption&#39; in self.options:</span>
<span class="gi">+                caption = self.options[&#39;caption&#39;] or self.arguments[0]</span>
<span class="gi">+                retnode = container_wrapper(self, retnode, caption)</span>
<span class="gi">+</span>
<span class="gi">+            # retnode will be note_implicit_target that is linked from caption and numref.</span>
<span class="gi">+            # when options[&#39;name&#39;] is provided, it should be primary ID.</span>
<span class="gi">+            self.add_name(retnode)</span>
<span class="gi">+</span>
<span class="gi">+            return [retnode]</span>
<span class="gi">+        except Exception as exc:</span>
<span class="gi">+            return [document.reporter.warning(exc, line=self.lineno)]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    directives.register_directive(&#39;highlight&#39;, Highlight)</span>
<span class="gi">+    directives.register_directive(&#39;code-block&#39;, CodeBlock)</span>
<span class="gi">+    directives.register_directive(&#39;sourcecode&#39;, CodeBlock)</span>
<span class="gi">+    directives.register_directive(&#39;literalinclude&#39;, LiteralInclude)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/directives/other.py b/sphinx/directives/other.py</span>
<span class="gh">index 1a6198deb..18fdff194 100644</span>
<span class="gd">--- a/sphinx/directives/other.py</span>
<span class="gi">+++ b/sphinx/directives/other.py</span>
<span class="gu">@@ -1,14 +1,17 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from os.path import abspath, relpath
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import TYPE_CHECKING, Any, ClassVar, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.parsers.rst import directives
<span class="w"> </span>from docutils.parsers.rst.directives.admonitions import BaseAdmonition
<span class="w"> </span>from docutils.parsers.rst.directives.misc import Class
<span class="w"> </span>from docutils.parsers.rst.directives.misc import Include as BaseInclude
<span class="w"> </span>from docutils.statemachine import StateMachine
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.domains.std import StandardDomain
<span class="w"> </span>from sphinx.locale import _, __
<span class="gu">@@ -16,35 +19,160 @@ from sphinx.util import docname_join, logging, url_re</span>
<span class="w"> </span>from sphinx.util.docutils import SphinxDirective
<span class="w"> </span>from sphinx.util.matching import Matcher, patfilter
<span class="w"> </span>from sphinx.util.nodes import explicit_title_re
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Sequence
<span class="gi">+</span>
<span class="w"> </span>    from docutils.nodes import Element, Node
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata, OptionSpec
<span class="gd">-glob_re = re.compile(&#39;.*[*?\\[].*&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+glob_re = re.compile(r&#39;.*[*?\[].*&#39;)</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="gi">+def int_or_nothing(argument: str) -&gt; int:</span>
<span class="gi">+    if not argument:</span>
<span class="gi">+        return 999</span>
<span class="gi">+    return int(argument)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class TocTree(SphinxDirective):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Directive to notify Sphinx about the hierarchical structure of the docs,
<span class="w"> </span>    and to include a table-of-contents like tree in the current document.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    has_content = True
<span class="w"> </span>    required_arguments = 0
<span class="w"> </span>    optional_arguments = 0
<span class="w"> </span>    final_argument_whitespace = False
<span class="gd">-    option_spec = {&#39;maxdepth&#39;: int, &#39;name&#39;: directives.unchanged, &#39;class&#39;:</span>
<span class="gd">-        directives.class_option, &#39;caption&#39;: directives.unchanged_required,</span>
<span class="gd">-        &#39;glob&#39;: directives.flag, &#39;hidden&#39;: directives.flag, &#39;includehidden&#39;:</span>
<span class="gd">-        directives.flag, &#39;numbered&#39;: int_or_nothing, &#39;titlesonly&#39;:</span>
<span class="gd">-        directives.flag, &#39;reversed&#39;: directives.flag}</span>
<span class="gi">+    option_spec = {</span>
<span class="gi">+        &#39;maxdepth&#39;: int,</span>
<span class="gi">+        &#39;name&#39;: directives.unchanged,</span>
<span class="gi">+        &#39;class&#39;: directives.class_option,</span>
<span class="gi">+        &#39;caption&#39;: directives.unchanged_required,</span>
<span class="gi">+        &#39;glob&#39;: directives.flag,</span>
<span class="gi">+        &#39;hidden&#39;: directives.flag,</span>
<span class="gi">+        &#39;includehidden&#39;: directives.flag,</span>
<span class="gi">+        &#39;numbered&#39;: int_or_nothing,</span>
<span class="gi">+        &#39;titlesonly&#39;: directives.flag,</span>
<span class="gi">+        &#39;reversed&#39;: directives.flag,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        subnode = addnodes.toctree()</span>
<span class="gi">+        subnode[&#39;parent&#39;] = self.env.docname</span>
<span class="gi">+</span>
<span class="gi">+        # (title, ref) pairs, where ref may be a document, or an external link,</span>
<span class="gi">+        # and title may be None if the document&#39;s title is to be used</span>
<span class="gi">+        subnode[&#39;entries&#39;] = []</span>
<span class="gi">+        subnode[&#39;includefiles&#39;] = []</span>
<span class="gi">+        subnode[&#39;maxdepth&#39;] = self.options.get(&#39;maxdepth&#39;, -1)</span>
<span class="gi">+        subnode[&#39;caption&#39;] = self.options.get(&#39;caption&#39;)</span>
<span class="gi">+        subnode[&#39;glob&#39;] = &#39;glob&#39; in self.options</span>
<span class="gi">+        subnode[&#39;hidden&#39;] = &#39;hidden&#39; in self.options</span>
<span class="gi">+        subnode[&#39;includehidden&#39;] = &#39;includehidden&#39; in self.options</span>
<span class="gi">+        subnode[&#39;numbered&#39;] = self.options.get(&#39;numbered&#39;, 0)</span>
<span class="gi">+        subnode[&#39;titlesonly&#39;] = &#39;titlesonly&#39; in self.options</span>
<span class="gi">+        self.set_source_info(subnode)</span>
<span class="gi">+        self.parse_content(subnode)</span>
<span class="gi">+</span>
<span class="gi">+        wrappernode = nodes.compound(</span>
<span class="gi">+            classes=[&#39;toctree-wrapper&#39;, *self.options.get(&#39;class&#39;, ())],</span>
<span class="gi">+        )</span>
<span class="gi">+        wrappernode.append(subnode)</span>
<span class="gi">+        self.add_name(wrappernode)</span>
<span class="gi">+        return [wrappernode]</span>

<span class="gd">-    def parse_content(self, toctree: addnodes.toctree) -&gt;None:</span>
<span class="gi">+    def parse_content(self, toctree: addnodes.toctree) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Populate ``toctree[&#39;entries&#39;]`` and ``toctree[&#39;includefiles&#39;]`` from content.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        generated_docnames = frozenset(StandardDomain._virtual_doc_names)</span>
<span class="gi">+        suffixes = self.config.source_suffix</span>
<span class="gi">+        current_docname = self.env.docname</span>
<span class="gi">+        glob = toctree[&#39;glob&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        # glob target documents</span>
<span class="gi">+        all_docnames = self.env.found_docs.copy() | generated_docnames</span>
<span class="gi">+        all_docnames.remove(current_docname)  # remove current document</span>
<span class="gi">+        frozen_all_docnames = frozenset(all_docnames)</span>
<span class="gi">+</span>
<span class="gi">+        excluded = Matcher(self.config.exclude_patterns)</span>
<span class="gi">+        for entry in self.content:</span>
<span class="gi">+            if not entry:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # look for explicit titles (&quot;Some Title &lt;document&gt;&quot;)</span>
<span class="gi">+            explicit = explicit_title_re.match(entry)</span>
<span class="gi">+            url_match = url_re.match(entry) is not None</span>
<span class="gi">+            if glob and glob_re.match(entry) and not explicit and not url_match:</span>
<span class="gi">+                pat_name = docname_join(current_docname, entry)</span>
<span class="gi">+                doc_names = sorted(</span>
<span class="gi">+                    docname for docname in patfilter(all_docnames, pat_name)</span>
<span class="gi">+                    # don&#39;t include generated documents in globs</span>
<span class="gi">+                    if docname not in generated_docnames</span>
<span class="gi">+                )</span>
<span class="gi">+                if not doc_names:</span>
<span class="gi">+                    logger.warning(</span>
<span class="gi">+                        __(&quot;toctree glob pattern %r didn&#39;t match any documents&quot;),</span>
<span class="gi">+                        entry, location=toctree)</span>
<span class="gi">+</span>
<span class="gi">+                for docname in doc_names:</span>
<span class="gi">+                    all_docnames.remove(docname)  # don&#39;t include it again</span>
<span class="gi">+                    toctree[&#39;entries&#39;].append((None, docname))</span>
<span class="gi">+                    toctree[&#39;includefiles&#39;].append(docname)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if explicit:</span>
<span class="gi">+                ref = explicit.group(2)</span>
<span class="gi">+                title = explicit.group(1)</span>
<span class="gi">+                docname = ref</span>
<span class="gi">+            else:</span>
<span class="gi">+                ref = docname = entry</span>
<span class="gi">+                title = None</span>
<span class="gi">+</span>
<span class="gi">+            # remove suffixes (backwards compatibility)</span>
<span class="gi">+            for suffix in suffixes:</span>
<span class="gi">+                if docname.endswith(suffix):</span>
<span class="gi">+                    docname = docname.removesuffix(suffix)</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+            # absolutise filenames</span>
<span class="gi">+            docname = docname_join(current_docname, docname)</span>
<span class="gi">+            if url_match or ref == &#39;self&#39;:</span>
<span class="gi">+                toctree[&#39;entries&#39;].append((title, ref))</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if docname not in frozen_all_docnames:</span>
<span class="gi">+                if excluded(str(self.env.doc2path(docname, False))):</span>
<span class="gi">+                    message = __(&#39;toctree contains reference to excluded document %r&#39;)</span>
<span class="gi">+                    subtype = &#39;excluded&#39;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    message = __(&#39;toctree contains reference to nonexisting document %r&#39;)</span>
<span class="gi">+                    subtype = &#39;not_readable&#39;</span>
<span class="gi">+</span>
<span class="gi">+                logger.warning(message, docname, type=&#39;toc&#39;, subtype=subtype,</span>
<span class="gi">+                               location=toctree)</span>
<span class="gi">+                self.env.note_reread()</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if docname in all_docnames:</span>
<span class="gi">+                all_docnames.remove(docname)</span>
<span class="gi">+            else:</span>
<span class="gi">+                logger.warning(__(&#39;duplicated entry found in toctree: %s&#39;), docname,</span>
<span class="gi">+                               location=toctree)</span>
<span class="gi">+</span>
<span class="gi">+            toctree[&#39;entries&#39;].append((title, docname))</span>
<span class="gi">+            toctree[&#39;includefiles&#39;].append(docname)</span>
<span class="gi">+</span>
<span class="gi">+        # entries contains all entries (self references, external links etc.)</span>
<span class="gi">+        if &#39;reversed&#39; in self.options:</span>
<span class="gi">+            toctree[&#39;entries&#39;] = list(reversed(toctree[&#39;entries&#39;]))</span>
<span class="gi">+            toctree[&#39;includefiles&#39;] = list(reversed(toctree[&#39;includefiles&#39;]))</span>


<span class="w"> </span>class Author(SphinxDirective):
<span class="gu">@@ -52,17 +180,41 @@ class Author(SphinxDirective):</span>
<span class="w"> </span>    Directive to give the name of the author of the current document
<span class="w"> </span>    or section. Shown in the output only if the show_authors option is on.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    has_content = False
<span class="w"> </span>    required_arguments = 1
<span class="w"> </span>    optional_arguments = 0
<span class="w"> </span>    final_argument_whitespace = True
<span class="w"> </span>    option_spec: ClassVar[OptionSpec] = {}

<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        if not self.config.show_authors:</span>
<span class="gi">+            return []</span>
<span class="gi">+        para: Element = nodes.paragraph(translatable=False)</span>
<span class="gi">+        emph = nodes.emphasis()</span>
<span class="gi">+        para += emph</span>
<span class="gi">+        if self.name == &#39;sectionauthor&#39;:</span>
<span class="gi">+            text = _(&#39;Section author: &#39;)</span>
<span class="gi">+        elif self.name == &#39;moduleauthor&#39;:</span>
<span class="gi">+            text = _(&#39;Module author: &#39;)</span>
<span class="gi">+        elif self.name == &#39;codeauthor&#39;:</span>
<span class="gi">+            text = _(&#39;Code author: &#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            text = _(&#39;Author: &#39;)</span>
<span class="gi">+        emph += nodes.Text(text)</span>
<span class="gi">+        inodes, messages = self.parse_inline(self.arguments[0])</span>
<span class="gi">+        emph.extend(inodes)</span>

<span class="gd">-class SeeAlso(BaseAdmonition):</span>
<span class="gi">+        ret: list[Node] = [para]</span>
<span class="gi">+        ret += messages</span>
<span class="gi">+        return ret</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class SeeAlso(BaseAdmonition):  # type: ignore[misc]</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    An admonition mentioning things to look at as reference.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    node_class = addnodes.seealso


<span class="gu">@@ -70,59 +222,230 @@ class TabularColumns(SphinxDirective):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Directive to give an explicit tabulary column definition to LaTeX.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    has_content = False
<span class="w"> </span>    required_arguments = 1
<span class="w"> </span>    optional_arguments = 0
<span class="w"> </span>    final_argument_whitespace = True
<span class="w"> </span>    option_spec: ClassVar[OptionSpec] = {}

<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        node = addnodes.tabular_col_spec()</span>
<span class="gi">+        node[&#39;spec&#39;] = self.arguments[0]</span>
<span class="gi">+        self.set_source_info(node)</span>
<span class="gi">+        return [node]</span>
<span class="gi">+</span>

<span class="w"> </span>class Centered(SphinxDirective):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Directive to create a centered line of bold text.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    has_content = False
<span class="w"> </span>    required_arguments = 1
<span class="w"> </span>    optional_arguments = 0
<span class="w"> </span>    final_argument_whitespace = True
<span class="w"> </span>    option_spec: ClassVar[OptionSpec] = {}

<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        if not self.arguments:</span>
<span class="gi">+            return []</span>
<span class="gi">+        subnode: Element = addnodes.centered()</span>
<span class="gi">+        inodes, messages = self.parse_inline(self.arguments[0])</span>
<span class="gi">+        subnode.extend(inodes)</span>
<span class="gi">+</span>
<span class="gi">+        ret: list[Node] = [subnode]</span>
<span class="gi">+        ret += messages</span>
<span class="gi">+        return ret</span>
<span class="gi">+</span>

<span class="w"> </span>class Acks(SphinxDirective):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Directive for a list of names.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    has_content = True
<span class="w"> </span>    required_arguments = 0
<span class="w"> </span>    optional_arguments = 0
<span class="w"> </span>    final_argument_whitespace = False
<span class="w"> </span>    option_spec: ClassVar[OptionSpec] = {}

<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        children = self.parse_content_to_nodes()</span>
<span class="gi">+        if len(children) != 1 or not isinstance(children[0], nodes.bullet_list):</span>
<span class="gi">+            logger.warning(__(&#39;.. acks content is not a list&#39;),</span>
<span class="gi">+                           location=(self.env.docname, self.lineno))</span>
<span class="gi">+            return []</span>
<span class="gi">+        return [addnodes.acks(&#39;&#39;, *children)]</span>
<span class="gi">+</span>

<span class="w"> </span>class HList(SphinxDirective):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Directive for a list that gets compacted horizontally.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    has_content = True
<span class="w"> </span>    required_arguments = 0
<span class="w"> </span>    optional_arguments = 0
<span class="w"> </span>    final_argument_whitespace = False
<span class="gd">-    option_spec: ClassVar[OptionSpec] = {&#39;columns&#39;: int}</span>
<span class="gi">+    option_spec: ClassVar[OptionSpec] = {</span>
<span class="gi">+        &#39;columns&#39;: int,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        ncolumns = self.options.get(&#39;columns&#39;, 2)</span>
<span class="gi">+        children = self.parse_content_to_nodes()</span>
<span class="gi">+        if len(children) != 1 or not isinstance(children[0], nodes.bullet_list):</span>
<span class="gi">+            logger.warning(__(&#39;.. hlist content is not a list&#39;),</span>
<span class="gi">+                           location=(self.env.docname, self.lineno))</span>
<span class="gi">+            return []</span>
<span class="gi">+        fulllist = children[0]</span>
<span class="gi">+        # create a hlist node where the items are distributed</span>
<span class="gi">+        npercol, nmore = divmod(len(fulllist), ncolumns)</span>
<span class="gi">+        index = 0</span>
<span class="gi">+        newnode = addnodes.hlist()</span>
<span class="gi">+        newnode[&#39;ncolumns&#39;] = str(ncolumns)</span>
<span class="gi">+        for column in range(ncolumns):</span>
<span class="gi">+            endindex = index + ((npercol + 1) if column &lt; nmore else npercol)</span>
<span class="gi">+            bullet_list = nodes.bullet_list()</span>
<span class="gi">+            bullet_list += fulllist.children[index:endindex]</span>
<span class="gi">+            newnode += addnodes.hlistcol(&#39;&#39;, bullet_list)</span>
<span class="gi">+            index = endindex</span>
<span class="gi">+        return [newnode]</span>


<span class="w"> </span>class Only(SphinxDirective):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Directive to only include text if the given tag(s) are enabled.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    has_content = True
<span class="w"> </span>    required_arguments = 1
<span class="w"> </span>    optional_arguments = 0
<span class="w"> </span>    final_argument_whitespace = True
<span class="w"> </span>    option_spec: ClassVar[OptionSpec] = {}

<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        node = addnodes.only()</span>
<span class="gi">+        node.document = self.state.document</span>
<span class="gi">+        self.set_source_info(node)</span>
<span class="gi">+        node[&#39;expr&#39;] = self.arguments[0]</span>
<span class="gi">+</span>
<span class="gi">+        # Same as util.nested_parse_with_titles but try to handle nested</span>
<span class="gi">+        # sections which should be raised higher up the doctree.</span>
<span class="gi">+        memo: Any = self.state.memo</span>
<span class="gi">+        surrounding_title_styles = memo.title_styles</span>
<span class="gi">+        surrounding_section_level = memo.section_level</span>
<span class="gi">+        memo.title_styles = []</span>
<span class="gi">+        memo.section_level = 0</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.state.nested_parse(self.content, self.content_offset,</span>
<span class="gi">+                                    node, match_titles=True)</span>
<span class="gi">+            title_styles = memo.title_styles</span>
<span class="gi">+            if (not surrounding_title_styles or</span>
<span class="gi">+                    not title_styles or</span>
<span class="gi">+                    title_styles[0] not in surrounding_title_styles or</span>
<span class="gi">+                    not self.state.parent):</span>
<span class="gi">+                # No nested sections so no special handling needed.</span>
<span class="gi">+                return [node]</span>
<span class="gi">+            # Calculate the depths of the current and nested sections.</span>
<span class="gi">+            current_depth = 0</span>
<span class="gi">+            parent = self.state.parent</span>
<span class="gi">+            while parent:</span>
<span class="gi">+                current_depth += 1</span>
<span class="gi">+                parent = parent.parent</span>
<span class="gi">+            current_depth -= 2</span>
<span class="gi">+            title_style = title_styles[0]</span>
<span class="gi">+            nested_depth = len(surrounding_title_styles)</span>
<span class="gi">+            if title_style in surrounding_title_styles:</span>
<span class="gi">+                nested_depth = surrounding_title_styles.index(title_style)</span>
<span class="gi">+            # Use these depths to determine where the nested sections should</span>
<span class="gi">+            # be placed in the doctree.</span>
<span class="gi">+            n_sects_to_raise = current_depth - nested_depth + 1</span>
<span class="gi">+            parent = cast(nodes.Element, self.state.parent)</span>
<span class="gi">+            for _i in range(n_sects_to_raise):</span>
<span class="gi">+                if parent.parent:</span>
<span class="gi">+                    parent = parent.parent</span>
<span class="gi">+            parent.append(node)</span>
<span class="gi">+            return []</span>
<span class="gi">+        finally:</span>
<span class="gi">+            memo.title_styles = surrounding_title_styles</span>
<span class="gi">+            memo.section_level = surrounding_section_level</span>
<span class="gi">+</span>

<span class="w"> </span>class Include(BaseInclude, SphinxDirective):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Like the standard &quot;Include&quot; directive, but interprets absolute paths
<span class="w"> </span>    &quot;correctly&quot;, i.e. relative to source directory.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; Sequence[Node]:</span>
<span class="gi">+</span>
<span class="gi">+        # To properly emit &quot;include-read&quot; events from included RST text,</span>
<span class="gi">+        # we must patch the ``StateMachine.insert_input()`` method.</span>
<span class="gi">+        # In the future, docutils will hopefully offer a way for Sphinx</span>
<span class="gi">+        # to provide the RST parser to use</span>
<span class="gi">+        # when parsing RST text that comes in via Include directive.</span>
<span class="gi">+        def _insert_input(include_lines: list[str], source: str) -&gt; None:</span>
<span class="gi">+            # First, we need to combine the lines back into text so that</span>
<span class="gi">+            # we can send it with the include-read event.</span>
<span class="gi">+            # In docutils 0.18 and later, there are two lines at the end</span>
<span class="gi">+            # that act as markers.</span>
<span class="gi">+            # We must preserve them and leave them out of the include-read event:</span>
<span class="gi">+            text = &quot;\n&quot;.join(include_lines[:-2])</span>
<span class="gi">+</span>
<span class="gi">+            path = Path(relpath(abspath(source), start=self.env.srcdir))</span>
<span class="gi">+            docname = self.env.docname</span>
<span class="gi">+</span>
<span class="gi">+            # Emit the &quot;include-read&quot; event</span>
<span class="gi">+            arg = [text]</span>
<span class="gi">+            self.env.app.events.emit(&#39;include-read&#39;, path, docname, arg)</span>
<span class="gi">+            text = arg[0]</span>
<span class="gi">+</span>
<span class="gi">+            # Split back into lines and reattach the two marker lines</span>
<span class="gi">+            include_lines = text.splitlines() + include_lines[-2:]</span>
<span class="gi">+</span>
<span class="gi">+            # Call the parent implementation.</span>
<span class="gi">+            # Note that this snake does not eat its tail because we patch</span>
<span class="gi">+            # the *Instance* method and this call is to the *Class* method.</span>
<span class="gi">+            return StateMachine.insert_input(self.state_machine, include_lines, source)</span>
<span class="gi">+</span>
<span class="gi">+        # Only enable this patch if there are listeners for &#39;include-read&#39;.</span>
<span class="gi">+        if self.env.app.events.listeners.get(&#39;include-read&#39;):</span>
<span class="gi">+            # See https://github.com/python/mypy/issues/2427 for details on the mypy issue</span>
<span class="gi">+            self.state_machine.insert_input = _insert_input</span>
<span class="gi">+</span>
<span class="gi">+        if self.arguments[0].startswith(&#39;&lt;&#39;) and \</span>
<span class="gi">+           self.arguments[0].endswith(&#39;&gt;&#39;):</span>
<span class="gi">+            # docutils &quot;standard&quot; includes, do not do path processing</span>
<span class="gi">+            return super().run()</span>
<span class="gi">+        rel_filename, filename = self.env.relfn2path(self.arguments[0])</span>
<span class="gi">+        self.arguments[0] = filename</span>
<span class="gi">+        self.env.note_included(filename)</span>
<span class="gi">+        return super().run()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    directives.register_directive(&#39;toctree&#39;, TocTree)</span>
<span class="gi">+    directives.register_directive(&#39;sectionauthor&#39;, Author)</span>
<span class="gi">+    directives.register_directive(&#39;moduleauthor&#39;, Author)</span>
<span class="gi">+    directives.register_directive(&#39;codeauthor&#39;, Author)</span>
<span class="gi">+    directives.register_directive(&#39;seealso&#39;, SeeAlso)</span>
<span class="gi">+    directives.register_directive(&#39;tabularcolumns&#39;, TabularColumns)</span>
<span class="gi">+    directives.register_directive(&#39;centered&#39;, Centered)</span>
<span class="gi">+    directives.register_directive(&#39;acks&#39;, Acks)</span>
<span class="gi">+    directives.register_directive(&#39;hlist&#39;, HList)</span>
<span class="gi">+    directives.register_directive(&#39;only&#39;, Only)</span>
<span class="gi">+    directives.register_directive(&#39;include&#39;, Include)</span>
<span class="gi">+</span>
<span class="gi">+    # register the standard rst class directive under a different name</span>
<span class="gi">+    # only for backwards compatibility now</span>
<span class="gi">+    directives.register_directive(&#39;cssclass&#39;, Class)</span>
<span class="gi">+    # new standard name when default-domain with &quot;class&quot; is in effect</span>
<span class="gi">+    directives.register_directive(&#39;rst-class&#39;, Class)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/directives/patches.py b/sphinx/directives/patches.py</span>
<span class="gh">index 8dde54aa7..55716ba89 100644</span>
<span class="gd">--- a/sphinx/directives/patches.py</span>
<span class="gi">+++ b/sphinx/directives/patches.py</span>
<span class="gu">@@ -1,13 +1,16 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING, ClassVar, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.nodes import Node, make_id
<span class="w"> </span>from docutils.parsers.rst import directives
<span class="w"> </span>from docutils.parsers.rst.directives import images, tables
<span class="w"> </span>from docutils.parsers.rst.directives.misc import Meta
<span class="w"> </span>from docutils.parsers.rst.roles import set_classes
<span class="gi">+</span>
<span class="w"> </span>from sphinx.directives import optional_int
<span class="w"> </span>from sphinx.domains.math import MathDomain
<span class="w"> </span>from sphinx.locale import __
<span class="gu">@@ -15,53 +18,199 @@ from sphinx.util import logging</span>
<span class="w"> </span>from sphinx.util.docutils import SphinxDirective
<span class="w"> </span>from sphinx.util.nodes import set_source_info
<span class="w"> </span>from sphinx.util.osutil import SEP, os_path, relpath
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata, OptionSpec
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="gd">-class Figure(images.Figure):</span>
<span class="gi">+class Figure(images.Figure):  # type: ignore[misc]</span>
<span class="w"> </span>    &quot;&quot;&quot;The figure directive which applies `:name:` option to the figure node
<span class="w"> </span>    instead of the image node.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        name = self.options.pop(&#39;name&#39;, None)</span>
<span class="gi">+        result = super().run()</span>
<span class="gi">+        if len(result) == 2 or isinstance(result[0], nodes.system_message):</span>
<span class="gi">+            return result</span>
<span class="gi">+</span>
<span class="gi">+        assert len(result) == 1</span>
<span class="gi">+        figure_node = cast(nodes.figure, result[0])</span>
<span class="gi">+        if name:</span>
<span class="gi">+            # set ``name`` to figure_node if given</span>
<span class="gi">+            self.options[&#39;name&#39;] = name</span>
<span class="gi">+            self.add_name(figure_node)</span>
<span class="gi">+</span>
<span class="gi">+        # copy lineno from image node</span>
<span class="gi">+        if figure_node.line is None and len(figure_node) == 2:</span>
<span class="gi">+            caption = cast(nodes.caption, figure_node[1])</span>
<span class="gi">+            figure_node.line = caption.line</span>

<span class="gd">-class CSVTable(tables.CSVTable):</span>
<span class="gi">+        return [figure_node]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class CSVTable(tables.CSVTable):  # type: ignore[misc]</span>
<span class="w"> </span>    &quot;&quot;&quot;The csv-table directive which searches a CSV file from Sphinx project&#39;s source
<span class="w"> </span>    directory when an absolute path is given via :file: option.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        if &#39;file&#39; in self.options and self.options[&#39;file&#39;].startswith((SEP, os.sep)):</span>
<span class="gi">+            env = self.state.document.settings.env</span>
<span class="gi">+            filename = self.options[&#39;file&#39;]</span>
<span class="gi">+            if path.exists(filename):</span>
<span class="gi">+                logger.warning(__(&#39;&quot;:file:&quot; option for csv-table directive now recognizes &#39;</span>
<span class="gi">+                                  &#39;an absolute path as a relative path from source directory. &#39;</span>
<span class="gi">+                                  &#39;Please update your document.&#39;),</span>
<span class="gi">+                               location=(env.docname, self.lineno))</span>
<span class="gi">+            else:</span>
<span class="gi">+                abspath = path.join(env.srcdir, os_path(self.options[&#39;file&#39;][1:]))</span>
<span class="gi">+                docdir = path.dirname(env.doc2path(env.docname))</span>
<span class="gi">+                self.options[&#39;file&#39;] = relpath(abspath, docdir)</span>
<span class="gi">+</span>
<span class="gi">+        return super().run()</span>
<span class="gi">+</span>

<span class="w"> </span>class Code(SphinxDirective):
<span class="w"> </span>    &quot;&quot;&quot;Parse and mark up content of a code block.

<span class="w"> </span>    This is compatible with docutils&#39; :rst:dir:`code` directive.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    optional_arguments = 1
<span class="gd">-    option_spec: ClassVar[OptionSpec] = {&#39;class&#39;: directives.class_option,</span>
<span class="gd">-        &#39;force&#39;: directives.flag, &#39;name&#39;: directives.unchanged,</span>
<span class="gd">-        &#39;number-lines&#39;: optional_int}</span>
<span class="gi">+    option_spec: ClassVar[OptionSpec] = {</span>
<span class="gi">+        &#39;class&#39;: directives.class_option,</span>
<span class="gi">+        &#39;force&#39;: directives.flag,</span>
<span class="gi">+        &#39;name&#39;: directives.unchanged,</span>
<span class="gi">+        &#39;number-lines&#39;: optional_int,</span>
<span class="gi">+    }</span>
<span class="w"> </span>    has_content = True

<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        self.assert_has_content()</span>
<span class="gi">+</span>
<span class="gi">+        set_classes(self.options)</span>
<span class="gi">+        code = &#39;\n&#39;.join(self.content)</span>
<span class="gi">+        node = nodes.literal_block(code, code,</span>
<span class="gi">+                                   classes=self.options.get(&#39;classes&#39;, []),</span>
<span class="gi">+                                   force=&#39;force&#39; in self.options,</span>
<span class="gi">+                                   highlight_args={})</span>
<span class="gi">+        self.add_name(node)</span>
<span class="gi">+        set_source_info(self, node)</span>
<span class="gi">+</span>
<span class="gi">+        if self.arguments:</span>
<span class="gi">+            # highlight language specified</span>
<span class="gi">+            node[&#39;language&#39;] = self.arguments[0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            # no highlight language specified.  Then this directive refers the current</span>
<span class="gi">+            # highlight setting via ``highlight`` directive or ``highlight_language``</span>
<span class="gi">+            # configuration.</span>
<span class="gi">+            node[&#39;language&#39;] = self.env.temp_data.get(&#39;highlight_language&#39;,</span>
<span class="gi">+                                                      self.config.highlight_language)</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;number-lines&#39; in self.options:</span>
<span class="gi">+            node[&#39;linenos&#39;] = True</span>
<span class="gi">+</span>
<span class="gi">+            # if number given, treat as lineno-start.</span>
<span class="gi">+            if self.options[&#39;number-lines&#39;]:</span>
<span class="gi">+                node[&#39;highlight_args&#39;][&#39;linenostart&#39;] = self.options[&#39;number-lines&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        return [node]</span>
<span class="gi">+</span>

<span class="w"> </span>class MathDirective(SphinxDirective):
<span class="w"> </span>    has_content = True
<span class="w"> </span>    required_arguments = 0
<span class="w"> </span>    optional_arguments = 1
<span class="w"> </span>    final_argument_whitespace = True
<span class="gd">-    option_spec: ClassVar[OptionSpec] = {&#39;label&#39;: directives.unchanged,</span>
<span class="gd">-        &#39;name&#39;: directives.unchanged, &#39;class&#39;: directives.class_option,</span>
<span class="gd">-        &#39;nowrap&#39;: directives.flag}</span>
<span class="gi">+    option_spec: ClassVar[OptionSpec] = {</span>
<span class="gi">+        &#39;label&#39;: directives.unchanged,</span>
<span class="gi">+        &#39;name&#39;: directives.unchanged,</span>
<span class="gi">+        &#39;class&#39;: directives.class_option,</span>
<span class="gi">+        &#39;nowrap&#39;: directives.flag,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        latex = &#39;\n&#39;.join(self.content)</span>
<span class="gi">+        if self.arguments and self.arguments[0]:</span>
<span class="gi">+            latex = self.arguments[0] + &#39;\n\n&#39; + latex</span>
<span class="gi">+        label = self.options.get(&#39;label&#39;, self.options.get(&#39;name&#39;))</span>
<span class="gi">+        node = nodes.math_block(latex, latex,</span>
<span class="gi">+                                classes=self.options.get(&#39;class&#39;, []),</span>
<span class="gi">+                                docname=self.env.docname,</span>
<span class="gi">+                                number=None,</span>
<span class="gi">+                                label=label,</span>
<span class="gi">+                                nowrap=&#39;nowrap&#39; in self.options)</span>
<span class="gi">+        self.add_name(node)</span>
<span class="gi">+        self.set_source_info(node)</span>
<span class="gi">+</span>
<span class="gi">+        ret: list[Node] = [node]</span>
<span class="gi">+        self.add_target(ret)</span>
<span class="gi">+        return ret</span>
<span class="gi">+</span>
<span class="gi">+    def add_target(self, ret: list[Node]) -&gt; None:</span>
<span class="gi">+        node = cast(nodes.math_block, ret[0])</span>
<span class="gi">+</span>
<span class="gi">+        # assign label automatically if math_number_all enabled</span>
<span class="gi">+        if node[&#39;label&#39;] == &#39;&#39; or (self.config.math_number_all and not node[&#39;label&#39;]):</span>
<span class="gi">+            seq = self.env.new_serialno(&#39;sphinx.ext.math#equations&#39;)</span>
<span class="gi">+            node[&#39;label&#39;] = &quot;%s:%d&quot; % (self.env.docname, seq)</span>
<span class="gi">+</span>
<span class="gi">+        # no targets and numbers are needed</span>
<span class="gi">+        if not node[&#39;label&#39;]:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # register label to domain</span>
<span class="gi">+        domain = cast(MathDomain, self.env.get_domain(&#39;math&#39;))</span>
<span class="gi">+        domain.note_equation(self.env.docname, node[&#39;label&#39;], location=node)</span>
<span class="gi">+        node[&#39;number&#39;] = domain.get_equation_number_for(node[&#39;label&#39;])</span>
<span class="gi">+</span>
<span class="gi">+        # add target node</span>
<span class="gi">+        node_id = make_id(&#39;equation-%s&#39; % node[&#39;label&#39;])</span>
<span class="gi">+        target = nodes.target(&#39;&#39;, &#39;&#39;, ids=[node_id])</span>
<span class="gi">+        self.state.document.note_explicit_target(target)</span>
<span class="gi">+        ret.insert(0, target)</span>


<span class="w"> </span>class Rubric(SphinxDirective):
<span class="w"> </span>    &quot;&quot;&quot;A patch of the docutils&#39; :rst:dir:`rubric` directive,
<span class="w"> </span>    which adds a level option to specify the heading level of the rubric.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    required_arguments = 1
<span class="w"> </span>    optional_arguments = 0
<span class="w"> </span>    final_argument_whitespace = True
<span class="gd">-    option_spec = {&#39;class&#39;: directives.class_option, &#39;name&#39;: directives.</span>
<span class="gd">-        unchanged, &#39;heading-level&#39;: lambda c: directives.choice(c, (&#39;1&#39;,</span>
<span class="gd">-        &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;))}</span>
<span class="gi">+    option_spec = {</span>
<span class="gi">+        &#39;class&#39;: directives.class_option,</span>
<span class="gi">+        &#39;name&#39;: directives.unchanged,</span>
<span class="gi">+        &#39;heading-level&#39;: lambda c: directives.choice(c, (&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;)),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; list[nodes.rubric | nodes.system_message]:</span>
<span class="gi">+        set_classes(self.options)</span>
<span class="gi">+        rubric_text = self.arguments[0]</span>
<span class="gi">+        textnodes, messages = self.parse_inline(rubric_text, lineno=self.lineno)</span>
<span class="gi">+        if &#39;heading-level&#39; in self.options:</span>
<span class="gi">+            self.options[&#39;heading-level&#39;] = int(self.options[&#39;heading-level&#39;])</span>
<span class="gi">+        rubric = nodes.rubric(rubric_text, &#39;&#39;, *textnodes, **self.options)</span>
<span class="gi">+        self.add_name(rubric)</span>
<span class="gi">+        return [rubric, *messages]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    directives.register_directive(&#39;figure&#39;, Figure)</span>
<span class="gi">+    directives.register_directive(&#39;meta&#39;, Meta)</span>
<span class="gi">+    directives.register_directive(&#39;csv-table&#39;, CSVTable)</span>
<span class="gi">+    directives.register_directive(&#39;code&#39;, Code)</span>
<span class="gi">+    directives.register_directive(&#39;math&#39;, MathDirective)</span>
<span class="gi">+    directives.register_directive(&#39;rubric&#39;, Rubric)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/domains/_index.py b/sphinx/domains/_index.py</span>
<span class="gh">index ef50b53cd..1598d2f20 100644</span>
<span class="gd">--- a/sphinx/domains/_index.py</span>
<span class="gi">+++ b/sphinx/domains/_index.py</span>
<span class="gu">@@ -1,10 +1,15 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Domain indices.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from abc import ABC, abstractmethod
<span class="w"> </span>from typing import TYPE_CHECKING, NamedTuple
<span class="gi">+</span>
<span class="w"> </span>from sphinx.errors import SphinxError
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Iterable
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.domains import Domain


<span class="gu">@@ -40,21 +45,22 @@ class Index(ABC):</span>
<span class="w"> </span>       Index pages can be referred by domain name and index name via
<span class="w"> </span>       :rst:role:`ref` role.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name: str
<span class="w"> </span>    localname: str
<span class="w"> </span>    shortname: str | None = None

<span class="gd">-    def __init__(self, domain: Domain) -&gt;None:</span>
<span class="gi">+    def __init__(self, domain: Domain) -&gt; None:</span>
<span class="w"> </span>        if not self.name or self.localname is None:
<span class="gd">-            msg = (</span>
<span class="gd">-                f&#39;Index subclass {self.__class__.__name__} has no valid name or localname&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+            msg = f&#39;Index subclass {self.__class__.__name__} has no valid name or localname&#39;</span>
<span class="w"> </span>            raise SphinxError(msg)
<span class="w"> </span>        self.domain = domain

<span class="w"> </span>    @abstractmethod
<span class="gd">-    def generate(self, docnames: (Iterable[str] | None)=None) -&gt;tuple[list[</span>
<span class="gd">-        tuple[str, list[IndexEntry]]], bool]:</span>
<span class="gi">+    def generate(</span>
<span class="gi">+        self,</span>
<span class="gi">+        docnames: Iterable[str] | None = None,</span>
<span class="gi">+    ) -&gt; tuple[list[tuple[str, list[IndexEntry]]], bool]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get entries for the index.

<span class="w"> </span>        If ``docnames`` is given, restrict to entries referring to these
<span class="gu">@@ -104,4 +110,4 @@ class Index(ABC):</span>
<span class="w"> </span>        Qualifier and description are not rendered for some output formats such
<span class="w"> </span>        as LaTeX.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gh">diff --git a/sphinx/domains/c/_ast.py b/sphinx/domains/c/_ast.py</span>
<span class="gh">index 91f418235..5147a4598 100644</span>
<span class="gd">--- a/sphinx/domains/c/_ast.py</span>
<span class="gi">+++ b/sphinx/domains/c/_ast.py</span>
<span class="gu">@@ -1,98 +1,255 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>import warnings
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Union, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.domains.c._ids import _id_prefix, _max_id
<span class="gd">-from sphinx.util.cfamily import ASTAttributeList, ASTBaseBase, ASTBaseParenExprList, UnsupportedMultiCharacterCharLiteral, verify_description_mode</span>
<span class="gi">+from sphinx.util.cfamily import (</span>
<span class="gi">+    ASTAttributeList,</span>
<span class="gi">+    ASTBaseBase,</span>
<span class="gi">+    ASTBaseParenExprList,</span>
<span class="gi">+    UnsupportedMultiCharacterCharLiteral,</span>
<span class="gi">+    verify_description_mode,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing import TypeAlias
<span class="gi">+</span>
<span class="w"> </span>    from docutils.nodes import Element, Node, TextElement
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.domains.c._symbol import Symbol
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="w"> </span>    from sphinx.util.cfamily import StringifyTransform
<span class="gd">-DeclarationType: TypeAlias = Union[&#39;ASTStruct&#39;, &#39;ASTUnion&#39;, &#39;ASTEnum&#39;,</span>
<span class="gd">-    &#39;ASTEnumerator&#39;, &#39;ASTType&#39;, &#39;ASTTypeWithInit&#39;, &#39;ASTMacro&#39;]</span>
<span class="gi">+</span>
<span class="gi">+DeclarationType: TypeAlias = Union[  # NoQA: UP007</span>
<span class="gi">+    &quot;ASTStruct&quot;, &quot;ASTUnion&quot;, &quot;ASTEnum&quot;, &quot;ASTEnumerator&quot;,</span>
<span class="gi">+    &quot;ASTType&quot;, &quot;ASTTypeWithInit&quot;, &quot;ASTMacro&quot;,</span>
<span class="gi">+]</span>


<span class="w"> </span>class ASTBase(ASTBaseBase):
<span class="gd">-    pass</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>


<span class="gd">-class ASTIdentifier(ASTBaseBase):</span>
<span class="gi">+# Names</span>
<span class="gi">+################################################################################</span>

<span class="gd">-    def __init__(self, name: str) -&gt;None:</span>
<span class="gi">+class ASTIdentifier(ASTBaseBase):</span>
<span class="gi">+    def __init__(self, name: str) -&gt; None:</span>
<span class="w"> </span>        if not isinstance(name, str) or len(name) == 0:
<span class="w"> </span>            raise AssertionError
<span class="w"> </span>        self.name = sys.intern(name)
<span class="w"> </span>        self.is_anonymous = name[0] == &#39;@&#39;

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    # ASTBaseBase already implements this method,</span>
<span class="gi">+    # but specialising it here improves performance</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTIdentifier):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.name == other.name

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def is_anon(self) -&gt; bool:</span>
<span class="gi">+        return self.is_anonymous</span>
<span class="gi">+</span>
<span class="gi">+    # and this is where we finally make a difference between __str__ and the display string</span>
<span class="gi">+</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return self.name

<span class="gi">+    def get_display_string(self) -&gt; str:</span>
<span class="gi">+        return &quot;[anonymous]&quot; if self.is_anonymous else self.name</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str, env: BuildEnvironment,</span>
<span class="gi">+                           prefix: str, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        # note: slightly different signature of describe_signature due to the prefix</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        if self.is_anonymous:</span>
<span class="gi">+            node = addnodes.desc_sig_name(text=&quot;[anonymous]&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            node = addnodes.desc_sig_name(self.name, self.name)</span>
<span class="gi">+        if mode == &#39;markType&#39;:</span>
<span class="gi">+            targetText = prefix + self.name</span>
<span class="gi">+            pnode = addnodes.pending_xref(&#39;&#39;, refdomain=&#39;c&#39;,</span>
<span class="gi">+                                          reftype=&#39;identifier&#39;,</span>
<span class="gi">+                                          reftarget=targetText, modname=None,</span>
<span class="gi">+                                          classname=None)</span>
<span class="gi">+            pnode[&#39;c:parent_key&#39;] = symbol.get_lookup_key()</span>
<span class="gi">+            pnode += node</span>
<span class="gi">+            signode += pnode</span>
<span class="gi">+        elif mode == &#39;lastIsName&#39;:</span>
<span class="gi">+            nameNode = addnodes.desc_name()</span>
<span class="gi">+            nameNode += node</span>
<span class="gi">+            signode += nameNode</span>
<span class="gi">+        elif mode == &#39;noneIsName&#39;:</span>
<span class="gi">+            signode += node</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise Exception(&#39;Unknown description mode: %s&#39; % mode)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def identifier(self) -&gt; str:</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;`ASTIdentifier.identifier` is deprecated, use `ASTIdentifier.name` instead&#39;,</span>
<span class="gi">+            DeprecationWarning, stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+        return self.name</span>

<span class="gd">-class ASTNestedName(ASTBase):</span>

<span class="gd">-    def __init__(self, names: list[ASTIdentifier], rooted: bool) -&gt;None:</span>
<span class="gi">+class ASTNestedName(ASTBase):</span>
<span class="gi">+    def __init__(self, names: list[ASTIdentifier], rooted: bool) -&gt; None:</span>
<span class="w"> </span>        assert len(names) &gt; 0
<span class="w"> </span>        self.names = names
<span class="w"> </span>        self.rooted = rooted

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTNestedName):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.names == other.names and self.rooted == other.rooted

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.names, self.rooted))

<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        return &#39;.&#39;.join(str(n) for n in self.names)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = &#39;.&#39;.join(transform(n) for n in self.names)</span>
<span class="gi">+        if self.rooted:</span>
<span class="gi">+            return &#39;.&#39; + res</span>
<span class="gi">+        else:</span>
<span class="gi">+            return res</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        # just print the name part, with template args, not template params</span>
<span class="gi">+        if mode == &#39;noneIsName&#39;:</span>
<span class="gi">+            if self.rooted:</span>
<span class="gi">+                unreachable = &quot;Can this happen?&quot;</span>
<span class="gi">+                raise AssertionError(unreachable)  # TODO</span>
<span class="gi">+                signode += nodes.Text(&#39;.&#39;)</span>
<span class="gi">+            for i in range(len(self.names)):</span>
<span class="gi">+                if i != 0:</span>
<span class="gi">+                    unreachable = &quot;Can this happen?&quot;</span>
<span class="gi">+                    raise AssertionError(unreachable)  # TODO</span>
<span class="gi">+                    signode += nodes.Text(&#39;.&#39;)</span>
<span class="gi">+                n = self.names[i]</span>
<span class="gi">+                n.describe_signature(signode, mode, env, &#39;&#39;, symbol)</span>
<span class="gi">+        elif mode == &#39;param&#39;:</span>
<span class="gi">+            assert not self.rooted, str(self)</span>
<span class="gi">+            assert len(self.names) == 1</span>
<span class="gi">+            self.names[0].describe_signature(signode, &#39;noneIsName&#39;, env, &#39;&#39;, symbol)</span>
<span class="gi">+        elif mode in (&#39;markType&#39;, &#39;lastIsName&#39;, &#39;markName&#39;):</span>
<span class="gi">+            # Each element should be a pending xref targeting the complete</span>
<span class="gi">+            # prefix.</span>
<span class="gi">+            prefix = &#39;&#39;</span>
<span class="gi">+            first = True</span>
<span class="gi">+            names = self.names[:-1] if mode == &#39;lastIsName&#39; else self.names</span>
<span class="gi">+            # If lastIsName, then wrap all of the prefix in a desc_addname,</span>
<span class="gi">+            # else append directly to signode.</span>
<span class="gi">+            # TODO: also for C?</span>
<span class="gi">+            #  NOTE: Breathe previously relied on the prefix being in the desc_addname node,</span>
<span class="gi">+            #       so it can remove it in inner declarations.</span>
<span class="gi">+            dest = signode</span>
<span class="gi">+            if mode == &#39;lastIsName&#39;:</span>
<span class="gi">+                dest = addnodes.desc_addname()</span>
<span class="gi">+            if self.rooted:</span>
<span class="gi">+                prefix += &#39;.&#39;</span>
<span class="gi">+                if mode == &#39;lastIsName&#39; and len(names) == 0:</span>
<span class="gi">+                    signode += addnodes.desc_sig_punctuation(&#39;.&#39;, &#39;.&#39;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    dest += addnodes.desc_sig_punctuation(&#39;.&#39;, &#39;.&#39;)</span>
<span class="gi">+            for i in range(len(names)):</span>
<span class="gi">+                ident = names[i]</span>
<span class="gi">+                if not first:</span>
<span class="gi">+                    dest += addnodes.desc_sig_punctuation(&#39;.&#39;, &#39;.&#39;)</span>
<span class="gi">+                    prefix += &#39;.&#39;</span>
<span class="gi">+                first = False</span>
<span class="gi">+                txt_ident = str(ident)</span>
<span class="gi">+                if txt_ident != &#39;&#39;:</span>
<span class="gi">+                    ident.describe_signature(dest, &#39;markType&#39;, env, prefix, symbol)</span>
<span class="gi">+                prefix += txt_ident</span>
<span class="gi">+            if mode == &#39;lastIsName&#39;:</span>
<span class="gi">+                if len(self.names) &gt; 1:</span>
<span class="gi">+                    dest += addnodes.desc_sig_punctuation(&#39;.&#39;, &#39;.&#39;)</span>
<span class="gi">+                    signode += dest</span>
<span class="gi">+                self.names[-1].describe_signature(signode, mode, env, &#39;&#39;, symbol)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise Exception(&#39;Unknown description mode: %s&#39; % mode)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+################################################################################</span>
<span class="gi">+# Expressions</span>
<span class="gi">+################################################################################</span>

<span class="w"> </span>class ASTExpression(ASTBase):
<span class="w"> </span>    pass


<span class="gi">+# Primary expressions</span>
<span class="gi">+################################################################################</span>
<span class="gi">+</span>
<span class="w"> </span>class ASTLiteral(ASTExpression):
<span class="w"> </span>    pass


<span class="w"> </span>class ASTBooleanLiteral(ASTLiteral):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, value: bool) -&gt;None:</span>
<span class="gi">+    def __init__(self, value: bool) -&gt; None:</span>
<span class="w"> </span>        self.value = value

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTBooleanLiteral):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.value == other.value

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.value)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        if self.value:</span>
<span class="gi">+            return &#39;true&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;false&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        txt = str(self)</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(txt, txt)</span>

<span class="gd">-class ASTNumberLiteral(ASTLiteral):</span>

<span class="gd">-    def __init__(self, data: str) -&gt;None:</span>
<span class="gi">+class ASTNumberLiteral(ASTLiteral):</span>
<span class="gi">+    def __init__(self, data: str) -&gt; None:</span>
<span class="w"> </span>        self.data = data

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTNumberLiteral):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.data == other.data

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.data)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return self.data</span>

<span class="gd">-class ASTCharLiteral(ASTLiteral):</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        txt = str(self)</span>
<span class="gi">+        signode += addnodes.desc_sig_literal_number(txt, txt)</span>

<span class="gd">-    def __init__(self, prefix: str, data: str) -&gt;None:</span>
<span class="gd">-        self.prefix = prefix</span>
<span class="gi">+</span>
<span class="gi">+class ASTCharLiteral(ASTLiteral):</span>
<span class="gi">+    def __init__(self, prefix: str, data: str) -&gt; None:</span>
<span class="gi">+        self.prefix = prefix  # may be None when no prefix</span>
<span class="w"> </span>        self.data = data
<span class="w"> </span>        decoded = data.encode().decode(&#39;unicode-escape&#39;)
<span class="w"> </span>        if len(decoded) == 1:
<span class="gu">@@ -100,320 +257,626 @@ class ASTCharLiteral(ASTLiteral):</span>
<span class="w"> </span>        else:
<span class="w"> </span>            raise UnsupportedMultiCharacterCharLiteral(decoded)

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTCharLiteral):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return self.prefix == other.prefix and self.value == other.value</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.prefix == other.prefix</span>
<span class="gi">+            and self.value == other.value</span>
<span class="gi">+        )</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.prefix, self.value))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        if self.prefix is None:</span>
<span class="gi">+            return &quot;&#39;&quot; + self.data + &quot;&#39;&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.prefix + &quot;&#39;&quot; + self.data + &quot;&#39;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        txt = str(self)</span>
<span class="gi">+        signode += addnodes.desc_sig_literal_char(txt, txt)</span>

<span class="gd">-class ASTStringLiteral(ASTLiteral):</span>

<span class="gd">-    def __init__(self, data: str) -&gt;None:</span>
<span class="gi">+class ASTStringLiteral(ASTLiteral):</span>
<span class="gi">+    def __init__(self, data: str) -&gt; None:</span>
<span class="w"> </span>        self.data = data

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTStringLiteral):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.data == other.data

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.data)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return self.data</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        txt = str(self)</span>
<span class="gi">+        signode += addnodes.desc_sig_literal_string(txt, txt)</span>

<span class="gd">-class ASTIdExpression(ASTExpression):</span>

<span class="gd">-    def __init__(self, name: ASTNestedName) -&gt;None:</span>
<span class="gi">+class ASTIdExpression(ASTExpression):</span>
<span class="gi">+    def __init__(self, name: ASTNestedName) -&gt; None:</span>
<span class="gi">+        # note: this class is basically to cast a nested name as an expression</span>
<span class="w"> </span>        self.name = name

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTIdExpression):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.name == other.name

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.name)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return transform(self.name)</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        return self.name.get_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        self.name.describe_signature(signode, mode, env, symbol)</span>

<span class="gd">-class ASTParenExpr(ASTExpression):</span>

<span class="gd">-    def __init__(self, expr: ASTExpression) -&gt;None:</span>
<span class="gi">+class ASTParenExpr(ASTExpression):</span>
<span class="gi">+    def __init__(self, expr: ASTExpression) -&gt; None:</span>
<span class="w"> </span>        self.expr = expr

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTParenExpr):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.expr == other.expr

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.expr)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &#39;(&#39; + transform(self.expr) + &#39;)&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        return self.expr.get_id(version)  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;(&#39;, &#39;(&#39;)</span>
<span class="gi">+        self.expr.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;)&#39;, &#39;)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Postfix expressions</span>
<span class="gi">+################################################################################</span>

<span class="w"> </span>class ASTPostfixOp(ASTBase):
<span class="w"> </span>    pass


<span class="w"> </span>class ASTPostfixCallExpr(ASTPostfixOp):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, lst: (ASTParenExprList | ASTBracedInitList)) -&gt;None:</span>
<span class="gi">+    def __init__(self, lst: ASTParenExprList | ASTBracedInitList) -&gt; None:</span>
<span class="w"> </span>        self.lst = lst

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTPostfixCallExpr):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.lst == other.lst

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.lst)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return transform(self.lst)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        self.lst.describe_signature(signode, mode, env, symbol)</span>

<span class="gd">-class ASTPostfixArray(ASTPostfixOp):</span>

<span class="gd">-    def __init__(self, expr: ASTExpression) -&gt;None:</span>
<span class="gi">+class ASTPostfixArray(ASTPostfixOp):</span>
<span class="gi">+    def __init__(self, expr: ASTExpression) -&gt; None:</span>
<span class="w"> </span>        self.expr = expr

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTPostfixArray):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.expr == other.expr

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.expr)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &#39;[&#39; + transform(self.expr) + &#39;]&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;[&#39;, &#39;[&#39;)</span>
<span class="gi">+        self.expr.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;]&#39;, &#39;]&#39;)</span>
<span class="gi">+</span>

<span class="w"> </span>class ASTPostfixInc(ASTPostfixOp):
<span class="gd">-    pass</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &#39;++&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_operator(&#39;++&#39;, &#39;++&#39;)</span>


<span class="w"> </span>class ASTPostfixDec(ASTPostfixOp):
<span class="gd">-    pass</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &#39;--&#39;</span>

<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_operator(&#39;--&#39;, &#39;--&#39;)</span>

<span class="gd">-class ASTPostfixMemberOfPointer(ASTPostfixOp):</span>

<span class="gd">-    def __init__(self, name: ASTNestedName) -&gt;None:</span>
<span class="gi">+class ASTPostfixMemberOfPointer(ASTPostfixOp):</span>
<span class="gi">+    def __init__(self, name: ASTNestedName) -&gt; None:</span>
<span class="w"> </span>        self.name = name

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTPostfixMemberOfPointer):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.name == other.name

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.name)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &#39;-&gt;&#39; + transform(self.name)</span>

<span class="gd">-class ASTPostfixExpr(ASTExpression):</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_operator(&#39;-&gt;&#39;, &#39;-&gt;&#39;)</span>
<span class="gi">+        self.name.describe_signature(signode, &#39;noneIsName&#39;, env, symbol)</span>

<span class="gd">-    def __init__(self, prefix: ASTExpression, postFixes: list[ASTPostfixOp]</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class ASTPostfixExpr(ASTExpression):</span>
<span class="gi">+    def __init__(self, prefix: ASTExpression, postFixes: list[ASTPostfixOp]) -&gt; None:</span>
<span class="w"> </span>        self.prefix = prefix
<span class="w"> </span>        self.postFixes = postFixes

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTPostfixExpr):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.prefix == other.prefix and self.postFixes == other.</span>
<span class="gd">-            postFixes)</span>
<span class="gi">+        return self.prefix == other.prefix and self.postFixes == other.postFixes</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.prefix, self.postFixes))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &#39;&#39;.join([transform(self.prefix), *(transform(p) for p in self.postFixes)])</span>

<span class="gd">-class ASTUnaryOpExpr(ASTExpression):</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        self.prefix.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        for p in self.postFixes:</span>
<span class="gi">+            p.describe_signature(signode, mode, env, symbol)</span>

<span class="gd">-    def __init__(self, op: str, expr: ASTExpression) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+# Unary expressions</span>
<span class="gi">+################################################################################</span>
<span class="gi">+</span>
<span class="gi">+class ASTUnaryOpExpr(ASTExpression):</span>
<span class="gi">+    def __init__(self, op: str, expr: ASTExpression) -&gt; None:</span>
<span class="w"> </span>        self.op = op
<span class="w"> </span>        self.expr = expr

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTUnaryOpExpr):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.op == other.op and self.expr == other.expr

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.op, self.expr))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        if self.op[0] in &#39;cn&#39;:</span>
<span class="gi">+            return self.op + &quot; &quot; + transform(self.expr)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.op + transform(self.expr)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        if self.op[0] in &#39;cn&#39;:</span>
<span class="gi">+            signode += addnodes.desc_sig_keyword(self.op, self.op)</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+        else:</span>
<span class="gi">+            signode += addnodes.desc_sig_operator(self.op, self.op)</span>
<span class="gi">+        self.expr.describe_signature(signode, mode, env, symbol)</span>

<span class="gd">-class ASTSizeofType(ASTExpression):</span>

<span class="gd">-    def __init__(self, typ: ASTType) -&gt;None:</span>
<span class="gi">+class ASTSizeofType(ASTExpression):</span>
<span class="gi">+    def __init__(self, typ: ASTType) -&gt; None:</span>
<span class="w"> </span>        self.typ = typ

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTSizeofType):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.typ == other.typ

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.typ)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &quot;sizeof(&quot; + transform(self.typ) + &quot;)&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(&#39;sizeof&#39;, &#39;sizeof&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;(&#39;, &#39;(&#39;)</span>
<span class="gi">+        self.typ.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;)&#39;, &#39;)&#39;)</span>

<span class="gd">-class ASTSizeofExpr(ASTExpression):</span>

<span class="gd">-    def __init__(self, expr: ASTExpression) -&gt;None:</span>
<span class="gi">+class ASTSizeofExpr(ASTExpression):</span>
<span class="gi">+    def __init__(self, expr: ASTExpression) -&gt; None:</span>
<span class="w"> </span>        self.expr = expr

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTSizeofExpr):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.expr == other.expr

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.expr)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &quot;sizeof &quot; + transform(self.expr)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(&#39;sizeof&#39;, &#39;sizeof&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_space()</span>
<span class="gi">+        self.expr.describe_signature(signode, mode, env, symbol)</span>

<span class="gd">-class ASTAlignofExpr(ASTExpression):</span>

<span class="gd">-    def __init__(self, typ: ASTType) -&gt;None:</span>
<span class="gi">+class ASTAlignofExpr(ASTExpression):</span>
<span class="gi">+    def __init__(self, typ: ASTType) -&gt; None:</span>
<span class="w"> </span>        self.typ = typ

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTAlignofExpr):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.typ == other.typ

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.typ)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &quot;alignof(&quot; + transform(self.typ) + &quot;)&quot;</span>

<span class="gd">-class ASTCastExpr(ASTExpression):</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(&#39;alignof&#39;, &#39;alignof&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;(&#39;, &#39;(&#39;)</span>
<span class="gi">+        self.typ.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;)&#39;, &#39;)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Other expressions</span>
<span class="gi">+################################################################################</span>

<span class="gd">-    def __init__(self, typ: ASTType, expr: ASTExpression) -&gt;None:</span>
<span class="gi">+class ASTCastExpr(ASTExpression):</span>
<span class="gi">+    def __init__(self, typ: ASTType, expr: ASTExpression) -&gt; None:</span>
<span class="w"> </span>        self.typ = typ
<span class="w"> </span>        self.expr = expr

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTCastExpr):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return self.typ == other.typ and self.expr == other.expr</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.typ == other.typ</span>
<span class="gi">+            and self.expr == other.expr</span>
<span class="gi">+        )</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.typ, self.expr))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = [&#39;(&#39;]</span>
<span class="gi">+        res.append(transform(self.typ))</span>
<span class="gi">+        res.append(&#39;)&#39;)</span>
<span class="gi">+        res.append(transform(self.expr))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;(&#39;, &#39;(&#39;)</span>
<span class="gi">+        self.typ.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;)&#39;, &#39;)&#39;)</span>
<span class="gi">+        self.expr.describe_signature(signode, mode, env, symbol)</span>

<span class="gd">-class ASTBinOpExpr(ASTBase):</span>

<span class="gd">-    def __init__(self, exprs: list[ASTExpression], ops: list[str]) -&gt;None:</span>
<span class="gi">+class ASTBinOpExpr(ASTBase):</span>
<span class="gi">+    def __init__(self, exprs: list[ASTExpression], ops: list[str]) -&gt; None:</span>
<span class="w"> </span>        assert len(exprs) &gt; 0
<span class="w"> </span>        assert len(exprs) == len(ops) + 1
<span class="w"> </span>        self.exprs = exprs
<span class="w"> </span>        self.ops = ops

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTBinOpExpr):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return self.exprs == other.exprs and self.ops == other.ops</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.exprs == other.exprs</span>
<span class="gi">+            and self.ops == other.ops</span>
<span class="gi">+        )</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.exprs, self.ops))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        res.append(transform(self.exprs[0]))</span>
<span class="gi">+        for i in range(1, len(self.exprs)):</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+            res.append(self.ops[i - 1])</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+            res.append(transform(self.exprs[i]))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        self.exprs[0].describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        for i in range(1, len(self.exprs)):</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            op = self.ops[i - 1]</span>
<span class="gi">+            if ord(op[0]) &gt;= ord(&#39;a&#39;) and ord(op[0]) &lt;= ord(&#39;z&#39;):</span>
<span class="gi">+                signode += addnodes.desc_sig_keyword(op, op)</span>
<span class="gi">+            else:</span>
<span class="gi">+                signode += addnodes.desc_sig_operator(op, op)</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            self.exprs[i].describe_signature(signode, mode, env, symbol)</span>

<span class="gd">-class ASTAssignmentExpr(ASTExpression):</span>

<span class="gd">-    def __init__(self, exprs: list[ASTExpression], ops: list[str]) -&gt;None:</span>
<span class="gi">+class ASTAssignmentExpr(ASTExpression):</span>
<span class="gi">+    def __init__(self, exprs: list[ASTExpression], ops: list[str]) -&gt; None:</span>
<span class="w"> </span>        assert len(exprs) &gt; 0
<span class="w"> </span>        assert len(exprs) == len(ops) + 1
<span class="w"> </span>        self.exprs = exprs
<span class="w"> </span>        self.ops = ops

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTAssignmentExpr):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return self.exprs == other.exprs and self.ops == other.ops</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.exprs == other.exprs</span>
<span class="gi">+            and self.ops == other.ops</span>
<span class="gi">+        )</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.exprs, self.ops))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        res.append(transform(self.exprs[0]))</span>
<span class="gi">+        for i in range(1, len(self.exprs)):</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+            res.append(self.ops[i - 1])</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+            res.append(transform(self.exprs[i]))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        self.exprs[0].describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        for i in range(1, len(self.exprs)):</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            op = self.ops[i - 1]</span>
<span class="gi">+            if ord(op[0]) &gt;= ord(&#39;a&#39;) and ord(op[0]) &lt;= ord(&#39;z&#39;):</span>
<span class="gi">+                signode += addnodes.desc_sig_keyword(op, op)</span>
<span class="gi">+            else:</span>
<span class="gi">+                signode += addnodes.desc_sig_operator(op, op)</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            self.exprs[i].describe_signature(signode, mode, env, symbol)</span>

<span class="gd">-class ASTFallbackExpr(ASTExpression):</span>

<span class="gd">-    def __init__(self, expr: str) -&gt;None:</span>
<span class="gi">+class ASTFallbackExpr(ASTExpression):</span>
<span class="gi">+    def __init__(self, expr: str) -&gt; None:</span>
<span class="w"> </span>        self.expr = expr

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTFallbackExpr):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.expr == other.expr

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.expr)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return self.expr</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        return str(self.expr)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += nodes.literal(self.expr, self.expr)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+################################################################################</span>
<span class="gi">+# Types</span>
<span class="gi">+################################################################################</span>

<span class="w"> </span>class ASTTrailingTypeSpec(ASTBase):
<span class="w"> </span>    pass


<span class="w"> </span>class ASTTrailingTypeSpecFundamental(ASTTrailingTypeSpec):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, names: list[str]) -&gt;None:</span>
<span class="gi">+    def __init__(self, names: list[str]) -&gt; None:</span>
<span class="w"> </span>        assert len(names) != 0
<span class="w"> </span>        self.names = names

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTTrailingTypeSpecFundamental):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.names == other.names

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.names)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &#39; &#39;.join(self.names)</span>

<span class="gd">-class ASTTrailingTypeSpecName(ASTTrailingTypeSpec):</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        first = True</span>
<span class="gi">+        for n in self.names:</span>
<span class="gi">+            if not first:</span>
<span class="gi">+                signode += addnodes.desc_sig_space()</span>
<span class="gi">+            else:</span>
<span class="gi">+                first = False</span>
<span class="gi">+            signode += addnodes.desc_sig_keyword_type(n, n)</span>

<span class="gd">-    def __init__(self, prefix: str, nestedName: ASTNestedName) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class ASTTrailingTypeSpecName(ASTTrailingTypeSpec):</span>
<span class="gi">+    def __init__(self, prefix: str, nestedName: ASTNestedName) -&gt; None:</span>
<span class="w"> </span>        self.prefix = prefix
<span class="w"> </span>        self.nestedName = nestedName

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTTrailingTypeSpecName):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.prefix == other.prefix and self.nestedName == other.</span>
<span class="gd">-            nestedName)</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.prefix == other.prefix</span>
<span class="gi">+            and self.nestedName == other.nestedName</span>
<span class="gi">+        )</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.prefix, self.nestedName))

<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        return self.nestedName</span>

<span class="gd">-class ASTFunctionParameter(ASTBase):</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        if self.prefix:</span>
<span class="gi">+            res.append(self.prefix)</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+        res.append(transform(self.nestedName))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>

<span class="gd">-    def __init__(self, arg: (ASTTypeWithInit | None), ellipsis: bool=False</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        if self.prefix:</span>
<span class="gi">+            signode += addnodes.desc_sig_keyword(self.prefix, self.prefix)</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+        self.nestedName.describe_signature(signode, mode, env, symbol=symbol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ASTFunctionParameter(ASTBase):</span>
<span class="gi">+    def __init__(self, arg: ASTTypeWithInit | None, ellipsis: bool = False) -&gt; None:</span>
<span class="w"> </span>        self.arg = arg
<span class="w"> </span>        self.ellipsis = ellipsis

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTFunctionParameter):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.arg == other.arg and self.ellipsis == other.ellipsis

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.arg, self.ellipsis))

<span class="gi">+    def get_id(self, version: int, objectType: str, symbol: Symbol) -&gt; str:</span>
<span class="gi">+        # the anchor will be our parent</span>
<span class="gi">+        return symbol.parent.declaration.get_id(version, prefixed=False)</span>

<span class="gd">-class ASTParameters(ASTBase):</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        if self.ellipsis:</span>
<span class="gi">+            return &#39;...&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return transform(self.arg)</span>

<span class="gd">-    def __init__(self, args: list[ASTFunctionParameter], attrs:</span>
<span class="gd">-        ASTAttributeList) -&gt;None:</span>
<span class="gi">+    def describe_signature(self, signode: Any, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        if self.ellipsis:</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;...&#39;, &#39;...&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.arg.describe_signature(signode, mode, env, symbol=symbol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ASTParameters(ASTBase):</span>
<span class="gi">+    def __init__(self, args: list[ASTFunctionParameter], attrs: ASTAttributeList) -&gt; None:</span>
<span class="w"> </span>        self.args = args
<span class="w"> </span>        self.attrs = attrs

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTParameters):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.args == other.args and self.attrs == other.attrs

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.args, self.attrs))

<span class="gi">+    @property</span>
<span class="gi">+    def function_params(self) -&gt; list[ASTFunctionParameter]:</span>
<span class="gi">+        return self.args</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        res.append(&#39;(&#39;)</span>
<span class="gi">+        first = True</span>
<span class="gi">+        for a in self.args:</span>
<span class="gi">+            if not first:</span>
<span class="gi">+                res.append(&#39;, &#39;)</span>
<span class="gi">+            first = False</span>
<span class="gi">+            res.append(str(a))</span>
<span class="gi">+        res.append(&#39;)&#39;)</span>
<span class="gi">+        if len(self.attrs) != 0:</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+            res.append(transform(self.attrs))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        multi_line_parameter_list = False</span>
<span class="gi">+        test_node: Element = signode</span>
<span class="gi">+        while test_node.parent:</span>
<span class="gi">+            if not isinstance(test_node, addnodes.desc_signature):</span>
<span class="gi">+                test_node = test_node.parent</span>
<span class="gi">+                continue</span>
<span class="gi">+            multi_line_parameter_list = test_node.get(&#39;multi_line_parameter_list&#39;, False)</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+        # only use the desc_parameterlist for the outer list, not for inner lists</span>
<span class="gi">+        if mode == &#39;lastIsName&#39;:</span>
<span class="gi">+            paramlist = addnodes.desc_parameterlist()</span>
<span class="gi">+            paramlist[&#39;multi_line_parameter_list&#39;] = multi_line_parameter_list</span>
<span class="gi">+            for arg in self.args:</span>
<span class="gi">+                param = addnodes.desc_parameter(&#39;&#39;, &#39;&#39;, noemph=True)</span>
<span class="gi">+                arg.describe_signature(param, &#39;param&#39;, env, symbol=symbol)</span>
<span class="gi">+                paramlist += param</span>
<span class="gi">+            signode += paramlist</span>
<span class="gi">+        else:</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;(&#39;, &#39;(&#39;)</span>
<span class="gi">+            first = True</span>
<span class="gi">+            for arg in self.args:</span>
<span class="gi">+                if not first:</span>
<span class="gi">+                    signode += addnodes.desc_sig_punctuation(&#39;,&#39;, &#39;,&#39;)</span>
<span class="gi">+                    signode += addnodes.desc_sig_space()</span>
<span class="gi">+                first = False</span>
<span class="gi">+                arg.describe_signature(signode, &#39;markType&#39;, env, symbol=symbol)</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;)&#39;, &#39;)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if len(self.attrs) != 0:</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            self.attrs.describe_signature(signode)</span>

<span class="gd">-class ASTDeclSpecsSimple(ASTBaseBase):</span>

<span class="gi">+class ASTDeclSpecsSimple(ASTBaseBase):</span>
<span class="w"> </span>    def __init__(self, storage: str, threadLocal: str, inline: bool,
<span class="gd">-        restrict: bool, volatile: bool, const: bool, attrs: ASTAttributeList</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+                 restrict: bool, volatile: bool, const: bool, attrs: ASTAttributeList) -&gt; None:</span>
<span class="w"> </span>        self.storage = storage
<span class="w"> </span>        self.threadLocal = threadLocal
<span class="w"> </span>        self.inline = inline
<span class="gu">@@ -422,45 +885,159 @@ class ASTDeclSpecsSimple(ASTBaseBase):</span>
<span class="w"> </span>        self.const = const
<span class="w"> </span>        self.attrs = attrs

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTDeclSpecsSimple):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.storage == other.storage and self.threadLocal == other</span>
<span class="gd">-            .threadLocal and self.inline == other.inline and self.restrict ==</span>
<span class="gd">-            other.restrict and self.volatile == other.volatile and self.</span>
<span class="gd">-            const == other.const and self.attrs == other.attrs)</span>
<span class="gd">-</span>
<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gd">-        return hash((self.storage, self.threadLocal, self.inline, self.</span>
<span class="gd">-            restrict, self.volatile, self.const, self.attrs))</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.storage == other.storage</span>
<span class="gi">+            and self.threadLocal == other.threadLocal</span>
<span class="gi">+            and self.inline == other.inline</span>
<span class="gi">+            and self.restrict == other.restrict</span>
<span class="gi">+            and self.volatile == other.volatile</span>
<span class="gi">+            and self.const == other.const</span>
<span class="gi">+            and self.attrs == other.attrs</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="gi">+        return hash((</span>
<span class="gi">+            self.storage,</span>
<span class="gi">+            self.threadLocal,</span>
<span class="gi">+            self.inline,</span>
<span class="gi">+            self.restrict,</span>
<span class="gi">+            self.volatile,</span>
<span class="gi">+            self.const,</span>
<span class="gi">+            self.attrs,</span>
<span class="gi">+        ))</span>
<span class="gi">+</span>
<span class="gi">+    def mergeWith(self, other: ASTDeclSpecsSimple) -&gt; ASTDeclSpecsSimple:</span>
<span class="gi">+        if not other:</span>
<span class="gi">+            return self</span>
<span class="gi">+        return ASTDeclSpecsSimple(self.storage or other.storage,</span>
<span class="gi">+                                  self.threadLocal or other.threadLocal,</span>
<span class="gi">+                                  self.inline or other.inline,</span>
<span class="gi">+                                  self.volatile or other.volatile,</span>
<span class="gi">+                                  self.const or other.const,</span>
<span class="gi">+                                  self.restrict or other.restrict,</span>
<span class="gi">+                                  self.attrs + other.attrs)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res: list[str] = []</span>
<span class="gi">+        if len(self.attrs) != 0:</span>
<span class="gi">+            res.append(transform(self.attrs))</span>
<span class="gi">+        if self.storage:</span>
<span class="gi">+            res.append(self.storage)</span>
<span class="gi">+        if self.threadLocal:</span>
<span class="gi">+            res.append(self.threadLocal)</span>
<span class="gi">+        if self.inline:</span>
<span class="gi">+            res.append(&#39;inline&#39;)</span>
<span class="gi">+        if self.restrict:</span>
<span class="gi">+            res.append(&#39;restrict&#39;)</span>
<span class="gi">+        if self.volatile:</span>
<span class="gi">+            res.append(&#39;volatile&#39;)</span>
<span class="gi">+        if self.const:</span>
<span class="gi">+            res.append(&#39;const&#39;)</span>
<span class="gi">+        return &#39; &#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, modifiers: list[Node]) -&gt; None:</span>
<span class="gi">+        def _add(modifiers: list[Node], text: str) -&gt; None:</span>
<span class="gi">+            if len(modifiers) != 0:</span>
<span class="gi">+                modifiers.append(addnodes.desc_sig_space())</span>
<span class="gi">+            modifiers.append(addnodes.desc_sig_keyword(text, text))</span>
<span class="gi">+</span>
<span class="gi">+        if len(modifiers) != 0 and len(self.attrs) != 0:</span>
<span class="gi">+            modifiers.append(addnodes.desc_sig_space())</span>
<span class="gi">+        tempNode = nodes.TextElement()</span>
<span class="gi">+        self.attrs.describe_signature(tempNode)</span>
<span class="gi">+        modifiers.extend(tempNode.children)</span>
<span class="gi">+        if self.storage:</span>
<span class="gi">+            _add(modifiers, self.storage)</span>
<span class="gi">+        if self.threadLocal:</span>
<span class="gi">+            _add(modifiers, self.threadLocal)</span>
<span class="gi">+        if self.inline:</span>
<span class="gi">+            _add(modifiers, &#39;inline&#39;)</span>
<span class="gi">+        if self.restrict:</span>
<span class="gi">+            _add(modifiers, &#39;restrict&#39;)</span>
<span class="gi">+        if self.volatile:</span>
<span class="gi">+            _add(modifiers, &#39;volatile&#39;)</span>
<span class="gi">+        if self.const:</span>
<span class="gi">+            _add(modifiers, &#39;const&#39;)</span>


<span class="w"> </span>class ASTDeclSpecs(ASTBase):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, outer: str, leftSpecs: ASTDeclSpecsSimple,</span>
<span class="gd">-        rightSpecs: ASTDeclSpecsSimple, trailing: ASTTrailingTypeSpec) -&gt;None:</span>
<span class="gi">+    def __init__(self, outer: str,</span>
<span class="gi">+                 leftSpecs: ASTDeclSpecsSimple,</span>
<span class="gi">+                 rightSpecs: ASTDeclSpecsSimple,</span>
<span class="gi">+                 trailing: ASTTrailingTypeSpec) -&gt; None:</span>
<span class="gi">+        # leftSpecs and rightSpecs are used for output</span>
<span class="gi">+        # allSpecs are used for id generation TODO: remove?</span>
<span class="w"> </span>        self.outer = outer
<span class="w"> </span>        self.leftSpecs = leftSpecs
<span class="w"> </span>        self.rightSpecs = rightSpecs
<span class="w"> </span>        self.allSpecs = self.leftSpecs.mergeWith(self.rightSpecs)
<span class="w"> </span>        self.trailingTypeSpec = trailing

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTDeclSpecs):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.outer == other.outer and self.leftSpecs == other.</span>
<span class="gd">-            leftSpecs and self.rightSpecs == other.rightSpecs and self.</span>
<span class="gd">-            trailingTypeSpec == other.trailingTypeSpec)</span>
<span class="gd">-</span>
<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gd">-        return hash((self.outer, self.leftSpecs, self.rightSpecs, self.</span>
<span class="gd">-            trailingTypeSpec))</span>
<span class="gd">-</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.outer == other.outer</span>
<span class="gi">+            and self.leftSpecs == other.leftSpecs</span>
<span class="gi">+            and self.rightSpecs == other.rightSpecs</span>
<span class="gi">+            and self.trailingTypeSpec == other.trailingTypeSpec</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="gi">+        return hash((</span>
<span class="gi">+            self.outer,</span>
<span class="gi">+            self.leftSpecs,</span>
<span class="gi">+            self.rightSpecs,</span>
<span class="gi">+            self.trailingTypeSpec,</span>
<span class="gi">+        ))</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res: list[str] = []</span>
<span class="gi">+        l = transform(self.leftSpecs)</span>
<span class="gi">+        if len(l) &gt; 0:</span>
<span class="gi">+            res.append(l)</span>
<span class="gi">+        if self.trailingTypeSpec:</span>
<span class="gi">+            if len(res) &gt; 0:</span>
<span class="gi">+                res.append(&quot; &quot;)</span>
<span class="gi">+            res.append(transform(self.trailingTypeSpec))</span>
<span class="gi">+            r = str(self.rightSpecs)</span>
<span class="gi">+            if len(r) &gt; 0:</span>
<span class="gi">+                if len(res) &gt; 0:</span>
<span class="gi">+                    res.append(&quot; &quot;)</span>
<span class="gi">+                res.append(r)</span>
<span class="gi">+        return &quot;&quot;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        modifiers: list[Node] = []</span>
<span class="gi">+</span>
<span class="gi">+        self.leftSpecs.describe_signature(modifiers)</span>
<span class="gi">+</span>
<span class="gi">+        for m in modifiers:</span>
<span class="gi">+            signode += m</span>
<span class="gi">+        if self.trailingTypeSpec:</span>
<span class="gi">+            if len(modifiers) &gt; 0:</span>
<span class="gi">+                signode += addnodes.desc_sig_space()</span>
<span class="gi">+            self.trailingTypeSpec.describe_signature(signode, mode, env,</span>
<span class="gi">+                                                     symbol=symbol)</span>
<span class="gi">+            modifiers = []</span>
<span class="gi">+            self.rightSpecs.describe_signature(modifiers)</span>
<span class="gi">+            if len(modifiers) &gt; 0:</span>
<span class="gi">+                signode += addnodes.desc_sig_space()</span>
<span class="gi">+            for m in modifiers:</span>
<span class="gi">+                signode += m</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Declarator</span>
<span class="gi">+################################################################################</span>

<span class="w"> </span>class ASTArray(ASTBase):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, static: bool, const: bool, volatile: bool, restrict:</span>
<span class="gd">-        bool, vla: bool, size: ASTExpression) -&gt;None:</span>
<span class="gi">+    def __init__(self, static: bool, const: bool, volatile: bool, restrict: bool,</span>
<span class="gi">+                 vla: bool, size: ASTExpression) -&gt; None:</span>
<span class="w"> </span>        self.static = static
<span class="w"> </span>        self.const = const
<span class="w"> </span>        self.volatile = volatile
<span class="gu">@@ -472,59 +1049,182 @@ class ASTArray(ASTBase):</span>
<span class="w"> </span>        if size is not None:
<span class="w"> </span>            assert not vla

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTArray):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.static == other.static and self.const == other.const and</span>
<span class="gd">-            self.volatile == other.volatile and self.restrict == other.</span>
<span class="gd">-            restrict and self.vla == other.vla and self.size == other.size)</span>
<span class="gd">-</span>
<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gd">-        return hash((self.static, self.const, self.volatile, self.restrict,</span>
<span class="gd">-            self.vla, self.size))</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.static == other.static</span>
<span class="gi">+            and self.const == other.const</span>
<span class="gi">+            and self.volatile == other.volatile</span>
<span class="gi">+            and self.restrict == other.restrict</span>
<span class="gi">+            and self.vla == other.vla</span>
<span class="gi">+            and self.size == other.size</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="gi">+        return hash((</span>
<span class="gi">+            self.static,</span>
<span class="gi">+            self.const,</span>
<span class="gi">+            self.volatile,</span>
<span class="gi">+            self.restrict,</span>
<span class="gi">+            self.vla,</span>
<span class="gi">+            self.size,</span>
<span class="gi">+        ))</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        el = []</span>
<span class="gi">+        if self.static:</span>
<span class="gi">+            el.append(&#39;static&#39;)</span>
<span class="gi">+        if self.restrict:</span>
<span class="gi">+            el.append(&#39;restrict&#39;)</span>
<span class="gi">+        if self.volatile:</span>
<span class="gi">+            el.append(&#39;volatile&#39;)</span>
<span class="gi">+        if self.const:</span>
<span class="gi">+            el.append(&#39;const&#39;)</span>
<span class="gi">+        if self.vla:</span>
<span class="gi">+            return &#39;[&#39; + &#39; &#39;.join(el) + &#39;*]&#39;</span>
<span class="gi">+        elif self.size:</span>
<span class="gi">+            el.append(transform(self.size))</span>
<span class="gi">+        return &#39;[&#39; + &#39; &#39;.join(el) + &#39;]&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;[&#39;, &#39;[&#39;)</span>
<span class="gi">+        addSpace = False</span>
<span class="gi">+</span>
<span class="gi">+        def _add(signode: TextElement, text: str) -&gt; bool:</span>
<span class="gi">+            if addSpace:</span>
<span class="gi">+                signode += addnodes.desc_sig_space()</span>
<span class="gi">+            signode += addnodes.desc_sig_keyword(text, text)</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        if self.static:</span>
<span class="gi">+            addSpace = _add(signode, &#39;static&#39;)</span>
<span class="gi">+        if self.restrict:</span>
<span class="gi">+            addSpace = _add(signode, &#39;restrict&#39;)</span>
<span class="gi">+        if self.volatile:</span>
<span class="gi">+            addSpace = _add(signode, &#39;volatile&#39;)</span>
<span class="gi">+        if self.const:</span>
<span class="gi">+            addSpace = _add(signode, &#39;const&#39;)</span>
<span class="gi">+        if self.vla:</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;*&#39;, &#39;*&#39;)</span>
<span class="gi">+        elif self.size:</span>
<span class="gi">+            if addSpace:</span>
<span class="gi">+                signode += addnodes.desc_sig_space()</span>
<span class="gi">+            self.size.describe_signature(signode, &#39;markType&#39;, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;]&#39;, &#39;]&#39;)</span>


<span class="w"> </span>class ASTDeclarator(ASTBase):
<span class="gd">-    pass</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>

<span class="gi">+    @property</span>
<span class="gi">+    def function_params(self) -&gt; list[ASTFunctionParameter]:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>
<span class="gi">+</span>
<span class="gi">+    def require_space_after_declSpecs(self) -&gt; bool:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>

<span class="gd">-class ASTDeclaratorNameParam(ASTDeclarator):</span>

<span class="gd">-    def __init__(self, declId: ASTNestedName, arrayOps: list[ASTArray],</span>
<span class="gd">-        param: ASTParameters) -&gt;None:</span>
<span class="gi">+class ASTDeclaratorNameParam(ASTDeclarator):</span>
<span class="gi">+    def __init__(self, declId: ASTNestedName,</span>
<span class="gi">+                 arrayOps: list[ASTArray], param: ASTParameters) -&gt; None:</span>
<span class="w"> </span>        self.declId = declId
<span class="w"> </span>        self.arrayOps = arrayOps
<span class="w"> </span>        self.param = param

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTDeclaratorNameParam):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.declId == other.declId and self.arrayOps == other.</span>
<span class="gd">-            arrayOps and self.param == other.param)</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.declId == other.declId</span>
<span class="gi">+            and self.arrayOps == other.arrayOps</span>
<span class="gi">+            and self.param == other.param</span>
<span class="gi">+        )</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.declId, self.arrayOps, self.param))

<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        return self.declId</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def function_params(self) -&gt; list[ASTFunctionParameter]:</span>
<span class="gi">+        return self.param.function_params</span>
<span class="gi">+</span>
<span class="gi">+    # ------------------------------------------------------------------------</span>
<span class="gi">+</span>
<span class="gi">+    def require_space_after_declSpecs(self) -&gt; bool:</span>
<span class="gi">+        return self.declId is not None</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        if self.declId:</span>
<span class="gi">+            res.append(transform(self.declId))</span>
<span class="gi">+        res.extend(transform(op) for op in self.arrayOps)</span>
<span class="gi">+        if self.param:</span>
<span class="gi">+            res.append(transform(self.param))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        if self.declId:</span>
<span class="gi">+            self.declId.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        for op in self.arrayOps:</span>
<span class="gi">+            op.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        if self.param:</span>
<span class="gi">+            self.param.describe_signature(signode, mode, env, symbol)</span>

<span class="gd">-class ASTDeclaratorNameBitField(ASTDeclarator):</span>

<span class="gd">-    def __init__(self, declId: ASTNestedName, size: ASTExpression) -&gt;None:</span>
<span class="gi">+class ASTDeclaratorNameBitField(ASTDeclarator):</span>
<span class="gi">+    def __init__(self, declId: ASTNestedName, size: ASTExpression) -&gt; None:</span>
<span class="w"> </span>        self.declId = declId
<span class="w"> </span>        self.size = size

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTDeclaratorNameBitField):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.declId == other.declId and self.size == other.size

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.declId, self.size))

<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        return self.declId</span>
<span class="gi">+</span>
<span class="gi">+    # ------------------------------------------------------------------------</span>
<span class="gi">+</span>
<span class="gi">+    def require_space_after_declSpecs(self) -&gt; bool:</span>
<span class="gi">+        return self.declId is not None</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        if self.declId:</span>
<span class="gi">+            res.append(transform(self.declId))</span>
<span class="gi">+        res.append(&quot; : &quot;)</span>
<span class="gi">+        res.append(transform(self.size))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        if self.declId:</span>
<span class="gi">+            self.declId.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_space()</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;:&#39;, &#39;:&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_space()</span>
<span class="gi">+        self.size.describe_signature(signode, mode, env, symbol)</span>

<span class="gd">-class ASTDeclaratorPtr(ASTDeclarator):</span>

<span class="gd">-    def __init__(self, next: ASTDeclarator, restrict: bool, volatile: bool,</span>
<span class="gd">-        const: bool, attrs: ASTAttributeList) -&gt;None:</span>
<span class="gi">+class ASTDeclaratorPtr(ASTDeclarator):</span>
<span class="gi">+    def __init__(self, next: ASTDeclarator, restrict: bool, volatile: bool, const: bool,</span>
<span class="gi">+                 attrs: ASTAttributeList) -&gt; None:</span>
<span class="w"> </span>        assert next
<span class="w"> </span>        self.next = next
<span class="w"> </span>        self.restrict = restrict
<span class="gu">@@ -532,225 +1232,615 @@ class ASTDeclaratorPtr(ASTDeclarator):</span>
<span class="w"> </span>        self.const = const
<span class="w"> </span>        self.attrs = attrs

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTDeclaratorPtr):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.next == other.next and self.restrict == other.restrict and</span>
<span class="gd">-            self.volatile == other.volatile and self.const == other.const and</span>
<span class="gd">-            self.attrs == other.attrs)</span>
<span class="gd">-</span>
<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gd">-        return hash((self.next, self.restrict, self.volatile, self.const,</span>
<span class="gd">-            self.attrs))</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.next == other.next</span>
<span class="gi">+            and self.restrict == other.restrict</span>
<span class="gi">+            and self.volatile == other.volatile</span>
<span class="gi">+            and self.const == other.const</span>
<span class="gi">+            and self.attrs == other.attrs</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="gi">+        return hash((self.next, self.restrict, self.volatile, self.const, self.attrs))</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        return self.next.name</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def function_params(self) -&gt; list[ASTFunctionParameter]:</span>
<span class="gi">+        return self.next.function_params</span>
<span class="gi">+</span>
<span class="gi">+    def require_space_after_declSpecs(self) -&gt; bool:</span>
<span class="gi">+        return self.const or self.volatile or self.restrict or \</span>
<span class="gi">+            len(self.attrs) &gt; 0 or \</span>
<span class="gi">+            self.next.require_space_after_declSpecs()</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = [&#39;*&#39;]</span>
<span class="gi">+        res.append(transform(self.attrs))</span>
<span class="gi">+        if len(self.attrs) != 0 and (self.restrict or self.volatile or self.const):</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+        if self.restrict:</span>
<span class="gi">+            res.append(&#39;restrict&#39;)</span>
<span class="gi">+        if self.volatile:</span>
<span class="gi">+            if self.restrict:</span>
<span class="gi">+                res.append(&#39; &#39;)</span>
<span class="gi">+            res.append(&#39;volatile&#39;)</span>
<span class="gi">+        if self.const:</span>
<span class="gi">+            if self.restrict or self.volatile:</span>
<span class="gi">+                res.append(&#39; &#39;)</span>
<span class="gi">+            res.append(&#39;const&#39;)</span>
<span class="gi">+        if self.const or self.volatile or self.restrict or len(self.attrs) &gt; 0:</span>
<span class="gi">+            if self.next.require_space_after_declSpecs():</span>
<span class="gi">+                res.append(&#39; &#39;)</span>
<span class="gi">+        res.append(transform(self.next))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;*&#39;, &#39;*&#39;)</span>
<span class="gi">+        self.attrs.describe_signature(signode)</span>
<span class="gi">+        if len(self.attrs) != 0 and (self.restrict or self.volatile or self.const):</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+</span>
<span class="gi">+        def _add_anno(signode: TextElement, text: str) -&gt; None:</span>
<span class="gi">+            signode += addnodes.desc_sig_keyword(text, text)</span>
<span class="gi">+</span>
<span class="gi">+        if self.restrict:</span>
<span class="gi">+            _add_anno(signode, &#39;restrict&#39;)</span>
<span class="gi">+        if self.volatile:</span>
<span class="gi">+            if self.restrict:</span>
<span class="gi">+                signode += addnodes.desc_sig_space()</span>
<span class="gi">+            _add_anno(signode, &#39;volatile&#39;)</span>
<span class="gi">+        if self.const:</span>
<span class="gi">+            if self.restrict or self.volatile:</span>
<span class="gi">+                signode += addnodes.desc_sig_space()</span>
<span class="gi">+            _add_anno(signode, &#39;const&#39;)</span>
<span class="gi">+        if self.const or self.volatile or self.restrict or len(self.attrs) &gt; 0:</span>
<span class="gi">+            if self.next.require_space_after_declSpecs():</span>
<span class="gi">+                signode += addnodes.desc_sig_space()</span>
<span class="gi">+        self.next.describe_signature(signode, mode, env, symbol)</span>


<span class="w"> </span>class ASTDeclaratorParen(ASTDeclarator):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, inner: ASTDeclarator, next: ASTDeclarator) -&gt;None:</span>
<span class="gi">+    def __init__(self, inner: ASTDeclarator, next: ASTDeclarator) -&gt; None:</span>
<span class="w"> </span>        assert inner
<span class="w"> </span>        assert next
<span class="w"> </span>        self.inner = inner
<span class="w"> </span>        self.next = next
<span class="gi">+        # TODO: we assume the name and params are in inner</span>

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTDeclaratorParen):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.inner == other.inner and self.next == other.next

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.inner, self.next))

<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        return self.inner.name</span>

<span class="gd">-class ASTParenExprList(ASTBaseParenExprList):</span>
<span class="gi">+    @property</span>
<span class="gi">+    def function_params(self) -&gt; list[ASTFunctionParameter]:</span>
<span class="gi">+        return self.inner.function_params</span>
<span class="gi">+</span>
<span class="gi">+    def require_space_after_declSpecs(self) -&gt; bool:</span>
<span class="gi">+        return True</span>

<span class="gd">-    def __init__(self, exprs: list[ASTExpression]) -&gt;None:</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = [&#39;(&#39;]</span>
<span class="gi">+        res.append(transform(self.inner))</span>
<span class="gi">+        res.append(&#39;)&#39;)</span>
<span class="gi">+        res.append(transform(self.next))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;(&#39;, &#39;(&#39;)</span>
<span class="gi">+        self.inner.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;)&#39;, &#39;)&#39;)</span>
<span class="gi">+        self.next.describe_signature(signode, &quot;noneIsName&quot;, env, symbol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Initializer</span>
<span class="gi">+################################################################################</span>
<span class="gi">+</span>
<span class="gi">+class ASTParenExprList(ASTBaseParenExprList):</span>
<span class="gi">+    def __init__(self, exprs: list[ASTExpression]) -&gt; None:</span>
<span class="w"> </span>        self.exprs = exprs

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTParenExprList):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.exprs == other.exprs

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.exprs)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        exprs = [transform(e) for e in self.exprs]</span>
<span class="gi">+        return &#39;(%s)&#39; % &#39;, &#39;.join(exprs)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;(&#39;, &#39;(&#39;)</span>
<span class="gi">+        first = True</span>
<span class="gi">+        for e in self.exprs:</span>
<span class="gi">+            if not first:</span>
<span class="gi">+                signode += addnodes.desc_sig_punctuation(&#39;,&#39;, &#39;,&#39;)</span>
<span class="gi">+                signode += addnodes.desc_sig_space()</span>
<span class="gi">+            else:</span>
<span class="gi">+                first = False</span>
<span class="gi">+            e.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;)&#39;, &#39;)&#39;)</span>

<span class="gd">-class ASTBracedInitList(ASTBase):</span>

<span class="gd">-    def __init__(self, exprs: list[ASTExpression], trailingComma: bool) -&gt;None:</span>
<span class="gi">+class ASTBracedInitList(ASTBase):</span>
<span class="gi">+    def __init__(self, exprs: list[ASTExpression], trailingComma: bool) -&gt; None:</span>
<span class="w"> </span>        self.exprs = exprs
<span class="w"> </span>        self.trailingComma = trailingComma

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTBracedInitList):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.exprs == other.exprs and self.trailingComma == other.</span>
<span class="gd">-            trailingComma)</span>
<span class="gi">+        return self.exprs == other.exprs and self.trailingComma == other.trailingComma</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.exprs, self.trailingComma))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        exprs = &#39;, &#39;.join(transform(e) for e in self.exprs)</span>
<span class="gi">+        trailingComma = &#39;,&#39; if self.trailingComma else &#39;&#39;</span>
<span class="gi">+        return f&#39;{{{exprs}{trailingComma}}}&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;{&#39;, &#39;{&#39;)</span>
<span class="gi">+        first = True</span>
<span class="gi">+        for e in self.exprs:</span>
<span class="gi">+            if not first:</span>
<span class="gi">+                signode += addnodes.desc_sig_punctuation(&#39;,&#39;, &#39;,&#39;)</span>
<span class="gi">+                signode += addnodes.desc_sig_space()</span>
<span class="gi">+            else:</span>
<span class="gi">+                first = False</span>
<span class="gi">+            e.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        if self.trailingComma:</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;,&#39;, &#39;,&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;}&#39;, &#39;}&#39;)</span>

<span class="gd">-class ASTInitializer(ASTBase):</span>

<span class="gd">-    def __init__(self, value: (ASTBracedInitList | ASTExpression),</span>
<span class="gd">-        hasAssign: bool=True) -&gt;None:</span>
<span class="gi">+class ASTInitializer(ASTBase):</span>
<span class="gi">+    def __init__(self, value: ASTBracedInitList | ASTExpression,</span>
<span class="gi">+                 hasAssign: bool = True) -&gt; None:</span>
<span class="w"> </span>        self.value = value
<span class="w"> </span>        self.hasAssign = hasAssign

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTInitializer):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.value == other.value and self.hasAssign == other.hasAssign

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.value, self.hasAssign))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        val = transform(self.value)</span>
<span class="gi">+        if self.hasAssign:</span>
<span class="gi">+            return &#39; = &#39; + val</span>
<span class="gi">+        else:</span>
<span class="gi">+            return val</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        if self.hasAssign:</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;=&#39;, &#39;=&#39;)</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+        self.value.describe_signature(signode, &#39;markType&#39;, env, symbol)</span>

<span class="gd">-class ASTType(ASTBase):</span>

<span class="gd">-    def __init__(self, declSpecs: ASTDeclSpecs, decl: ASTDeclarator) -&gt;None:</span>
<span class="gi">+class ASTType(ASTBase):</span>
<span class="gi">+    def __init__(self, declSpecs: ASTDeclSpecs, decl: ASTDeclarator) -&gt; None:</span>
<span class="w"> </span>        assert declSpecs
<span class="w"> </span>        assert decl
<span class="w"> </span>        self.declSpecs = declSpecs
<span class="w"> </span>        self.decl = decl

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTType):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.declSpecs == other.declSpecs and self.decl == other.decl

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.declSpecs, self.decl))

<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        return self.decl.name</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int, objectType: str, symbol: Symbol) -&gt; str:</span>
<span class="gi">+        return symbol.get_full_nested_name().get_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def function_params(self) -&gt; list[ASTFunctionParameter]:</span>
<span class="gi">+        return self.decl.function_params</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        declSpecs = transform(self.declSpecs)</span>
<span class="gi">+        res.append(declSpecs)</span>
<span class="gi">+        if self.decl.require_space_after_declSpecs() and len(declSpecs) &gt; 0:</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+        res.append(transform(self.decl))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def get_type_declaration_prefix(self) -&gt; str:</span>
<span class="gi">+        if self.declSpecs.trailingTypeSpec:</span>
<span class="gi">+            return &#39;typedef&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;type&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        self.declSpecs.describe_signature(signode, &#39;markType&#39;, env, symbol)</span>
<span class="gi">+        if (self.decl.require_space_after_declSpecs() and</span>
<span class="gi">+                len(str(self.declSpecs)) &gt; 0):</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+        # for parameters that don&#39;t really declare new names we get &#39;markType&#39;,</span>
<span class="gi">+        # this should not be propagated, but be &#39;noneIsName&#39;.</span>
<span class="gi">+        if mode == &#39;markType&#39;:</span>
<span class="gi">+            mode = &#39;noneIsName&#39;</span>
<span class="gi">+        self.decl.describe_signature(signode, mode, env, symbol)</span>

<span class="gd">-class ASTTypeWithInit(ASTBase):</span>

<span class="gd">-    def __init__(self, type: ASTType, init: ASTInitializer) -&gt;None:</span>
<span class="gi">+class ASTTypeWithInit(ASTBase):</span>
<span class="gi">+    def __init__(self, type: ASTType, init: ASTInitializer) -&gt; None:</span>
<span class="w"> </span>        self.type = type
<span class="w"> </span>        self.init = init

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTTypeWithInit):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.type == other.type and self.init == other.init

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.type, self.init))

<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        return self.type.name</span>

<span class="gd">-class ASTMacroParameter(ASTBase):</span>
<span class="gi">+    def get_id(self, version: int, objectType: str, symbol: Symbol) -&gt; str:</span>
<span class="gi">+        return self.type.get_id(version, objectType, symbol)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        res.append(transform(self.type))</span>
<span class="gi">+        if self.init:</span>
<span class="gi">+            res.append(transform(self.init))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>

<span class="gd">-    def __init__(self, arg: (ASTNestedName | None), ellipsis: bool=False,</span>
<span class="gd">-        variadic: bool=False) -&gt;None:</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        self.type.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        if self.init:</span>
<span class="gi">+            self.init.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ASTMacroParameter(ASTBase):</span>
<span class="gi">+    def __init__(self, arg: ASTNestedName | None, ellipsis: bool = False,</span>
<span class="gi">+                 variadic: bool = False) -&gt; None:</span>
<span class="w"> </span>        self.arg = arg
<span class="w"> </span>        self.ellipsis = ellipsis
<span class="w"> </span>        self.variadic = variadic

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTMacroParameter):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.arg == other.arg and self.ellipsis == other.ellipsis and</span>
<span class="gd">-            self.variadic == other.variadic)</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.arg == other.arg</span>
<span class="gi">+            and self.ellipsis == other.ellipsis</span>
<span class="gi">+            and self.variadic == other.variadic</span>
<span class="gi">+        )</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.arg, self.ellipsis, self.variadic))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        if self.ellipsis:</span>
<span class="gi">+            return &#39;...&#39;</span>
<span class="gi">+        elif self.variadic:</span>
<span class="gi">+            return transform(self.arg) + &#39;...&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return transform(self.arg)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: Any, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        if self.ellipsis:</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;...&#39;, &#39;...&#39;)</span>
<span class="gi">+        elif self.variadic:</span>
<span class="gi">+            name = str(self)</span>
<span class="gi">+            signode += addnodes.desc_sig_name(name, name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.arg.describe_signature(signode, mode, env, symbol=symbol)</span>
<span class="gi">+</span>

<span class="w"> </span>class ASTMacro(ASTBase):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, ident: ASTNestedName, args: (list[ASTMacroParameter] |</span>
<span class="gd">-        None)) -&gt;None:</span>
<span class="gi">+    def __init__(self, ident: ASTNestedName, args: list[ASTMacroParameter] | None) -&gt; None:</span>
<span class="w"> </span>        self.ident = ident
<span class="w"> </span>        self.args = args

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTMacro):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.ident == other.ident and self.args == other.args

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.ident, self.args))

<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        return self.ident</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int, objectType: str, symbol: Symbol) -&gt; str:</span>
<span class="gi">+        return symbol.get_full_nested_name().get_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        res.append(transform(self.ident))</span>
<span class="gi">+        if self.args is not None:</span>
<span class="gi">+            res.append(&#39;(&#39;)</span>
<span class="gi">+            first = True</span>
<span class="gi">+            for arg in self.args:</span>
<span class="gi">+                if not first:</span>
<span class="gi">+                    res.append(&#39;, &#39;)</span>
<span class="gi">+                first = False</span>
<span class="gi">+                res.append(transform(arg))</span>
<span class="gi">+            res.append(&#39;)&#39;)</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        self.ident.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        if self.args is None:</span>
<span class="gi">+            return</span>
<span class="gi">+        paramlist = addnodes.desc_parameterlist()</span>
<span class="gi">+        for arg in self.args:</span>
<span class="gi">+            param = addnodes.desc_parameter(&#39;&#39;, &#39;&#39;, noemph=True)</span>
<span class="gi">+            arg.describe_signature(param, &#39;param&#39;, env, symbol=symbol)</span>
<span class="gi">+            paramlist += param</span>
<span class="gi">+        signode += paramlist</span>

<span class="gd">-class ASTStruct(ASTBase):</span>

<span class="gd">-    def __init__(self, name: ASTNestedName) -&gt;None:</span>
<span class="gi">+class ASTStruct(ASTBase):</span>
<span class="gi">+    def __init__(self, name: ASTNestedName) -&gt; None:</span>
<span class="w"> </span>        self.name = name

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTStruct):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.name == other.name

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.name)

<span class="gi">+    def get_id(self, version: int, objectType: str, symbol: Symbol) -&gt; str:</span>
<span class="gi">+        return symbol.get_full_nested_name().get_id(version)</span>

<span class="gd">-class ASTUnion(ASTBase):</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return transform(self.name)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        self.name.describe_signature(signode, mode, env, symbol=symbol)</span>

<span class="gd">-    def __init__(self, name: ASTNestedName) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class ASTUnion(ASTBase):</span>
<span class="gi">+    def __init__(self, name: ASTNestedName) -&gt; None:</span>
<span class="w"> </span>        self.name = name

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTUnion):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.name == other.name

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.name)

<span class="gi">+    def get_id(self, version: int, objectType: str, symbol: Symbol) -&gt; str:</span>
<span class="gi">+        return symbol.get_full_nested_name().get_id(version)</span>

<span class="gd">-class ASTEnum(ASTBase):</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return transform(self.name)</span>

<span class="gd">-    def __init__(self, name: ASTNestedName) -&gt;None:</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        self.name.describe_signature(signode, mode, env, symbol=symbol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ASTEnum(ASTBase):</span>
<span class="gi">+    def __init__(self, name: ASTNestedName) -&gt; None:</span>
<span class="w"> </span>        self.name = name

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTEnum):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.name == other.name

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.name)

<span class="gi">+    def get_id(self, version: int, objectType: str, symbol: Symbol) -&gt; str:</span>
<span class="gi">+        return symbol.get_full_nested_name().get_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return transform(self.name)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        self.name.describe_signature(signode, mode, env, symbol=symbol)</span>

<span class="gd">-class ASTEnumerator(ASTBase):</span>

<span class="gd">-    def __init__(self, name: ASTNestedName, init: (ASTInitializer | None),</span>
<span class="gd">-        attrs: ASTAttributeList) -&gt;None:</span>
<span class="gi">+class ASTEnumerator(ASTBase):</span>
<span class="gi">+    def __init__(self, name: ASTNestedName, init: ASTInitializer | None,</span>
<span class="gi">+                 attrs: ASTAttributeList) -&gt; None:</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.init = init
<span class="w"> </span>        self.attrs = attrs

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTEnumerator):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.name == other.name and self.init == other.init and </span>
<span class="gd">-            self.attrs == other.attrs)</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.name == other.name</span>
<span class="gi">+            and self.init == other.init</span>
<span class="gi">+            and self.attrs == other.attrs</span>
<span class="gi">+        )</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.name, self.init, self.attrs))

<span class="gi">+    def get_id(self, version: int, objectType: str, symbol: Symbol) -&gt; str:</span>
<span class="gi">+        return symbol.get_full_nested_name().get_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        res.append(transform(self.name))</span>
<span class="gi">+        if len(self.attrs) != 0:</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+            res.append(transform(self.attrs))</span>
<span class="gi">+        if self.init:</span>
<span class="gi">+            res.append(transform(self.init))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        self.name.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        if len(self.attrs) != 0:</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            self.attrs.describe_signature(signode)</span>
<span class="gi">+        if self.init:</span>
<span class="gi">+            self.init.describe_signature(signode, &#39;markType&#39;, env, symbol)</span>

<span class="gd">-class ASTDeclaration(ASTBaseBase):</span>

<span class="gd">-    def __init__(self, objectType: str, directiveType: (str | None),</span>
<span class="gd">-        declaration: (DeclarationType | ASTFunctionParameter), semicolon:</span>
<span class="gd">-        bool=False) -&gt;None:</span>
<span class="gi">+class ASTDeclaration(ASTBaseBase):</span>
<span class="gi">+    def __init__(self, objectType: str, directiveType: str | None,</span>
<span class="gi">+                 declaration: DeclarationType | ASTFunctionParameter,</span>
<span class="gi">+                 semicolon: bool = False) -&gt; None:</span>
<span class="w"> </span>        self.objectType = objectType
<span class="w"> </span>        self.directiveType = directiveType
<span class="w"> </span>        self.declaration = declaration
<span class="w"> </span>        self.semicolon = semicolon
<span class="gi">+</span>
<span class="w"> </span>        self.symbol: Symbol | None = None
<span class="gi">+        # set by CObject._add_enumerator_to_parent</span>
<span class="w"> </span>        self.enumeratorScopedSymbol: Symbol | None = None
<span class="gi">+</span>
<span class="gi">+        # the cache assumes that by the time get_newest_id is called, no</span>
<span class="gi">+        # further changes will be made to this object</span>
<span class="w"> </span>        self._newest_id_cache: str | None = None

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTDeclaration):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.objectType == other.objectType and self.directiveType ==</span>
<span class="gd">-            other.directiveType and self.declaration == other.declaration and</span>
<span class="gd">-            self.semicolon == other.semicolon and self.symbol == other.</span>
<span class="gd">-            symbol and self.enumeratorScopedSymbol == other.</span>
<span class="gd">-            enumeratorScopedSymbol)</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.objectType == other.objectType</span>
<span class="gi">+            and self.directiveType == other.directiveType</span>
<span class="gi">+            and self.declaration == other.declaration</span>
<span class="gi">+            and self.semicolon == other.semicolon</span>
<span class="gi">+            and self.symbol == other.symbol</span>
<span class="gi">+            and self.enumeratorScopedSymbol == other.enumeratorScopedSymbol</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def clone(self) -&gt; ASTDeclaration:</span>
<span class="gi">+        return ASTDeclaration(self.objectType, self.directiveType,</span>
<span class="gi">+                              self.declaration.clone(), self.semicolon)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        decl = cast(DeclarationType, self.declaration)</span>
<span class="gi">+        return decl.name</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def function_params(self) -&gt; list[ASTFunctionParameter] | None:</span>
<span class="gi">+        if self.objectType != &#39;function&#39;:</span>
<span class="gi">+            return None</span>
<span class="gi">+        decl = cast(ASTType, self.declaration)</span>
<span class="gi">+        return decl.function_params</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int, prefixed: bool = True) -&gt; str:</span>
<span class="gi">+        if self.objectType == &#39;enumerator&#39; and self.enumeratorScopedSymbol:</span>
<span class="gi">+            return self.enumeratorScopedSymbol.declaration.get_id(version, prefixed)</span>
<span class="gi">+        id_ = self.declaration.get_id(version, self.objectType, self.symbol)</span>
<span class="gi">+        if prefixed:</span>
<span class="gi">+            return _id_prefix[version] + id_</span>
<span class="gi">+        else:</span>
<span class="gi">+            return id_</span>
<span class="gi">+</span>
<span class="gi">+    def get_newest_id(self) -&gt; str:</span>
<span class="gi">+        if self._newest_id_cache is None:</span>
<span class="gi">+            self._newest_id_cache = self.get_id(_max_id, True)</span>
<span class="gi">+        return self._newest_id_cache</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = transform(self.declaration)</span>
<span class="gi">+        if self.semicolon:</span>
<span class="gi">+            res += &#39;;&#39;</span>
<span class="gi">+        return res</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, options: dict[str, bool]) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        assert self.symbol</span>
<span class="gi">+        # The caller of the domain added a desc_signature node.</span>
<span class="gi">+        # Always enable multiline:</span>
<span class="gi">+        signode[&#39;is_multiline&#39;] = True</span>
<span class="gi">+        # Put each line in a desc_signature_line node.</span>
<span class="gi">+        mainDeclNode = addnodes.desc_signature_line()</span>
<span class="gi">+        mainDeclNode.sphinx_line_type = &#39;declarator&#39;</span>
<span class="gi">+        mainDeclNode[&#39;add_permalink&#39;] = not self.symbol.isRedeclaration</span>
<span class="gi">+        signode += mainDeclNode</span>
<span class="gi">+</span>
<span class="gi">+        if self.objectType in {&#39;member&#39;, &#39;function&#39;, &#39;macro&#39;}:</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif self.objectType == &#39;struct&#39;:</span>
<span class="gi">+            mainDeclNode += addnodes.desc_sig_keyword(&#39;struct&#39;, &#39;struct&#39;)</span>
<span class="gi">+            mainDeclNode += addnodes.desc_sig_space()</span>
<span class="gi">+        elif self.objectType == &#39;union&#39;:</span>
<span class="gi">+            mainDeclNode += addnodes.desc_sig_keyword(&#39;union&#39;, &#39;union&#39;)</span>
<span class="gi">+            mainDeclNode += addnodes.desc_sig_space()</span>
<span class="gi">+        elif self.objectType == &#39;enum&#39;:</span>
<span class="gi">+            mainDeclNode += addnodes.desc_sig_keyword(&#39;enum&#39;, &#39;enum&#39;)</span>
<span class="gi">+            mainDeclNode += addnodes.desc_sig_space()</span>
<span class="gi">+        elif self.objectType == &#39;enumerator&#39;:</span>
<span class="gi">+            mainDeclNode += addnodes.desc_sig_keyword(&#39;enumerator&#39;, &#39;enumerator&#39;)</span>
<span class="gi">+            mainDeclNode += addnodes.desc_sig_space()</span>
<span class="gi">+        elif self.objectType == &#39;type&#39;:</span>
<span class="gi">+            decl = cast(ASTType, self.declaration)</span>
<span class="gi">+            prefix = decl.get_type_declaration_prefix()</span>
<span class="gi">+            mainDeclNode += addnodes.desc_sig_keyword(prefix, prefix)</span>
<span class="gi">+            mainDeclNode += addnodes.desc_sig_space()</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise AssertionError</span>
<span class="gi">+        self.declaration.describe_signature(mainDeclNode, mode, env, self.symbol)</span>
<span class="gi">+        if self.semicolon:</span>
<span class="gi">+            mainDeclNode += addnodes.desc_sig_punctuation(&#39;;&#39;, &#39;;&#39;)</span>
<span class="gh">diff --git a/sphinx/domains/c/_ids.py b/sphinx/domains/c/_ids.py</span>
<span class="gh">index 76036e7d2..cd617be90 100644</span>
<span class="gd">--- a/sphinx/domains/c/_ids.py</span>
<span class="gi">+++ b/sphinx/domains/c/_ids.py</span>
<span class="gu">@@ -1,30 +1,53 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="gd">-_keywords = [&#39;auto&#39;, &#39;break&#39;, &#39;case&#39;, &#39;char&#39;, &#39;const&#39;, &#39;continue&#39;,</span>
<span class="gd">-    &#39;default&#39;, &#39;do&#39;, &#39;double&#39;, &#39;else&#39;, &#39;enum&#39;, &#39;extern&#39;, &#39;float&#39;, &#39;for&#39;,</span>
<span class="gd">-    &#39;goto&#39;, &#39;if&#39;, &#39;inline&#39;, &#39;int&#39;, &#39;long&#39;, &#39;register&#39;, &#39;restrict&#39;, &#39;return&#39;,</span>
<span class="gd">-    &#39;short&#39;, &#39;signed&#39;, &#39;sizeof&#39;, &#39;static&#39;, &#39;struct&#39;, &#39;switch&#39;, &#39;typedef&#39;,</span>
<span class="gd">-    &#39;union&#39;, &#39;unsigned&#39;, &#39;void&#39;, &#39;volatile&#39;, &#39;while&#39;, &#39;_Alignas&#39;,</span>
<span class="gd">-    &#39;_Alignof&#39;, &#39;_Atomic&#39;, &#39;_Bool&#39;, &#39;_Complex&#39;, &#39;_Decimal32&#39;, &#39;_Decimal64&#39;,</span>
<span class="gd">-    &#39;_Decimal128&#39;, &#39;_Generic&#39;, &#39;_Imaginary&#39;, &#39;_Noreturn&#39;, &#39;_Static_assert&#39;,</span>
<span class="gd">-    &#39;_Thread_local&#39;]</span>
<span class="gd">-_macroKeywords = [&#39;alignas&#39;, &#39;alignof&#39;, &#39;bool&#39;, &#39;complex&#39;, &#39;imaginary&#39;,</span>
<span class="gd">-    &#39;noreturn&#39;, &#39;static_assert&#39;, &#39;thread_local&#39;]</span>
<span class="gd">-_expression_bin_ops = [[&#39;||&#39;, &#39;or&#39;], [&#39;&amp;&amp;&#39;, &#39;and&#39;], [&#39;|&#39;, &#39;bitor&#39;], [&#39;^&#39;,</span>
<span class="gd">-    &#39;xor&#39;], [&#39;&amp;&#39;, &#39;bitand&#39;], [&#39;==&#39;, &#39;!=&#39;, &#39;not_eq&#39;], [&#39;&lt;=&#39;, &#39;&gt;=&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;],</span>
<span class="gd">-    [&#39;&lt;&lt;&#39;, &#39;&gt;&gt;&#39;], [&#39;+&#39;, &#39;-&#39;], [&#39;*&#39;, &#39;/&#39;, &#39;%&#39;], [&#39;.*&#39;, &#39;-&gt;*&#39;]]</span>
<span class="gd">-_expression_unary_ops = [&#39;++&#39;, &#39;--&#39;, &#39;*&#39;, &#39;&amp;&#39;, &#39;+&#39;, &#39;-&#39;, &#39;!&#39;, &#39;not&#39;, &#39;~&#39;,</span>
<span class="gd">-    &#39;compl&#39;]</span>
<span class="gd">-_expression_assignment_ops = [&#39;=&#39;, &#39;*=&#39;, &#39;/=&#39;, &#39;%=&#39;, &#39;+=&#39;, &#39;-=&#39;, &#39;&gt;&gt;=&#39;,</span>
<span class="gd">-    &#39;&lt;&lt;=&#39;, &#39;&amp;=&#39;, &#39;and_eq&#39;, &#39;^=&#39;, &#39;xor_eq&#39;, &#39;|=&#39;, &#39;or_eq&#39;]</span>
<span class="gi">+</span>
<span class="gi">+# https://en.cppreference.com/w/c/keyword</span>
<span class="gi">+_keywords = [</span>
<span class="gi">+    &#39;auto&#39;, &#39;break&#39;, &#39;case&#39;, &#39;char&#39;, &#39;const&#39;, &#39;continue&#39;, &#39;default&#39;, &#39;do&#39;, &#39;double&#39;,</span>
<span class="gi">+    &#39;else&#39;, &#39;enum&#39;, &#39;extern&#39;, &#39;float&#39;, &#39;for&#39;, &#39;goto&#39;, &#39;if&#39;, &#39;inline&#39;, &#39;int&#39;, &#39;long&#39;,</span>
<span class="gi">+    &#39;register&#39;, &#39;restrict&#39;, &#39;return&#39;, &#39;short&#39;, &#39;signed&#39;, &#39;sizeof&#39;, &#39;static&#39;, &#39;struct&#39;,</span>
<span class="gi">+    &#39;switch&#39;, &#39;typedef&#39;, &#39;union&#39;, &#39;unsigned&#39;, &#39;void&#39;, &#39;volatile&#39;, &#39;while&#39;,</span>
<span class="gi">+    &#39;_Alignas&#39;, &#39;_Alignof&#39;, &#39;_Atomic&#39;, &#39;_Bool&#39;, &#39;_Complex&#39;,</span>
<span class="gi">+    &#39;_Decimal32&#39;, &#39;_Decimal64&#39;, &#39;_Decimal128&#39;,</span>
<span class="gi">+    &#39;_Generic&#39;, &#39;_Imaginary&#39;, &#39;_Noreturn&#39;, &#39;_Static_assert&#39;, &#39;_Thread_local&#39;,</span>
<span class="gi">+]</span>
<span class="gi">+# These are only keyword&#39;y when the corresponding headers are included.</span>
<span class="gi">+# They are used as default value for c_extra_keywords.</span>
<span class="gi">+_macroKeywords = [</span>
<span class="gi">+    &#39;alignas&#39;, &#39;alignof&#39;, &#39;bool&#39;, &#39;complex&#39;, &#39;imaginary&#39;, &#39;noreturn&#39;, &#39;static_assert&#39;,</span>
<span class="gi">+    &#39;thread_local&#39;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+# these are ordered by precedence</span>
<span class="gi">+_expression_bin_ops = [</span>
<span class="gi">+    [&#39;||&#39;, &#39;or&#39;],</span>
<span class="gi">+    [&#39;&amp;&amp;&#39;, &#39;and&#39;],</span>
<span class="gi">+    [&#39;|&#39;, &#39;bitor&#39;],</span>
<span class="gi">+    [&#39;^&#39;, &#39;xor&#39;],</span>
<span class="gi">+    [&#39;&amp;&#39;, &#39;bitand&#39;],</span>
<span class="gi">+    [&#39;==&#39;, &#39;!=&#39;, &#39;not_eq&#39;],</span>
<span class="gi">+    [&#39;&lt;=&#39;, &#39;&gt;=&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;],</span>
<span class="gi">+    [&#39;&lt;&lt;&#39;, &#39;&gt;&gt;&#39;],</span>
<span class="gi">+    [&#39;+&#39;, &#39;-&#39;],</span>
<span class="gi">+    [&#39;*&#39;, &#39;/&#39;, &#39;%&#39;],</span>
<span class="gi">+    [&#39;.*&#39;, &#39;-&gt;*&#39;],</span>
<span class="gi">+]</span>
<span class="gi">+_expression_unary_ops = [&quot;++&quot;, &quot;--&quot;, &quot;*&quot;, &quot;&amp;&quot;, &quot;+&quot;, &quot;-&quot;, &quot;!&quot;, &quot;not&quot;, &quot;~&quot;, &quot;compl&quot;]</span>
<span class="gi">+_expression_assignment_ops = [&quot;=&quot;, &quot;*=&quot;, &quot;/=&quot;, &quot;%=&quot;, &quot;+=&quot;, &quot;-=&quot;,</span>
<span class="gi">+                              &quot;&gt;&gt;=&quot;, &quot;&lt;&lt;=&quot;, &quot;&amp;=&quot;, &quot;and_eq&quot;, &quot;^=&quot;, &quot;xor_eq&quot;, &quot;|=&quot;, &quot;or_eq&quot;]</span>
<span class="gi">+</span>
<span class="w"> </span>_max_id = 1
<span class="w"> </span>_id_prefix = [None, &#39;c.&#39;, &#39;Cv2.&#39;]
<span class="gd">-_string_re = re.compile(</span>
<span class="gd">-    &#39;[LuU8]?(\&#39;([^\&#39;\\\\]*(?:\\\\.[^\&#39;\\\\]*)*)\&#39;|&quot;([^&quot;\\\\]*(?:\\\\.[^&quot;\\\\]*)*)&quot;)&#39;</span>
<span class="gd">-    , re.DOTALL)</span>
<span class="gd">-_simple_type_specifiers_re = re.compile(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    \\b(</span>
<span class="gi">+# Ids are used in lookup keys which are used across pickled files,</span>
<span class="gi">+# so when _max_id changes, make sure to update the ENV_VERSION.</span>
<span class="gi">+</span>
<span class="gi">+_string_re = re.compile(r&quot;[LuU8]?(&#39;([^&#39;\\]*(?:\\.[^&#39;\\]*)*)&#39;&quot;</span>
<span class="gi">+                        r&#39;|&quot;([^&quot;\\]*(?:\\.[^&quot;\\]*)*)&quot;)&#39;, re.DOTALL)</span>
<span class="gi">+</span>
<span class="gi">+# bool, complex, and imaginary are macro &quot;keywords&quot;, so they are handled separately</span>
<span class="gi">+_simple_type_specifiers_re = re.compile(r&quot;&quot;&quot;</span>
<span class="gi">+    \b(</span>
<span class="w"> </span>    void|_Bool
<span class="w"> </span>    |signed|unsigned
<span class="w"> </span>    |short|long
<span class="gu">@@ -38,6 +61,5 @@ _simple_type_specifiers_re = re.compile(</span>
<span class="w"> </span>    |__float80|_Float64x|__float128|_Float128|__ibm128  # extension
<span class="w"> </span>    |__fp16  # extension
<span class="w"> </span>    |_Sat|_Fract|fract|_Accum|accum  # extension
<span class="gd">-    )\\b</span>
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    , re.VERBOSE)</span>
<span class="gi">+    )\b</span>
<span class="gi">+&quot;&quot;&quot;, re.VERBOSE)</span>
<span class="gh">diff --git a/sphinx/domains/c/_parser.py b/sphinx/domains/c/_parser.py</span>
<span class="gh">index c92013687..1d29c6083 100644</span>
<span class="gd">--- a/sphinx/domains/c/_parser.py</span>
<span class="gi">+++ b/sphinx/domains/c/_parser.py</span>
<span class="gu">@@ -1,24 +1,1053 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gd">-from sphinx.domains.c._ast import ASTAlignofExpr, ASTArray, ASTAssignmentExpr, ASTBinOpExpr, ASTBooleanLiteral, ASTBracedInitList, ASTCastExpr, ASTCharLiteral, ASTDeclaration, ASTDeclarator, ASTDeclaratorNameBitField, ASTDeclaratorNameParam, ASTDeclaratorParen, ASTDeclaratorPtr, ASTDeclSpecs, ASTDeclSpecsSimple, ASTEnum, ASTEnumerator, ASTExpression, ASTFallbackExpr, ASTFunctionParameter, ASTIdentifier, ASTIdExpression, ASTInitializer, ASTLiteral, ASTMacro, ASTMacroParameter, ASTNestedName, ASTNumberLiteral, ASTParameters, ASTParenExpr, ASTParenExprList, ASTPostfixArray, ASTPostfixCallExpr, ASTPostfixDec, ASTPostfixExpr, ASTPostfixInc, ASTPostfixMemberOfPointer, ASTPostfixOp, ASTSizeofExpr, ASTSizeofType, ASTStringLiteral, ASTStruct, ASTTrailingTypeSpec, ASTTrailingTypeSpecFundamental, ASTTrailingTypeSpecName, ASTType, ASTTypeWithInit, ASTUnaryOpExpr, ASTUnion</span>
<span class="gd">-from sphinx.domains.c._ids import _expression_assignment_ops, _expression_bin_ops, _expression_unary_ops, _keywords, _simple_type_specifiers_re, _string_re</span>
<span class="gd">-from sphinx.util.cfamily import ASTAttributeList, BaseParser, DefinitionError, UnsupportedMultiCharacterCharLiteral, binary_literal_re, char_literal_re, float_literal_re, float_literal_suffix_re, hex_literal_re, identifier_re, integer_literal_re, integers_literal_suffix_re, octal_literal_re</span>
<span class="gi">+</span>
<span class="gi">+from sphinx.domains.c._ast import (</span>
<span class="gi">+    ASTAlignofExpr,</span>
<span class="gi">+    ASTArray,</span>
<span class="gi">+    ASTAssignmentExpr,</span>
<span class="gi">+    ASTBinOpExpr,</span>
<span class="gi">+    ASTBooleanLiteral,</span>
<span class="gi">+    ASTBracedInitList,</span>
<span class="gi">+    ASTCastExpr,</span>
<span class="gi">+    ASTCharLiteral,</span>
<span class="gi">+    ASTDeclaration,</span>
<span class="gi">+    ASTDeclarator,</span>
<span class="gi">+    ASTDeclaratorNameBitField,</span>
<span class="gi">+    ASTDeclaratorNameParam,</span>
<span class="gi">+    ASTDeclaratorParen,</span>
<span class="gi">+    ASTDeclaratorPtr,</span>
<span class="gi">+    ASTDeclSpecs,</span>
<span class="gi">+    ASTDeclSpecsSimple,</span>
<span class="gi">+    ASTEnum,</span>
<span class="gi">+    ASTEnumerator,</span>
<span class="gi">+    ASTExpression,</span>
<span class="gi">+    ASTFallbackExpr,</span>
<span class="gi">+    ASTFunctionParameter,</span>
<span class="gi">+    ASTIdentifier,</span>
<span class="gi">+    ASTIdExpression,</span>
<span class="gi">+    ASTInitializer,</span>
<span class="gi">+    ASTLiteral,</span>
<span class="gi">+    ASTMacro,</span>
<span class="gi">+    ASTMacroParameter,</span>
<span class="gi">+    ASTNestedName,</span>
<span class="gi">+    ASTNumberLiteral,</span>
<span class="gi">+    ASTParameters,</span>
<span class="gi">+    ASTParenExpr,</span>
<span class="gi">+    ASTParenExprList,</span>
<span class="gi">+    ASTPostfixArray,</span>
<span class="gi">+    ASTPostfixCallExpr,</span>
<span class="gi">+    ASTPostfixDec,</span>
<span class="gi">+    ASTPostfixExpr,</span>
<span class="gi">+    ASTPostfixInc,</span>
<span class="gi">+    ASTPostfixMemberOfPointer,</span>
<span class="gi">+    ASTPostfixOp,</span>
<span class="gi">+    ASTSizeofExpr,</span>
<span class="gi">+    ASTSizeofType,</span>
<span class="gi">+    ASTStringLiteral,</span>
<span class="gi">+    ASTStruct,</span>
<span class="gi">+    ASTTrailingTypeSpec,</span>
<span class="gi">+    ASTTrailingTypeSpecFundamental,</span>
<span class="gi">+    ASTTrailingTypeSpecName,</span>
<span class="gi">+    ASTType,</span>
<span class="gi">+    ASTTypeWithInit,</span>
<span class="gi">+    ASTUnaryOpExpr,</span>
<span class="gi">+    ASTUnion,</span>
<span class="gi">+)</span>
<span class="gi">+from sphinx.domains.c._ids import (</span>
<span class="gi">+    _expression_assignment_ops,</span>
<span class="gi">+    _expression_bin_ops,</span>
<span class="gi">+    _expression_unary_ops,</span>
<span class="gi">+    _keywords,</span>
<span class="gi">+    _simple_type_specifiers_re,</span>
<span class="gi">+    _string_re,</span>
<span class="gi">+)</span>
<span class="gi">+from sphinx.util.cfamily import (</span>
<span class="gi">+    ASTAttributeList,</span>
<span class="gi">+    BaseParser,</span>
<span class="gi">+    DefinitionError,</span>
<span class="gi">+    UnsupportedMultiCharacterCharLiteral,</span>
<span class="gi">+    binary_literal_re,</span>
<span class="gi">+    char_literal_re,</span>
<span class="gi">+    float_literal_re,</span>
<span class="gi">+    float_literal_suffix_re,</span>
<span class="gi">+    hex_literal_re,</span>
<span class="gi">+    identifier_re,</span>
<span class="gi">+    integer_literal_re,</span>
<span class="gi">+    integers_literal_suffix_re,</span>
<span class="gi">+    octal_literal_re,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Callable, Sequence
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.domains.c._ast import DeclarationType


<span class="w"> </span>class DefinitionParser(BaseParser):
<span class="gi">+    @property</span>
<span class="gi">+    def language(self) -&gt; str:</span>
<span class="gi">+        return &#39;C&#39;</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def id_attributes(self) -&gt; Sequence[str]:</span>
<span class="gi">+        return self.config.c_id_attributes</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def paren_attributes(self) -&gt; Sequence[str]:</span>
<span class="gi">+        return self.config.c_paren_attributes</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_string(self) -&gt; str | None:</span>
<span class="gi">+        if self.current_char != &#39;&quot;&#39;:</span>
<span class="gi">+            return None</span>
<span class="gi">+        startPos = self.pos</span>
<span class="gi">+        self.pos += 1</span>
<span class="gi">+        escape = False</span>
<span class="gi">+        while True:</span>
<span class="gi">+            if self.eof:</span>
<span class="gi">+                self.fail(&quot;Unexpected end during inside string.&quot;)</span>
<span class="gi">+            elif self.current_char == &#39;&quot;&#39; and not escape:</span>
<span class="gi">+                self.pos += 1</span>
<span class="gi">+                break</span>
<span class="gi">+            elif self.current_char == &#39;\\&#39;:</span>
<span class="gi">+                escape = True</span>
<span class="gi">+            else:</span>
<span class="gi">+                escape = False</span>
<span class="gi">+            self.pos += 1</span>
<span class="gi">+        return self.definition[startPos:self.pos]</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_literal(self) -&gt; ASTLiteral | None:</span>
<span class="gi">+        # -&gt; integer-literal</span>
<span class="gi">+        #  | character-literal</span>
<span class="gi">+        #  | floating-literal</span>
<span class="gi">+        #  | string-literal</span>
<span class="gi">+        #  | boolean-literal -&gt; &quot;false&quot; | &quot;true&quot;</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if self.skip_word(&#39;true&#39;):</span>
<span class="gi">+            return ASTBooleanLiteral(True)</span>
<span class="gi">+        if self.skip_word(&#39;false&#39;):</span>
<span class="gi">+            return ASTBooleanLiteral(False)</span>
<span class="gi">+        pos = self.pos</span>
<span class="gi">+        if self.match(float_literal_re):</span>
<span class="gi">+            self.match(float_literal_suffix_re)</span>
<span class="gi">+            return ASTNumberLiteral(self.definition[pos:self.pos])</span>
<span class="gi">+        for regex in (binary_literal_re, hex_literal_re,</span>
<span class="gi">+                      integer_literal_re, octal_literal_re):</span>
<span class="gi">+            if self.match(regex):</span>
<span class="gi">+                self.match(integers_literal_suffix_re)</span>
<span class="gi">+                return ASTNumberLiteral(self.definition[pos:self.pos])</span>
<span class="gi">+</span>
<span class="gi">+        string = self._parse_string()</span>
<span class="gi">+        if string is not None:</span>
<span class="gi">+            return ASTStringLiteral(string)</span>
<span class="gi">+</span>
<span class="gi">+        # character-literal</span>
<span class="gi">+        if self.match(char_literal_re):</span>
<span class="gi">+            prefix = self.last_match.group(1)  # may be None when no prefix</span>
<span class="gi">+            data = self.last_match.group(2)</span>
<span class="gi">+            try:</span>
<span class="gi">+                return ASTCharLiteral(prefix, data)</span>
<span class="gi">+            except UnicodeDecodeError as e:</span>
<span class="gi">+                self.fail(&quot;Can not handle character literal. Internal error was: %s&quot; % e)</span>
<span class="gi">+            except UnsupportedMultiCharacterCharLiteral:</span>
<span class="gi">+                self.fail(&quot;Can not handle character literal&quot;</span>
<span class="gi">+                          &quot; resulting in multiple decoded characters.&quot;)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_paren_expression(self) -&gt; ASTExpression | None:</span>
<span class="gi">+        # &quot;(&quot; expression &quot;)&quot;</span>
<span class="gi">+        if self.current_char != &#39;(&#39;:</span>
<span class="gi">+            return None</span>
<span class="gi">+        self.pos += 1</span>
<span class="gi">+        res = self._parse_expression()</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+            self.fail(&quot;Expected &#39;)&#39; in end of parenthesized expression.&quot;)</span>
<span class="gi">+        return ASTParenExpr(res)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_primary_expression(self) -&gt; ASTExpression | None:</span>
<span class="gi">+        # literal</span>
<span class="gi">+        # &quot;(&quot; expression &quot;)&quot;</span>
<span class="gi">+        # id-expression -&gt; we parse this with _parse_nested_name</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        res: ASTExpression | None = self._parse_literal()</span>
<span class="gi">+        if res is not None:</span>
<span class="gi">+            return res</span>
<span class="gi">+        res = self._parse_paren_expression()</span>
<span class="gi">+        if res is not None:</span>
<span class="gi">+            return res</span>
<span class="gi">+        nn = self._parse_nested_name()</span>
<span class="gi">+        if nn is not None:</span>
<span class="gi">+            return ASTIdExpression(nn)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_initializer_list(self, name: str, open: str, close: str,</span>
<span class="gi">+                                ) -&gt; tuple[list[ASTExpression] | None, bool | None]:</span>
<span class="gi">+        # Parse open and close with the actual initializer-list in between</span>
<span class="gi">+        # -&gt; initializer-clause &#39;...&#39;[opt]</span>
<span class="gi">+        #  | initializer-list &#39;,&#39; initializer-clause &#39;...&#39;[opt]</span>
<span class="gi">+        # TODO: designators</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if not self.skip_string_and_ws(open):</span>
<span class="gi">+            return None, None</span>
<span class="gi">+        if self.skip_string(close):</span>
<span class="gi">+            return [], False</span>
<span class="gi">+</span>
<span class="gi">+        exprs = []</span>
<span class="gi">+        trailingComma = False</span>
<span class="gi">+        while True:</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            expr = self._parse_expression()</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            exprs.append(expr)</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if self.skip_string(close):</span>
<span class="gi">+                break</span>
<span class="gi">+            if not self.skip_string_and_ws(&#39;,&#39;):</span>
<span class="gi">+                self.fail(f&quot;Error in {name}, expected &#39;,&#39; or &#39;{close}&#39;.&quot;)</span>
<span class="gi">+            if self.current_char == close == &#39;}&#39;:</span>
<span class="gi">+                self.pos += 1</span>
<span class="gi">+                trailingComma = True</span>
<span class="gi">+                break</span>
<span class="gi">+        return exprs, trailingComma</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_paren_expression_list(self) -&gt; ASTParenExprList | None:</span>
<span class="gi">+        # -&gt; &#39;(&#39; expression-list &#39;)&#39;</span>
<span class="gi">+        # though, we relax it to also allow empty parens</span>
<span class="gi">+        # as it&#39;s needed in some cases</span>
<span class="gi">+        #</span>
<span class="gi">+        # expression-list</span>
<span class="gi">+        # -&gt; initializer-list</span>
<span class="gi">+        exprs, trailingComma = self._parse_initializer_list(&quot;parenthesized expression-list&quot;,</span>
<span class="gi">+                                                            &#39;(&#39;, &#39;)&#39;)</span>
<span class="gi">+        if exprs is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return ASTParenExprList(exprs)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_braced_init_list(self) -&gt; ASTBracedInitList | None:</span>
<span class="gi">+        # -&gt; &#39;{&#39; initializer-list &#39;,&#39;[opt] &#39;}&#39;</span>
<span class="gi">+        #  | &#39;{&#39; &#39;}&#39;</span>
<span class="gi">+        exprs, trailingComma = self._parse_initializer_list(&quot;braced-init-list&quot;, &#39;{&#39;, &#39;}&#39;)</span>
<span class="gi">+        if exprs is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return ASTBracedInitList(exprs, trailingComma)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_postfix_expression(self) -&gt; ASTPostfixExpr:</span>
<span class="gi">+        # -&gt; primary</span>
<span class="gi">+        #  | postfix &quot;[&quot; expression &quot;]&quot;</span>
<span class="gi">+        #  | postfix &quot;[&quot; braced-init-list [opt] &quot;]&quot;</span>
<span class="gi">+        #  | postfix &quot;(&quot; expression-list [opt] &quot;)&quot;</span>
<span class="gi">+        #  | postfix &quot;.&quot; id-expression  // taken care of in primary by nested name</span>
<span class="gi">+        #  | postfix &quot;-&gt;&quot; id-expression</span>
<span class="gi">+        #  | postfix &quot;++&quot;</span>
<span class="gi">+        #  | postfix &quot;--&quot;</span>
<span class="gi">+</span>
<span class="gi">+        prefix = self._parse_primary_expression()</span>
<span class="gi">+</span>
<span class="gi">+        # and now parse postfixes</span>
<span class="gi">+        postFixes: list[ASTPostfixOp] = []</span>
<span class="gi">+        while True:</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if self.skip_string_and_ws(&#39;[&#39;):</span>
<span class="gi">+                expr = self._parse_expression()</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                if not self.skip_string(&#39;]&#39;):</span>
<span class="gi">+                    self.fail(&quot;Expected &#39;]&#39; in end of postfix expression.&quot;)</span>
<span class="gi">+                postFixes.append(ASTPostfixArray(expr))</span>
<span class="gi">+                continue</span>
<span class="gi">+            if self.skip_string(&#39;-&gt;&#39;):</span>
<span class="gi">+                if self.skip_string(&#39;*&#39;):</span>
<span class="gi">+                    # don&#39;t steal the arrow</span>
<span class="gi">+                    self.pos -= 3</span>
<span class="gi">+                else:</span>
<span class="gi">+                    name = self._parse_nested_name()</span>
<span class="gi">+                    postFixes.append(ASTPostfixMemberOfPointer(name))</span>
<span class="gi">+                    continue</span>
<span class="gi">+            if self.skip_string(&#39;++&#39;):</span>
<span class="gi">+                postFixes.append(ASTPostfixInc())</span>
<span class="gi">+                continue</span>
<span class="gi">+            if self.skip_string(&#39;--&#39;):</span>
<span class="gi">+                postFixes.append(ASTPostfixDec())</span>
<span class="gi">+                continue</span>
<span class="gi">+            lst = self._parse_paren_expression_list()</span>
<span class="gi">+            if lst is not None:</span>
<span class="gi">+                postFixes.append(ASTPostfixCallExpr(lst))</span>
<span class="gi">+                continue</span>
<span class="gi">+            break</span>
<span class="gi">+        return ASTPostfixExpr(prefix, postFixes)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_unary_expression(self) -&gt; ASTExpression:</span>
<span class="gi">+        # -&gt; postfix</span>
<span class="gi">+        #  | &quot;++&quot; cast</span>
<span class="gi">+        #  | &quot;--&quot; cast</span>
<span class="gi">+        #  | unary-operator cast -&gt; (* | &amp; | + | - | ! | ~) cast</span>
<span class="gi">+        # The rest:</span>
<span class="gi">+        #  | &quot;sizeof&quot; unary</span>
<span class="gi">+        #  | &quot;sizeof&quot; &quot;(&quot; type-id &quot;)&quot;</span>
<span class="gi">+        #  | &quot;alignof&quot; &quot;(&quot; type-id &quot;)&quot;</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        for op in _expression_unary_ops:</span>
<span class="gi">+            # TODO: hmm, should we be able to backtrack here?</span>
<span class="gi">+            if op[0] in &#39;cn&#39;:</span>
<span class="gi">+                res = self.skip_word(op)</span>
<span class="gi">+            else:</span>
<span class="gi">+                res = self.skip_string(op)</span>
<span class="gi">+            if res:</span>
<span class="gi">+                expr = self._parse_cast_expression()</span>
<span class="gi">+                return ASTUnaryOpExpr(op, expr)</span>
<span class="gi">+        if self.skip_word_and_ws(&#39;sizeof&#39;):</span>
<span class="gi">+            if self.skip_string_and_ws(&#39;(&#39;):</span>
<span class="gi">+                typ = self._parse_type(named=False)</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+                    self.fail(&quot;Expecting &#39;)&#39; to end &#39;sizeof&#39;.&quot;)</span>
<span class="gi">+                return ASTSizeofType(typ)</span>
<span class="gi">+            expr = self._parse_unary_expression()</span>
<span class="gi">+            return ASTSizeofExpr(expr)</span>
<span class="gi">+        if self.skip_word_and_ws(&#39;alignof&#39;):</span>
<span class="gi">+            if not self.skip_string_and_ws(&#39;(&#39;):</span>
<span class="gi">+                self.fail(&quot;Expecting &#39;(&#39; after &#39;alignof&#39;.&quot;)</span>
<span class="gi">+            typ = self._parse_type(named=False)</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+                self.fail(&quot;Expecting &#39;)&#39; to end &#39;alignof&#39;.&quot;)</span>
<span class="gi">+            return ASTAlignofExpr(typ)</span>
<span class="gi">+        return self._parse_postfix_expression()</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_cast_expression(self) -&gt; ASTExpression:</span>
<span class="gi">+        # -&gt; unary  | &quot;(&quot; type-id &quot;)&quot; cast</span>
<span class="gi">+        pos = self.pos</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if self.skip_string(&#39;(&#39;):</span>
<span class="gi">+            try:</span>
<span class="gi">+                typ = self._parse_type(False)</span>
<span class="gi">+                if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+                    self.fail(&quot;Expected &#39;)&#39; in cast expression.&quot;)</span>
<span class="gi">+                expr = self._parse_cast_expression()</span>
<span class="gi">+                return ASTCastExpr(typ, expr)</span>
<span class="gi">+            except DefinitionError as exCast:</span>
<span class="gi">+                self.pos = pos</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return self._parse_unary_expression()</span>
<span class="gi">+                except DefinitionError as exUnary:</span>
<span class="gi">+                    errs = []</span>
<span class="gi">+                    errs.append((exCast, &quot;If type cast expression&quot;))</span>
<span class="gi">+                    errs.append((exUnary, &quot;If unary expression&quot;))</span>
<span class="gi">+                    raise self._make_multi_error(errs,</span>
<span class="gi">+                                                 &quot;Error in cast expression.&quot;) from exUnary</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self._parse_unary_expression()</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_logical_or_expression(self) -&gt; ASTExpression:</span>
<span class="gi">+        # logical-or     = logical-and      ||</span>
<span class="gi">+        # logical-and    = inclusive-or     &amp;&amp;</span>
<span class="gi">+        # inclusive-or   = exclusive-or     |</span>
<span class="gi">+        # exclusive-or   = and              ^</span>
<span class="gi">+        # and            = equality         &amp;</span>
<span class="gi">+        # equality       = relational       ==, !=</span>
<span class="gi">+        # relational     = shift            &lt;, &gt;, &lt;=, &gt;=</span>
<span class="gi">+        # shift          = additive         &lt;&lt;, &gt;&gt;</span>
<span class="gi">+        # additive       = multiplicative   +, -</span>
<span class="gi">+        # multiplicative = pm               *, /, %</span>
<span class="gi">+        # pm             = cast             .*, -&gt;*</span>
<span class="gi">+        def _parse_bin_op_expr(self: DefinitionParser, opId: int) -&gt; ASTExpression:</span>
<span class="gi">+            if opId + 1 == len(_expression_bin_ops):</span>
<span class="gi">+                def parser() -&gt; ASTExpression:</span>
<span class="gi">+                    return self._parse_cast_expression()</span>
<span class="gi">+            else:</span>
<span class="gi">+                def parser() -&gt; ASTExpression:</span>
<span class="gi">+                    return _parse_bin_op_expr(self, opId + 1)</span>
<span class="gi">+            exprs = []</span>
<span class="gi">+            ops = []</span>
<span class="gi">+            exprs.append(parser())</span>
<span class="gi">+            while True:</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                pos = self.pos</span>
<span class="gi">+                oneMore = False</span>
<span class="gi">+                for op in _expression_bin_ops[opId]:</span>
<span class="gi">+                    if op[0] in &#39;abcnox&#39;:</span>
<span class="gi">+                        if not self.skip_word(op):</span>
<span class="gi">+                            continue</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        if not self.skip_string(op):</span>
<span class="gi">+                            continue</span>
<span class="gi">+                    if op == self.current_char == &#39;&amp;&#39;:</span>
<span class="gi">+                        # don&#39;t split the &amp;&amp; &#39;token&#39;</span>
<span class="gi">+                        self.pos -= 1</span>
<span class="gi">+                        # and btw. &amp;&amp; has lower precedence, so we are done</span>
<span class="gi">+                        break</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        expr = parser()</span>
<span class="gi">+                        exprs.append(expr)</span>
<span class="gi">+                        ops.append(op)</span>
<span class="gi">+                        oneMore = True</span>
<span class="gi">+                        break</span>
<span class="gi">+                    except DefinitionError:</span>
<span class="gi">+                        self.pos = pos</span>
<span class="gi">+                if not oneMore:</span>
<span class="gi">+                    break</span>
<span class="gi">+            return ASTBinOpExpr(exprs, ops)  # type: ignore[return-value]</span>
<span class="gi">+        return _parse_bin_op_expr(self, 0)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_conditional_expression_tail(self, orExprHead: Any) -&gt; ASTExpression | None:</span>
<span class="gi">+        # -&gt; &quot;?&quot; expression &quot;:&quot; assignment-expression</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_assignment_expression(self) -&gt; ASTExpression:</span>
<span class="gi">+        # -&gt; conditional-expression</span>
<span class="gi">+        #  | logical-or-expression assignment-operator initializer-clause</span>
<span class="gi">+        # -&gt; conditional-expression -&gt;</span>
<span class="gi">+        #     logical-or-expression</span>
<span class="gi">+        #   | logical-or-expression &quot;?&quot; expression &quot;:&quot; assignment-expression</span>
<span class="gi">+        #   | logical-or-expression assignment-operator initializer-clause</span>
<span class="gi">+        exprs = []</span>
<span class="gi">+        ops = []</span>
<span class="gi">+        orExpr = self._parse_logical_or_expression()</span>
<span class="gi">+        exprs.append(orExpr)</span>
<span class="gi">+        # TODO: handle ternary with _parse_conditional_expression_tail</span>
<span class="gi">+        while True:</span>
<span class="gi">+            oneMore = False</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            for op in _expression_assignment_ops:</span>
<span class="gi">+                if op[0] in &#39;abcnox&#39;:</span>
<span class="gi">+                    if not self.skip_word(op):</span>
<span class="gi">+                        continue</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if not self.skip_string(op):</span>
<span class="gi">+                        continue</span>
<span class="gi">+                expr = self._parse_logical_or_expression()</span>
<span class="gi">+                exprs.append(expr)</span>
<span class="gi">+                ops.append(op)</span>
<span class="gi">+                oneMore = True</span>
<span class="gi">+            if not oneMore:</span>
<span class="gi">+                break</span>
<span class="gi">+        return ASTAssignmentExpr(exprs, ops)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_constant_expression(self) -&gt; ASTExpression:</span>
<span class="gi">+        # -&gt; conditional-expression</span>
<span class="gi">+        orExpr = self._parse_logical_or_expression()</span>
<span class="gi">+        # TODO: use _parse_conditional_expression_tail</span>
<span class="gi">+        return orExpr</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_expression(self) -&gt; ASTExpression:</span>
<span class="gi">+        # -&gt; assignment-expression</span>
<span class="gi">+        #  | expression &quot;,&quot; assignment-expression</span>
<span class="gi">+        # TODO: actually parse the second production</span>
<span class="gi">+        return self._parse_assignment_expression()</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_expression_fallback(</span>
<span class="gi">+            self, end: list[str],</span>
<span class="gi">+            parser: Callable[[], ASTExpression],</span>
<span class="gi">+            allow: bool = True) -&gt; ASTExpression:</span>
<span class="gi">+        # Stupidly &quot;parse&quot; an expression.</span>
<span class="gi">+        # &#39;end&#39; should be a list of characters which ends the expression.</span>
<span class="gi">+</span>
<span class="gi">+        # first try to use the provided parser</span>
<span class="gi">+        prevPos = self.pos</span>
<span class="gi">+        try:</span>
<span class="gi">+            return parser()</span>
<span class="gi">+        except DefinitionError as e:</span>
<span class="gi">+            # some places (e.g., template parameters) we really don&#39;t want to use fallback,</span>
<span class="gi">+            # and for testing we may want to globally disable it</span>
<span class="gi">+            if not allow or not self.allowFallbackExpressionParsing:</span>
<span class="gi">+                raise</span>
<span class="gi">+            self.warn(&quot;Parsing of expression failed. Using fallback parser.&quot;</span>
<span class="gi">+                      &quot; Error was:\n%s&quot; % e)</span>
<span class="gi">+            self.pos = prevPos</span>
<span class="gi">+        # and then the fallback scanning</span>
<span class="gi">+        assert end is not None</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        startPos = self.pos</span>
<span class="gi">+        if self.match(_string_re):</span>
<span class="gi">+            value = self.matched_text</span>
<span class="gi">+        else:</span>
<span class="gi">+            # TODO: add handling of more bracket-like things, and quote handling</span>
<span class="gi">+            brackets = {&#39;(&#39;: &#39;)&#39;, &#39;{&#39;: &#39;}&#39;, &#39;[&#39;: &#39;]&#39;}</span>
<span class="gi">+            symbols: list[str] = []</span>
<span class="gi">+            while not self.eof:</span>
<span class="gi">+                if (len(symbols) == 0 and self.current_char in end):</span>
<span class="gi">+                    break</span>
<span class="gi">+                if self.current_char in brackets:</span>
<span class="gi">+                    symbols.append(brackets[self.current_char])</span>
<span class="gi">+                elif len(symbols) &gt; 0 and self.current_char == symbols[-1]:</span>
<span class="gi">+                    symbols.pop()</span>
<span class="gi">+                self.pos += 1</span>
<span class="gi">+            if len(end) &gt; 0 and self.eof:</span>
<span class="gi">+                self.fail(&quot;Could not find end of expression starting at %d.&quot;</span>
<span class="gi">+                          % startPos)</span>
<span class="gi">+            value = self.definition[startPos:self.pos].strip()</span>
<span class="gi">+        return ASTFallbackExpr(value.strip())</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_nested_name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        names: list[Any] = []</span>
<span class="gi">+</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        rooted = False</span>
<span class="gi">+        if self.skip_string(&#39;.&#39;):</span>
<span class="gi">+            rooted = True</span>
<span class="gi">+        while 1:</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if not self.match(identifier_re):</span>
<span class="gi">+                self.fail(&quot;Expected identifier in nested name.&quot;)</span>
<span class="gi">+            identifier = self.matched_text</span>
<span class="gi">+            # make sure there isn&#39;t a keyword</span>
<span class="gi">+            if identifier in _keywords:</span>
<span class="gi">+                self.fail(&quot;Expected identifier in nested name, &quot;</span>
<span class="gi">+                          &quot;got keyword: %s&quot; % identifier)</span>
<span class="gi">+            if self.matched_text in self.config.c_extra_keywords:</span>
<span class="gi">+                msg = (</span>
<span class="gi">+                    &#39;Expected identifier, got user-defined keyword: %s.&#39;</span>
<span class="gi">+                    &#39; Remove it from c_extra_keywords to allow it as identifier.\n&#39;</span>
<span class="gi">+                    &#39;Currently c_extra_keywords is %s.&#39;</span>
<span class="gi">+                )</span>
<span class="gi">+                self.fail(msg % (self.matched_text,</span>
<span class="gi">+                                 str(self.config.c_extra_keywords)))</span>
<span class="gi">+            ident = ASTIdentifier(identifier)</span>
<span class="gi">+            names.append(ident)</span>
<span class="gi">+</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if not self.skip_string(&#39;.&#39;):</span>
<span class="gi">+                break</span>
<span class="gi">+        return ASTNestedName(names, rooted)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_simple_type_specifier(self) -&gt; str | None:</span>
<span class="gi">+        if self.match(_simple_type_specifiers_re):</span>
<span class="gi">+            return self.matched_text</span>
<span class="gi">+        for t in (&#39;bool&#39;, &#39;complex&#39;, &#39;imaginary&#39;):</span>
<span class="gi">+            if t in self.config.c_extra_keywords:</span>
<span class="gi">+                if self.skip_word(t):</span>
<span class="gi">+                    return t</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_simple_type_specifiers(self) -&gt; ASTTrailingTypeSpecFundamental | None:</span>
<span class="gi">+        names: list[str] = []</span>
<span class="gi">+</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        while True:</span>
<span class="gi">+            t = self._parse_simple_type_specifier()</span>
<span class="gi">+            if t is None:</span>
<span class="gi">+                break</span>
<span class="gi">+            names.append(t)</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+        if len(names) == 0:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return ASTTrailingTypeSpecFundamental(names)</span>

<span class="gd">-    def _parse_decl_specs_simple(self, outer: (str | None), typed: bool</span>
<span class="gd">-        ) -&gt;ASTDeclSpecsSimple:</span>
<span class="gi">+    def _parse_trailing_type_spec(self) -&gt; ASTTrailingTypeSpec:</span>
<span class="gi">+        # fundamental types, https://en.cppreference.com/w/c/language/type</span>
<span class="gi">+        # and extensions</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        res = self._parse_simple_type_specifiers()</span>
<span class="gi">+        if res is not None:</span>
<span class="gi">+            return res</span>
<span class="gi">+</span>
<span class="gi">+        # prefixed</span>
<span class="gi">+        prefix = None</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        for k in (&#39;struct&#39;, &#39;enum&#39;, &#39;union&#39;):</span>
<span class="gi">+            if self.skip_word_and_ws(k):</span>
<span class="gi">+                prefix = k</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        nestedName = self._parse_nested_name()</span>
<span class="gi">+        return ASTTrailingTypeSpecName(prefix, nestedName)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_parameters(self, paramMode: str) -&gt; ASTParameters | None:</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if not self.skip_string(&#39;(&#39;):</span>
<span class="gi">+            if paramMode == &#39;function&#39;:</span>
<span class="gi">+                self.fail(&#39;Expecting &quot;(&quot; in parameters.&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+        args = []</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+            while 1:</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                if self.skip_string(&#39;...&#39;):</span>
<span class="gi">+                    args.append(ASTFunctionParameter(None, True))</span>
<span class="gi">+                    self.skip_ws()</span>
<span class="gi">+                    if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+                        self.fail(&#39;Expected &quot;)&quot; after &quot;...&quot; in parameters.&#39;)</span>
<span class="gi">+                    break</span>
<span class="gi">+                # note: it seems that function arguments can always be named,</span>
<span class="gi">+                # even in function pointers and similar.</span>
<span class="gi">+                arg = self._parse_type_with_init(outer=None, named=&#39;single&#39;)</span>
<span class="gi">+                # TODO: parse default parameters # TODO: didn&#39;t we just do that?</span>
<span class="gi">+                args.append(ASTFunctionParameter(arg))</span>
<span class="gi">+</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                if self.skip_string(&#39;,&#39;):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if self.skip_string(&#39;)&#39;):</span>
<span class="gi">+                    break</span>
<span class="gi">+                self.fail(f&#39;Expecting &quot;,&quot; or &quot;)&quot; in parameters, got &quot;{self.current_char}&quot;.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        attrs = self._parse_attribute_list()</span>
<span class="gi">+        return ASTParameters(args, attrs)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_decl_specs_simple(</span>
<span class="gi">+        self, outer: str | None, typed: bool,</span>
<span class="gi">+    ) -&gt; ASTDeclSpecsSimple:</span>
<span class="w"> </span>        &quot;&quot;&quot;Just parse the simple ones.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        storage = None</span>
<span class="gi">+        threadLocal = None</span>
<span class="gi">+        inline = None</span>
<span class="gi">+        restrict = None</span>
<span class="gi">+        volatile = None</span>
<span class="gi">+        const = None</span>
<span class="gi">+        attrs = []</span>
<span class="gi">+        while 1:  # accept any permutation of a subset of some decl-specs</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if not storage:</span>
<span class="gi">+                if outer == &#39;member&#39;:</span>
<span class="gi">+                    if self.skip_word(&#39;auto&#39;):</span>
<span class="gi">+                        storage = &#39;auto&#39;</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    if self.skip_word(&#39;register&#39;):</span>
<span class="gi">+                        storage = &#39;register&#39;</span>
<span class="gi">+                        continue</span>
<span class="gi">+                if outer in (&#39;member&#39;, &#39;function&#39;):</span>
<span class="gi">+                    if self.skip_word(&#39;static&#39;):</span>
<span class="gi">+                        storage = &#39;static&#39;</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    if self.skip_word(&#39;extern&#39;):</span>
<span class="gi">+                        storage = &#39;extern&#39;</span>
<span class="gi">+                        continue</span>
<span class="gi">+            if outer == &#39;member&#39; and not threadLocal:</span>
<span class="gi">+                if self.skip_word(&#39;thread_local&#39;):</span>
<span class="gi">+                    threadLocal = &#39;thread_local&#39;</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if self.skip_word(&#39;_Thread_local&#39;):</span>
<span class="gi">+                    threadLocal = &#39;_Thread_local&#39;</span>
<span class="gi">+                    continue</span>
<span class="gi">+            if outer == &#39;function&#39; and not inline:</span>
<span class="gi">+                inline = self.skip_word(&#39;inline&#39;)</span>
<span class="gi">+                if inline:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+            if not restrict and typed:</span>
<span class="gi">+                restrict = self.skip_word(&#39;restrict&#39;)</span>
<span class="gi">+                if restrict:</span>
<span class="gi">+                    continue</span>
<span class="gi">+            if not volatile and typed:</span>
<span class="gi">+                volatile = self.skip_word(&#39;volatile&#39;)</span>
<span class="gi">+                if volatile:</span>
<span class="gi">+                    continue</span>
<span class="gi">+            if not const and typed:</span>
<span class="gi">+                const = self.skip_word(&#39;const&#39;)</span>
<span class="gi">+                if const:</span>
<span class="gi">+                    continue</span>
<span class="gi">+            attr = self._parse_attribute()</span>
<span class="gi">+            if attr:</span>
<span class="gi">+                attrs.append(attr)</span>
<span class="gi">+                continue</span>
<span class="gi">+            break</span>
<span class="gi">+        return ASTDeclSpecsSimple(storage, threadLocal, inline,</span>
<span class="gi">+                                  restrict, volatile, const, ASTAttributeList(attrs))</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_decl_specs(self, outer: str | None, typed: bool = True) -&gt; ASTDeclSpecs:</span>
<span class="gi">+        if outer:</span>
<span class="gi">+            if outer not in (&#39;type&#39;, &#39;member&#39;, &#39;function&#39;):</span>
<span class="gi">+                raise Exception(&#39;Internal error, unknown outer &quot;%s&quot;.&#39; % outer)</span>
<span class="gi">+        leftSpecs = self._parse_decl_specs_simple(outer, typed)</span>
<span class="gi">+        rightSpecs = None</span>
<span class="gi">+</span>
<span class="gi">+        if typed:</span>
<span class="gi">+            trailing = self._parse_trailing_type_spec()</span>
<span class="gi">+            rightSpecs = self._parse_decl_specs_simple(outer, typed)</span>
<span class="gi">+        else:</span>
<span class="gi">+            trailing = None</span>
<span class="gi">+        return ASTDeclSpecs(outer, leftSpecs, rightSpecs, trailing)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_declarator_name_suffix(</span>
<span class="gi">+            self, named: bool | str, paramMode: str, typed: bool,</span>
<span class="gi">+    ) -&gt; ASTDeclarator:</span>
<span class="gi">+        assert named in (True, False, &#39;single&#39;)</span>
<span class="gi">+        # now we should parse the name, and then suffixes</span>
<span class="gi">+        if named == &#39;single&#39;:</span>
<span class="gi">+            if self.match(identifier_re):</span>
<span class="gi">+                if self.matched_text in _keywords:</span>
<span class="gi">+                    self.fail(&quot;Expected identifier, &quot;</span>
<span class="gi">+                              &quot;got keyword: %s&quot; % self.matched_text)</span>
<span class="gi">+                if self.matched_text in self.config.c_extra_keywords:</span>
<span class="gi">+                    msg = (</span>
<span class="gi">+                        &#39;Expected identifier, got user-defined keyword: %s. &#39;</span>
<span class="gi">+                        &#39;Remove it from c_extra_keywords to allow it as identifier.\n&#39;</span>
<span class="gi">+                        &#39;Currently c_extra_keywords is %s.&#39;</span>
<span class="gi">+                    )</span>
<span class="gi">+                    self.fail(msg % (self.matched_text,</span>
<span class="gi">+                                     str(self.config.c_extra_keywords)))</span>
<span class="gi">+                identifier = ASTIdentifier(self.matched_text)</span>
<span class="gi">+                declId = ASTNestedName([identifier], rooted=False)</span>
<span class="gi">+            else:</span>
<span class="gi">+                declId = None</span>
<span class="gi">+        elif named:</span>
<span class="gi">+            declId = self._parse_nested_name()</span>
<span class="gi">+        else:</span>
<span class="gi">+            declId = None</span>
<span class="gi">+        arrayOps = []</span>
<span class="gi">+        while 1:</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if typed and self.skip_string(&#39;[&#39;):</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                static = False</span>
<span class="gi">+                const = False</span>
<span class="gi">+                volatile = False</span>
<span class="gi">+                restrict = False</span>
<span class="gi">+                while True:</span>
<span class="gi">+                    if not static:</span>
<span class="gi">+                        if self.skip_word_and_ws(&#39;static&#39;):</span>
<span class="gi">+                            static = True</span>
<span class="gi">+                            continue</span>
<span class="gi">+                    if not const:</span>
<span class="gi">+                        if self.skip_word_and_ws(&#39;const&#39;):</span>
<span class="gi">+                            const = True</span>
<span class="gi">+                            continue</span>
<span class="gi">+                    if not volatile:</span>
<span class="gi">+                        if self.skip_word_and_ws(&#39;volatile&#39;):</span>
<span class="gi">+                            volatile = True</span>
<span class="gi">+                            continue</span>
<span class="gi">+                    if not restrict:</span>
<span class="gi">+                        if self.skip_word_and_ws(&#39;restrict&#39;):</span>
<span class="gi">+                            restrict = True</span>
<span class="gi">+                            continue</span>
<span class="gi">+                    break</span>
<span class="gi">+                vla = False if static else self.skip_string_and_ws(&#39;*&#39;)</span>
<span class="gi">+                if vla:</span>
<span class="gi">+                    if not self.skip_string(&#39;]&#39;):</span>
<span class="gi">+                        self.fail(&quot;Expected &#39;]&#39; in end of array operator.&quot;)</span>
<span class="gi">+                    size = None</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if self.skip_string(&#39;]&#39;):</span>
<span class="gi">+                        size = None</span>
<span class="gi">+                    else:</span>
<span class="gi">+</span>
<span class="gi">+                        def parser() -&gt; ASTExpression:</span>
<span class="gi">+                            return self._parse_expression()</span>
<span class="gi">+                        size = self._parse_expression_fallback([&#39;]&#39;], parser)</span>
<span class="gi">+                        self.skip_ws()</span>
<span class="gi">+                        if not self.skip_string(&#39;]&#39;):</span>
<span class="gi">+                            self.fail(&quot;Expected &#39;]&#39; in end of array operator.&quot;)</span>
<span class="gi">+                arrayOps.append(ASTArray(static, const, volatile, restrict, vla, size))</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>
<span class="gi">+        param = self._parse_parameters(paramMode)</span>
<span class="gi">+        if param is None and len(arrayOps) == 0:</span>
<span class="gi">+            # perhaps a bit-field</span>
<span class="gi">+            if named and paramMode == &#39;type&#39; and typed:</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                if self.skip_string(&#39;:&#39;):</span>
<span class="gi">+                    size = self._parse_constant_expression()</span>
<span class="gi">+                    return ASTDeclaratorNameBitField(declId=declId, size=size)</span>
<span class="gi">+        return ASTDeclaratorNameParam(declId=declId, arrayOps=arrayOps,</span>
<span class="gi">+                                      param=param)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_declarator(self, named: bool | str, paramMode: str,</span>
<span class="gi">+                          typed: bool = True) -&gt; ASTDeclarator:</span>
<span class="gi">+        # &#39;typed&#39; here means &#39;parse return type stuff&#39;</span>
<span class="gi">+        if paramMode not in (&#39;type&#39;, &#39;function&#39;):</span>
<span class="gi">+            raise Exception(</span>
<span class="gi">+                &quot;Internal error, unknown paramMode &#39;%s&#39;.&quot; % paramMode)</span>
<span class="gi">+        prevErrors = []</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if typed and self.skip_string(&#39;*&#39;):</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            restrict = False</span>
<span class="gi">+            volatile = False</span>
<span class="gi">+            const = False</span>
<span class="gi">+            attrs = []</span>
<span class="gi">+            while 1:</span>
<span class="gi">+                if not restrict:</span>
<span class="gi">+                    restrict = self.skip_word_and_ws(&#39;restrict&#39;)</span>
<span class="gi">+                    if restrict:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                if not volatile:</span>
<span class="gi">+                    volatile = self.skip_word_and_ws(&#39;volatile&#39;)</span>
<span class="gi">+                    if volatile:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                if not const:</span>
<span class="gi">+                    const = self.skip_word_and_ws(&#39;const&#39;)</span>
<span class="gi">+                    if const:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                attr = self._parse_attribute()</span>
<span class="gi">+                if attr is not None:</span>
<span class="gi">+                    attrs.append(attr)</span>
<span class="gi">+                    continue</span>
<span class="gi">+                break</span>
<span class="gi">+            next = self._parse_declarator(named, paramMode, typed)</span>
<span class="gi">+            return ASTDeclaratorPtr(next=next,</span>
<span class="gi">+                                    restrict=restrict, volatile=volatile, const=const,</span>
<span class="gi">+                                    attrs=ASTAttributeList(attrs))</span>
<span class="gi">+        if typed and self.current_char == &#39;(&#39;:  # note: peeking, not skipping</span>
<span class="gi">+            # maybe this is the beginning of params, try that first,</span>
<span class="gi">+            # otherwise assume it&#39;s noptr-&gt;declarator &gt; ( ptr-declarator )</span>
<span class="gi">+            pos = self.pos</span>
<span class="gi">+            try:</span>
<span class="gi">+                # assume this is params</span>
<span class="gi">+                res = self._parse_declarator_name_suffix(named, paramMode,</span>
<span class="gi">+                                                         typed)</span>
<span class="gi">+                return res</span>
<span class="gi">+            except DefinitionError as exParamQual:</span>
<span class="gi">+                msg = &quot;If declarator-id with parameters&quot;</span>
<span class="gi">+                if paramMode == &#39;function&#39;:</span>
<span class="gi">+                    msg += &quot; (e.g., &#39;void f(int arg)&#39;)&quot;</span>
<span class="gi">+                prevErrors.append((exParamQual, msg))</span>
<span class="gi">+                self.pos = pos</span>
<span class="gi">+                try:</span>
<span class="gi">+                    assert self.current_char == &#39;(&#39;</span>
<span class="gi">+                    self.skip_string(&#39;(&#39;)</span>
<span class="gi">+                    # TODO: hmm, if there is a name, it must be in inner, right?</span>
<span class="gi">+                    # TODO: hmm, if there must be parameters, they must b</span>
<span class="gi">+                    # inside, right?</span>
<span class="gi">+                    inner = self._parse_declarator(named, paramMode, typed)</span>
<span class="gi">+                    if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+                        self.fail(&quot;Expected &#39;)&#39; in \&quot;( ptr-declarator )\&quot;&quot;)</span>
<span class="gi">+                    next = self._parse_declarator(named=False,</span>
<span class="gi">+                                                  paramMode=&quot;type&quot;,</span>
<span class="gi">+                                                  typed=typed)</span>
<span class="gi">+                    return ASTDeclaratorParen(inner=inner, next=next)</span>
<span class="gi">+                except DefinitionError as exNoPtrParen:</span>
<span class="gi">+                    self.pos = pos</span>
<span class="gi">+                    msg = &quot;If parenthesis in noptr-declarator&quot;</span>
<span class="gi">+                    if paramMode == &#39;function&#39;:</span>
<span class="gi">+                        msg += &quot; (e.g., &#39;void (*f(int arg))(double)&#39;)&quot;</span>
<span class="gi">+                    prevErrors.append((exNoPtrParen, msg))</span>
<span class="gi">+                    header = &quot;Error in declarator&quot;</span>
<span class="gi">+                    raise self._make_multi_error(prevErrors, header) from exNoPtrParen</span>
<span class="gi">+        pos = self.pos</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._parse_declarator_name_suffix(named, paramMode, typed)</span>
<span class="gi">+        except DefinitionError as e:</span>
<span class="gi">+            self.pos = pos</span>
<span class="gi">+            prevErrors.append((e, &quot;If declarator-id&quot;))</span>
<span class="gi">+            header = &quot;Error in declarator or parameters&quot;</span>
<span class="gi">+            raise self._make_multi_error(prevErrors, header) from e</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_initializer(self, outer: str | None = None, allowFallback: bool = True,</span>
<span class="gi">+                           ) -&gt; ASTInitializer | None:</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if outer == &#39;member&#39; and False:  # NoQA: SIM223  # TODO</span>
<span class="gi">+            bracedInit = self._parse_braced_init_list()</span>
<span class="gi">+            if bracedInit is not None:</span>
<span class="gi">+                return ASTInitializer(bracedInit, hasAssign=False)</span>
<span class="gi">+</span>
<span class="gi">+        if not self.skip_string(&#39;=&#39;):</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        bracedInit = self._parse_braced_init_list()</span>
<span class="gi">+        if bracedInit is not None:</span>
<span class="gi">+            return ASTInitializer(bracedInit)</span>
<span class="gi">+</span>
<span class="gi">+        if outer == &#39;member&#39;:</span>
<span class="gi">+            fallbackEnd: list[str] = []</span>
<span class="gi">+        elif outer is None:  # function parameter</span>
<span class="gi">+            fallbackEnd = [&#39;,&#39;, &#39;)&#39;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.fail(&quot;Internal error, initializer for outer &#39;%s&#39; not &quot;</span>
<span class="gi">+                      &quot;implemented.&quot; % outer)</span>

<span class="gd">-    def _parse_type(self, named: (bool | str), outer: (str | None)=None</span>
<span class="gd">-        ) -&gt;ASTType:</span>
<span class="gi">+        def parser() -&gt; ASTExpression:</span>
<span class="gi">+            return self._parse_assignment_expression()</span>
<span class="gi">+</span>
<span class="gi">+        value = self._parse_expression_fallback(fallbackEnd, parser, allow=allowFallback)</span>
<span class="gi">+        return ASTInitializer(value)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_type(self, named: bool | str, outer: str | None = None) -&gt; ASTType:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        named=False|&#39;single&#39;|True: &#39;single&#39; is e.g., for function objects which
<span class="w"> </span>        doesn&#39;t need to name the arguments, but otherwise is a single name
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if outer:  # always named</span>
<span class="gi">+            if outer not in (&#39;type&#39;, &#39;member&#39;, &#39;function&#39;):</span>
<span class="gi">+                raise Exception(&#39;Internal error, unknown outer &quot;%s&quot;.&#39; % outer)</span>
<span class="gi">+            assert named</span>
<span class="gi">+</span>
<span class="gi">+        if outer == &#39;type&#39;:</span>
<span class="gi">+            # We allow type objects to just be a name.</span>
<span class="gi">+            prevErrors = []</span>
<span class="gi">+            startPos = self.pos</span>
<span class="gi">+            # first try without the type</span>
<span class="gi">+            try:</span>
<span class="gi">+                declSpecs = self._parse_decl_specs(outer=outer, typed=False)</span>
<span class="gi">+                decl = self._parse_declarator(named=True, paramMode=outer,</span>
<span class="gi">+                                              typed=False)</span>
<span class="gi">+                self.assert_end(allowSemicolon=True)</span>
<span class="gi">+            except DefinitionError as exUntyped:</span>
<span class="gi">+                desc = &quot;If just a name&quot;</span>
<span class="gi">+                prevErrors.append((exUntyped, desc))</span>
<span class="gi">+                self.pos = startPos</span>
<span class="gi">+                try:</span>
<span class="gi">+                    declSpecs = self._parse_decl_specs(outer=outer)</span>
<span class="gi">+                    decl = self._parse_declarator(named=True, paramMode=outer)</span>
<span class="gi">+                except DefinitionError as exTyped:</span>
<span class="gi">+                    self.pos = startPos</span>
<span class="gi">+                    desc = &quot;If typedef-like declaration&quot;</span>
<span class="gi">+                    prevErrors.append((exTyped, desc))</span>
<span class="gi">+                    # Retain the else branch for easier debugging.</span>
<span class="gi">+                    # TODO: it would be nice to save the previous stacktrace</span>
<span class="gi">+                    #       and output it here.</span>
<span class="gi">+                    if True:</span>
<span class="gi">+                        header = &quot;Type must be either just a name or a &quot;</span>
<span class="gi">+                        header += &quot;typedef-like declaration.&quot;</span>
<span class="gi">+                        raise self._make_multi_error(prevErrors, header) from exTyped</span>
<span class="gi">+                    else:  # NoQA: RET506</span>
<span class="gi">+                        # For testing purposes.</span>
<span class="gi">+                        # do it again to get the proper traceback (how do you</span>
<span class="gi">+                        # reliably save a traceback when an exception is</span>
<span class="gi">+                        # constructed?)</span>
<span class="gi">+                        self.pos = startPos</span>
<span class="gi">+                        typed = True</span>
<span class="gi">+                        declSpecs = self._parse_decl_specs(outer=outer, typed=typed)</span>
<span class="gi">+                        decl = self._parse_declarator(named=True, paramMode=outer,</span>
<span class="gi">+                                                      typed=typed)</span>
<span class="gi">+        elif outer == &#39;function&#39;:</span>
<span class="gi">+            declSpecs = self._parse_decl_specs(outer=outer)</span>
<span class="gi">+            decl = self._parse_declarator(named=True, paramMode=outer)</span>
<span class="gi">+        else:</span>
<span class="gi">+            paramMode = &#39;type&#39;</span>
<span class="gi">+            if outer == &#39;member&#39;:  # i.e., member</span>
<span class="gi">+                named = True</span>
<span class="gi">+            declSpecs = self._parse_decl_specs(outer=outer)</span>
<span class="gi">+            decl = self._parse_declarator(named=named, paramMode=paramMode)</span>
<span class="gi">+        return ASTType(declSpecs, decl)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_type_with_init(self, named: bool | str, outer: str | None) -&gt; ASTTypeWithInit:</span>
<span class="gi">+        if outer:</span>
<span class="gi">+            assert outer in (&#39;type&#39;, &#39;member&#39;, &#39;function&#39;)</span>
<span class="gi">+        type = self._parse_type(outer=outer, named=named)</span>
<span class="gi">+        init = self._parse_initializer(outer=outer)</span>
<span class="gi">+        return ASTTypeWithInit(type, init)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_macro(self) -&gt; ASTMacro:</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        ident = self._parse_nested_name()</span>
<span class="gi">+        if ident is None:</span>
<span class="gi">+            self.fail(&quot;Expected identifier in macro definition.&quot;)</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if not self.skip_string_and_ws(&#39;(&#39;):</span>
<span class="gi">+            return ASTMacro(ident, None)</span>
<span class="gi">+        if self.skip_string(&#39;)&#39;):</span>
<span class="gi">+            return ASTMacro(ident, [])</span>
<span class="gi">+        args = []</span>
<span class="gi">+        while 1:</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if self.skip_string(&#39;...&#39;):</span>
<span class="gi">+                args.append(ASTMacroParameter(None, True))</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+                    self.fail(&#39;Expected &quot;)&quot; after &quot;...&quot; in macro parameters.&#39;)</span>
<span class="gi">+                break</span>
<span class="gi">+            if not self.match(identifier_re):</span>
<span class="gi">+                self.fail(&quot;Expected identifier in macro parameters.&quot;)</span>
<span class="gi">+            nn = ASTNestedName([ASTIdentifier(self.matched_text)], rooted=False)</span>
<span class="gi">+            # Allow named variadic args:</span>
<span class="gi">+            # https://gcc.gnu.org/onlinedocs/cpp/Variadic-Macros.html</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if self.skip_string_and_ws(&#39;...&#39;):</span>
<span class="gi">+                args.append(ASTMacroParameter(nn, False, True))</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+                    self.fail(&#39;Expected &quot;)&quot; after &quot;...&quot; in macro parameters.&#39;)</span>
<span class="gi">+                break</span>
<span class="gi">+            args.append(ASTMacroParameter(nn))</span>
<span class="gi">+            if self.skip_string_and_ws(&#39;,&#39;):</span>
<span class="gi">+                continue</span>
<span class="gi">+            if self.skip_string_and_ws(&#39;)&#39;):</span>
<span class="gi">+                break</span>
<span class="gi">+            self.fail(&quot;Expected identifier, &#39;)&#39;, or &#39;,&#39; in macro parameter list.&quot;)</span>
<span class="gi">+        return ASTMacro(ident, args)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_struct(self) -&gt; ASTStruct:</span>
<span class="gi">+        name = self._parse_nested_name()</span>
<span class="gi">+        return ASTStruct(name)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_union(self) -&gt; ASTUnion:</span>
<span class="gi">+        name = self._parse_nested_name()</span>
<span class="gi">+        return ASTUnion(name)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_enum(self) -&gt; ASTEnum:</span>
<span class="gi">+        name = self._parse_nested_name()</span>
<span class="gi">+        return ASTEnum(name)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_enumerator(self) -&gt; ASTEnumerator:</span>
<span class="gi">+        name = self._parse_nested_name()</span>
<span class="gi">+        attrs = self._parse_attribute_list()</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        init = None</span>
<span class="gi">+        if self.skip_string(&#39;=&#39;):</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+</span>
<span class="gi">+            def parser() -&gt; ASTExpression:</span>
<span class="gi">+                return self._parse_constant_expression()</span>
<span class="gi">+</span>
<span class="gi">+            initVal = self._parse_expression_fallback([], parser)</span>
<span class="gi">+            init = ASTInitializer(initVal)</span>
<span class="gi">+        return ASTEnumerator(name, init, attrs)</span>
<span class="gi">+</span>
<span class="gi">+    def parse_declaration(self, objectType: str, directiveType: str) -&gt; ASTDeclaration:</span>
<span class="gi">+        if objectType not in (&#39;function&#39;, &#39;member&#39;,</span>
<span class="gi">+                              &#39;macro&#39;, &#39;struct&#39;, &#39;union&#39;, &#39;enum&#39;, &#39;enumerator&#39;, &#39;type&#39;):</span>
<span class="gi">+            raise Exception(&#39;Internal error, unknown objectType &quot;%s&quot;.&#39; % objectType)</span>
<span class="gi">+        if directiveType not in (&#39;function&#39;, &#39;member&#39;, &#39;var&#39;,</span>
<span class="gi">+                                 &#39;macro&#39;, &#39;struct&#39;, &#39;union&#39;, &#39;enum&#39;, &#39;enumerator&#39;, &#39;type&#39;):</span>
<span class="gi">+            raise Exception(&#39;Internal error, unknown directiveType &quot;%s&quot;.&#39; % directiveType)</span>
<span class="gi">+</span>
<span class="gi">+        declaration: DeclarationType | None = None</span>
<span class="gi">+        if objectType == &#39;member&#39;:</span>
<span class="gi">+            declaration = self._parse_type_with_init(named=True, outer=&#39;member&#39;)</span>
<span class="gi">+        elif objectType == &#39;function&#39;:</span>
<span class="gi">+            declaration = self._parse_type(named=True, outer=&#39;function&#39;)</span>
<span class="gi">+        elif objectType == &#39;macro&#39;:</span>
<span class="gi">+            declaration = self._parse_macro()</span>
<span class="gi">+        elif objectType == &#39;struct&#39;:</span>
<span class="gi">+            declaration = self._parse_struct()</span>
<span class="gi">+        elif objectType == &#39;union&#39;:</span>
<span class="gi">+            declaration = self._parse_union()</span>
<span class="gi">+        elif objectType == &#39;enum&#39;:</span>
<span class="gi">+            declaration = self._parse_enum()</span>
<span class="gi">+        elif objectType == &#39;enumerator&#39;:</span>
<span class="gi">+            declaration = self._parse_enumerator()</span>
<span class="gi">+        elif objectType == &#39;type&#39;:</span>
<span class="gi">+            declaration = self._parse_type(named=True, outer=&#39;type&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise AssertionError</span>
<span class="gi">+        if objectType != &#39;macro&#39;:</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            semicolon = self.skip_string(&#39;;&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            semicolon = False</span>
<span class="gi">+        return ASTDeclaration(objectType, directiveType, declaration, semicolon)</span>
<span class="gi">+</span>
<span class="gi">+    def parse_namespace_object(self) -&gt; ASTNestedName:</span>
<span class="gi">+        return self._parse_nested_name()</span>
<span class="gi">+</span>
<span class="gi">+    def parse_xref_object(self) -&gt; ASTNestedName:</span>
<span class="gi">+        name = self._parse_nested_name()</span>
<span class="gi">+        # if there are &#39;()&#39; left, just skip them</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        self.skip_string(&#39;()&#39;)</span>
<span class="gi">+        self.assert_end()</span>
<span class="gi">+        return name</span>
<span class="gi">+</span>
<span class="gi">+    def parse_expression(self) -&gt; ASTExpression | ASTType:</span>
<span class="gi">+        pos = self.pos</span>
<span class="gi">+        res: ASTExpression | ASTType | None = None</span>
<span class="gi">+        try:</span>
<span class="gi">+            res = self._parse_expression()</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            self.assert_end()</span>
<span class="gi">+        except DefinitionError as exExpr:</span>
<span class="gi">+            self.pos = pos</span>
<span class="gi">+            try:</span>
<span class="gi">+                res = self._parse_type(False)</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                self.assert_end()</span>
<span class="gi">+            except DefinitionError as exType:</span>
<span class="gi">+                header = &quot;Error when parsing (type) expression.&quot;</span>
<span class="gi">+                errs = []</span>
<span class="gi">+                errs.append((exExpr, &quot;If expression&quot;))</span>
<span class="gi">+                errs.append((exType, &quot;If type&quot;))</span>
<span class="gi">+                raise self._make_multi_error(errs, header) from exType</span>
<span class="gi">+        return res</span>
<span class="gh">diff --git a/sphinx/domains/c/_symbol.py b/sphinx/domains/c/_symbol.py</span>
<span class="gh">index 8ce95af65..c70b51316 100644</span>
<span class="gd">--- a/sphinx/domains/c/_symbol.py</span>
<span class="gi">+++ b/sphinx/domains/c/_symbol.py</span>
<span class="gu">@@ -1,69 +1,98 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gd">-from sphinx.domains.c._ast import ASTDeclaration, ASTIdentifier, ASTNestedName</span>
<span class="gi">+</span>
<span class="gi">+from sphinx.domains.c._ast import (</span>
<span class="gi">+    ASTDeclaration,</span>
<span class="gi">+    ASTIdentifier,</span>
<span class="gi">+    ASTNestedName,</span>
<span class="gi">+)</span>
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.util import logging
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Callable, Iterable, Iterator, Sequence
<span class="gi">+</span>
<span class="w"> </span>    from typing_extensions import Self
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="w"> </span>class _DuplicateSymbolError(Exception):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, symbol: Symbol, declaration: ASTDeclaration) -&gt;None:</span>
<span class="gi">+    def __init__(self, symbol: Symbol, declaration: ASTDeclaration) -&gt; None:</span>
<span class="w"> </span>        assert symbol
<span class="w"> </span>        assert declaration
<span class="w"> </span>        self.symbol = symbol
<span class="w"> </span>        self.declaration = declaration

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gd">-        return &#39;Internal C duplicate symbol error:\n%s&#39; % self.symbol.dump(0)</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="gi">+        return &quot;Internal C duplicate symbol error:\n%s&quot; % self.symbol.dump(0)</span>


<span class="w"> </span>class SymbolLookupResult:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, symbols: Sequence[Symbol], parentSymbol: Symbol,
<span class="gd">-        ident: ASTIdentifier) -&gt;None:</span>
<span class="gi">+                 ident: ASTIdentifier) -&gt; None:</span>
<span class="w"> </span>        self.symbols = symbols
<span class="w"> </span>        self.parentSymbol = parentSymbol
<span class="w"> </span>        self.ident = ident


<span class="w"> </span>class LookupKey:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, data: list[tuple[ASTIdentifier, str]]) -&gt;None:</span>
<span class="gi">+    def __init__(self, data: list[tuple[ASTIdentifier, str]]) -&gt; None:</span>
<span class="w"> </span>        self.data = data

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gd">-        inner = &#39;, &#39;.join(f&#39;({ident}, {id_})&#39; for ident, id_ in self.data)</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="gi">+        inner = &#39;, &#39;.join(f&quot;({ident}, {id_})&quot; for ident, id_ in self.data)</span>
<span class="w"> </span>        return f&#39;[{inner}]&#39;


<span class="w"> </span>class Symbol:
<span class="w"> </span>    debug_indent = 0
<span class="gd">-    debug_indent_string = &#39;  &#39;</span>
<span class="gi">+    debug_indent_string = &quot;  &quot;</span>
<span class="w"> </span>    debug_lookup = False
<span class="w"> </span>    debug_show_tree = False

<span class="gd">-    def __copy__(self) -&gt;Self:</span>
<span class="gd">-        raise AssertionError</span>
<span class="gi">+    def __copy__(self) -&gt; Self:</span>
<span class="gi">+        raise AssertionError  # shouldn&#39;t happen</span>

<span class="gd">-    def __deepcopy__(self, memo: Any) -&gt;Symbol:</span>
<span class="gi">+    def __deepcopy__(self, memo: Any) -&gt; Symbol:</span>
<span class="w"> </span>        if self.parent:
<span class="gd">-            raise AssertionError</span>
<span class="gi">+            raise AssertionError  # shouldn&#39;t happen</span>
<span class="gi">+        # the domain base class makes a copy of the initial data, which is fine</span>
<span class="w"> </span>        return Symbol(None, None, None, None, None)

<span class="gd">-    def __setattr__(self, key: str, value: Any) -&gt;None:</span>
<span class="gd">-        if key == &#39;children&#39;:</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def debug_print(*args: Any) -&gt; None:</span>
<span class="gi">+        msg = Symbol.debug_indent_string * Symbol.debug_indent</span>
<span class="gi">+        msg += &quot;&quot;.join(str(e) for e in args)</span>
<span class="gi">+        logger.debug(msg)</span>
<span class="gi">+</span>
<span class="gi">+    def _assert_invariants(self) -&gt; None:</span>
<span class="gi">+        if not self.parent:</span>
<span class="gi">+            # parent == None means global scope, so declaration means a parent</span>
<span class="gi">+            assert not self.declaration</span>
<span class="gi">+            assert not self.docname</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self.declaration:</span>
<span class="gi">+                assert self.docname</span>
<span class="gi">+</span>
<span class="gi">+    def __setattr__(self, key: str, value: Any) -&gt; None:</span>
<span class="gi">+        if key == &quot;children&quot;:</span>
<span class="w"> </span>            raise AssertionError
<span class="w"> </span>        return super().__setattr__(key, value)

<span class="gd">-    def __init__(self, parent: (Symbol | None), ident: (ASTIdentifier |</span>
<span class="gd">-        None), declaration: (ASTDeclaration | None), docname: (str | None),</span>
<span class="gd">-        line: (int | None)) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        parent: Symbol | None,</span>
<span class="gi">+        ident: ASTIdentifier | None,</span>
<span class="gi">+        declaration: ASTDeclaration | None,</span>
<span class="gi">+        docname: str | None,</span>
<span class="gi">+        line: int | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.parent = parent
<span class="gi">+        # declarations in a single directive are linked together</span>
<span class="w"> </span>        self.siblingAbove: Symbol | None = None
<span class="w"> </span>        self.siblingBelow: Symbol | None = None
<span class="w"> </span>        self.ident = ident
<span class="gu">@@ -72,14 +101,555 @@ class Symbol:</span>
<span class="w"> </span>        self.line = line
<span class="w"> </span>        self.isRedeclaration = False
<span class="w"> </span>        self._assert_invariants()
<span class="gi">+</span>
<span class="gi">+        # These properties store the same children for different access patterns.</span>
<span class="gi">+        # ``_add_child()`` and ``_remove_child()`` should be used for modifying them.</span>
<span class="w"> </span>        self._children_by_name: dict[str, Symbol] = {}
<span class="w"> </span>        self._children_by_docname: dict[str, dict[str, Symbol]] = {}
<span class="w"> </span>        self._anon_children: set[Symbol] = set()
<span class="gi">+</span>
<span class="w"> </span>        if self.parent:
<span class="w"> </span>            self.parent._add_child(self)
<span class="w"> </span>        if self.declaration:
<span class="w"> </span>            self.declaration.symbol = self
<span class="gi">+</span>
<span class="gi">+        # Do symbol addition after self._children has been initialised.</span>
<span class="w"> </span>        self._add_function_params()

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return f&#39;&lt;Symbol {self.to_string(indent=0)!r}&gt;&#39;
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def _children(self) -&gt; Iterable[Symbol]:</span>
<span class="gi">+        return self._children_by_name.values()</span>
<span class="gi">+</span>
<span class="gi">+    def _add_child(self, child: Symbol) -&gt; None:</span>
<span class="gi">+        name = child.ident.name</span>
<span class="gi">+        if name in self._children_by_name:</span>
<span class="gi">+            # Duplicate so don&#39;t add - will be reported in _add_symbols()</span>
<span class="gi">+            return</span>
<span class="gi">+        self._children_by_name[name] = child</span>
<span class="gi">+        self._children_by_docname.setdefault(child.docname, {})[name] = child</span>
<span class="gi">+        if child.ident.is_anonymous:</span>
<span class="gi">+            self._anon_children.add(child)</span>
<span class="gi">+</span>
<span class="gi">+    def _remove_child(self, child: Symbol) -&gt; None:</span>
<span class="gi">+        name = child.ident.name</span>
<span class="gi">+        self._children_by_name.pop(name, None)</span>
<span class="gi">+        self._children_by_docname.get(child.docname, {}).pop(name, None)</span>
<span class="gi">+        if child.ident.is_anonymous:</span>
<span class="gi">+            self._anon_children.discard(child)</span>
<span class="gi">+</span>
<span class="gi">+    def _fill_empty(self, declaration: ASTDeclaration, docname: str, line: int) -&gt; None:</span>
<span class="gi">+        self._assert_invariants()</span>
<span class="gi">+        assert self.declaration is None</span>
<span class="gi">+        assert self.docname is None</span>
<span class="gi">+        assert self.line is None</span>
<span class="gi">+        assert declaration is not None</span>
<span class="gi">+        assert docname is not None</span>
<span class="gi">+        assert line is not None</span>
<span class="gi">+        self.declaration = declaration</span>
<span class="gi">+        self.declaration.symbol = self</span>
<span class="gi">+        self.docname = docname</span>
<span class="gi">+        self.line = line</span>
<span class="gi">+        self._assert_invariants()</span>
<span class="gi">+        # and symbol addition should be done as well</span>
<span class="gi">+        self._add_function_params()</span>
<span class="gi">+</span>
<span class="gi">+    def _add_function_params(self) -&gt; None:</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;_add_function_params:&quot;)</span>
<span class="gi">+        # Note: we may be called from _fill_empty, so the symbols we want</span>
<span class="gi">+        #       to add may actually already be present (as empty symbols).</span>
<span class="gi">+</span>
<span class="gi">+        # add symbols for function parameters, if any</span>
<span class="gi">+        if self.declaration is not None and self.declaration.function_params is not None:</span>
<span class="gi">+            for p in self.declaration.function_params:</span>
<span class="gi">+                if p.arg is None:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                nn = p.arg.name</span>
<span class="gi">+                if nn is None:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                # (comparing to the template params: we have checked that we are a declaration)</span>
<span class="gi">+                decl = ASTDeclaration(&#39;functionParam&#39;, None, p)</span>
<span class="gi">+                assert not nn.rooted</span>
<span class="gi">+                assert len(nn.names) == 1</span>
<span class="gi">+                self._add_symbols(nn, decl, self.docname, self.line)</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent -= 1</span>
<span class="gi">+</span>
<span class="gi">+    def remove(self) -&gt; None:</span>
<span class="gi">+        if self.parent:</span>
<span class="gi">+            self.parent._remove_child(self)</span>
<span class="gi">+            self.parent = None</span>
<span class="gi">+</span>
<span class="gi">+    def clear_doc(self, docname: str) -&gt; None:</span>
<span class="gi">+        if docname not in self._children_by_docname:</span>
<span class="gi">+            for child in self._children:</span>
<span class="gi">+                child.clear_doc(docname)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        children: dict[str, Symbol] = self._children_by_docname.pop(docname)</span>
<span class="gi">+        for child in children.values():</span>
<span class="gi">+            child.declaration = None</span>
<span class="gi">+            child.docname = None</span>
<span class="gi">+            child.line = None</span>
<span class="gi">+            if child.siblingAbove is not None:</span>
<span class="gi">+                child.siblingAbove.siblingBelow = child.siblingBelow</span>
<span class="gi">+            if child.siblingBelow is not None:</span>
<span class="gi">+                child.siblingBelow.siblingAbove = child.siblingAbove</span>
<span class="gi">+            child.siblingAbove = None</span>
<span class="gi">+            child.siblingBelow = None</span>
<span class="gi">+            self._remove_child(child)</span>
<span class="gi">+</span>
<span class="gi">+    def get_all_symbols(self) -&gt; Iterator[Symbol]:</span>
<span class="gi">+        yield self</span>
<span class="gi">+        for sChild in self._children:</span>
<span class="gi">+            yield from sChild.get_all_symbols()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def children(self) -&gt; Iterator[Symbol]:</span>
<span class="gi">+        yield from self._children</span>
<span class="gi">+</span>
<span class="gi">+    def get_lookup_key(self) -&gt; LookupKey:</span>
<span class="gi">+        # The pickle files for the environment and for each document are distinct.</span>
<span class="gi">+        # The environment has all the symbols, but the documents has xrefs that</span>
<span class="gi">+        # must know their scope. A lookup key is essentially a specification of</span>
<span class="gi">+        # how to find a specific symbol.</span>
<span class="gi">+        symbols = []</span>
<span class="gi">+        s = self</span>
<span class="gi">+        while s.parent:</span>
<span class="gi">+            symbols.append(s)</span>
<span class="gi">+            s = s.parent</span>
<span class="gi">+        symbols.reverse()</span>
<span class="gi">+        key = []</span>
<span class="gi">+        for s in symbols:</span>
<span class="gi">+            if s.declaration is not None:</span>
<span class="gi">+                # TODO: do we need the ID?</span>
<span class="gi">+                key.append((s.ident, s.declaration.get_newest_id()))</span>
<span class="gi">+            else:</span>
<span class="gi">+                key.append((s.ident, None))</span>
<span class="gi">+        return LookupKey(key)</span>
<span class="gi">+</span>
<span class="gi">+    def get_full_nested_name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        symbols = []</span>
<span class="gi">+        s = self</span>
<span class="gi">+        while s.parent:</span>
<span class="gi">+            symbols.append(s)</span>
<span class="gi">+            s = s.parent</span>
<span class="gi">+        symbols.reverse()</span>
<span class="gi">+        names = [s.ident for s in symbols]</span>
<span class="gi">+        return ASTNestedName(names, rooted=False)</span>
<span class="gi">+</span>
<span class="gi">+    def _symbol_lookup(</span>
<span class="gi">+        self,</span>
<span class="gi">+        nestedName: ASTNestedName,</span>
<span class="gi">+        onMissingQualifiedSymbol: Callable[[Symbol, ASTIdentifier], Symbol | None],</span>
<span class="gi">+        ancestorLookupType: str | None,</span>
<span class="gi">+        matchSelf: bool,</span>
<span class="gi">+        recurseInAnon: bool,</span>
<span class="gi">+        searchInSiblings: bool,</span>
<span class="gi">+    ) -&gt; SymbolLookupResult | None:</span>
<span class="gi">+        # TODO: further simplification from C++ to C</span>
<span class="gi">+        # ancestorLookupType: if not None, specifies the target type of the lookup</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;_symbol_lookup:&quot;)</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;self:&quot;)</span>
<span class="gi">+            logger.debug(self.to_string(Symbol.debug_indent + 1, addEndNewline=False))</span>
<span class="gi">+            Symbol.debug_print(&quot;nestedName:        &quot;, nestedName)</span>
<span class="gi">+            Symbol.debug_print(&quot;ancestorLookupType:&quot;, ancestorLookupType)</span>
<span class="gi">+            Symbol.debug_print(&quot;matchSelf:         &quot;, matchSelf)</span>
<span class="gi">+            Symbol.debug_print(&quot;recurseInAnon:     &quot;, recurseInAnon)</span>
<span class="gi">+            Symbol.debug_print(&quot;searchInSiblings:  &quot;, searchInSiblings)</span>
<span class="gi">+</span>
<span class="gi">+        names = nestedName.names</span>
<span class="gi">+</span>
<span class="gi">+        # find the right starting point for lookup</span>
<span class="gi">+        parentSymbol = self</span>
<span class="gi">+        if nestedName.rooted:</span>
<span class="gi">+            while parentSymbol.parent is not None:</span>
<span class="gi">+                parentSymbol = parentSymbol.parent</span>
<span class="gi">+</span>
<span class="gi">+        if ancestorLookupType is not None:</span>
<span class="gi">+            # walk up until we find the first identifier</span>
<span class="gi">+            firstName = names[0]</span>
<span class="gi">+            while parentSymbol.parent:</span>
<span class="gi">+                if firstName.name in parentSymbol._children_by_name:</span>
<span class="gi">+                    break</span>
<span class="gi">+                parentSymbol = parentSymbol.parent</span>
<span class="gi">+</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_print(&quot;starting point:&quot;)</span>
<span class="gi">+            logger.debug(parentSymbol.to_string(Symbol.debug_indent + 1, addEndNewline=False))</span>
<span class="gi">+</span>
<span class="gi">+        # and now the actual lookup</span>
<span class="gi">+        for ident in names[:-1]:</span>
<span class="gi">+            name = ident.name</span>
<span class="gi">+            if name in parentSymbol._children_by_name:</span>
<span class="gi">+                symbol = parentSymbol._children_by_name[name]</span>
<span class="gi">+            else:</span>
<span class="gi">+                symbol = onMissingQualifiedSymbol(parentSymbol, ident)</span>
<span class="gi">+                if symbol is None:</span>
<span class="gi">+                    if Symbol.debug_lookup:</span>
<span class="gi">+                        Symbol.debug_indent -= 2</span>
<span class="gi">+                    return None</span>
<span class="gi">+            parentSymbol = symbol</span>
<span class="gi">+</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_print(&quot;handle last name from:&quot;)</span>
<span class="gi">+            logger.debug(parentSymbol.to_string(Symbol.debug_indent + 1, addEndNewline=False))</span>
<span class="gi">+</span>
<span class="gi">+        # handle the last name</span>
<span class="gi">+        ident = names[-1]</span>
<span class="gi">+        name = ident.name</span>
<span class="gi">+        symbol = parentSymbol._children_by_name.get(name)</span>
<span class="gi">+        if not symbol and recurseInAnon:</span>
<span class="gi">+            for child in parentSymbol._anon_children:</span>
<span class="gi">+                if name in child._children_by_name:</span>
<span class="gi">+                    symbol = child._children_by_name[name]</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent -= 2</span>
<span class="gi">+</span>
<span class="gi">+        result = [symbol] if symbol else []</span>
<span class="gi">+        return SymbolLookupResult(result, parentSymbol, ident)</span>
<span class="gi">+</span>
<span class="gi">+    def _add_symbols(</span>
<span class="gi">+        self,</span>
<span class="gi">+        nestedName: ASTNestedName,</span>
<span class="gi">+        declaration: ASTDeclaration | None,</span>
<span class="gi">+        docname: str | None,</span>
<span class="gi">+        line: int | None,</span>
<span class="gi">+    ) -&gt; Symbol:</span>
<span class="gi">+        # TODO: further simplification from C++ to C</span>
<span class="gi">+        # Used for adding a whole path of symbols, where the last may or may not</span>
<span class="gi">+        # be an actual declaration.</span>
<span class="gi">+</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;_add_symbols:&quot;)</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;nn:       &quot;, nestedName)</span>
<span class="gi">+            Symbol.debug_print(&quot;decl:     &quot;, declaration)</span>
<span class="gi">+            Symbol.debug_print(f&quot;location: {docname}:{line}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        def onMissingQualifiedSymbol(parentSymbol: Symbol, ident: ASTIdentifier) -&gt; Symbol:</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_indent += 1</span>
<span class="gi">+                Symbol.debug_print(&quot;_add_symbols, onMissingQualifiedSymbol:&quot;)</span>
<span class="gi">+                Symbol.debug_indent += 1</span>
<span class="gi">+                Symbol.debug_print(&quot;ident: &quot;, ident)</span>
<span class="gi">+                Symbol.debug_indent -= 2</span>
<span class="gi">+            return Symbol(parent=parentSymbol, ident=ident,</span>
<span class="gi">+                          declaration=None, docname=None, line=None)</span>
<span class="gi">+</span>
<span class="gi">+        lookupResult = self._symbol_lookup(nestedName,</span>
<span class="gi">+                                           onMissingQualifiedSymbol,</span>
<span class="gi">+                                           ancestorLookupType=None,</span>
<span class="gi">+                                           matchSelf=False,</span>
<span class="gi">+                                           recurseInAnon=False,</span>
<span class="gi">+                                           searchInSiblings=False)</span>
<span class="gi">+        assert lookupResult is not None  # we create symbols all the way, so that can&#39;t happen</span>
<span class="gi">+        symbols = list(lookupResult.symbols)</span>
<span class="gi">+        if len(symbols) == 0:</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_print(&quot;_add_symbols, result, no symbol:&quot;)</span>
<span class="gi">+                Symbol.debug_indent += 1</span>
<span class="gi">+                Symbol.debug_print(&quot;ident:       &quot;, lookupResult.ident)</span>
<span class="gi">+                Symbol.debug_print(&quot;declaration: &quot;, declaration)</span>
<span class="gi">+                Symbol.debug_print(f&quot;location:    {docname}:{line}&quot;)</span>
<span class="gi">+                Symbol.debug_indent -= 1</span>
<span class="gi">+            symbol = Symbol(parent=lookupResult.parentSymbol,</span>
<span class="gi">+                            ident=lookupResult.ident,</span>
<span class="gi">+                            declaration=declaration,</span>
<span class="gi">+                            docname=docname, line=line)</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_indent -= 2</span>
<span class="gi">+            return symbol</span>
<span class="gi">+</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_print(&quot;_add_symbols, result, symbols:&quot;)</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;number symbols:&quot;, len(symbols))</span>
<span class="gi">+            Symbol.debug_indent -= 1</span>
<span class="gi">+</span>
<span class="gi">+        if not declaration:</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_print(&quot;no declaration&quot;)</span>
<span class="gi">+                Symbol.debug_indent -= 2</span>
<span class="gi">+            # good, just a scope creation</span>
<span class="gi">+            # TODO: what if we have more than one symbol?</span>
<span class="gi">+            return symbols[0]</span>
<span class="gi">+</span>
<span class="gi">+        noDecl = []</span>
<span class="gi">+        withDecl = []</span>
<span class="gi">+        dupDecl = []</span>
<span class="gi">+        for s in symbols:</span>
<span class="gi">+            if s.declaration is None:</span>
<span class="gi">+                noDecl.append(s)</span>
<span class="gi">+            elif s.isRedeclaration:</span>
<span class="gi">+                dupDecl.append(s)</span>
<span class="gi">+            else:</span>
<span class="gi">+                withDecl.append(s)</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_print(&quot;#noDecl:  &quot;, len(noDecl))</span>
<span class="gi">+            Symbol.debug_print(&quot;#withDecl:&quot;, len(withDecl))</span>
<span class="gi">+            Symbol.debug_print(&quot;#dupDecl: &quot;, len(dupDecl))</span>
<span class="gi">+</span>
<span class="gi">+        # With partial builds we may start with a large symbol tree stripped of declarations.</span>
<span class="gi">+        # Essentially any combination of noDecl, withDecl, and dupDecls seems possible.</span>
<span class="gi">+        # TODO: make partial builds fully work. What should happen when the primary symbol gets</span>
<span class="gi">+        #  deleted, and other duplicates exist? The full document should probably be rebuild.</span>
<span class="gi">+</span>
<span class="gi">+        # First check if one of those with a declaration matches.</span>
<span class="gi">+        # If it&#39;s a function, we need to compare IDs,</span>
<span class="gi">+        # otherwise there should be only one symbol with a declaration.</span>
<span class="gi">+        def makeCandSymbol() -&gt; Symbol:</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_print(&quot;begin: creating candidate symbol&quot;)</span>
<span class="gi">+            symbol = Symbol(parent=lookupResult.parentSymbol,</span>
<span class="gi">+                            ident=lookupResult.ident,</span>
<span class="gi">+                            declaration=declaration,</span>
<span class="gi">+                            docname=docname, line=line)</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_print(&quot;end:   creating candidate symbol&quot;)</span>
<span class="gi">+            return symbol</span>
<span class="gi">+</span>
<span class="gi">+        if len(withDecl) == 0:</span>
<span class="gi">+            candSymbol = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            candSymbol = makeCandSymbol()</span>
<span class="gi">+</span>
<span class="gi">+            def handleDuplicateDeclaration(symbol: Symbol, candSymbol: Symbol) -&gt; None:</span>
<span class="gi">+                if Symbol.debug_lookup:</span>
<span class="gi">+                    Symbol.debug_indent += 1</span>
<span class="gi">+                    Symbol.debug_print(&quot;redeclaration&quot;)</span>
<span class="gi">+                    Symbol.debug_indent -= 1</span>
<span class="gi">+                    Symbol.debug_indent -= 2</span>
<span class="gi">+                # Redeclaration of the same symbol.</span>
<span class="gi">+                # Let the new one be there, but raise an error to the client</span>
<span class="gi">+                # so it can use the real symbol as subscope.</span>
<span class="gi">+                # This will probably result in a duplicate id warning.</span>
<span class="gi">+                candSymbol.isRedeclaration = True</span>
<span class="gi">+                raise _DuplicateSymbolError(symbol, declaration)</span>
<span class="gi">+</span>
<span class="gi">+            if declaration.objectType != &quot;function&quot;:</span>
<span class="gi">+                assert len(withDecl) &lt;= 1</span>
<span class="gi">+                handleDuplicateDeclaration(withDecl[0], candSymbol)</span>
<span class="gi">+                # (not reachable)</span>
<span class="gi">+</span>
<span class="gi">+            # a function, so compare IDs</span>
<span class="gi">+            candId = declaration.get_newest_id()</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_print(&quot;candId:&quot;, candId)</span>
<span class="gi">+            for symbol in withDecl:</span>
<span class="gi">+                oldId = symbol.declaration.get_newest_id()</span>
<span class="gi">+                if Symbol.debug_lookup:</span>
<span class="gi">+                    Symbol.debug_print(&quot;oldId: &quot;, oldId)</span>
<span class="gi">+                if candId == oldId:</span>
<span class="gi">+                    handleDuplicateDeclaration(symbol, candSymbol)</span>
<span class="gi">+                    # (not reachable)</span>
<span class="gi">+            # no candidate symbol found with matching ID</span>
<span class="gi">+        # if there is an empty symbol, fill that one</span>
<span class="gi">+        if len(noDecl) == 0:</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_print(</span>
<span class="gi">+                    &quot;no match, no empty, candSybmol is not None?:&quot;, candSymbol is not None,</span>
<span class="gi">+                )</span>
<span class="gi">+                Symbol.debug_indent -= 2</span>
<span class="gi">+            if candSymbol is not None:</span>
<span class="gi">+                return candSymbol</span>
<span class="gi">+            else:</span>
<span class="gi">+                return makeCandSymbol()</span>
<span class="gi">+        else:</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_print(</span>
<span class="gi">+                    &quot;no match, but fill an empty declaration, candSybmol is not None?:&quot;,</span>
<span class="gi">+                    candSymbol is not None)</span>
<span class="gi">+                Symbol.debug_indent -= 2</span>
<span class="gi">+            if candSymbol is not None:</span>
<span class="gi">+                candSymbol.remove()</span>
<span class="gi">+            # assert len(noDecl) == 1</span>
<span class="gi">+            # TODO: enable assertion when we at some point find out how to do cleanup</span>
<span class="gi">+            # for now, just take the first one, it should work fine ... right?</span>
<span class="gi">+            symbol = noDecl[0]</span>
<span class="gi">+            # If someone first opened the scope, and then later</span>
<span class="gi">+            # declares it, e.g,</span>
<span class="gi">+            # .. namespace:: Test</span>
<span class="gi">+            # .. namespace:: nullptr</span>
<span class="gi">+            # .. class:: Test</span>
<span class="gi">+            symbol._fill_empty(declaration, docname, line)</span>
<span class="gi">+            return symbol</span>
<span class="gi">+</span>
<span class="gi">+    def merge_with(self, other: Symbol, docnames: list[str],</span>
<span class="gi">+                   env: BuildEnvironment) -&gt; None:</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;merge_with:&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        assert other is not None</span>
<span class="gi">+        for otherChild in other._children:</span>
<span class="gi">+            otherName = otherChild.ident.name</span>
<span class="gi">+            if otherName not in self._children_by_name:</span>
<span class="gi">+                # TODO: hmm, should we prune by docnames?</span>
<span class="gi">+                otherChild.parent = self</span>
<span class="gi">+                self._add_child(otherChild)</span>
<span class="gi">+                otherChild._assert_invariants()</span>
<span class="gi">+                continue</span>
<span class="gi">+            ourChild = self._children_by_name[otherName]</span>
<span class="gi">+            if otherChild.declaration and otherChild.docname in docnames:</span>
<span class="gi">+                if not ourChild.declaration:</span>
<span class="gi">+                    ourChild._fill_empty(otherChild.declaration,</span>
<span class="gi">+                                         otherChild.docname, otherChild.line)</span>
<span class="gi">+                elif ourChild.docname != otherChild.docname:</span>
<span class="gi">+                    name = str(ourChild.declaration)</span>
<span class="gi">+                    msg = __(&quot;Duplicate C declaration, also defined at %s:%s.\n&quot;</span>
<span class="gi">+                             &quot;Declaration is &#39;.. c:%s:: %s&#39;.&quot;)</span>
<span class="gi">+                    msg = msg % (ourChild.docname, ourChild.line,</span>
<span class="gi">+                                 ourChild.declaration.directiveType, name)</span>
<span class="gi">+                    logger.warning(msg, location=(otherChild.docname, otherChild.line))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # Both have declarations, and in the same docname.</span>
<span class="gi">+                    # This can apparently happen, it should be safe to</span>
<span class="gi">+                    # just ignore it, right?</span>
<span class="gi">+                    pass</span>
<span class="gi">+            ourChild.merge_with(otherChild, docnames, env)</span>
<span class="gi">+</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent -= 1</span>
<span class="gi">+</span>
<span class="gi">+    def add_name(self, nestedName: ASTNestedName) -&gt; Symbol:</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;add_name:&quot;)</span>
<span class="gi">+        res = self._add_symbols(nestedName, declaration=None, docname=None, line=None)</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent -= 1</span>
<span class="gi">+        return res</span>
<span class="gi">+</span>
<span class="gi">+    def add_declaration(self, declaration: ASTDeclaration,</span>
<span class="gi">+                        docname: str, line: int) -&gt; Symbol:</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;add_declaration:&quot;)</span>
<span class="gi">+        assert declaration is not None</span>
<span class="gi">+        assert docname is not None</span>
<span class="gi">+        assert line is not None</span>
<span class="gi">+        nestedName = declaration.name</span>
<span class="gi">+        res = self._add_symbols(nestedName, declaration, docname, line)</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent -= 1</span>
<span class="gi">+        return res</span>
<span class="gi">+</span>
<span class="gi">+    def find_identifier(self, ident: ASTIdentifier,</span>
<span class="gi">+                        matchSelf: bool, recurseInAnon: bool, searchInSiblings: bool,</span>
<span class="gi">+                        ) -&gt; Symbol | None:</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;find_identifier:&quot;)</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;ident:           &quot;, ident)</span>
<span class="gi">+            Symbol.debug_print(&quot;matchSelf:       &quot;, matchSelf)</span>
<span class="gi">+            Symbol.debug_print(&quot;recurseInAnon:   &quot;, recurseInAnon)</span>
<span class="gi">+            Symbol.debug_print(&quot;searchInSiblings:&quot;, searchInSiblings)</span>
<span class="gi">+            logger.debug(self.to_string(Symbol.debug_indent + 1, addEndNewline=False))</span>
<span class="gi">+            Symbol.debug_indent -= 2</span>
<span class="gi">+        current = self</span>
<span class="gi">+        while current is not None:</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_indent += 2</span>
<span class="gi">+                Symbol.debug_print(&quot;trying:&quot;)</span>
<span class="gi">+                logger.debug(current.to_string(Symbol.debug_indent + 1, addEndNewline=False))</span>
<span class="gi">+                Symbol.debug_indent -= 2</span>
<span class="gi">+            if matchSelf and current.ident == ident:</span>
<span class="gi">+                return current</span>
<span class="gi">+            name = ident.name</span>
<span class="gi">+            if name in current._children_by_name:</span>
<span class="gi">+                return current._children_by_name[name]</span>
<span class="gi">+            if recurseInAnon:</span>
<span class="gi">+                for child in current._anon_children:</span>
<span class="gi">+                    if name in child._children_by_name:</span>
<span class="gi">+                        return child._children_by_name[name]</span>
<span class="gi">+            if not searchInSiblings:</span>
<span class="gi">+                break</span>
<span class="gi">+            current = current.siblingAbove</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def direct_lookup(self, key: LookupKey) -&gt; Symbol | None:</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;direct_lookup:&quot;)</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+        s = self</span>
<span class="gi">+        for ident, id_ in key.data:</span>
<span class="gi">+            s = s._children_by_name.get(ident.name)</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_print(&quot;name:          &quot;, ident.name)</span>
<span class="gi">+                Symbol.debug_print(&quot;id:            &quot;, id_)</span>
<span class="gi">+                if s is not None:</span>
<span class="gi">+                    logger.debug(s.to_string(Symbol.debug_indent + 1, addEndNewline=False))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    Symbol.debug_print(&quot;not found&quot;)</span>
<span class="gi">+            if s is None:</span>
<span class="gi">+                break</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent -= 2</span>
<span class="gi">+        return s</span>
<span class="gi">+</span>
<span class="gi">+    def find_declaration(self, nestedName: ASTNestedName, typ: str,</span>
<span class="gi">+                         matchSelf: bool, recurseInAnon: bool) -&gt; Symbol | None:</span>
<span class="gi">+        # templateShorthand: missing template parameter lists for templates is ok</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;find_declaration:&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        def onMissingQualifiedSymbol(</span>
<span class="gi">+            parentSymbol: Symbol,</span>
<span class="gi">+            ident: ASTIdentifier,</span>
<span class="gi">+        ) -&gt; Symbol | None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        lookupResult = self._symbol_lookup(nestedName,</span>
<span class="gi">+                                           onMissingQualifiedSymbol,</span>
<span class="gi">+                                           ancestorLookupType=typ,</span>
<span class="gi">+                                           matchSelf=matchSelf,</span>
<span class="gi">+                                           recurseInAnon=recurseInAnon,</span>
<span class="gi">+                                           searchInSiblings=False)</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent -= 1</span>
<span class="gi">+        if lookupResult is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        symbols = list(lookupResult.symbols)</span>
<span class="gi">+        if len(symbols) == 0:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return symbols[0]</span>
<span class="gi">+</span>
<span class="gi">+    def to_string(self, indent: int, *, addEndNewline: bool = True) -&gt; str:</span>
<span class="gi">+        res = [Symbol.debug_indent_string * indent]</span>
<span class="gi">+        if not self.parent:</span>
<span class="gi">+            res.append(&#39;::&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self.ident:</span>
<span class="gi">+                res.append(self.ident.name)</span>
<span class="gi">+            else:</span>
<span class="gi">+                res.append(str(self.declaration))</span>
<span class="gi">+            if self.declaration:</span>
<span class="gi">+                res.append(&quot;: &quot;)</span>
<span class="gi">+                if self.isRedeclaration:</span>
<span class="gi">+                    res.append(&#39;!!duplicate!! &#39;)</span>
<span class="gi">+                res.append(str(self.declaration))</span>
<span class="gi">+        if self.docname:</span>
<span class="gi">+            res.append(&#39;\t(&#39;)</span>
<span class="gi">+            res.append(self.docname)</span>
<span class="gi">+            res.append(&#39;)&#39;)</span>
<span class="gi">+        if addEndNewline:</span>
<span class="gi">+            res.append(&#39;\n&#39;)</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def dump(self, indent: int) -&gt; str:</span>
<span class="gi">+        return &#39;&#39;.join([self.to_string(indent), *(c.dump(indent + 1) for c in self._children)])</span>
<span class="gh">diff --git a/sphinx/domains/changeset.py b/sphinx/domains/changeset.py</span>
<span class="gh">index dab2cbaf4..cc1d4a338 100644</span>
<span class="gd">--- a/sphinx/domains/changeset.py</span>
<span class="gi">+++ b/sphinx/domains/changeset.py</span>
<span class="gu">@@ -1,22 +1,37 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The changeset domain.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any, ClassVar, NamedTuple, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.domains import Domain
<span class="w"> </span>from sphinx.locale import _
<span class="w"> </span>from sphinx.util.docutils import SphinxDirective
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.nodes import Node
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata, OptionSpec
<span class="gd">-versionlabels = {&#39;versionadded&#39;: _(&#39;Added in version %s&#39;), &#39;versionchanged&#39;:</span>
<span class="gd">-    _(&#39;Changed in version %s&#39;), &#39;deprecated&#39;: _(</span>
<span class="gd">-    &#39;Deprecated since version %s&#39;), &#39;versionremoved&#39;: _(</span>
<span class="gd">-    &#39;Removed in version %s&#39;)}</span>
<span class="gd">-versionlabel_classes = {&#39;versionadded&#39;: &#39;added&#39;, &#39;versionchanged&#39;:</span>
<span class="gd">-    &#39;changed&#39;, &#39;deprecated&#39;: &#39;deprecated&#39;, &#39;versionremoved&#39;: &#39;removed&#39;}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+versionlabels = {</span>
<span class="gi">+    &#39;versionadded&#39;:   _(&#39;Added in version %s&#39;),</span>
<span class="gi">+    &#39;versionchanged&#39;: _(&#39;Changed in version %s&#39;),</span>
<span class="gi">+    &#39;deprecated&#39;:     _(&#39;Deprecated since version %s&#39;),</span>
<span class="gi">+    &#39;versionremoved&#39;: _(&#39;Removed in version %s&#39;),</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+versionlabel_classes = {</span>
<span class="gi">+    &#39;versionadded&#39;:     &#39;added&#39;,</span>
<span class="gi">+    &#39;versionchanged&#39;:   &#39;changed&#39;,</span>
<span class="gi">+    &#39;deprecated&#39;:       &#39;deprecated&#39;,</span>
<span class="gi">+    &#39;versionremoved&#39;:   &#39;removed&#39;,</span>
<span class="gi">+}</span>


<span class="w"> </span>class ChangeSet(NamedTuple):
<span class="gu">@@ -32,15 +47,118 @@ class VersionChange(SphinxDirective):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Directive to describe a change/addition/deprecation in a specific version.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    has_content = True
<span class="w"> </span>    required_arguments = 1
<span class="w"> </span>    optional_arguments = 1
<span class="w"> </span>    final_argument_whitespace = True
<span class="w"> </span>    option_spec: ClassVar[OptionSpec] = {}

<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        node = addnodes.versionmodified()</span>
<span class="gi">+        node.document = self.state.document</span>
<span class="gi">+        self.set_source_info(node)</span>
<span class="gi">+        node[&#39;type&#39;] = self.name</span>
<span class="gi">+        node[&#39;version&#39;] = self.arguments[0]</span>
<span class="gi">+        text = versionlabels[self.name] % self.arguments[0]</span>
<span class="gi">+        if len(self.arguments) == 2:</span>
<span class="gi">+            inodes, messages = self.parse_inline(self.arguments[1], lineno=self.lineno + 1)</span>
<span class="gi">+            para = nodes.paragraph(self.arguments[1], &#39;&#39;, *inodes, translatable=False)</span>
<span class="gi">+            self.set_source_info(para)</span>
<span class="gi">+            node.append(para)</span>
<span class="gi">+        else:</span>
<span class="gi">+            messages = []</span>
<span class="gi">+        if self.content:</span>
<span class="gi">+            node += self.parse_content_to_nodes()</span>
<span class="gi">+        classes = [&#39;versionmodified&#39;, versionlabel_classes[self.name]]</span>
<span class="gi">+        if len(node) &gt; 0 and isinstance(node[0], nodes.paragraph):</span>
<span class="gi">+            # the contents start with a paragraph</span>
<span class="gi">+            if node[0].rawsource:</span>
<span class="gi">+                # make the first paragraph translatable</span>
<span class="gi">+                content = nodes.inline(node[0].rawsource, translatable=True)</span>
<span class="gi">+                content.source = node[0].source</span>
<span class="gi">+                content.line = node[0].line</span>
<span class="gi">+                content += node[0].children</span>
<span class="gi">+                node[0].replace_self(nodes.paragraph(&#39;&#39;, &#39;&#39;, content, translatable=False))</span>
<span class="gi">+</span>
<span class="gi">+            para = node[0]</span>
<span class="gi">+            para.insert(0, nodes.inline(&#39;&#39;, &#39;%s: &#39; % text, classes=classes))</span>
<span class="gi">+        elif len(node) &gt; 0:</span>
<span class="gi">+            # the contents do not starts with a paragraph</span>
<span class="gi">+            para = nodes.paragraph(&#39;&#39;, &#39;&#39;,</span>
<span class="gi">+                                   nodes.inline(&#39;&#39;, &#39;%s: &#39; % text, classes=classes),</span>
<span class="gi">+                                   translatable=False)</span>
<span class="gi">+            node.insert(0, para)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # the contents are empty</span>
<span class="gi">+            para = nodes.paragraph(&#39;&#39;, &#39;&#39;,</span>
<span class="gi">+                                   nodes.inline(&#39;&#39;, &#39;%s.&#39; % text, classes=classes),</span>
<span class="gi">+                                   translatable=False)</span>
<span class="gi">+            node.append(para)</span>
<span class="gi">+</span>
<span class="gi">+        domain = cast(ChangeSetDomain, self.env.get_domain(&#39;changeset&#39;))</span>
<span class="gi">+        domain.note_changeset(node)</span>
<span class="gi">+</span>
<span class="gi">+        ret: list[Node] = [node]</span>
<span class="gi">+        ret += messages</span>
<span class="gi">+        return ret</span>
<span class="gi">+</span>

<span class="w"> </span>class ChangeSetDomain(Domain):
<span class="w"> </span>    &quot;&quot;&quot;Domain for changesets.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name = &#39;changeset&#39;
<span class="w"> </span>    label = &#39;changeset&#39;
<span class="gd">-    initial_data: dict[str, dict[str, list[ChangeSet]]] = {&#39;changes&#39;: {}}</span>
<span class="gi">+</span>
<span class="gi">+    initial_data: dict[str, dict[str, list[ChangeSet]]] = {</span>
<span class="gi">+        &#39;changes&#39;: {},      # version -&gt; list of ChangeSet</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def changesets(self) -&gt; dict[str, list[ChangeSet]]:</span>
<span class="gi">+        return self.data.setdefault(&#39;changes&#39;, {})  # version -&gt; list of ChangeSet</span>
<span class="gi">+</span>
<span class="gi">+    def note_changeset(self, node: addnodes.versionmodified) -&gt; None:</span>
<span class="gi">+        version = node[&#39;version&#39;]</span>
<span class="gi">+        module = self.env.ref_context.get(&#39;py:module&#39;)</span>
<span class="gi">+        objname = self.env.temp_data.get(&#39;object&#39;)</span>
<span class="gi">+        changeset = ChangeSet(node[&#39;type&#39;], self.env.docname, node.line,  # type: ignore[arg-type]</span>
<span class="gi">+                              module, objname, node.astext())</span>
<span class="gi">+        self.changesets.setdefault(version, []).append(changeset)</span>
<span class="gi">+</span>
<span class="gi">+    def clear_doc(self, docname: str) -&gt; None:</span>
<span class="gi">+        for changes in self.changesets.values():</span>
<span class="gi">+            for changeset in changes.copy():</span>
<span class="gi">+                if changeset.docname == docname:</span>
<span class="gi">+                    changes.remove(changeset)</span>
<span class="gi">+</span>
<span class="gi">+    def merge_domaindata(self, docnames: list[str], otherdata: dict[str, Any]) -&gt; None:</span>
<span class="gi">+        # XXX duplicates?</span>
<span class="gi">+        for version, otherchanges in otherdata[&#39;changes&#39;].items():</span>
<span class="gi">+            changes = self.changesets.setdefault(version, [])</span>
<span class="gi">+            for changeset in otherchanges:</span>
<span class="gi">+                if changeset.docname in docnames:</span>
<span class="gi">+                    changes.append(changeset)</span>
<span class="gi">+</span>
<span class="gi">+    def process_doc(</span>
<span class="gi">+        self, env: BuildEnvironment, docname: str, document: nodes.document,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        pass  # nothing to do here. All changesets are registered on calling directive.</span>
<span class="gi">+</span>
<span class="gi">+    def get_changesets_for(self, version: str) -&gt; list[ChangeSet]:</span>
<span class="gi">+        return self.changesets.get(version, [])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_domain(ChangeSetDomain)</span>
<span class="gi">+    app.add_directive(&#39;deprecated&#39;, VersionChange)</span>
<span class="gi">+    app.add_directive(&#39;versionadded&#39;, VersionChange)</span>
<span class="gi">+    app.add_directive(&#39;versionchanged&#39;, VersionChange)</span>
<span class="gi">+    app.add_directive(&#39;versionremoved&#39;, VersionChange)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;env_version&#39;: 1,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/domains/citation.py b/sphinx/domains/citation.py</span>
<span class="gh">index f8da22b79..4f00feb81 100644</span>
<span class="gd">--- a/sphinx/domains/citation.py</span>
<span class="gi">+++ b/sphinx/domains/citation.py</span>
<span class="gu">@@ -1,37 +1,157 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The citation domain.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>from sphinx.addnodes import pending_xref
<span class="w"> </span>from sphinx.domains import Domain
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.transforms import SphinxTransform
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.nodes import copy_source_info, make_refnode
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.nodes import Element
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.builders import Builder
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="w"> </span>class CitationDomain(Domain):
<span class="w"> </span>    &quot;&quot;&quot;Domain for citations.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name = &#39;citation&#39;
<span class="w"> </span>    label = &#39;citation&#39;
<span class="gd">-    dangling_warnings = {&#39;ref&#39;: &#39;citation not found: %(target)s&#39;}</span>
<span class="gi">+</span>
<span class="gi">+    dangling_warnings = {</span>
<span class="gi">+        &#39;ref&#39;: &#39;citation not found: %(target)s&#39;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def citations(self) -&gt; dict[str, tuple[str, str, int]]:</span>
<span class="gi">+        return self.data.setdefault(&#39;citations&#39;, {})</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def citation_refs(self) -&gt; dict[str, set[str]]:</span>
<span class="gi">+        return self.data.setdefault(&#39;citation_refs&#39;, {})</span>
<span class="gi">+</span>
<span class="gi">+    def clear_doc(self, docname: str) -&gt; None:</span>
<span class="gi">+        for key, (fn, _l, _lineno) in list(self.citations.items()):</span>
<span class="gi">+            if fn == docname:</span>
<span class="gi">+                del self.citations[key]</span>
<span class="gi">+        for key, docnames in list(self.citation_refs.items()):</span>
<span class="gi">+            if docnames == {docname}:</span>
<span class="gi">+                del self.citation_refs[key]</span>
<span class="gi">+            elif docname in docnames:</span>
<span class="gi">+                docnames.remove(docname)</span>
<span class="gi">+</span>
<span class="gi">+    def merge_domaindata(self, docnames: list[str], otherdata: dict[str, Any]) -&gt; None:</span>
<span class="gi">+        # XXX duplicates?</span>
<span class="gi">+        for key, data in otherdata[&#39;citations&#39;].items():</span>
<span class="gi">+            if data[0] in docnames:</span>
<span class="gi">+                self.citations[key] = data</span>
<span class="gi">+        for key, data in otherdata[&#39;citation_refs&#39;].items():</span>
<span class="gi">+            citation_refs = self.citation_refs.setdefault(key, set())</span>
<span class="gi">+            for docname in data:</span>
<span class="gi">+                if docname in docnames:</span>
<span class="gi">+                    citation_refs.add(docname)</span>
<span class="gi">+</span>
<span class="gi">+    def note_citation(self, node: nodes.citation) -&gt; None:</span>
<span class="gi">+        label = node[0].astext()</span>
<span class="gi">+        if label in self.citations:</span>
<span class="gi">+            path = self.env.doc2path(self.citations[label][0])</span>
<span class="gi">+            logger.warning(__(&#39;duplicate citation %s, other instance in %s&#39;), label, path,</span>
<span class="gi">+                           location=node, type=&#39;ref&#39;, subtype=&#39;citation&#39;)</span>
<span class="gi">+        self.citations[label] = (node[&#39;docname&#39;], node[&#39;ids&#39;][0], node.line)  # type: ignore[assignment]</span>
<span class="gi">+</span>
<span class="gi">+    def note_citation_reference(self, node: pending_xref) -&gt; None:</span>
<span class="gi">+        docnames = self.citation_refs.setdefault(node[&#39;reftarget&#39;], set())</span>
<span class="gi">+        docnames.add(self.env.docname)</span>
<span class="gi">+</span>
<span class="gi">+    def check_consistency(self) -&gt; None:</span>
<span class="gi">+        for name, (docname, _labelid, lineno) in self.citations.items():</span>
<span class="gi">+            if name not in self.citation_refs:</span>
<span class="gi">+                logger.warning(__(&#39;Citation [%s] is not referenced.&#39;), name,</span>
<span class="gi">+                               type=&#39;ref&#39;, subtype=&#39;citation&#39;, location=(docname, lineno))</span>
<span class="gi">+</span>
<span class="gi">+    def resolve_xref(self, env: BuildEnvironment, fromdocname: str, builder: Builder,</span>
<span class="gi">+                     typ: str, target: str, node: pending_xref, contnode: Element,</span>
<span class="gi">+                     ) -&gt; Element | None:</span>
<span class="gi">+        docname, labelid, lineno = self.citations.get(target, (&#39;&#39;, &#39;&#39;, 0))</span>
<span class="gi">+        if not docname:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        return make_refnode(builder, fromdocname, docname,</span>
<span class="gi">+                            labelid, contnode)</span>
<span class="gi">+</span>
<span class="gi">+    def resolve_any_xref(self, env: BuildEnvironment, fromdocname: str, builder: Builder,</span>
<span class="gi">+                         target: str, node: pending_xref, contnode: Element,</span>
<span class="gi">+                         ) -&gt; list[tuple[str, Element]]:</span>
<span class="gi">+        refnode = self.resolve_xref(env, fromdocname, builder, &#39;ref&#39;, target, node, contnode)</span>
<span class="gi">+        if refnode is None:</span>
<span class="gi">+            return []</span>
<span class="gi">+        else:</span>
<span class="gi">+            return [(&#39;ref&#39;, refnode)]</span>


<span class="w"> </span>class CitationDefinitionTransform(SphinxTransform):
<span class="w"> </span>    &quot;&quot;&quot;Mark citation definition labels as not smartquoted.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    default_priority = 619

<span class="gi">+    def apply(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        domain = cast(CitationDomain, self.env.get_domain(&#39;citation&#39;))</span>
<span class="gi">+        for node in self.document.findall(nodes.citation):</span>
<span class="gi">+            # register citation node to domain</span>
<span class="gi">+            node[&#39;docname&#39;] = self.env.docname</span>
<span class="gi">+            domain.note_citation(node)</span>
<span class="gi">+</span>
<span class="gi">+            # mark citation labels as not smartquoted</span>
<span class="gi">+            label = cast(nodes.label, node[0])</span>
<span class="gi">+            label[&#39;support_smartquotes&#39;] = False</span>
<span class="gi">+</span>

<span class="w"> </span>class CitationReferenceTransform(SphinxTransform):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Replace citation references by pending_xref nodes before the default
<span class="w"> </span>    docutils transform tries to resolve them.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    default_priority = 619
<span class="gi">+</span>
<span class="gi">+    def apply(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        domain = cast(CitationDomain, self.env.get_domain(&#39;citation&#39;))</span>
<span class="gi">+        for node in self.document.findall(nodes.citation_reference):</span>
<span class="gi">+            target = node.astext()</span>
<span class="gi">+            ref = pending_xref(target, refdomain=&#39;citation&#39;, reftype=&#39;ref&#39;,</span>
<span class="gi">+                               reftarget=target, refwarn=True,</span>
<span class="gi">+                               support_smartquotes=False,</span>
<span class="gi">+                               ids=node[&quot;ids&quot;],</span>
<span class="gi">+                               classes=node.get(&#39;classes&#39;, []))</span>
<span class="gi">+            ref += nodes.inline(target, &#39;[%s]&#39; % target)</span>
<span class="gi">+            copy_source_info(node, ref)</span>
<span class="gi">+            node.replace_self(ref)</span>
<span class="gi">+</span>
<span class="gi">+            # register reference node to domain</span>
<span class="gi">+            domain.note_citation_reference(ref)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_domain(CitationDomain)</span>
<span class="gi">+    app.add_transform(CitationDefinitionTransform)</span>
<span class="gi">+    app.add_transform(CitationReferenceTransform)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;env_version&#39;: 1,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/domains/cpp/_ast.py b/sphinx/domains/cpp/_ast.py</span>
<span class="gh">index 48f498a13..e97756344 100644</span>
<span class="gd">--- a/sphinx/domains/cpp/_ast.py</span>
<span class="gi">+++ b/sphinx/domains/cpp/_ast.py</span>
<span class="gu">@@ -1,13 +1,36 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>import warnings
<span class="w"> </span>from typing import TYPE_CHECKING, Any, ClassVar, Literal
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="gd">-from sphinx.domains.cpp._ids import _id_char_from_prefix, _id_explicit_cast, _id_fundamental_v1, _id_fundamental_v2, _id_operator_unary_v2, _id_operator_v1, _id_operator_v2, _id_prefix, _id_shorthands_v1, _max_id</span>
<span class="gd">-from sphinx.util.cfamily import ASTAttributeList, ASTBaseBase, ASTBaseParenExprList, NoOldIdError, UnsupportedMultiCharacterCharLiteral, verify_description_mode</span>
<span class="gi">+from sphinx.domains.cpp._ids import (</span>
<span class="gi">+    _id_char_from_prefix,</span>
<span class="gi">+    _id_explicit_cast,</span>
<span class="gi">+    _id_fundamental_v1,</span>
<span class="gi">+    _id_fundamental_v2,</span>
<span class="gi">+    _id_operator_unary_v2,</span>
<span class="gi">+    _id_operator_v1,</span>
<span class="gi">+    _id_operator_v2,</span>
<span class="gi">+    _id_prefix,</span>
<span class="gi">+    _id_shorthands_v1,</span>
<span class="gi">+    _max_id,</span>
<span class="gi">+)</span>
<span class="gi">+from sphinx.util.cfamily import (</span>
<span class="gi">+    ASTAttributeList,</span>
<span class="gi">+    ASTBaseBase,</span>
<span class="gi">+    ASTBaseParenExprList,</span>
<span class="gi">+    NoOldIdError,</span>
<span class="gi">+    UnsupportedMultiCharacterCharLiteral,</span>
<span class="gi">+    verify_description_mode,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.nodes import Element, TextElement
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.addnodes import desc_signature
<span class="w"> </span>    from sphinx.domains.cpp._symbol import Symbol
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="gu">@@ -18,126 +41,411 @@ class ASTBase(ASTBaseBase):</span>
<span class="w"> </span>    pass


<span class="gd">-class ASTIdentifier(ASTBase):</span>
<span class="gi">+# Names</span>
<span class="gi">+################################################################################</span>

<span class="gd">-    def __init__(self, name: str) -&gt;None:</span>
<span class="gi">+class ASTIdentifier(ASTBase):</span>
<span class="gi">+    def __init__(self, name: str) -&gt; None:</span>
<span class="w"> </span>        if not isinstance(name, str) or len(name) == 0:
<span class="w"> </span>            raise AssertionError
<span class="w"> </span>        self.name = sys.intern(name)
<span class="w"> </span>        self.is_anonymous = name[0] == &#39;@&#39;

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    # ASTBaseBase already implements this method,</span>
<span class="gi">+    # but specialising it here improves performance</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTIdentifier):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.name == other.name

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.name)

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return transform(self.name)</span>
<span class="gi">+</span>
<span class="gi">+    def is_anon(self) -&gt; bool:</span>
<span class="gi">+        return self.is_anonymous</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        if self.is_anonymous and version &lt; 3:</span>
<span class="gi">+            raise NoOldIdError</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            if self.name == &#39;size_t&#39;:</span>
<span class="gi">+                return &#39;s&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                return self.name</span>
<span class="gi">+        if self.name == &quot;std&quot;:</span>
<span class="gi">+            return &#39;St&#39;</span>
<span class="gi">+        elif self.name[0] == &quot;~&quot;:</span>
<span class="gi">+            # a destructor, just use an arbitrary version of dtors</span>
<span class="gi">+            return &#39;D0&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self.is_anonymous:</span>
<span class="gi">+                return &#39;Ut%d_%s&#39; % (len(self.name) - 1, self.name[1:])</span>
<span class="gi">+            else:</span>
<span class="gi">+                return str(len(self.name)) + self.name</span>
<span class="gi">+</span>
<span class="gi">+    # and this is where we finally make a difference between __str__ and the display string</span>
<span class="gi">+</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return self.name

<span class="gi">+    def get_display_string(self) -&gt; str:</span>
<span class="gi">+        return &quot;[anonymous]&quot; if self.is_anonymous else self.name</span>

<span class="gd">-class ASTNestedNameElement(ASTBase):</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str, env: BuildEnvironment,</span>
<span class="gi">+                           prefix: str, templateArgs: str, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        if self.is_anonymous:</span>
<span class="gi">+            node = addnodes.desc_sig_name(text=&quot;[anonymous]&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            node = addnodes.desc_sig_name(self.name, self.name)</span>
<span class="gi">+        if mode == &#39;markType&#39;:</span>
<span class="gi">+            targetText = prefix + self.name + templateArgs</span>
<span class="gi">+            pnode = addnodes.pending_xref(&#39;&#39;, refdomain=&#39;cpp&#39;,</span>
<span class="gi">+                                          reftype=&#39;identifier&#39;,</span>
<span class="gi">+                                          reftarget=targetText, modname=None,</span>
<span class="gi">+                                          classname=None)</span>
<span class="gi">+            pnode[&#39;cpp:parent_key&#39;] = symbol.get_lookup_key()</span>
<span class="gi">+            pnode += node</span>
<span class="gi">+            signode += pnode</span>
<span class="gi">+        elif mode == &#39;lastIsName&#39;:</span>
<span class="gi">+            nameNode = addnodes.desc_name()</span>
<span class="gi">+            nameNode += node</span>
<span class="gi">+            signode += nameNode</span>
<span class="gi">+        elif mode == &#39;noneIsName&#39;:</span>
<span class="gi">+            signode += node</span>
<span class="gi">+        elif mode == &#39;param&#39;:</span>
<span class="gi">+            node[&#39;classes&#39;].append(&#39;sig-param&#39;)</span>
<span class="gi">+            signode += node</span>
<span class="gi">+        elif mode == &#39;udl&#39;:</span>
<span class="gi">+            # the target is &#39;operator&quot;&quot;id&#39; instead of just &#39;id&#39;</span>
<span class="gi">+            assert len(prefix) == 0</span>
<span class="gi">+            assert len(templateArgs) == 0</span>
<span class="gi">+            assert not self.is_anonymous</span>
<span class="gi">+            targetText = &#39;operator&quot;&quot;&#39; + self.name</span>
<span class="gi">+            pnode = addnodes.pending_xref(&#39;&#39;, refdomain=&#39;cpp&#39;,</span>
<span class="gi">+                                          reftype=&#39;identifier&#39;,</span>
<span class="gi">+                                          reftarget=targetText, modname=None,</span>
<span class="gi">+                                          classname=None)</span>
<span class="gi">+            pnode[&#39;cpp:parent_key&#39;] = symbol.get_lookup_key()</span>
<span class="gi">+            pnode += node</span>
<span class="gi">+            signode += pnode</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise Exception(&#39;Unknown description mode: %s&#39; % mode)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def identifier(self) -&gt; str:</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;`ASTIdentifier.identifier` is deprecated, use `ASTIdentifier.name` instead&#39;,</span>
<span class="gi">+            DeprecationWarning, stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+        return self.name</span>

<span class="gd">-    def __init__(self, identOrOp: (ASTIdentifier | ASTOperator),</span>
<span class="gd">-        templateArgs: (ASTTemplateArgs | None)) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class ASTNestedNameElement(ASTBase):</span>
<span class="gi">+    def __init__(self, identOrOp: ASTIdentifier | ASTOperator,</span>
<span class="gi">+                 templateArgs: ASTTemplateArgs | None) -&gt; None:</span>
<span class="w"> </span>        self.identOrOp = identOrOp
<span class="w"> </span>        self.templateArgs = templateArgs

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTNestedNameElement):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.identOrOp == other.identOrOp and self.templateArgs ==</span>
<span class="gd">-            other.templateArgs)</span>
<span class="gi">+        return self.identOrOp == other.identOrOp and self.templateArgs == other.templateArgs</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.identOrOp, self.templateArgs))

<span class="gi">+    def is_operator(self) -&gt; bool:</span>
<span class="gi">+        return False</span>

<span class="gd">-class ASTNestedName(ASTBase):</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        res = self.identOrOp.get_id(version)</span>
<span class="gi">+        if self.templateArgs:</span>
<span class="gi">+            res += self.templateArgs.get_id(version)</span>
<span class="gi">+        return res</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = transform(self.identOrOp)</span>
<span class="gi">+        if self.templateArgs:</span>
<span class="gi">+            res += transform(self.templateArgs)</span>
<span class="gi">+        return res</span>

<span class="gd">-    def __init__(self, names: list[ASTNestedNameElement], templates: list[</span>
<span class="gd">-        bool], rooted: bool) -&gt;None:</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, prefix: str, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        tArgs = str(self.templateArgs) if self.templateArgs is not None else &#39;&#39;</span>
<span class="gi">+        self.identOrOp.describe_signature(signode, mode, env, prefix, tArgs, symbol)</span>
<span class="gi">+        if self.templateArgs is not None:</span>
<span class="gi">+            self.templateArgs.describe_signature(signode, &#39;markType&#39;, env, symbol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ASTNestedName(ASTBase):</span>
<span class="gi">+    def __init__(self, names: list[ASTNestedNameElement],</span>
<span class="gi">+                 templates: list[bool], rooted: bool) -&gt; None:</span>
<span class="w"> </span>        assert len(names) &gt; 0
<span class="w"> </span>        self.names = names
<span class="w"> </span>        self.templates = templates
<span class="w"> </span>        assert len(self.names) == len(self.templates)
<span class="w"> </span>        self.rooted = rooted

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTNestedName):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.names == other.names and self.templates == other.</span>
<span class="gd">-            templates and self.rooted == other.rooted)</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.names == other.names</span>
<span class="gi">+            and self.templates == other.templates</span>
<span class="gi">+            and self.rooted == other.rooted</span>
<span class="gi">+        )</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.names, self.templates, self.rooted))

<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        return self</span>
<span class="gi">+</span>
<span class="gi">+    def num_templates(self) -&gt; int:</span>
<span class="gi">+        count = 0</span>
<span class="gi">+        for n in self.names:</span>
<span class="gi">+            if n.is_operator():</span>
<span class="gi">+                continue</span>
<span class="gi">+            if n.templateArgs:</span>
<span class="gi">+                count += 1</span>
<span class="gi">+        return count</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int, modifiers: str = &#39;&#39;) -&gt; str:</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            tt = str(self)</span>
<span class="gi">+            if tt in _id_shorthands_v1:</span>
<span class="gi">+                return _id_shorthands_v1[tt]</span>
<span class="gi">+            else:</span>
<span class="gi">+                return &#39;::&#39;.join(n.get_id(version) for n in self.names)</span>
<span class="gi">+</span>
<span class="gi">+        res = []</span>
<span class="gi">+        if len(self.names) &gt; 1 or len(modifiers) &gt; 0:</span>
<span class="gi">+            res.append(&#39;N&#39;)</span>
<span class="gi">+        res.append(modifiers)</span>
<span class="gi">+        res.extend(n.get_id(version) for n in self.names)</span>
<span class="gi">+        if len(self.names) &gt; 1 or len(modifiers) &gt; 0:</span>
<span class="gi">+            res.append(&#39;E&#39;)</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        if self.rooted:</span>
<span class="gi">+            res.append(&#39;&#39;)</span>
<span class="gi">+        for i in range(len(self.names)):</span>
<span class="gi">+            n = self.names[i]</span>
<span class="gi">+            if self.templates[i]:</span>
<span class="gi">+                res.append(&quot;template &quot; + transform(n))</span>
<span class="gi">+            else:</span>
<span class="gi">+                res.append(transform(n))</span>
<span class="gi">+        return &#39;::&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        # just print the name part, with template args, not template params</span>
<span class="gi">+        if mode == &#39;noneIsName&#39;:</span>
<span class="gi">+            if self.rooted:</span>
<span class="gi">+                unreachable = &quot;Can this happen?&quot;</span>
<span class="gi">+                raise AssertionError(unreachable)  # TODO</span>
<span class="gi">+                signode += nodes.Text(&#39;::&#39;)</span>
<span class="gi">+            for i in range(len(self.names)):</span>
<span class="gi">+                if i != 0:</span>
<span class="gi">+                    unreachable = &quot;Can this happen?&quot;</span>
<span class="gi">+                    raise AssertionError(unreachable)  # TODO</span>
<span class="gi">+                    signode += nodes.Text(&#39;::blah&#39;)</span>
<span class="gi">+                n = self.names[i]</span>
<span class="gi">+                if self.templates[i]:</span>
<span class="gi">+                    unreachable = &quot;Can this happen?&quot;</span>
<span class="gi">+                    raise AssertionError(unreachable)  # TODO</span>
<span class="gi">+                    signode += nodes.Text(&quot;template&quot;)</span>
<span class="gi">+                    signode += nodes.Text(&quot; &quot;)</span>
<span class="gi">+                n.describe_signature(signode, mode, env, &#39;&#39;, symbol)</span>
<span class="gi">+        elif mode == &#39;param&#39;:</span>
<span class="gi">+            assert not self.rooted, str(self)</span>
<span class="gi">+            assert len(self.names) == 1</span>
<span class="gi">+            assert not self.templates[0]</span>
<span class="gi">+            self.names[0].describe_signature(signode, &#39;param&#39;, env, &#39;&#39;, symbol)</span>
<span class="gi">+        elif mode in (&#39;markType&#39;, &#39;lastIsName&#39;, &#39;markName&#39;):</span>
<span class="gi">+            # Each element should be a pending xref targeting the complete</span>
<span class="gi">+            # prefix. however, only the identifier part should be a link, such</span>
<span class="gi">+            # that template args can be a link as well.</span>
<span class="gi">+            # For &#39;lastIsName&#39; we should also prepend template parameter lists.</span>
<span class="gi">+            templateParams: list[Any] = []</span>
<span class="gi">+            if mode == &#39;lastIsName&#39;:</span>
<span class="gi">+                assert symbol is not None</span>
<span class="gi">+                if symbol.declaration.templatePrefix is not None:</span>
<span class="gi">+                    templateParams = symbol.declaration.templatePrefix.templates</span>
<span class="gi">+            iTemplateParams = 0</span>
<span class="gi">+            templateParamsPrefix = &#39;&#39;</span>
<span class="gi">+            prefix = &#39;&#39;</span>
<span class="gi">+            first = True</span>
<span class="gi">+            names = self.names[:-1] if mode == &#39;lastIsName&#39; else self.names</span>
<span class="gi">+            # If lastIsName, then wrap all of the prefix in a desc_addname,</span>
<span class="gi">+            # else append directly to signode.</span>
<span class="gi">+            # NOTE: Breathe previously relied on the prefix being in the desc_addname node,</span>
<span class="gi">+            #       so it can remove it in inner declarations.</span>
<span class="gi">+            dest = signode</span>
<span class="gi">+            if mode == &#39;lastIsName&#39;:</span>
<span class="gi">+                dest = addnodes.desc_addname()</span>
<span class="gi">+            if self.rooted:</span>
<span class="gi">+                prefix += &#39;::&#39;</span>
<span class="gi">+                if mode == &#39;lastIsName&#39; and len(names) == 0:</span>
<span class="gi">+                    signode += addnodes.desc_sig_punctuation(&#39;::&#39;, &#39;::&#39;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    dest += addnodes.desc_sig_punctuation(&#39;::&#39;, &#39;::&#39;)</span>
<span class="gi">+            for i in range(len(names)):</span>
<span class="gi">+                nne = names[i]</span>
<span class="gi">+                template = self.templates[i]</span>
<span class="gi">+                if not first:</span>
<span class="gi">+                    dest += addnodes.desc_sig_punctuation(&#39;::&#39;, &#39;::&#39;)</span>
<span class="gi">+                    prefix += &#39;::&#39;</span>
<span class="gi">+                if template:</span>
<span class="gi">+                    dest += addnodes.desc_sig_keyword(&#39;template&#39;, &#39;template&#39;)</span>
<span class="gi">+                    dest += addnodes.desc_sig_space()</span>
<span class="gi">+                first = False</span>
<span class="gi">+                txt_nne = str(nne)</span>
<span class="gi">+                if txt_nne != &#39;&#39;:</span>
<span class="gi">+                    if nne.templateArgs and iTemplateParams &lt; len(templateParams):</span>
<span class="gi">+                        templateParamsPrefix += str(templateParams[iTemplateParams])</span>
<span class="gi">+                        iTemplateParams += 1</span>
<span class="gi">+                    nne.describe_signature(dest, &#39;markType&#39;,</span>
<span class="gi">+                                           env, templateParamsPrefix + prefix, symbol)</span>
<span class="gi">+                prefix += txt_nne</span>
<span class="gi">+            if mode == &#39;lastIsName&#39;:</span>
<span class="gi">+                if len(self.names) &gt; 1:</span>
<span class="gi">+                    dest += addnodes.desc_sig_punctuation(&#39;::&#39;, &#39;::&#39;)</span>
<span class="gi">+                    signode += dest</span>
<span class="gi">+                if self.templates[-1]:</span>
<span class="gi">+                    signode += addnodes.desc_sig_keyword(&#39;template&#39;, &#39;template&#39;)</span>
<span class="gi">+                    signode += addnodes.desc_sig_space()</span>
<span class="gi">+                self.names[-1].describe_signature(signode, mode, env, &#39;&#39;, symbol)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise Exception(&#39;Unknown description mode: %s&#39; % mode)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+################################################################################</span>
<span class="gi">+# Expressions</span>
<span class="gi">+################################################################################</span>

<span class="w"> </span>class ASTExpression(ASTBase):
<span class="gd">-    pass</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>
<span class="gi">+</span>

<span class="gi">+# Primary expressions</span>
<span class="gi">+################################################################################</span>

<span class="w"> </span>class ASTLiteral(ASTExpression):
<span class="w"> </span>    pass


<span class="w"> </span>class ASTPointerLiteral(ASTLiteral):
<span class="gd">-</span>
<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return isinstance(other, ASTPointerLiteral)

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(&#39;nullptr&#39;)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &#39;nullptr&#39;</span>

<span class="gd">-class ASTBooleanLiteral(ASTLiteral):</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        return &#39;LDnE&#39;</span>

<span class="gd">-    def __init__(self, value: bool) -&gt;None:</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(&#39;nullptr&#39;, &#39;nullptr&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ASTBooleanLiteral(ASTLiteral):</span>
<span class="gi">+    def __init__(self, value: bool) -&gt; None:</span>
<span class="w"> </span>        self.value = value

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTBooleanLiteral):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.value == other.value

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.value)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        if self.value:</span>
<span class="gi">+            return &#39;true&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;false&#39;</span>

<span class="gd">-class ASTNumberLiteral(ASTLiteral):</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        if self.value:</span>
<span class="gi">+            return &#39;L1E&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;L0E&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(str(self), str(self))</span>

<span class="gd">-    def __init__(self, data: str) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class ASTNumberLiteral(ASTLiteral):</span>
<span class="gi">+    def __init__(self, data: str) -&gt; None:</span>
<span class="w"> </span>        self.data = data

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTNumberLiteral):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.data == other.data

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.data)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return self.data</span>

<span class="gd">-class ASTStringLiteral(ASTLiteral):</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        # TODO: floats should be mangled by writing the hex of the binary representation</span>
<span class="gi">+        return &quot;L%sE&quot; % self.data.replace(&quot;&#39;&quot;, &quot;&quot;)</span>

<span class="gd">-    def __init__(self, data: str) -&gt;None:</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_literal_number(self.data, self.data)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ASTStringLiteral(ASTLiteral):</span>
<span class="gi">+    def __init__(self, data: str) -&gt; None:</span>
<span class="w"> </span>        self.data = data

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTStringLiteral):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.data == other.data

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.data)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return self.data</span>

<span class="gd">-class ASTCharLiteral(ASTLiteral):</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        # note: the length is not really correct with escaping</span>
<span class="gi">+        return &quot;LA%d_KcE&quot; % (len(self.data) - 2)</span>

<span class="gd">-    def __init__(self, prefix: str, data: str) -&gt;None:</span>
<span class="gd">-        self.prefix = prefix</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_literal_string(self.data, self.data)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ASTCharLiteral(ASTLiteral):</span>
<span class="gi">+    def __init__(self, prefix: str, data: str) -&gt; None:</span>
<span class="gi">+        self.prefix = prefix  # may be None when no prefix</span>
<span class="w"> </span>        self.data = data
<span class="w"> </span>        assert prefix in _id_char_from_prefix
<span class="w"> </span>        self.type = _id_char_from_prefix[prefix]
<span class="gu">@@ -147,639 +455,1490 @@ class ASTCharLiteral(ASTLiteral):</span>
<span class="w"> </span>        else:
<span class="w"> </span>            raise UnsupportedMultiCharacterCharLiteral(decoded)

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTCharLiteral):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return self.prefix == other.prefix and self.value == other.value</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.prefix == other.prefix</span>
<span class="gi">+            and self.value == other.value</span>
<span class="gi">+        )</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.prefix, self.value))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        if self.prefix is None:</span>
<span class="gi">+            return &quot;&#39;&quot; + self.data + &quot;&#39;&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.prefix + &quot;&#39;&quot; + self.data + &quot;&#39;&quot;</span>

<span class="gd">-class ASTUserDefinedLiteral(ASTLiteral):</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        # TODO: the ID should be have L E around it</span>
<span class="gi">+        return self.type + str(self.value)</span>

<span class="gd">-    def __init__(self, literal: ASTLiteral, ident: ASTIdentifier) -&gt;None:</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        if self.prefix is not None:</span>
<span class="gi">+            signode += addnodes.desc_sig_keyword(self.prefix, self.prefix)</span>
<span class="gi">+        txt = &quot;&#39;&quot; + self.data + &quot;&#39;&quot;</span>
<span class="gi">+        signode += addnodes.desc_sig_literal_char(txt, txt)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ASTUserDefinedLiteral(ASTLiteral):</span>
<span class="gi">+    def __init__(self, literal: ASTLiteral, ident: ASTIdentifier) -&gt; None:</span>
<span class="w"> </span>        self.literal = literal
<span class="w"> </span>        self.ident = ident

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTUserDefinedLiteral):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.literal == other.literal and self.ident == other.ident

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.literal, self.ident))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return transform(self.literal) + transform(self.ident)</span>

<span class="gd">-class ASTThisLiteral(ASTExpression):</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        # mangle as if it was a function call: ident(literal)</span>
<span class="gi">+        return f&#39;clL_Zli{self.ident.get_id(version)}E{self.literal.get_id(version)}E&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        self.literal.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        self.ident.describe_signature(signode, &quot;udl&quot;, env, &quot;&quot;, &quot;&quot;, symbol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+################################################################################</span>

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+class ASTThisLiteral(ASTExpression):</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return isinstance(other, ASTThisLiteral)

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gd">-        return hash(&#39;this&#39;)</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="gi">+        return hash(&quot;this&quot;)</span>

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &quot;this&quot;</span>

<span class="gd">-class ASTFoldExpr(ASTExpression):</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        return &quot;fpT&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(&#39;this&#39;, &#39;this&#39;)</span>

<span class="gd">-    def __init__(self, leftExpr: (ASTExpression | None), op: str, rightExpr:</span>
<span class="gd">-        (ASTExpression | None)) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class ASTFoldExpr(ASTExpression):</span>
<span class="gi">+    def __init__(self, leftExpr: ASTExpression | None,</span>
<span class="gi">+                 op: str, rightExpr: ASTExpression | None) -&gt; None:</span>
<span class="w"> </span>        assert leftExpr is not None or rightExpr is not None
<span class="w"> </span>        self.leftExpr = leftExpr
<span class="w"> </span>        self.op = op
<span class="w"> </span>        self.rightExpr = rightExpr

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTFoldExpr):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.leftExpr == other.leftExpr and self.op == other.op and</span>
<span class="gd">-            self.rightExpr == other.rightExpr)</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.leftExpr == other.leftExpr</span>
<span class="gi">+            and self.op == other.op</span>
<span class="gi">+            and self.rightExpr == other.rightExpr</span>
<span class="gi">+        )</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.leftExpr, self.op, self.rightExpr))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = [&#39;(&#39;]</span>
<span class="gi">+        if self.leftExpr:</span>
<span class="gi">+            res.append(transform(self.leftExpr))</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+            res.append(self.op)</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+        res.append(&#39;...&#39;)</span>
<span class="gi">+        if self.rightExpr:</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+            res.append(self.op)</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+            res.append(transform(self.rightExpr))</span>
<span class="gi">+        res.append(&#39;)&#39;)</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        assert version &gt;= 3</span>
<span class="gi">+        if version == 3:</span>
<span class="gi">+            return str(self)</span>
<span class="gi">+        # https://github.com/itanium-cxx-abi/cxx-abi/pull/67</span>
<span class="gi">+        res = []</span>
<span class="gi">+        if self.leftExpr is None:  # (... op expr)</span>
<span class="gi">+            res.append(&#39;fl&#39;)</span>
<span class="gi">+        elif self.rightExpr is None:  # (expr op ...)</span>
<span class="gi">+            res.append(&#39;fr&#39;)</span>
<span class="gi">+        else:  # (expr op ... op expr)</span>
<span class="gi">+            # we don&#39;t check where the parameter pack is,</span>
<span class="gi">+            # we just always call this a binary left fold</span>
<span class="gi">+            res.append(&#39;fL&#39;)</span>
<span class="gi">+        res.append(_id_operator_v2[self.op])</span>
<span class="gi">+        if self.leftExpr:</span>
<span class="gi">+            res.append(self.leftExpr.get_id(version))</span>
<span class="gi">+        if self.rightExpr:</span>
<span class="gi">+            res.append(self.rightExpr.get_id(version))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;(&#39;, &#39;(&#39;)</span>
<span class="gi">+        if self.leftExpr:</span>
<span class="gi">+            self.leftExpr.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            signode += addnodes.desc_sig_operator(self.op, self.op)</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;...&#39;, &#39;...&#39;)</span>
<span class="gi">+        if self.rightExpr:</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            signode += addnodes.desc_sig_operator(self.op, self.op)</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            self.rightExpr.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;)&#39;, &#39;)&#39;)</span>

<span class="gd">-class ASTParenExpr(ASTExpression):</span>

<span class="gd">-    def __init__(self, expr: ASTExpression) -&gt;None:</span>
<span class="gi">+class ASTParenExpr(ASTExpression):</span>
<span class="gi">+    def __init__(self, expr: ASTExpression) -&gt; None:</span>
<span class="w"> </span>        self.expr = expr

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTParenExpr):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.expr == other.expr

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.expr)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &#39;(&#39; + transform(self.expr) + &#39;)&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        return self.expr.get_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;(&#39;, &#39;(&#39;)</span>
<span class="gi">+        self.expr.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;)&#39;, &#39;)&#39;)</span>

<span class="gd">-class ASTIdExpression(ASTExpression):</span>

<span class="gd">-    def __init__(self, name: ASTNestedName) -&gt;None:</span>
<span class="gi">+class ASTIdExpression(ASTExpression):</span>
<span class="gi">+    def __init__(self, name: ASTNestedName) -&gt; None:</span>
<span class="gi">+        # note: this class is basically to cast a nested name as an expression</span>
<span class="w"> </span>        self.name = name

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTIdExpression):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.name == other.name

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.name)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return transform(self.name)</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        return self.name.get_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        self.name.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Postfix expressions</span>
<span class="gi">+################################################################################</span>

<span class="w"> </span>class ASTPostfixOp(ASTBase):
<span class="gd">-    pass</span>
<span class="gi">+    def get_id(self, idPrefix: str, version: int) -&gt; str:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>

<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>

<span class="gd">-class ASTPostfixArray(ASTPostfixOp):</span>

<span class="gd">-    def __init__(self, expr: ASTExpression) -&gt;None:</span>
<span class="gi">+class ASTPostfixArray(ASTPostfixOp):</span>
<span class="gi">+    def __init__(self, expr: ASTExpression) -&gt; None:</span>
<span class="w"> </span>        self.expr = expr

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTPostfixArray):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.expr == other.expr

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.expr)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &#39;[&#39; + transform(self.expr) + &#39;]&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, idPrefix: str, version: int) -&gt; str:</span>
<span class="gi">+        return &#39;ix&#39; + idPrefix + self.expr.get_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;[&#39;, &#39;[&#39;)</span>
<span class="gi">+        self.expr.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;]&#39;, &#39;]&#39;)</span>

<span class="gd">-class ASTPostfixMember(ASTPostfixOp):</span>

<span class="gd">-    def __init__(self, name: ASTNestedName) -&gt;None:</span>
<span class="gi">+class ASTPostfixMember(ASTPostfixOp):</span>
<span class="gi">+    def __init__(self, name: ASTNestedName) -&gt; None:</span>
<span class="w"> </span>        self.name = name

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTPostfixMember):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.name == other.name

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.name)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &#39;.&#39; + transform(self.name)</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, idPrefix: str, version: int) -&gt; str:</span>
<span class="gi">+        return &#39;dt&#39; + idPrefix + self.name.get_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;.&#39;, &#39;.&#39;)</span>
<span class="gi">+        self.name.describe_signature(signode, &#39;noneIsName&#39;, env, symbol)</span>

<span class="gd">-class ASTPostfixMemberOfPointer(ASTPostfixOp):</span>

<span class="gd">-    def __init__(self, name: ASTNestedName) -&gt;None:</span>
<span class="gi">+class ASTPostfixMemberOfPointer(ASTPostfixOp):</span>
<span class="gi">+    def __init__(self, name: ASTNestedName) -&gt; None:</span>
<span class="w"> </span>        self.name = name

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTPostfixMemberOfPointer):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.name == other.name

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.name)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &#39;-&gt;&#39; + transform(self.name)</span>

<span class="gd">-class ASTPostfixInc(ASTPostfixOp):</span>
<span class="gi">+    def get_id(self, idPrefix: str, version: int) -&gt; str:</span>
<span class="gi">+        return &#39;pt&#39; + idPrefix + self.name.get_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_operator(&#39;-&gt;&#39;, &#39;-&gt;&#39;)</span>
<span class="gi">+        self.name.describe_signature(signode, &#39;noneIsName&#39;, env, symbol)</span>

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+</span>
<span class="gi">+class ASTPostfixInc(ASTPostfixOp):</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return isinstance(other, ASTPostfixInc)

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(&#39;++&#39;)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &#39;++&#39;</span>

<span class="gd">-class ASTPostfixDec(ASTPostfixOp):</span>
<span class="gi">+    def get_id(self, idPrefix: str, version: int) -&gt; str:</span>
<span class="gi">+        return &#39;pp&#39; + idPrefix</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_operator(&#39;++&#39;, &#39;++&#39;)</span>

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+</span>
<span class="gi">+class ASTPostfixDec(ASTPostfixOp):</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return isinstance(other, ASTPostfixDec)

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(&#39;--&#39;)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &#39;--&#39;</span>

<span class="gd">-class ASTPostfixCallExpr(ASTPostfixOp):</span>
<span class="gi">+    def get_id(self, idPrefix: str, version: int) -&gt; str:</span>
<span class="gi">+        return &#39;mm&#39; + idPrefix</span>

<span class="gd">-    def __init__(self, lst: (ASTParenExprList | ASTBracedInitList)) -&gt;None:</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_operator(&#39;--&#39;, &#39;--&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ASTPostfixCallExpr(ASTPostfixOp):</span>
<span class="gi">+    def __init__(self, lst: ASTParenExprList | ASTBracedInitList) -&gt; None:</span>
<span class="w"> </span>        self.lst = lst

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTPostfixCallExpr):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.lst == other.lst

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.lst)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return transform(self.lst)</span>

<span class="gd">-class ASTPostfixExpr(ASTExpression):</span>
<span class="gi">+    def get_id(self, idPrefix: str, version: int) -&gt; str:</span>
<span class="gi">+        return &#39;&#39;.join([</span>
<span class="gi">+            &#39;cl&#39;,</span>
<span class="gi">+            idPrefix,</span>
<span class="gi">+            *(e.get_id(version) for e in self.lst.exprs),</span>
<span class="gi">+            &#39;E&#39;,</span>
<span class="gi">+        ])</span>

<span class="gd">-    def __init__(self, prefix: ASTType, postFixes: list[ASTPostfixOp]) -&gt;None:</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        self.lst.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ASTPostfixExpr(ASTExpression):</span>
<span class="gi">+    def __init__(self, prefix: ASTType, postFixes: list[ASTPostfixOp]) -&gt; None:</span>
<span class="w"> </span>        self.prefix = prefix
<span class="w"> </span>        self.postFixes = postFixes

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTPostfixExpr):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.prefix == other.prefix and self.postFixes == other.</span>
<span class="gd">-            postFixes)</span>
<span class="gi">+        return self.prefix == other.prefix and self.postFixes == other.postFixes</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.prefix, self.postFixes))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &#39;&#39;.join([transform(self.prefix), *(transform(p) for p in self.postFixes)])</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        id = self.prefix.get_id(version)</span>
<span class="gi">+        for p in self.postFixes:</span>
<span class="gi">+            id = p.get_id(id, version)</span>
<span class="gi">+        return id</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        self.prefix.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        for p in self.postFixes:</span>
<span class="gi">+            p.describe_signature(signode, mode, env, symbol)</span>

<span class="gd">-class ASTExplicitCast(ASTExpression):</span>

<span class="gd">-    def __init__(self, cast: str, typ: ASTType, expr: ASTExpression) -&gt;None:</span>
<span class="gi">+class ASTExplicitCast(ASTExpression):</span>
<span class="gi">+    def __init__(self, cast: str, typ: ASTType, expr: ASTExpression) -&gt; None:</span>
<span class="w"> </span>        assert cast in _id_explicit_cast
<span class="w"> </span>        self.cast = cast
<span class="w"> </span>        self.typ = typ
<span class="w"> </span>        self.expr = expr

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTExplicitCast):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.cast == other.cast and self.typ == other.typ and self.</span>
<span class="gd">-            expr == other.expr)</span>
<span class="gi">+        return self.cast == other.cast and self.typ == other.typ and self.expr == other.expr</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.cast, self.typ, self.expr))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = [self.cast]</span>
<span class="gi">+        res.append(&#39;&lt;&#39;)</span>
<span class="gi">+        res.append(transform(self.typ))</span>
<span class="gi">+        res.append(&#39;&gt;(&#39;)</span>
<span class="gi">+        res.append(transform(self.expr))</span>
<span class="gi">+        res.append(&#39;)&#39;)</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        return (_id_explicit_cast[self.cast] +</span>
<span class="gi">+                self.typ.get_id(version) +</span>
<span class="gi">+                self.expr.get_id(version))</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(self.cast, self.cast)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;&lt;&#39;, &#39;&lt;&#39;)</span>
<span class="gi">+        self.typ.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;&gt;&#39;, &#39;&gt;&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;(&#39;, &#39;(&#39;)</span>
<span class="gi">+        self.expr.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;)&#39;, &#39;)&#39;)</span>

<span class="gd">-class ASTTypeId(ASTExpression):</span>

<span class="gd">-    def __init__(self, typeOrExpr: (ASTType | ASTExpression), isType: bool</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+class ASTTypeId(ASTExpression):</span>
<span class="gi">+    def __init__(self, typeOrExpr: ASTType | ASTExpression, isType: bool) -&gt; None:</span>
<span class="w"> </span>        self.typeOrExpr = typeOrExpr
<span class="w"> </span>        self.isType = isType

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTTypeId):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.typeOrExpr == other.typeOrExpr and self.isType ==</span>
<span class="gd">-            other.isType)</span>
<span class="gi">+        return self.typeOrExpr == other.typeOrExpr and self.isType == other.isType</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.typeOrExpr, self.isType))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &#39;typeid(&#39; + transform(self.typeOrExpr) + &#39;)&#39;</span>

<span class="gd">-class ASTUnaryOpExpr(ASTExpression):</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        prefix = &#39;ti&#39; if self.isType else &#39;te&#39;</span>
<span class="gi">+        return prefix + self.typeOrExpr.get_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(&#39;typeid&#39;, &#39;typeid&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;(&#39;, &#39;(&#39;)</span>
<span class="gi">+        self.typeOrExpr.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;)&#39;, &#39;)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Unary expressions</span>
<span class="gi">+################################################################################</span>

<span class="gd">-    def __init__(self, op: str, expr: ASTExpression) -&gt;None:</span>
<span class="gi">+class ASTUnaryOpExpr(ASTExpression):</span>
<span class="gi">+    def __init__(self, op: str, expr: ASTExpression) -&gt; None:</span>
<span class="w"> </span>        self.op = op
<span class="w"> </span>        self.expr = expr

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTUnaryOpExpr):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.op == other.op and self.expr == other.expr

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.op, self.expr))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        if self.op[0] in &#39;cn&#39;:</span>
<span class="gi">+            return self.op + &quot; &quot; + transform(self.expr)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.op + transform(self.expr)</span>

<span class="gd">-class ASTSizeofParamPack(ASTExpression):</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        return _id_operator_unary_v2[self.op] + self.expr.get_id(version)</span>

<span class="gd">-    def __init__(self, identifier: ASTIdentifier) -&gt;None:</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        if self.op[0] in &#39;cn&#39;:</span>
<span class="gi">+            signode += addnodes.desc_sig_keyword(self.op, self.op)</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+        else:</span>
<span class="gi">+            signode += addnodes.desc_sig_operator(self.op, self.op)</span>
<span class="gi">+        self.expr.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ASTSizeofParamPack(ASTExpression):</span>
<span class="gi">+    def __init__(self, identifier: ASTIdentifier) -&gt; None:</span>
<span class="w"> </span>        self.identifier = identifier

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTSizeofParamPack):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.identifier == other.identifier

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.identifier)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &quot;sizeof...(&quot; + transform(self.identifier) + &quot;)&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        return &#39;sZ&#39; + self.identifier.get_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(&#39;sizeof&#39;, &#39;sizeof&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;...&#39;, &#39;...&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;(&#39;, &#39;(&#39;)</span>
<span class="gi">+        self.identifier.describe_signature(signode, &#39;markType&#39;, env,</span>
<span class="gi">+                                           symbol=symbol, prefix=&quot;&quot;, templateArgs=&quot;&quot;)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;)&#39;, &#39;)&#39;)</span>

<span class="gd">-class ASTSizeofType(ASTExpression):</span>

<span class="gd">-    def __init__(self, typ: ASTType) -&gt;None:</span>
<span class="gi">+class ASTSizeofType(ASTExpression):</span>
<span class="gi">+    def __init__(self, typ: ASTType) -&gt; None:</span>
<span class="w"> </span>        self.typ = typ

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTSizeofType):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.typ == other.typ

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.typ)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &quot;sizeof(&quot; + transform(self.typ) + &quot;)&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        return &#39;st&#39; + self.typ.get_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(&#39;sizeof&#39;, &#39;sizeof&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;(&#39;, &#39;(&#39;)</span>
<span class="gi">+        self.typ.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;)&#39;, &#39;)&#39;)</span>

<span class="gd">-class ASTSizeofExpr(ASTExpression):</span>

<span class="gd">-    def __init__(self, expr: ASTExpression) -&gt;None:</span>
<span class="gi">+class ASTSizeofExpr(ASTExpression):</span>
<span class="gi">+    def __init__(self, expr: ASTExpression) -&gt; None:</span>
<span class="w"> </span>        self.expr = expr

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTSizeofExpr):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.expr == other.expr

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.expr)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &quot;sizeof &quot; + transform(self.expr)</span>

<span class="gd">-class ASTAlignofExpr(ASTExpression):</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        return &#39;sz&#39; + self.expr.get_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(&#39;sizeof&#39;, &#39;sizeof&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_space()</span>
<span class="gi">+        self.expr.describe_signature(signode, mode, env, symbol)</span>

<span class="gd">-    def __init__(self, typ: ASTType) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class ASTAlignofExpr(ASTExpression):</span>
<span class="gi">+    def __init__(self, typ: ASTType) -&gt; None:</span>
<span class="w"> </span>        self.typ = typ

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTAlignofExpr):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.typ == other.typ

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.typ)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &quot;alignof(&quot; + transform(self.typ) + &quot;)&quot;</span>

<span class="gd">-class ASTNoexceptExpr(ASTExpression):</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        return &#39;at&#39; + self.typ.get_id(version)</span>

<span class="gd">-    def __init__(self, expr: ASTExpression) -&gt;None:</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(&#39;alignof&#39;, &#39;alignof&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;(&#39;, &#39;(&#39;)</span>
<span class="gi">+        self.typ.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;)&#39;, &#39;)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ASTNoexceptExpr(ASTExpression):</span>
<span class="gi">+    def __init__(self, expr: ASTExpression) -&gt; None:</span>
<span class="w"> </span>        self.expr = expr

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTNoexceptExpr):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.expr == other.expr

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.expr)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &#39;noexcept(&#39; + transform(self.expr) + &#39;)&#39;</span>

<span class="gd">-class ASTNewExpr(ASTExpression):</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        return &#39;nx&#39; + self.expr.get_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(&#39;noexcept&#39;, &#39;noexcept&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;(&#39;, &#39;(&#39;)</span>
<span class="gi">+        self.expr.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;)&#39;, &#39;)&#39;)</span>

<span class="gi">+</span>
<span class="gi">+class ASTNewExpr(ASTExpression):</span>
<span class="w"> </span>    def __init__(self, rooted: bool, isNewTypeId: bool, typ: ASTType,
<span class="gd">-        initList: (ASTParenExprList | ASTBracedInitList)) -&gt;None:</span>
<span class="gi">+                 initList: ASTParenExprList | ASTBracedInitList) -&gt; None:</span>
<span class="w"> </span>        self.rooted = rooted
<span class="w"> </span>        self.isNewTypeId = isNewTypeId
<span class="w"> </span>        self.typ = typ
<span class="w"> </span>        self.initList = initList

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTNewExpr):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.rooted == other.rooted and self.isNewTypeId == other.</span>
<span class="gd">-            isNewTypeId and self.typ == other.typ and self.initList ==</span>
<span class="gd">-            other.initList)</span>
<span class="gd">-</span>
<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.rooted == other.rooted</span>
<span class="gi">+            and self.isNewTypeId == other.isNewTypeId</span>
<span class="gi">+            and self.typ == other.typ</span>
<span class="gi">+            and self.initList == other.initList</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.rooted, self.isNewTypeId, self.typ, self.initList))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        if self.rooted:</span>
<span class="gi">+            res.append(&#39;::&#39;)</span>
<span class="gi">+        res.append(&#39;new &#39;)</span>
<span class="gi">+        # TODO: placement</span>
<span class="gi">+        if self.isNewTypeId:</span>
<span class="gi">+            res.append(transform(self.typ))</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise AssertionError</span>
<span class="gi">+        if self.initList is not None:</span>
<span class="gi">+            res.append(transform(self.initList))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        # the array part will be in the type mangling, so na is not used</span>
<span class="gi">+        res = [&#39;nw&#39;]</span>
<span class="gi">+        # TODO: placement</span>
<span class="gi">+        res.append(&#39;_&#39;)</span>
<span class="gi">+        res.append(self.typ.get_id(version))</span>
<span class="gi">+        if self.initList is not None:</span>
<span class="gi">+            res.append(self.initList.get_id(version))</span>
<span class="gi">+        else:</span>
<span class="gi">+            res.append(&#39;E&#39;)</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        if self.rooted:</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;::&#39;, &#39;::&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(&#39;new&#39;, &#39;new&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_space()</span>
<span class="gi">+        # TODO: placement</span>
<span class="gi">+        if self.isNewTypeId:</span>
<span class="gi">+            self.typ.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise AssertionError</span>
<span class="gi">+        if self.initList is not None:</span>
<span class="gi">+            self.initList.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+</span>

<span class="w"> </span>class ASTDeleteExpr(ASTExpression):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, rooted: bool, array: bool, expr: ASTExpression) -&gt;None:</span>
<span class="gi">+    def __init__(self, rooted: bool, array: bool, expr: ASTExpression) -&gt; None:</span>
<span class="w"> </span>        self.rooted = rooted
<span class="w"> </span>        self.array = array
<span class="w"> </span>        self.expr = expr

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTDeleteExpr):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.rooted == other.rooted and self.array == other.array and</span>
<span class="gd">-            self.expr == other.expr)</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.rooted == other.rooted</span>
<span class="gi">+            and self.array == other.array</span>
<span class="gi">+            and self.expr == other.expr</span>
<span class="gi">+        )</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.rooted, self.array, self.expr))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        if self.rooted:</span>
<span class="gi">+            res.append(&#39;::&#39;)</span>
<span class="gi">+        res.append(&#39;delete &#39;)</span>
<span class="gi">+        if self.array:</span>
<span class="gi">+            res.append(&#39;[] &#39;)</span>
<span class="gi">+        res.append(transform(self.expr))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        if self.array:</span>
<span class="gi">+            id = &quot;da&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            id = &quot;dl&quot;</span>
<span class="gi">+        return id + self.expr.get_id(version)</span>

<span class="gd">-class ASTCastExpr(ASTExpression):</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        if self.rooted:</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;::&#39;, &#39;::&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(&#39;delete&#39;, &#39;delete&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_space()</span>
<span class="gi">+        if self.array:</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;[]&#39;, &#39;[]&#39;)</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+        self.expr.describe_signature(signode, mode, env, symbol)</span>

<span class="gd">-    def __init__(self, typ: ASTType, expr: ASTExpression) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+# Other expressions</span>
<span class="gi">+################################################################################</span>
<span class="gi">+</span>
<span class="gi">+class ASTCastExpr(ASTExpression):</span>
<span class="gi">+    def __init__(self, typ: ASTType, expr: ASTExpression) -&gt; None:</span>
<span class="w"> </span>        self.typ = typ
<span class="w"> </span>        self.expr = expr

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTCastExpr):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return self.typ == other.typ and self.expr == other.expr</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.typ == other.typ</span>
<span class="gi">+            and self.expr == other.expr</span>
<span class="gi">+        )</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.typ, self.expr))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = [&#39;(&#39;]</span>
<span class="gi">+        res.append(transform(self.typ))</span>
<span class="gi">+        res.append(&#39;)&#39;)</span>
<span class="gi">+        res.append(transform(self.expr))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>

<span class="gd">-class ASTBinOpExpr(ASTExpression):</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        return &#39;cv&#39; + self.typ.get_id(version) + self.expr.get_id(version)</span>

<span class="gd">-    def __init__(self, exprs: list[ASTExpression], ops: list[str]) -&gt;None:</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;(&#39;, &#39;(&#39;)</span>
<span class="gi">+        self.typ.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;)&#39;, &#39;)&#39;)</span>
<span class="gi">+        self.expr.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ASTBinOpExpr(ASTExpression):</span>
<span class="gi">+    def __init__(self, exprs: list[ASTExpression], ops: list[str]) -&gt; None:</span>
<span class="w"> </span>        assert len(exprs) &gt; 0
<span class="w"> </span>        assert len(exprs) == len(ops) + 1
<span class="w"> </span>        self.exprs = exprs
<span class="w"> </span>        self.ops = ops

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTBinOpExpr):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return self.exprs == other.exprs and self.ops == other.ops</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.exprs == other.exprs</span>
<span class="gi">+            and self.ops == other.ops</span>
<span class="gi">+        )</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.exprs, self.ops))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        res.append(transform(self.exprs[0]))</span>
<span class="gi">+        for i in range(1, len(self.exprs)):</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+            res.append(self.ops[i - 1])</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+            res.append(transform(self.exprs[i]))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        assert version &gt;= 2</span>
<span class="gi">+        res = []</span>
<span class="gi">+        for i in range(len(self.ops)):</span>
<span class="gi">+            res.append(_id_operator_v2[self.ops[i]])</span>
<span class="gi">+            res.append(self.exprs[i].get_id(version))</span>
<span class="gi">+        res.append(self.exprs[-1].get_id(version))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        self.exprs[0].describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        for i in range(1, len(self.exprs)):</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            op = self.ops[i - 1]</span>
<span class="gi">+            if ord(op[0]) &gt;= ord(&#39;a&#39;) and ord(op[0]) &lt;= ord(&#39;z&#39;):</span>
<span class="gi">+                signode += addnodes.desc_sig_keyword(op, op)</span>
<span class="gi">+            else:</span>
<span class="gi">+                signode += addnodes.desc_sig_operator(op, op)</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            self.exprs[i].describe_signature(signode, mode, env, symbol)</span>

<span class="gd">-class ASTConditionalExpr(ASTExpression):</span>

<span class="gi">+class ASTConditionalExpr(ASTExpression):</span>
<span class="w"> </span>    def __init__(self, ifExpr: ASTExpression, thenExpr: ASTExpression,
<span class="gd">-        elseExpr: ASTExpression) -&gt;None:</span>
<span class="gi">+                 elseExpr: ASTExpression) -&gt; None:</span>
<span class="w"> </span>        self.ifExpr = ifExpr
<span class="w"> </span>        self.thenExpr = thenExpr
<span class="w"> </span>        self.elseExpr = elseExpr

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTConditionalExpr):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.ifExpr == other.ifExpr and self.thenExpr == other.</span>
<span class="gd">-            thenExpr and self.elseExpr == other.elseExpr)</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.ifExpr == other.ifExpr</span>
<span class="gi">+            and self.thenExpr == other.thenExpr</span>
<span class="gi">+            and self.elseExpr == other.elseExpr</span>
<span class="gi">+        )</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.ifExpr, self.thenExpr, self.elseExpr))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        res.append(transform(self.ifExpr))</span>
<span class="gi">+        res.append(&#39; ? &#39;)</span>
<span class="gi">+        res.append(transform(self.thenExpr))</span>
<span class="gi">+        res.append(&#39; : &#39;)</span>
<span class="gi">+        res.append(transform(self.elseExpr))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        assert version &gt;= 2</span>
<span class="gi">+        res = []</span>
<span class="gi">+        res.append(_id_operator_v2[&#39;?&#39;])</span>
<span class="gi">+        res.append(self.ifExpr.get_id(version))</span>
<span class="gi">+        res.append(self.thenExpr.get_id(version))</span>
<span class="gi">+        res.append(self.elseExpr.get_id(version))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        self.ifExpr.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_space()</span>
<span class="gi">+        signode += addnodes.desc_sig_operator(&#39;?&#39;, &#39;?&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_space()</span>
<span class="gi">+        self.thenExpr.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_space()</span>
<span class="gi">+        signode += addnodes.desc_sig_operator(&#39;:&#39;, &#39;:&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_space()</span>
<span class="gi">+        self.elseExpr.describe_signature(signode, mode, env, symbol)</span>

<span class="gd">-class ASTBracedInitList(ASTBase):</span>

<span class="gi">+class ASTBracedInitList(ASTBase):</span>
<span class="w"> </span>    def __init__(self, exprs: list[ASTExpression | ASTBracedInitList],
<span class="gd">-        trailingComma: bool) -&gt;None:</span>
<span class="gi">+                 trailingComma: bool) -&gt; None:</span>
<span class="w"> </span>        self.exprs = exprs
<span class="w"> </span>        self.trailingComma = trailingComma

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTBracedInitList):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.exprs == other.exprs and self.trailingComma == other.</span>
<span class="gd">-            trailingComma)</span>
<span class="gi">+        return self.exprs == other.exprs and self.trailingComma == other.trailingComma</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.exprs, self.trailingComma))

<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        return &quot;il%sE&quot; % &#39;&#39;.join(e.get_id(version) for e in self.exprs)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        exprs = &#39;, &#39;.join(transform(e) for e in self.exprs)</span>
<span class="gi">+        trailingComma = &#39;,&#39; if self.trailingComma else &#39;&#39;</span>
<span class="gi">+        return f&#39;{{{exprs}{trailingComma}}}&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;{&#39;, &#39;{&#39;)</span>
<span class="gi">+        first = True</span>
<span class="gi">+        for e in self.exprs:</span>
<span class="gi">+            if not first:</span>
<span class="gi">+                signode += addnodes.desc_sig_punctuation(&#39;,&#39;, &#39;,&#39;)</span>
<span class="gi">+                signode += addnodes.desc_sig_space()</span>
<span class="gi">+            else:</span>
<span class="gi">+                first = False</span>
<span class="gi">+            e.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        if self.trailingComma:</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;,&#39;, &#39;,&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;}&#39;, &#39;}&#39;)</span>

<span class="gd">-class ASTAssignmentExpr(ASTExpression):</span>

<span class="gd">-    def __init__(self, leftExpr: ASTExpression, op: str, rightExpr: (</span>
<span class="gd">-        ASTExpression | ASTBracedInitList)) -&gt;None:</span>
<span class="gi">+class ASTAssignmentExpr(ASTExpression):</span>
<span class="gi">+    def __init__(self, leftExpr: ASTExpression, op: str,</span>
<span class="gi">+                 rightExpr: ASTExpression | ASTBracedInitList) -&gt; None:</span>
<span class="w"> </span>        self.leftExpr = leftExpr
<span class="w"> </span>        self.op = op
<span class="w"> </span>        self.rightExpr = rightExpr

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTAssignmentExpr):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.leftExpr == other.leftExpr and self.op == other.op and</span>
<span class="gd">-            self.rightExpr == other.rightExpr)</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.leftExpr == other.leftExpr</span>
<span class="gi">+            and self.op == other.op</span>
<span class="gi">+            and self.rightExpr == other.rightExpr</span>
<span class="gi">+        )</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.leftExpr, self.op, self.rightExpr))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        res.append(transform(self.leftExpr))</span>
<span class="gi">+        res.append(&#39; &#39;)</span>
<span class="gi">+        res.append(self.op)</span>
<span class="gi">+        res.append(&#39; &#39;)</span>
<span class="gi">+        res.append(transform(self.rightExpr))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        # we end up generating the ID from left to right, instead of right to left</span>
<span class="gi">+        res = []</span>
<span class="gi">+        res.append(_id_operator_v2[self.op])</span>
<span class="gi">+        res.append(self.leftExpr.get_id(version))</span>
<span class="gi">+        res.append(self.rightExpr.get_id(version))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        self.leftExpr.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_space()</span>
<span class="gi">+        if ord(self.op[0]) &gt;= ord(&#39;a&#39;) and ord(self.op[0]) &lt;= ord(&#39;z&#39;):</span>
<span class="gi">+            signode += addnodes.desc_sig_keyword(self.op, self.op)</span>
<span class="gi">+        else:</span>
<span class="gi">+            signode += addnodes.desc_sig_operator(self.op, self.op)</span>
<span class="gi">+        signode += addnodes.desc_sig_space()</span>
<span class="gi">+        self.rightExpr.describe_signature(signode, mode, env, symbol)</span>

<span class="gd">-class ASTCommaExpr(ASTExpression):</span>

<span class="gd">-    def __init__(self, exprs: list[ASTExpression]) -&gt;None:</span>
<span class="gi">+class ASTCommaExpr(ASTExpression):</span>
<span class="gi">+    def __init__(self, exprs: list[ASTExpression]) -&gt; None:</span>
<span class="w"> </span>        assert len(exprs) &gt; 0
<span class="w"> </span>        self.exprs = exprs

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTCommaExpr):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.exprs == other.exprs

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.exprs)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &#39;, &#39;.join(transform(e) for e in self.exprs)</span>

<span class="gd">-class ASTFallbackExpr(ASTExpression):</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        id_ = _id_operator_v2[&#39;,&#39;]</span>
<span class="gi">+        res = []</span>
<span class="gi">+        for i in range(len(self.exprs) - 1):</span>
<span class="gi">+            res.append(id_)</span>
<span class="gi">+            res.append(self.exprs[i].get_id(version))</span>
<span class="gi">+        res.append(self.exprs[-1].get_id(version))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>

<span class="gd">-    def __init__(self, expr: str) -&gt;None:</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        self.exprs[0].describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        for i in range(1, len(self.exprs)):</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;,&#39;, &#39;,&#39;)</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            self.exprs[i].describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ASTFallbackExpr(ASTExpression):</span>
<span class="gi">+    def __init__(self, expr: str) -&gt; None:</span>
<span class="w"> </span>        self.expr = expr

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTFallbackExpr):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.expr == other.expr

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.expr)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return self.expr</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        return str(self.expr)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += nodes.literal(self.expr, self.expr)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+################################################################################</span>
<span class="gi">+# Types</span>
<span class="gi">+################################################################################</span>
<span class="gi">+</span>
<span class="gi">+# Things for ASTNestedName</span>
<span class="gi">+################################################################################</span>

<span class="w"> </span>class ASTOperator(ASTBase):
<span class="w"> </span>    is_anonymous: ClassVar[Literal[False]] = False

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        raise NotImplementedError(repr(self))

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        raise NotImplementedError(repr(self))

<span class="gd">-    def _describe_identifier(self, signode: TextElement, identnode:</span>
<span class="gd">-        TextElement, env: BuildEnvironment, symbol: Symbol) -&gt;None:</span>
<span class="gi">+    def is_anon(self) -&gt; bool:</span>
<span class="gi">+        return self.is_anonymous</span>
<span class="gi">+</span>
<span class="gi">+    def is_operator(self) -&gt; bool:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def _describe_identifier(self, signode: TextElement, identnode: TextElement,</span>
<span class="gi">+                             env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Render the prefix into signode, and the last part into identnode.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, prefix: str, templateArgs: str,</span>
<span class="gi">+                           symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        if mode == &#39;lastIsName&#39;:</span>
<span class="gi">+            mainName = addnodes.desc_name()</span>
<span class="gi">+            self._describe_identifier(mainName, mainName, env, symbol)</span>
<span class="gi">+            signode += mainName</span>
<span class="gi">+        elif mode == &#39;markType&#39;:</span>
<span class="gi">+            targetText = prefix + str(self) + templateArgs</span>
<span class="gi">+            pnode = addnodes.pending_xref(&#39;&#39;, refdomain=&#39;cpp&#39;,</span>
<span class="gi">+                                          reftype=&#39;identifier&#39;,</span>
<span class="gi">+                                          reftarget=targetText, modname=None,</span>
<span class="gi">+                                          classname=None)</span>
<span class="gi">+            pnode[&#39;cpp:parent_key&#39;] = symbol.get_lookup_key()</span>
<span class="gi">+            # Render the identifier part, but collapse it into a string</span>
<span class="gi">+            # and make that the a link to this operator.</span>
<span class="gi">+            # E.g., if it is &#39;operator SomeType&#39;, then &#39;SomeType&#39; becomes</span>
<span class="gi">+            # a link to the operator, not to &#39;SomeType&#39;.</span>
<span class="gi">+            container = nodes.literal()</span>
<span class="gi">+            self._describe_identifier(signode, container, env, symbol)</span>
<span class="gi">+            txt = container.astext()</span>
<span class="gi">+            pnode += addnodes.desc_name(txt, txt)</span>
<span class="gi">+            signode += pnode</span>
<span class="gi">+        else:</span>
<span class="gi">+            addName = addnodes.desc_addname()</span>
<span class="gi">+            self._describe_identifier(addName, addName, env, symbol)</span>
<span class="gi">+            signode += addName</span>


<span class="w"> </span>class ASTOperatorBuildIn(ASTOperator):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, op: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, op: str) -&gt; None:</span>
<span class="w"> </span>        self.op = op

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTOperatorBuildIn):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.op == other.op

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.op)

<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            ids = _id_operator_v1</span>
<span class="gi">+            if self.op not in ids:</span>
<span class="gi">+                raise NoOldIdError</span>
<span class="gi">+        else:</span>
<span class="gi">+            ids = _id_operator_v2</span>
<span class="gi">+        if self.op not in ids:</span>
<span class="gi">+            raise Exception(&#39;Internal error: Built-in operator &quot;%s&quot; can not &#39;</span>
<span class="gi">+                            &#39;be mapped to an id.&#39; % self.op)</span>
<span class="gi">+        return ids[self.op]</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        if self.op in (&#39;new&#39;, &#39;new[]&#39;, &#39;delete&#39;, &#39;delete[]&#39;) or self.op[0] in &quot;abcnox&quot;:</span>
<span class="gi">+            return &#39;operator &#39; + self.op</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;operator&#39; + self.op</span>
<span class="gi">+</span>
<span class="gi">+    def _describe_identifier(self, signode: TextElement, identnode: TextElement,</span>
<span class="gi">+                             env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(&#39;operator&#39;, &#39;operator&#39;)</span>
<span class="gi">+        if self.op in (&#39;new&#39;, &#39;new[]&#39;, &#39;delete&#39;, &#39;delete[]&#39;) or self.op[0] in &quot;abcnox&quot;:</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+        identnode += addnodes.desc_sig_operator(self.op, self.op)</span>

<span class="gd">-class ASTOperatorLiteral(ASTOperator):</span>

<span class="gd">-    def __init__(self, identifier: ASTIdentifier) -&gt;None:</span>
<span class="gi">+class ASTOperatorLiteral(ASTOperator):</span>
<span class="gi">+    def __init__(self, identifier: ASTIdentifier) -&gt; None:</span>
<span class="w"> </span>        self.identifier = identifier

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTOperatorLiteral):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.identifier == other.identifier

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.identifier)

<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            raise NoOldIdError</span>
<span class="gi">+        return &#39;li&#39; + self.identifier.get_id(version)</span>

<span class="gd">-class ASTOperatorType(ASTOperator):</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &#39;operator&quot;&quot;&#39; + transform(self.identifier)</span>
<span class="gi">+</span>
<span class="gi">+    def _describe_identifier(self, signode: TextElement, identnode: TextElement,</span>
<span class="gi">+                             env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(&#39;operator&#39;, &#39;operator&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_literal_string(&#39;&quot;&quot;&#39;, &#39;&quot;&quot;&#39;)</span>
<span class="gi">+        self.identifier.describe_signature(identnode, &#39;markType&#39;, env, &#39;&#39;, &#39;&#39;, symbol)</span>

<span class="gd">-    def __init__(self, type: ASTType) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class ASTOperatorType(ASTOperator):</span>
<span class="gi">+    def __init__(self, type: ASTType) -&gt; None:</span>
<span class="w"> </span>        self.type = type

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTOperatorType):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.type == other.type

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.type)

<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            return &#39;castto-%s-operator&#39; % self.type.get_id(version)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;cv&#39; + self.type.get_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return f&#39;operator {transform(self.type)}&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def get_name_no_template(self) -&gt; str:</span>
<span class="gi">+        return str(self)</span>
<span class="gi">+</span>
<span class="gi">+    def _describe_identifier(self, signode: TextElement, identnode: TextElement,</span>
<span class="gi">+                             env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(&#39;operator&#39;, &#39;operator&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_space()</span>
<span class="gi">+        self.type.describe_signature(identnode, &#39;markType&#39;, env, symbol)</span>

<span class="gd">-class ASTTemplateArgConstant(ASTBase):</span>

<span class="gd">-    def __init__(self, value: ASTExpression) -&gt;None:</span>
<span class="gi">+class ASTTemplateArgConstant(ASTBase):</span>
<span class="gi">+    def __init__(self, value: ASTExpression) -&gt; None:</span>
<span class="w"> </span>        self.value = value

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTTemplateArgConstant):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.value == other.value

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.value)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return transform(self.value)</span>

<span class="gd">-class ASTTemplateArgs(ASTBase):</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            return str(self).replace(&#39; &#39;, &#39;-&#39;)</span>
<span class="gi">+        if version == 2:</span>
<span class="gi">+            return &#39;X&#39; + str(self) + &#39;E&#39;</span>
<span class="gi">+        return &#39;X&#39; + self.value.get_id(version) + &#39;E&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        self.value.describe_signature(signode, mode, env, symbol)</span>

<span class="gi">+</span>
<span class="gi">+class ASTTemplateArgs(ASTBase):</span>
<span class="w"> </span>    def __init__(self, args: list[ASTType | ASTTemplateArgConstant],
<span class="gd">-        packExpansion: bool) -&gt;None:</span>
<span class="gi">+                 packExpansion: bool) -&gt; None:</span>
<span class="w"> </span>        assert args is not None
<span class="w"> </span>        self.args = args
<span class="w"> </span>        self.packExpansion = packExpansion

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTTemplateArgs):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.args == other.args and self.packExpansion == other.</span>
<span class="gd">-            packExpansion)</span>
<span class="gi">+        return self.args == other.args and self.packExpansion == other.packExpansion</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.args, self.packExpansion))

<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            res = []</span>
<span class="gi">+            res.append(&#39;:&#39;)</span>
<span class="gi">+            res.append(&#39;.&#39;.join(a.get_id(version) for a in self.args))</span>
<span class="gi">+            res.append(&#39;:&#39;)</span>
<span class="gi">+            return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+        res = []</span>
<span class="gi">+        res.append(&#39;I&#39;)</span>
<span class="gi">+        if len(self.args) &gt; 0:</span>
<span class="gi">+            for a in self.args[:-1]:</span>
<span class="gi">+                res.append(a.get_id(version))</span>
<span class="gi">+            if self.packExpansion:</span>
<span class="gi">+                res.append(&#39;J&#39;)</span>
<span class="gi">+            res.append(self.args[-1].get_id(version))</span>
<span class="gi">+            if self.packExpansion:</span>
<span class="gi">+                res.append(&#39;E&#39;)</span>
<span class="gi">+        res.append(&#39;E&#39;)</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = &#39;, &#39;.join(transform(a) for a in self.args)</span>
<span class="gi">+        if self.packExpansion:</span>
<span class="gi">+            res += &#39;...&#39;</span>
<span class="gi">+        return &#39;&lt;&#39; + res + &#39;&gt;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;&lt;&#39;, &#39;&lt;&#39;)</span>
<span class="gi">+        first = True</span>
<span class="gi">+        for a in self.args:</span>
<span class="gi">+            if not first:</span>
<span class="gi">+                signode += addnodes.desc_sig_punctuation(&#39;,&#39;, &#39;,&#39;)</span>
<span class="gi">+                signode += addnodes.desc_sig_space()</span>
<span class="gi">+            first = False</span>
<span class="gi">+            a.describe_signature(signode, &#39;markType&#39;, env, symbol=symbol)</span>
<span class="gi">+        if self.packExpansion:</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;...&#39;, &#39;...&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;&gt;&#39;, &#39;&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Main part of declarations</span>
<span class="gi">+################################################################################</span>

<span class="w"> </span>class ASTTrailingTypeSpec(ASTBase):
<span class="gd">-    pass</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>

<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>

<span class="gd">-class ASTTrailingTypeSpecFundamental(ASTTrailingTypeSpec):</span>

<span class="gd">-    def __init__(self, names: list[str], canonNames: list[str]) -&gt;None:</span>
<span class="gi">+class ASTTrailingTypeSpecFundamental(ASTTrailingTypeSpec):</span>
<span class="gi">+    def __init__(self, names: list[str], canonNames: list[str]) -&gt; None:</span>
<span class="w"> </span>        assert len(names) != 0
<span class="w"> </span>        assert len(names) == len(canonNames), (names, canonNames)
<span class="w"> </span>        self.names = names
<span class="gi">+        # the canonical name list is for ID lookup</span>
<span class="w"> </span>        self.canonNames = canonNames

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTTrailingTypeSpecFundamental):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.names == other.names and self.canonNames == other.</span>
<span class="gd">-            canonNames)</span>
<span class="gi">+        return self.names == other.names and self.canonNames == other.canonNames</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.names, self.canonNames))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &#39; &#39;.join(self.names)</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            res = []</span>
<span class="gi">+            for a in self.canonNames:</span>
<span class="gi">+                if a in _id_fundamental_v1:</span>
<span class="gi">+                    res.append(_id_fundamental_v1[a])</span>
<span class="gi">+                else:</span>
<span class="gi">+                    res.append(a)</span>
<span class="gi">+            return &#39;-&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+        txt = &#39; &#39;.join(self.canonNames)</span>
<span class="gi">+        if txt not in _id_fundamental_v2:</span>
<span class="gi">+            raise Exception(</span>
<span class="gi">+                &#39;Semi-internal error: Fundamental type &quot;%s&quot; can not be mapped &#39;</span>
<span class="gi">+                &#39;to an ID. Is it a true fundamental type? If not so, the &#39;</span>
<span class="gi">+                &#39;parser should have rejected it.&#39; % txt)</span>
<span class="gi">+        return _id_fundamental_v2[txt]</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        first = True</span>
<span class="gi">+        for n in self.names:</span>
<span class="gi">+            if not first:</span>
<span class="gi">+                signode += addnodes.desc_sig_space()</span>
<span class="gi">+            else:</span>
<span class="gi">+                first = False</span>
<span class="gi">+            signode += addnodes.desc_sig_keyword_type(n, n)</span>

<span class="gd">-class ASTTrailingTypeSpecDecltypeAuto(ASTTrailingTypeSpec):</span>

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+class ASTTrailingTypeSpecDecltypeAuto(ASTTrailingTypeSpec):</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return isinstance(other, ASTTrailingTypeSpecDecltypeAuto)

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(&#39;decltype(auto)&#39;)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &#39;decltype(auto)&#39;</span>

<span class="gd">-class ASTTrailingTypeSpecDecltype(ASTTrailingTypeSpec):</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            raise NoOldIdError</span>
<span class="gi">+        return &#39;Dc&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(&#39;decltype&#39;, &#39;decltype&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;(&#39;, &#39;(&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(&#39;auto&#39;, &#39;auto&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;)&#39;, &#39;)&#39;)</span>

<span class="gd">-    def __init__(self, expr: ASTExpression) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class ASTTrailingTypeSpecDecltype(ASTTrailingTypeSpec):</span>
<span class="gi">+    def __init__(self, expr: ASTExpression) -&gt; None:</span>
<span class="w"> </span>        self.expr = expr

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTTrailingTypeSpecDecltype):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.expr == other.expr

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.expr)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &#39;decltype(&#39; + transform(self.expr) + &#39;)&#39;</span>

<span class="gd">-class ASTTrailingTypeSpecName(ASTTrailingTypeSpec):</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            raise NoOldIdError</span>
<span class="gi">+        return &#39;DT&#39; + self.expr.get_id(version) + &quot;E&quot;</span>

<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(&#39;decltype&#39;, &#39;decltype&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;(&#39;, &#39;(&#39;)</span>
<span class="gi">+        self.expr.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;)&#39;, &#39;)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ASTTrailingTypeSpecName(ASTTrailingTypeSpec):</span>
<span class="w"> </span>    def __init__(self, prefix: str, nestedName: ASTNestedName,
<span class="gd">-        placeholderType: (str | None)) -&gt;None:</span>
<span class="gi">+                 placeholderType: str | None) -&gt; None:</span>
<span class="w"> </span>        self.prefix = prefix
<span class="w"> </span>        self.nestedName = nestedName
<span class="w"> </span>        self.placeholderType = placeholderType

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTTrailingTypeSpecName):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.prefix == other.prefix and self.nestedName == other.</span>
<span class="gd">-            nestedName and self.placeholderType == other.placeholderType)</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.prefix == other.prefix</span>
<span class="gi">+            and self.nestedName == other.nestedName</span>
<span class="gi">+            and self.placeholderType == other.placeholderType</span>
<span class="gi">+        )</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.prefix, self.nestedName, self.placeholderType))

<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        return self.nestedName</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        return self.nestedName.get_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        if self.prefix:</span>
<span class="gi">+            res.append(self.prefix)</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+        res.append(transform(self.nestedName))</span>
<span class="gi">+        if self.placeholderType is not None:</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+            res.append(self.placeholderType)</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        if self.prefix:</span>
<span class="gi">+            signode += addnodes.desc_sig_keyword(self.prefix, self.prefix)</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+        self.nestedName.describe_signature(signode, mode, env, symbol=symbol)</span>
<span class="gi">+        if self.placeholderType is not None:</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            if self.placeholderType == &#39;auto&#39;:</span>
<span class="gi">+                signode += addnodes.desc_sig_keyword(&#39;auto&#39;, &#39;auto&#39;)</span>
<span class="gi">+            elif self.placeholderType == &#39;decltype(auto)&#39;:</span>
<span class="gi">+                signode += addnodes.desc_sig_keyword(&#39;decltype&#39;, &#39;decltype&#39;)</span>
<span class="gi">+                signode += addnodes.desc_sig_punctuation(&#39;(&#39;, &#39;(&#39;)</span>
<span class="gi">+                signode += addnodes.desc_sig_keyword(&#39;auto&#39;, &#39;auto&#39;)</span>
<span class="gi">+                signode += addnodes.desc_sig_punctuation(&#39;)&#39;, &#39;)&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise AssertionError(self.placeholderType)</span>

<span class="gd">-class ASTFunctionParameter(ASTBase):</span>

<span class="gd">-    def __init__(self, arg: (ASTTypeWithInit |</span>
<span class="gd">-        ASTTemplateParamConstrainedTypeWithInit), ellipsis: bool=False) -&gt;None:</span>
<span class="gi">+class ASTFunctionParameter(ASTBase):</span>
<span class="gi">+    def __init__(self, arg: ASTTypeWithInit | ASTTemplateParamConstrainedTypeWithInit,</span>
<span class="gi">+                 ellipsis: bool = False) -&gt; None:</span>
<span class="w"> </span>        self.arg = arg
<span class="w"> </span>        self.ellipsis = ellipsis

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTFunctionParameter):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.arg == other.arg and self.ellipsis == other.ellipsis

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.arg, self.ellipsis))

<span class="gi">+    def get_id(</span>
<span class="gi">+        self, version: int, objectType: str | None = None, symbol: Symbol | None = None,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        # this is not part of the normal name mangling in C++</span>
<span class="gi">+        if symbol:</span>
<span class="gi">+            # the anchor will be our parent</span>
<span class="gi">+            return symbol.parent.declaration.get_id(version, prefixed=False)</span>
<span class="gi">+        # else, do the usual</span>
<span class="gi">+        if self.ellipsis:</span>
<span class="gi">+            return &#39;z&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.arg.get_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        if self.ellipsis:</span>
<span class="gi">+            return &#39;...&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return transform(self.arg)</span>

<span class="gd">-class ASTNoexceptSpec(ASTBase):</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        if self.ellipsis:</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;...&#39;, &#39;...&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.arg.describe_signature(signode, mode, env, symbol=symbol)</span>

<span class="gd">-    def __init__(self, expr: (ASTExpression | None)) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class ASTNoexceptSpec(ASTBase):</span>
<span class="gi">+    def __init__(self, expr: ASTExpression | None) -&gt; None:</span>
<span class="w"> </span>        self.expr = expr

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTNoexceptSpec):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.expr == other.expr

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.expr)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        if self.expr:</span>
<span class="gi">+            return &#39;noexcept(&#39; + transform(self.expr) + &#39;)&#39;</span>
<span class="gi">+        return &#39;noexcept&#39;</span>

<span class="gd">-class ASTParametersQualifiers(ASTBase):</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(&#39;noexcept&#39;, &#39;noexcept&#39;)</span>
<span class="gi">+        if self.expr:</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;(&#39;, &#39;(&#39;)</span>
<span class="gi">+            self.expr.describe_signature(signode, &#39;markType&#39;, env, symbol)</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;)&#39;, &#39;)&#39;)</span>

<span class="gd">-    def __init__(self, args: list[ASTFunctionParameter], volatile: bool,</span>
<span class="gd">-        const: bool, refQual: (str | None), exceptionSpec: ASTNoexceptSpec,</span>
<span class="gd">-        trailingReturn: ASTType, override: bool, final: bool, attrs:</span>
<span class="gd">-        ASTAttributeList, initializer: (str | None)) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class ASTParametersQualifiers(ASTBase):</span>
<span class="gi">+    def __init__(self, args: list[ASTFunctionParameter], volatile: bool, const: bool,</span>
<span class="gi">+                 refQual: str | None, exceptionSpec: ASTNoexceptSpec,</span>
<span class="gi">+                 trailingReturn: ASTType,</span>
<span class="gi">+                 override: bool, final: bool, attrs: ASTAttributeList,</span>
<span class="gi">+                 initializer: str | None) -&gt; None:</span>
<span class="w"> </span>        self.args = args
<span class="w"> </span>        self.volatile = volatile
<span class="w"> </span>        self.const = const
<span class="gu">@@ -791,42 +1950,197 @@ class ASTParametersQualifiers(ASTBase):</span>
<span class="w"> </span>        self.attrs = attrs
<span class="w"> </span>        self.initializer = initializer

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTParametersQualifiers):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.args == other.args and self.volatile == other.volatile and</span>
<span class="gd">-            self.const == other.const and self.refQual == other.refQual and</span>
<span class="gd">-            self.exceptionSpec == other.exceptionSpec and self.</span>
<span class="gd">-            trailingReturn == other.trailingReturn and self.override ==</span>
<span class="gd">-            other.override and self.final == other.final and self.attrs ==</span>
<span class="gd">-            other.attrs and self.initializer == other.initializer)</span>
<span class="gd">-</span>
<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gd">-        return hash((self.args, self.volatile, self.const, self.refQual,</span>
<span class="gd">-            self.exceptionSpec, self.trailingReturn, self.override, self.</span>
<span class="gd">-            final, self.attrs, self.initializer))</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.args == other.args</span>
<span class="gi">+            and self.volatile == other.volatile</span>
<span class="gi">+            and self.const == other.const</span>
<span class="gi">+            and self.refQual == other.refQual</span>
<span class="gi">+            and self.exceptionSpec == other.exceptionSpec</span>
<span class="gi">+            and self.trailingReturn == other.trailingReturn</span>
<span class="gi">+            and self.override == other.override</span>
<span class="gi">+            and self.final == other.final</span>
<span class="gi">+            and self.attrs == other.attrs</span>
<span class="gi">+            and self.initializer == other.initializer</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="gi">+        return hash((</span>
<span class="gi">+            self.args, self.volatile, self.const, self.refQual, self.exceptionSpec,</span>
<span class="gi">+            self.trailingReturn, self.override, self.final, self.attrs, self.initializer</span>
<span class="gi">+        ))</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def function_params(self) -&gt; list[ASTFunctionParameter]:</span>
<span class="gi">+        return self.args</span>
<span class="gi">+</span>
<span class="gi">+    def get_modifiers_id(self, version: int) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        if self.volatile:</span>
<span class="gi">+            res.append(&#39;V&#39;)</span>
<span class="gi">+        if self.const:</span>
<span class="gi">+            if version == 1:</span>
<span class="gi">+                res.append(&#39;C&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                res.append(&#39;K&#39;)</span>
<span class="gi">+        if self.refQual == &#39;&amp;&amp;&#39;:</span>
<span class="gi">+            res.append(&#39;O&#39;)</span>
<span class="gi">+        elif self.refQual == &#39;&amp;&#39;:</span>
<span class="gi">+            res.append(&#39;R&#39;)</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def get_param_id(self, version: int) -&gt; str:</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            if len(self.args) == 0:</span>
<span class="gi">+                return &#39;&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                return &#39;__&#39; + &#39;.&#39;.join(a.get_id(version) for a in self.args)</span>
<span class="gi">+        if len(self.args) == 0:</span>
<span class="gi">+            return &#39;v&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;&#39;.join(a.get_id(version) for a in self.args)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        res.append(&#39;(&#39;)</span>
<span class="gi">+        first = True</span>
<span class="gi">+        for a in self.args:</span>
<span class="gi">+            if not first:</span>
<span class="gi">+                res.append(&#39;, &#39;)</span>
<span class="gi">+            first = False</span>
<span class="gi">+            res.append(str(a))</span>
<span class="gi">+        res.append(&#39;)&#39;)</span>
<span class="gi">+        if self.volatile:</span>
<span class="gi">+            res.append(&#39; volatile&#39;)</span>
<span class="gi">+        if self.const:</span>
<span class="gi">+            res.append(&#39; const&#39;)</span>
<span class="gi">+        if self.refQual:</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+            res.append(self.refQual)</span>
<span class="gi">+        if self.exceptionSpec:</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+            res.append(transform(self.exceptionSpec))</span>
<span class="gi">+        if self.trailingReturn:</span>
<span class="gi">+            res.append(&#39; -&gt; &#39;)</span>
<span class="gi">+            res.append(transform(self.trailingReturn))</span>
<span class="gi">+        if self.final:</span>
<span class="gi">+            res.append(&#39; final&#39;)</span>
<span class="gi">+        if self.override:</span>
<span class="gi">+            res.append(&#39; override&#39;)</span>
<span class="gi">+        if len(self.attrs) != 0:</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+            res.append(transform(self.attrs))</span>
<span class="gi">+        if self.initializer:</span>
<span class="gi">+            res.append(&#39; = &#39;)</span>
<span class="gi">+            res.append(self.initializer)</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        multi_line_parameter_list = False</span>
<span class="gi">+        test_node: Element = signode</span>
<span class="gi">+        while test_node.parent:</span>
<span class="gi">+            if not isinstance(test_node, addnodes.desc_signature):</span>
<span class="gi">+                test_node = test_node.parent</span>
<span class="gi">+                continue</span>
<span class="gi">+            multi_line_parameter_list = test_node.get(&#39;multi_line_parameter_list&#39;, False)</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+        # only use the desc_parameterlist for the outer list, not for inner lists</span>
<span class="gi">+        if mode == &#39;lastIsName&#39;:</span>
<span class="gi">+            paramlist = addnodes.desc_parameterlist()</span>
<span class="gi">+            paramlist[&#39;multi_line_parameter_list&#39;] = multi_line_parameter_list</span>
<span class="gi">+            for arg in self.args:</span>
<span class="gi">+                param = addnodes.desc_parameter(&#39;&#39;, &#39;&#39;, noemph=True)</span>
<span class="gi">+                arg.describe_signature(param, &#39;param&#39;, env, symbol=symbol)</span>
<span class="gi">+                paramlist += param</span>
<span class="gi">+            signode += paramlist</span>
<span class="gi">+        else:</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;(&#39;, &#39;(&#39;)</span>
<span class="gi">+            first = True</span>
<span class="gi">+            for arg in self.args:</span>
<span class="gi">+                if not first:</span>
<span class="gi">+                    signode += addnodes.desc_sig_punctuation(&#39;,&#39;, &#39;,&#39;)</span>
<span class="gi">+                    signode += addnodes.desc_sig_space()</span>
<span class="gi">+                first = False</span>
<span class="gi">+                arg.describe_signature(signode, &#39;markType&#39;, env, symbol=symbol)</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;)&#39;, &#39;)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        def _add_anno(signode: TextElement, text: str) -&gt; None:</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            signode += addnodes.desc_sig_keyword(text, text)</span>
<span class="gi">+</span>
<span class="gi">+        if self.volatile:</span>
<span class="gi">+            _add_anno(signode, &#39;volatile&#39;)</span>
<span class="gi">+        if self.const:</span>
<span class="gi">+            _add_anno(signode, &#39;const&#39;)</span>
<span class="gi">+        if self.refQual:</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(self.refQual, self.refQual)</span>
<span class="gi">+        if self.exceptionSpec:</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            self.exceptionSpec.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        if self.trailingReturn:</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            signode += addnodes.desc_sig_operator(&#39;-&gt;&#39;, &#39;-&gt;&#39;)</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            self.trailingReturn.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        if self.final:</span>
<span class="gi">+            _add_anno(signode, &#39;final&#39;)</span>
<span class="gi">+        if self.override:</span>
<span class="gi">+            _add_anno(signode, &#39;override&#39;)</span>
<span class="gi">+        if len(self.attrs) != 0:</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            self.attrs.describe_signature(signode)</span>
<span class="gi">+        if self.initializer:</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;=&#39;, &#39;=&#39;)</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            assert self.initializer in (&#39;0&#39;, &#39;delete&#39;, &#39;default&#39;)</span>
<span class="gi">+            if self.initializer == &#39;0&#39;:</span>
<span class="gi">+                signode += addnodes.desc_sig_literal_number(&#39;0&#39;, &#39;0&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                signode += addnodes.desc_sig_keyword(self.initializer, self.initializer)</span>


<span class="w"> </span>class ASTExplicitSpec(ASTBase):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, expr: (ASTExpression | None)) -&gt;None:</span>
<span class="gi">+    def __init__(self, expr: ASTExpression | None) -&gt; None:</span>
<span class="w"> </span>        self.expr = expr

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTExplicitSpec):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.expr == other.expr

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.expr)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = [&#39;explicit&#39;]</span>
<span class="gi">+        if self.expr is not None:</span>
<span class="gi">+            res.append(&#39;(&#39;)</span>
<span class="gi">+            res.append(transform(self.expr))</span>
<span class="gi">+            res.append(&#39;)&#39;)</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>

<span class="gd">-class ASTDeclSpecsSimple(ASTBase):</span>
<span class="gi">+    def describe_signature(self, signode: TextElement,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(&#39;explicit&#39;, &#39;explicit&#39;)</span>
<span class="gi">+        if self.expr is not None:</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;(&#39;, &#39;(&#39;)</span>
<span class="gi">+            self.expr.describe_signature(signode, &#39;markType&#39;, env, symbol)</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;)&#39;, &#39;)&#39;)</span>

<span class="gd">-    def __init__(self, storage: str, threadLocal: bool, inline: bool,</span>
<span class="gd">-        virtual: bool, explicitSpec: (ASTExplicitSpec | None), consteval:</span>
<span class="gd">-        bool, constexpr: bool, constinit: bool, volatile: bool, const: bool,</span>
<span class="gd">-        friend: bool, attrs: ASTAttributeList) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class ASTDeclSpecsSimple(ASTBase):</span>
<span class="gi">+    def __init__(self, storage: str, threadLocal: bool, inline: bool, virtual: bool,</span>
<span class="gi">+                 explicitSpec: ASTExplicitSpec | None,</span>
<span class="gi">+                 consteval: bool, constexpr: bool, constinit: bool,</span>
<span class="gi">+                 volatile: bool, const: bool, friend: bool,</span>
<span class="gi">+                 attrs: ASTAttributeList) -&gt; None:</span>
<span class="w"> </span>        self.storage = storage
<span class="w"> </span>        self.threadLocal = threadLocal
<span class="w"> </span>        self.inline = inline
<span class="gu">@@ -840,152 +2154,717 @@ class ASTDeclSpecsSimple(ASTBase):</span>
<span class="w"> </span>        self.friend = friend
<span class="w"> </span>        self.attrs = attrs

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTDeclSpecsSimple):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.storage == other.storage and self.threadLocal == other</span>
<span class="gd">-            .threadLocal and self.inline == other.inline and self.virtual ==</span>
<span class="gd">-            other.virtual and self.explicitSpec == other.explicitSpec and </span>
<span class="gd">-            self.consteval == other.consteval and self.constexpr == other.</span>
<span class="gd">-            constexpr and self.constinit == other.constinit and self.</span>
<span class="gd">-            volatile == other.volatile and self.const == other.const and </span>
<span class="gd">-            self.friend == other.friend and self.attrs == other.attrs)</span>
<span class="gd">-</span>
<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gd">-        return hash((self.storage, self.threadLocal, self.inline, self.</span>
<span class="gd">-            virtual, self.explicitSpec, self.consteval, self.constexpr,</span>
<span class="gd">-            self.constinit, self.volatile, self.const, self.friend, self.attrs)</span>
<span class="gd">-            )</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.storage == other.storage</span>
<span class="gi">+            and self.threadLocal == other.threadLocal</span>
<span class="gi">+            and self.inline == other.inline</span>
<span class="gi">+            and self.virtual == other.virtual</span>
<span class="gi">+            and self.explicitSpec == other.explicitSpec</span>
<span class="gi">+            and self.consteval == other.consteval</span>
<span class="gi">+            and self.constexpr == other.constexpr</span>
<span class="gi">+            and self.constinit == other.constinit</span>
<span class="gi">+            and self.volatile == other.volatile</span>
<span class="gi">+            and self.const == other.const</span>
<span class="gi">+            and self.friend == other.friend</span>
<span class="gi">+            and self.attrs == other.attrs</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="gi">+        return hash((</span>
<span class="gi">+            self.storage,</span>
<span class="gi">+            self.threadLocal,</span>
<span class="gi">+            self.inline,</span>
<span class="gi">+            self.virtual,</span>
<span class="gi">+            self.explicitSpec,</span>
<span class="gi">+            self.consteval,</span>
<span class="gi">+            self.constexpr,</span>
<span class="gi">+            self.constinit,</span>
<span class="gi">+            self.volatile,</span>
<span class="gi">+            self.const,</span>
<span class="gi">+            self.friend,</span>
<span class="gi">+            self.attrs,</span>
<span class="gi">+        ))</span>
<span class="gi">+</span>
<span class="gi">+    def mergeWith(self, other: ASTDeclSpecsSimple) -&gt; ASTDeclSpecsSimple:</span>
<span class="gi">+        if not other:</span>
<span class="gi">+            return self</span>
<span class="gi">+        return ASTDeclSpecsSimple(self.storage or other.storage,</span>
<span class="gi">+                                  self.threadLocal or other.threadLocal,</span>
<span class="gi">+                                  self.inline or other.inline,</span>
<span class="gi">+                                  self.virtual or other.virtual,</span>
<span class="gi">+                                  self.explicitSpec or other.explicitSpec,</span>
<span class="gi">+                                  self.consteval or other.consteval,</span>
<span class="gi">+                                  self.constexpr or other.constexpr,</span>
<span class="gi">+                                  self.constinit or other.constinit,</span>
<span class="gi">+                                  self.volatile or other.volatile,</span>
<span class="gi">+                                  self.const or other.const,</span>
<span class="gi">+                                  self.friend or other.friend,</span>
<span class="gi">+                                  self.attrs + other.attrs)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res: list[str] = []</span>
<span class="gi">+        if len(self.attrs) != 0:</span>
<span class="gi">+            res.append(transform(self.attrs))</span>
<span class="gi">+        if self.storage:</span>
<span class="gi">+            res.append(self.storage)</span>
<span class="gi">+        if self.threadLocal:</span>
<span class="gi">+            res.append(&#39;thread_local&#39;)</span>
<span class="gi">+        if self.inline:</span>
<span class="gi">+            res.append(&#39;inline&#39;)</span>
<span class="gi">+        if self.friend:</span>
<span class="gi">+            res.append(&#39;friend&#39;)</span>
<span class="gi">+        if self.virtual:</span>
<span class="gi">+            res.append(&#39;virtual&#39;)</span>
<span class="gi">+        if self.explicitSpec:</span>
<span class="gi">+            res.append(transform(self.explicitSpec))</span>
<span class="gi">+        if self.consteval:</span>
<span class="gi">+            res.append(&#39;consteval&#39;)</span>
<span class="gi">+        if self.constexpr:</span>
<span class="gi">+            res.append(&#39;constexpr&#39;)</span>
<span class="gi">+        if self.constinit:</span>
<span class="gi">+            res.append(&#39;constinit&#39;)</span>
<span class="gi">+        if self.volatile:</span>
<span class="gi">+            res.append(&#39;volatile&#39;)</span>
<span class="gi">+        if self.const:</span>
<span class="gi">+            res.append(&#39;const&#39;)</span>
<span class="gi">+        return &#39; &#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        self.attrs.describe_signature(signode)</span>
<span class="gi">+        addSpace = len(self.attrs) != 0</span>
<span class="gi">+</span>
<span class="gi">+        def _add(signode: TextElement, text: str) -&gt; bool:</span>
<span class="gi">+            if addSpace:</span>
<span class="gi">+                signode += addnodes.desc_sig_space()</span>
<span class="gi">+            signode += addnodes.desc_sig_keyword(text, text)</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        if self.storage:</span>
<span class="gi">+            addSpace = _add(signode, self.storage)</span>
<span class="gi">+        if self.threadLocal:</span>
<span class="gi">+            addSpace = _add(signode, &#39;thread_local&#39;)</span>
<span class="gi">+        if self.inline:</span>
<span class="gi">+            addSpace = _add(signode, &#39;inline&#39;)</span>
<span class="gi">+        if self.friend:</span>
<span class="gi">+            addSpace = _add(signode, &#39;friend&#39;)</span>
<span class="gi">+        if self.virtual:</span>
<span class="gi">+            addSpace = _add(signode, &#39;virtual&#39;)</span>
<span class="gi">+        if self.explicitSpec:</span>
<span class="gi">+            if addSpace:</span>
<span class="gi">+                signode += addnodes.desc_sig_space()</span>
<span class="gi">+            self.explicitSpec.describe_signature(signode, env, symbol)</span>
<span class="gi">+            addSpace = True</span>
<span class="gi">+        if self.consteval:</span>
<span class="gi">+            addSpace = _add(signode, &#39;consteval&#39;)</span>
<span class="gi">+        if self.constexpr:</span>
<span class="gi">+            addSpace = _add(signode, &#39;constexpr&#39;)</span>
<span class="gi">+        if self.constinit:</span>
<span class="gi">+            addSpace = _add(signode, &#39;constinit&#39;)</span>
<span class="gi">+        if self.volatile:</span>
<span class="gi">+            addSpace = _add(signode, &#39;volatile&#39;)</span>
<span class="gi">+        if self.const:</span>
<span class="gi">+            addSpace = _add(signode, &#39;const&#39;)</span>


<span class="w"> </span>class ASTDeclSpecs(ASTBase):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, outer: str, leftSpecs: ASTDeclSpecsSimple,</span>
<span class="gd">-        rightSpecs: ASTDeclSpecsSimple, trailing: ASTTrailingTypeSpec) -&gt;None:</span>
<span class="gi">+    def __init__(self, outer: str,</span>
<span class="gi">+                 leftSpecs: ASTDeclSpecsSimple, rightSpecs: ASTDeclSpecsSimple,</span>
<span class="gi">+                 trailing: ASTTrailingTypeSpec) -&gt; None:</span>
<span class="gi">+        # leftSpecs and rightSpecs are used for output</span>
<span class="gi">+        # allSpecs are used for id generation</span>
<span class="w"> </span>        self.outer = outer
<span class="w"> </span>        self.leftSpecs = leftSpecs
<span class="w"> </span>        self.rightSpecs = rightSpecs
<span class="w"> </span>        self.allSpecs = self.leftSpecs.mergeWith(self.rightSpecs)
<span class="w"> </span>        self.trailingTypeSpec = trailing

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTDeclSpecs):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.outer == other.outer and self.leftSpecs == other.</span>
<span class="gd">-            leftSpecs and self.rightSpecs == other.rightSpecs and self.</span>
<span class="gd">-            trailingTypeSpec == other.trailingTypeSpec)</span>
<span class="gd">-</span>
<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gd">-        return hash((self.outer, self.leftSpecs, self.rightSpecs, self.</span>
<span class="gd">-            trailingTypeSpec))</span>
<span class="gd">-</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.outer == other.outer</span>
<span class="gi">+            and self.leftSpecs == other.leftSpecs</span>
<span class="gi">+            and self.rightSpecs == other.rightSpecs</span>
<span class="gi">+            and self.trailingTypeSpec == other.trailingTypeSpec</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="gi">+        return hash((</span>
<span class="gi">+            self.outer,</span>
<span class="gi">+            self.leftSpecs,</span>
<span class="gi">+            self.rightSpecs,</span>
<span class="gi">+            self.trailingTypeSpec,</span>
<span class="gi">+        ))</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            res = []</span>
<span class="gi">+            res.append(self.trailingTypeSpec.get_id(version))</span>
<span class="gi">+            if self.allSpecs.volatile:</span>
<span class="gi">+                res.append(&#39;V&#39;)</span>
<span class="gi">+            if self.allSpecs.const:</span>
<span class="gi">+                res.append(&#39;C&#39;)</span>
<span class="gi">+            return &#39;&#39;.join(res)</span>
<span class="gi">+        res = []</span>
<span class="gi">+        if self.allSpecs.volatile:</span>
<span class="gi">+            res.append(&#39;V&#39;)</span>
<span class="gi">+        if self.allSpecs.const:</span>
<span class="gi">+            res.append(&#39;K&#39;)</span>
<span class="gi">+        if self.trailingTypeSpec is not None:</span>
<span class="gi">+            res.append(self.trailingTypeSpec.get_id(version))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res: list[str] = []</span>
<span class="gi">+        l = transform(self.leftSpecs)</span>
<span class="gi">+        if len(l) &gt; 0:</span>
<span class="gi">+            res.append(l)</span>
<span class="gi">+        if self.trailingTypeSpec:</span>
<span class="gi">+            if len(res) &gt; 0:</span>
<span class="gi">+                res.append(&quot; &quot;)</span>
<span class="gi">+            res.append(transform(self.trailingTypeSpec))</span>
<span class="gi">+            r = str(self.rightSpecs)</span>
<span class="gi">+            if len(r) &gt; 0:</span>
<span class="gi">+                if len(res) &gt; 0:</span>
<span class="gi">+                    res.append(&quot; &quot;)</span>
<span class="gi">+                res.append(r)</span>
<span class="gi">+        return &quot;&quot;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        numChildren = len(signode)</span>
<span class="gi">+        self.leftSpecs.describe_signature(signode, env, symbol)</span>
<span class="gi">+        addSpace = len(signode) != numChildren</span>
<span class="gi">+</span>
<span class="gi">+        if self.trailingTypeSpec:</span>
<span class="gi">+            if addSpace:</span>
<span class="gi">+                signode += addnodes.desc_sig_space()</span>
<span class="gi">+            numChildren = len(signode)</span>
<span class="gi">+            self.trailingTypeSpec.describe_signature(signode, mode, env,</span>
<span class="gi">+                                                     symbol=symbol)</span>
<span class="gi">+            addSpace = len(signode) != numChildren</span>
<span class="gi">+</span>
<span class="gi">+            if len(str(self.rightSpecs)) &gt; 0:</span>
<span class="gi">+                if addSpace:</span>
<span class="gi">+                    signode += addnodes.desc_sig_space()</span>
<span class="gi">+                self.rightSpecs.describe_signature(signode, env, symbol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Declarator</span>
<span class="gi">+################################################################################</span>

<span class="w"> </span>class ASTArray(ASTBase):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, size: ASTExpression) -&gt;None:</span>
<span class="gi">+    def __init__(self, size: ASTExpression) -&gt; None:</span>
<span class="w"> </span>        self.size = size

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTArray):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.size == other.size

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.size)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        if self.size:</span>
<span class="gi">+            return &#39;[&#39; + transform(self.size) + &#39;]&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;[]&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            return &#39;A&#39;</span>
<span class="gi">+        if version == 2:</span>
<span class="gi">+            if self.size:</span>
<span class="gi">+                return &#39;A&#39; + str(self.size) + &#39;_&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                return &#39;A_&#39;</span>
<span class="gi">+        if self.size:</span>
<span class="gi">+            return &#39;A&#39; + self.size.get_id(version) + &#39;_&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;A_&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;[&#39;, &#39;[&#39;)</span>
<span class="gi">+        if self.size:</span>
<span class="gi">+            self.size.describe_signature(signode, &#39;markType&#39;, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;]&#39;, &#39;]&#39;)</span>
<span class="gi">+</span>

<span class="w"> </span>class ASTDeclarator(ASTBase):
<span class="gd">-    pass</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>

<span class="gi">+    @name.setter</span>
<span class="gi">+    def name(self, name: ASTNestedName) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>

<span class="gd">-class ASTDeclaratorNameParamQual(ASTDeclarator):</span>
<span class="gi">+    @property</span>
<span class="gi">+    def isPack(self) -&gt; bool:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def function_params(self) -&gt; list[ASTFunctionParameter]:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def trailingReturn(self) -&gt; ASTType:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>

<span class="gd">-    def __init__(self, declId: ASTNestedName, arrayOps: list[ASTArray],</span>
<span class="gd">-        paramQual: ASTParametersQualifiers) -&gt;None:</span>
<span class="gi">+    def require_space_after_declSpecs(self) -&gt; bool:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>
<span class="gi">+</span>
<span class="gi">+    def get_modifiers_id(self, version: int) -&gt; str:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>
<span class="gi">+</span>
<span class="gi">+    def get_param_id(self, version: int) -&gt; str:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>
<span class="gi">+</span>
<span class="gi">+    def get_ptr_suffix_id(self, version: int) -&gt; str:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>
<span class="gi">+</span>
<span class="gi">+    def get_type_id(self, version: int, returnTypeId: str) -&gt; str:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>
<span class="gi">+</span>
<span class="gi">+    def is_function_type(self) -&gt; bool:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ASTDeclaratorNameParamQual(ASTDeclarator):</span>
<span class="gi">+    def __init__(self, declId: ASTNestedName,</span>
<span class="gi">+                 arrayOps: list[ASTArray],</span>
<span class="gi">+                 paramQual: ASTParametersQualifiers) -&gt; None:</span>
<span class="w"> </span>        self.declId = declId
<span class="w"> </span>        self.arrayOps = arrayOps
<span class="w"> </span>        self.paramQual = paramQual

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTDeclaratorNameParamQual):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.declId == other.declId and self.arrayOps == other.</span>
<span class="gd">-            arrayOps and self.paramQual == other.paramQual)</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.declId == other.declId</span>
<span class="gi">+            and self.arrayOps == other.arrayOps</span>
<span class="gi">+            and self.paramQual == other.paramQual</span>
<span class="gi">+        )</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.declId, self.arrayOps, self.paramQual))

<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        return self.declId</span>

<span class="gd">-class ASTDeclaratorNameBitField(ASTDeclarator):</span>
<span class="gi">+    @name.setter</span>
<span class="gi">+    def name(self, name: ASTNestedName) -&gt; None:</span>
<span class="gi">+        self.declId = name</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def isPack(self) -&gt; bool:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def function_params(self) -&gt; list[ASTFunctionParameter]:</span>
<span class="gi">+        return self.paramQual.function_params</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def trailingReturn(self) -&gt; ASTType:</span>
<span class="gi">+        return self.paramQual.trailingReturn</span>

<span class="gd">-    def __init__(self, declId: ASTNestedName, size: ASTExpression) -&gt;None:</span>
<span class="gi">+    # only the modifiers for a function, e.g.,</span>
<span class="gi">+    def get_modifiers_id(self, version: int) -&gt; str:</span>
<span class="gi">+        # cv-qualifiers</span>
<span class="gi">+        if self.paramQual:</span>
<span class="gi">+            return self.paramQual.get_modifiers_id(version)</span>
<span class="gi">+        raise Exception(&quot;This should only be called on a function: %s&quot; % self)</span>
<span class="gi">+</span>
<span class="gi">+    def get_param_id(self, version: int) -&gt; str:  # only the parameters (if any)</span>
<span class="gi">+        if self.paramQual:</span>
<span class="gi">+            return self.paramQual.get_param_id(version)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def get_ptr_suffix_id(self, version: int) -&gt; str:  # only the array specifiers</span>
<span class="gi">+        return &#39;&#39;.join(a.get_id(version) for a in self.arrayOps)</span>
<span class="gi">+</span>
<span class="gi">+    def get_type_id(self, version: int, returnTypeId: str) -&gt; str:</span>
<span class="gi">+        assert version &gt;= 2</span>
<span class="gi">+        res = []</span>
<span class="gi">+        # TODO: can we actually have both array ops and paramQual?</span>
<span class="gi">+        res.append(self.get_ptr_suffix_id(version))</span>
<span class="gi">+        if self.paramQual:</span>
<span class="gi">+            res.append(self.get_modifiers_id(version))</span>
<span class="gi">+            res.append(&#39;F&#39;)</span>
<span class="gi">+            res.append(returnTypeId)</span>
<span class="gi">+            res.append(self.get_param_id(version))</span>
<span class="gi">+            res.append(&#39;E&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            res.append(returnTypeId)</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    # ------------------------------------------------------------------------</span>
<span class="gi">+</span>
<span class="gi">+    def require_space_after_declSpecs(self) -&gt; bool:</span>
<span class="gi">+        return self.declId is not None</span>
<span class="gi">+</span>
<span class="gi">+    def is_function_type(self) -&gt; bool:</span>
<span class="gi">+        return self.paramQual is not None</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        if self.declId:</span>
<span class="gi">+            res.append(transform(self.declId))</span>
<span class="gi">+        res.extend(transform(op) for op in self.arrayOps)</span>
<span class="gi">+        if self.paramQual:</span>
<span class="gi">+            res.append(transform(self.paramQual))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        if self.declId:</span>
<span class="gi">+            self.declId.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        for op in self.arrayOps:</span>
<span class="gi">+            op.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        if self.paramQual:</span>
<span class="gi">+            self.paramQual.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ASTDeclaratorNameBitField(ASTDeclarator):</span>
<span class="gi">+    def __init__(self, declId: ASTNestedName, size: ASTExpression) -&gt; None:</span>
<span class="w"> </span>        self.declId = declId
<span class="w"> </span>        self.size = size

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTDeclaratorNameBitField):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.declId == other.declId and self.size == other.size

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.declId, self.size))

<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        return self.declId</span>

<span class="gd">-class ASTDeclaratorPtr(ASTDeclarator):</span>
<span class="gi">+    @name.setter</span>
<span class="gi">+    def name(self, name: ASTNestedName) -&gt; None:</span>
<span class="gi">+        self.declId = name</span>
<span class="gi">+</span>
<span class="gi">+    def get_param_id(self, version: int) -&gt; str:  # only the parameters (if any)</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def get_ptr_suffix_id(self, version: int) -&gt; str:  # only the array specifiers</span>
<span class="gi">+        return &#39;&#39;</span>

<span class="gi">+    # ------------------------------------------------------------------------</span>
<span class="gi">+</span>
<span class="gi">+    def require_space_after_declSpecs(self) -&gt; bool:</span>
<span class="gi">+        return self.declId is not None</span>
<span class="gi">+</span>
<span class="gi">+    def is_function_type(self) -&gt; bool:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        if self.declId:</span>
<span class="gi">+            res.append(transform(self.declId))</span>
<span class="gi">+        res.append(&quot; : &quot;)</span>
<span class="gi">+        res.append(transform(self.size))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        if self.declId:</span>
<span class="gi">+            self.declId.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_space()</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;:&#39;, &#39;:&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_space()</span>
<span class="gi">+        self.size.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ASTDeclaratorPtr(ASTDeclarator):</span>
<span class="w"> </span>    def __init__(self, next: ASTDeclarator, volatile: bool, const: bool,
<span class="gd">-        attrs: ASTAttributeList) -&gt;None:</span>
<span class="gi">+                 attrs: ASTAttributeList) -&gt; None:</span>
<span class="w"> </span>        assert next
<span class="w"> </span>        self.next = next
<span class="w"> </span>        self.volatile = volatile
<span class="w"> </span>        self.const = const
<span class="w"> </span>        self.attrs = attrs

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTDeclaratorPtr):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.next == other.next and self.volatile == other.volatile and</span>
<span class="gd">-            self.const == other.const and self.attrs == other.attrs)</span>
<span class="gd">-</span>
<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.next == other.next</span>
<span class="gi">+            and self.volatile == other.volatile</span>
<span class="gi">+            and self.const == other.const</span>
<span class="gi">+            and self.attrs == other.attrs</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.next, self.volatile, self.const, self.attrs))

<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        return self.next.name</span>
<span class="gi">+</span>
<span class="gi">+    @name.setter</span>
<span class="gi">+    def name(self, name: ASTNestedName) -&gt; None:</span>
<span class="gi">+        self.next.name = name</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def isPack(self) -&gt; bool:</span>
<span class="gi">+        return self.next.isPack</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def function_params(self) -&gt; list[ASTFunctionParameter]:</span>
<span class="gi">+        return self.next.function_params</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def trailingReturn(self) -&gt; ASTType:</span>
<span class="gi">+        return self.next.trailingReturn</span>
<span class="gi">+</span>
<span class="gi">+    def require_space_after_declSpecs(self) -&gt; bool:</span>
<span class="gi">+        return self.next.require_space_after_declSpecs()</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = [&#39;*&#39;]</span>
<span class="gi">+        res.append(transform(self.attrs))</span>
<span class="gi">+        if len(self.attrs) != 0 and (self.volatile or self.const):</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+        if self.volatile:</span>
<span class="gi">+            res.append(&#39;volatile&#39;)</span>
<span class="gi">+        if self.const:</span>
<span class="gi">+            if self.volatile:</span>
<span class="gi">+                res.append(&#39; &#39;)</span>
<span class="gi">+            res.append(&#39;const&#39;)</span>
<span class="gi">+        if self.const or self.volatile or len(self.attrs) &gt; 0:</span>
<span class="gi">+            if self.next.require_space_after_declSpecs():</span>
<span class="gi">+                res.append(&#39; &#39;)</span>
<span class="gi">+        res.append(transform(self.next))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def get_modifiers_id(self, version: int) -&gt; str:</span>
<span class="gi">+        return self.next.get_modifiers_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def get_param_id(self, version: int) -&gt; str:</span>
<span class="gi">+        return self.next.get_param_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def get_ptr_suffix_id(self, version: int) -&gt; str:</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            res = [&#39;P&#39;]</span>
<span class="gi">+            if self.volatile:</span>
<span class="gi">+                res.append(&#39;V&#39;)</span>
<span class="gi">+            if self.const:</span>
<span class="gi">+                res.append(&#39;C&#39;)</span>
<span class="gi">+            res.append(self.next.get_ptr_suffix_id(version))</span>
<span class="gi">+            return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+        res = [self.next.get_ptr_suffix_id(version)]</span>
<span class="gi">+        res.append(&#39;P&#39;)</span>
<span class="gi">+        if self.volatile:</span>
<span class="gi">+            res.append(&#39;V&#39;)</span>
<span class="gi">+        if self.const:</span>
<span class="gi">+            res.append(&#39;C&#39;)</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def get_type_id(self, version: int, returnTypeId: str) -&gt; str:</span>
<span class="gi">+        # ReturnType *next, so we are part of the return type of &#39;next</span>
<span class="gi">+        res = [&#39;P&#39;]</span>
<span class="gi">+        if self.volatile:</span>
<span class="gi">+            res.append(&#39;V&#39;)</span>
<span class="gi">+        if self.const:</span>
<span class="gi">+            res.append(&#39;C&#39;)</span>
<span class="gi">+        res.append(returnTypeId)</span>
<span class="gi">+        return self.next.get_type_id(version, returnTypeId=&#39;&#39;.join(res))</span>
<span class="gi">+</span>
<span class="gi">+    def is_function_type(self) -&gt; bool:</span>
<span class="gi">+        return self.next.is_function_type()</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;*&#39;, &#39;*&#39;)</span>
<span class="gi">+        self.attrs.describe_signature(signode)</span>
<span class="gi">+        if len(self.attrs) != 0 and (self.volatile or self.const):</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+</span>
<span class="gi">+        def _add_anno(signode: TextElement, text: str) -&gt; None:</span>
<span class="gi">+            signode += addnodes.desc_sig_keyword(text, text)</span>
<span class="gi">+        if self.volatile:</span>
<span class="gi">+            _add_anno(signode, &#39;volatile&#39;)</span>
<span class="gi">+        if self.const:</span>
<span class="gi">+            if self.volatile:</span>
<span class="gi">+                signode += addnodes.desc_sig_space()</span>
<span class="gi">+            _add_anno(signode, &#39;const&#39;)</span>
<span class="gi">+        if self.const or self.volatile or len(self.attrs) &gt; 0:</span>
<span class="gi">+            if self.next.require_space_after_declSpecs():</span>
<span class="gi">+                signode += addnodes.desc_sig_space()</span>
<span class="gi">+        self.next.describe_signature(signode, mode, env, symbol)</span>

<span class="gd">-class ASTDeclaratorRef(ASTDeclarator):</span>

<span class="gd">-    def __init__(self, next: ASTDeclarator, attrs: ASTAttributeList) -&gt;None:</span>
<span class="gi">+class ASTDeclaratorRef(ASTDeclarator):</span>
<span class="gi">+    def __init__(self, next: ASTDeclarator, attrs: ASTAttributeList) -&gt; None:</span>
<span class="w"> </span>        assert next
<span class="w"> </span>        self.next = next
<span class="w"> </span>        self.attrs = attrs

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTDeclaratorRef):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.next == other.next and self.attrs == other.attrs

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.next, self.attrs))

<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        return self.next.name</span>

<span class="gd">-class ASTDeclaratorParamPack(ASTDeclarator):</span>
<span class="gi">+    @name.setter</span>
<span class="gi">+    def name(self, name: ASTNestedName) -&gt; None:</span>
<span class="gi">+        self.next.name = name</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def isPack(self) -&gt; bool:</span>
<span class="gi">+        return self.next.isPack</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def function_params(self) -&gt; list[ASTFunctionParameter]:</span>
<span class="gi">+        return self.next.function_params</span>

<span class="gd">-    def __init__(self, next: ASTDeclarator) -&gt;None:</span>
<span class="gi">+    @property</span>
<span class="gi">+    def trailingReturn(self) -&gt; ASTType:</span>
<span class="gi">+        return self.next.trailingReturn</span>
<span class="gi">+</span>
<span class="gi">+    def require_space_after_declSpecs(self) -&gt; bool:</span>
<span class="gi">+        return self.next.require_space_after_declSpecs()</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = [&#39;&amp;&#39;]</span>
<span class="gi">+        res.append(transform(self.attrs))</span>
<span class="gi">+        if len(self.attrs) != 0 and self.next.require_space_after_declSpecs():</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+        res.append(transform(self.next))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def get_modifiers_id(self, version: int) -&gt; str:</span>
<span class="gi">+        return self.next.get_modifiers_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def get_param_id(self, version: int) -&gt; str:  # only the parameters (if any)</span>
<span class="gi">+        return self.next.get_param_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def get_ptr_suffix_id(self, version: int) -&gt; str:</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            return &#39;R&#39; + self.next.get_ptr_suffix_id(version)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.next.get_ptr_suffix_id(version) + &#39;R&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def get_type_id(self, version: int, returnTypeId: str) -&gt; str:</span>
<span class="gi">+        assert version &gt;= 2</span>
<span class="gi">+        # ReturnType &amp;next, so we are part of the return type of &#39;next</span>
<span class="gi">+        return self.next.get_type_id(version, returnTypeId=&#39;R&#39; + returnTypeId)</span>
<span class="gi">+</span>
<span class="gi">+    def is_function_type(self) -&gt; bool:</span>
<span class="gi">+        return self.next.is_function_type()</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;&amp;&#39;, &#39;&amp;&#39;)</span>
<span class="gi">+        self.attrs.describe_signature(signode)</span>
<span class="gi">+        if len(self.attrs) &gt; 0 and self.next.require_space_after_declSpecs():</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+        self.next.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ASTDeclaratorParamPack(ASTDeclarator):</span>
<span class="gi">+    def __init__(self, next: ASTDeclarator) -&gt; None:</span>
<span class="w"> </span>        assert next
<span class="w"> </span>        self.next = next

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTDeclaratorParamPack):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.next == other.next

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.next)

<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        return self.next.name</span>

<span class="gd">-class ASTDeclaratorMemPtr(ASTDeclarator):</span>
<span class="gi">+    @name.setter</span>
<span class="gi">+    def name(self, name: ASTNestedName) -&gt; None:</span>
<span class="gi">+        self.next.name = name</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def function_params(self) -&gt; list[ASTFunctionParameter]:</span>
<span class="gi">+        return self.next.function_params</span>

<span class="gd">-    def __init__(self, className: ASTNestedName, const: bool, volatile:</span>
<span class="gd">-        bool, next: ASTDeclarator) -&gt;None:</span>
<span class="gi">+    @property</span>
<span class="gi">+    def trailingReturn(self) -&gt; ASTType:</span>
<span class="gi">+        return self.next.trailingReturn</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def isPack(self) -&gt; bool:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def require_space_after_declSpecs(self) -&gt; bool:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = transform(self.next)</span>
<span class="gi">+        if self.next.name:</span>
<span class="gi">+            res = &#39; &#39; + res</span>
<span class="gi">+        return &#39;...&#39; + res</span>
<span class="gi">+</span>
<span class="gi">+    def get_modifiers_id(self, version: int) -&gt; str:</span>
<span class="gi">+        return self.next.get_modifiers_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def get_param_id(self, version: int) -&gt; str:  # only the parameters (if any)</span>
<span class="gi">+        return self.next.get_param_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def get_ptr_suffix_id(self, version: int) -&gt; str:</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            return &#39;Dp&#39; + self.next.get_ptr_suffix_id(version)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.next.get_ptr_suffix_id(version) + &#39;Dp&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def get_type_id(self, version: int, returnTypeId: str) -&gt; str:</span>
<span class="gi">+        assert version &gt;= 2</span>
<span class="gi">+        # ReturnType... next, so we are part of the return type of &#39;next</span>
<span class="gi">+        return self.next.get_type_id(version, returnTypeId=&#39;Dp&#39; + returnTypeId)</span>
<span class="gi">+</span>
<span class="gi">+    def is_function_type(self) -&gt; bool:</span>
<span class="gi">+        return self.next.is_function_type()</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;...&#39;, &#39;...&#39;)</span>
<span class="gi">+        if self.next.name:</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+        self.next.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ASTDeclaratorMemPtr(ASTDeclarator):</span>
<span class="gi">+    def __init__(self, className: ASTNestedName,</span>
<span class="gi">+                 const: bool, volatile: bool, next: ASTDeclarator) -&gt; None:</span>
<span class="w"> </span>        assert className
<span class="w"> </span>        assert next
<span class="w"> </span>        self.className = className
<span class="gu">@@ -993,258 +2872,851 @@ class ASTDeclaratorMemPtr(ASTDeclarator):</span>
<span class="w"> </span>        self.volatile = volatile
<span class="w"> </span>        self.next = next

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTDeclaratorMemPtr):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.className == other.className and self.const == other.</span>
<span class="gd">-            const and self.volatile == other.volatile and self.next ==</span>
<span class="gd">-            other.next)</span>
<span class="gd">-</span>
<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.className == other.className</span>
<span class="gi">+            and self.const == other.const</span>
<span class="gi">+            and self.volatile == other.volatile</span>
<span class="gi">+            and self.next == other.next</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.className, self.const, self.volatile, self.next))

<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        return self.next.name</span>
<span class="gi">+</span>
<span class="gi">+    @name.setter</span>
<span class="gi">+    def name(self, name: ASTNestedName) -&gt; None:</span>
<span class="gi">+        self.next.name = name</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def isPack(self) -&gt; bool:</span>
<span class="gi">+        return self.next.isPack</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def function_params(self) -&gt; list[ASTFunctionParameter]:</span>
<span class="gi">+        return self.next.function_params</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def trailingReturn(self) -&gt; ASTType:</span>
<span class="gi">+        return self.next.trailingReturn</span>
<span class="gi">+</span>
<span class="gi">+    def require_space_after_declSpecs(self) -&gt; bool:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        res.append(transform(self.className))</span>
<span class="gi">+        res.append(&#39;::*&#39;)</span>
<span class="gi">+        if self.volatile:</span>
<span class="gi">+            res.append(&#39;volatile&#39;)</span>
<span class="gi">+        if self.const:</span>
<span class="gi">+            if self.volatile:</span>
<span class="gi">+                res.append(&#39; &#39;)</span>
<span class="gi">+            res.append(&#39;const&#39;)</span>
<span class="gi">+        if self.next.require_space_after_declSpecs():</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+        res.append(transform(self.next))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def get_modifiers_id(self, version: int) -&gt; str:</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            raise NoOldIdError</span>
<span class="gi">+        return self.next.get_modifiers_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def get_param_id(self, version: int) -&gt; str:  # only the parameters (if any)</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            raise NoOldIdError</span>
<span class="gi">+        return self.next.get_param_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def get_ptr_suffix_id(self, version: int) -&gt; str:</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            raise NoOldIdError</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+        return self.next.get_ptr_suffix_id(version) + &#39;Dp&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def get_type_id(self, version: int, returnTypeId: str) -&gt; str:</span>
<span class="gi">+        assert version &gt;= 2</span>
<span class="gi">+        # ReturnType name::* next, so we are part of the return type of next</span>
<span class="gi">+        nextReturnTypeId = &#39;&#39;</span>
<span class="gi">+        if self.volatile:</span>
<span class="gi">+            nextReturnTypeId += &#39;V&#39;</span>
<span class="gi">+        if self.const:</span>
<span class="gi">+            nextReturnTypeId += &#39;K&#39;</span>
<span class="gi">+        nextReturnTypeId += &#39;M&#39;</span>
<span class="gi">+        nextReturnTypeId += self.className.get_id(version)</span>
<span class="gi">+        nextReturnTypeId += returnTypeId</span>
<span class="gi">+        return self.next.get_type_id(version, nextReturnTypeId)</span>
<span class="gi">+</span>
<span class="gi">+    def is_function_type(self) -&gt; bool:</span>
<span class="gi">+        return self.next.is_function_type()</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        self.className.describe_signature(signode, &#39;markType&#39;, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;::&#39;, &#39;::&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;*&#39;, &#39;*&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        def _add_anno(signode: TextElement, text: str) -&gt; None:</span>
<span class="gi">+            signode += addnodes.desc_sig_keyword(text, text)</span>
<span class="gi">+        if self.volatile:</span>
<span class="gi">+            _add_anno(signode, &#39;volatile&#39;)</span>
<span class="gi">+        if self.const:</span>
<span class="gi">+            if self.volatile:</span>
<span class="gi">+                signode += addnodes.desc_sig_space()</span>
<span class="gi">+            _add_anno(signode, &#39;const&#39;)</span>
<span class="gi">+        if self.next.require_space_after_declSpecs():</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+        self.next.describe_signature(signode, mode, env, symbol)</span>

<span class="gd">-class ASTDeclaratorParen(ASTDeclarator):</span>

<span class="gd">-    def __init__(self, inner: ASTDeclarator, next: ASTDeclarator) -&gt;None:</span>
<span class="gi">+class ASTDeclaratorParen(ASTDeclarator):</span>
<span class="gi">+    def __init__(self, inner: ASTDeclarator, next: ASTDeclarator) -&gt; None:</span>
<span class="w"> </span>        assert inner
<span class="w"> </span>        assert next
<span class="w"> </span>        self.inner = inner
<span class="w"> </span>        self.next = next
<span class="gi">+        # TODO: we assume the name, params, and qualifiers are in inner</span>

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTDeclaratorParen):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.inner == other.inner and self.next == other.next

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.inner, self.next))

<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        return self.inner.name</span>

<span class="gd">-class ASTPackExpansionExpr(ASTExpression):</span>
<span class="gi">+    @name.setter</span>
<span class="gi">+    def name(self, name: ASTNestedName) -&gt; None:</span>
<span class="gi">+        self.inner.name = name</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def isPack(self) -&gt; bool:</span>
<span class="gi">+        return self.inner.isPack or self.next.isPack</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def function_params(self) -&gt; list[ASTFunctionParameter]:</span>
<span class="gi">+        return self.inner.function_params</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def trailingReturn(self) -&gt; ASTType:</span>
<span class="gi">+        return self.inner.trailingReturn</span>
<span class="gi">+</span>
<span class="gi">+    def require_space_after_declSpecs(self) -&gt; bool:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = [&#39;(&#39;]</span>
<span class="gi">+        res.append(transform(self.inner))</span>
<span class="gi">+        res.append(&#39;)&#39;)</span>
<span class="gi">+        res.append(transform(self.next))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def get_modifiers_id(self, version: int) -&gt; str:</span>
<span class="gi">+        return self.inner.get_modifiers_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def get_param_id(self, version: int) -&gt; str:  # only the parameters (if any)</span>
<span class="gi">+        return self.inner.get_param_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def get_ptr_suffix_id(self, version: int) -&gt; str:</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            raise NoOldIdError  # TODO: was this implemented before?</span>
<span class="gi">+            return self.next.get_ptr_suffix_id(version) + \</span>
<span class="gi">+                self.inner.get_ptr_suffix_id(version)</span>
<span class="gi">+        return self.inner.get_ptr_suffix_id(version) + \</span>
<span class="gi">+            self.next.get_ptr_suffix_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def get_type_id(self, version: int, returnTypeId: str) -&gt; str:</span>
<span class="gi">+        assert version &gt;= 2</span>
<span class="gi">+        # ReturnType (inner)next, so &#39;inner&#39; returns everything outside</span>
<span class="gi">+        nextId = self.next.get_type_id(version, returnTypeId)</span>
<span class="gi">+        return self.inner.get_type_id(version, returnTypeId=nextId)</span>
<span class="gi">+</span>
<span class="gi">+    def is_function_type(self) -&gt; bool:</span>
<span class="gi">+        return self.inner.is_function_type()</span>

<span class="gd">-    def __init__(self, expr: (ASTExpression | ASTBracedInitList)) -&gt;None:</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;(&#39;, &#39;(&#39;)</span>
<span class="gi">+        self.inner.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;)&#39;, &#39;)&#39;)</span>
<span class="gi">+        self.next.describe_signature(signode, &quot;noneIsName&quot;, env, symbol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Type and initializer stuff</span>
<span class="gi">+##############################################################################################</span>
<span class="gi">+</span>
<span class="gi">+class ASTPackExpansionExpr(ASTExpression):</span>
<span class="gi">+    def __init__(self, expr: ASTExpression | ASTBracedInitList) -&gt; None:</span>
<span class="w"> </span>        self.expr = expr

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTPackExpansionExpr):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.expr == other.expr

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.expr)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return transform(self.expr) + &#39;...&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        id = self.expr.get_id(version)</span>
<span class="gi">+        return &#39;sp&#39; + id</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        self.expr.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;...&#39;, &#39;...&#39;)</span>

<span class="gd">-class ASTParenExprList(ASTBaseParenExprList):</span>

<span class="gd">-    def __init__(self, exprs: list[ASTExpression | ASTBracedInitList]) -&gt;None:</span>
<span class="gi">+class ASTParenExprList(ASTBaseParenExprList):</span>
<span class="gi">+    def __init__(self, exprs: list[ASTExpression | ASTBracedInitList]) -&gt; None:</span>
<span class="w"> </span>        self.exprs = exprs

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTParenExprList):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.exprs == other.exprs

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.exprs)

<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        return &quot;pi%sE&quot; % &#39;&#39;.join(e.get_id(version) for e in self.exprs)</span>

<span class="gd">-class ASTInitializer(ASTBase):</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        exprs = [transform(e) for e in self.exprs]</span>
<span class="gi">+        return &#39;(%s)&#39; % &#39;, &#39;.join(exprs)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;(&#39;, &#39;(&#39;)</span>
<span class="gi">+        first = True</span>
<span class="gi">+        for e in self.exprs:</span>
<span class="gi">+            if not first:</span>
<span class="gi">+                signode += addnodes.desc_sig_punctuation(&#39;,&#39;, &#39;,&#39;)</span>
<span class="gi">+                signode += addnodes.desc_sig_space()</span>
<span class="gi">+            else:</span>
<span class="gi">+                first = False</span>
<span class="gi">+            e.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;)&#39;, &#39;)&#39;)</span>

<span class="gd">-    def __init__(self, value: (ASTExpression | ASTBracedInitList),</span>
<span class="gd">-        hasAssign: bool=True) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class ASTInitializer(ASTBase):</span>
<span class="gi">+    def __init__(self, value: ASTExpression | ASTBracedInitList,</span>
<span class="gi">+                 hasAssign: bool = True) -&gt; None:</span>
<span class="w"> </span>        self.value = value
<span class="w"> </span>        self.hasAssign = hasAssign

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTInitializer):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.value == other.value and self.hasAssign == other.hasAssign

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.value, self.hasAssign))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        val = transform(self.value)</span>
<span class="gi">+        if self.hasAssign:</span>
<span class="gi">+            return &#39; = &#39; + val</span>
<span class="gi">+        else:</span>
<span class="gi">+            return val</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        if self.hasAssign:</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;=&#39;, &#39;=&#39;)</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+        self.value.describe_signature(signode, &#39;markType&#39;, env, symbol)</span>

<span class="gd">-class ASTType(ASTBase):</span>

<span class="gd">-    def __init__(self, declSpecs: ASTDeclSpecs, decl: ASTDeclarator) -&gt;None:</span>
<span class="gi">+class ASTType(ASTBase):</span>
<span class="gi">+    def __init__(self, declSpecs: ASTDeclSpecs, decl: ASTDeclarator) -&gt; None:</span>
<span class="w"> </span>        assert declSpecs
<span class="w"> </span>        assert decl
<span class="w"> </span>        self.declSpecs = declSpecs
<span class="w"> </span>        self.decl = decl

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTType):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.declSpecs == other.declSpecs and self.decl == other.decl

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.declSpecs, self.decl))

<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        return self.decl.name</span>
<span class="gi">+</span>
<span class="gi">+    @name.setter</span>
<span class="gi">+    def name(self, name: ASTNestedName) -&gt; None:</span>
<span class="gi">+        self.decl.name = name</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def isPack(self) -&gt; bool:</span>
<span class="gi">+        return self.decl.isPack</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def function_params(self) -&gt; list[ASTFunctionParameter]:</span>
<span class="gi">+        return self.decl.function_params</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def trailingReturn(self) -&gt; ASTType:</span>
<span class="gi">+        return self.decl.trailingReturn</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int, objectType: str | None = None,</span>
<span class="gi">+               symbol: Symbol | None = None) -&gt; str:</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            res = []</span>
<span class="gi">+            if objectType:  # needs the name</span>
<span class="gi">+                if objectType == &#39;function&#39;:  # also modifiers</span>
<span class="gi">+                    res.append(symbol.get_full_nested_name().get_id(version))</span>
<span class="gi">+                    res.append(self.decl.get_param_id(version))</span>
<span class="gi">+                    res.append(self.decl.get_modifiers_id(version))</span>
<span class="gi">+                    if (self.declSpecs.leftSpecs.constexpr or</span>
<span class="gi">+                            (self.declSpecs.rightSpecs and</span>
<span class="gi">+                             self.declSpecs.rightSpecs.constexpr)):</span>
<span class="gi">+                        res.append(&#39;CE&#39;)</span>
<span class="gi">+                elif objectType == &#39;type&#39;:  # just the name</span>
<span class="gi">+                    res.append(symbol.get_full_nested_name().get_id(version))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise AssertionError(objectType)</span>
<span class="gi">+            else:  # only type encoding</span>
<span class="gi">+                if self.decl.is_function_type():</span>
<span class="gi">+                    raise NoOldIdError</span>
<span class="gi">+                res.append(self.declSpecs.get_id(version))</span>
<span class="gi">+                res.append(self.decl.get_ptr_suffix_id(version))</span>
<span class="gi">+                res.append(self.decl.get_param_id(version))</span>
<span class="gi">+            return &#39;&#39;.join(res)</span>
<span class="gi">+        # other versions</span>
<span class="gi">+        res = []</span>
<span class="gi">+        if objectType:  # needs the name</span>
<span class="gi">+            if objectType == &#39;function&#39;:  # also modifiers</span>
<span class="gi">+                modifiers = self.decl.get_modifiers_id(version)</span>
<span class="gi">+                res.append(symbol.get_full_nested_name().get_id(version, modifiers))</span>
<span class="gi">+                if version &gt;= 4:</span>
<span class="gi">+                    # with templates we need to mangle the return type in as well</span>
<span class="gi">+                    templ = symbol.declaration.templatePrefix</span>
<span class="gi">+                    if templ is not None:</span>
<span class="gi">+                        typeId = self.decl.get_ptr_suffix_id(version)</span>
<span class="gi">+                        if self.trailingReturn:</span>
<span class="gi">+                            returnTypeId = self.trailingReturn.get_id(version)</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            returnTypeId = self.declSpecs.get_id(version)</span>
<span class="gi">+                        res.append(typeId)</span>
<span class="gi">+                        res.append(returnTypeId)</span>
<span class="gi">+                res.append(self.decl.get_param_id(version))</span>
<span class="gi">+            elif objectType == &#39;type&#39;:  # just the name</span>
<span class="gi">+                res.append(symbol.get_full_nested_name().get_id(version))</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise AssertionError(objectType)</span>
<span class="gi">+        else:  # only type encoding</span>
<span class="gi">+            # the &#39;returnType&#39; of a non-function type is simply just the last</span>
<span class="gi">+            # type, i.e., for &#39;int*&#39; it is &#39;int&#39;</span>
<span class="gi">+            returnTypeId = self.declSpecs.get_id(version)</span>
<span class="gi">+            typeId = self.decl.get_type_id(version, returnTypeId)</span>
<span class="gi">+            res.append(typeId)</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        declSpecs = transform(self.declSpecs)</span>
<span class="gi">+        res.append(declSpecs)</span>
<span class="gi">+        if self.decl.require_space_after_declSpecs() and len(declSpecs) &gt; 0:</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+        res.append(transform(self.decl))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def get_type_declaration_prefix(self) -&gt; str:</span>
<span class="gi">+        if self.declSpecs.trailingTypeSpec:</span>
<span class="gi">+            return &#39;typedef&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;type&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        self.declSpecs.describe_signature(signode, &#39;markType&#39;, env, symbol)</span>
<span class="gi">+        if (self.decl.require_space_after_declSpecs() and</span>
<span class="gi">+                len(str(self.declSpecs)) &gt; 0):</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+        # for parameters that don&#39;t really declare new names we get &#39;markType&#39;,</span>
<span class="gi">+        # this should not be propagated, but be &#39;noneIsName&#39;.</span>
<span class="gi">+        if mode == &#39;markType&#39;:</span>
<span class="gi">+            mode = &#39;noneIsName&#39;</span>
<span class="gi">+        self.decl.describe_signature(signode, mode, env, symbol)</span>

<span class="gd">-class ASTTemplateParamConstrainedTypeWithInit(ASTBase):</span>

<span class="gd">-    def __init__(self, type: ASTType, init: ASTType) -&gt;None:</span>
<span class="gi">+class ASTTemplateParamConstrainedTypeWithInit(ASTBase):</span>
<span class="gi">+    def __init__(self, type: ASTType, init: ASTType) -&gt; None:</span>
<span class="w"> </span>        assert type
<span class="w"> </span>        self.type = type
<span class="w"> </span>        self.init = init

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTTemplateParamConstrainedTypeWithInit):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.type == other.type and self.init == other.init

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.type, self.init))

<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        return self.type.name</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def isPack(self) -&gt; bool:</span>
<span class="gi">+        return self.type.isPack</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(</span>
<span class="gi">+        self, version: int, objectType: str | None = None, symbol: Symbol | None = None,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        # this is not part of the normal name mangling in C++</span>
<span class="gi">+        assert version &gt;= 2</span>
<span class="gi">+        if symbol:</span>
<span class="gi">+            # the anchor will be our parent</span>
<span class="gi">+            return symbol.parent.declaration.get_id(version, prefixed=False)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.type.get_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = transform(self.type)</span>
<span class="gi">+        if self.init:</span>
<span class="gi">+            res += &quot; = &quot;</span>
<span class="gi">+            res += transform(self.init)</span>
<span class="gi">+        return res</span>

<span class="gd">-class ASTTypeWithInit(ASTBase):</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        self.type.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        if self.init:</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;=&#39;, &#39;=&#39;)</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            self.init.describe_signature(signode, mode, env, symbol)</span>

<span class="gd">-    def __init__(self, type: ASTType, init: ASTInitializer) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class ASTTypeWithInit(ASTBase):</span>
<span class="gi">+    def __init__(self, type: ASTType, init: ASTInitializer) -&gt; None:</span>
<span class="w"> </span>        self.type = type
<span class="w"> </span>        self.init = init

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTTypeWithInit):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.type == other.type and self.init == other.init

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.type, self.init))

<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        return self.type.name</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def isPack(self) -&gt; bool:</span>
<span class="gi">+        return self.type.isPack</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int, objectType: str | None = None,</span>
<span class="gi">+               symbol: Symbol | None = None) -&gt; str:</span>
<span class="gi">+        if objectType != &#39;member&#39;:</span>
<span class="gi">+            return self.type.get_id(version, objectType)</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            return (symbol.get_full_nested_name().get_id(version) + &#39;__&#39; +</span>
<span class="gi">+                    self.type.get_id(version))</span>
<span class="gi">+        return symbol.get_full_nested_name().get_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        res.append(transform(self.type))</span>
<span class="gi">+        if self.init:</span>
<span class="gi">+            res.append(transform(self.init))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        self.type.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        if self.init:</span>
<span class="gi">+            self.init.describe_signature(signode, mode, env, symbol)</span>

<span class="gd">-class ASTTypeUsing(ASTBase):</span>

<span class="gd">-    def __init__(self, name: ASTNestedName, type: (ASTType | None)) -&gt;None:</span>
<span class="gi">+class ASTTypeUsing(ASTBase):</span>
<span class="gi">+    def __init__(self, name: ASTNestedName, type: ASTType | None) -&gt; None:</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.type = type

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTTypeUsing):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.name == other.name and self.type == other.type

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.name, self.type))

<span class="gi">+    def get_id(self, version: int, objectType: str | None = None,</span>
<span class="gi">+               symbol: Symbol | None = None) -&gt; str:</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            raise NoOldIdError</span>
<span class="gi">+        return symbol.get_full_nested_name().get_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        res.append(transform(self.name))</span>
<span class="gi">+        if self.type:</span>
<span class="gi">+            res.append(&#39; = &#39;)</span>
<span class="gi">+            res.append(transform(self.type))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def get_type_declaration_prefix(self) -&gt; str:</span>
<span class="gi">+        return &#39;using&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        self.name.describe_signature(signode, mode, env, symbol=symbol)</span>
<span class="gi">+        if self.type:</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;=&#39;, &#39;=&#39;)</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            self.type.describe_signature(signode, &#39;markType&#39;, env, symbol=symbol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Other declarations</span>
<span class="gi">+##############################################################################################</span>

<span class="w"> </span>class ASTConcept(ASTBase):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, nestedName: ASTNestedName, initializer: ASTInitializer</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, nestedName: ASTNestedName, initializer: ASTInitializer) -&gt; None:</span>
<span class="w"> </span>        self.nestedName = nestedName
<span class="w"> </span>        self.initializer = initializer

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTConcept):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.nestedName == other.nestedName and self.initializer ==</span>
<span class="gd">-            other.initializer)</span>
<span class="gi">+        return self.nestedName == other.nestedName and self.initializer == other.initializer</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.nestedName, self.initializer))

<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        return self.nestedName</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int, objectType: str | None = None,</span>
<span class="gi">+               symbol: Symbol | None = None) -&gt; str:</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            raise NoOldIdError</span>
<span class="gi">+        return symbol.get_full_nested_name().get_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = transform(self.nestedName)</span>
<span class="gi">+        if self.initializer:</span>
<span class="gi">+            res += transform(self.initializer)</span>
<span class="gi">+        return res</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        self.nestedName.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        if self.initializer:</span>
<span class="gi">+            self.initializer.describe_signature(signode, mode, env, symbol)</span>

<span class="gd">-class ASTBaseClass(ASTBase):</span>

<span class="gd">-    def __init__(self, name: ASTNestedName, visibility: str, virtual: bool,</span>
<span class="gd">-        pack: bool) -&gt;None:</span>
<span class="gi">+class ASTBaseClass(ASTBase):</span>
<span class="gi">+    def __init__(self, name: ASTNestedName, visibility: str,</span>
<span class="gi">+                 virtual: bool, pack: bool) -&gt; None:</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.visibility = visibility
<span class="w"> </span>        self.virtual = virtual
<span class="w"> </span>        self.pack = pack

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTBaseClass):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.name == other.name and self.visibility == other.</span>
<span class="gd">-            visibility and self.virtual == other.virtual and self.pack ==</span>
<span class="gd">-            other.pack)</span>
<span class="gd">-</span>
<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.name == other.name</span>
<span class="gi">+            and self.visibility == other.visibility</span>
<span class="gi">+            and self.virtual == other.virtual</span>
<span class="gi">+            and self.pack == other.pack</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.name, self.visibility, self.virtual, self.pack))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        if self.visibility is not None:</span>
<span class="gi">+            res.append(self.visibility)</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+        if self.virtual:</span>
<span class="gi">+            res.append(&#39;virtual &#39;)</span>
<span class="gi">+        res.append(transform(self.name))</span>
<span class="gi">+        if self.pack:</span>
<span class="gi">+            res.append(&#39;...&#39;)</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        if self.visibility is not None:</span>
<span class="gi">+            signode += addnodes.desc_sig_keyword(self.visibility,</span>
<span class="gi">+                                                 self.visibility)</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+        if self.virtual:</span>
<span class="gi">+            signode += addnodes.desc_sig_keyword(&#39;virtual&#39;, &#39;virtual&#39;)</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+        self.name.describe_signature(signode, &#39;markType&#39;, env, symbol=symbol)</span>
<span class="gi">+        if self.pack:</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;...&#39;, &#39;...&#39;)</span>

<span class="gd">-class ASTClass(ASTBase):</span>

<span class="gd">-    def __init__(self, name: ASTNestedName, final: bool, bases: list[</span>
<span class="gd">-        ASTBaseClass], attrs: ASTAttributeList) -&gt;None:</span>
<span class="gi">+class ASTClass(ASTBase):</span>
<span class="gi">+    def __init__(self, name: ASTNestedName, final: bool, bases: list[ASTBaseClass],</span>
<span class="gi">+                 attrs: ASTAttributeList) -&gt; None:</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.final = final
<span class="w"> </span>        self.bases = bases
<span class="w"> </span>        self.attrs = attrs

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTClass):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.name == other.name and self.final == other.final and </span>
<span class="gd">-            self.bases == other.bases and self.attrs == other.attrs)</span>
<span class="gd">-</span>
<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.name == other.name</span>
<span class="gi">+            and self.final == other.final</span>
<span class="gi">+            and self.bases == other.bases</span>
<span class="gi">+            and self.attrs == other.attrs</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.name, self.final, self.bases, self.attrs))

<span class="gi">+    def get_id(self, version: int, objectType: str, symbol: Symbol) -&gt; str:</span>
<span class="gi">+        return symbol.get_full_nested_name().get_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        res.append(transform(self.attrs))</span>
<span class="gi">+        if len(self.attrs) != 0:</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+        res.append(transform(self.name))</span>
<span class="gi">+        if self.final:</span>
<span class="gi">+            res.append(&#39; final&#39;)</span>
<span class="gi">+        if len(self.bases) &gt; 0:</span>
<span class="gi">+            res.append(&#39; : &#39;)</span>
<span class="gi">+            first = True</span>
<span class="gi">+            for b in self.bases:</span>
<span class="gi">+                if not first:</span>
<span class="gi">+                    res.append(&#39;, &#39;)</span>
<span class="gi">+                first = False</span>
<span class="gi">+                res.append(transform(b))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        self.attrs.describe_signature(signode)</span>
<span class="gi">+        if len(self.attrs) != 0:</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+        self.name.describe_signature(signode, mode, env, symbol=symbol)</span>
<span class="gi">+        if self.final:</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            signode += addnodes.desc_sig_keyword(&#39;final&#39;, &#39;final&#39;)</span>
<span class="gi">+        if len(self.bases) &gt; 0:</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;:&#39;, &#39;:&#39;)</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            for b in self.bases:</span>
<span class="gi">+                b.describe_signature(signode, mode, env, symbol=symbol)</span>
<span class="gi">+                signode += addnodes.desc_sig_punctuation(&#39;,&#39;, &#39;,&#39;)</span>
<span class="gi">+                signode += addnodes.desc_sig_space()</span>
<span class="gi">+            signode.pop()</span>
<span class="gi">+            signode.pop()</span>

<span class="gd">-class ASTUnion(ASTBase):</span>

<span class="gd">-    def __init__(self, name: ASTNestedName, attrs: ASTAttributeList) -&gt;None:</span>
<span class="gi">+class ASTUnion(ASTBase):</span>
<span class="gi">+    def __init__(self, name: ASTNestedName, attrs: ASTAttributeList) -&gt; None:</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.attrs = attrs

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTUnion):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.name == other.name and self.attrs == other.attrs

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.name, self.attrs))

<span class="gi">+    def get_id(self, version: int, objectType: str, symbol: Symbol) -&gt; str:</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            raise NoOldIdError</span>
<span class="gi">+        return symbol.get_full_nested_name().get_id(version)</span>

<span class="gd">-class ASTEnum(ASTBase):</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        res.append(transform(self.attrs))</span>
<span class="gi">+        if len(self.attrs) != 0:</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+        res.append(transform(self.name))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        self.attrs.describe_signature(signode)</span>
<span class="gi">+        if len(self.attrs) != 0:</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+        self.name.describe_signature(signode, mode, env, symbol=symbol)</span>

<span class="gd">-    def __init__(self, name: ASTNestedName, scoped: str, underlyingType:</span>
<span class="gd">-        ASTType, attrs: ASTAttributeList) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class ASTEnum(ASTBase):</span>
<span class="gi">+    def __init__(self, name: ASTNestedName, scoped: str, underlyingType: ASTType,</span>
<span class="gi">+                 attrs: ASTAttributeList) -&gt; None:</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.scoped = scoped
<span class="w"> </span>        self.underlyingType = underlyingType
<span class="w"> </span>        self.attrs = attrs

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTEnum):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.name == other.name and self.scoped == other.scoped and</span>
<span class="gd">-            self.underlyingType == other.underlyingType and self.attrs ==</span>
<span class="gd">-            other.attrs)</span>
<span class="gd">-</span>
<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.name == other.name</span>
<span class="gi">+            and self.scoped == other.scoped</span>
<span class="gi">+            and self.underlyingType == other.underlyingType</span>
<span class="gi">+            and self.attrs == other.attrs</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.name, self.scoped, self.underlyingType, self.attrs))

<span class="gi">+    def get_id(self, version: int, objectType: str, symbol: Symbol) -&gt; str:</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            raise NoOldIdError</span>
<span class="gi">+        return symbol.get_full_nested_name().get_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        if self.scoped:</span>
<span class="gi">+            res.append(self.scoped)</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+        res.append(transform(self.attrs))</span>
<span class="gi">+        if len(self.attrs) != 0:</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+        res.append(transform(self.name))</span>
<span class="gi">+        if self.underlyingType:</span>
<span class="gi">+            res.append(&#39; : &#39;)</span>
<span class="gi">+            res.append(transform(self.underlyingType))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        # self.scoped has been done by the CPPEnumObject</span>
<span class="gi">+        self.attrs.describe_signature(signode)</span>
<span class="gi">+        if len(self.attrs) != 0:</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+        self.name.describe_signature(signode, mode, env, symbol=symbol)</span>
<span class="gi">+        if self.underlyingType:</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;:&#39;, &#39;:&#39;)</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            self.underlyingType.describe_signature(signode, &#39;noneIsName&#39;,</span>
<span class="gi">+                                                   env, symbol=symbol)</span>

<span class="gd">-class ASTEnumerator(ASTBase):</span>

<span class="gd">-    def __init__(self, name: ASTNestedName, init: (ASTInitializer | None),</span>
<span class="gd">-        attrs: ASTAttributeList) -&gt;None:</span>
<span class="gi">+class ASTEnumerator(ASTBase):</span>
<span class="gi">+    def __init__(self, name: ASTNestedName, init: ASTInitializer | None,</span>
<span class="gi">+                 attrs: ASTAttributeList) -&gt; None:</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.init = init
<span class="w"> </span>        self.attrs = attrs

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTEnumerator):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.name == other.name and self.init == other.init and </span>
<span class="gd">-            self.attrs == other.attrs)</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.name == other.name</span>
<span class="gi">+            and self.init == other.init</span>
<span class="gi">+            and self.attrs == other.attrs</span>
<span class="gi">+        )</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.name, self.init, self.attrs))

<span class="gi">+    def get_id(self, version: int, objectType: str, symbol: Symbol) -&gt; str:</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            raise NoOldIdError</span>
<span class="gi">+        return symbol.get_full_nested_name().get_id(version)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        res.append(transform(self.name))</span>
<span class="gi">+        if len(self.attrs) != 0:</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+            res.append(transform(self.attrs))</span>
<span class="gi">+        if self.init:</span>
<span class="gi">+            res.append(transform(self.init))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        self.name.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        if len(self.attrs) != 0:</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            self.attrs.describe_signature(signode)</span>
<span class="gi">+        if self.init:</span>
<span class="gi">+            self.init.describe_signature(signode, &#39;markType&#39;, env, symbol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+################################################################################</span>
<span class="gi">+# Templates</span>
<span class="gi">+################################################################################</span>
<span class="gi">+</span>
<span class="gi">+# Parameters</span>
<span class="gi">+################################################################################</span>

<span class="w"> </span>class ASTTemplateParam(ASTBase):
<span class="gd">-    pass</span>
<span class="gi">+    def get_identifier(self) -&gt; ASTIdentifier:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>

<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>

<span class="gd">-class ASTTemplateKeyParamPackIdDefault(ASTTemplateParam):</span>
<span class="gi">+    def describe_signature(self, parentNode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def isPack(self) -&gt; bool:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>

<span class="gd">-    def __init__(self, key: str, identifier: ASTIdentifier, parameterPack:</span>
<span class="gd">-        bool, default: ASTType) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class ASTTemplateKeyParamPackIdDefault(ASTTemplateParam):</span>
<span class="gi">+    def __init__(self, key: str, identifier: ASTIdentifier,</span>
<span class="gi">+                 parameterPack: bool, default: ASTType) -&gt; None:</span>
<span class="w"> </span>        assert key
<span class="w"> </span>        if parameterPack:
<span class="w"> </span>            assert default is None
<span class="gu">@@ -1253,155 +3725,510 @@ class ASTTemplateKeyParamPackIdDefault(ASTTemplateParam):</span>
<span class="w"> </span>        self.parameterPack = parameterPack
<span class="w"> </span>        self.default = default

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTTemplateKeyParamPackIdDefault):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.key == other.key and self.identifier == other.</span>
<span class="gd">-            identifier and self.parameterPack == other.parameterPack and </span>
<span class="gd">-            self.default == other.default)</span>
<span class="gd">-</span>
<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gd">-        return hash((self.key, self.identifier, self.parameterPack, self.</span>
<span class="gd">-            default))</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.key == other.key</span>
<span class="gi">+            and self.identifier == other.identifier</span>
<span class="gi">+            and self.parameterPack == other.parameterPack</span>
<span class="gi">+            and self.default == other.default</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="gi">+        return hash((self.key, self.identifier, self.parameterPack, self.default))</span>
<span class="gi">+</span>
<span class="gi">+    def get_identifier(self) -&gt; ASTIdentifier:</span>
<span class="gi">+        return self.identifier</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        assert version &gt;= 2</span>
<span class="gi">+        # this is not part of the normal name mangling in C++</span>
<span class="gi">+        res = []</span>
<span class="gi">+        if self.parameterPack:</span>
<span class="gi">+            res.append(&#39;Dp&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            res.append(&#39;0&#39;)  # we need to put something</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = [self.key]</span>
<span class="gi">+        if self.parameterPack:</span>
<span class="gi">+            if self.identifier:</span>
<span class="gi">+                res.append(&#39; &#39;)</span>
<span class="gi">+            res.append(&#39;...&#39;)</span>
<span class="gi">+        if self.identifier:</span>
<span class="gi">+            if not self.parameterPack:</span>
<span class="gi">+                res.append(&#39; &#39;)</span>
<span class="gi">+            res.append(transform(self.identifier))</span>
<span class="gi">+        if self.default:</span>
<span class="gi">+            res.append(&#39; = &#39;)</span>
<span class="gi">+            res.append(transform(self.default))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(self.key, self.key)</span>
<span class="gi">+        if self.parameterPack:</span>
<span class="gi">+            if self.identifier:</span>
<span class="gi">+                signode += addnodes.desc_sig_space()</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;...&#39;, &#39;...&#39;)</span>
<span class="gi">+        if self.identifier:</span>
<span class="gi">+            if not self.parameterPack:</span>
<span class="gi">+                signode += addnodes.desc_sig_space()</span>
<span class="gi">+            self.identifier.describe_signature(signode, mode, env, &#39;&#39;, &#39;&#39;, symbol)</span>
<span class="gi">+        if self.default:</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;=&#39;, &#39;=&#39;)</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            self.default.describe_signature(signode, &#39;markType&#39;, env, symbol)</span>


<span class="w"> </span>class ASTTemplateParamType(ASTTemplateParam):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, data: ASTTemplateKeyParamPackIdDefault) -&gt;None:</span>
<span class="gi">+    def __init__(self, data: ASTTemplateKeyParamPackIdDefault) -&gt; None:</span>
<span class="w"> </span>        assert data
<span class="w"> </span>        self.data = data

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTTemplateParamType):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.data == other.data

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.data)

<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        id = self.get_identifier()</span>
<span class="gi">+        return ASTNestedName([ASTNestedNameElement(id, None)], [False], rooted=False)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def isPack(self) -&gt; bool:</span>
<span class="gi">+        return self.data.parameterPack</span>
<span class="gi">+</span>
<span class="gi">+    def get_identifier(self) -&gt; ASTIdentifier:</span>
<span class="gi">+        return self.data.get_identifier()</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(</span>
<span class="gi">+        self, version: int, objectType: str | None = None, symbol: Symbol | None = None,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        # this is not part of the normal name mangling in C++</span>
<span class="gi">+        assert version &gt;= 2</span>
<span class="gi">+        if symbol:</span>
<span class="gi">+            # the anchor will be our parent</span>
<span class="gi">+            return symbol.parent.declaration.get_id(version, prefixed=False)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.data.get_id(version)</span>

<span class="gd">-class ASTTemplateParamTemplateType(ASTTemplateParam):</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return transform(self.data)</span>

<span class="gd">-    def __init__(self, nestedParams: ASTTemplateParams, data:</span>
<span class="gd">-        ASTTemplateKeyParamPackIdDefault) -&gt;None:</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        self.data.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ASTTemplateParamTemplateType(ASTTemplateParam):</span>
<span class="gi">+    def __init__(self, nestedParams: ASTTemplateParams,</span>
<span class="gi">+                 data: ASTTemplateKeyParamPackIdDefault) -&gt; None:</span>
<span class="w"> </span>        assert nestedParams
<span class="w"> </span>        assert data
<span class="w"> </span>        self.nestedParams = nestedParams
<span class="w"> </span>        self.data = data

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTTemplateParamTemplateType):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.nestedParams == other.nestedParams and self.data ==</span>
<span class="gd">-            other.data)</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.nestedParams == other.nestedParams</span>
<span class="gi">+            and self.data == other.data</span>
<span class="gi">+        )</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.nestedParams, self.data))

<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        id = self.get_identifier()</span>
<span class="gi">+        return ASTNestedName([ASTNestedNameElement(id, None)], [False], rooted=False)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def isPack(self) -&gt; bool:</span>
<span class="gi">+        return self.data.parameterPack</span>
<span class="gi">+</span>
<span class="gi">+    def get_identifier(self) -&gt; ASTIdentifier:</span>
<span class="gi">+        return self.data.get_identifier()</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(</span>
<span class="gi">+        self, version: int, objectType: str | None = None, symbol: Symbol | None = None,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        assert version &gt;= 2</span>
<span class="gi">+        # this is not part of the normal name mangling in C++</span>
<span class="gi">+        if symbol:</span>
<span class="gi">+            # the anchor will be our parent</span>
<span class="gi">+            return symbol.parent.declaration.get_id(version, prefixed=None)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.nestedParams.get_id(version) + self.data.get_id(version)</span>

<span class="gd">-class ASTTemplateParamNonType(ASTTemplateParam):</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return transform(self.nestedParams) + transform(self.data)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        self.nestedParams.describe_signature(signode, &#39;noneIsName&#39;, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_space()</span>
<span class="gi">+        self.data.describe_signature(signode, mode, env, symbol)</span>

<span class="gd">-    def __init__(self, param: (ASTTypeWithInit |</span>
<span class="gd">-        ASTTemplateParamConstrainedTypeWithInit), parameterPack: bool=False</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class ASTTemplateParamNonType(ASTTemplateParam):</span>
<span class="gi">+    def __init__(self,</span>
<span class="gi">+                 param: ASTTypeWithInit | ASTTemplateParamConstrainedTypeWithInit,</span>
<span class="gi">+                 parameterPack: bool = False) -&gt; None:</span>
<span class="w"> </span>        assert param
<span class="w"> </span>        self.param = param
<span class="w"> </span>        self.parameterPack = parameterPack

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTTemplateParamNonType):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.param == other.param and self.parameterPack == other.</span>
<span class="gd">-            parameterPack)</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.param == other.param</span>
<span class="gi">+            and self.parameterPack == other.parameterPack</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        id = self.get_identifier()</span>
<span class="gi">+        return ASTNestedName([ASTNestedNameElement(id, None)], [False], rooted=False)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def isPack(self) -&gt; bool:</span>
<span class="gi">+        return self.param.isPack or self.parameterPack</span>
<span class="gi">+</span>
<span class="gi">+    def get_identifier(self) -&gt; ASTIdentifier:</span>
<span class="gi">+        name = self.param.name</span>
<span class="gi">+        if name:</span>
<span class="gi">+            assert len(name.names) == 1</span>
<span class="gi">+            assert name.names[0].identOrOp</span>
<span class="gi">+            assert not name.names[0].templateArgs</span>
<span class="gi">+            res = name.names[0].identOrOp</span>
<span class="gi">+            assert isinstance(res, ASTIdentifier)</span>
<span class="gi">+            return res</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(</span>
<span class="gi">+        self, version: int, objectType: str | None = None, symbol: Symbol | None = None,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        assert version &gt;= 2</span>
<span class="gi">+        # this is not part of the normal name mangling in C++</span>
<span class="gi">+        if symbol:</span>
<span class="gi">+            # the anchor will be our parent</span>
<span class="gi">+            return symbol.parent.declaration.get_id(version, prefixed=None)</span>
<span class="gi">+        else:</span>
<span class="gi">+            res = &#39;_&#39;</span>
<span class="gi">+            if self.parameterPack:</span>
<span class="gi">+                res += &#39;Dp&#39;</span>
<span class="gi">+            return res + self.param.get_id(version)</span>

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = transform(self.param)</span>
<span class="gi">+        if self.parameterPack:</span>
<span class="gi">+            res += &#39;...&#39;</span>
<span class="gi">+        return res</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        self.param.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        if self.parameterPack:</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;...&#39;, &#39;...&#39;)</span>

<span class="gd">-class ASTTemplateParams(ASTBase):</span>

<span class="gd">-    def __init__(self, params: list[ASTTemplateParam], requiresClause: (</span>
<span class="gd">-        ASTRequiresClause | None)) -&gt;None:</span>
<span class="gi">+class ASTTemplateParams(ASTBase):</span>
<span class="gi">+    def __init__(self, params: list[ASTTemplateParam],</span>
<span class="gi">+                 requiresClause: ASTRequiresClause | None) -&gt; None:</span>
<span class="w"> </span>        assert params is not None
<span class="w"> </span>        self.params = params
<span class="w"> </span>        self.requiresClause = requiresClause

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTTemplateParams):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.params == other.params and self.requiresClause ==</span>
<span class="gd">-            other.requiresClause)</span>
<span class="gi">+        return self.params == other.params and self.requiresClause == other.requiresClause</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.params, self.requiresClause))

<span class="gi">+    def get_id(self, version: int, excludeRequires: bool = False) -&gt; str:</span>
<span class="gi">+        assert version &gt;= 2</span>
<span class="gi">+        res = []</span>
<span class="gi">+        res.append(&quot;I&quot;)</span>
<span class="gi">+        res.extend(param.get_id(version) for param in self.params)</span>
<span class="gi">+        res.append(&quot;E&quot;)</span>
<span class="gi">+        if not excludeRequires and self.requiresClause:</span>
<span class="gi">+            res.extend([&#39;IQ&#39;, self.requiresClause.expr.get_id(version), &#39;E&#39;])</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        res.append(&quot;template&lt;&quot;)</span>
<span class="gi">+        res.append(&quot;, &quot;.join(transform(a) for a in self.params))</span>
<span class="gi">+        res.append(&quot;&gt; &quot;)</span>
<span class="gi">+        if self.requiresClause is not None:</span>
<span class="gi">+            res.append(transform(self.requiresClause))</span>
<span class="gi">+            res.append(&quot; &quot;)</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(&#39;template&#39;, &#39;template&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;&lt;&#39;, &#39;&lt;&#39;)</span>
<span class="gi">+        first = True</span>
<span class="gi">+        for param in self.params:</span>
<span class="gi">+            if not first:</span>
<span class="gi">+                signode += addnodes.desc_sig_punctuation(&#39;,&#39;, &#39;,&#39;)</span>
<span class="gi">+                signode += addnodes.desc_sig_space()</span>
<span class="gi">+            first = False</span>
<span class="gi">+            param.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;&gt;&#39;, &#39;&gt;&#39;)</span>
<span class="gi">+        if self.requiresClause is not None:</span>
<span class="gi">+            signode += addnodes.desc_sig_space()</span>
<span class="gi">+            self.requiresClause.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature_as_introducer(</span>
<span class="gi">+            self, parentNode: desc_signature, mode: str, env: BuildEnvironment,</span>
<span class="gi">+            symbol: Symbol, lineSpec: bool) -&gt; None:</span>
<span class="gi">+        def makeLine(parentNode: desc_signature) -&gt; addnodes.desc_signature_line:</span>
<span class="gi">+            signode = addnodes.desc_signature_line()</span>
<span class="gi">+            parentNode += signode</span>
<span class="gi">+            signode.sphinx_line_type = &#39;templateParams&#39;</span>
<span class="gi">+            return signode</span>
<span class="gi">+        lineNode = makeLine(parentNode)</span>
<span class="gi">+        lineNode += addnodes.desc_sig_keyword(&#39;template&#39;, &#39;template&#39;)</span>
<span class="gi">+        lineNode += addnodes.desc_sig_punctuation(&#39;&lt;&#39;, &#39;&lt;&#39;)</span>
<span class="gi">+        first = True</span>
<span class="gi">+        for param in self.params:</span>
<span class="gi">+            if not first:</span>
<span class="gi">+                lineNode += addnodes.desc_sig_punctuation(&#39;,&#39;, &#39;,&#39;)</span>
<span class="gi">+                lineNode += addnodes.desc_sig_space()</span>
<span class="gi">+            first = False</span>
<span class="gi">+            if lineSpec:</span>
<span class="gi">+                lineNode = makeLine(parentNode)</span>
<span class="gi">+            param.describe_signature(lineNode, mode, env, symbol)</span>
<span class="gi">+        if lineSpec and not first:</span>
<span class="gi">+            lineNode = makeLine(parentNode)</span>
<span class="gi">+        lineNode += addnodes.desc_sig_punctuation(&#39;&gt;&#39;, &#39;&gt;&#39;)</span>
<span class="gi">+        if self.requiresClause:</span>
<span class="gi">+            reqNode = addnodes.desc_signature_line()</span>
<span class="gi">+            reqNode.sphinx_line_type = &#39;requiresClause&#39;</span>
<span class="gi">+            parentNode += reqNode</span>
<span class="gi">+            self.requiresClause.describe_signature(reqNode, &#39;markType&#39;, env, symbol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Template introducers</span>
<span class="gi">+################################################################################</span>

<span class="w"> </span>class ASTTemplateIntroductionParameter(ASTBase):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, identifier: ASTIdentifier, parameterPack: bool) -&gt;None:</span>
<span class="gi">+    def __init__(self, identifier: ASTIdentifier, parameterPack: bool) -&gt; None:</span>
<span class="w"> </span>        self.identifier = identifier
<span class="w"> </span>        self.parameterPack = parameterPack

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTTemplateIntroductionParameter):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.identifier == other.identifier and self.parameterPack ==</span>
<span class="gd">-            other.parameterPack)</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.identifier == other.identifier</span>
<span class="gi">+            and self.parameterPack == other.parameterPack</span>
<span class="gi">+        )</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.identifier, self.parameterPack))

<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        id = self.get_identifier()</span>
<span class="gi">+        return ASTNestedName([ASTNestedNameElement(id, None)], [False], rooted=False)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def isPack(self) -&gt; bool:</span>
<span class="gi">+        return self.parameterPack</span>
<span class="gi">+</span>
<span class="gi">+    def get_identifier(self) -&gt; ASTIdentifier:</span>
<span class="gi">+        return self.identifier</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(</span>
<span class="gi">+        self, version: int, objectType: str | None = None, symbol: Symbol | None = None,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        assert version &gt;= 2</span>
<span class="gi">+        # this is not part of the normal name mangling in C++</span>
<span class="gi">+        if symbol:</span>
<span class="gi">+            # the anchor will be our parent</span>
<span class="gi">+            return symbol.parent.declaration.get_id(version, prefixed=None)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self.parameterPack:</span>
<span class="gi">+                return &#39;Dp&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                return &#39;0&#39;  # we need to put something</span>
<span class="gi">+</span>
<span class="gi">+    def get_id_as_arg(self, version: int) -&gt; str:</span>
<span class="gi">+        assert version &gt;= 2</span>
<span class="gi">+        # used for the implicit requires clause</span>
<span class="gi">+        res = self.identifier.get_id(version)</span>
<span class="gi">+        if self.parameterPack:</span>
<span class="gi">+            return &#39;sp&#39; + res</span>
<span class="gi">+        else:</span>
<span class="gi">+            return res</span>

<span class="gd">-class ASTTemplateIntroduction(ASTBase):</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        if self.parameterPack:</span>
<span class="gi">+            res.append(&#39;...&#39;)</span>
<span class="gi">+        res.append(transform(self.identifier))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>

<span class="gd">-    def __init__(self, concept: ASTNestedName, params: list[</span>
<span class="gd">-        ASTTemplateIntroductionParameter]) -&gt;None:</span>
<span class="gi">+    def describe_signature(self, signode: TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        if self.parameterPack:</span>
<span class="gi">+            signode += addnodes.desc_sig_punctuation(&#39;...&#39;, &#39;...&#39;)</span>
<span class="gi">+        self.identifier.describe_signature(signode, mode, env, &#39;&#39;, &#39;&#39;, symbol)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ASTTemplateIntroduction(ASTBase):</span>
<span class="gi">+    def __init__(self, concept: ASTNestedName,</span>
<span class="gi">+                 params: list[ASTTemplateIntroductionParameter]) -&gt; None:</span>
<span class="w"> </span>        assert len(params) &gt; 0
<span class="w"> </span>        self.concept = concept
<span class="w"> </span>        self.params = params

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTTemplateIntroduction):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.concept == other.concept and self.params == other.params

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.concept, self.params))

<span class="gi">+    def get_id(self, version: int) -&gt; str:</span>
<span class="gi">+        assert version &gt;= 2</span>
<span class="gi">+        return &#39;&#39;.join([</span>
<span class="gi">+            # first do the same as a normal template parameter list</span>
<span class="gi">+            &quot;I&quot;,</span>
<span class="gi">+            *(param.get_id(version) for param in self.params),</span>
<span class="gi">+            &quot;E&quot;,</span>
<span class="gi">+            # let&#39;s use X expr E, which is otherwise for constant template args</span>
<span class="gi">+            &quot;X&quot;,</span>
<span class="gi">+            self.concept.get_id(version),</span>
<span class="gi">+            &quot;I&quot;,</span>
<span class="gi">+            *(param.get_id_as_arg(version) for param in self.params),</span>
<span class="gi">+            &quot;E&quot;,</span>
<span class="gi">+            &quot;E&quot;,</span>
<span class="gi">+        ])</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        res.append(transform(self.concept))</span>
<span class="gi">+        res.append(&#39;{&#39;)</span>
<span class="gi">+        res.append(&#39;, &#39;.join(transform(param) for param in self.params))</span>
<span class="gi">+        res.append(&#39;} &#39;)</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature_as_introducer(</span>
<span class="gi">+            self, parentNode: desc_signature, mode: str,</span>
<span class="gi">+            env: BuildEnvironment, symbol: Symbol, lineSpec: bool) -&gt; None:</span>
<span class="gi">+        # Note: &#39;lineSpec&#39; has no effect on template introductions.</span>
<span class="gi">+        signode = addnodes.desc_signature_line()</span>
<span class="gi">+        parentNode += signode</span>
<span class="gi">+        signode.sphinx_line_type = &#39;templateIntroduction&#39;</span>
<span class="gi">+        self.concept.describe_signature(signode, &#39;markType&#39;, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;{&#39;, &#39;{&#39;)</span>
<span class="gi">+        first = True</span>
<span class="gi">+        for param in self.params:</span>
<span class="gi">+            if not first:</span>
<span class="gi">+                signode += addnodes.desc_sig_punctuation(&#39;,&#39;, &#39;,&#39;)</span>
<span class="gi">+                signode += addnodes.desc_sig_space()</span>
<span class="gi">+            first = False</span>
<span class="gi">+            param.describe_signature(signode, mode, env, symbol)</span>
<span class="gi">+        signode += addnodes.desc_sig_punctuation(&#39;}&#39;, &#39;}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+################################################################################</span>

<span class="w"> </span>class ASTTemplateDeclarationPrefix(ASTBase):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, templates: (list[ASTTemplateParams |</span>
<span class="gd">-        ASTTemplateIntroduction] | None)) -&gt;None:</span>
<span class="gi">+    def __init__(self,</span>
<span class="gi">+                 templates: list[ASTTemplateParams | ASTTemplateIntroduction] | None) -&gt; None:</span>
<span class="gi">+        # templates is None means it&#39;s an explicit instantiation of a variable</span>
<span class="w"> </span>        self.templates = templates

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTTemplateDeclarationPrefix):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.templates == other.templates

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.templates)

<span class="gi">+    def get_requires_clause_in_last(self) -&gt; ASTRequiresClause | None:</span>
<span class="gi">+        if self.templates is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        lastList = self.templates[-1]</span>
<span class="gi">+        if not isinstance(lastList, ASTTemplateParams):</span>
<span class="gi">+            return None</span>
<span class="gi">+        return lastList.requiresClause  # which may be None</span>
<span class="gi">+</span>
<span class="gi">+    def get_id_except_requires_clause_in_last(self, version: int) -&gt; str:</span>
<span class="gi">+        assert version &gt;= 2</span>
<span class="gi">+        # This is not part of the Itanium ABI mangling system.</span>
<span class="gi">+        res = []</span>
<span class="gi">+        lastIndex = len(self.templates) - 1</span>
<span class="gi">+        for i, t in enumerate(self.templates):</span>
<span class="gi">+            if isinstance(t, ASTTemplateParams):</span>
<span class="gi">+                res.append(t.get_id(version, excludeRequires=(i == lastIndex)))</span>
<span class="gi">+            else:</span>
<span class="gi">+                res.append(t.get_id(version))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &#39;&#39;.join(map(transform, self.templates))</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: desc_signature, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol, lineSpec: bool) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        for t in self.templates:</span>
<span class="gi">+            t.describe_signature_as_introducer(signode, &#39;lastIsName&#39;, env, symbol, lineSpec)</span>

<span class="gd">-class ASTRequiresClause(ASTBase):</span>

<span class="gd">-    def __init__(self, expr: ASTExpression) -&gt;None:</span>
<span class="gi">+class ASTRequiresClause(ASTBase):</span>
<span class="gi">+    def __init__(self, expr: ASTExpression) -&gt; None:</span>
<span class="w"> </span>        self.expr = expr

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTRequiresClause):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.expr == other.expr

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.expr)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &#39;requires &#39; + transform(self.expr)</span>

<span class="gd">-class ASTDeclaration(ASTBase):</span>
<span class="gi">+    def describe_signature(self, signode: nodes.TextElement, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, symbol: Symbol) -&gt; None:</span>
<span class="gi">+        signode += addnodes.desc_sig_keyword(&#39;requires&#39;, &#39;requires&#39;)</span>
<span class="gi">+        signode += addnodes.desc_sig_space()</span>
<span class="gi">+        self.expr.describe_signature(signode, mode, env, symbol)</span>

<span class="gd">-    def __init__(self, objectType: str, directiveType: (str | None)=None,</span>
<span class="gd">-        visibility: (str | None)=None, templatePrefix: (</span>
<span class="gd">-        ASTTemplateDeclarationPrefix | None)=None, declaration: Any=None,</span>
<span class="gd">-        trailingRequiresClause: (ASTRequiresClause | None)=None, semicolon:</span>
<span class="gd">-        bool=False) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+################################################################################</span>
<span class="gi">+################################################################################</span>
<span class="gi">+</span>
<span class="gi">+class ASTDeclaration(ASTBase):</span>
<span class="gi">+    def __init__(self, objectType: str, directiveType: str | None = None,</span>
<span class="gi">+                 visibility: str | None = None,</span>
<span class="gi">+                 templatePrefix: ASTTemplateDeclarationPrefix | None = None,</span>
<span class="gi">+                 declaration: Any = None,</span>
<span class="gi">+                 trailingRequiresClause: ASTRequiresClause | None = None,</span>
<span class="gi">+                 semicolon: bool = False) -&gt; None:</span>
<span class="w"> </span>        self.objectType = objectType
<span class="w"> </span>        self.directiveType = directiveType
<span class="w"> </span>        self.visibility = visibility
<span class="gu">@@ -1409,31 +4236,196 @@ class ASTDeclaration(ASTBase):</span>
<span class="w"> </span>        self.declaration = declaration
<span class="w"> </span>        self.trailingRequiresClause = trailingRequiresClause
<span class="w"> </span>        self.semicolon = semicolon
<span class="gi">+</span>
<span class="w"> </span>        self.symbol: Symbol | None = None
<span class="gi">+        # set by CPPObject._add_enumerator_to_parent</span>
<span class="w"> </span>        self.enumeratorScopedSymbol: Symbol | None = None
<span class="gi">+</span>
<span class="gi">+        # the cache assumes that by the time get_newest_id is called, no</span>
<span class="gi">+        # further changes will be made to this object</span>
<span class="w"> </span>        self._newest_id_cache: str | None = None

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTDeclaration):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.objectType == other.objectType and self.directiveType ==</span>
<span class="gd">-            other.directiveType and self.visibility == other.visibility and</span>
<span class="gd">-            self.templatePrefix == other.templatePrefix and self.</span>
<span class="gd">-            declaration == other.declaration and self.</span>
<span class="gd">-            trailingRequiresClause == other.trailingRequiresClause and self</span>
<span class="gd">-            .semicolon == other.semicolon and self.symbol == other.symbol and</span>
<span class="gd">-            self.enumeratorScopedSymbol == other.enumeratorScopedSymbol)</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.objectType == other.objectType</span>
<span class="gi">+            and self.directiveType == other.directiveType</span>
<span class="gi">+            and self.visibility == other.visibility</span>
<span class="gi">+            and self.templatePrefix == other.templatePrefix</span>
<span class="gi">+            and self.declaration == other.declaration</span>
<span class="gi">+            and self.trailingRequiresClause == other.trailingRequiresClause</span>
<span class="gi">+            and self.semicolon == other.semicolon</span>
<span class="gi">+            and self.symbol == other.symbol</span>
<span class="gi">+            and self.enumeratorScopedSymbol == other.enumeratorScopedSymbol</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def clone(self) -&gt; ASTDeclaration:</span>
<span class="gi">+        templatePrefixClone = self.templatePrefix.clone() if self.templatePrefix else None</span>
<span class="gi">+        trailingRequiresClasueClone = self.trailingRequiresClause.clone() \</span>
<span class="gi">+            if self.trailingRequiresClause else None</span>
<span class="gi">+        return ASTDeclaration(self.objectType, self.directiveType, self.visibility,</span>
<span class="gi">+                              templatePrefixClone,</span>
<span class="gi">+                              self.declaration.clone(), trailingRequiresClasueClone,</span>
<span class="gi">+                              self.semicolon)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        return self.declaration.name</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def function_params(self) -&gt; list[ASTFunctionParameter]:</span>
<span class="gi">+        if self.objectType != &#39;function&#39;:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return self.declaration.function_params</span>
<span class="gi">+</span>
<span class="gi">+    def get_id(self, version: int, prefixed: bool = True) -&gt; str:</span>
<span class="gi">+        if version == 1:</span>
<span class="gi">+            if self.templatePrefix or self.trailingRequiresClause:</span>
<span class="gi">+                raise NoOldIdError</span>
<span class="gi">+            if self.objectType == &#39;enumerator&#39; and self.enumeratorScopedSymbol:</span>
<span class="gi">+                return self.enumeratorScopedSymbol.declaration.get_id(version)</span>
<span class="gi">+            return self.declaration.get_id(version, self.objectType, self.symbol)</span>
<span class="gi">+        # version &gt;= 2</span>
<span class="gi">+        if self.objectType == &#39;enumerator&#39; and self.enumeratorScopedSymbol:</span>
<span class="gi">+            return self.enumeratorScopedSymbol.declaration.get_id(version, prefixed)</span>
<span class="gi">+        if prefixed:</span>
<span class="gi">+            res = [_id_prefix[version]]</span>
<span class="gi">+        else:</span>
<span class="gi">+            res = []</span>
<span class="gi">+        # (See also https://github.com/sphinx-doc/sphinx/pull/10286#issuecomment-1168102147)</span>
<span class="gi">+        # The first implementation of requires clauses only supported a single clause after the</span>
<span class="gi">+        # template prefix, and no trailing clause. It put the ID after the template parameter</span>
<span class="gi">+        # list, i.e.,</span>
<span class="gi">+        #    &quot;I&quot; + template_parameter_list_id + &quot;E&quot; + &quot;IQ&quot; + requires_clause_id + &quot;E&quot;</span>
<span class="gi">+        # but the second implementation associates the requires clause with each list, i.e.,</span>
<span class="gi">+        #    &quot;I&quot; + template_parameter_list_id + &quot;IQ&quot; + requires_clause_id + &quot;E&quot; + &quot;E&quot;</span>
<span class="gi">+        # To avoid making a new ID version, we make an exception for the last requires clause</span>
<span class="gi">+        # in the template prefix, and still put it in the end.</span>
<span class="gi">+        # As we now support trailing requires clauses we add that as if it was a conjunction.</span>
<span class="gi">+        if self.templatePrefix is not None:</span>
<span class="gi">+            res.append(self.templatePrefix.get_id_except_requires_clause_in_last(version))</span>
<span class="gi">+            requiresClauseInLast = self.templatePrefix.get_requires_clause_in_last()</span>
<span class="gi">+        else:</span>
<span class="gi">+            requiresClauseInLast = None</span>
<span class="gi">+</span>
<span class="gi">+        if requiresClauseInLast or self.trailingRequiresClause:</span>
<span class="gi">+            if version &lt; 4:</span>
<span class="gi">+                raise NoOldIdError</span>
<span class="gi">+            res.append(&#39;IQ&#39;)</span>
<span class="gi">+            if requiresClauseInLast and self.trailingRequiresClause:</span>
<span class="gi">+                # make a conjunction of them</span>
<span class="gi">+                res.append(&#39;aa&#39;)</span>
<span class="gi">+            if requiresClauseInLast:</span>
<span class="gi">+                res.append(requiresClauseInLast.expr.get_id(version))</span>
<span class="gi">+            if self.trailingRequiresClause:</span>
<span class="gi">+                res.append(self.trailingRequiresClause.expr.get_id(version))</span>
<span class="gi">+            res.append(&#39;E&#39;)</span>
<span class="gi">+        res.append(self.declaration.get_id(version, self.objectType, self.symbol))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def get_newest_id(self) -&gt; str:</span>
<span class="gi">+        if self._newest_id_cache is None:</span>
<span class="gi">+            self._newest_id_cache = self.get_id(_max_id, True)</span>
<span class="gi">+        return self._newest_id_cache</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        if self.visibility and self.visibility != &quot;public&quot;:</span>
<span class="gi">+            res.append(self.visibility)</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+        if self.templatePrefix:</span>
<span class="gi">+            res.append(transform(self.templatePrefix))</span>
<span class="gi">+        res.append(transform(self.declaration))</span>
<span class="gi">+        if self.trailingRequiresClause:</span>
<span class="gi">+            res.append(&#39; &#39;)</span>
<span class="gi">+            res.append(transform(self.trailingRequiresClause))</span>
<span class="gi">+        if self.semicolon:</span>
<span class="gi">+            res.append(&#39;;&#39;)</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: desc_signature, mode: str,</span>
<span class="gi">+                           env: BuildEnvironment, options: dict[str, bool]) -&gt; None:</span>
<span class="gi">+        verify_description_mode(mode)</span>
<span class="gi">+        assert self.symbol</span>
<span class="gi">+        # The caller of the domain added a desc_signature node.</span>
<span class="gi">+        # Always enable multiline:</span>
<span class="gi">+        signode[&#39;is_multiline&#39;] = True</span>
<span class="gi">+        # Put each line in a desc_signature_line node.</span>
<span class="gi">+        mainDeclNode = addnodes.desc_signature_line()</span>
<span class="gi">+        mainDeclNode.sphinx_line_type = &#39;declarator&#39;</span>
<span class="gi">+        mainDeclNode[&#39;add_permalink&#39;] = not self.symbol.isRedeclaration</span>
<span class="gi">+</span>
<span class="gi">+        if self.templatePrefix:</span>
<span class="gi">+            self.templatePrefix.describe_signature(signode, mode, env,</span>
<span class="gi">+                                                   symbol=self.symbol,</span>
<span class="gi">+                                                   lineSpec=options.get(&#39;tparam-line-spec&#39;))</span>
<span class="gi">+        signode += mainDeclNode</span>
<span class="gi">+        if self.visibility and self.visibility != &quot;public&quot;:</span>
<span class="gi">+            mainDeclNode += addnodes.desc_sig_keyword(self.visibility, self.visibility)</span>
<span class="gi">+            mainDeclNode += addnodes.desc_sig_space()</span>
<span class="gi">+        if self.objectType == &#39;type&#39;:</span>
<span class="gi">+            prefix = self.declaration.get_type_declaration_prefix()</span>
<span class="gi">+            mainDeclNode += addnodes.desc_sig_keyword(prefix, prefix)</span>
<span class="gi">+            mainDeclNode += addnodes.desc_sig_space()</span>
<span class="gi">+        elif self.objectType == &#39;concept&#39;:</span>
<span class="gi">+            mainDeclNode += addnodes.desc_sig_keyword(&#39;concept&#39;, &#39;concept&#39;)</span>
<span class="gi">+            mainDeclNode += addnodes.desc_sig_space()</span>
<span class="gi">+        elif self.objectType in {&#39;member&#39;, &#39;function&#39;}:</span>
<span class="gi">+            pass</span>
<span class="gi">+        elif self.objectType == &#39;class&#39;:</span>
<span class="gi">+            assert self.directiveType in (&#39;class&#39;, &#39;struct&#39;)</span>
<span class="gi">+            mainDeclNode += addnodes.desc_sig_keyword(self.directiveType, self.directiveType)</span>
<span class="gi">+            mainDeclNode += addnodes.desc_sig_space()</span>
<span class="gi">+        elif self.objectType == &#39;union&#39;:</span>
<span class="gi">+            mainDeclNode += addnodes.desc_sig_keyword(&#39;union&#39;, &#39;union&#39;)</span>
<span class="gi">+            mainDeclNode += addnodes.desc_sig_space()</span>
<span class="gi">+        elif self.objectType == &#39;enum&#39;:</span>
<span class="gi">+            mainDeclNode += addnodes.desc_sig_keyword(&#39;enum&#39;, &#39;enum&#39;)</span>
<span class="gi">+            mainDeclNode += addnodes.desc_sig_space()</span>
<span class="gi">+            if self.directiveType == &#39;enum-class&#39;:</span>
<span class="gi">+                mainDeclNode += addnodes.desc_sig_keyword(&#39;class&#39;, &#39;class&#39;)</span>
<span class="gi">+                mainDeclNode += addnodes.desc_sig_space()</span>
<span class="gi">+            elif self.directiveType == &#39;enum-struct&#39;:</span>
<span class="gi">+                mainDeclNode += addnodes.desc_sig_keyword(&#39;struct&#39;, &#39;struct&#39;)</span>
<span class="gi">+                mainDeclNode += addnodes.desc_sig_space()</span>
<span class="gi">+            else:</span>
<span class="gi">+                assert self.directiveType == &#39;enum&#39;, self.directiveType</span>
<span class="gi">+        elif self.objectType == &#39;enumerator&#39;:</span>
<span class="gi">+            mainDeclNode += addnodes.desc_sig_keyword(&#39;enumerator&#39;, &#39;enumerator&#39;)</span>
<span class="gi">+            mainDeclNode += addnodes.desc_sig_space()</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise AssertionError(self.objectType)</span>
<span class="gi">+        self.declaration.describe_signature(mainDeclNode, mode, env, self.symbol)</span>
<span class="gi">+        lastDeclNode = mainDeclNode</span>
<span class="gi">+        if self.trailingRequiresClause:</span>
<span class="gi">+            trailingReqNode = addnodes.desc_signature_line()</span>
<span class="gi">+            trailingReqNode.sphinx_line_type = &#39;trailingRequiresClause&#39;</span>
<span class="gi">+            signode.append(trailingReqNode)</span>
<span class="gi">+            lastDeclNode = trailingReqNode</span>
<span class="gi">+            self.trailingRequiresClause.describe_signature(</span>
<span class="gi">+                trailingReqNode, &#39;markType&#39;, env, self.symbol)</span>
<span class="gi">+        if self.semicolon:</span>
<span class="gi">+            lastDeclNode += addnodes.desc_sig_punctuation(&#39;;&#39;, &#39;;&#39;)</span>


<span class="w"> </span>class ASTNamespace(ASTBase):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, nestedName: ASTNestedName, templatePrefix:</span>
<span class="gd">-        ASTTemplateDeclarationPrefix) -&gt;None:</span>
<span class="gi">+    def __init__(self, nestedName: ASTNestedName,</span>
<span class="gi">+                 templatePrefix: ASTTemplateDeclarationPrefix) -&gt; None:</span>
<span class="w"> </span>        self.nestedName = nestedName
<span class="w"> </span>        self.templatePrefix = templatePrefix

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTNamespace):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.nestedName == other.nestedName and self.templatePrefix ==</span>
<span class="gd">-            other.templatePrefix)</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.nestedName == other.nestedName</span>
<span class="gi">+            and self.templatePrefix == other.templatePrefix</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        if self.templatePrefix:</span>
<span class="gi">+            res.append(transform(self.templatePrefix))</span>
<span class="gi">+        res.append(transform(self.nestedName))</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gh">diff --git a/sphinx/domains/cpp/_ids.py b/sphinx/domains/cpp/_ids.py</span>
<span class="gh">index aceb10c93..ee8eb4920 100644</span>
<span class="gd">--- a/sphinx/domains/cpp/_ids.py</span>
<span class="gi">+++ b/sphinx/domains/cpp/_ids.py</span>
<span class="gu">@@ -249,54 +249,54 @@ namespace_object:</span>
<span class="w"> </span>    grammar:
<span class="w"> </span>        nested-name
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="gd">-udl_identifier_re = re.compile(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    [a-zA-Z_][a-zA-Z0-9_]*\\b   # note, no word boundary in the beginning</span>
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    , re.VERBOSE)</span>
<span class="gd">-_string_re = re.compile(</span>
<span class="gd">-    &#39;[LuU8]?(\&#39;([^\&#39;\\\\]*(?:\\\\.[^\&#39;\\\\]*)*)\&#39;|&quot;([^&quot;\\\\]*(?:\\\\.[^&quot;\\\\]*)*)&quot;)&#39;</span>
<span class="gd">-    , re.DOTALL)</span>
<span class="gd">-_visibility_re = re.compile(&#39;\\b(public|private|protected)\\b&#39;)</span>
<span class="gd">-_operator_re = re.compile(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-        \\[\\s*\\]</span>
<span class="gd">-    |   \\(\\s*\\)</span>
<span class="gd">-    |   \\+\\+ | --</span>
<span class="gd">-    |   -&gt;\\*? | \\,</span>
<span class="gd">-    |   (&lt;&lt;|&gt;&gt;)=? | &amp;&amp; | \\|\\|</span>
<span class="gi">+</span>
<span class="gi">+udl_identifier_re = re.compile(r&#39;&#39;&#39;</span>
<span class="gi">+    [a-zA-Z_][a-zA-Z0-9_]*\b   # note, no word boundary in the beginning</span>
<span class="gi">+&#39;&#39;&#39;, re.VERBOSE)</span>
<span class="gi">+_string_re = re.compile(r&quot;[LuU8]?(&#39;([^&#39;\\]*(?:\\.[^&#39;\\]*)*)&#39;&quot;</span>
<span class="gi">+                        r&#39;|&quot;([^&quot;\\]*(?:\\.[^&quot;\\]*)*)&quot;)&#39;, re.DOTALL)</span>
<span class="gi">+_visibility_re = re.compile(r&#39;\b(public|private|protected)\b&#39;)</span>
<span class="gi">+_operator_re = re.compile(r&#39;&#39;&#39;</span>
<span class="gi">+        \[\s*\]</span>
<span class="gi">+    |   \(\s*\)</span>
<span class="gi">+    |   \+\+ | --</span>
<span class="gi">+    |   -&gt;\*? | \,</span>
<span class="gi">+    |   (&lt;&lt;|&gt;&gt;)=? | &amp;&amp; | \|\|</span>
<span class="w"> </span>    |   &lt;=&gt;
<span class="w"> </span>    |   [!&lt;&gt;=/*%+|&amp;^~-]=?
<span class="gd">-    |   (\\b(and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|xor|xor_eq)\\b)</span>
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    , re.VERBOSE)</span>
<span class="gd">-_fold_operator_re = re.compile(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-        -&gt;\\*    |    \\.\\*    |    \\,</span>
<span class="gd">-    |   (&lt;&lt;|&gt;&gt;)=?    |    &amp;&amp;    |    \\|\\|</span>
<span class="gi">+    |   (\b(and|and_eq|bitand|bitor|compl|not|not_eq|or|or_eq|xor|xor_eq)\b)</span>
<span class="gi">+&#39;&#39;&#39;, re.VERBOSE)</span>
<span class="gi">+_fold_operator_re = re.compile(r&#39;&#39;&#39;</span>
<span class="gi">+        -&gt;\*    |    \.\*    |    \,</span>
<span class="gi">+    |   (&lt;&lt;|&gt;&gt;)=?    |    &amp;&amp;    |    \|\|</span>
<span class="w"> </span>    |   !=
<span class="w"> </span>    |   [&lt;&gt;=/*%+|&amp;^~-]=?
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    , re.VERBOSE)</span>
<span class="gd">-_keywords = [&#39;alignas&#39;, &#39;alignof&#39;, &#39;and&#39;, &#39;and_eq&#39;, &#39;asm&#39;, &#39;auto&#39;, &#39;bitand&#39;,</span>
<span class="gd">-    &#39;bitor&#39;, &#39;bool&#39;, &#39;break&#39;, &#39;case&#39;, &#39;catch&#39;, &#39;char&#39;, &#39;char8_t&#39;,</span>
<span class="gd">-    &#39;char16_t&#39;, &#39;char32_t&#39;, &#39;class&#39;, &#39;compl&#39;, &#39;concept&#39;, &#39;const&#39;,</span>
<span class="gd">-    &#39;consteval&#39;, &#39;constexpr&#39;, &#39;constinit&#39;, &#39;const_cast&#39;, &#39;continue&#39;,</span>
<span class="gi">+&#39;&#39;&#39;, re.VERBOSE)</span>
<span class="gi">+# see https://en.cppreference.com/w/cpp/keyword</span>
<span class="gi">+_keywords = [</span>
<span class="gi">+    &#39;alignas&#39;, &#39;alignof&#39;, &#39;and&#39;, &#39;and_eq&#39;, &#39;asm&#39;, &#39;auto&#39;, &#39;bitand&#39;, &#39;bitor&#39;,</span>
<span class="gi">+    &#39;bool&#39;, &#39;break&#39;, &#39;case&#39;, &#39;catch&#39;, &#39;char&#39;, &#39;char8_t&#39;, &#39;char16_t&#39;, &#39;char32_t&#39;,</span>
<span class="gi">+    &#39;class&#39;, &#39;compl&#39;, &#39;concept&#39;, &#39;const&#39;, &#39;consteval&#39;, &#39;constexpr&#39;, &#39;constinit&#39;,</span>
<span class="gi">+    &#39;const_cast&#39;, &#39;continue&#39;,</span>
<span class="w"> </span>    &#39;decltype&#39;, &#39;default&#39;, &#39;delete&#39;, &#39;do&#39;, &#39;double&#39;, &#39;dynamic_cast&#39;, &#39;else&#39;,
<span class="gd">-    &#39;enum&#39;, &#39;explicit&#39;, &#39;export&#39;, &#39;extern&#39;, &#39;false&#39;, &#39;float&#39;, &#39;for&#39;,</span>
<span class="gd">-    &#39;friend&#39;, &#39;goto&#39;, &#39;if&#39;, &#39;inline&#39;, &#39;int&#39;, &#39;long&#39;, &#39;mutable&#39;, &#39;namespace&#39;,</span>
<span class="gd">-    &#39;new&#39;, &#39;noexcept&#39;, &#39;not&#39;, &#39;not_eq&#39;, &#39;nullptr&#39;, &#39;operator&#39;, &#39;or&#39;,</span>
<span class="gd">-    &#39;or_eq&#39;, &#39;private&#39;, &#39;protected&#39;, &#39;public&#39;, &#39;register&#39;,</span>
<span class="gd">-    &#39;reinterpret_cast&#39;, &#39;requires&#39;, &#39;return&#39;, &#39;short&#39;, &#39;signed&#39;, &#39;sizeof&#39;,</span>
<span class="gd">-    &#39;static&#39;, &#39;static_assert&#39;, &#39;static_cast&#39;, &#39;struct&#39;, &#39;switch&#39;,</span>
<span class="gd">-    &#39;template&#39;, &#39;this&#39;, &#39;thread_local&#39;, &#39;throw&#39;, &#39;true&#39;, &#39;try&#39;, &#39;typedef&#39;,</span>
<span class="gd">-    &#39;typeid&#39;, &#39;typename&#39;, &#39;union&#39;, &#39;unsigned&#39;, &#39;using&#39;, &#39;virtual&#39;, &#39;void&#39;,</span>
<span class="gd">-    &#39;volatile&#39;, &#39;wchar_t&#39;, &#39;while&#39;, &#39;xor&#39;, &#39;xor_eq&#39;]</span>
<span class="gd">-_simple_type_specifiers_re = re.compile(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    \\b(</span>
<span class="gi">+    &#39;enum&#39;, &#39;explicit&#39;, &#39;export&#39;, &#39;extern&#39;, &#39;false&#39;, &#39;float&#39;, &#39;for&#39;, &#39;friend&#39;,</span>
<span class="gi">+    &#39;goto&#39;, &#39;if&#39;, &#39;inline&#39;, &#39;int&#39;, &#39;long&#39;, &#39;mutable&#39;, &#39;namespace&#39;, &#39;new&#39;,</span>
<span class="gi">+    &#39;noexcept&#39;, &#39;not&#39;, &#39;not_eq&#39;, &#39;nullptr&#39;, &#39;operator&#39;, &#39;or&#39;, &#39;or_eq&#39;,</span>
<span class="gi">+    &#39;private&#39;, &#39;protected&#39;, &#39;public&#39;, &#39;register&#39;, &#39;reinterpret_cast&#39;,</span>
<span class="gi">+    &#39;requires&#39;, &#39;return&#39;, &#39;short&#39;, &#39;signed&#39;, &#39;sizeof&#39;, &#39;static&#39;,</span>
<span class="gi">+    &#39;static_assert&#39;, &#39;static_cast&#39;, &#39;struct&#39;, &#39;switch&#39;, &#39;template&#39;, &#39;this&#39;,</span>
<span class="gi">+    &#39;thread_local&#39;, &#39;throw&#39;, &#39;true&#39;, &#39;try&#39;, &#39;typedef&#39;, &#39;typeid&#39;, &#39;typename&#39;,</span>
<span class="gi">+    &#39;union&#39;, &#39;unsigned&#39;, &#39;using&#39;, &#39;virtual&#39;, &#39;void&#39;, &#39;volatile&#39;, &#39;wchar_t&#39;,</span>
<span class="gi">+    &#39;while&#39;, &#39;xor&#39;, &#39;xor_eq&#39;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_simple_type_specifiers_re = re.compile(r&quot;&quot;&quot;</span>
<span class="gi">+    \b(</span>
<span class="w"> </span>    auto|void|bool
<span class="w"> </span>    |signed|unsigned
<span class="w"> </span>    |short|long
<span class="gu">@@ -306,72 +306,232 @@ _simple_type_specifiers_re = re.compile(</span>
<span class="w"> </span>    |float|double
<span class="w"> </span>    |__float80|_Float64x|__float128|_Float128  # extension
<span class="w"> </span>    |_Complex|_Imaginary  # extension
<span class="gd">-    )\\b</span>
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    , re.VERBOSE)</span>
<span class="gi">+    )\b</span>
<span class="gi">+&quot;&quot;&quot;, re.VERBOSE)</span>
<span class="gi">+</span>
<span class="w"> </span>_max_id = 4
<span class="w"> </span>_id_prefix = [None, &#39;&#39;, &#39;_CPPv2&#39;, &#39;_CPPv3&#39;, &#39;_CPPv4&#39;]
<span class="gd">-_id_fundamental_v1 = {&#39;char&#39;: &#39;c&#39;, &#39;signed char&#39;: &#39;c&#39;, &#39;unsigned char&#39;: &#39;C&#39;,</span>
<span class="gd">-    &#39;int&#39;: &#39;i&#39;, &#39;signed int&#39;: &#39;i&#39;, &#39;unsigned int&#39;: &#39;U&#39;, &#39;long&#39;: &#39;l&#39;,</span>
<span class="gd">-    &#39;signed long&#39;: &#39;l&#39;, &#39;unsigned long&#39;: &#39;L&#39;, &#39;bool&#39;: &#39;b&#39;}</span>
<span class="gd">-_id_shorthands_v1 = {&#39;std::string&#39;: &#39;ss&#39;, &#39;std::ostream&#39;: &#39;os&#39;,</span>
<span class="gd">-    &#39;std::istream&#39;: &#39;is&#39;, &#39;std::iostream&#39;: &#39;ios&#39;, &#39;std::vector&#39;: &#39;v&#39;,</span>
<span class="gd">-    &#39;std::map&#39;: &#39;m&#39;}</span>
<span class="gd">-_id_operator_v1 = {&#39;new&#39;: &#39;new-operator&#39;, &#39;new[]&#39;: &#39;new-array-operator&#39;,</span>
<span class="gd">-    &#39;delete&#39;: &#39;delete-operator&#39;, &#39;delete[]&#39;: &#39;delete-array-operator&#39;, &#39;~&#39;:</span>
<span class="gd">-    &#39;inv-operator&#39;, &#39;+&#39;: &#39;add-operator&#39;, &#39;-&#39;: &#39;sub-operator&#39;, &#39;*&#39;:</span>
<span class="gd">-    &#39;mul-operator&#39;, &#39;/&#39;: &#39;div-operator&#39;, &#39;%&#39;: &#39;mod-operator&#39;, &#39;&amp;&#39;:</span>
<span class="gd">-    &#39;and-operator&#39;, &#39;|&#39;: &#39;or-operator&#39;, &#39;^&#39;: &#39;xor-operator&#39;, &#39;=&#39;:</span>
<span class="gd">-    &#39;assign-operator&#39;, &#39;+=&#39;: &#39;add-assign-operator&#39;, &#39;-=&#39;:</span>
<span class="gd">-    &#39;sub-assign-operator&#39;, &#39;*=&#39;: &#39;mul-assign-operator&#39;, &#39;/=&#39;:</span>
<span class="gd">-    &#39;div-assign-operator&#39;, &#39;%=&#39;: &#39;mod-assign-operator&#39;, &#39;&amp;=&#39;:</span>
<span class="gd">-    &#39;and-assign-operator&#39;, &#39;|=&#39;: &#39;or-assign-operator&#39;, &#39;^=&#39;:</span>
<span class="gd">-    &#39;xor-assign-operator&#39;, &#39;&lt;&lt;&#39;: &#39;lshift-operator&#39;, &#39;&gt;&gt;&#39;: &#39;rshift-operator&#39;,</span>
<span class="gd">-    &#39;&lt;&lt;=&#39;: &#39;lshift-assign-operator&#39;, &#39;&gt;&gt;=&#39;: &#39;rshift-assign-operator&#39;, &#39;==&#39;:</span>
<span class="gd">-    &#39;eq-operator&#39;, &#39;!=&#39;: &#39;neq-operator&#39;, &#39;&lt;&#39;: &#39;lt-operator&#39;, &#39;&gt;&#39;:</span>
<span class="gd">-    &#39;gt-operator&#39;, &#39;&lt;=&#39;: &#39;lte-operator&#39;, &#39;&gt;=&#39;: &#39;gte-operator&#39;, &#39;!&#39;:</span>
<span class="gd">-    &#39;not-operator&#39;, &#39;&amp;&amp;&#39;: &#39;sand-operator&#39;, &#39;||&#39;: &#39;sor-operator&#39;, &#39;++&#39;:</span>
<span class="gd">-    &#39;inc-operator&#39;, &#39;--&#39;: &#39;dec-operator&#39;, &#39;,&#39;: &#39;comma-operator&#39;, &#39;-&gt;*&#39;:</span>
<span class="gd">-    &#39;pointer-by-pointer-operator&#39;, &#39;-&gt;&#39;: &#39;pointer-operator&#39;, &#39;()&#39;:</span>
<span class="gd">-    &#39;call-operator&#39;, &#39;[]&#39;: &#39;subscript-operator&#39;}</span>
<span class="gd">-_id_fundamental_v2 = {&#39;void&#39;: &#39;v&#39;, &#39;bool&#39;: &#39;b&#39;, &#39;char&#39;: &#39;c&#39;, &#39;signed char&#39;:</span>
<span class="gd">-    &#39;a&#39;, &#39;unsigned char&#39;: &#39;h&#39;, &#39;wchar_t&#39;: &#39;w&#39;, &#39;char32_t&#39;: &#39;Di&#39;, &#39;char16_t&#39;:</span>
<span class="gd">-    &#39;Ds&#39;, &#39;char8_t&#39;: &#39;Du&#39;, &#39;short&#39;: &#39;s&#39;, &#39;short int&#39;: &#39;s&#39;, &#39;signed short&#39;:</span>
<span class="gd">-    &#39;s&#39;, &#39;signed short int&#39;: &#39;s&#39;, &#39;unsigned short&#39;: &#39;t&#39;,</span>
<span class="gd">-    &#39;unsigned short int&#39;: &#39;t&#39;, &#39;int&#39;: &#39;i&#39;, &#39;signed&#39;: &#39;i&#39;, &#39;signed int&#39;: &#39;i&#39;,</span>
<span class="gd">-    &#39;unsigned&#39;: &#39;j&#39;, &#39;unsigned int&#39;: &#39;j&#39;, &#39;long&#39;: &#39;l&#39;, &#39;long int&#39;: &#39;l&#39;,</span>
<span class="gd">-    &#39;signed long&#39;: &#39;l&#39;, &#39;signed long int&#39;: &#39;l&#39;, &#39;unsigned long&#39;: &#39;m&#39;,</span>
<span class="gd">-    &#39;unsigned long int&#39;: &#39;m&#39;, &#39;long long&#39;: &#39;x&#39;, &#39;long long int&#39;: &#39;x&#39;,</span>
<span class="gd">-    &#39;signed long long&#39;: &#39;x&#39;, &#39;signed long long int&#39;: &#39;x&#39;, &#39;__int64&#39;: &#39;x&#39;,</span>
<span class="gd">-    &#39;unsigned long long&#39;: &#39;y&#39;, &#39;unsigned long long int&#39;: &#39;y&#39;, &#39;__int128&#39;:</span>
<span class="gd">-    &#39;n&#39;, &#39;signed __int128&#39;: &#39;n&#39;, &#39;unsigned __int128&#39;: &#39;o&#39;, &#39;float&#39;: &#39;f&#39;,</span>
<span class="gd">-    &#39;double&#39;: &#39;d&#39;, &#39;long double&#39;: &#39;e&#39;, &#39;__float80&#39;: &#39;e&#39;, &#39;_Float64x&#39;: &#39;e&#39;,</span>
<span class="gd">-    &#39;__float128&#39;: &#39;g&#39;, &#39;_Float128&#39;: &#39;g&#39;, &#39;_Complex float&#39;: &#39;Cf&#39;,</span>
<span class="gd">-    &#39;_Complex double&#39;: &#39;Cd&#39;, &#39;_Complex long double&#39;: &#39;Ce&#39;,</span>
<span class="gd">-    &#39;_Imaginary float&#39;: &#39;f&#39;, &#39;_Imaginary double&#39;: &#39;d&#39;,</span>
<span class="gd">-    &#39;_Imaginary long double&#39;: &#39;e&#39;, &#39;auto&#39;: &#39;Da&#39;, &#39;decltype(auto)&#39;: &#39;Dc&#39;,</span>
<span class="gd">-    &#39;std::nullptr_t&#39;: &#39;Dn&#39;}</span>
<span class="gd">-_id_operator_v2 = {&#39;new&#39;: &#39;nw&#39;, &#39;new[]&#39;: &#39;na&#39;, &#39;delete&#39;: &#39;dl&#39;, &#39;delete[]&#39;:</span>
<span class="gd">-    &#39;da&#39;, &#39;~&#39;: &#39;co&#39;, &#39;compl&#39;: &#39;co&#39;, &#39;+&#39;: &#39;pl&#39;, &#39;-&#39;: &#39;mi&#39;, &#39;*&#39;: &#39;ml&#39;, &#39;/&#39;:</span>
<span class="gd">-    &#39;dv&#39;, &#39;%&#39;: &#39;rm&#39;, &#39;&amp;&#39;: &#39;an&#39;, &#39;bitand&#39;: &#39;an&#39;, &#39;|&#39;: &#39;or&#39;, &#39;bitor&#39;: &#39;or&#39;,</span>
<span class="gd">-    &#39;^&#39;: &#39;eo&#39;, &#39;xor&#39;: &#39;eo&#39;, &#39;=&#39;: &#39;aS&#39;, &#39;+=&#39;: &#39;pL&#39;, &#39;-=&#39;: &#39;mI&#39;, &#39;*=&#39;: &#39;mL&#39;,</span>
<span class="gd">-    &#39;/=&#39;: &#39;dV&#39;, &#39;%=&#39;: &#39;rM&#39;, &#39;&amp;=&#39;: &#39;aN&#39;, &#39;and_eq&#39;: &#39;aN&#39;, &#39;|=&#39;: &#39;oR&#39;, &#39;or_eq&#39;:</span>
<span class="gd">-    &#39;oR&#39;, &#39;^=&#39;: &#39;eO&#39;, &#39;xor_eq&#39;: &#39;eO&#39;, &#39;&lt;&lt;&#39;: &#39;ls&#39;, &#39;&gt;&gt;&#39;: &#39;rs&#39;, &#39;&lt;&lt;=&#39;: &#39;lS&#39;,</span>
<span class="gd">-    &#39;&gt;&gt;=&#39;: &#39;rS&#39;, &#39;==&#39;: &#39;eq&#39;, &#39;!=&#39;: &#39;ne&#39;, &#39;not_eq&#39;: &#39;ne&#39;, &#39;&lt;&#39;: &#39;lt&#39;, &#39;&gt;&#39;:</span>
<span class="gd">-    &#39;gt&#39;, &#39;&lt;=&#39;: &#39;le&#39;, &#39;&gt;=&#39;: &#39;ge&#39;, &#39;&lt;=&gt;&#39;: &#39;ss&#39;, &#39;!&#39;: &#39;nt&#39;, &#39;not&#39;: &#39;nt&#39;, &#39;&amp;&amp;&#39;:</span>
<span class="gd">-    &#39;aa&#39;, &#39;and&#39;: &#39;aa&#39;, &#39;||&#39;: &#39;oo&#39;, &#39;or&#39;: &#39;oo&#39;, &#39;++&#39;: &#39;pp&#39;, &#39;--&#39;: &#39;mm&#39;, &#39;,&#39;:</span>
<span class="gd">-    &#39;cm&#39;, &#39;-&gt;*&#39;: &#39;pm&#39;, &#39;-&gt;&#39;: &#39;pt&#39;, &#39;()&#39;: &#39;cl&#39;, &#39;[]&#39;: &#39;ix&#39;, &#39;.*&#39;: &#39;ds&#39;, &#39;?&#39;:</span>
<span class="gd">-    &#39;qu&#39;}</span>
<span class="gd">-_id_operator_unary_v2 = {&#39;++&#39;: &#39;pp_&#39;, &#39;--&#39;: &#39;mm_&#39;, &#39;*&#39;: &#39;de&#39;, &#39;&amp;&#39;: &#39;ad&#39;,</span>
<span class="gd">-    &#39;+&#39;: &#39;ps&#39;, &#39;-&#39;: &#39;ng&#39;, &#39;!&#39;: &#39;nt&#39;, &#39;not&#39;: &#39;nt&#39;, &#39;~&#39;: &#39;co&#39;, &#39;compl&#39;: &#39;co&#39;}</span>
<span class="gd">-_id_char_from_prefix: dict[str | None, str] = {None: &#39;c&#39;, &#39;u8&#39;: &#39;c&#39;, &#39;u&#39;:</span>
<span class="gd">-    &#39;Ds&#39;, &#39;U&#39;: &#39;Di&#39;, &#39;L&#39;: &#39;w&#39;}</span>
<span class="gd">-_expression_bin_ops = [[&#39;||&#39;, &#39;or&#39;], [&#39;&amp;&amp;&#39;, &#39;and&#39;], [&#39;|&#39;, &#39;bitor&#39;], [&#39;^&#39;,</span>
<span class="gd">-    &#39;xor&#39;], [&#39;&amp;&#39;, &#39;bitand&#39;], [&#39;==&#39;, &#39;!=&#39;, &#39;not_eq&#39;], [&#39;&lt;=&gt;&#39;, &#39;&lt;=&#39;, &#39;&gt;=&#39;,</span>
<span class="gd">-    &#39;&lt;&#39;, &#39;&gt;&#39;], [&#39;&lt;&lt;&#39;, &#39;&gt;&gt;&#39;], [&#39;+&#39;, &#39;-&#39;], [&#39;*&#39;, &#39;/&#39;, &#39;%&#39;], [&#39;.*&#39;, &#39;-&gt;*&#39;]]</span>
<span class="gd">-_expression_unary_ops = [&#39;++&#39;, &#39;--&#39;, &#39;*&#39;, &#39;&amp;&#39;, &#39;+&#39;, &#39;-&#39;, &#39;!&#39;, &#39;not&#39;, &#39;~&#39;,</span>
<span class="gd">-    &#39;compl&#39;]</span>
<span class="gd">-_expression_assignment_ops = [&#39;=&#39;, &#39;*=&#39;, &#39;/=&#39;, &#39;%=&#39;, &#39;+=&#39;, &#39;-=&#39;, &#39;&gt;&gt;=&#39;,</span>
<span class="gd">-    &#39;&lt;&lt;=&#39;, &#39;&amp;=&#39;, &#39;and_eq&#39;, &#39;^=&#39;, &#39;|=&#39;, &#39;xor_eq&#39;, &#39;or_eq&#39;]</span>
<span class="gd">-_id_explicit_cast = {&#39;dynamic_cast&#39;: &#39;dc&#39;, &#39;static_cast&#39;: &#39;sc&#39;,</span>
<span class="gd">-    &#39;const_cast&#39;: &#39;cc&#39;, &#39;reinterpret_cast&#39;: &#39;rc&#39;}</span>
<span class="gi">+# Ids are used in lookup keys which are used across pickled files,</span>
<span class="gi">+# so when _max_id changes, make sure to update the ENV_VERSION.</span>
<span class="gi">+</span>
<span class="gi">+# ------------------------------------------------------------------------------</span>
<span class="gi">+# Id v1 constants</span>
<span class="gi">+# ------------------------------------------------------------------------------</span>
<span class="gi">+</span>
<span class="gi">+_id_fundamental_v1 = {</span>
<span class="gi">+    &#39;char&#39;: &#39;c&#39;,</span>
<span class="gi">+    &#39;signed char&#39;: &#39;c&#39;,</span>
<span class="gi">+    &#39;unsigned char&#39;: &#39;C&#39;,</span>
<span class="gi">+    &#39;int&#39;: &#39;i&#39;,</span>
<span class="gi">+    &#39;signed int&#39;: &#39;i&#39;,</span>
<span class="gi">+    &#39;unsigned int&#39;: &#39;U&#39;,</span>
<span class="gi">+    &#39;long&#39;: &#39;l&#39;,</span>
<span class="gi">+    &#39;signed long&#39;: &#39;l&#39;,</span>
<span class="gi">+    &#39;unsigned long&#39;: &#39;L&#39;,</span>
<span class="gi">+    &#39;bool&#39;: &#39;b&#39;,</span>
<span class="gi">+}</span>
<span class="gi">+_id_shorthands_v1 = {</span>
<span class="gi">+    &#39;std::string&#39;: &#39;ss&#39;,</span>
<span class="gi">+    &#39;std::ostream&#39;: &#39;os&#39;,</span>
<span class="gi">+    &#39;std::istream&#39;: &#39;is&#39;,</span>
<span class="gi">+    &#39;std::iostream&#39;: &#39;ios&#39;,</span>
<span class="gi">+    &#39;std::vector&#39;: &#39;v&#39;,</span>
<span class="gi">+    &#39;std::map&#39;: &#39;m&#39;,</span>
<span class="gi">+}</span>
<span class="gi">+_id_operator_v1 = {</span>
<span class="gi">+    &#39;new&#39;: &#39;new-operator&#39;,</span>
<span class="gi">+    &#39;new[]&#39;: &#39;new-array-operator&#39;,</span>
<span class="gi">+    &#39;delete&#39;: &#39;delete-operator&#39;,</span>
<span class="gi">+    &#39;delete[]&#39;: &#39;delete-array-operator&#39;,</span>
<span class="gi">+    # the arguments will make the difference between unary and binary</span>
<span class="gi">+    # &#39;+(unary)&#39; : &#39;ps&#39;,</span>
<span class="gi">+    # &#39;-(unary)&#39; : &#39;ng&#39;,</span>
<span class="gi">+    # &#39;&amp;(unary)&#39; : &#39;ad&#39;,</span>
<span class="gi">+    # &#39;*(unary)&#39; : &#39;de&#39;,</span>
<span class="gi">+    &#39;~&#39;: &#39;inv-operator&#39;,</span>
<span class="gi">+    &#39;+&#39;: &#39;add-operator&#39;,</span>
<span class="gi">+    &#39;-&#39;: &#39;sub-operator&#39;,</span>
<span class="gi">+    &#39;*&#39;: &#39;mul-operator&#39;,</span>
<span class="gi">+    &#39;/&#39;: &#39;div-operator&#39;,</span>
<span class="gi">+    &#39;%&#39;: &#39;mod-operator&#39;,</span>
<span class="gi">+    &#39;&amp;&#39;: &#39;and-operator&#39;,</span>
<span class="gi">+    &#39;|&#39;: &#39;or-operator&#39;,</span>
<span class="gi">+    &#39;^&#39;: &#39;xor-operator&#39;,</span>
<span class="gi">+    &#39;=&#39;: &#39;assign-operator&#39;,</span>
<span class="gi">+    &#39;+=&#39;: &#39;add-assign-operator&#39;,</span>
<span class="gi">+    &#39;-=&#39;: &#39;sub-assign-operator&#39;,</span>
<span class="gi">+    &#39;*=&#39;: &#39;mul-assign-operator&#39;,</span>
<span class="gi">+    &#39;/=&#39;: &#39;div-assign-operator&#39;,</span>
<span class="gi">+    &#39;%=&#39;: &#39;mod-assign-operator&#39;,</span>
<span class="gi">+    &#39;&amp;=&#39;: &#39;and-assign-operator&#39;,</span>
<span class="gi">+    &#39;|=&#39;: &#39;or-assign-operator&#39;,</span>
<span class="gi">+    &#39;^=&#39;: &#39;xor-assign-operator&#39;,</span>
<span class="gi">+    &#39;&lt;&lt;&#39;: &#39;lshift-operator&#39;,</span>
<span class="gi">+    &#39;&gt;&gt;&#39;: &#39;rshift-operator&#39;,</span>
<span class="gi">+    &#39;&lt;&lt;=&#39;: &#39;lshift-assign-operator&#39;,</span>
<span class="gi">+    &#39;&gt;&gt;=&#39;: &#39;rshift-assign-operator&#39;,</span>
<span class="gi">+    &#39;==&#39;: &#39;eq-operator&#39;,</span>
<span class="gi">+    &#39;!=&#39;: &#39;neq-operator&#39;,</span>
<span class="gi">+    &#39;&lt;&#39;: &#39;lt-operator&#39;,</span>
<span class="gi">+    &#39;&gt;&#39;: &#39;gt-operator&#39;,</span>
<span class="gi">+    &#39;&lt;=&#39;: &#39;lte-operator&#39;,</span>
<span class="gi">+    &#39;&gt;=&#39;: &#39;gte-operator&#39;,</span>
<span class="gi">+    &#39;!&#39;: &#39;not-operator&#39;,</span>
<span class="gi">+    &#39;&amp;&amp;&#39;: &#39;sand-operator&#39;,</span>
<span class="gi">+    &#39;||&#39;: &#39;sor-operator&#39;,</span>
<span class="gi">+    &#39;++&#39;: &#39;inc-operator&#39;,</span>
<span class="gi">+    &#39;--&#39;: &#39;dec-operator&#39;,</span>
<span class="gi">+    &#39;,&#39;: &#39;comma-operator&#39;,</span>
<span class="gi">+    &#39;-&gt;*&#39;: &#39;pointer-by-pointer-operator&#39;,</span>
<span class="gi">+    &#39;-&gt;&#39;: &#39;pointer-operator&#39;,</span>
<span class="gi">+    &#39;()&#39;: &#39;call-operator&#39;,</span>
<span class="gi">+    &#39;[]&#39;: &#39;subscript-operator&#39;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+# ------------------------------------------------------------------------------</span>
<span class="gi">+# Id v &gt; 1 constants</span>
<span class="gi">+# ------------------------------------------------------------------------------</span>
<span class="gi">+</span>
<span class="gi">+_id_fundamental_v2 = {</span>
<span class="gi">+    # not all of these are actually parsed as fundamental types, TODO: do that</span>
<span class="gi">+    &#39;void&#39;: &#39;v&#39;,</span>
<span class="gi">+    &#39;bool&#39;: &#39;b&#39;,</span>
<span class="gi">+    &#39;char&#39;: &#39;c&#39;,</span>
<span class="gi">+    &#39;signed char&#39;: &#39;a&#39;,</span>
<span class="gi">+    &#39;unsigned char&#39;: &#39;h&#39;,</span>
<span class="gi">+    &#39;wchar_t&#39;: &#39;w&#39;,</span>
<span class="gi">+    &#39;char32_t&#39;: &#39;Di&#39;,</span>
<span class="gi">+    &#39;char16_t&#39;: &#39;Ds&#39;,</span>
<span class="gi">+    &#39;char8_t&#39;: &#39;Du&#39;,</span>
<span class="gi">+    &#39;short&#39;: &#39;s&#39;,</span>
<span class="gi">+    &#39;short int&#39;: &#39;s&#39;,</span>
<span class="gi">+    &#39;signed short&#39;: &#39;s&#39;,</span>
<span class="gi">+    &#39;signed short int&#39;: &#39;s&#39;,</span>
<span class="gi">+    &#39;unsigned short&#39;: &#39;t&#39;,</span>
<span class="gi">+    &#39;unsigned short int&#39;: &#39;t&#39;,</span>
<span class="gi">+    &#39;int&#39;: &#39;i&#39;,</span>
<span class="gi">+    &#39;signed&#39;: &#39;i&#39;,</span>
<span class="gi">+    &#39;signed int&#39;: &#39;i&#39;,</span>
<span class="gi">+    &#39;unsigned&#39;: &#39;j&#39;,</span>
<span class="gi">+    &#39;unsigned int&#39;: &#39;j&#39;,</span>
<span class="gi">+    &#39;long&#39;: &#39;l&#39;,</span>
<span class="gi">+    &#39;long int&#39;: &#39;l&#39;,</span>
<span class="gi">+    &#39;signed long&#39;: &#39;l&#39;,</span>
<span class="gi">+    &#39;signed long int&#39;: &#39;l&#39;,</span>
<span class="gi">+    &#39;unsigned long&#39;: &#39;m&#39;,</span>
<span class="gi">+    &#39;unsigned long int&#39;: &#39;m&#39;,</span>
<span class="gi">+    &#39;long long&#39;: &#39;x&#39;,</span>
<span class="gi">+    &#39;long long int&#39;: &#39;x&#39;,</span>
<span class="gi">+    &#39;signed long long&#39;: &#39;x&#39;,</span>
<span class="gi">+    &#39;signed long long int&#39;: &#39;x&#39;,</span>
<span class="gi">+    &#39;__int64&#39;: &#39;x&#39;,</span>
<span class="gi">+    &#39;unsigned long long&#39;: &#39;y&#39;,</span>
<span class="gi">+    &#39;unsigned long long int&#39;: &#39;y&#39;,</span>
<span class="gi">+    &#39;__int128&#39;: &#39;n&#39;,</span>
<span class="gi">+    &#39;signed __int128&#39;: &#39;n&#39;,</span>
<span class="gi">+    &#39;unsigned __int128&#39;: &#39;o&#39;,</span>
<span class="gi">+    &#39;float&#39;: &#39;f&#39;,</span>
<span class="gi">+    &#39;double&#39;: &#39;d&#39;,</span>
<span class="gi">+    &#39;long double&#39;: &#39;e&#39;,</span>
<span class="gi">+    &#39;__float80&#39;: &#39;e&#39;, &#39;_Float64x&#39;: &#39;e&#39;,</span>
<span class="gi">+    &#39;__float128&#39;: &#39;g&#39;, &#39;_Float128&#39;: &#39;g&#39;,</span>
<span class="gi">+    &#39;_Complex float&#39;: &#39;Cf&#39;,</span>
<span class="gi">+    &#39;_Complex double&#39;: &#39;Cd&#39;,</span>
<span class="gi">+    &#39;_Complex long double&#39;: &#39;Ce&#39;,</span>
<span class="gi">+    &#39;_Imaginary float&#39;: &#39;f&#39;,</span>
<span class="gi">+    &#39;_Imaginary double&#39;: &#39;d&#39;,</span>
<span class="gi">+    &#39;_Imaginary long double&#39;: &#39;e&#39;,</span>
<span class="gi">+    &#39;auto&#39;: &#39;Da&#39;,</span>
<span class="gi">+    &#39;decltype(auto)&#39;: &#39;Dc&#39;,</span>
<span class="gi">+    &#39;std::nullptr_t&#39;: &#39;Dn&#39;,</span>
<span class="gi">+}</span>
<span class="gi">+_id_operator_v2 = {</span>
<span class="gi">+    &#39;new&#39;: &#39;nw&#39;,</span>
<span class="gi">+    &#39;new[]&#39;: &#39;na&#39;,</span>
<span class="gi">+    &#39;delete&#39;: &#39;dl&#39;,</span>
<span class="gi">+    &#39;delete[]&#39;: &#39;da&#39;,</span>
<span class="gi">+    # the arguments will make the difference between unary and binary</span>
<span class="gi">+    # in operator definitions</span>
<span class="gi">+    # &#39;+(unary)&#39; : &#39;ps&#39;,</span>
<span class="gi">+    # &#39;-(unary)&#39; : &#39;ng&#39;,</span>
<span class="gi">+    # &#39;&amp;(unary)&#39; : &#39;ad&#39;,</span>
<span class="gi">+    # &#39;*(unary)&#39; : &#39;de&#39;,</span>
<span class="gi">+    &#39;~&#39;: &#39;co&#39;, &#39;compl&#39;: &#39;co&#39;,</span>
<span class="gi">+    &#39;+&#39;: &#39;pl&#39;,</span>
<span class="gi">+    &#39;-&#39;: &#39;mi&#39;,</span>
<span class="gi">+    &#39;*&#39;: &#39;ml&#39;,</span>
<span class="gi">+    &#39;/&#39;: &#39;dv&#39;,</span>
<span class="gi">+    &#39;%&#39;: &#39;rm&#39;,</span>
<span class="gi">+    &#39;&amp;&#39;: &#39;an&#39;, &#39;bitand&#39;: &#39;an&#39;,</span>
<span class="gi">+    &#39;|&#39;: &#39;or&#39;, &#39;bitor&#39;: &#39;or&#39;,</span>
<span class="gi">+    &#39;^&#39;: &#39;eo&#39;, &#39;xor&#39;: &#39;eo&#39;,</span>
<span class="gi">+    &#39;=&#39;: &#39;aS&#39;,</span>
<span class="gi">+    &#39;+=&#39;: &#39;pL&#39;,</span>
<span class="gi">+    &#39;-=&#39;: &#39;mI&#39;,</span>
<span class="gi">+    &#39;*=&#39;: &#39;mL&#39;,</span>
<span class="gi">+    &#39;/=&#39;: &#39;dV&#39;,</span>
<span class="gi">+    &#39;%=&#39;: &#39;rM&#39;,</span>
<span class="gi">+    &#39;&amp;=&#39;: &#39;aN&#39;, &#39;and_eq&#39;: &#39;aN&#39;,</span>
<span class="gi">+    &#39;|=&#39;: &#39;oR&#39;, &#39;or_eq&#39;: &#39;oR&#39;,</span>
<span class="gi">+    &#39;^=&#39;: &#39;eO&#39;, &#39;xor_eq&#39;: &#39;eO&#39;,</span>
<span class="gi">+    &#39;&lt;&lt;&#39;: &#39;ls&#39;,</span>
<span class="gi">+    &#39;&gt;&gt;&#39;: &#39;rs&#39;,</span>
<span class="gi">+    &#39;&lt;&lt;=&#39;: &#39;lS&#39;,</span>
<span class="gi">+    &#39;&gt;&gt;=&#39;: &#39;rS&#39;,</span>
<span class="gi">+    &#39;==&#39;: &#39;eq&#39;,</span>
<span class="gi">+    &#39;!=&#39;: &#39;ne&#39;, &#39;not_eq&#39;: &#39;ne&#39;,</span>
<span class="gi">+    &#39;&lt;&#39;: &#39;lt&#39;,</span>
<span class="gi">+    &#39;&gt;&#39;: &#39;gt&#39;,</span>
<span class="gi">+    &#39;&lt;=&#39;: &#39;le&#39;,</span>
<span class="gi">+    &#39;&gt;=&#39;: &#39;ge&#39;,</span>
<span class="gi">+    &#39;&lt;=&gt;&#39;: &#39;ss&#39;,</span>
<span class="gi">+    &#39;!&#39;: &#39;nt&#39;, &#39;not&#39;: &#39;nt&#39;,</span>
<span class="gi">+    &#39;&amp;&amp;&#39;: &#39;aa&#39;, &#39;and&#39;: &#39;aa&#39;,</span>
<span class="gi">+    &#39;||&#39;: &#39;oo&#39;, &#39;or&#39;: &#39;oo&#39;,</span>
<span class="gi">+    &#39;++&#39;: &#39;pp&#39;,</span>
<span class="gi">+    &#39;--&#39;: &#39;mm&#39;,</span>
<span class="gi">+    &#39;,&#39;: &#39;cm&#39;,</span>
<span class="gi">+    &#39;-&gt;*&#39;: &#39;pm&#39;,</span>
<span class="gi">+    &#39;-&gt;&#39;: &#39;pt&#39;,</span>
<span class="gi">+    &#39;()&#39;: &#39;cl&#39;,</span>
<span class="gi">+    &#39;[]&#39;: &#39;ix&#39;,</span>
<span class="gi">+    &#39;.*&#39;: &#39;ds&#39;,  # this one is not overloadable, but we need it for expressions</span>
<span class="gi">+    &#39;?&#39;: &#39;qu&#39;,</span>
<span class="gi">+}</span>
<span class="gi">+_id_operator_unary_v2 = {</span>
<span class="gi">+    &#39;++&#39;: &#39;pp_&#39;,</span>
<span class="gi">+    &#39;--&#39;: &#39;mm_&#39;,</span>
<span class="gi">+    &#39;*&#39;: &#39;de&#39;,</span>
<span class="gi">+    &#39;&amp;&#39;: &#39;ad&#39;,</span>
<span class="gi">+    &#39;+&#39;: &#39;ps&#39;,</span>
<span class="gi">+    &#39;-&#39;: &#39;ng&#39;,</span>
<span class="gi">+    &#39;!&#39;: &#39;nt&#39;, &#39;not&#39;: &#39;nt&#39;,</span>
<span class="gi">+    &#39;~&#39;: &#39;co&#39;, &#39;compl&#39;: &#39;co&#39;,</span>
<span class="gi">+}</span>
<span class="gi">+_id_char_from_prefix: dict[str | None, str] = {</span>
<span class="gi">+    None: &#39;c&#39;, &#39;u8&#39;: &#39;c&#39;,</span>
<span class="gi">+    &#39;u&#39;: &#39;Ds&#39;, &#39;U&#39;: &#39;Di&#39;, &#39;L&#39;: &#39;w&#39;,</span>
<span class="gi">+}</span>
<span class="gi">+# these are ordered by preceedence</span>
<span class="gi">+_expression_bin_ops = [</span>
<span class="gi">+    [&#39;||&#39;, &#39;or&#39;],</span>
<span class="gi">+    [&#39;&amp;&amp;&#39;, &#39;and&#39;],</span>
<span class="gi">+    [&#39;|&#39;, &#39;bitor&#39;],</span>
<span class="gi">+    [&#39;^&#39;, &#39;xor&#39;],</span>
<span class="gi">+    [&#39;&amp;&#39;, &#39;bitand&#39;],</span>
<span class="gi">+    [&#39;==&#39;, &#39;!=&#39;, &#39;not_eq&#39;],</span>
<span class="gi">+    [&#39;&lt;=&gt;&#39;, &#39;&lt;=&#39;, &#39;&gt;=&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;],</span>
<span class="gi">+    [&#39;&lt;&lt;&#39;, &#39;&gt;&gt;&#39;],</span>
<span class="gi">+    [&#39;+&#39;, &#39;-&#39;],</span>
<span class="gi">+    [&#39;*&#39;, &#39;/&#39;, &#39;%&#39;],</span>
<span class="gi">+    [&#39;.*&#39;, &#39;-&gt;*&#39;],</span>
<span class="gi">+]</span>
<span class="gi">+_expression_unary_ops = [&quot;++&quot;, &quot;--&quot;, &quot;*&quot;, &quot;&amp;&quot;, &quot;+&quot;, &quot;-&quot;, &quot;!&quot;, &quot;not&quot;, &quot;~&quot;, &quot;compl&quot;]</span>
<span class="gi">+_expression_assignment_ops = [&quot;=&quot;, &quot;*=&quot;, &quot;/=&quot;, &quot;%=&quot;, &quot;+=&quot;, &quot;-=&quot;,</span>
<span class="gi">+                              &quot;&gt;&gt;=&quot;, &quot;&lt;&lt;=&quot;, &quot;&amp;=&quot;, &quot;and_eq&quot;, &quot;^=&quot;, &quot;|=&quot;, &quot;xor_eq&quot;, &quot;or_eq&quot;]</span>
<span class="gi">+_id_explicit_cast = {</span>
<span class="gi">+    &#39;dynamic_cast&#39;: &#39;dc&#39;,</span>
<span class="gi">+    &#39;static_cast&#39;: &#39;sc&#39;,</span>
<span class="gi">+    &#39;const_cast&#39;: &#39;cc&#39;,</span>
<span class="gi">+    &#39;reinterpret_cast&#39;: &#39;rc&#39;,</span>
<span class="gi">+}</span>
<span class="gh">diff --git a/sphinx/domains/cpp/_parser.py b/sphinx/domains/cpp/_parser.py</span>
<span class="gh">index f09b4224d..d0d70221a 100644</span>
<span class="gd">--- a/sphinx/domains/cpp/_parser.py</span>
<span class="gi">+++ b/sphinx/domains/cpp/_parser.py</span>
<span class="gu">@@ -1,28 +1,2118 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gd">-from sphinx.domains.cpp._ast import ASTAlignofExpr, ASTArray, ASTAssignmentExpr, ASTBaseClass, ASTBinOpExpr, ASTBooleanLiteral, ASTBracedInitList, ASTCastExpr, ASTCharLiteral, ASTClass, ASTCommaExpr, ASTConcept, ASTConditionalExpr, ASTDeclaration, ASTDeclarator, ASTDeclaratorMemPtr, ASTDeclaratorNameBitField, ASTDeclaratorNameParamQual, ASTDeclaratorParamPack, ASTDeclaratorParen, ASTDeclaratorPtr, ASTDeclaratorRef, ASTDeclSpecs, ASTDeclSpecsSimple, ASTDeleteExpr, ASTEnum, ASTEnumerator, ASTExplicitCast, ASTExplicitSpec, ASTExpression, ASTFallbackExpr, ASTFoldExpr, ASTFunctionParameter, ASTIdentifier, ASTIdExpression, ASTInitializer, ASTLiteral, ASTNamespace, ASTNestedName, ASTNestedNameElement, ASTNewExpr, ASTNoexceptExpr, ASTNoexceptSpec, ASTNumberLiteral, ASTOperator, ASTOperatorBuildIn, ASTOperatorLiteral, ASTOperatorType, ASTPackExpansionExpr, ASTParametersQualifiers, ASTParenExpr, ASTParenExprList, ASTPointerLiteral, ASTPostfixArray, ASTPostfixCallExpr, ASTPostfixDec, ASTPostfixExpr, ASTPostfixInc, ASTPostfixMember, ASTPostfixMemberOfPointer, ASTPostfixOp, ASTRequiresClause, ASTSizeofExpr, ASTSizeofParamPack, ASTSizeofType, ASTStringLiteral, ASTTemplateArgConstant, ASTTemplateArgs, ASTTemplateDeclarationPrefix, ASTTemplateIntroduction, ASTTemplateIntroductionParameter, ASTTemplateKeyParamPackIdDefault, ASTTemplateParam, ASTTemplateParamConstrainedTypeWithInit, ASTTemplateParamNonType, ASTTemplateParams, ASTTemplateParamTemplateType, ASTTemplateParamType, ASTThisLiteral, ASTTrailingTypeSpec, ASTTrailingTypeSpecDecltype, ASTTrailingTypeSpecDecltypeAuto, ASTTrailingTypeSpecFundamental, ASTTrailingTypeSpecName, ASTType, ASTTypeId, ASTTypeUsing, ASTTypeWithInit, ASTUnaryOpExpr, ASTUnion, ASTUserDefinedLiteral</span>
<span class="gd">-from sphinx.domains.cpp._ids import _expression_assignment_ops, _expression_bin_ops, _expression_unary_ops, _fold_operator_re, _id_explicit_cast, _keywords, _operator_re, _simple_type_specifiers_re, _string_re, _visibility_re, udl_identifier_re</span>
<span class="gi">+</span>
<span class="gi">+from sphinx.domains.cpp._ast import (</span>
<span class="gi">+    ASTAlignofExpr,</span>
<span class="gi">+    ASTArray,</span>
<span class="gi">+    ASTAssignmentExpr,</span>
<span class="gi">+    ASTBaseClass,</span>
<span class="gi">+    ASTBinOpExpr,</span>
<span class="gi">+    ASTBooleanLiteral,</span>
<span class="gi">+    ASTBracedInitList,</span>
<span class="gi">+    ASTCastExpr,</span>
<span class="gi">+    ASTCharLiteral,</span>
<span class="gi">+    ASTClass,</span>
<span class="gi">+    ASTCommaExpr,</span>
<span class="gi">+    ASTConcept,</span>
<span class="gi">+    ASTConditionalExpr,</span>
<span class="gi">+    ASTDeclaration,</span>
<span class="gi">+    ASTDeclarator,</span>
<span class="gi">+    ASTDeclaratorMemPtr,</span>
<span class="gi">+    ASTDeclaratorNameBitField,</span>
<span class="gi">+    ASTDeclaratorNameParamQual,</span>
<span class="gi">+    ASTDeclaratorParamPack,</span>
<span class="gi">+    ASTDeclaratorParen,</span>
<span class="gi">+    ASTDeclaratorPtr,</span>
<span class="gi">+    ASTDeclaratorRef,</span>
<span class="gi">+    ASTDeclSpecs,</span>
<span class="gi">+    ASTDeclSpecsSimple,</span>
<span class="gi">+    ASTDeleteExpr,</span>
<span class="gi">+    ASTEnum,</span>
<span class="gi">+    ASTEnumerator,</span>
<span class="gi">+    ASTExplicitCast,</span>
<span class="gi">+    ASTExplicitSpec,</span>
<span class="gi">+    ASTExpression,</span>
<span class="gi">+    ASTFallbackExpr,</span>
<span class="gi">+    ASTFoldExpr,</span>
<span class="gi">+    ASTFunctionParameter,</span>
<span class="gi">+    ASTIdentifier,</span>
<span class="gi">+    ASTIdExpression,</span>
<span class="gi">+    ASTInitializer,</span>
<span class="gi">+    ASTLiteral,</span>
<span class="gi">+    ASTNamespace,</span>
<span class="gi">+    ASTNestedName,</span>
<span class="gi">+    ASTNestedNameElement,</span>
<span class="gi">+    ASTNewExpr,</span>
<span class="gi">+    ASTNoexceptExpr,</span>
<span class="gi">+    ASTNoexceptSpec,</span>
<span class="gi">+    ASTNumberLiteral,</span>
<span class="gi">+    ASTOperator,</span>
<span class="gi">+    ASTOperatorBuildIn,</span>
<span class="gi">+    ASTOperatorLiteral,</span>
<span class="gi">+    ASTOperatorType,</span>
<span class="gi">+    ASTPackExpansionExpr,</span>
<span class="gi">+    ASTParametersQualifiers,</span>
<span class="gi">+    ASTParenExpr,</span>
<span class="gi">+    ASTParenExprList,</span>
<span class="gi">+    ASTPointerLiteral,</span>
<span class="gi">+    ASTPostfixArray,</span>
<span class="gi">+    ASTPostfixCallExpr,</span>
<span class="gi">+    ASTPostfixDec,</span>
<span class="gi">+    ASTPostfixExpr,</span>
<span class="gi">+    ASTPostfixInc,</span>
<span class="gi">+    ASTPostfixMember,</span>
<span class="gi">+    ASTPostfixMemberOfPointer,</span>
<span class="gi">+    ASTPostfixOp,</span>
<span class="gi">+    ASTRequiresClause,</span>
<span class="gi">+    ASTSizeofExpr,</span>
<span class="gi">+    ASTSizeofParamPack,</span>
<span class="gi">+    ASTSizeofType,</span>
<span class="gi">+    ASTStringLiteral,</span>
<span class="gi">+    ASTTemplateArgConstant,</span>
<span class="gi">+    ASTTemplateArgs,</span>
<span class="gi">+    ASTTemplateDeclarationPrefix,</span>
<span class="gi">+    ASTTemplateIntroduction,</span>
<span class="gi">+    ASTTemplateIntroductionParameter,</span>
<span class="gi">+    ASTTemplateKeyParamPackIdDefault,</span>
<span class="gi">+    ASTTemplateParam,</span>
<span class="gi">+    ASTTemplateParamConstrainedTypeWithInit,</span>
<span class="gi">+    ASTTemplateParamNonType,</span>
<span class="gi">+    ASTTemplateParams,</span>
<span class="gi">+    ASTTemplateParamTemplateType,</span>
<span class="gi">+    ASTTemplateParamType,</span>
<span class="gi">+    ASTThisLiteral,</span>
<span class="gi">+    ASTTrailingTypeSpec,</span>
<span class="gi">+    ASTTrailingTypeSpecDecltype,</span>
<span class="gi">+    ASTTrailingTypeSpecDecltypeAuto,</span>
<span class="gi">+    ASTTrailingTypeSpecFundamental,</span>
<span class="gi">+    ASTTrailingTypeSpecName,</span>
<span class="gi">+    ASTType,</span>
<span class="gi">+    ASTTypeId,</span>
<span class="gi">+    ASTTypeUsing,</span>
<span class="gi">+    ASTTypeWithInit,</span>
<span class="gi">+    ASTUnaryOpExpr,</span>
<span class="gi">+    ASTUnion,</span>
<span class="gi">+    ASTUserDefinedLiteral,</span>
<span class="gi">+)</span>
<span class="gi">+from sphinx.domains.cpp._ids import (</span>
<span class="gi">+    _expression_assignment_ops,</span>
<span class="gi">+    _expression_bin_ops,</span>
<span class="gi">+    _expression_unary_ops,</span>
<span class="gi">+    _fold_operator_re,</span>
<span class="gi">+    _id_explicit_cast,</span>
<span class="gi">+    _keywords,</span>
<span class="gi">+    _operator_re,</span>
<span class="gi">+    _simple_type_specifiers_re,</span>
<span class="gi">+    _string_re,</span>
<span class="gi">+    _visibility_re,</span>
<span class="gi">+    udl_identifier_re,</span>
<span class="gi">+)</span>
<span class="w"> </span>from sphinx.util import logging
<span class="gd">-from sphinx.util.cfamily import ASTAttributeList, BaseParser, DefinitionError, UnsupportedMultiCharacterCharLiteral, binary_literal_re, char_literal_re, float_literal_re, float_literal_suffix_re, hex_literal_re, identifier_re, integer_literal_re, integers_literal_suffix_re, octal_literal_re</span>
<span class="gi">+from sphinx.util.cfamily import (</span>
<span class="gi">+    ASTAttributeList,</span>
<span class="gi">+    BaseParser,</span>
<span class="gi">+    DefinitionError,</span>
<span class="gi">+    UnsupportedMultiCharacterCharLiteral,</span>
<span class="gi">+    binary_literal_re,</span>
<span class="gi">+    char_literal_re,</span>
<span class="gi">+    float_literal_re,</span>
<span class="gi">+    float_literal_suffix_re,</span>
<span class="gi">+    hex_literal_re,</span>
<span class="gi">+    identifier_re,</span>
<span class="gi">+    integer_literal_re,</span>
<span class="gi">+    integers_literal_suffix_re,</span>
<span class="gi">+    octal_literal_re,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Callable, Sequence
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="w"> </span>class DefinitionParser(BaseParser):
<span class="gi">+    @property</span>
<span class="gi">+    def language(self) -&gt; str:</span>
<span class="gi">+        return &#39;C++&#39;</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def id_attributes(self) -&gt; Sequence[str]:</span>
<span class="gi">+        return self.config.cpp_id_attributes</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def paren_attributes(self) -&gt; Sequence[str]:</span>
<span class="gi">+        return self.config.cpp_paren_attributes</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_string(self) -&gt; str:</span>
<span class="gi">+        if self.current_char != &#39;&quot;&#39;:</span>
<span class="gi">+            return None</span>
<span class="gi">+        startPos = self.pos</span>
<span class="gi">+        self.pos += 1</span>
<span class="gi">+        escape = False</span>
<span class="gi">+        while True:</span>
<span class="gi">+            if self.eof:</span>
<span class="gi">+                self.fail(&quot;Unexpected end during inside string.&quot;)</span>
<span class="gi">+            elif self.current_char == &#39;&quot;&#39; and not escape:</span>
<span class="gi">+                self.pos += 1</span>
<span class="gi">+                break</span>
<span class="gi">+            elif self.current_char == &#39;\\&#39;:</span>
<span class="gi">+                escape = True</span>
<span class="gi">+            else:</span>
<span class="gi">+                escape = False</span>
<span class="gi">+            self.pos += 1</span>
<span class="gi">+        return self.definition[startPos:self.pos]</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_literal(self) -&gt; ASTLiteral:</span>
<span class="gi">+        # -&gt; integer-literal</span>
<span class="gi">+        #  | character-literal</span>
<span class="gi">+        #  | floating-literal</span>
<span class="gi">+        #  | string-literal</span>
<span class="gi">+        #  | boolean-literal -&gt; &quot;false&quot; | &quot;true&quot;</span>
<span class="gi">+        #  | pointer-literal -&gt; &quot;nullptr&quot;</span>
<span class="gi">+        #  | user-defined-literal</span>
<span class="gi">+</span>
<span class="gi">+        def _udl(literal: ASTLiteral) -&gt; ASTLiteral:</span>
<span class="gi">+            if not self.match(udl_identifier_re):</span>
<span class="gi">+                return literal</span>
<span class="gi">+            # hmm, should we care if it&#39;s a keyword?</span>
<span class="gi">+            # it looks like GCC does not disallow keywords</span>
<span class="gi">+            ident = ASTIdentifier(self.matched_text)</span>
<span class="gi">+            return ASTUserDefinedLiteral(literal, ident)</span>
<span class="gi">+</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if self.skip_word(&#39;nullptr&#39;):</span>
<span class="gi">+            return ASTPointerLiteral()</span>
<span class="gi">+        if self.skip_word(&#39;true&#39;):</span>
<span class="gi">+            return ASTBooleanLiteral(True)</span>
<span class="gi">+        if self.skip_word(&#39;false&#39;):</span>
<span class="gi">+            return ASTBooleanLiteral(False)</span>
<span class="gi">+        pos = self.pos</span>
<span class="gi">+        if self.match(float_literal_re):</span>
<span class="gi">+            hasSuffix = self.match(float_literal_suffix_re)</span>
<span class="gi">+            floatLit = ASTNumberLiteral(self.definition[pos:self.pos])</span>
<span class="gi">+            if hasSuffix:</span>
<span class="gi">+                return floatLit</span>
<span class="gi">+            else:</span>
<span class="gi">+                return _udl(floatLit)</span>
<span class="gi">+        for regex in (binary_literal_re, hex_literal_re,</span>
<span class="gi">+                      integer_literal_re, octal_literal_re):</span>
<span class="gi">+            if self.match(regex):</span>
<span class="gi">+                hasSuffix = self.match(integers_literal_suffix_re)</span>
<span class="gi">+                intLit = ASTNumberLiteral(self.definition[pos:self.pos])</span>
<span class="gi">+                if hasSuffix:</span>
<span class="gi">+                    return intLit</span>
<span class="gi">+                else:</span>
<span class="gi">+                    return _udl(intLit)</span>
<span class="gi">+</span>
<span class="gi">+        string = self._parse_string()</span>
<span class="gi">+        if string is not None:</span>
<span class="gi">+            return _udl(ASTStringLiteral(string))</span>
<span class="gi">+</span>
<span class="gi">+        # character-literal</span>
<span class="gi">+        if self.match(char_literal_re):</span>
<span class="gi">+            prefix = self.last_match.group(1)  # may be None when no prefix</span>
<span class="gi">+            data = self.last_match.group(2)</span>
<span class="gi">+            try:</span>
<span class="gi">+                charLit = ASTCharLiteral(prefix, data)</span>
<span class="gi">+            except UnicodeDecodeError as e:</span>
<span class="gi">+                self.fail(&quot;Can not handle character literal. Internal error was: %s&quot; % e)</span>
<span class="gi">+            except UnsupportedMultiCharacterCharLiteral:</span>
<span class="gi">+                self.fail(&quot;Can not handle character literal&quot;</span>
<span class="gi">+                          &quot; resulting in multiple decoded characters.&quot;)</span>
<span class="gi">+            return _udl(charLit)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_fold_or_paren_expression(self) -&gt; ASTExpression | None:</span>
<span class="gi">+        # &quot;(&quot; expression &quot;)&quot;</span>
<span class="gi">+        # fold-expression</span>
<span class="gi">+        # -&gt; ( cast-expression fold-operator ... )</span>
<span class="gi">+        #  | ( ... fold-operator cast-expression )</span>
<span class="gi">+        #  | ( cast-expression fold-operator ... fold-operator cast-expression</span>
<span class="gi">+        if self.current_char != &#39;(&#39;:</span>
<span class="gi">+            return None</span>
<span class="gi">+        self.pos += 1</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if self.skip_string_and_ws(&quot;...&quot;):</span>
<span class="gi">+            # ( ... fold-operator cast-expression )</span>
<span class="gi">+            if not self.match(_fold_operator_re):</span>
<span class="gi">+                self.fail(&quot;Expected fold operator after &#39;...&#39; in fold expression.&quot;)</span>
<span class="gi">+            op = self.matched_text</span>
<span class="gi">+            rightExpr = self._parse_cast_expression()</span>
<span class="gi">+            if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+                self.fail(&quot;Expected &#39;)&#39; in end of fold expression.&quot;)</span>
<span class="gi">+            return ASTFoldExpr(None, op, rightExpr)</span>
<span class="gi">+        # try first parsing a unary right fold, or a binary fold</span>
<span class="gi">+        pos = self.pos</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            leftExpr = self._parse_cast_expression()</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if not self.match(_fold_operator_re):</span>
<span class="gi">+                self.fail(&quot;Expected fold operator after left expression in fold expression.&quot;)</span>
<span class="gi">+            op = self.matched_text</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if not self.skip_string_and_ws(&#39;...&#39;):</span>
<span class="gi">+                self.fail(&quot;Expected &#39;...&#39; after fold operator in fold expression.&quot;)</span>
<span class="gi">+        except DefinitionError as eFold:</span>
<span class="gi">+            self.pos = pos</span>
<span class="gi">+            # fall back to a paren expression</span>
<span class="gi">+            try:</span>
<span class="gi">+                res = self._parse_expression()</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+                    self.fail(&quot;Expected &#39;)&#39; in end of parenthesized expression.&quot;)</span>
<span class="gi">+            except DefinitionError as eExpr:</span>
<span class="gi">+                raise self._make_multi_error([</span>
<span class="gi">+                    (eFold, &quot;If fold expression&quot;),</span>
<span class="gi">+                    (eExpr, &quot;If parenthesized expression&quot;),</span>
<span class="gi">+                ], &quot;Error in fold expression or parenthesized expression.&quot;) from eExpr</span>
<span class="gi">+            return ASTParenExpr(res)</span>
<span class="gi">+        # now it definitely is a fold expression</span>
<span class="gi">+        if self.skip_string(&#39;)&#39;):</span>
<span class="gi">+            return ASTFoldExpr(leftExpr, op, None)</span>
<span class="gi">+        if not self.match(_fold_operator_re):</span>
<span class="gi">+            self.fail(&quot;Expected fold operator or &#39;)&#39; after &#39;...&#39; in fold expression.&quot;)</span>
<span class="gi">+        if op != self.matched_text:</span>
<span class="gi">+            self.fail(&quot;Operators are different in binary fold: &#39;%s&#39; and &#39;%s&#39;.&quot;</span>
<span class="gi">+                      % (op, self.matched_text))</span>
<span class="gi">+        rightExpr = self._parse_cast_expression()</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+            self.fail(&quot;Expected &#39;)&#39; to end binary fold expression.&quot;)</span>
<span class="gi">+        return ASTFoldExpr(leftExpr, op, rightExpr)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_primary_expression(self) -&gt; ASTExpression:</span>
<span class="gi">+        # literal</span>
<span class="gi">+        # &quot;this&quot;</span>
<span class="gi">+        # lambda-expression</span>
<span class="gi">+        # &quot;(&quot; expression &quot;)&quot;</span>
<span class="gi">+        # fold-expression</span>
<span class="gi">+        # id-expression -&gt; we parse this with _parse_nested_name</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        res: ASTExpression = self._parse_literal()</span>
<span class="gi">+        if res is not None:</span>
<span class="gi">+            return res</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if self.skip_word(&quot;this&quot;):</span>
<span class="gi">+            return ASTThisLiteral()</span>
<span class="gi">+        # TODO: try lambda expression</span>
<span class="gi">+        res = self._parse_fold_or_paren_expression()</span>
<span class="gi">+        if res is not None:</span>
<span class="gi">+            return res</span>
<span class="gi">+        nn = self._parse_nested_name()</span>
<span class="gi">+        if nn is not None:</span>
<span class="gi">+            return ASTIdExpression(nn)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_initializer_list(self, name: str, open: str, close: str,</span>
<span class="gi">+                                ) -&gt; tuple[list[ASTExpression | ASTBracedInitList],</span>
<span class="gi">+                                           bool]:</span>
<span class="gi">+        # Parse open and close with the actual initializer-list in between</span>
<span class="gi">+        # -&gt; initializer-clause &#39;...&#39;[opt]</span>
<span class="gi">+        #  | initializer-list &#39;,&#39; initializer-clause &#39;...&#39;[opt]</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if not self.skip_string_and_ws(open):</span>
<span class="gi">+            return None, None</span>
<span class="gi">+        if self.skip_string(close):</span>
<span class="gi">+            return [], False</span>
<span class="gi">+</span>
<span class="gi">+        exprs: list[ASTExpression | ASTBracedInitList] = []</span>
<span class="gi">+        trailingComma = False</span>
<span class="gi">+        while True:</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            expr = self._parse_initializer_clause()</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if self.skip_string(&#39;...&#39;):</span>
<span class="gi">+                exprs.append(ASTPackExpansionExpr(expr))</span>
<span class="gi">+            else:</span>
<span class="gi">+                exprs.append(expr)</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if self.skip_string(close):</span>
<span class="gi">+                break</span>
<span class="gi">+            if not self.skip_string_and_ws(&#39;,&#39;):</span>
<span class="gi">+                self.fail(f&quot;Error in {name}, expected &#39;,&#39; or &#39;{close}&#39;.&quot;)</span>
<span class="gi">+            if self.current_char == close == &#39;}&#39;:</span>
<span class="gi">+                self.pos += 1</span>
<span class="gi">+                trailingComma = True</span>
<span class="gi">+                break</span>
<span class="gi">+        return exprs, trailingComma</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_paren_expression_list(self) -&gt; ASTParenExprList:</span>
<span class="gi">+        # -&gt; &#39;(&#39; expression-list &#39;)&#39;</span>
<span class="gi">+        # though, we relax it to also allow empty parens</span>
<span class="gi">+        # as it&#39;s needed in some cases</span>
<span class="gi">+        #</span>
<span class="gi">+        # expression-list</span>
<span class="gi">+        # -&gt; initializer-list</span>
<span class="gi">+        exprs, trailingComma = self._parse_initializer_list(&quot;parenthesized expression-list&quot;,</span>
<span class="gi">+                                                            &#39;(&#39;, &#39;)&#39;)</span>
<span class="gi">+        if exprs is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return ASTParenExprList(exprs)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_initializer_clause(self) -&gt; ASTExpression | ASTBracedInitList:</span>
<span class="gi">+        bracedInitList = self._parse_braced_init_list()</span>
<span class="gi">+        if bracedInitList is not None:</span>
<span class="gi">+            return bracedInitList</span>
<span class="gi">+        return self._parse_assignment_expression(inTemplate=False)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_braced_init_list(self) -&gt; ASTBracedInitList:</span>
<span class="gi">+        # -&gt; &#39;{&#39; initializer-list &#39;,&#39;[opt] &#39;}&#39;</span>
<span class="gi">+        #  | &#39;{&#39; &#39;}&#39;</span>
<span class="gi">+        exprs, trailingComma = self._parse_initializer_list(&quot;braced-init-list&quot;, &#39;{&#39;, &#39;}&#39;)</span>
<span class="gi">+        if exprs is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return ASTBracedInitList(exprs, trailingComma)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_expression_list_or_braced_init_list(</span>
<span class="gi">+        self,</span>
<span class="gi">+    ) -&gt; ASTParenExprList | ASTBracedInitList:</span>
<span class="gi">+        paren = self._parse_paren_expression_list()</span>
<span class="gi">+        if paren is not None:</span>
<span class="gi">+            return paren</span>
<span class="gi">+        return self._parse_braced_init_list()</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_postfix_expression(self) -&gt; ASTPostfixExpr:</span>
<span class="gi">+        # -&gt; primary</span>
<span class="gi">+        #  | postfix &quot;[&quot; expression &quot;]&quot;</span>
<span class="gi">+        #  | postfix &quot;[&quot; braced-init-list [opt] &quot;]&quot;</span>
<span class="gi">+        #  | postfix &quot;(&quot; expression-list [opt] &quot;)&quot;</span>
<span class="gi">+        #  | postfix &quot;.&quot; &quot;template&quot; [opt] id-expression</span>
<span class="gi">+        #  | postfix &quot;-&gt;&quot; &quot;template&quot; [opt] id-expression</span>
<span class="gi">+        #  | postfix &quot;.&quot; pseudo-destructor-name</span>
<span class="gi">+        #  | postfix &quot;-&gt;&quot; pseudo-destructor-name</span>
<span class="gi">+        #  | postfix &quot;++&quot;</span>
<span class="gi">+        #  | postfix &quot;--&quot;</span>
<span class="gi">+        #  | simple-type-specifier &quot;(&quot; expression-list [opt] &quot;)&quot;</span>
<span class="gi">+        #  | simple-type-specifier braced-init-list</span>
<span class="gi">+        #  | typename-specifier &quot;(&quot; expression-list [opt] &quot;)&quot;</span>
<span class="gi">+        #  | typename-specifier braced-init-list</span>
<span class="gi">+        #  | &quot;dynamic_cast&quot; &quot;&lt;&quot; type-id &quot;&gt;&quot; &quot;(&quot; expression &quot;)&quot;</span>
<span class="gi">+        #  | &quot;static_cast&quot; &quot;&lt;&quot; type-id &quot;&gt;&quot; &quot;(&quot; expression &quot;)&quot;</span>
<span class="gi">+        #  | &quot;reinterpret_cast&quot; &quot;&lt;&quot; type-id &quot;&gt;&quot; &quot;(&quot; expression &quot;)&quot;</span>
<span class="gi">+        #  | &quot;const_cast&quot; &quot;&lt;&quot; type-id &quot;&gt;&quot; &quot;(&quot; expression &quot;)&quot;</span>
<span class="gi">+        #  | &quot;typeid&quot; &quot;(&quot; expression &quot;)&quot;</span>
<span class="gi">+        #  | &quot;typeid&quot; &quot;(&quot; type-id &quot;)&quot;</span>
<span class="gi">+</span>
<span class="gi">+        prefixType = None</span>
<span class="gi">+        prefix: Any = None</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+</span>
<span class="gi">+        cast = None</span>
<span class="gi">+        for c in _id_explicit_cast:</span>
<span class="gi">+            if self.skip_word_and_ws(c):</span>
<span class="gi">+                cast = c</span>
<span class="gi">+                break</span>
<span class="gi">+        if cast is not None:</span>
<span class="gi">+            prefixType = &quot;cast&quot;</span>
<span class="gi">+            if not self.skip_string(&quot;&lt;&quot;):</span>
<span class="gi">+                self.fail(&quot;Expected &#39;&lt;&#39; after &#39;%s&#39;.&quot; % cast)</span>
<span class="gi">+            typ = self._parse_type(False)</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if not self.skip_string_and_ws(&quot;&gt;&quot;):</span>
<span class="gi">+                self.fail(&quot;Expected &#39;&gt;&#39; after type in &#39;%s&#39;.&quot; % cast)</span>
<span class="gi">+            if not self.skip_string(&quot;(&quot;):</span>
<span class="gi">+                self.fail(&quot;Expected &#39;(&#39; in &#39;%s&#39;.&quot; % cast)</span>
<span class="gi">+</span>
<span class="gi">+            def parser() -&gt; ASTExpression:</span>
<span class="gi">+                return self._parse_expression()</span>
<span class="gi">+            expr = self._parse_expression_fallback([&#39;)&#39;], parser)</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if not self.skip_string(&quot;)&quot;):</span>
<span class="gi">+                self.fail(&quot;Expected &#39;)&#39; to end &#39;%s&#39;.&quot; % cast)</span>
<span class="gi">+            prefix = ASTExplicitCast(cast, typ, expr)</span>
<span class="gi">+        elif self.skip_word_and_ws(&quot;typeid&quot;):</span>
<span class="gi">+            prefixType = &quot;typeid&quot;</span>
<span class="gi">+            if not self.skip_string_and_ws(&#39;(&#39;):</span>
<span class="gi">+                self.fail(&quot;Expected &#39;(&#39; after &#39;typeid&#39;.&quot;)</span>
<span class="gi">+            pos = self.pos</span>
<span class="gi">+            try:</span>
<span class="gi">+                typ = self._parse_type(False)</span>
<span class="gi">+                prefix = ASTTypeId(typ, isType=True)</span>
<span class="gi">+                if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+                    self.fail(&quot;Expected &#39;)&#39; to end &#39;typeid&#39; of type.&quot;)</span>
<span class="gi">+            except DefinitionError as eType:</span>
<span class="gi">+                self.pos = pos</span>
<span class="gi">+                try:</span>
<span class="gi">+</span>
<span class="gi">+                    def parser() -&gt; ASTExpression:</span>
<span class="gi">+                        return self._parse_expression()</span>
<span class="gi">+                    expr = self._parse_expression_fallback([&#39;)&#39;], parser)</span>
<span class="gi">+                    prefix = ASTTypeId(expr, isType=False)</span>
<span class="gi">+                    if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+                        self.fail(&quot;Expected &#39;)&#39; to end &#39;typeid&#39; of expression.&quot;)</span>
<span class="gi">+                except DefinitionError as eExpr:</span>
<span class="gi">+                    self.pos = pos</span>
<span class="gi">+                    header = &quot;Error in &#39;typeid(...)&#39;.&quot;</span>
<span class="gi">+                    header += &quot; Expected type or expression.&quot;</span>
<span class="gi">+                    errors = []</span>
<span class="gi">+                    errors.append((eType, &quot;If type&quot;))</span>
<span class="gi">+                    errors.append((eExpr, &quot;If expression&quot;))</span>
<span class="gi">+                    raise self._make_multi_error(errors, header) from eExpr</span>
<span class="gi">+        else:  # a primary expression or a type</span>
<span class="gi">+            pos = self.pos</span>
<span class="gi">+            try:</span>
<span class="gi">+                prefix = self._parse_primary_expression()</span>
<span class="gi">+                prefixType = &#39;expr&#39;</span>
<span class="gi">+            except DefinitionError as eOuter:</span>
<span class="gi">+                self.pos = pos</span>
<span class="gi">+                try:</span>
<span class="gi">+                    # we are potentially casting, so save parens for us</span>
<span class="gi">+                    # TODO: hmm, would we need to try both with operatorCast and with None?</span>
<span class="gi">+                    prefix = self._parse_type(False, &#39;operatorCast&#39;)</span>
<span class="gi">+                    prefixType = &#39;typeOperatorCast&#39;</span>
<span class="gi">+                    #  | simple-type-specifier &quot;(&quot; expression-list [opt] &quot;)&quot;</span>
<span class="gi">+                    #  | simple-type-specifier braced-init-list</span>
<span class="gi">+                    #  | typename-specifier &quot;(&quot; expression-list [opt] &quot;)&quot;</span>
<span class="gi">+                    #  | typename-specifier braced-init-list</span>
<span class="gi">+                    self.skip_ws()</span>
<span class="gi">+                    if self.current_char != &#39;(&#39; and self.current_char != &#39;{&#39;:</span>
<span class="gi">+                        self.fail(&quot;Expecting &#39;(&#39; or &#39;{&#39; after type in cast expression.&quot;)</span>
<span class="gi">+                except DefinitionError as eInner:</span>
<span class="gi">+                    self.pos = pos</span>
<span class="gi">+                    header = &quot;Error in postfix expression,&quot;</span>
<span class="gi">+                    header += &quot; expected primary expression or type.&quot;</span>
<span class="gi">+                    errors = []</span>
<span class="gi">+                    errors.append((eOuter, &quot;If primary expression&quot;))</span>
<span class="gi">+                    errors.append((eInner, &quot;If type&quot;))</span>
<span class="gi">+                    raise self._make_multi_error(errors, header) from eInner</span>
<span class="gi">+</span>
<span class="gi">+        # and now parse postfixes</span>
<span class="gi">+        postFixes: list[ASTPostfixOp] = []</span>
<span class="gi">+        while True:</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if prefixType in (&#39;expr&#39;, &#39;cast&#39;, &#39;typeid&#39;):</span>
<span class="gi">+                if self.skip_string_and_ws(&#39;[&#39;):</span>
<span class="gi">+                    expr = self._parse_expression()</span>
<span class="gi">+                    self.skip_ws()</span>
<span class="gi">+                    if not self.skip_string(&#39;]&#39;):</span>
<span class="gi">+                        self.fail(&quot;Expected &#39;]&#39; in end of postfix expression.&quot;)</span>
<span class="gi">+                    postFixes.append(ASTPostfixArray(expr))</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if self.skip_string(&#39;.&#39;):</span>
<span class="gi">+                    if self.skip_string(&#39;*&#39;):</span>
<span class="gi">+                        # don&#39;t steal the dot</span>
<span class="gi">+                        self.pos -= 2</span>
<span class="gi">+                    elif self.skip_string(&#39;..&#39;):</span>
<span class="gi">+                        # don&#39;t steal the dot</span>
<span class="gi">+                        self.pos -= 3</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        name = self._parse_nested_name()</span>
<span class="gi">+                        postFixes.append(ASTPostfixMember(name))</span>
<span class="gi">+                        continue</span>
<span class="gi">+                if self.skip_string(&#39;-&gt;&#39;):</span>
<span class="gi">+                    if self.skip_string(&#39;*&#39;):</span>
<span class="gi">+                        # don&#39;t steal the arrow</span>
<span class="gi">+                        self.pos -= 3</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        name = self._parse_nested_name()</span>
<span class="gi">+                        postFixes.append(ASTPostfixMemberOfPointer(name))</span>
<span class="gi">+                        continue</span>
<span class="gi">+                if self.skip_string(&#39;++&#39;):</span>
<span class="gi">+                    postFixes.append(ASTPostfixInc())</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if self.skip_string(&#39;--&#39;):</span>
<span class="gi">+                    postFixes.append(ASTPostfixDec())</span>
<span class="gi">+                    continue</span>
<span class="gi">+            lst = self._parse_expression_list_or_braced_init_list()</span>
<span class="gi">+            if lst is not None:</span>
<span class="gi">+                postFixes.append(ASTPostfixCallExpr(lst))</span>
<span class="gi">+                continue</span>
<span class="gi">+            break</span>
<span class="gi">+        return ASTPostfixExpr(prefix, postFixes)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_unary_expression(self) -&gt; ASTExpression:</span>
<span class="gi">+        # -&gt; postfix</span>
<span class="gi">+        #  | &quot;++&quot; cast</span>
<span class="gi">+        #  | &quot;--&quot; cast</span>
<span class="gi">+        #  | unary-operator cast -&gt; (* | &amp; | + | - | ! | ~) cast</span>
<span class="gi">+        # The rest:</span>
<span class="gi">+        #  | &quot;sizeof&quot; unary</span>
<span class="gi">+        #  | &quot;sizeof&quot; &quot;(&quot; type-id &quot;)&quot;</span>
<span class="gi">+        #  | &quot;sizeof&quot; &quot;...&quot; &quot;(&quot; identifier &quot;)&quot;</span>
<span class="gi">+        #  | &quot;alignof&quot; &quot;(&quot; type-id &quot;)&quot;</span>
<span class="gi">+        #  | noexcept-expression -&gt; noexcept &quot;(&quot; expression &quot;)&quot;</span>
<span class="gi">+        #  | new-expression</span>
<span class="gi">+        #  | delete-expression</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        for op in _expression_unary_ops:</span>
<span class="gi">+            # TODO: hmm, should we be able to backtrack here?</span>
<span class="gi">+            if op[0] in &#39;cn&#39;:</span>
<span class="gi">+                res = self.skip_word(op)</span>
<span class="gi">+            else:</span>
<span class="gi">+                res = self.skip_string(op)</span>
<span class="gi">+            if res:</span>
<span class="gi">+                expr = self._parse_cast_expression()</span>
<span class="gi">+                return ASTUnaryOpExpr(op, expr)</span>
<span class="gi">+        if self.skip_word_and_ws(&#39;sizeof&#39;):</span>
<span class="gi">+            if self.skip_string_and_ws(&#39;...&#39;):</span>
<span class="gi">+                if not self.skip_string_and_ws(&#39;(&#39;):</span>
<span class="gi">+                    self.fail(&quot;Expecting &#39;(&#39; after &#39;sizeof...&#39;.&quot;)</span>
<span class="gi">+                if not self.match(identifier_re):</span>
<span class="gi">+                    self.fail(&quot;Expecting identifier for &#39;sizeof...&#39;.&quot;)</span>
<span class="gi">+                ident = ASTIdentifier(self.matched_text)</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                if not self.skip_string(&quot;)&quot;):</span>
<span class="gi">+                    self.fail(&quot;Expecting &#39;)&#39; to end &#39;sizeof...&#39;.&quot;)</span>
<span class="gi">+                return ASTSizeofParamPack(ident)</span>
<span class="gi">+            if self.skip_string_and_ws(&#39;(&#39;):</span>
<span class="gi">+                typ = self._parse_type(named=False)</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+                    self.fail(&quot;Expecting &#39;)&#39; to end &#39;sizeof&#39;.&quot;)</span>
<span class="gi">+                return ASTSizeofType(typ)</span>
<span class="gi">+            expr = self._parse_unary_expression()</span>
<span class="gi">+            return ASTSizeofExpr(expr)</span>
<span class="gi">+        if self.skip_word_and_ws(&#39;alignof&#39;):</span>
<span class="gi">+            if not self.skip_string_and_ws(&#39;(&#39;):</span>
<span class="gi">+                self.fail(&quot;Expecting &#39;(&#39; after &#39;alignof&#39;.&quot;)</span>
<span class="gi">+            typ = self._parse_type(named=False)</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+                self.fail(&quot;Expecting &#39;)&#39; to end &#39;alignof&#39;.&quot;)</span>
<span class="gi">+            return ASTAlignofExpr(typ)</span>
<span class="gi">+        if self.skip_word_and_ws(&#39;noexcept&#39;):</span>
<span class="gi">+            if not self.skip_string_and_ws(&#39;(&#39;):</span>
<span class="gi">+                self.fail(&quot;Expecting &#39;(&#39; after &#39;noexcept&#39;.&quot;)</span>
<span class="gi">+            expr = self._parse_expression()</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+                self.fail(&quot;Expecting &#39;)&#39; to end &#39;noexcept&#39;.&quot;)</span>
<span class="gi">+            return ASTNoexceptExpr(expr)</span>
<span class="gi">+        # new-expression</span>
<span class="gi">+        pos = self.pos</span>
<span class="gi">+        rooted = self.skip_string(&#39;::&#39;)</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if not self.skip_word_and_ws(&#39;new&#39;):</span>
<span class="gi">+            self.pos = pos</span>
<span class="gi">+        else:</span>
<span class="gi">+            # new-placement[opt] new-type-id new-initializer[opt]</span>
<span class="gi">+            # new-placement[opt] ( type-id ) new-initializer[opt]</span>
<span class="gi">+            isNewTypeId = True</span>
<span class="gi">+            if self.skip_string_and_ws(&#39;(&#39;):</span>
<span class="gi">+                # either this is a new-placement or it&#39;s the second production</span>
<span class="gi">+                # without placement, and it&#39;s actually the ( type-id ) part</span>
<span class="gi">+                self.fail(&quot;Sorry, neither new-placement nor parenthesised type-id &quot;</span>
<span class="gi">+                          &quot;in new-epression is supported yet.&quot;)</span>
<span class="gi">+                # set isNewTypeId = False if it&#39;s (type-id)</span>
<span class="gi">+            if isNewTypeId:</span>
<span class="gi">+                declSpecs = self._parse_decl_specs(outer=None)</span>
<span class="gi">+                decl = self._parse_declarator(named=False, paramMode=&quot;new&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.fail(&quot;Sorry, parenthesised type-id in new expression not yet supported.&quot;)</span>
<span class="gi">+            lst = self._parse_expression_list_or_braced_init_list()</span>
<span class="gi">+            return ASTNewExpr(rooted, isNewTypeId, ASTType(declSpecs, decl), lst)</span>
<span class="gi">+        # delete-expression</span>
<span class="gi">+        pos = self.pos</span>
<span class="gi">+        rooted = self.skip_string(&#39;::&#39;)</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if not self.skip_word_and_ws(&#39;delete&#39;):</span>
<span class="gi">+            self.pos = pos</span>
<span class="gi">+        else:</span>
<span class="gi">+            array = self.skip_string_and_ws(&#39;[&#39;)</span>
<span class="gi">+            if array and not self.skip_string_and_ws(&#39;]&#39;):</span>
<span class="gi">+                self.fail(&quot;Expected &#39;]&#39; in array delete-expression.&quot;)</span>
<span class="gi">+            expr = self._parse_cast_expression()</span>
<span class="gi">+            return ASTDeleteExpr(rooted, array, expr)</span>
<span class="gi">+        return self._parse_postfix_expression()</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_cast_expression(self) -&gt; ASTExpression:</span>
<span class="gi">+        # -&gt; unary  | &quot;(&quot; type-id &quot;)&quot; cast</span>
<span class="gi">+        pos = self.pos</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if self.skip_string(&#39;(&#39;):</span>
<span class="gi">+            try:</span>
<span class="gi">+                typ = self._parse_type(False)</span>
<span class="gi">+                if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+                    self.fail(&quot;Expected &#39;)&#39; in cast expression.&quot;)</span>
<span class="gi">+                expr = self._parse_cast_expression()</span>
<span class="gi">+                return ASTCastExpr(typ, expr)</span>
<span class="gi">+            except DefinitionError as exCast:</span>
<span class="gi">+                self.pos = pos</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return self._parse_unary_expression()</span>
<span class="gi">+                except DefinitionError as exUnary:</span>
<span class="gi">+                    errs = []</span>
<span class="gi">+                    errs.append((exCast, &quot;If type cast expression&quot;))</span>
<span class="gi">+                    errs.append((exUnary, &quot;If unary expression&quot;))</span>
<span class="gi">+                    raise self._make_multi_error(errs,</span>
<span class="gi">+                                                 &quot;Error in cast expression.&quot;) from exUnary</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self._parse_unary_expression()</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_logical_or_expression(self, inTemplate: bool) -&gt; ASTExpression:</span>
<span class="gi">+        # logical-or     = logical-and      ||</span>
<span class="gi">+        # logical-and    = inclusive-or     &amp;&amp;</span>
<span class="gi">+        # inclusive-or   = exclusive-or     |</span>
<span class="gi">+        # exclusive-or   = and              ^</span>
<span class="gi">+        # and            = equality         &amp;</span>
<span class="gi">+        # equality       = relational       ==, !=</span>
<span class="gi">+        # relational     = shift            &lt;, &gt;, &lt;=, &gt;=, &lt;=&gt;</span>
<span class="gi">+        # shift          = additive         &lt;&lt;, &gt;&gt;</span>
<span class="gi">+        # additive       = multiplicative   +, -</span>
<span class="gi">+        # multiplicative = pm               *, /, %</span>
<span class="gi">+        # pm             = cast             .*, -&gt;*</span>
<span class="gi">+        def _parse_bin_op_expr(self: DefinitionParser,</span>
<span class="gi">+                               opId: int, inTemplate: bool) -&gt; ASTExpression:</span>
<span class="gi">+            if opId + 1 == len(_expression_bin_ops):</span>
<span class="gi">+                def parser(inTemplate: bool) -&gt; ASTExpression:</span>
<span class="gi">+                    return self._parse_cast_expression()</span>
<span class="gi">+            else:</span>
<span class="gi">+                def parser(inTemplate: bool) -&gt; ASTExpression:</span>
<span class="gi">+                    return _parse_bin_op_expr(self, opId + 1, inTemplate=inTemplate)</span>
<span class="gi">+            exprs = []</span>
<span class="gi">+            ops = []</span>
<span class="gi">+            exprs.append(parser(inTemplate=inTemplate))</span>
<span class="gi">+            while True:</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                if inTemplate and self.current_char == &#39;&gt;&#39;:</span>
<span class="gi">+                    break</span>
<span class="gi">+                pos = self.pos</span>
<span class="gi">+                oneMore = False</span>
<span class="gi">+                for op in _expression_bin_ops[opId]:</span>
<span class="gi">+                    if op[0] in &#39;abcnox&#39;:</span>
<span class="gi">+                        if not self.skip_word(op):</span>
<span class="gi">+                            continue</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        if not self.skip_string(op):</span>
<span class="gi">+                            continue</span>
<span class="gi">+                    if op == self.current_char == &#39;&amp;&#39;:</span>
<span class="gi">+                        # don&#39;t split the &amp;&amp; &#39;token&#39;</span>
<span class="gi">+                        self.pos -= 1</span>
<span class="gi">+                        # and btw. &amp;&amp; has lower precedence, so we are done</span>
<span class="gi">+                        break</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        expr = parser(inTemplate=inTemplate)</span>
<span class="gi">+                        exprs.append(expr)</span>
<span class="gi">+                        ops.append(op)</span>
<span class="gi">+                        oneMore = True</span>
<span class="gi">+                        break</span>
<span class="gi">+                    except DefinitionError:</span>
<span class="gi">+                        self.pos = pos</span>
<span class="gi">+                if not oneMore:</span>
<span class="gi">+                    break</span>
<span class="gi">+            return ASTBinOpExpr(exprs, ops)</span>
<span class="gi">+        return _parse_bin_op_expr(self, 0, inTemplate=inTemplate)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_conditional_expression_tail(self, orExprHead: ASTExpression,</span>
<span class="gi">+                                           inTemplate: bool) -&gt; ASTConditionalExpr | None:</span>
<span class="gi">+        # Consumes the orExprHead on success.</span>
<span class="gi">+</span>
<span class="gi">+        # -&gt; &quot;?&quot; expression &quot;:&quot; assignment-expression</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if not self.skip_string(&quot;?&quot;):</span>
<span class="gi">+            return None</span>
<span class="gi">+        thenExpr = self._parse_expression()</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if not self.skip_string(&quot;:&quot;):</span>
<span class="gi">+            self.fail(&#39;Expected &quot;:&quot; after then-expression in conditional expression.&#39;)</span>
<span class="gi">+        elseExpr = self._parse_assignment_expression(inTemplate)</span>
<span class="gi">+        return ASTConditionalExpr(orExprHead, thenExpr, elseExpr)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_assignment_expression(self, inTemplate: bool) -&gt; ASTExpression:</span>
<span class="gi">+        # -&gt; conditional-expression</span>
<span class="gi">+        #  | logical-or-expression assignment-operator initializer-clause</span>
<span class="gi">+        #  | yield-expression -&gt; &quot;co_yield&quot; assignment-expression</span>
<span class="gi">+        #                      | &quot;co_yield&quot; braced-init-list</span>
<span class="gi">+        #  | throw-expression -&gt; &quot;throw&quot; assignment-expression[opt]</span>
<span class="gi">+        # TODO: yield-expression</span>
<span class="gi">+        # TODO: throw-expression</span>
<span class="gi">+</span>
<span class="gi">+        # Now we have (after expanding conditional-expression:</span>
<span class="gi">+        #     logical-or-expression</span>
<span class="gi">+        #   | logical-or-expression &quot;?&quot; expression &quot;:&quot; assignment-expression</span>
<span class="gi">+        #   | logical-or-expression assignment-operator initializer-clause</span>
<span class="gi">+        leftExpr = self._parse_logical_or_expression(inTemplate=inTemplate)</span>
<span class="gi">+        # the ternary operator</span>
<span class="gi">+        condExpr = self._parse_conditional_expression_tail(leftExpr, inTemplate)</span>
<span class="gi">+        if condExpr is not None:</span>
<span class="gi">+            return condExpr</span>
<span class="gi">+        # and actual assignment</span>
<span class="gi">+        for op in _expression_assignment_ops:</span>
<span class="gi">+            if op[0] in &#39;anox&#39;:</span>
<span class="gi">+                if not self.skip_word(op):</span>
<span class="gi">+                    continue</span>
<span class="gi">+            else:</span>
<span class="gi">+                if not self.skip_string(op):</span>
<span class="gi">+                    continue</span>
<span class="gi">+            rightExpr = self._parse_initializer_clause()</span>
<span class="gi">+            return ASTAssignmentExpr(leftExpr, op, rightExpr)</span>
<span class="gi">+        # just a logical-or-expression</span>
<span class="gi">+        return leftExpr</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_constant_expression(self, inTemplate: bool) -&gt; ASTExpression:</span>
<span class="gi">+        # -&gt; conditional-expression -&gt;</span>
<span class="gi">+        #    logical-or-expression</span>
<span class="gi">+        #  | logical-or-expression &quot;?&quot; expression &quot;:&quot; assignment-expression</span>
<span class="gi">+        orExpr = self._parse_logical_or_expression(inTemplate=inTemplate)</span>
<span class="gi">+        condExpr = self._parse_conditional_expression_tail(orExpr, inTemplate)</span>
<span class="gi">+        if condExpr is not None:</span>
<span class="gi">+            return condExpr</span>
<span class="gi">+        return orExpr</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_expression(self) -&gt; ASTExpression:</span>
<span class="gi">+        # -&gt; assignment-expression</span>
<span class="gi">+        #  | expression &quot;,&quot; assignment-expression</span>
<span class="gi">+        exprs = [self._parse_assignment_expression(inTemplate=False)]</span>
<span class="gi">+        while True:</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if not self.skip_string(&#39;,&#39;):</span>
<span class="gi">+                break</span>
<span class="gi">+            exprs.append(self._parse_assignment_expression(inTemplate=False))</span>
<span class="gi">+        if len(exprs) == 1:</span>
<span class="gi">+            return exprs[0]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return ASTCommaExpr(exprs)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_expression_fallback(self, end: list[str],</span>
<span class="gi">+                                   parser: Callable[[], ASTExpression],</span>
<span class="gi">+                                   allow: bool = True) -&gt; ASTExpression:</span>
<span class="gi">+        # Stupidly &quot;parse&quot; an expression.</span>
<span class="gi">+        # &#39;end&#39; should be a list of characters which ends the expression.</span>
<span class="gi">+</span>
<span class="gi">+        # first try to use the provided parser</span>
<span class="gi">+        prevPos = self.pos</span>
<span class="gi">+        try:</span>
<span class="gi">+            return parser()</span>
<span class="gi">+        except DefinitionError as e:</span>
<span class="gi">+            # some places (e.g., template parameters) we really don&#39;t want to use fallback,</span>
<span class="gi">+            # and for testing we may want to globally disable it</span>
<span class="gi">+            if not allow or not self.allowFallbackExpressionParsing:</span>
<span class="gi">+                raise</span>
<span class="gi">+            self.warn(&quot;Parsing of expression failed. Using fallback parser.&quot;</span>
<span class="gi">+                      &quot; Error was:\n%s&quot; % e)</span>
<span class="gi">+            self.pos = prevPos</span>
<span class="gi">+        # and then the fallback scanning</span>
<span class="gi">+        assert end is not None</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        startPos = self.pos</span>
<span class="gi">+        if self.match(_string_re):</span>
<span class="gi">+            value = self.matched_text</span>
<span class="gi">+        else:</span>
<span class="gi">+            # TODO: add handling of more bracket-like things, and quote handling</span>
<span class="gi">+            brackets = {&#39;(&#39;: &#39;)&#39;, &#39;{&#39;: &#39;}&#39;, &#39;[&#39;: &#39;]&#39;, &#39;&lt;&#39;: &#39;&gt;&#39;}</span>
<span class="gi">+            symbols: list[str] = []</span>
<span class="gi">+            while not self.eof:</span>
<span class="gi">+                if (len(symbols) == 0 and self.current_char in end):</span>
<span class="gi">+                    break</span>
<span class="gi">+                if self.current_char in brackets:</span>
<span class="gi">+                    symbols.append(brackets[self.current_char])</span>
<span class="gi">+                elif len(symbols) &gt; 0 and self.current_char == symbols[-1]:</span>
<span class="gi">+                    symbols.pop()</span>
<span class="gi">+                self.pos += 1</span>
<span class="gi">+            if len(end) &gt; 0 and self.eof:</span>
<span class="gi">+                self.fail(&quot;Could not find end of expression starting at %d.&quot;</span>
<span class="gi">+                          % startPos)</span>
<span class="gi">+            value = self.definition[startPos:self.pos].strip()</span>
<span class="gi">+        return ASTFallbackExpr(value.strip())</span>
<span class="gi">+</span>
<span class="gi">+    # ==========================================================================</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_operator(self) -&gt; ASTOperator:</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        # adapted from the old code</span>
<span class="gi">+        # yay, a regular operator definition</span>
<span class="gi">+        if self.match(_operator_re):</span>
<span class="gi">+            return ASTOperatorBuildIn(self.matched_text)</span>
<span class="gi">+</span>
<span class="gi">+        # new/delete operator?</span>
<span class="gi">+        for op in &#39;new&#39;, &#39;delete&#39;:</span>
<span class="gi">+            if not self.skip_word(op):</span>
<span class="gi">+                continue</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if self.skip_string(&#39;[&#39;):</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                if not self.skip_string(&#39;]&#39;):</span>
<span class="gi">+                    self.fail(&#39;Expected &quot;]&quot; after  &quot;operator &#39; + op + &#39;[&quot;&#39;)</span>
<span class="gi">+                op += &#39;[]&#39;</span>
<span class="gi">+            return ASTOperatorBuildIn(op)</span>
<span class="gi">+</span>
<span class="gi">+        # user-defined literal?</span>
<span class="gi">+        if self.skip_string(&#39;&quot;&quot;&#39;):</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if not self.match(identifier_re):</span>
<span class="gi">+                self.fail(&quot;Expected user-defined literal suffix.&quot;)</span>
<span class="gi">+            identifier = ASTIdentifier(self.matched_text)</span>
<span class="gi">+            return ASTOperatorLiteral(identifier)</span>
<span class="gi">+</span>
<span class="gi">+        # oh well, looks like a cast operator definition.</span>
<span class="gi">+        # In that case, eat another type.</span>
<span class="gi">+        type = self._parse_type(named=False, outer=&quot;operatorCast&quot;)</span>
<span class="gi">+        return ASTOperatorType(type)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_template_argument_list(self) -&gt; ASTTemplateArgs:</span>
<span class="gi">+        # template-argument-list: (but we include the &lt; and &gt; here</span>
<span class="gi">+        #    template-argument ...[opt]</span>
<span class="gi">+        #    template-argument-list, template-argument ...[opt]</span>
<span class="gi">+        # template-argument:</span>
<span class="gi">+        #    constant-expression</span>
<span class="gi">+        #    type-id</span>
<span class="gi">+        #    id-expression</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if not self.skip_string_and_ws(&#39;&lt;&#39;):</span>
<span class="gi">+            return None</span>
<span class="gi">+        if self.skip_string(&#39;&gt;&#39;):</span>
<span class="gi">+            return ASTTemplateArgs([], False)</span>
<span class="gi">+        prevErrors = []</span>
<span class="gi">+        templateArgs: list[ASTType | ASTTemplateArgConstant] = []</span>
<span class="gi">+        packExpansion = False</span>
<span class="gi">+        while 1:</span>
<span class="gi">+            pos = self.pos</span>
<span class="gi">+            parsedComma = False</span>
<span class="gi">+            parsedEnd = False</span>
<span class="gi">+            try:</span>
<span class="gi">+                type = self._parse_type(named=False)</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                if self.skip_string_and_ws(&#39;...&#39;):</span>
<span class="gi">+                    packExpansion = True</span>
<span class="gi">+                    parsedEnd = True</span>
<span class="gi">+                    if not self.skip_string(&#39;&gt;&#39;):</span>
<span class="gi">+                        self.fail(&#39;Expected &quot;&gt;&quot; after &quot;...&quot; in template argument list.&#39;)</span>
<span class="gi">+                elif self.skip_string(&#39;&gt;&#39;):</span>
<span class="gi">+                    parsedEnd = True</span>
<span class="gi">+                elif self.skip_string(&#39;,&#39;):</span>
<span class="gi">+                    parsedComma = True</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.fail(&#39;Expected &quot;...&gt;&quot;, &quot;&gt;&quot; or &quot;,&quot; in template argument list.&#39;)</span>
<span class="gi">+                templateArgs.append(type)</span>
<span class="gi">+            except DefinitionError as e:</span>
<span class="gi">+                prevErrors.append((e, &quot;If type argument&quot;))</span>
<span class="gi">+                self.pos = pos</span>
<span class="gi">+                try:</span>
<span class="gi">+                    value = self._parse_constant_expression(inTemplate=True)</span>
<span class="gi">+                    self.skip_ws()</span>
<span class="gi">+                    if self.skip_string_and_ws(&#39;...&#39;):</span>
<span class="gi">+                        packExpansion = True</span>
<span class="gi">+                        parsedEnd = True</span>
<span class="gi">+                        if not self.skip_string(&#39;&gt;&#39;):</span>
<span class="gi">+                            self.fail(&#39;Expected &quot;&gt;&quot; after &quot;...&quot; in template argument list.&#39;)</span>
<span class="gi">+                    elif self.skip_string(&#39;&gt;&#39;):</span>
<span class="gi">+                        parsedEnd = True</span>
<span class="gi">+                    elif self.skip_string(&#39;,&#39;):</span>
<span class="gi">+                        parsedComma = True</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        self.fail(&#39;Expected &quot;...&gt;&quot;, &quot;&gt;&quot; or &quot;,&quot; in template argument list.&#39;)</span>
<span class="gi">+                    templateArgs.append(ASTTemplateArgConstant(value))</span>
<span class="gi">+                except DefinitionError as e:</span>
<span class="gi">+                    self.pos = pos</span>
<span class="gi">+                    prevErrors.append((e, &quot;If non-type argument&quot;))</span>
<span class="gi">+                    header = &quot;Error in parsing template argument list.&quot;</span>
<span class="gi">+                    raise self._make_multi_error(prevErrors, header) from e</span>
<span class="gi">+            if parsedEnd:</span>
<span class="gi">+                assert not parsedComma</span>
<span class="gi">+                break</span>
<span class="gi">+            assert not packExpansion</span>
<span class="gi">+        return ASTTemplateArgs(templateArgs, packExpansion)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_nested_name(self, memberPointer: bool = False) -&gt; ASTNestedName:</span>
<span class="gi">+        names: list[ASTNestedNameElement] = []</span>
<span class="gi">+        templates: list[bool] = []</span>
<span class="gi">+</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        rooted = False</span>
<span class="gi">+        if self.skip_string(&#39;::&#39;):</span>
<span class="gi">+            rooted = True</span>
<span class="gi">+        while 1:</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if len(names) &gt; 0:</span>
<span class="gi">+                template = self.skip_word_and_ws(&#39;template&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                template = False</span>
<span class="gi">+            templates.append(template)</span>
<span class="gi">+            identOrOp: ASTIdentifier | ASTOperator | None = None</span>
<span class="gi">+            if self.skip_word_and_ws(&#39;operator&#39;):</span>
<span class="gi">+                identOrOp = self._parse_operator()</span>
<span class="gi">+            else:</span>
<span class="gi">+                if not self.match(identifier_re):</span>
<span class="gi">+                    if memberPointer and len(names) &gt; 0:</span>
<span class="gi">+                        templates.pop()</span>
<span class="gi">+                        break</span>
<span class="gi">+                    self.fail(&quot;Expected identifier in nested name.&quot;)</span>
<span class="gi">+                identifier = self.matched_text</span>
<span class="gi">+                # make sure there isn&#39;t a keyword</span>
<span class="gi">+                if identifier in _keywords:</span>
<span class="gi">+                    self.fail(&quot;Expected identifier in nested name, &quot;</span>
<span class="gi">+                              &quot;got keyword: %s&quot; % identifier)</span>
<span class="gi">+                identOrOp = ASTIdentifier(identifier)</span>
<span class="gi">+            # try greedily to get template arguments,</span>
<span class="gi">+            # but otherwise a &lt; might be because we are in an expression</span>
<span class="gi">+            pos = self.pos</span>
<span class="gi">+            try:</span>
<span class="gi">+                templateArgs = self._parse_template_argument_list()</span>
<span class="gi">+            except DefinitionError as ex:</span>
<span class="gi">+                self.pos = pos</span>
<span class="gi">+                templateArgs = None</span>
<span class="gi">+                self.otherErrors.append(ex)</span>
<span class="gi">+            names.append(ASTNestedNameElement(identOrOp, templateArgs))</span>
<span class="gi">+</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if not self.skip_string(&#39;::&#39;):</span>
<span class="gi">+                if memberPointer:</span>
<span class="gi">+                    self.fail(&quot;Expected &#39;::&#39; in pointer to member (function).&quot;)</span>
<span class="gi">+                break</span>
<span class="gi">+        return ASTNestedName(names, templates, rooted)</span>
<span class="gi">+</span>
<span class="gi">+    # ==========================================================================</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_simple_type_specifiers(self) -&gt; ASTTrailingTypeSpecFundamental:</span>
<span class="gi">+        modifier: str | None = None</span>
<span class="gi">+        signedness: str | None = None</span>
<span class="gi">+        width: list[str] = []</span>
<span class="gi">+        typ: str | None = None</span>
<span class="gi">+        names: list[str] = []  # the parsed sequence</span>
<span class="gi">+</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        while self.match(_simple_type_specifiers_re):</span>
<span class="gi">+            t = self.matched_text</span>
<span class="gi">+            names.append(t)</span>
<span class="gi">+            if t in (&#39;auto&#39;, &#39;void&#39;, &#39;bool&#39;,</span>
<span class="gi">+                     &#39;char&#39;, &#39;wchar_t&#39;, &#39;char8_t&#39;, &#39;char16_t&#39;, &#39;char32_t&#39;,</span>
<span class="gi">+                     &#39;int&#39;, &#39;__int64&#39;, &#39;__int128&#39;,</span>
<span class="gi">+                     &#39;float&#39;, &#39;double&#39;,</span>
<span class="gi">+                     &#39;__float80&#39;, &#39;_Float64x&#39;, &#39;__float128&#39;, &#39;_Float128&#39;):</span>
<span class="gi">+                if typ is not None:</span>
<span class="gi">+                    self.fail(f&quot;Can not have both {t} and {typ}.&quot;)</span>
<span class="gi">+                typ = t</span>
<span class="gi">+            elif t in (&#39;signed&#39;, &#39;unsigned&#39;):</span>
<span class="gi">+                if signedness is not None:</span>
<span class="gi">+                    self.fail(f&quot;Can not have both {t} and {signedness}.&quot;)</span>
<span class="gi">+                signedness = t</span>
<span class="gi">+            elif t == &#39;short&#39;:</span>
<span class="gi">+                if len(width) != 0:</span>
<span class="gi">+                    self.fail(f&quot;Can not have both {t} and {width[0]}.&quot;)</span>
<span class="gi">+                width.append(t)</span>
<span class="gi">+            elif t == &#39;long&#39;:</span>
<span class="gi">+                if len(width) != 0 and width[0] != &#39;long&#39;:</span>
<span class="gi">+                    self.fail(f&quot;Can not have both {t} and {width[0]}.&quot;)</span>
<span class="gi">+                width.append(t)</span>
<span class="gi">+            elif t in (&#39;_Imaginary&#39;, &#39;_Complex&#39;):</span>
<span class="gi">+                if modifier is not None:</span>
<span class="gi">+                    self.fail(f&quot;Can not have both {t} and {modifier}.&quot;)</span>
<span class="gi">+                modifier = t</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+        if len(names) == 0:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        if typ in (&#39;auto&#39;, &#39;void&#39;, &#39;bool&#39;,</span>
<span class="gi">+                   &#39;wchar_t&#39;, &#39;char8_t&#39;, &#39;char16_t&#39;, &#39;char32_t&#39;,</span>
<span class="gi">+                   &#39;__float80&#39;, &#39;_Float64x&#39;, &#39;__float128&#39;, &#39;_Float128&#39;):</span>
<span class="gi">+            if modifier is not None:</span>
<span class="gi">+                self.fail(f&quot;Can not have both {typ} and {modifier}.&quot;)</span>
<span class="gi">+            if signedness is not None:</span>
<span class="gi">+                self.fail(f&quot;Can not have both {typ} and {signedness}.&quot;)</span>
<span class="gi">+            if len(width) != 0:</span>
<span class="gi">+                self.fail(f&quot;Can not have both {typ} and {&#39; &#39;.join(width)}.&quot;)</span>
<span class="gi">+        elif typ == &#39;char&#39;:</span>
<span class="gi">+            if modifier is not None:</span>
<span class="gi">+                self.fail(f&quot;Can not have both {typ} and {modifier}.&quot;)</span>
<span class="gi">+            if len(width) != 0:</span>
<span class="gi">+                self.fail(f&quot;Can not have both {typ} and {&#39; &#39;.join(width)}.&quot;)</span>
<span class="gi">+        elif typ == &#39;int&#39;:</span>
<span class="gi">+            if modifier is not None:</span>
<span class="gi">+                self.fail(f&quot;Can not have both {typ} and {modifier}.&quot;)</span>
<span class="gi">+        elif typ in (&#39;__int64&#39;, &#39;__int128&#39;):</span>
<span class="gi">+            if modifier is not None:</span>
<span class="gi">+                self.fail(f&quot;Can not have both {typ} and {modifier}.&quot;)</span>
<span class="gi">+            if len(width) != 0:</span>
<span class="gi">+                self.fail(f&quot;Can not have both {typ} and {&#39; &#39;.join(width)}.&quot;)</span>
<span class="gi">+        elif typ == &#39;float&#39;:</span>
<span class="gi">+            if signedness is not None:</span>
<span class="gi">+                self.fail(f&quot;Can not have both {typ} and {signedness}.&quot;)</span>
<span class="gi">+            if len(width) != 0:</span>
<span class="gi">+                self.fail(f&quot;Can not have both {typ} and {&#39; &#39;.join(width)}.&quot;)</span>
<span class="gi">+        elif typ == &#39;double&#39;:</span>
<span class="gi">+            if signedness is not None:</span>
<span class="gi">+                self.fail(f&quot;Can not have both {typ} and {signedness}.&quot;)</span>
<span class="gi">+            if len(width) &gt; 1:</span>
<span class="gi">+                self.fail(f&quot;Can not have both {typ} and {&#39; &#39;.join(width)}.&quot;)</span>
<span class="gi">+            if len(width) == 1 and width[0] != &#39;long&#39;:</span>
<span class="gi">+                self.fail(f&quot;Can not have both {typ} and {&#39; &#39;.join(width)}.&quot;)</span>
<span class="gi">+        elif typ is None:</span>
<span class="gi">+            if modifier is not None:</span>
<span class="gi">+                self.fail(f&quot;Can not have {modifier} without a floating point type.&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            msg = f&#39;Unhandled type {typ}&#39;</span>
<span class="gi">+            raise AssertionError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        canonNames: list[str] = []</span>
<span class="gi">+        if modifier is not None:</span>
<span class="gi">+            canonNames.append(modifier)</span>
<span class="gi">+        if signedness is not None:</span>
<span class="gi">+            canonNames.append(signedness)</span>
<span class="gi">+        canonNames.extend(width)</span>
<span class="gi">+        if typ is not None:</span>
<span class="gi">+            canonNames.append(typ)</span>
<span class="gi">+        return ASTTrailingTypeSpecFundamental(names, canonNames)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_trailing_type_spec(self) -&gt; ASTTrailingTypeSpec:</span>
<span class="gi">+        # fundamental types, https://en.cppreference.com/w/cpp/language/type</span>
<span class="gi">+        # and extensions</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        res = self._parse_simple_type_specifiers()</span>
<span class="gi">+        if res is not None:</span>
<span class="gi">+            return res</span>
<span class="gi">+</span>
<span class="gi">+        # decltype</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if self.skip_word_and_ws(&#39;decltype&#39;):</span>
<span class="gi">+            if not self.skip_string_and_ws(&#39;(&#39;):</span>
<span class="gi">+                self.fail(&quot;Expected &#39;(&#39; after &#39;decltype&#39;.&quot;)</span>
<span class="gi">+            if self.skip_word_and_ws(&#39;auto&#39;):</span>
<span class="gi">+                if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+                    self.fail(&quot;Expected &#39;)&#39; after &#39;decltype(auto&#39;.&quot;)</span>
<span class="gi">+                return ASTTrailingTypeSpecDecltypeAuto()</span>
<span class="gi">+            expr = self._parse_expression()</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+                self.fail(&quot;Expected &#39;)&#39; after &#39;decltype(&lt;expr&gt;&#39;.&quot;)</span>
<span class="gi">+            return ASTTrailingTypeSpecDecltype(expr)</span>
<span class="gi">+</span>
<span class="gi">+        # prefixed</span>
<span class="gi">+        prefix = None</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        for k in (&#39;class&#39;, &#39;struct&#39;, &#39;enum&#39;, &#39;union&#39;, &#39;typename&#39;):</span>
<span class="gi">+            if self.skip_word_and_ws(k):</span>
<span class="gi">+                prefix = k</span>
<span class="gi">+                break</span>
<span class="gi">+        nestedName = self._parse_nested_name()</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        placeholderType = None</span>
<span class="gi">+        if self.skip_word(&#39;auto&#39;):</span>
<span class="gi">+            placeholderType = &#39;auto&#39;</span>
<span class="gi">+        elif self.skip_word_and_ws(&#39;decltype&#39;):</span>
<span class="gi">+            if not self.skip_string_and_ws(&#39;(&#39;):</span>
<span class="gi">+                self.fail(&quot;Expected &#39;(&#39; after &#39;decltype&#39; in placeholder type specifier.&quot;)</span>
<span class="gi">+            if not self.skip_word_and_ws(&#39;auto&#39;):</span>
<span class="gi">+                self.fail(&quot;Expected &#39;auto&#39; after &#39;decltype(&#39; in placeholder type specifier.&quot;)</span>
<span class="gi">+            if not self.skip_string_and_ws(&#39;)&#39;):</span>
<span class="gi">+                self.fail(&quot;Expected &#39;)&#39; after &#39;decltype(auto&#39; in placeholder type specifier.&quot;)</span>
<span class="gi">+            placeholderType = &#39;decltype(auto)&#39;</span>
<span class="gi">+        return ASTTrailingTypeSpecName(prefix, nestedName, placeholderType)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_parameters_and_qualifiers(</span>
<span class="gi">+        self, paramMode: str,</span>
<span class="gi">+    ) -&gt; ASTParametersQualifiers | None:</span>
<span class="gi">+        if paramMode == &#39;new&#39;:</span>
<span class="gi">+            return None</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if not self.skip_string(&#39;(&#39;):</span>
<span class="gi">+            if paramMode == &#39;function&#39;:</span>
<span class="gi">+                self.fail(&#39;Expecting &quot;(&quot; in parameters-and-qualifiers.&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return None</span>
<span class="gi">+        args = []</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+            while 1:</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                if self.skip_string(&#39;...&#39;):</span>
<span class="gi">+                    args.append(ASTFunctionParameter(None, True))</span>
<span class="gi">+                    self.skip_ws()</span>
<span class="gi">+                    if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+                        self.fail(&#39;Expected &quot;)&quot; after &quot;...&quot; in &#39;</span>
<span class="gi">+                                  &#39;parameters-and-qualifiers.&#39;)</span>
<span class="gi">+                    break</span>
<span class="gi">+                # note: it seems that function arguments can always be named,</span>
<span class="gi">+                # even in function pointers and similar.</span>
<span class="gi">+                arg = self._parse_type_with_init(outer=None, named=&#39;single&#39;)</span>
<span class="gi">+                # TODO: parse default parameters # TODO: didn&#39;t we just do that?</span>
<span class="gi">+                args.append(ASTFunctionParameter(arg))</span>

<span class="gd">-    def _parse_decl_specs_simple(self, outer: str, typed: bool</span>
<span class="gd">-        ) -&gt;ASTDeclSpecsSimple:</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                if self.skip_string(&#39;,&#39;):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if self.skip_string(&#39;)&#39;):</span>
<span class="gi">+                    break</span>
<span class="gi">+                self.fail(&#39;Expecting &quot;,&quot; or &quot;)&quot; in parameters-and-qualifiers, &#39;</span>
<span class="gi">+                          f&#39;got &quot;{self.current_char}&quot;.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        const = self.skip_word_and_ws(&#39;const&#39;)</span>
<span class="gi">+        volatile = self.skip_word_and_ws(&#39;volatile&#39;)</span>
<span class="gi">+        if not const:  # the can be permuted</span>
<span class="gi">+            const = self.skip_word_and_ws(&#39;const&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        refQual = None</span>
<span class="gi">+        if self.skip_string(&#39;&amp;&amp;&#39;):</span>
<span class="gi">+            refQual = &#39;&amp;&amp;&#39;</span>
<span class="gi">+        if not refQual and self.skip_string(&#39;&amp;&#39;):</span>
<span class="gi">+            refQual = &#39;&amp;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        exceptionSpec = None</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if self.skip_string(&#39;noexcept&#39;):</span>
<span class="gi">+            if self.skip_string_and_ws(&#39;(&#39;):</span>
<span class="gi">+                expr = self._parse_constant_expression(False)</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+                    self.fail(&quot;Expecting &#39;)&#39; to end &#39;noexcept&#39;.&quot;)</span>
<span class="gi">+                exceptionSpec = ASTNoexceptSpec(expr)</span>
<span class="gi">+            else:</span>
<span class="gi">+                exceptionSpec = ASTNoexceptSpec(None)</span>
<span class="gi">+</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if self.skip_string(&#39;-&gt;&#39;):</span>
<span class="gi">+            trailingReturn = self._parse_type(named=False)</span>
<span class="gi">+        else:</span>
<span class="gi">+            trailingReturn = None</span>
<span class="gi">+</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        override = self.skip_word_and_ws(&#39;override&#39;)</span>
<span class="gi">+        final = self.skip_word_and_ws(&#39;final&#39;)</span>
<span class="gi">+        if not override:</span>
<span class="gi">+            override = self.skip_word_and_ws(</span>
<span class="gi">+                &#39;override&#39;)  # they can be permuted</span>
<span class="gi">+</span>
<span class="gi">+        attrs = self._parse_attribute_list()</span>
<span class="gi">+</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        initializer = None</span>
<span class="gi">+        # if this is a function pointer we should not swallow an initializer</span>
<span class="gi">+        if paramMode == &#39;function&#39; and self.skip_string(&#39;=&#39;):</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            valid = (&#39;0&#39;, &#39;delete&#39;, &#39;default&#39;)</span>
<span class="gi">+            for w in valid:</span>
<span class="gi">+                if self.skip_word_and_ws(w):</span>
<span class="gi">+                    initializer = w</span>
<span class="gi">+                    break</span>
<span class="gi">+            if not initializer:</span>
<span class="gi">+                self.fail(</span>
<span class="gi">+                    &#39;Expected &quot;%s&quot; in initializer-specifier.&#39;</span>
<span class="gi">+                    % &#39;&quot; or &quot;&#39;.join(valid))</span>
<span class="gi">+</span>
<span class="gi">+        return ASTParametersQualifiers(</span>
<span class="gi">+            args, volatile, const, refQual, exceptionSpec, trailingReturn,</span>
<span class="gi">+            override, final, attrs, initializer)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_decl_specs_simple(self, outer: str, typed: bool) -&gt; ASTDeclSpecsSimple:</span>
<span class="w"> </span>        &quot;&quot;&quot;Just parse the simple ones.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        storage = None</span>
<span class="gi">+        threadLocal = None</span>
<span class="gi">+        inline = None</span>
<span class="gi">+        virtual = None</span>
<span class="gi">+        explicitSpec = None</span>
<span class="gi">+        consteval = None</span>
<span class="gi">+        constexpr = None</span>
<span class="gi">+        constinit = None</span>
<span class="gi">+        volatile = None</span>
<span class="gi">+        const = None</span>
<span class="gi">+        friend = None</span>
<span class="gi">+        attrs = []</span>
<span class="gi">+        while 1:  # accept any permutation of a subset of some decl-specs</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if not const and typed:</span>
<span class="gi">+                const = self.skip_word(&#39;const&#39;)</span>
<span class="gi">+                if const:</span>
<span class="gi">+                    continue</span>
<span class="gi">+            if not volatile and typed:</span>
<span class="gi">+                volatile = self.skip_word(&#39;volatile&#39;)</span>
<span class="gi">+                if volatile:</span>
<span class="gi">+                    continue</span>
<span class="gi">+            if not storage:</span>
<span class="gi">+                if outer in (&#39;member&#39;, &#39;function&#39;):</span>
<span class="gi">+                    if self.skip_word(&#39;static&#39;):</span>
<span class="gi">+                        storage = &#39;static&#39;</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    if self.skip_word(&#39;extern&#39;):</span>
<span class="gi">+                        storage = &#39;extern&#39;</span>
<span class="gi">+                        continue</span>
<span class="gi">+                if outer == &#39;member&#39;:</span>
<span class="gi">+                    if self.skip_word(&#39;mutable&#39;):</span>
<span class="gi">+                        storage = &#39;mutable&#39;</span>
<span class="gi">+                        continue</span>
<span class="gi">+                if self.skip_word(&#39;register&#39;):</span>
<span class="gi">+                    storage = &#39;register&#39;</span>
<span class="gi">+                    continue</span>
<span class="gi">+            if not inline and outer in (&#39;function&#39;, &#39;member&#39;):</span>
<span class="gi">+                inline = self.skip_word(&#39;inline&#39;)</span>
<span class="gi">+                if inline:</span>
<span class="gi">+                    continue</span>
<span class="gi">+            if not constexpr and outer in (&#39;member&#39;, &#39;function&#39;):</span>
<span class="gi">+                constexpr = self.skip_word(&quot;constexpr&quot;)</span>
<span class="gi">+                if constexpr:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+            if outer == &#39;member&#39;:</span>
<span class="gi">+                if not constinit:</span>
<span class="gi">+                    constinit = self.skip_word(&#39;constinit&#39;)</span>
<span class="gi">+                    if constinit:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                if not threadLocal:</span>
<span class="gi">+                    threadLocal = self.skip_word(&#39;thread_local&#39;)</span>
<span class="gi">+                    if threadLocal:</span>
<span class="gi">+                        continue</span>
<span class="gi">+            if outer == &#39;function&#39;:</span>
<span class="gi">+                if not consteval:</span>
<span class="gi">+                    consteval = self.skip_word(&#39;consteval&#39;)</span>
<span class="gi">+                    if consteval:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                if not friend:</span>
<span class="gi">+                    friend = self.skip_word(&#39;friend&#39;)</span>
<span class="gi">+                    if friend:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                if not virtual:</span>
<span class="gi">+                    virtual = self.skip_word(&#39;virtual&#39;)</span>
<span class="gi">+                    if virtual:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                if not explicitSpec:</span>
<span class="gi">+                    explicit = self.skip_word_and_ws(&#39;explicit&#39;)</span>
<span class="gi">+                    if explicit:</span>
<span class="gi">+                        expr: ASTExpression = None</span>
<span class="gi">+                        if self.skip_string(&#39;(&#39;):</span>
<span class="gi">+                            expr = self._parse_constant_expression(inTemplate=False)</span>
<span class="gi">+                            if not expr:</span>
<span class="gi">+                                self.fail(&quot;Expected constant expression after &#39;(&#39;&quot;</span>
<span class="gi">+                                          &quot; in explicit specifier.&quot;)</span>
<span class="gi">+                            self.skip_ws()</span>
<span class="gi">+                            if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+                                self.fail(&quot;Expected &#39;)&#39; to end explicit specifier.&quot;)</span>
<span class="gi">+                        explicitSpec = ASTExplicitSpec(expr)</span>
<span class="gi">+                        continue</span>
<span class="gi">+            attr = self._parse_attribute()</span>
<span class="gi">+            if attr:</span>
<span class="gi">+                attrs.append(attr)</span>
<span class="gi">+                continue</span>
<span class="gi">+            break</span>
<span class="gi">+        return ASTDeclSpecsSimple(storage, threadLocal, inline, virtual,</span>
<span class="gi">+                                  explicitSpec, consteval, constexpr, constinit,</span>
<span class="gi">+                                  volatile, const, friend, ASTAttributeList(attrs))</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_decl_specs(self, outer: str, typed: bool = True) -&gt; ASTDeclSpecs:</span>
<span class="gi">+        if outer:</span>
<span class="gi">+            if outer not in (&#39;type&#39;, &#39;member&#39;, &#39;function&#39;, &#39;templateParam&#39;):</span>
<span class="gi">+                raise Exception(&#39;Internal error, unknown outer &quot;%s&quot;.&#39; % outer)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        storage-class-specifier function-specifier &quot;constexpr&quot;</span>
<span class="gi">+        &quot;volatile&quot; &quot;const&quot; trailing-type-specifier</span>
<span class="gi">+</span>
<span class="gi">+        storage-class-specifier -&gt;</span>
<span class="gi">+              &quot;static&quot; (only for member_object and function_object)</span>
<span class="gi">+            | &quot;register&quot;</span>
<span class="gi">+</span>
<span class="gi">+        function-specifier -&gt; &quot;inline&quot; | &quot;virtual&quot; | &quot;explicit&quot; (only for</span>
<span class="gi">+        function_object)</span>

<span class="gd">-    def _parse_type(self, named: (bool | str), outer: (str | None)=None</span>
<span class="gd">-        ) -&gt;ASTType:</span>
<span class="gi">+        &quot;constexpr&quot; (only for member_object and function_object)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        leftSpecs = self._parse_decl_specs_simple(outer, typed)</span>
<span class="gi">+        rightSpecs = None</span>
<span class="gi">+</span>
<span class="gi">+        if typed:</span>
<span class="gi">+            trailing = self._parse_trailing_type_spec()</span>
<span class="gi">+            rightSpecs = self._parse_decl_specs_simple(outer, typed)</span>
<span class="gi">+        else:</span>
<span class="gi">+            trailing = None</span>
<span class="gi">+        return ASTDeclSpecs(outer, leftSpecs, rightSpecs, trailing)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_declarator_name_suffix(</span>
<span class="gi">+        self, named: bool | str, paramMode: str, typed: bool,</span>
<span class="gi">+    ) -&gt; ASTDeclaratorNameParamQual | ASTDeclaratorNameBitField:</span>
<span class="gi">+        # now we should parse the name, and then suffixes</span>
<span class="gi">+        if named == &#39;maybe&#39;:</span>
<span class="gi">+            pos = self.pos</span>
<span class="gi">+            try:</span>
<span class="gi">+                declId = self._parse_nested_name()</span>
<span class="gi">+            except DefinitionError:</span>
<span class="gi">+                self.pos = pos</span>
<span class="gi">+                declId = None</span>
<span class="gi">+        elif named == &#39;single&#39;:</span>
<span class="gi">+            if self.match(identifier_re):</span>
<span class="gi">+                identifier = ASTIdentifier(self.matched_text)</span>
<span class="gi">+                nne = ASTNestedNameElement(identifier, None)</span>
<span class="gi">+                declId = ASTNestedName([nne], [False], rooted=False)</span>
<span class="gi">+                # if it&#39;s a member pointer, we may have &#39;::&#39;, which should be an error</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                if self.current_char == &#39;:&#39;:</span>
<span class="gi">+                    self.fail(&quot;Unexpected &#39;:&#39; after identifier.&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                declId = None</span>
<span class="gi">+        elif named:</span>
<span class="gi">+            declId = self._parse_nested_name()</span>
<span class="gi">+        else:</span>
<span class="gi">+            declId = None</span>
<span class="gi">+        arrayOps = []</span>
<span class="gi">+        while 1:</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if typed and self.skip_string(&#39;[&#39;):</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                if self.skip_string(&#39;]&#39;):</span>
<span class="gi">+                    arrayOps.append(ASTArray(None))</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                def parser() -&gt; ASTExpression:</span>
<span class="gi">+                    return self._parse_expression()</span>
<span class="gi">+                value = self._parse_expression_fallback([&#39;]&#39;], parser)</span>
<span class="gi">+                if not self.skip_string(&#39;]&#39;):</span>
<span class="gi">+                    self.fail(&quot;Expected &#39;]&#39; in end of array operator.&quot;)</span>
<span class="gi">+                arrayOps.append(ASTArray(value))</span>
<span class="gi">+                continue</span>
<span class="gi">+            break</span>
<span class="gi">+        paramQual = self._parse_parameters_and_qualifiers(paramMode)</span>
<span class="gi">+        if paramQual is None and len(arrayOps) == 0:</span>
<span class="gi">+            # perhaps a bit-field</span>
<span class="gi">+            if named and paramMode == &#39;type&#39; and typed:</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                if self.skip_string(&#39;:&#39;):</span>
<span class="gi">+                    size = self._parse_constant_expression(inTemplate=False)</span>
<span class="gi">+                    return ASTDeclaratorNameBitField(declId=declId, size=size)</span>
<span class="gi">+        return ASTDeclaratorNameParamQual(declId=declId, arrayOps=arrayOps,</span>
<span class="gi">+                                          paramQual=paramQual)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_declarator(self, named: bool | str, paramMode: str,</span>
<span class="gi">+                          typed: bool = True,</span>
<span class="gi">+                          ) -&gt; ASTDeclarator:</span>
<span class="gi">+        # &#39;typed&#39; here means &#39;parse return type stuff&#39;</span>
<span class="gi">+        if paramMode not in (&#39;type&#39;, &#39;function&#39;, &#39;operatorCast&#39;, &#39;new&#39;):</span>
<span class="gi">+            raise Exception(</span>
<span class="gi">+                &quot;Internal error, unknown paramMode &#39;%s&#39;.&quot; % paramMode)</span>
<span class="gi">+        prevErrors = []</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if typed and self.skip_string(&#39;*&#39;):</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            volatile = False</span>
<span class="gi">+            const = False</span>
<span class="gi">+            attrList = []</span>
<span class="gi">+            while 1:</span>
<span class="gi">+                if not volatile:</span>
<span class="gi">+                    volatile = self.skip_word_and_ws(&#39;volatile&#39;)</span>
<span class="gi">+                    if volatile:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                if not const:</span>
<span class="gi">+                    const = self.skip_word_and_ws(&#39;const&#39;)</span>
<span class="gi">+                    if const:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                attr = self._parse_attribute()</span>
<span class="gi">+                if attr is not None:</span>
<span class="gi">+                    attrList.append(attr)</span>
<span class="gi">+                    continue</span>
<span class="gi">+                break</span>
<span class="gi">+            next = self._parse_declarator(named, paramMode, typed)</span>
<span class="gi">+            return ASTDeclaratorPtr(next=next, volatile=volatile, const=const,</span>
<span class="gi">+                                    attrs=ASTAttributeList(attrList))</span>
<span class="gi">+        # TODO: shouldn&#39;t we parse an R-value ref here first?</span>
<span class="gi">+        if typed and self.skip_string(&quot;&amp;&quot;):</span>
<span class="gi">+            attrs = self._parse_attribute_list()</span>
<span class="gi">+            next = self._parse_declarator(named, paramMode, typed)</span>
<span class="gi">+            return ASTDeclaratorRef(next=next, attrs=attrs)</span>
<span class="gi">+        if typed and self.skip_string(&quot;...&quot;):</span>
<span class="gi">+            next = self._parse_declarator(named, paramMode, False)</span>
<span class="gi">+            return ASTDeclaratorParamPack(next=next)</span>
<span class="gi">+        if typed and self.current_char == &#39;(&#39;:  # note: peeking, not skipping</span>
<span class="gi">+            if paramMode == &quot;operatorCast&quot;:</span>
<span class="gi">+                # TODO: we should be able to parse cast operators which return</span>
<span class="gi">+                # function pointers. For now, just hax it and ignore.</span>
<span class="gi">+                return ASTDeclaratorNameParamQual(declId=None, arrayOps=[],</span>
<span class="gi">+                                                  paramQual=None)</span>
<span class="gi">+            # maybe this is the beginning of params and quals,try that first,</span>
<span class="gi">+            # otherwise assume it&#39;s noptr-&gt;declarator &gt; ( ptr-declarator )</span>
<span class="gi">+            pos = self.pos</span>
<span class="gi">+            try:</span>
<span class="gi">+                # assume this is params and quals</span>
<span class="gi">+                res = self._parse_declarator_name_suffix(named, paramMode,</span>
<span class="gi">+                                                         typed)</span>
<span class="gi">+                return res</span>
<span class="gi">+            except DefinitionError as exParamQual:</span>
<span class="gi">+                prevErrors.append((exParamQual,</span>
<span class="gi">+                                   &quot;If declarator-id with parameters-and-qualifiers&quot;))</span>
<span class="gi">+                self.pos = pos</span>
<span class="gi">+                try:</span>
<span class="gi">+                    assert self.current_char == &#39;(&#39;</span>
<span class="gi">+                    self.skip_string(&#39;(&#39;)</span>
<span class="gi">+                    # TODO: hmm, if there is a name, it must be in inner, right?</span>
<span class="gi">+                    # TODO: hmm, if there must be parameters, they must be</span>
<span class="gi">+                    #       inside, right?</span>
<span class="gi">+                    inner = self._parse_declarator(named, paramMode, typed)</span>
<span class="gi">+                    if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+                        self.fail(&quot;Expected &#39;)&#39; in \&quot;( ptr-declarator )\&quot;&quot;)</span>
<span class="gi">+                    next = self._parse_declarator(named=False,</span>
<span class="gi">+                                                  paramMode=&quot;type&quot;,</span>
<span class="gi">+                                                  typed=typed)</span>
<span class="gi">+                    return ASTDeclaratorParen(inner=inner, next=next)</span>
<span class="gi">+                except DefinitionError as exNoPtrParen:</span>
<span class="gi">+                    self.pos = pos</span>
<span class="gi">+                    prevErrors.append((exNoPtrParen, &quot;If parenthesis in noptr-declarator&quot;))</span>
<span class="gi">+                    header = &quot;Error in declarator&quot;</span>
<span class="gi">+                    raise self._make_multi_error(prevErrors, header) from exNoPtrParen</span>
<span class="gi">+        if typed:  # pointer to member</span>
<span class="gi">+            pos = self.pos</span>
<span class="gi">+            try:</span>
<span class="gi">+                name = self._parse_nested_name(memberPointer=True)</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                if not self.skip_string(&#39;*&#39;):</span>
<span class="gi">+                    self.fail(&quot;Expected &#39;*&#39; in pointer to member declarator.&quot;)</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+            except DefinitionError as e:</span>
<span class="gi">+                self.pos = pos</span>
<span class="gi">+                prevErrors.append((e, &quot;If pointer to member declarator&quot;))</span>
<span class="gi">+            else:</span>
<span class="gi">+                volatile = False</span>
<span class="gi">+                const = False</span>
<span class="gi">+                while 1:</span>
<span class="gi">+                    if not volatile:</span>
<span class="gi">+                        volatile = self.skip_word_and_ws(&#39;volatile&#39;)</span>
<span class="gi">+                        if volatile:</span>
<span class="gi">+                            continue</span>
<span class="gi">+                    if not const:</span>
<span class="gi">+                        const = self.skip_word_and_ws(&#39;const&#39;)</span>
<span class="gi">+                        if const:</span>
<span class="gi">+                            continue</span>
<span class="gi">+                    break</span>
<span class="gi">+                next = self._parse_declarator(named, paramMode, typed)</span>
<span class="gi">+                return ASTDeclaratorMemPtr(name, const, volatile, next=next)</span>
<span class="gi">+        pos = self.pos</span>
<span class="gi">+        try:</span>
<span class="gi">+            res = self._parse_declarator_name_suffix(named, paramMode, typed)</span>
<span class="gi">+            # this is a heuristic for error messages, for when there is a &lt; after a</span>
<span class="gi">+            # nested name, but it was not a successful template argument list</span>
<span class="gi">+            if self.current_char == &#39;&lt;&#39;:</span>
<span class="gi">+                self.otherErrors.append(self._make_multi_error(prevErrors, &quot;&quot;))</span>
<span class="gi">+            return res</span>
<span class="gi">+        except DefinitionError as e:</span>
<span class="gi">+            self.pos = pos</span>
<span class="gi">+            prevErrors.append((e, &quot;If declarator-id&quot;))</span>
<span class="gi">+            header = &quot;Error in declarator or parameters-and-qualifiers&quot;</span>
<span class="gi">+            raise self._make_multi_error(prevErrors, header) from e</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_initializer(self, outer: str | None = None, allowFallback: bool = True,</span>
<span class="gi">+                           ) -&gt; ASTInitializer | None:</span>
<span class="gi">+        # initializer                           # global vars</span>
<span class="gi">+        # -&gt; brace-or-equal-initializer</span>
<span class="gi">+        #  | &#39;(&#39; expression-list &#39;)&#39;</span>
<span class="gi">+        #</span>
<span class="gi">+        # brace-or-equal-initializer            # member vars</span>
<span class="gi">+        # -&gt; &#39;=&#39; initializer-clause</span>
<span class="gi">+        #  | braced-init-list</span>
<span class="gi">+        #</span>
<span class="gi">+        # initializer-clause  # function params, non-type template params (with &#39;=&#39; in front)</span>
<span class="gi">+        # -&gt; assignment-expression</span>
<span class="gi">+        #  | braced-init-list</span>
<span class="gi">+        #</span>
<span class="gi">+        # we don&#39;t distinguish between global and member vars, so disallow paren:</span>
<span class="gi">+        #</span>
<span class="gi">+        # -&gt; braced-init-list             # var only</span>
<span class="gi">+        #  | &#39;=&#39; assignment-expression</span>
<span class="gi">+        #  | &#39;=&#39; braced-init-list</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if outer == &#39;member&#39;:</span>
<span class="gi">+            bracedInit = self._parse_braced_init_list()</span>
<span class="gi">+            if bracedInit is not None:</span>
<span class="gi">+                return ASTInitializer(bracedInit, hasAssign=False)</span>
<span class="gi">+</span>
<span class="gi">+        if not self.skip_string(&#39;=&#39;):</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        bracedInit = self._parse_braced_init_list()</span>
<span class="gi">+        if bracedInit is not None:</span>
<span class="gi">+            return ASTInitializer(bracedInit)</span>
<span class="gi">+</span>
<span class="gi">+        if outer == &#39;member&#39;:</span>
<span class="gi">+            fallbackEnd: list[str] = []</span>
<span class="gi">+        elif outer == &#39;templateParam&#39;:</span>
<span class="gi">+            fallbackEnd = [&#39;,&#39;, &#39;&gt;&#39;]</span>
<span class="gi">+        elif outer is None:  # function parameter</span>
<span class="gi">+            fallbackEnd = [&#39;,&#39;, &#39;)&#39;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.fail(&quot;Internal error, initializer for outer &#39;%s&#39; not &quot;</span>
<span class="gi">+                      &quot;implemented.&quot; % outer)</span>
<span class="gi">+</span>
<span class="gi">+        inTemplate = outer == &#39;templateParam&#39;</span>
<span class="gi">+</span>
<span class="gi">+        def parser() -&gt; ASTExpression:</span>
<span class="gi">+            return self._parse_assignment_expression(inTemplate=inTemplate)</span>
<span class="gi">+        value = self._parse_expression_fallback(fallbackEnd, parser, allow=allowFallback)</span>
<span class="gi">+        return ASTInitializer(value)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_type(self, named: bool | str, outer: str | None = None) -&gt; ASTType:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        named=False|&#39;maybe&#39;|True: &#39;maybe&#39; is e.g., for function objects which
<span class="w"> </span>        doesn&#39;t need to name the arguments

<span class="w"> </span>        outer == operatorCast: annoying case, we should not take the params
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if outer:  # always named</span>
<span class="gi">+            if outer not in (&#39;type&#39;, &#39;member&#39;, &#39;function&#39;,</span>
<span class="gi">+                             &#39;operatorCast&#39;, &#39;templateParam&#39;):</span>
<span class="gi">+                raise Exception(&#39;Internal error, unknown outer &quot;%s&quot;.&#39; % outer)</span>
<span class="gi">+            if outer != &#39;operatorCast&#39;:</span>
<span class="gi">+                assert named</span>
<span class="gi">+        if outer in (&#39;type&#39;, &#39;function&#39;):</span>
<span class="gi">+            # We allow type objects to just be a name.</span>
<span class="gi">+            # Some functions don&#39;t have normal return types: constructors,</span>
<span class="gi">+            # destructors, cast operators</span>
<span class="gi">+            prevErrors = []</span>
<span class="gi">+            startPos = self.pos</span>
<span class="gi">+            # first try without the type</span>
<span class="gi">+            try:</span>
<span class="gi">+                declSpecs = self._parse_decl_specs(outer=outer, typed=False)</span>
<span class="gi">+                decl = self._parse_declarator(named=True, paramMode=outer,</span>
<span class="gi">+                                              typed=False)</span>
<span class="gi">+                mustEnd = True</span>
<span class="gi">+                if outer == &#39;function&#39;:</span>
<span class="gi">+                    # Allow trailing requires on functions.</span>
<span class="gi">+                    self.skip_ws()</span>
<span class="gi">+                    if re.compile(r&#39;requires\b&#39;).match(self.definition, self.pos):</span>
<span class="gi">+                        mustEnd = False</span>
<span class="gi">+                if mustEnd:</span>
<span class="gi">+                    self.assert_end(allowSemicolon=True)</span>
<span class="gi">+            except DefinitionError as exUntyped:</span>
<span class="gi">+                if outer == &#39;type&#39;:</span>
<span class="gi">+                    desc = &quot;If just a name&quot;</span>
<span class="gi">+                elif outer == &#39;function&#39;:</span>
<span class="gi">+                    desc = &quot;If the function has no return type&quot;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise AssertionError from exUntyped</span>
<span class="gi">+                prevErrors.append((exUntyped, desc))</span>
<span class="gi">+                self.pos = startPos</span>
<span class="gi">+                try:</span>
<span class="gi">+                    declSpecs = self._parse_decl_specs(outer=outer)</span>
<span class="gi">+                    decl = self._parse_declarator(named=True, paramMode=outer)</span>
<span class="gi">+                except DefinitionError as exTyped:</span>
<span class="gi">+                    self.pos = startPos</span>
<span class="gi">+                    if outer == &#39;type&#39;:</span>
<span class="gi">+                        desc = &quot;If typedef-like declaration&quot;</span>
<span class="gi">+                    elif outer == &#39;function&#39;:</span>
<span class="gi">+                        desc = &quot;If the function has a return type&quot;</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        raise AssertionError from exUntyped</span>
<span class="gi">+                    prevErrors.append((exTyped, desc))</span>
<span class="gi">+                    # Retain the else branch for easier debugging.</span>
<span class="gi">+                    # TODO: it would be nice to save the previous stacktrace</span>
<span class="gi">+                    #       and output it here.</span>
<span class="gi">+                    if True:</span>
<span class="gi">+                        if outer == &#39;type&#39;:</span>
<span class="gi">+                            header = &quot;Type must be either just a name or a &quot;</span>
<span class="gi">+                            header += &quot;typedef-like declaration.&quot;</span>
<span class="gi">+                        elif outer == &#39;function&#39;:</span>
<span class="gi">+                            header = &quot;Error when parsing function declaration.&quot;</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            raise AssertionError from exUntyped</span>
<span class="gi">+                        raise self._make_multi_error(prevErrors, header) from exTyped</span>
<span class="gi">+                    else:  # NoQA: RET506</span>
<span class="gi">+                        # For testing purposes.</span>
<span class="gi">+                        # do it again to get the proper traceback (how do you</span>
<span class="gi">+                        # reliably save a traceback when an exception is</span>
<span class="gi">+                        # constructed?)</span>
<span class="gi">+                        self.pos = startPos</span>
<span class="gi">+                        typed = True</span>
<span class="gi">+                        declSpecs = self._parse_decl_specs(outer=outer, typed=typed)</span>
<span class="gi">+                        decl = self._parse_declarator(named=True, paramMode=outer,</span>
<span class="gi">+                                                      typed=typed)</span>
<span class="gi">+        else:</span>
<span class="gi">+            paramMode = &#39;type&#39;</span>
<span class="gi">+            if outer == &#39;member&#39;:</span>
<span class="gi">+                named = True</span>
<span class="gi">+            elif outer == &#39;operatorCast&#39;:</span>
<span class="gi">+                paramMode = &#39;operatorCast&#39;</span>
<span class="gi">+                outer = None</span>
<span class="gi">+            elif outer == &#39;templateParam&#39;:</span>
<span class="gi">+                named = &#39;single&#39;</span>
<span class="gi">+            declSpecs = self._parse_decl_specs(outer=outer)</span>
<span class="gi">+            decl = self._parse_declarator(named=named, paramMode=paramMode)</span>
<span class="gi">+        return ASTType(declSpecs, decl)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_type_with_init(</span>
<span class="gi">+            self, named: bool | str,</span>
<span class="gi">+            outer: str) -&gt; ASTTypeWithInit | ASTTemplateParamConstrainedTypeWithInit:</span>
<span class="gi">+        if outer:</span>
<span class="gi">+            assert outer in (&#39;type&#39;, &#39;member&#39;, &#39;function&#39;, &#39;templateParam&#39;)</span>
<span class="gi">+        type = self._parse_type(outer=outer, named=named)</span>
<span class="gi">+        if outer != &#39;templateParam&#39;:</span>
<span class="gi">+            init = self._parse_initializer(outer=outer)</span>
<span class="gi">+            return ASTTypeWithInit(type, init)</span>
<span class="gi">+        # it could also be a constrained type parameter, e.g., C T = int&amp;</span>
<span class="gi">+        pos = self.pos</span>
<span class="gi">+        eExpr = None</span>
<span class="gi">+        try:</span>
<span class="gi">+            init = self._parse_initializer(outer=outer, allowFallback=False)</span>
<span class="gi">+            # note: init may be None if there is no =</span>
<span class="gi">+            if init is None:</span>
<span class="gi">+                return ASTTypeWithInit(type, None)</span>
<span class="gi">+            # we parsed an expression, so we must have a , or a &gt;,</span>
<span class="gi">+            # otherwise the expression didn&#39;t get everything</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if self.current_char != &#39;,&#39; and self.current_char != &#39;&gt;&#39;:</span>
<span class="gi">+                # pretend it didn&#39;t happen</span>
<span class="gi">+                self.pos = pos</span>
<span class="gi">+                init = None</span>
<span class="gi">+            else:</span>
<span class="gi">+                # we assume that it was indeed an expression</span>
<span class="gi">+                return ASTTypeWithInit(type, init)</span>
<span class="gi">+        except DefinitionError as e:</span>
<span class="gi">+            self.pos = pos</span>
<span class="gi">+            eExpr = e</span>
<span class="gi">+        if not self.skip_string(&quot;=&quot;):</span>
<span class="gi">+            return ASTTypeWithInit(type, None)</span>
<span class="gi">+        try:</span>
<span class="gi">+            typeInit = self._parse_type(named=False, outer=None)</span>
<span class="gi">+            return ASTTemplateParamConstrainedTypeWithInit(type, typeInit)</span>
<span class="gi">+        except DefinitionError as eType:</span>
<span class="gi">+            if eExpr is None:</span>
<span class="gi">+                raise</span>
<span class="gi">+            errs = []</span>
<span class="gi">+            errs.append((eExpr, &quot;If default template argument is an expression&quot;))</span>
<span class="gi">+            errs.append((eType, &quot;If default template argument is a type&quot;))</span>
<span class="gi">+            msg = &quot;Error in non-type template parameter&quot;</span>
<span class="gi">+            msg += &quot; or constrained template parameter.&quot;</span>
<span class="gi">+            raise self._make_multi_error(errs, msg) from eType</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_type_using(self) -&gt; ASTTypeUsing:</span>
<span class="gi">+        name = self._parse_nested_name()</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if not self.skip_string(&#39;=&#39;):</span>
<span class="gi">+            return ASTTypeUsing(name, None)</span>
<span class="gi">+        type = self._parse_type(False, None)</span>
<span class="gi">+        return ASTTypeUsing(name, type)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_concept(self) -&gt; ASTConcept:</span>
<span class="gi">+        nestedName = self._parse_nested_name()</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        initializer = self._parse_initializer(&#39;member&#39;)</span>
<span class="gi">+        return ASTConcept(nestedName, initializer)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_class(self) -&gt; ASTClass:</span>
<span class="gi">+        attrs = self._parse_attribute_list()</span>
<span class="gi">+        name = self._parse_nested_name()</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        final = self.skip_word_and_ws(&#39;final&#39;)</span>
<span class="gi">+        bases = []</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if self.skip_string(&#39;:&#39;):</span>
<span class="gi">+            while 1:</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                visibility = None</span>
<span class="gi">+                virtual = False</span>
<span class="gi">+                pack = False</span>
<span class="gi">+                if self.skip_word_and_ws(&#39;virtual&#39;):</span>
<span class="gi">+                    virtual = True</span>
<span class="gi">+                if self.match(_visibility_re):</span>
<span class="gi">+                    visibility = self.matched_text</span>
<span class="gi">+                    self.skip_ws()</span>
<span class="gi">+                if not virtual and self.skip_word_and_ws(&#39;virtual&#39;):</span>
<span class="gi">+                    virtual = True</span>
<span class="gi">+                baseName = self._parse_nested_name()</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                pack = self.skip_string(&#39;...&#39;)</span>
<span class="gi">+                bases.append(ASTBaseClass(baseName, visibility, virtual, pack))</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                if self.skip_string(&#39;,&#39;):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                break</span>
<span class="gi">+        return ASTClass(name, final, bases, attrs)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_union(self) -&gt; ASTUnion:</span>
<span class="gi">+        attrs = self._parse_attribute_list()</span>
<span class="gi">+        name = self._parse_nested_name()</span>
<span class="gi">+        return ASTUnion(name, attrs)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_enum(self) -&gt; ASTEnum:</span>
<span class="gi">+        scoped = None  # is set by CPPEnumObject</span>
<span class="gi">+        attrs = self._parse_attribute_list()</span>
<span class="gi">+        name = self._parse_nested_name()</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        underlyingType = None</span>
<span class="gi">+        if self.skip_string(&#39;:&#39;):</span>
<span class="gi">+            underlyingType = self._parse_type(named=False)</span>
<span class="gi">+        return ASTEnum(name, scoped, underlyingType, attrs)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_enumerator(self) -&gt; ASTEnumerator:</span>
<span class="gi">+        name = self._parse_nested_name()</span>
<span class="gi">+        attrs = self._parse_attribute_list()</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        init = None</span>
<span class="gi">+        if self.skip_string(&#39;=&#39;):</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+</span>
<span class="gi">+            def parser() -&gt; ASTExpression:</span>
<span class="gi">+                return self._parse_constant_expression(inTemplate=False)</span>
<span class="gi">+            initVal = self._parse_expression_fallback([], parser)</span>
<span class="gi">+            init = ASTInitializer(initVal)</span>
<span class="gi">+        return ASTEnumerator(name, init, attrs)</span>
<span class="gi">+</span>
<span class="gi">+    # ==========================================================================</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_template_parameter(self) -&gt; ASTTemplateParam:</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if self.skip_word(&#39;template&#39;):</span>
<span class="gi">+            # declare a template template parameter</span>
<span class="gi">+            nestedParams = self._parse_template_parameter_list()</span>
<span class="gi">+        else:</span>
<span class="gi">+            nestedParams = None</span>
<span class="gi">+</span>
<span class="gi">+        pos = self.pos</span>
<span class="gi">+        try:</span>
<span class="gi">+            # Unconstrained type parameter or template type parameter</span>
<span class="gi">+            key = None</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if self.skip_word_and_ws(&#39;typename&#39;):</span>
<span class="gi">+                key = &#39;typename&#39;</span>
<span class="gi">+            elif self.skip_word_and_ws(&#39;class&#39;):</span>
<span class="gi">+                key = &#39;class&#39;</span>
<span class="gi">+            elif nestedParams:</span>
<span class="gi">+                self.fail(&quot;Expected &#39;typename&#39; or &#39;class&#39; after &quot;</span>
<span class="gi">+                          &quot;template template parameter list.&quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.fail(&quot;Expected &#39;typename&#39; or &#39;class&#39; in the &quot;</span>
<span class="gi">+                          &quot;beginning of template type parameter.&quot;)</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            parameterPack = self.skip_string(&#39;...&#39;)</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if self.match(identifier_re):</span>
<span class="gi">+                identifier = ASTIdentifier(self.matched_text)</span>
<span class="gi">+            else:</span>
<span class="gi">+                identifier = None</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if not parameterPack and self.skip_string(&#39;=&#39;):</span>
<span class="gi">+                default = self._parse_type(named=False, outer=None)</span>
<span class="gi">+            else:</span>
<span class="gi">+                default = None</span>
<span class="gi">+                if self.current_char not in &#39;,&gt;&#39;:</span>
<span class="gi">+                    self.fail(&#39;Expected &quot;,&quot; or &quot;&gt;&quot; after (template) type parameter.&#39;)</span>
<span class="gi">+            data = ASTTemplateKeyParamPackIdDefault(key, identifier,</span>
<span class="gi">+                                                    parameterPack, default)</span>
<span class="gi">+            if nestedParams:</span>
<span class="gi">+                return ASTTemplateParamTemplateType(nestedParams, data)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return ASTTemplateParamType(data)</span>
<span class="gi">+        except DefinitionError as eType:</span>
<span class="gi">+            if nestedParams:</span>
<span class="gi">+                raise</span>
<span class="gi">+            try:</span>
<span class="gi">+                # non-type parameter or constrained type parameter</span>
<span class="gi">+                self.pos = pos</span>
<span class="gi">+                param = self._parse_type_with_init(&#39;maybe&#39;, &#39;templateParam&#39;)</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                parameterPack = self.skip_string(&#39;...&#39;)</span>
<span class="gi">+                return ASTTemplateParamNonType(param, parameterPack)</span>
<span class="gi">+            except DefinitionError as eNonType:</span>
<span class="gi">+                self.pos = pos</span>
<span class="gi">+                header = &quot;Error when parsing template parameter.&quot;</span>
<span class="gi">+                errs = []</span>
<span class="gi">+                errs.append(</span>
<span class="gi">+                    (eType, &quot;If unconstrained type parameter or template type parameter&quot;))</span>
<span class="gi">+                errs.append(</span>
<span class="gi">+                    (eNonType, &quot;If constrained type parameter or non-type parameter&quot;))</span>
<span class="gi">+                raise self._make_multi_error(errs, header) from None</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_template_parameter_list(self) -&gt; ASTTemplateParams:</span>
<span class="gi">+        # only: &#39;&lt;&#39; parameter-list &#39;&gt;&#39;</span>
<span class="gi">+        # we assume that &#39;template&#39; has just been parsed</span>
<span class="gi">+        templateParams: list[ASTTemplateParam] = []</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if not self.skip_string(&quot;&lt;&quot;):</span>
<span class="gi">+            self.fail(&quot;Expected &#39;&lt;&#39; after &#39;template&#39;&quot;)</span>
<span class="gi">+        while 1:</span>
<span class="gi">+            pos = self.pos</span>
<span class="gi">+            err = None</span>
<span class="gi">+            try:</span>
<span class="gi">+                param = self._parse_template_parameter()</span>
<span class="gi">+                templateParams.append(param)</span>
<span class="gi">+            except DefinitionError as eParam:</span>
<span class="gi">+                self.pos = pos</span>
<span class="gi">+                err = eParam</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if self.skip_string(&#39;&gt;&#39;):</span>
<span class="gi">+                requiresClause = self._parse_requires_clause()</span>
<span class="gi">+                return ASTTemplateParams(templateParams, requiresClause)</span>
<span class="gi">+            elif self.skip_string(&#39;,&#39;):</span>
<span class="gi">+                continue</span>
<span class="gi">+            else:</span>
<span class="gi">+                header = &quot;Error in template parameter list.&quot;</span>
<span class="gi">+                errs = []</span>
<span class="gi">+                if err:</span>
<span class="gi">+                    errs.append((err, &quot;If parameter&quot;))</span>
<span class="gi">+                try:</span>
<span class="gi">+                    self.fail(&#39;Expected &quot;,&quot; or &quot;&gt;&quot;.&#39;)</span>
<span class="gi">+                except DefinitionError as e:</span>
<span class="gi">+                    errs.append((e, &quot;If no parameter&quot;))</span>
<span class="gi">+                logger.debug(errs)</span>
<span class="gi">+                raise self._make_multi_error(errs, header)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_template_introduction(self) -&gt; ASTTemplateIntroduction | None:</span>
<span class="gi">+        pos = self.pos</span>
<span class="gi">+        try:</span>
<span class="gi">+            concept = self._parse_nested_name()</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            self.pos = pos</span>
<span class="gi">+            return None</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if not self.skip_string(&#39;{&#39;):</span>
<span class="gi">+            self.pos = pos</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        # for sure it must be a template introduction now</span>
<span class="gi">+        params = []</span>
<span class="gi">+        while 1:</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            parameterPack = self.skip_string(&#39;...&#39;)</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if not self.match(identifier_re):</span>
<span class="gi">+                self.fail(&quot;Expected identifier in template introduction list.&quot;)</span>
<span class="gi">+            txt_identifier = self.matched_text</span>
<span class="gi">+            # make sure there isn&#39;t a keyword</span>
<span class="gi">+            if txt_identifier in _keywords:</span>
<span class="gi">+                self.fail(&quot;Expected identifier in template introduction list, &quot;</span>
<span class="gi">+                          &quot;got keyword: %s&quot; % txt_identifier)</span>
<span class="gi">+            identifier = ASTIdentifier(txt_identifier)</span>
<span class="gi">+            params.append(ASTTemplateIntroductionParameter(identifier, parameterPack))</span>
<span class="gi">+</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            if self.skip_string(&#39;}&#39;):</span>
<span class="gi">+                break</span>
<span class="gi">+            if self.skip_string(&#39;,&#39;):</span>
<span class="gi">+                continue</span>
<span class="gi">+            self.fail(&#39;Error in template introduction list. Expected &quot;,&quot;, or &quot;}&quot;.&#39;)</span>
<span class="gi">+        return ASTTemplateIntroduction(concept, params)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_requires_clause(self) -&gt; ASTRequiresClause | None:</span>
<span class="gi">+        # requires-clause -&gt; &#39;requires&#39; constraint-logical-or-expression</span>
<span class="gi">+        # constraint-logical-or-expression</span>
<span class="gi">+        #   -&gt; constraint-logical-and-expression</span>
<span class="gi">+        #    | constraint-logical-or-expression &#39;||&#39; constraint-logical-and-expression</span>
<span class="gi">+        # constraint-logical-and-expression</span>
<span class="gi">+        #   -&gt; primary-expression</span>
<span class="gi">+        #    | constraint-logical-and-expression &#39;&amp;&amp;&#39; primary-expression</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if not self.skip_word(&#39;requires&#39;):</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        def parse_and_expr(self: DefinitionParser) -&gt; ASTExpression:</span>
<span class="gi">+            andExprs = []</span>
<span class="gi">+            ops = []</span>
<span class="gi">+            andExprs.append(self._parse_primary_expression())</span>
<span class="gi">+            while True:</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                oneMore = False</span>
<span class="gi">+                if self.skip_string(&#39;&amp;&amp;&#39;):</span>
<span class="gi">+                    oneMore = True</span>
<span class="gi">+                    ops.append(&#39;&amp;&amp;&#39;)</span>
<span class="gi">+                elif self.skip_word(&#39;and&#39;):</span>
<span class="gi">+                    oneMore = True</span>
<span class="gi">+                    ops.append(&#39;and&#39;)</span>
<span class="gi">+                if not oneMore:</span>
<span class="gi">+                    break</span>
<span class="gi">+                andExprs.append(self._parse_primary_expression())</span>
<span class="gi">+            if len(andExprs) == 1:</span>
<span class="gi">+                return andExprs[0]</span>
<span class="gi">+            else:</span>
<span class="gi">+                return ASTBinOpExpr(andExprs, ops)</span>
<span class="gi">+</span>
<span class="gi">+        orExprs = []</span>
<span class="gi">+        ops = []</span>
<span class="gi">+        orExprs.append(parse_and_expr(self))</span>
<span class="gi">+        while True:</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            oneMore = False</span>
<span class="gi">+            if self.skip_string(&#39;||&#39;):</span>
<span class="gi">+                oneMore = True</span>
<span class="gi">+                ops.append(&#39;||&#39;)</span>
<span class="gi">+            elif self.skip_word(&#39;or&#39;):</span>
<span class="gi">+                oneMore = True</span>
<span class="gi">+                ops.append(&#39;or&#39;)</span>
<span class="gi">+            if not oneMore:</span>
<span class="gi">+                break</span>
<span class="gi">+            orExprs.append(parse_and_expr(self))</span>
<span class="gi">+        if len(orExprs) == 1:</span>
<span class="gi">+            return ASTRequiresClause(orExprs[0])</span>
<span class="gi">+        else:</span>
<span class="gi">+            return ASTRequiresClause(ASTBinOpExpr(orExprs, ops))</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_template_declaration_prefix(self, objectType: str,</span>
<span class="gi">+                                           ) -&gt; ASTTemplateDeclarationPrefix | None:</span>
<span class="gi">+        templates: list[ASTTemplateParams | ASTTemplateIntroduction] = []</span>
<span class="gi">+        while 1:</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            # the saved position is only used to provide a better error message</span>
<span class="gi">+            params: ASTTemplateParams | ASTTemplateIntroduction | None = None</span>
<span class="gi">+            pos = self.pos</span>
<span class="gi">+            if self.skip_word(&quot;template&quot;):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    params = self._parse_template_parameter_list()</span>
<span class="gi">+                except DefinitionError as e:</span>
<span class="gi">+                    if objectType == &#39;member&#39; and len(templates) == 0:</span>
<span class="gi">+                        return ASTTemplateDeclarationPrefix(None)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        raise e</span>
<span class="gi">+                if objectType == &#39;concept&#39; and params.requiresClause is not None:</span>
<span class="gi">+                    self.fail(&#39;requires-clause not allowed for concept&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                params = self._parse_template_introduction()</span>
<span class="gi">+                if not params:</span>
<span class="gi">+                    break</span>
<span class="gi">+            if objectType == &#39;concept&#39; and len(templates) &gt; 0:</span>
<span class="gi">+                self.pos = pos</span>
<span class="gi">+                self.fail(&quot;More than 1 template parameter list for concept.&quot;)</span>
<span class="gi">+            templates.append(params)</span>
<span class="gi">+        if len(templates) == 0 and objectType == &#39;concept&#39;:</span>
<span class="gi">+            self.fail(&#39;Missing template parameter list for concept.&#39;)</span>
<span class="gi">+        if len(templates) == 0:</span>
<span class="gi">+            return None</span>
<span class="gi">+        else:</span>
<span class="gi">+            return ASTTemplateDeclarationPrefix(templates)</span>
<span class="gi">+</span>
<span class="gi">+    def _check_template_consistency(self, nestedName: ASTNestedName,</span>
<span class="gi">+                                    templatePrefix: ASTTemplateDeclarationPrefix,</span>
<span class="gi">+                                    fullSpecShorthand: bool, isMember: bool = False,</span>
<span class="gi">+                                    ) -&gt; ASTTemplateDeclarationPrefix:</span>
<span class="gi">+        numArgs = nestedName.num_templates()</span>
<span class="gi">+        isMemberInstantiation = False</span>
<span class="gi">+        if not templatePrefix:</span>
<span class="gi">+            numParams = 0</span>
<span class="gi">+        else:</span>
<span class="gi">+            if isMember and templatePrefix.templates is None:</span>
<span class="gi">+                numParams = 0</span>
<span class="gi">+                isMemberInstantiation = True</span>
<span class="gi">+            else:</span>
<span class="gi">+                numParams = len(templatePrefix.templates)</span>
<span class="gi">+        if numArgs + 1 &lt; numParams:</span>
<span class="gi">+            self.fail(&quot;Too few template argument lists compared to parameter&quot;</span>
<span class="gi">+                      &quot; lists. Argument lists: %d, Parameter lists: %d.&quot;</span>
<span class="gi">+                      % (numArgs, numParams))</span>
<span class="gi">+        if numArgs &gt; numParams:</span>
<span class="gi">+            numExtra = numArgs - numParams</span>
<span class="gi">+            if not fullSpecShorthand and not isMemberInstantiation:</span>
<span class="gi">+                msg = (</span>
<span class="gi">+                    f&#39;Too many template argument lists compared to parameter lists. &#39;</span>
<span class="gi">+                    f&#39;Argument lists: {numArgs:d}, Parameter lists: {numParams:d}, &#39;</span>
<span class="gi">+                    f&#39;Extra empty parameters lists prepended: {numExtra:d}. &#39;</span>
<span class="gi">+                    &#39;Declaration:\n\t&#39;</span>
<span class="gi">+                )</span>
<span class="gi">+                if templatePrefix:</span>
<span class="gi">+                    msg += f&quot;{templatePrefix}\n\t&quot;</span>
<span class="gi">+                msg += str(nestedName)</span>
<span class="gi">+                self.warn(msg)</span>
<span class="gi">+</span>
<span class="gi">+            newTemplates: list[ASTTemplateParams | ASTTemplateIntroduction] = [</span>
<span class="gi">+                ASTTemplateParams([], requiresClause=None)</span>
<span class="gi">+                for _i in range(numExtra)</span>
<span class="gi">+            ]</span>
<span class="gi">+            if templatePrefix and not isMemberInstantiation:</span>
<span class="gi">+                newTemplates.extend(templatePrefix.templates)</span>
<span class="gi">+            templatePrefix = ASTTemplateDeclarationPrefix(newTemplates)</span>
<span class="gi">+        return templatePrefix</span>
<span class="gi">+</span>
<span class="gi">+    def parse_declaration(self, objectType: str, directiveType: str) -&gt; ASTDeclaration:</span>
<span class="gi">+        if objectType not in (&#39;class&#39;, &#39;union&#39;, &#39;function&#39;, &#39;member&#39;, &#39;type&#39;,</span>
<span class="gi">+                              &#39;concept&#39;, &#39;enum&#39;, &#39;enumerator&#39;):</span>
<span class="gi">+            raise Exception(&#39;Internal error, unknown objectType &quot;%s&quot;.&#39; % objectType)</span>
<span class="gi">+        if directiveType not in (&#39;class&#39;, &#39;struct&#39;, &#39;union&#39;, &#39;function&#39;, &#39;member&#39;, &#39;var&#39;,</span>
<span class="gi">+                                 &#39;type&#39;, &#39;concept&#39;,</span>
<span class="gi">+                                 &#39;enum&#39;, &#39;enum-struct&#39;, &#39;enum-class&#39;, &#39;enumerator&#39;):</span>
<span class="gi">+            raise Exception(&#39;Internal error, unknown directiveType &quot;%s&quot;.&#39; % directiveType)</span>
<span class="gi">+        visibility = None</span>
<span class="gi">+        templatePrefix = None</span>
<span class="gi">+        trailingRequiresClause = None</span>
<span class="gi">+        declaration: Any = None</span>
<span class="gi">+</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if self.match(_visibility_re):</span>
<span class="gi">+            visibility = self.matched_text</span>
<span class="gi">+</span>
<span class="gi">+        if objectType in (&#39;type&#39;, &#39;concept&#39;, &#39;member&#39;, &#39;function&#39;, &#39;class&#39;, &#39;union&#39;):</span>
<span class="gi">+            templatePrefix = self._parse_template_declaration_prefix(objectType)</span>
<span class="gi">+</span>
<span class="gi">+        if objectType == &#39;type&#39;:</span>
<span class="gi">+            prevErrors = []</span>
<span class="gi">+            pos = self.pos</span>
<span class="gi">+            try:</span>
<span class="gi">+                if not templatePrefix:</span>
<span class="gi">+                    declaration = self._parse_type(named=True, outer=&#39;type&#39;)</span>
<span class="gi">+            except DefinitionError as e:</span>
<span class="gi">+                prevErrors.append((e, &quot;If typedef-like declaration&quot;))</span>
<span class="gi">+                self.pos = pos</span>
<span class="gi">+            pos = self.pos</span>
<span class="gi">+            try:</span>
<span class="gi">+                if not declaration:</span>
<span class="gi">+                    declaration = self._parse_type_using()</span>
<span class="gi">+            except DefinitionError as e:</span>
<span class="gi">+                self.pos = pos</span>
<span class="gi">+                prevErrors.append((e, &quot;If type alias or template alias&quot;))</span>
<span class="gi">+                header = &quot;Error in type declaration.&quot;</span>
<span class="gi">+                raise self._make_multi_error(prevErrors, header) from e</span>
<span class="gi">+        elif objectType == &#39;concept&#39;:</span>
<span class="gi">+            declaration = self._parse_concept()</span>
<span class="gi">+        elif objectType == &#39;member&#39;:</span>
<span class="gi">+            declaration = self._parse_type_with_init(named=True, outer=&#39;member&#39;)</span>
<span class="gi">+        elif objectType == &#39;function&#39;:</span>
<span class="gi">+            declaration = self._parse_type(named=True, outer=&#39;function&#39;)</span>
<span class="gi">+            trailingRequiresClause = self._parse_requires_clause()</span>
<span class="gi">+        elif objectType == &#39;class&#39;:</span>
<span class="gi">+            declaration = self._parse_class()</span>
<span class="gi">+        elif objectType == &#39;union&#39;:</span>
<span class="gi">+            declaration = self._parse_union()</span>
<span class="gi">+        elif objectType == &#39;enum&#39;:</span>
<span class="gi">+            declaration = self._parse_enum()</span>
<span class="gi">+        elif objectType == &#39;enumerator&#39;:</span>
<span class="gi">+            declaration = self._parse_enumerator()</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise AssertionError</span>
<span class="gi">+        templatePrefix = self._check_template_consistency(declaration.name,</span>
<span class="gi">+                                                          templatePrefix,</span>
<span class="gi">+                                                          fullSpecShorthand=False,</span>
<span class="gi">+                                                          isMember=objectType == &#39;member&#39;)</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        semicolon = self.skip_string(&#39;;&#39;)</span>
<span class="gi">+        return ASTDeclaration(objectType, directiveType, visibility,</span>
<span class="gi">+                              templatePrefix, declaration,</span>
<span class="gi">+                              trailingRequiresClause, semicolon)</span>
<span class="gi">+</span>
<span class="gi">+    def parse_namespace_object(self) -&gt; ASTNamespace:</span>
<span class="gi">+        templatePrefix = self._parse_template_declaration_prefix(objectType=&quot;namespace&quot;)</span>
<span class="gi">+        name = self._parse_nested_name()</span>
<span class="gi">+        templatePrefix = self._check_template_consistency(name, templatePrefix,</span>
<span class="gi">+                                                          fullSpecShorthand=False)</span>
<span class="gi">+        res = ASTNamespace(name, templatePrefix)</span>
<span class="gi">+        res.objectType = &#39;namespace&#39;  # type: ignore[attr-defined]</span>
<span class="gi">+        return res</span>
<span class="gi">+</span>
<span class="gi">+    def parse_xref_object(self) -&gt; tuple[ASTNamespace | ASTDeclaration, bool]:</span>
<span class="gi">+        pos = self.pos</span>
<span class="gi">+        try:</span>
<span class="gi">+            templatePrefix = self._parse_template_declaration_prefix(objectType=&quot;xref&quot;)</span>
<span class="gi">+            name = self._parse_nested_name()</span>
<span class="gi">+            # if there are &#39;()&#39; left, just skip them</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            self.skip_string(&#39;()&#39;)</span>
<span class="gi">+            self.assert_end()</span>
<span class="gi">+            templatePrefix = self._check_template_consistency(name, templatePrefix,</span>
<span class="gi">+                                                              fullSpecShorthand=True)</span>
<span class="gi">+            res1 = ASTNamespace(name, templatePrefix)</span>
<span class="gi">+            res1.objectType = &#39;xref&#39;  # type: ignore[attr-defined]</span>
<span class="gi">+            return res1, True</span>
<span class="gi">+        except DefinitionError as e1:</span>
<span class="gi">+            try:</span>
<span class="gi">+                self.pos = pos</span>
<span class="gi">+                res2 = self.parse_declaration(&#39;function&#39;, &#39;function&#39;)</span>
<span class="gi">+                # if there are &#39;()&#39; left, just skip them</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                self.skip_string(&#39;()&#39;)</span>
<span class="gi">+                self.assert_end()</span>
<span class="gi">+                return res2, False</span>
<span class="gi">+            except DefinitionError as e2:</span>
<span class="gi">+                errs = []</span>
<span class="gi">+                errs.append((e1, &quot;If shorthand ref&quot;))</span>
<span class="gi">+                errs.append((e2, &quot;If full function ref&quot;))</span>
<span class="gi">+                msg = &quot;Error in cross-reference.&quot;</span>
<span class="gi">+                raise self._make_multi_error(errs, msg) from e2</span>
<span class="gi">+</span>
<span class="gi">+    def parse_expression(self) -&gt; ASTExpression | ASTType:</span>
<span class="gi">+        pos = self.pos</span>
<span class="gi">+        try:</span>
<span class="gi">+            expr = self._parse_expression()</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            self.assert_end()</span>
<span class="gi">+            return expr</span>
<span class="gi">+        except DefinitionError as exExpr:</span>
<span class="gi">+            self.pos = pos</span>
<span class="gi">+            try:</span>
<span class="gi">+                typ = self._parse_type(False)</span>
<span class="gi">+                self.skip_ws()</span>
<span class="gi">+                self.assert_end()</span>
<span class="gi">+                return typ</span>
<span class="gi">+            except DefinitionError as exType:</span>
<span class="gi">+                header = &quot;Error when parsing (type) expression.&quot;</span>
<span class="gi">+                errs = []</span>
<span class="gi">+                errs.append((exExpr, &quot;If expression&quot;))</span>
<span class="gi">+                errs.append((exType, &quot;If type&quot;))</span>
<span class="gi">+                raise self._make_multi_error(errs, header) from exType</span>
<span class="gh">diff --git a/sphinx/domains/cpp/_symbol.py b/sphinx/domains/cpp/_symbol.py</span>
<span class="gh">index 1d87ea050..ef5a40588 100644</span>
<span class="gd">--- a/sphinx/domains/cpp/_symbol.py</span>
<span class="gi">+++ b/sphinx/domains/cpp/_symbol.py</span>
<span class="gu">@@ -1,31 +1,44 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any, NoReturn
<span class="gd">-from sphinx.domains.cpp._ast import ASTDeclaration, ASTIdentifier, ASTNestedName, ASTNestedNameElement, ASTOperator, ASTTemplateArgs, ASTTemplateDeclarationPrefix, ASTTemplateIntroduction, ASTTemplateParams</span>
<span class="gi">+</span>
<span class="gi">+from sphinx.domains.cpp._ast import (</span>
<span class="gi">+    ASTDeclaration,</span>
<span class="gi">+    ASTIdentifier,</span>
<span class="gi">+    ASTNestedName,</span>
<span class="gi">+    ASTNestedNameElement,</span>
<span class="gi">+    ASTOperator,</span>
<span class="gi">+    ASTTemplateArgs,</span>
<span class="gi">+    ASTTemplateDeclarationPrefix,</span>
<span class="gi">+    ASTTemplateIntroduction,</span>
<span class="gi">+    ASTTemplateParams,</span>
<span class="gi">+)</span>
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.util import logging
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Callable, Iterator
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="w"> </span>class _DuplicateSymbolError(Exception):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, symbol: Symbol, declaration: ASTDeclaration) -&gt;None:</span>
<span class="gi">+    def __init__(self, symbol: Symbol, declaration: ASTDeclaration) -&gt; None:</span>
<span class="w"> </span>        assert symbol
<span class="w"> </span>        assert declaration
<span class="w"> </span>        self.symbol = symbol
<span class="w"> </span>        self.declaration = declaration

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gd">-        return &#39;Internal C++ duplicate symbol error:\n%s&#39; % self.symbol.dump(0)</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="gi">+        return &quot;Internal C++ duplicate symbol error:\n%s&quot; % self.symbol.dump(0)</span>


<span class="w"> </span>class SymbolLookupResult:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, symbols: Iterator[Symbol], parentSymbol: Symbol,
<span class="gd">-        identOrOp: (ASTIdentifier | ASTOperator), templateParams: Any,</span>
<span class="gd">-        templateArgs: ASTTemplateArgs) -&gt;None:</span>
<span class="gi">+                 identOrOp: ASTIdentifier | ASTOperator, templateParams: Any,</span>
<span class="gi">+                 templateArgs: ASTTemplateArgs) -&gt; None:</span>
<span class="w"> </span>        self.symbols = symbols
<span class="w"> </span>        self.parentSymbol = parentSymbol
<span class="w"> </span>        self.identOrOp = identOrOp
<span class="gu">@@ -34,57 +47,1049 @@ class SymbolLookupResult:</span>


<span class="w"> </span>class LookupKey:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, data: list[tuple[ASTNestedNameElement, </span>
<span class="gd">-        ASTTemplateParams | ASTTemplateIntroduction, str]]) -&gt;None:</span>
<span class="gi">+    def __init__(self, data: list[tuple[ASTNestedNameElement,</span>
<span class="gi">+                                        ASTTemplateParams | ASTTemplateIntroduction,</span>
<span class="gi">+                                        str]]) -&gt; None:</span>
<span class="w"> </span>        self.data = data


<span class="gi">+def _is_specialization(templateParams: ASTTemplateParams | ASTTemplateIntroduction,</span>
<span class="gi">+                       templateArgs: ASTTemplateArgs) -&gt; bool:</span>
<span class="gi">+    # Checks if `templateArgs` does not exactly match `templateParams`.</span>
<span class="gi">+    # the names of the template parameters must be given exactly as args</span>
<span class="gi">+    # and params that are packs must in the args be the name expanded</span>
<span class="gi">+    if len(templateParams.params) != len(templateArgs.args):</span>
<span class="gi">+        return True</span>
<span class="gi">+    # having no template params and no arguments is also a specialization</span>
<span class="gi">+    if len(templateParams.params) == 0:</span>
<span class="gi">+        return True</span>
<span class="gi">+    for i in range(len(templateParams.params)):</span>
<span class="gi">+        param = templateParams.params[i]</span>
<span class="gi">+        arg = templateArgs.args[i]</span>
<span class="gi">+        # TODO: doing this by string manipulation is probably not the most efficient</span>
<span class="gi">+        paramName = str(param.name)</span>
<span class="gi">+        argTxt = str(arg)</span>
<span class="gi">+        isArgPackExpansion = argTxt.endswith(&#39;...&#39;)</span>
<span class="gi">+        if param.isPack != isArgPackExpansion:</span>
<span class="gi">+            return True</span>
<span class="gi">+        argName = argTxt[:-3] if isArgPackExpansion else argTxt</span>
<span class="gi">+        if paramName != argName:</span>
<span class="gi">+            return True</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class Symbol:
<span class="w"> </span>    debug_indent = 0
<span class="gd">-    debug_indent_string = &#39;  &#39;</span>
<span class="gd">-    debug_lookup = False</span>
<span class="gd">-    debug_show_tree = False</span>
<span class="gi">+    debug_indent_string = &quot;  &quot;</span>
<span class="gi">+    debug_lookup = False  # overridden by the corresponding config value</span>
<span class="gi">+    debug_show_tree = False  # overridden by the corresponding config value</span>

<span class="gd">-    def __copy__(self) -&gt;NoReturn:</span>
<span class="gd">-        raise AssertionError</span>
<span class="gi">+    def __copy__(self) -&gt; NoReturn:</span>
<span class="gi">+        raise AssertionError  # shouldn&#39;t happen</span>

<span class="gd">-    def __deepcopy__(self, memo: Any) -&gt;Symbol:</span>
<span class="gi">+    def __deepcopy__(self, memo: Any) -&gt; Symbol:</span>
<span class="w"> </span>        if self.parent:
<span class="gd">-            raise AssertionError</span>
<span class="gi">+            raise AssertionError  # shouldn&#39;t happen</span>
<span class="gi">+        # the domain base class makes a copy of the initial data, which is fine</span>
<span class="w"> </span>        return Symbol(None, None, None, None, None, None, None)

<span class="gd">-    def __setattr__(self, key: str, value: Any) -&gt;None:</span>
<span class="gd">-        if key == &#39;children&#39;:</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def debug_print(*args: Any) -&gt; None:</span>
<span class="gi">+        logger.debug(Symbol.debug_indent_string * Symbol.debug_indent, end=&quot;&quot;)</span>
<span class="gi">+        logger.debug(*args)</span>
<span class="gi">+</span>
<span class="gi">+    def _assert_invariants(self) -&gt; None:</span>
<span class="gi">+        if not self.parent:</span>
<span class="gi">+            # parent == None means global scope, so declaration means a parent</span>
<span class="gi">+            assert not self.identOrOp</span>
<span class="gi">+            assert not self.templateParams</span>
<span class="gi">+            assert not self.templateArgs</span>
<span class="gi">+            assert not self.declaration</span>
<span class="gi">+            assert not self.docname</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self.declaration:</span>
<span class="gi">+                assert self.docname</span>
<span class="gi">+</span>
<span class="gi">+    def __setattr__(self, key: str, value: Any) -&gt; None:</span>
<span class="gi">+        if key == &quot;children&quot;:</span>
<span class="w"> </span>            raise AssertionError
<span class="w"> </span>        return super().__setattr__(key, value)

<span class="gd">-    def __init__(self, parent: (Symbol | None), identOrOp: (ASTIdentifier |</span>
<span class="gd">-        ASTOperator | None), templateParams: (ASTTemplateParams |</span>
<span class="gd">-        ASTTemplateIntroduction | None), templateArgs: Any, declaration: (</span>
<span class="gd">-        ASTDeclaration | None), docname: (str | None), line: (int | None)</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, parent: Symbol | None,</span>
<span class="gi">+                 identOrOp: ASTIdentifier | ASTOperator | None,</span>
<span class="gi">+                 templateParams: ASTTemplateParams | ASTTemplateIntroduction | None,</span>
<span class="gi">+                 templateArgs: Any, declaration: ASTDeclaration | None,</span>
<span class="gi">+                 docname: str | None, line: int | None) -&gt; None:</span>
<span class="w"> </span>        self.parent = parent
<span class="gi">+        # declarations in a single directive are linked together</span>
<span class="w"> </span>        self.siblingAbove: Symbol | None = None
<span class="w"> </span>        self.siblingBelow: Symbol | None = None
<span class="w"> </span>        self.identOrOp = identOrOp
<span class="gd">-        if templateArgs is not None and not _is_specialization(templateParams,</span>
<span class="gd">-            templateArgs):</span>
<span class="gi">+        # Ensure the same symbol for `A` is created for:</span>
<span class="gi">+        #</span>
<span class="gi">+        #     .. cpp:class:: template &lt;typename T&gt; class A</span>
<span class="gi">+        #</span>
<span class="gi">+        # and</span>
<span class="gi">+        #</span>
<span class="gi">+        #     .. cpp:function:: template &lt;typename T&gt; int A&lt;T&gt;::foo()</span>
<span class="gi">+        if (templateArgs is not None and</span>
<span class="gi">+                not _is_specialization(templateParams, templateArgs)):</span>
<span class="w"> </span>            templateArgs = None
<span class="gd">-        self.templateParams = templateParams</span>
<span class="gd">-        self.templateArgs = templateArgs</span>
<span class="gi">+        self.templateParams = templateParams  # template&lt;templateParams&gt;</span>
<span class="gi">+        self.templateArgs = templateArgs  # identifier&lt;templateArgs&gt;</span>
<span class="w"> </span>        self.declaration = declaration
<span class="w"> </span>        self.docname = docname
<span class="w"> </span>        self.line = line
<span class="w"> </span>        self.isRedeclaration = False
<span class="w"> </span>        self._assert_invariants()
<span class="gi">+</span>
<span class="gi">+        # Remember to modify Symbol.remove if modifications to the parent change.</span>
<span class="w"> </span>        self._children: list[Symbol] = []
<span class="w"> </span>        self._anonChildren: list[Symbol] = []
<span class="gi">+        # note: _children includes _anonChildren</span>
<span class="w"> </span>        if self.parent:
<span class="w"> </span>            self.parent._children.append(self)
<span class="w"> </span>        if self.declaration:
<span class="w"> </span>            self.declaration.symbol = self
<span class="gi">+</span>
<span class="gi">+        # Do symbol addition after self._children has been initialised.</span>
<span class="w"> </span>        self._add_template_and_function_params()

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return f&#39;&lt;Symbol {self.to_string(indent=0)!r}&gt;&#39;
<span class="gi">+</span>
<span class="gi">+    def _fill_empty(self, declaration: ASTDeclaration, docname: str, line: int) -&gt; None:</span>
<span class="gi">+        self._assert_invariants()</span>
<span class="gi">+        assert self.declaration is None</span>
<span class="gi">+        assert self.docname is None</span>
<span class="gi">+        assert self.line is None</span>
<span class="gi">+        assert declaration is not None</span>
<span class="gi">+        assert docname is not None</span>
<span class="gi">+        assert line is not None</span>
<span class="gi">+        self.declaration = declaration</span>
<span class="gi">+        self.declaration.symbol = self</span>
<span class="gi">+        self.docname = docname</span>
<span class="gi">+        self.line = line</span>
<span class="gi">+        self._assert_invariants()</span>
<span class="gi">+        # and symbol addition should be done as well</span>
<span class="gi">+        self._add_template_and_function_params()</span>
<span class="gi">+</span>
<span class="gi">+    def _add_template_and_function_params(self) -&gt; None:</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;_add_template_and_function_params:&quot;)</span>
<span class="gi">+        # Note: we may be called from _fill_empty, so the symbols we want</span>
<span class="gi">+        #       to add may actually already be present (as empty symbols).</span>
<span class="gi">+</span>
<span class="gi">+        # add symbols for the template params</span>
<span class="gi">+        if self.templateParams:</span>
<span class="gi">+            for tp in self.templateParams.params:</span>
<span class="gi">+                if not tp.get_identifier():</span>
<span class="gi">+                    continue</span>
<span class="gi">+                # only add a declaration if we our self are from a declaration</span>
<span class="gi">+                if self.declaration:</span>
<span class="gi">+                    decl = ASTDeclaration(objectType=&#39;templateParam&#39;, declaration=tp)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    decl = None</span>
<span class="gi">+                nne = ASTNestedNameElement(tp.get_identifier(), None)</span>
<span class="gi">+                nn = ASTNestedName([nne], [False], rooted=False)</span>
<span class="gi">+                self._add_symbols(nn, [], decl, self.docname, self.line)</span>
<span class="gi">+        # add symbols for function parameters, if any</span>
<span class="gi">+        if self.declaration is not None and self.declaration.function_params is not None:</span>
<span class="gi">+            for fp in self.declaration.function_params:</span>
<span class="gi">+                if fp.arg is None:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                nn = fp.arg.name</span>
<span class="gi">+                if nn is None:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                # (comparing to the template params: we have checked that we are a declaration)</span>
<span class="gi">+                decl = ASTDeclaration(objectType=&#39;functionParam&#39;, declaration=fp)</span>
<span class="gi">+                assert not nn.rooted</span>
<span class="gi">+                assert len(nn.names) == 1</span>
<span class="gi">+                self._add_symbols(nn, [], decl, self.docname, self.line)</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent -= 1</span>
<span class="gi">+</span>
<span class="gi">+    def remove(self) -&gt; None:</span>
<span class="gi">+        if self.parent is None:</span>
<span class="gi">+            return</span>
<span class="gi">+        assert self in self.parent._children</span>
<span class="gi">+        self.parent._children.remove(self)</span>
<span class="gi">+        self.parent = None</span>
<span class="gi">+</span>
<span class="gi">+    def clear_doc(self, docname: str) -&gt; None:</span>
<span class="gi">+        newChildren: list[Symbol] = []</span>
<span class="gi">+        for sChild in self._children:</span>
<span class="gi">+            sChild.clear_doc(docname)</span>
<span class="gi">+            if sChild.declaration and sChild.docname == docname:</span>
<span class="gi">+                sChild.declaration = None</span>
<span class="gi">+                sChild.docname = None</span>
<span class="gi">+                sChild.line = None</span>
<span class="gi">+                if sChild.siblingAbove is not None:</span>
<span class="gi">+                    sChild.siblingAbove.siblingBelow = sChild.siblingBelow</span>
<span class="gi">+                if sChild.siblingBelow is not None:</span>
<span class="gi">+                    sChild.siblingBelow.siblingAbove = sChild.siblingAbove</span>
<span class="gi">+                sChild.siblingAbove = None</span>
<span class="gi">+                sChild.siblingBelow = None</span>
<span class="gi">+            newChildren.append(sChild)</span>
<span class="gi">+        self._children = newChildren</span>
<span class="gi">+</span>
<span class="gi">+    def get_all_symbols(self) -&gt; Iterator[Any]:</span>
<span class="gi">+        yield self</span>
<span class="gi">+        for sChild in self._children:</span>
<span class="gi">+            yield from sChild.get_all_symbols()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def children_recurse_anon(self) -&gt; Iterator[Symbol]:</span>
<span class="gi">+        for c in self._children:</span>
<span class="gi">+            yield c</span>
<span class="gi">+            if not c.identOrOp.is_anon():</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            yield from c.children_recurse_anon</span>
<span class="gi">+</span>
<span class="gi">+    def get_lookup_key(self) -&gt; LookupKey:</span>
<span class="gi">+        # The pickle files for the environment and for each document are distinct.</span>
<span class="gi">+        # The environment has all the symbols, but the documents has xrefs that</span>
<span class="gi">+        # must know their scope. A lookup key is essentially a specification of</span>
<span class="gi">+        # how to find a specific symbol.</span>
<span class="gi">+        symbols = []</span>
<span class="gi">+        s = self</span>
<span class="gi">+        while s.parent:</span>
<span class="gi">+            symbols.append(s)</span>
<span class="gi">+            s = s.parent</span>
<span class="gi">+        symbols.reverse()</span>
<span class="gi">+        key = []</span>
<span class="gi">+        for s in symbols:</span>
<span class="gi">+            nne = ASTNestedNameElement(s.identOrOp, s.templateArgs)</span>
<span class="gi">+            if s.declaration is not None:</span>
<span class="gi">+                key.append((nne, s.templateParams, s.declaration.get_newest_id()))</span>
<span class="gi">+            else:</span>
<span class="gi">+                key.append((nne, s.templateParams, None))</span>
<span class="gi">+        return LookupKey(key)</span>
<span class="gi">+</span>
<span class="gi">+    def get_full_nested_name(self) -&gt; ASTNestedName:</span>
<span class="gi">+        symbols = []</span>
<span class="gi">+        s = self</span>
<span class="gi">+        while s.parent:</span>
<span class="gi">+            symbols.append(s)</span>
<span class="gi">+            s = s.parent</span>
<span class="gi">+        symbols.reverse()</span>
<span class="gi">+        names = []</span>
<span class="gi">+        templates = []</span>
<span class="gi">+        for s in symbols:</span>
<span class="gi">+            names.append(ASTNestedNameElement(s.identOrOp, s.templateArgs))</span>
<span class="gi">+            templates.append(False)</span>
<span class="gi">+        return ASTNestedName(names, templates, rooted=False)</span>
<span class="gi">+</span>
<span class="gi">+    def _find_first_named_symbol(self, identOrOp: ASTIdentifier | ASTOperator,</span>
<span class="gi">+                                 templateParams: ASTTemplateParams | ASTTemplateIntroduction,</span>
<span class="gi">+                                 templateArgs: ASTTemplateArgs | None,</span>
<span class="gi">+                                 templateShorthand: bool, matchSelf: bool,</span>
<span class="gi">+                                 recurseInAnon: bool, correctPrimaryTemplateArgs: bool,</span>
<span class="gi">+                                 ) -&gt; Symbol | None:</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_print(&quot;_find_first_named_symbol -&gt;&quot;)</span>
<span class="gi">+        res = self._find_named_symbols(identOrOp, templateParams, templateArgs,</span>
<span class="gi">+                                       templateShorthand, matchSelf, recurseInAnon,</span>
<span class="gi">+                                       correctPrimaryTemplateArgs,</span>
<span class="gi">+                                       searchInSiblings=False)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return next(res)</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    def _find_named_symbols(self, identOrOp: ASTIdentifier | ASTOperator,</span>
<span class="gi">+                            templateParams: ASTTemplateParams | ASTTemplateIntroduction,</span>
<span class="gi">+                            templateArgs: ASTTemplateArgs,</span>
<span class="gi">+                            templateShorthand: bool, matchSelf: bool,</span>
<span class="gi">+                            recurseInAnon: bool, correctPrimaryTemplateArgs: bool,</span>
<span class="gi">+                            searchInSiblings: bool) -&gt; Iterator[Symbol]:</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;_find_named_symbols:&quot;)</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;self:&quot;)</span>
<span class="gi">+            logger.debug(self.to_string(Symbol.debug_indent + 1), end=&quot;&quot;)</span>
<span class="gi">+            Symbol.debug_print(&quot;identOrOp:                  &quot;, identOrOp)</span>
<span class="gi">+            Symbol.debug_print(&quot;templateParams:             &quot;, templateParams)</span>
<span class="gi">+            Symbol.debug_print(&quot;templateArgs:               &quot;, templateArgs)</span>
<span class="gi">+            Symbol.debug_print(&quot;templateShorthand:          &quot;, templateShorthand)</span>
<span class="gi">+            Symbol.debug_print(&quot;matchSelf:                  &quot;, matchSelf)</span>
<span class="gi">+            Symbol.debug_print(&quot;recurseInAnon:              &quot;, recurseInAnon)</span>
<span class="gi">+            Symbol.debug_print(&quot;correctPrimaryTemplateAargs:&quot;, correctPrimaryTemplateArgs)</span>
<span class="gi">+            Symbol.debug_print(&quot;searchInSiblings:           &quot;, searchInSiblings)</span>
<span class="gi">+</span>
<span class="gi">+        if correctPrimaryTemplateArgs:</span>
<span class="gi">+            if templateParams is not None and templateArgs is not None:</span>
<span class="gi">+                # If both are given, but it&#39;s not a specialization, then do lookup as if</span>
<span class="gi">+                # there is no argument list.</span>
<span class="gi">+                # For example: template&lt;typename T&gt; int A&lt;T&gt;::var;</span>
<span class="gi">+                if not _is_specialization(templateParams, templateArgs):</span>
<span class="gi">+                    templateArgs = None</span>
<span class="gi">+</span>
<span class="gi">+        def matches(s: Symbol) -&gt; bool:</span>
<span class="gi">+            if s.identOrOp != identOrOp:</span>
<span class="gi">+                return False</span>
<span class="gi">+            if (s.templateParams is None) != (templateParams is None):</span>
<span class="gi">+                if templateParams is not None:</span>
<span class="gi">+                    # we query with params, they must match params</span>
<span class="gi">+                    return False</span>
<span class="gi">+                if not templateShorthand:</span>
<span class="gi">+                    # we don&#39;t query with params, and we do care about them</span>
<span class="gi">+                    return False</span>
<span class="gi">+            if templateParams:</span>
<span class="gi">+                # TODO: do better comparison</span>
<span class="gi">+                if str(s.templateParams) != str(templateParams):</span>
<span class="gi">+                    return False</span>
<span class="gi">+            if (s.templateArgs is None) != (templateArgs is None):</span>
<span class="gi">+                return False</span>
<span class="gi">+            if s.templateArgs:</span>
<span class="gi">+                # TODO: do better comparison</span>
<span class="gi">+                if str(s.templateArgs) != str(templateArgs):</span>
<span class="gi">+                    return False</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        def candidates() -&gt; Iterator[Symbol]:</span>
<span class="gi">+            s = self</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_print(&quot;searching in self:&quot;)</span>
<span class="gi">+                logger.debug(s.to_string(Symbol.debug_indent + 1), end=&quot;&quot;)</span>
<span class="gi">+            while True:</span>
<span class="gi">+                if matchSelf:</span>
<span class="gi">+                    yield s</span>
<span class="gi">+                if recurseInAnon:</span>
<span class="gi">+                    yield from s.children_recurse_anon</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield from s._children</span>
<span class="gi">+</span>
<span class="gi">+                if s.siblingAbove is None:</span>
<span class="gi">+                    break</span>
<span class="gi">+                s = s.siblingAbove</span>
<span class="gi">+                if Symbol.debug_lookup:</span>
<span class="gi">+                    Symbol.debug_print(&quot;searching in sibling:&quot;)</span>
<span class="gi">+                    logger.debug(s.to_string(Symbol.debug_indent + 1), end=&quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        for s in candidates():</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_print(&quot;candidate:&quot;)</span>
<span class="gi">+                logger.debug(s.to_string(Symbol.debug_indent + 1), end=&quot;&quot;)</span>
<span class="gi">+            if matches(s):</span>
<span class="gi">+                if Symbol.debug_lookup:</span>
<span class="gi">+                    Symbol.debug_indent += 1</span>
<span class="gi">+                    Symbol.debug_print(&quot;matches&quot;)</span>
<span class="gi">+                    Symbol.debug_indent -= 3</span>
<span class="gi">+                yield s</span>
<span class="gi">+                if Symbol.debug_lookup:</span>
<span class="gi">+                    Symbol.debug_indent += 2</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent -= 2</span>
<span class="gi">+</span>
<span class="gi">+    def _symbol_lookup(</span>
<span class="gi">+        self,</span>
<span class="gi">+        nestedName: ASTNestedName,</span>
<span class="gi">+        templateDecls: list[Any],</span>
<span class="gi">+        onMissingQualifiedSymbol: Callable[</span>
<span class="gi">+            [Symbol, ASTIdentifier | ASTOperator, Any, ASTTemplateArgs], Symbol | None,</span>
<span class="gi">+        ],</span>
<span class="gi">+        strictTemplateParamArgLists: bool, ancestorLookupType: str,</span>
<span class="gi">+        templateShorthand: bool, matchSelf: bool,</span>
<span class="gi">+        recurseInAnon: bool, correctPrimaryTemplateArgs: bool,</span>
<span class="gi">+        searchInSiblings: bool,</span>
<span class="gi">+    ) -&gt; SymbolLookupResult:</span>
<span class="gi">+        # ancestorLookupType: if not None, specifies the target type of the lookup</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;_symbol_lookup:&quot;)</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;self:&quot;)</span>
<span class="gi">+            logger.debug(self.to_string(Symbol.debug_indent + 1), end=&quot;&quot;)</span>
<span class="gi">+            Symbol.debug_print(&quot;nestedName:        &quot;, nestedName)</span>
<span class="gi">+            Symbol.debug_print(&quot;templateDecls:     &quot;, &quot;,&quot;.join(str(t) for t in templateDecls))</span>
<span class="gi">+            Symbol.debug_print(&quot;strictTemplateParamArgLists:&quot;, strictTemplateParamArgLists)</span>
<span class="gi">+            Symbol.debug_print(&quot;ancestorLookupType:&quot;, ancestorLookupType)</span>
<span class="gi">+            Symbol.debug_print(&quot;templateShorthand: &quot;, templateShorthand)</span>
<span class="gi">+            Symbol.debug_print(&quot;matchSelf:         &quot;, matchSelf)</span>
<span class="gi">+            Symbol.debug_print(&quot;recurseInAnon:     &quot;, recurseInAnon)</span>
<span class="gi">+            Symbol.debug_print(&quot;correctPrimaryTemplateArgs: &quot;, correctPrimaryTemplateArgs)</span>
<span class="gi">+            Symbol.debug_print(&quot;searchInSiblings:  &quot;, searchInSiblings)</span>
<span class="gi">+</span>
<span class="gi">+        if strictTemplateParamArgLists:</span>
<span class="gi">+            # Each template argument list must have a template parameter list.</span>
<span class="gi">+            # But to declare a template there must be an additional template parameter list.</span>
<span class="gi">+            assert (nestedName.num_templates() == len(templateDecls) or</span>
<span class="gi">+                    nestedName.num_templates() + 1 == len(templateDecls))</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert len(templateDecls) &lt;= nestedName.num_templates() + 1</span>
<span class="gi">+</span>
<span class="gi">+        names = nestedName.names</span>
<span class="gi">+</span>
<span class="gi">+        # find the right starting point for lookup</span>
<span class="gi">+        parentSymbol = self</span>
<span class="gi">+        if nestedName.rooted:</span>
<span class="gi">+            while parentSymbol.parent:</span>
<span class="gi">+                parentSymbol = parentSymbol.parent</span>
<span class="gi">+        if ancestorLookupType is not None:</span>
<span class="gi">+            # walk up until we find the first identifier</span>
<span class="gi">+            firstName = names[0]</span>
<span class="gi">+            if not firstName.is_operator():</span>
<span class="gi">+                while parentSymbol.parent:</span>
<span class="gi">+                    if parentSymbol.find_identifier(firstName.identOrOp,</span>
<span class="gi">+                                                    matchSelf=matchSelf,</span>
<span class="gi">+                                                    recurseInAnon=recurseInAnon,</span>
<span class="gi">+                                                    searchInSiblings=searchInSiblings):</span>
<span class="gi">+                        # if we are in the scope of a constructor but wants to</span>
<span class="gi">+                        # reference the class we need to walk one extra up</span>
<span class="gi">+                        if (len(names) == 1 and ancestorLookupType == &#39;class&#39; and matchSelf and</span>
<span class="gi">+                                parentSymbol.parent and</span>
<span class="gi">+                                parentSymbol.parent.identOrOp == firstName.identOrOp):</span>
<span class="gi">+                            pass</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            break</span>
<span class="gi">+                    parentSymbol = parentSymbol.parent</span>
<span class="gi">+</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_print(&quot;starting point:&quot;)</span>
<span class="gi">+            logger.debug(parentSymbol.to_string(Symbol.debug_indent + 1), end=&quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # and now the actual lookup</span>
<span class="gi">+        iTemplateDecl = 0</span>
<span class="gi">+        for name in names[:-1]:</span>
<span class="gi">+            identOrOp = name.identOrOp</span>
<span class="gi">+            templateArgs = name.templateArgs</span>
<span class="gi">+            if strictTemplateParamArgLists:</span>
<span class="gi">+                # there must be a parameter list</span>
<span class="gi">+                if templateArgs:</span>
<span class="gi">+                    assert iTemplateDecl &lt; len(templateDecls)</span>
<span class="gi">+                    templateParams = templateDecls[iTemplateDecl]</span>
<span class="gi">+                    iTemplateDecl += 1</span>
<span class="gi">+                else:</span>
<span class="gi">+                    templateParams = None</span>
<span class="gi">+            else:</span>
<span class="gi">+                # take the next template parameter list if there is one</span>
<span class="gi">+                # otherwise it&#39;s ok</span>
<span class="gi">+                if templateArgs and iTemplateDecl &lt; len(templateDecls):</span>
<span class="gi">+                    templateParams = templateDecls[iTemplateDecl]</span>
<span class="gi">+                    iTemplateDecl += 1</span>
<span class="gi">+                else:</span>
<span class="gi">+                    templateParams = None</span>
<span class="gi">+</span>
<span class="gi">+            symbol = parentSymbol._find_first_named_symbol(</span>
<span class="gi">+                identOrOp,</span>
<span class="gi">+                templateParams, templateArgs,</span>
<span class="gi">+                templateShorthand=templateShorthand,</span>
<span class="gi">+                matchSelf=matchSelf,</span>
<span class="gi">+                recurseInAnon=recurseInAnon,</span>
<span class="gi">+                correctPrimaryTemplateArgs=correctPrimaryTemplateArgs)</span>
<span class="gi">+            if symbol is None:</span>
<span class="gi">+                symbol = onMissingQualifiedSymbol(parentSymbol, identOrOp,</span>
<span class="gi">+                                                  templateParams, templateArgs)</span>
<span class="gi">+                if symbol is None:</span>
<span class="gi">+                    if Symbol.debug_lookup:</span>
<span class="gi">+                        Symbol.debug_indent -= 2</span>
<span class="gi">+                    return None</span>
<span class="gi">+            # We have now matched part of a nested name, and need to match more</span>
<span class="gi">+            # so even if we should matchSelf before, we definitely shouldn&#39;t</span>
<span class="gi">+            # even more. (see also issue #2666)</span>
<span class="gi">+            matchSelf = False</span>
<span class="gi">+            parentSymbol = symbol</span>
<span class="gi">+</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_print(&quot;handle last name from:&quot;)</span>
<span class="gi">+            logger.debug(parentSymbol.to_string(Symbol.debug_indent + 1), end=&quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # handle the last name</span>
<span class="gi">+        name = names[-1]</span>
<span class="gi">+        identOrOp = name.identOrOp</span>
<span class="gi">+        templateArgs = name.templateArgs</span>
<span class="gi">+        if iTemplateDecl &lt; len(templateDecls):</span>
<span class="gi">+            assert iTemplateDecl + 1 == len(templateDecls)</span>
<span class="gi">+            templateParams = templateDecls[iTemplateDecl]</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert iTemplateDecl == len(templateDecls)</span>
<span class="gi">+            templateParams = None</span>
<span class="gi">+</span>
<span class="gi">+        symbols = parentSymbol._find_named_symbols(</span>
<span class="gi">+            identOrOp, templateParams, templateArgs,</span>
<span class="gi">+            templateShorthand=templateShorthand, matchSelf=matchSelf,</span>
<span class="gi">+            recurseInAnon=recurseInAnon, correctPrimaryTemplateArgs=False,</span>
<span class="gi">+            searchInSiblings=searchInSiblings)</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            symbols = list(symbols)  # type: ignore[assignment]</span>
<span class="gi">+            Symbol.debug_indent -= 2</span>
<span class="gi">+        return SymbolLookupResult(symbols, parentSymbol,</span>
<span class="gi">+                                  identOrOp, templateParams, templateArgs)</span>
<span class="gi">+</span>
<span class="gi">+    def _add_symbols(</span>
<span class="gi">+        self,</span>
<span class="gi">+        nestedName: ASTNestedName,</span>
<span class="gi">+        templateDecls: list[Any],</span>
<span class="gi">+        declaration: ASTDeclaration | None,</span>
<span class="gi">+        docname: str | None,</span>
<span class="gi">+        line: int | None,</span>
<span class="gi">+    ) -&gt; Symbol:</span>
<span class="gi">+        # Used for adding a whole path of symbols, where the last may or may not</span>
<span class="gi">+        # be an actual declaration.</span>
<span class="gi">+</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;_add_symbols:&quot;)</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;tdecls:&quot;, &quot;,&quot;.join(str(t) for t in templateDecls))</span>
<span class="gi">+            Symbol.debug_print(&quot;nn:       &quot;, nestedName)</span>
<span class="gi">+            Symbol.debug_print(&quot;decl:     &quot;, declaration)</span>
<span class="gi">+            Symbol.debug_print(f&quot;location: {docname}:{line}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        def onMissingQualifiedSymbol(parentSymbol: Symbol,</span>
<span class="gi">+                                     identOrOp: ASTIdentifier | ASTOperator,</span>
<span class="gi">+                                     templateParams: Any, templateArgs: ASTTemplateArgs,</span>
<span class="gi">+                                     ) -&gt; Symbol | None:</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_indent += 1</span>
<span class="gi">+                Symbol.debug_print(&quot;_add_symbols, onMissingQualifiedSymbol:&quot;)</span>
<span class="gi">+                Symbol.debug_indent += 1</span>
<span class="gi">+                Symbol.debug_print(&quot;templateParams:&quot;, templateParams)</span>
<span class="gi">+                Symbol.debug_print(&quot;identOrOp:     &quot;, identOrOp)</span>
<span class="gi">+                Symbol.debug_print(&quot;templateARgs:  &quot;, templateArgs)</span>
<span class="gi">+                Symbol.debug_indent -= 2</span>
<span class="gi">+            return Symbol(parent=parentSymbol, identOrOp=identOrOp,</span>
<span class="gi">+                          templateParams=templateParams,</span>
<span class="gi">+                          templateArgs=templateArgs, declaration=None,</span>
<span class="gi">+                          docname=None, line=None)</span>
<span class="gi">+</span>
<span class="gi">+        lookupResult = self._symbol_lookup(nestedName, templateDecls,</span>
<span class="gi">+                                           onMissingQualifiedSymbol,</span>
<span class="gi">+                                           strictTemplateParamArgLists=True,</span>
<span class="gi">+                                           ancestorLookupType=None,</span>
<span class="gi">+                                           templateShorthand=False,</span>
<span class="gi">+                                           matchSelf=False,</span>
<span class="gi">+                                           recurseInAnon=False,</span>
<span class="gi">+                                           correctPrimaryTemplateArgs=True,</span>
<span class="gi">+                                           searchInSiblings=False)</span>
<span class="gi">+        assert lookupResult is not None  # we create symbols all the way, so that can&#39;t happen</span>
<span class="gi">+        symbols = list(lookupResult.symbols)</span>
<span class="gi">+        if len(symbols) == 0:</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_print(&quot;_add_symbols, result, no symbol:&quot;)</span>
<span class="gi">+                Symbol.debug_indent += 1</span>
<span class="gi">+                Symbol.debug_print(&quot;templateParams:&quot;, lookupResult.templateParams)</span>
<span class="gi">+                Symbol.debug_print(&quot;identOrOp:     &quot;, lookupResult.identOrOp)</span>
<span class="gi">+                Symbol.debug_print(&quot;templateArgs:  &quot;, lookupResult.templateArgs)</span>
<span class="gi">+                Symbol.debug_print(&quot;declaration:   &quot;, declaration)</span>
<span class="gi">+                Symbol.debug_print(f&quot;location:      {docname}:{line}&quot;)</span>
<span class="gi">+                Symbol.debug_indent -= 1</span>
<span class="gi">+            symbol = Symbol(parent=lookupResult.parentSymbol,</span>
<span class="gi">+                            identOrOp=lookupResult.identOrOp,</span>
<span class="gi">+                            templateParams=lookupResult.templateParams,</span>
<span class="gi">+                            templateArgs=lookupResult.templateArgs,</span>
<span class="gi">+                            declaration=declaration,</span>
<span class="gi">+                            docname=docname, line=line)</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_indent -= 2</span>
<span class="gi">+            return symbol</span>
<span class="gi">+</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_print(&quot;_add_symbols, result, symbols:&quot;)</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;number symbols:&quot;, len(symbols))</span>
<span class="gi">+            Symbol.debug_indent -= 1</span>
<span class="gi">+</span>
<span class="gi">+        if not declaration:</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_print(&quot;no declaration&quot;)</span>
<span class="gi">+                Symbol.debug_indent -= 2</span>
<span class="gi">+            # good, just a scope creation</span>
<span class="gi">+            # TODO: what if we have more than one symbol?</span>
<span class="gi">+            return symbols[0]</span>
<span class="gi">+</span>
<span class="gi">+        noDecl = []</span>
<span class="gi">+        withDecl = []</span>
<span class="gi">+        dupDecl = []</span>
<span class="gi">+        for s in symbols:</span>
<span class="gi">+            if s.declaration is None:</span>
<span class="gi">+                noDecl.append(s)</span>
<span class="gi">+            elif s.isRedeclaration:</span>
<span class="gi">+                dupDecl.append(s)</span>
<span class="gi">+            else:</span>
<span class="gi">+                withDecl.append(s)</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_print(&quot;#noDecl:  &quot;, len(noDecl))</span>
<span class="gi">+            Symbol.debug_print(&quot;#withDecl:&quot;, len(withDecl))</span>
<span class="gi">+            Symbol.debug_print(&quot;#dupDecl: &quot;, len(dupDecl))</span>
<span class="gi">+        # With partial builds we may start with a large symbol tree stripped of declarations.</span>
<span class="gi">+        # Essentially any combination of noDecl, withDecl, and dupDecls seems possible.</span>
<span class="gi">+        # TODO: make partial builds fully work. What should happen when the primary symbol gets</span>
<span class="gi">+        #  deleted, and other duplicates exist? The full document should probably be rebuild.</span>
<span class="gi">+</span>
<span class="gi">+        # First check if one of those with a declaration matches.</span>
<span class="gi">+        # If it&#39;s a function, we need to compare IDs,</span>
<span class="gi">+        # otherwise there should be only one symbol with a declaration.</span>
<span class="gi">+        def makeCandSymbol() -&gt; Symbol:</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_print(&quot;begin: creating candidate symbol&quot;)</span>
<span class="gi">+            symbol = Symbol(parent=lookupResult.parentSymbol,</span>
<span class="gi">+                            identOrOp=lookupResult.identOrOp,</span>
<span class="gi">+                            templateParams=lookupResult.templateParams,</span>
<span class="gi">+                            templateArgs=lookupResult.templateArgs,</span>
<span class="gi">+                            declaration=declaration,</span>
<span class="gi">+                            docname=docname, line=line)</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_print(&quot;end:   creating candidate symbol&quot;)</span>
<span class="gi">+            return symbol</span>
<span class="gi">+        if len(withDecl) == 0:</span>
<span class="gi">+            candSymbol = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            candSymbol = makeCandSymbol()</span>
<span class="gi">+</span>
<span class="gi">+            def handleDuplicateDeclaration(symbol: Symbol, candSymbol: Symbol) -&gt; None:</span>
<span class="gi">+                if Symbol.debug_lookup:</span>
<span class="gi">+                    Symbol.debug_indent += 1</span>
<span class="gi">+                    Symbol.debug_print(&quot;redeclaration&quot;)</span>
<span class="gi">+                    Symbol.debug_indent -= 1</span>
<span class="gi">+                    Symbol.debug_indent -= 2</span>
<span class="gi">+                # Redeclaration of the same symbol.</span>
<span class="gi">+                # Let the new one be there, but raise an error to the client</span>
<span class="gi">+                # so it can use the real symbol as subscope.</span>
<span class="gi">+                # This will probably result in a duplicate id warning.</span>
<span class="gi">+                candSymbol.isRedeclaration = True</span>
<span class="gi">+                raise _DuplicateSymbolError(symbol, declaration)</span>
<span class="gi">+</span>
<span class="gi">+            if declaration.objectType != &quot;function&quot;:</span>
<span class="gi">+                assert len(withDecl) &lt;= 1</span>
<span class="gi">+                handleDuplicateDeclaration(withDecl[0], candSymbol)</span>
<span class="gi">+                # (not reachable)</span>
<span class="gi">+</span>
<span class="gi">+            # a function, so compare IDs</span>
<span class="gi">+            candId = declaration.get_newest_id()</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_print(&quot;candId:&quot;, candId)</span>
<span class="gi">+            for symbol in withDecl:</span>
<span class="gi">+                # but all existing must be functions as well,</span>
<span class="gi">+                # otherwise we declare it to be a duplicate</span>
<span class="gi">+                if symbol.declaration.objectType != &#39;function&#39;:</span>
<span class="gi">+                    handleDuplicateDeclaration(symbol, candSymbol)</span>
<span class="gi">+                    # (not reachable)</span>
<span class="gi">+                oldId = symbol.declaration.get_newest_id()</span>
<span class="gi">+                if Symbol.debug_lookup:</span>
<span class="gi">+                    Symbol.debug_print(&quot;oldId: &quot;, oldId)</span>
<span class="gi">+                if candId == oldId:</span>
<span class="gi">+                    handleDuplicateDeclaration(symbol, candSymbol)</span>
<span class="gi">+                    # (not reachable)</span>
<span class="gi">+            # no candidate symbol found with matching ID</span>
<span class="gi">+        # if there is an empty symbol, fill that one</span>
<span class="gi">+        if len(noDecl) == 0:</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_print(&quot;no match, no empty&quot;)</span>
<span class="gi">+                if candSymbol is not None:</span>
<span class="gi">+                    Symbol.debug_print(&quot;result is already created candSymbol&quot;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    Symbol.debug_print(&quot;result is makeCandSymbol()&quot;)</span>
<span class="gi">+                Symbol.debug_indent -= 2</span>
<span class="gi">+            if candSymbol is not None:</span>
<span class="gi">+                return candSymbol</span>
<span class="gi">+            else:</span>
<span class="gi">+                return makeCandSymbol()</span>
<span class="gi">+        else:</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_print(</span>
<span class="gi">+                    &quot;no match, but fill an empty declaration, candSybmol is not None?:&quot;,</span>
<span class="gi">+                    candSymbol is not None,</span>
<span class="gi">+                )</span>
<span class="gi">+                Symbol.debug_indent -= 2</span>
<span class="gi">+            if candSymbol is not None:</span>
<span class="gi">+                candSymbol.remove()</span>
<span class="gi">+            # assert len(noDecl) == 1</span>
<span class="gi">+            # TODO: enable assertion when we at some point find out how to do cleanup</span>
<span class="gi">+            # for now, just take the first one, it should work fine ... right?</span>
<span class="gi">+            symbol = noDecl[0]</span>
<span class="gi">+            # If someone first opened the scope, and then later</span>
<span class="gi">+            # declares it, e.g,</span>
<span class="gi">+            # .. namespace:: Test</span>
<span class="gi">+            # .. namespace:: nullptr</span>
<span class="gi">+            # .. class:: Test</span>
<span class="gi">+            symbol._fill_empty(declaration, docname, line)</span>
<span class="gi">+            return symbol</span>
<span class="gi">+</span>
<span class="gi">+    def merge_with(self, other: Symbol, docnames: list[str],</span>
<span class="gi">+                   env: BuildEnvironment) -&gt; None:</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;merge_with:&quot;)</span>
<span class="gi">+        assert other is not None</span>
<span class="gi">+</span>
<span class="gi">+        def unconditionalAdd(self: Symbol, otherChild: Symbol) -&gt; None:</span>
<span class="gi">+            # TODO: hmm, should we prune by docnames?</span>
<span class="gi">+            self._children.append(otherChild)</span>
<span class="gi">+            otherChild.parent = self</span>
<span class="gi">+            otherChild._assert_invariants()</span>
<span class="gi">+</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+        for otherChild in other._children:</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_print(&quot;otherChild:\n&quot;, otherChild.to_string(Symbol.debug_indent))</span>
<span class="gi">+                Symbol.debug_indent += 1</span>
<span class="gi">+            if otherChild.isRedeclaration:</span>
<span class="gi">+                unconditionalAdd(self, otherChild)</span>
<span class="gi">+                if Symbol.debug_lookup:</span>
<span class="gi">+                    Symbol.debug_print(&quot;isRedeclaration&quot;)</span>
<span class="gi">+                    Symbol.debug_indent -= 1</span>
<span class="gi">+                continue</span>
<span class="gi">+            candiateIter = self._find_named_symbols(</span>
<span class="gi">+                identOrOp=otherChild.identOrOp,</span>
<span class="gi">+                templateParams=otherChild.templateParams,</span>
<span class="gi">+                templateArgs=otherChild.templateArgs,</span>
<span class="gi">+                templateShorthand=False, matchSelf=False,</span>
<span class="gi">+                recurseInAnon=False, correctPrimaryTemplateArgs=False,</span>
<span class="gi">+                searchInSiblings=False)</span>
<span class="gi">+            candidates = list(candiateIter)</span>
<span class="gi">+</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_print(&quot;raw candidate symbols:&quot;, len(candidates))</span>
<span class="gi">+            symbols = [s for s in candidates if not s.isRedeclaration]</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_print(&quot;non-duplicate candidate symbols:&quot;, len(symbols))</span>
<span class="gi">+</span>
<span class="gi">+            if len(symbols) == 0:</span>
<span class="gi">+                unconditionalAdd(self, otherChild)</span>
<span class="gi">+                if Symbol.debug_lookup:</span>
<span class="gi">+                    Symbol.debug_indent -= 1</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            ourChild = None</span>
<span class="gi">+            if otherChild.declaration is None:</span>
<span class="gi">+                if Symbol.debug_lookup:</span>
<span class="gi">+                    Symbol.debug_print(&quot;no declaration in other child&quot;)</span>
<span class="gi">+                ourChild = symbols[0]</span>
<span class="gi">+            else:</span>
<span class="gi">+                queryId = otherChild.declaration.get_newest_id()</span>
<span class="gi">+                if Symbol.debug_lookup:</span>
<span class="gi">+                    Symbol.debug_print(&quot;queryId:  &quot;, queryId)</span>
<span class="gi">+                for symbol in symbols:</span>
<span class="gi">+                    if symbol.declaration is None:</span>
<span class="gi">+                        if Symbol.debug_lookup:</span>
<span class="gi">+                            Symbol.debug_print(&quot;empty candidate&quot;)</span>
<span class="gi">+                        # if in the end we have non-matching, but have an empty one,</span>
<span class="gi">+                        # then just continue with that</span>
<span class="gi">+                        ourChild = symbol</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    candId = symbol.declaration.get_newest_id()</span>
<span class="gi">+                    if Symbol.debug_lookup:</span>
<span class="gi">+                        Symbol.debug_print(&quot;candidate:&quot;, candId)</span>
<span class="gi">+                    if candId == queryId:</span>
<span class="gi">+                        ourChild = symbol</span>
<span class="gi">+                        break</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_indent -= 1</span>
<span class="gi">+            if ourChild is None:</span>
<span class="gi">+                unconditionalAdd(self, otherChild)</span>
<span class="gi">+                continue</span>
<span class="gi">+            if otherChild.declaration and otherChild.docname in docnames:</span>
<span class="gi">+                if not ourChild.declaration:</span>
<span class="gi">+                    ourChild._fill_empty(otherChild.declaration,</span>
<span class="gi">+                                         otherChild.docname, otherChild.line)</span>
<span class="gi">+                elif ourChild.docname != otherChild.docname:</span>
<span class="gi">+                    name = str(ourChild.declaration)</span>
<span class="gi">+                    msg = __(&quot;Duplicate C++ declaration, also defined at %s:%s.\n&quot;</span>
<span class="gi">+                             &quot;Declaration is &#39;.. cpp:%s:: %s&#39;.&quot;)</span>
<span class="gi">+                    msg = msg % (ourChild.docname, ourChild.line,</span>
<span class="gi">+                                 ourChild.declaration.directiveType, name)</span>
<span class="gi">+                    logger.warning(msg, location=(otherChild.docname, otherChild.line))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if (otherChild.declaration.objectType ==</span>
<span class="gi">+                            ourChild.declaration.objectType and</span>
<span class="gi">+                            otherChild.declaration.objectType in</span>
<span class="gi">+                            (&#39;templateParam&#39;, &#39;functionParam&#39;) and</span>
<span class="gi">+                            ourChild.parent.declaration == otherChild.parent.declaration):</span>
<span class="gi">+                        # `ourChild` was just created during merging by the call</span>
<span class="gi">+                        # to `_fill_empty` on the parent and can be ignored.</span>
<span class="gi">+                        pass</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        # Both have declarations, and in the same docname.</span>
<span class="gi">+                        # This can apparently happen, it should be safe to</span>
<span class="gi">+                        # just ignore it, right?</span>
<span class="gi">+                        # Hmm, only on duplicate declarations, right?</span>
<span class="gi">+                        msg = &quot;Internal C++ domain error during symbol merging.\n&quot;</span>
<span class="gi">+                        msg += &quot;ourChild:\n&quot; + ourChild.to_string(1)</span>
<span class="gi">+                        msg += &quot;\notherChild:\n&quot; + otherChild.to_string(1)</span>
<span class="gi">+                        logger.warning(msg, location=otherChild.docname)</span>
<span class="gi">+            ourChild.merge_with(otherChild, docnames, env)</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent -= 2</span>
<span class="gi">+</span>
<span class="gi">+    def add_name(self, nestedName: ASTNestedName,</span>
<span class="gi">+                 templatePrefix: ASTTemplateDeclarationPrefix | None = None) -&gt; Symbol:</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;add_name:&quot;)</span>
<span class="gi">+        if templatePrefix:</span>
<span class="gi">+            templateDecls = templatePrefix.templates</span>
<span class="gi">+        else:</span>
<span class="gi">+            templateDecls = []</span>
<span class="gi">+        res = self._add_symbols(nestedName, templateDecls,</span>
<span class="gi">+                                declaration=None, docname=None, line=None)</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent -= 1</span>
<span class="gi">+        return res</span>
<span class="gi">+</span>
<span class="gi">+    def add_declaration(self, declaration: ASTDeclaration,</span>
<span class="gi">+                        docname: str, line: int) -&gt; Symbol:</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;add_declaration:&quot;)</span>
<span class="gi">+        assert declaration is not None</span>
<span class="gi">+        assert docname is not None</span>
<span class="gi">+        assert line is not None</span>
<span class="gi">+        nestedName = declaration.name</span>
<span class="gi">+        if declaration.templatePrefix:</span>
<span class="gi">+            templateDecls = declaration.templatePrefix.templates</span>
<span class="gi">+        else:</span>
<span class="gi">+            templateDecls = []</span>
<span class="gi">+        res = self._add_symbols(nestedName, templateDecls, declaration, docname, line)</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent -= 1</span>
<span class="gi">+        return res</span>
<span class="gi">+</span>
<span class="gi">+    def find_identifier(self, identOrOp: ASTIdentifier | ASTOperator,</span>
<span class="gi">+                        matchSelf: bool, recurseInAnon: bool, searchInSiblings: bool,</span>
<span class="gi">+                        ) -&gt; Symbol | None:</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;find_identifier:&quot;)</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;identOrOp:       &quot;, identOrOp)</span>
<span class="gi">+            Symbol.debug_print(&quot;matchSelf:       &quot;, matchSelf)</span>
<span class="gi">+            Symbol.debug_print(&quot;recurseInAnon:   &quot;, recurseInAnon)</span>
<span class="gi">+            Symbol.debug_print(&quot;searchInSiblings:&quot;, searchInSiblings)</span>
<span class="gi">+            logger.debug(self.to_string(Symbol.debug_indent + 1), end=&quot;&quot;)</span>
<span class="gi">+            Symbol.debug_indent -= 2</span>
<span class="gi">+        current = self</span>
<span class="gi">+        while current is not None:</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_indent += 2</span>
<span class="gi">+                Symbol.debug_print(&quot;trying:&quot;)</span>
<span class="gi">+                logger.debug(current.to_string(Symbol.debug_indent + 1), end=&quot;&quot;)</span>
<span class="gi">+                Symbol.debug_indent -= 2</span>
<span class="gi">+            if matchSelf and current.identOrOp == identOrOp:</span>
<span class="gi">+                return current</span>
<span class="gi">+            children = current.children_recurse_anon if recurseInAnon else current._children</span>
<span class="gi">+            for s in children:</span>
<span class="gi">+                if s.identOrOp == identOrOp:</span>
<span class="gi">+                    return s</span>
<span class="gi">+            if not searchInSiblings:</span>
<span class="gi">+                break</span>
<span class="gi">+            current = current.siblingAbove</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def direct_lookup(self, key: LookupKey) -&gt; Symbol:</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;direct_lookup:&quot;)</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+        s = self</span>
<span class="gi">+        for name, templateParams, id_ in key.data:</span>
<span class="gi">+            if id_ is not None:</span>
<span class="gi">+                res = None</span>
<span class="gi">+                for cand in s._children:</span>
<span class="gi">+                    if cand.declaration is None:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    if cand.declaration.get_newest_id() == id_:</span>
<span class="gi">+                        res = cand</span>
<span class="gi">+                        break</span>
<span class="gi">+                s = res</span>
<span class="gi">+            else:</span>
<span class="gi">+                identOrOp = name.identOrOp</span>
<span class="gi">+                templateArgs = name.templateArgs</span>
<span class="gi">+                s = s._find_first_named_symbol(identOrOp,</span>
<span class="gi">+                                               templateParams, templateArgs,</span>
<span class="gi">+                                               templateShorthand=False,</span>
<span class="gi">+                                               matchSelf=False,</span>
<span class="gi">+                                               recurseInAnon=False,</span>
<span class="gi">+                                               correctPrimaryTemplateArgs=False)</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_print(&quot;name:          &quot;, name)</span>
<span class="gi">+                Symbol.debug_print(&quot;templateParams:&quot;, templateParams)</span>
<span class="gi">+                Symbol.debug_print(&quot;id:            &quot;, id_)</span>
<span class="gi">+                if s is not None:</span>
<span class="gi">+                    logger.debug(s.to_string(Symbol.debug_indent + 1), end=&quot;&quot;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    Symbol.debug_print(&quot;not found&quot;)</span>
<span class="gi">+            if s is None:</span>
<span class="gi">+                if Symbol.debug_lookup:</span>
<span class="gi">+                    Symbol.debug_indent -= 2</span>
<span class="gi">+                return None</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent -= 2</span>
<span class="gi">+        return s</span>
<span class="gi">+</span>
<span class="gi">+    def find_name(</span>
<span class="gi">+        self,</span>
<span class="gi">+        nestedName: ASTNestedName,</span>
<span class="gi">+        templateDecls: list[Any],</span>
<span class="gi">+        typ: str,</span>
<span class="gi">+        templateShorthand: bool,</span>
<span class="gi">+        matchSelf: bool,</span>
<span class="gi">+        recurseInAnon: bool,</span>
<span class="gi">+        searchInSiblings: bool,</span>
<span class="gi">+    ) -&gt; tuple[list[Symbol] | None, str]:</span>
<span class="gi">+        # templateShorthand: missing template parameter lists for templates is ok</span>
<span class="gi">+        # If the first component is None,</span>
<span class="gi">+        # then the second component _may_ be a string explaining why.</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;find_name:&quot;)</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;self:&quot;)</span>
<span class="gi">+            logger.debug(self.to_string(Symbol.debug_indent + 1), end=&quot;&quot;)</span>
<span class="gi">+            Symbol.debug_print(&quot;nestedName:       &quot;, nestedName)</span>
<span class="gi">+            Symbol.debug_print(&quot;templateDecls:    &quot;, templateDecls)</span>
<span class="gi">+            Symbol.debug_print(&quot;typ:              &quot;, typ)</span>
<span class="gi">+            Symbol.debug_print(&quot;templateShorthand:&quot;, templateShorthand)</span>
<span class="gi">+            Symbol.debug_print(&quot;matchSelf:        &quot;, matchSelf)</span>
<span class="gi">+            Symbol.debug_print(&quot;recurseInAnon:    &quot;, recurseInAnon)</span>
<span class="gi">+            Symbol.debug_print(&quot;searchInSiblings: &quot;, searchInSiblings)</span>
<span class="gi">+</span>
<span class="gi">+        class QualifiedSymbolIsTemplateParam(Exception):</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        def onMissingQualifiedSymbol(parentSymbol: Symbol,</span>
<span class="gi">+                                     identOrOp: ASTIdentifier | ASTOperator,</span>
<span class="gi">+                                     templateParams: Any,</span>
<span class="gi">+                                     templateArgs: ASTTemplateArgs) -&gt; Symbol | None:</span>
<span class="gi">+            # TODO: Maybe search without template args?</span>
<span class="gi">+            #       Though, the correctPrimaryTemplateArgs does</span>
<span class="gi">+            #       that for primary templates.</span>
<span class="gi">+            #       Is there another case where it would be good?</span>
<span class="gi">+            if parentSymbol.declaration is not None:</span>
<span class="gi">+                if parentSymbol.declaration.objectType == &#39;templateParam&#39;:</span>
<span class="gi">+                    raise QualifiedSymbolIsTemplateParam</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            lookupResult = self._symbol_lookup(nestedName, templateDecls,</span>
<span class="gi">+                                               onMissingQualifiedSymbol,</span>
<span class="gi">+                                               strictTemplateParamArgLists=False,</span>
<span class="gi">+                                               ancestorLookupType=typ,</span>
<span class="gi">+                                               templateShorthand=templateShorthand,</span>
<span class="gi">+                                               matchSelf=matchSelf,</span>
<span class="gi">+                                               recurseInAnon=recurseInAnon,</span>
<span class="gi">+                                               correctPrimaryTemplateArgs=False,</span>
<span class="gi">+                                               searchInSiblings=searchInSiblings)</span>
<span class="gi">+        except QualifiedSymbolIsTemplateParam:</span>
<span class="gi">+            return None, &quot;templateParamInQualified&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if lookupResult is None:</span>
<span class="gi">+            # if it was a part of the qualification that could not be found</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_indent -= 2</span>
<span class="gi">+            return None, None</span>
<span class="gi">+</span>
<span class="gi">+        res = list(lookupResult.symbols)</span>
<span class="gi">+        if len(res) != 0:</span>
<span class="gi">+            if Symbol.debug_lookup:</span>
<span class="gi">+                Symbol.debug_indent -= 2</span>
<span class="gi">+            return res, None</span>
<span class="gi">+</span>
<span class="gi">+        if lookupResult.parentSymbol.declaration is not None:</span>
<span class="gi">+            if lookupResult.parentSymbol.declaration.objectType == &#39;templateParam&#39;:</span>
<span class="gi">+                return None, &quot;templateParamInQualified&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # try without template params and args</span>
<span class="gi">+        symbol = lookupResult.parentSymbol._find_first_named_symbol(</span>
<span class="gi">+            lookupResult.identOrOp, None, None,</span>
<span class="gi">+            templateShorthand=templateShorthand, matchSelf=matchSelf,</span>
<span class="gi">+            recurseInAnon=recurseInAnon, correctPrimaryTemplateArgs=False)</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent -= 2</span>
<span class="gi">+        if symbol is not None:</span>
<span class="gi">+            return [symbol], None</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None, None</span>
<span class="gi">+</span>
<span class="gi">+    def find_declaration(self, declaration: ASTDeclaration, typ: str, templateShorthand: bool,</span>
<span class="gi">+                         matchSelf: bool, recurseInAnon: bool) -&gt; Symbol | None:</span>
<span class="gi">+        # templateShorthand: missing template parameter lists for templates is ok</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent += 1</span>
<span class="gi">+            Symbol.debug_print(&quot;find_declaration:&quot;)</span>
<span class="gi">+        nestedName = declaration.name</span>
<span class="gi">+        if declaration.templatePrefix:</span>
<span class="gi">+            templateDecls = declaration.templatePrefix.templates</span>
<span class="gi">+        else:</span>
<span class="gi">+            templateDecls = []</span>
<span class="gi">+</span>
<span class="gi">+        def onMissingQualifiedSymbol(parentSymbol: Symbol,</span>
<span class="gi">+                                     identOrOp: ASTIdentifier | ASTOperator,</span>
<span class="gi">+                                     templateParams: Any,</span>
<span class="gi">+                                     templateArgs: ASTTemplateArgs) -&gt; Symbol | None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        lookupResult = self._symbol_lookup(nestedName, templateDecls,</span>
<span class="gi">+                                           onMissingQualifiedSymbol,</span>
<span class="gi">+                                           strictTemplateParamArgLists=False,</span>
<span class="gi">+                                           ancestorLookupType=typ,</span>
<span class="gi">+                                           templateShorthand=templateShorthand,</span>
<span class="gi">+                                           matchSelf=matchSelf,</span>
<span class="gi">+                                           recurseInAnon=recurseInAnon,</span>
<span class="gi">+                                           correctPrimaryTemplateArgs=False,</span>
<span class="gi">+                                           searchInSiblings=False)</span>
<span class="gi">+        if Symbol.debug_lookup:</span>
<span class="gi">+            Symbol.debug_indent -= 1</span>
<span class="gi">+        if lookupResult is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        symbols = list(lookupResult.symbols)</span>
<span class="gi">+        if len(symbols) == 0:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        querySymbol = Symbol(parent=lookupResult.parentSymbol,</span>
<span class="gi">+                             identOrOp=lookupResult.identOrOp,</span>
<span class="gi">+                             templateParams=lookupResult.templateParams,</span>
<span class="gi">+                             templateArgs=lookupResult.templateArgs,</span>
<span class="gi">+                             declaration=declaration,</span>
<span class="gi">+                             docname=&#39;fakeDocnameForQuery&#39;,</span>
<span class="gi">+                             line=42)</span>
<span class="gi">+        queryId = declaration.get_newest_id()</span>
<span class="gi">+        for symbol in symbols:</span>
<span class="gi">+            if symbol.declaration is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+            candId = symbol.declaration.get_newest_id()</span>
<span class="gi">+            if candId == queryId:</span>
<span class="gi">+                querySymbol.remove()</span>
<span class="gi">+                return symbol</span>
<span class="gi">+        querySymbol.remove()</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def to_string(self, indent: int) -&gt; str:</span>
<span class="gi">+        res = [Symbol.debug_indent_string * indent]</span>
<span class="gi">+        if not self.parent:</span>
<span class="gi">+            res.append(&#39;::&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self.templateParams:</span>
<span class="gi">+                res.append(str(self.templateParams))</span>
<span class="gi">+                res.append(&#39;\n&#39;)</span>
<span class="gi">+                res.append(Symbol.debug_indent_string * indent)</span>
<span class="gi">+            if self.identOrOp:</span>
<span class="gi">+                res.append(str(self.identOrOp))</span>
<span class="gi">+            else:</span>
<span class="gi">+                res.append(str(self.declaration))</span>
<span class="gi">+            if self.templateArgs:</span>
<span class="gi">+                res.append(str(self.templateArgs))</span>
<span class="gi">+            if self.declaration:</span>
<span class="gi">+                res.append(&quot;: &quot;)</span>
<span class="gi">+                if self.isRedeclaration:</span>
<span class="gi">+                    res.append(&#39;!!duplicate!! &#39;)</span>
<span class="gi">+                res.append(&quot;{&quot; + self.declaration.objectType + &quot;} &quot;)</span>
<span class="gi">+                res.append(str(self.declaration))</span>
<span class="gi">+        if self.docname:</span>
<span class="gi">+            res.append(&#39;\t(&#39;)</span>
<span class="gi">+            res.append(self.docname)</span>
<span class="gi">+            res.append(&#39;)&#39;)</span>
<span class="gi">+        res.append(&#39;\n&#39;)</span>
<span class="gi">+        return &#39;&#39;.join(res)</span>
<span class="gi">+</span>
<span class="gi">+    def dump(self, indent: int) -&gt; str:</span>
<span class="gi">+        return &#39;&#39;.join([</span>
<span class="gi">+            self.to_string(indent),</span>
<span class="gi">+            *(c.dump(indent + 1) for c in self._children),</span>
<span class="gi">+        ])</span>
<span class="gh">diff --git a/sphinx/domains/index.py b/sphinx/domains/index.py</span>
<span class="gh">index 312617719..67cc4050a 100644</span>
<span class="gd">--- a/sphinx/domains/index.py</span>
<span class="gi">+++ b/sphinx/domains/index.py</span>
<span class="gu">@@ -1,44 +1,128 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The index domain.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any, ClassVar
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.parsers.rst import directives
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.domains import Domain
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.docutils import ReferenceRole, SphinxDirective
<span class="w"> </span>from sphinx.util.index_entries import split_index_msg
<span class="w"> </span>from sphinx.util.nodes import process_index_entry
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Iterable
<span class="gi">+</span>
<span class="w"> </span>    from docutils.nodes import Node, system_message
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata, OptionSpec
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="w"> </span>class IndexDomain(Domain):
<span class="w"> </span>    &quot;&quot;&quot;Index domain.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name = &#39;index&#39;
<span class="w"> </span>    label = &#39;index&#39;

<span class="gd">-    def process_doc(self, env: BuildEnvironment, docname: str, document: Node</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    @property</span>
<span class="gi">+    def entries(self) -&gt; dict[str, list[tuple[str, str, str, str, str | None]]]:</span>
<span class="gi">+        return self.data.setdefault(&#39;entries&#39;, {})</span>
<span class="gi">+</span>
<span class="gi">+    def clear_doc(self, docname: str) -&gt; None:</span>
<span class="gi">+        self.entries.pop(docname, None)</span>
<span class="gi">+</span>
<span class="gi">+    def merge_domaindata(self, docnames: Iterable[str], otherdata: dict[str, Any]) -&gt; None:</span>
<span class="gi">+        for docname in docnames:</span>
<span class="gi">+            self.entries[docname] = otherdata[&#39;entries&#39;][docname]</span>
<span class="gi">+</span>
<span class="gi">+    def process_doc(self, env: BuildEnvironment, docname: str, document: Node) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Process a document after it is read by the environment.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        entries = self.entries.setdefault(env.docname, [])</span>
<span class="gi">+        for node in list(document.findall(addnodes.index)):</span>
<span class="gi">+            try:</span>
<span class="gi">+                for (entry_type, value, _target_id, _main, _category_key) in node[&#39;entries&#39;]:</span>
<span class="gi">+                    split_index_msg(entry_type, value)</span>
<span class="gi">+            except ValueError as exc:</span>
<span class="gi">+                logger.warning(str(exc), location=node)</span>
<span class="gi">+                node.parent.remove(node)</span>
<span class="gi">+            else:</span>
<span class="gi">+                for entry in node[&#39;entries&#39;]:</span>
<span class="gi">+                    entries.append(entry)</span>


<span class="w"> </span>class IndexDirective(SphinxDirective):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Directive to add entries to the index.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    has_content = False
<span class="w"> </span>    required_arguments = 1
<span class="w"> </span>    optional_arguments = 0
<span class="w"> </span>    final_argument_whitespace = True
<span class="gd">-    option_spec: ClassVar[OptionSpec] = {&#39;name&#39;: directives.unchanged}</span>
<span class="gi">+    option_spec: ClassVar[OptionSpec] = {</span>
<span class="gi">+        &#39;name&#39;: directives.unchanged,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        arguments = self.arguments[0].split(&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;name&#39; in self.options:</span>
<span class="gi">+            targetname = self.options[&#39;name&#39;]</span>
<span class="gi">+            targetnode = nodes.target(&#39;&#39;, &#39;&#39;, names=[targetname])</span>
<span class="gi">+        else:</span>
<span class="gi">+            targetid = &#39;index-%s&#39; % self.env.new_serialno(&#39;index&#39;)</span>
<span class="gi">+            targetnode = nodes.target(&#39;&#39;, &#39;&#39;, ids=[targetid])</span>
<span class="gi">+</span>
<span class="gi">+        self.state.document.note_explicit_target(targetnode)</span>
<span class="gi">+        indexnode = addnodes.index()</span>
<span class="gi">+        indexnode[&#39;entries&#39;] = []</span>
<span class="gi">+        indexnode[&#39;inline&#39;] = False</span>
<span class="gi">+        self.set_source_info(indexnode)</span>
<span class="gi">+        for entry in arguments:</span>
<span class="gi">+            indexnode[&#39;entries&#39;].extend(process_index_entry(entry, targetnode[&#39;ids&#39;][0]))</span>
<span class="gi">+        return [indexnode, targetnode]</span>


<span class="w"> </span>class IndexRole(ReferenceRole):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+        target_id = &#39;index-%s&#39; % self.env.new_serialno(&#39;index&#39;)</span>
<span class="gi">+        if self.has_explicit_title:</span>
<span class="gi">+            # if an explicit target is given, process it as a full entry</span>
<span class="gi">+            title = self.title</span>
<span class="gi">+            entries = process_index_entry(self.target, target_id)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # otherwise we just create a single entry</span>
<span class="gi">+            if self.target.startswith(&#39;!&#39;):</span>
<span class="gi">+                title = self.title[1:]</span>
<span class="gi">+                entries = [(&#39;single&#39;, self.target[1:], target_id, &#39;main&#39;, None)]</span>
<span class="gi">+            else:</span>
<span class="gi">+                title = self.title</span>
<span class="gi">+                entries = [(&#39;single&#39;, self.target, target_id, &#39;&#39;, None)]</span>
<span class="gi">+</span>
<span class="gi">+        index = addnodes.index(entries=entries)</span>
<span class="gi">+        target = nodes.target(&#39;&#39;, &#39;&#39;, ids=[target_id])</span>
<span class="gi">+        text = nodes.Text(title)</span>
<span class="gi">+        self.set_source_info(index)</span>
<span class="gi">+        return [index, target, text], []</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_domain(IndexDomain)</span>
<span class="gi">+    app.add_directive(&#39;index&#39;, IndexDirective)</span>
<span class="gi">+    app.add_role(&#39;index&#39;, IndexRole())</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;env_version&#39;: 1,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/domains/javascript.py b/sphinx/domains/javascript.py</span>
<span class="gh">index 760e3b217..540b7a6c6 100644</span>
<span class="gd">--- a/sphinx/domains/javascript.py</span>
<span class="gi">+++ b/sphinx/domains/javascript.py</span>
<span class="gu">@@ -1,9 +1,13 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The JavaScript domain.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import contextlib
<span class="w"> </span>from typing import TYPE_CHECKING, Any, ClassVar, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.parsers.rst import directives
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.directives import ObjectDescription
<span class="w"> </span>from sphinx.domains import Domain, ObjType
<span class="gu">@@ -14,14 +18,18 @@ from sphinx.util import logging</span>
<span class="w"> </span>from sphinx.util.docfields import Field, GroupedField, TypedField
<span class="w"> </span>from sphinx.util.docutils import SphinxDirective
<span class="w"> </span>from sphinx.util.nodes import make_id, make_refnode
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Iterator
<span class="gi">+</span>
<span class="w"> </span>    from docutils.nodes import Element, Node
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.addnodes import desc_signature, pending_xref
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.builders import Builder
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata, OptionSpec
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="gu">@@ -29,25 +37,142 @@ class JSObject(ObjectDescription[tuple[str, str]]):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Description of a JavaScript object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    #: If set to ``True`` this object is callable and a `desc_parameterlist` is</span>
<span class="gi">+    #: added</span>
<span class="w"> </span>    has_arguments = False
<span class="gi">+</span>
<span class="gi">+    #: If ``allow_nesting`` is ``True``, the object prefixes will be accumulated</span>
<span class="gi">+    #: based on directive nesting</span>
<span class="w"> </span>    allow_nesting = False
<span class="gd">-    option_spec: ClassVar[OptionSpec] = {&#39;no-index&#39;: directives.flag,</span>
<span class="gd">-        &#39;no-index-entry&#39;: directives.flag, &#39;no-contents-entry&#39;: directives.</span>
<span class="gd">-        flag, &#39;no-typesetting&#39;: directives.flag, &#39;noindex&#39;: directives.flag,</span>
<span class="gd">-        &#39;noindexentry&#39;: directives.flag, &#39;nocontentsentry&#39;: directives.flag,</span>
<span class="gd">-        &#39;single-line-parameter-list&#39;: directives.flag}</span>
<span class="gd">-</span>
<span class="gd">-    def handle_signature(self, sig: str, signode: desc_signature) -&gt;tuple[</span>
<span class="gd">-        str, str]:</span>
<span class="gi">+</span>
<span class="gi">+    option_spec: ClassVar[OptionSpec] = {</span>
<span class="gi">+        &#39;no-index&#39;: directives.flag,</span>
<span class="gi">+        &#39;no-index-entry&#39;: directives.flag,</span>
<span class="gi">+        &#39;no-contents-entry&#39;: directives.flag,</span>
<span class="gi">+        &#39;no-typesetting&#39;: directives.flag,</span>
<span class="gi">+        &#39;noindex&#39;: directives.flag,</span>
<span class="gi">+        &#39;noindexentry&#39;: directives.flag,</span>
<span class="gi">+        &#39;nocontentsentry&#39;: directives.flag,</span>
<span class="gi">+        &#39;single-line-parameter-list&#39;: directives.flag,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def get_display_prefix(self) -&gt; list[Node]:</span>
<span class="gi">+        #: what is displayed right before the documentation entry</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    def handle_signature(self, sig: str, signode: desc_signature) -&gt; tuple[str, str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Breaks down construct signatures

<span class="w"> </span>        Parses out prefix and argument list from construct definition. The
<span class="w"> </span>        namespace and class will be determined by the nesting of domain
<span class="w"> </span>        directives.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        sig = sig.strip()</span>
<span class="gi">+        if &#39;(&#39; in sig and sig[-1:] == &#39;)&#39;:</span>
<span class="gi">+            member, arglist = sig.split(&#39;(&#39;, 1)</span>
<span class="gi">+            member = member.strip()</span>
<span class="gi">+            arglist = arglist[:-1].strip()</span>
<span class="gi">+        else:</span>
<span class="gi">+            member = sig</span>
<span class="gi">+            arglist = None</span>
<span class="gi">+        # If construct is nested, prefix the current prefix</span>
<span class="gi">+        prefix = self.env.ref_context.get(&#39;js:object&#39;, None)</span>
<span class="gi">+        mod_name = self.env.ref_context.get(&#39;js:module&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        name = member</span>
<span class="gi">+        try:</span>
<span class="gi">+            member_prefix, member_name = member.rsplit(&#39;.&#39;, 1)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            member_name = name</span>
<span class="gi">+            member_prefix = &#39;&#39;</span>
<span class="gi">+        finally:</span>
<span class="gi">+            name = member_name</span>
<span class="gi">+            if prefix and member_prefix:</span>
<span class="gi">+                prefix = f&#39;{prefix}.{member_prefix}&#39;</span>
<span class="gi">+            elif prefix is None and member_prefix:</span>
<span class="gi">+                prefix = member_prefix</span>
<span class="gi">+        fullname = name</span>
<span class="gi">+        if prefix:</span>
<span class="gi">+            fullname = f&#39;{prefix}.{name}&#39;</span>

<span class="gd">-    def before_content(self) -&gt;None:</span>
<span class="gi">+        signode[&#39;module&#39;] = mod_name</span>
<span class="gi">+        signode[&#39;object&#39;] = prefix</span>
<span class="gi">+        signode[&#39;fullname&#39;] = fullname</span>
<span class="gi">+</span>
<span class="gi">+        max_len = (self.env.config.javascript_maximum_signature_line_length</span>
<span class="gi">+                   or self.env.config.maximum_signature_line_length</span>
<span class="gi">+                   or 0)</span>
<span class="gi">+        multi_line_parameter_list = (</span>
<span class="gi">+            &#39;single-line-parameter-list&#39; not in self.options</span>
<span class="gi">+            and (len(sig) &gt; max_len &gt; 0)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        display_prefix = self.get_display_prefix()</span>
<span class="gi">+        if display_prefix:</span>
<span class="gi">+            signode += addnodes.desc_annotation(&#39;&#39;, &#39;&#39;, *display_prefix)</span>
<span class="gi">+</span>
<span class="gi">+        actual_prefix = None</span>
<span class="gi">+        if prefix:</span>
<span class="gi">+            actual_prefix = prefix</span>
<span class="gi">+        elif mod_name:</span>
<span class="gi">+            actual_prefix = mod_name</span>
<span class="gi">+        if actual_prefix:</span>
<span class="gi">+            addName = addnodes.desc_addname(&#39;&#39;, &#39;&#39;)</span>
<span class="gi">+            for p in actual_prefix.split(&#39;.&#39;):</span>
<span class="gi">+                addName += addnodes.desc_sig_name(p, p)</span>
<span class="gi">+                addName += addnodes.desc_sig_punctuation(&#39;.&#39;, &#39;.&#39;)</span>
<span class="gi">+            signode += addName</span>
<span class="gi">+        signode += addnodes.desc_name(&#39;&#39;, &#39;&#39;, addnodes.desc_sig_name(name, name))</span>
<span class="gi">+        if self.has_arguments:</span>
<span class="gi">+            if not arglist:</span>
<span class="gi">+                signode += addnodes.desc_parameterlist()</span>
<span class="gi">+            else:</span>
<span class="gi">+                _pseudo_parse_arglist(signode, arglist, multi_line_parameter_list)</span>
<span class="gi">+        return fullname, prefix</span>
<span class="gi">+</span>
<span class="gi">+    def _object_hierarchy_parts(self, sig_node: desc_signature) -&gt; tuple[str, ...]:</span>
<span class="gi">+        if &#39;fullname&#39; not in sig_node:</span>
<span class="gi">+            return ()</span>
<span class="gi">+        modname = sig_node.get(&#39;module&#39;)</span>
<span class="gi">+        fullname = sig_node[&#39;fullname&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        if modname:</span>
<span class="gi">+            return (modname, *fullname.split(&#39;.&#39;))</span>
<span class="gi">+        else:</span>
<span class="gi">+            return tuple(fullname.split(&#39;.&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    def add_target_and_index(self, name_obj: tuple[str, str], sig: str,</span>
<span class="gi">+                             signode: desc_signature) -&gt; None:</span>
<span class="gi">+        mod_name = self.env.ref_context.get(&#39;js:module&#39;)</span>
<span class="gi">+        fullname = (mod_name + &#39;.&#39; if mod_name else &#39;&#39;) + name_obj[0]</span>
<span class="gi">+        node_id = make_id(self.env, self.state.document, &#39;&#39;, fullname)</span>
<span class="gi">+        signode[&#39;ids&#39;].append(node_id)</span>
<span class="gi">+        self.state.document.note_explicit_target(signode)</span>
<span class="gi">+</span>
<span class="gi">+        domain = cast(JavaScriptDomain, self.env.get_domain(&#39;js&#39;))</span>
<span class="gi">+        domain.note_object(fullname, self.objtype, node_id, location=signode)</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;no-index-entry&#39; not in self.options:</span>
<span class="gi">+            indextext = self.get_index_text(mod_name, name_obj)  # type: ignore[arg-type]</span>
<span class="gi">+            if indextext:</span>
<span class="gi">+                self.indexnode[&#39;entries&#39;].append((&#39;single&#39;, indextext, node_id, &#39;&#39;, None))</span>
<span class="gi">+</span>
<span class="gi">+    def get_index_text(self, objectname: str, name_obj: tuple[str, str]) -&gt; str:</span>
<span class="gi">+        name, obj = name_obj</span>
<span class="gi">+        if self.objtype == &#39;function&#39;:</span>
<span class="gi">+            if not obj:</span>
<span class="gi">+                return _(&#39;%s() (built-in function)&#39;) % name</span>
<span class="gi">+            return _(&#39;%s() (%s method)&#39;) % (name, obj)</span>
<span class="gi">+        elif self.objtype == &#39;class&#39;:</span>
<span class="gi">+            return _(&#39;%s() (class)&#39;) % name</span>
<span class="gi">+        elif self.objtype == &#39;data&#39;:</span>
<span class="gi">+            return _(&#39;%s (global variable or constant)&#39;) % name</span>
<span class="gi">+        elif self.objtype == &#39;attribute&#39;:</span>
<span class="gi">+            return _(&#39;%s (%s attribute)&#39;) % (name, obj)</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def before_content(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handle object nesting before content

<span class="w"> </span>        :py:class:`JSObject` represents JavaScript language constructs. For
<span class="gu">@@ -71,9 +196,19 @@ class JSObject(ObjectDescription[tuple[str, str]]):</span>
<span class="w"> </span>                Current object prefix. This should generally reflect the last
<span class="w"> </span>                element in the prefix history
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        prefix = None</span>
<span class="gi">+        if self.names:</span>
<span class="gi">+            (obj_name, obj_name_prefix) = self.names.pop()</span>
<span class="gi">+            prefix = obj_name_prefix.strip(&#39;.&#39;) if obj_name_prefix else None</span>
<span class="gi">+            if self.allow_nesting:</span>
<span class="gi">+                prefix = obj_name</span>
<span class="gi">+        if prefix:</span>
<span class="gi">+            self.env.ref_context[&#39;js:object&#39;] = prefix</span>
<span class="gi">+            if self.allow_nesting:</span>
<span class="gi">+                objects = self.env.ref_context.setdefault(&#39;js:objects&#39;, [])</span>
<span class="gi">+                objects.append(prefix)</span>

<span class="gd">-    def after_content(self) -&gt;None:</span>
<span class="gi">+    def after_content(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handle object de-nesting after content

<span class="w"> </span>        If this class is a nestable object, removing the last nested class prefix
<span class="gu">@@ -83,25 +218,62 @@ class JSObject(ObjectDescription[tuple[str, str]]):</span>
<span class="w"> </span>        be altered as we didn&#39;t affect the nesting levels in
<span class="w"> </span>        :py:meth:`before_content`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        objects = self.env.ref_context.setdefault(&#39;js:objects&#39;, [])</span>
<span class="gi">+        if self.allow_nesting:</span>
<span class="gi">+            with contextlib.suppress(IndexError):</span>
<span class="gi">+                objects.pop()</span>
<span class="gi">+</span>
<span class="gi">+        self.env.ref_context[&#39;js:object&#39;] = (objects[-1] if len(objects) &gt; 0</span>
<span class="gi">+                                             else None)</span>
<span class="gi">+</span>
<span class="gi">+    def _toc_entry_name(self, sig_node: desc_signature) -&gt; str:</span>
<span class="gi">+        if not sig_node.get(&#39;_toc_parts&#39;):</span>
<span class="gi">+            return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        config = self.env.app.config</span>
<span class="gi">+        objtype = sig_node.parent.get(&#39;objtype&#39;)</span>
<span class="gi">+        if config.add_function_parentheses and objtype in {&#39;function&#39;, &#39;method&#39;}:</span>
<span class="gi">+            parens = &#39;()&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            parens = &#39;&#39;</span>
<span class="gi">+        *parents, name = sig_node[&#39;_toc_parts&#39;]</span>
<span class="gi">+        if config.toc_object_entries_show_parents == &#39;domain&#39;:</span>
<span class="gi">+            return sig_node.get(&#39;fullname&#39;, name) + parens</span>
<span class="gi">+        if config.toc_object_entries_show_parents == &#39;hide&#39;:</span>
<span class="gi">+            return name + parens</span>
<span class="gi">+        if config.toc_object_entries_show_parents == &#39;all&#39;:</span>
<span class="gi">+            return &#39;.&#39;.join([*parents, name + parens])</span>
<span class="gi">+        return &#39;&#39;</span>


<span class="w"> </span>class JSCallable(JSObject):
<span class="w"> </span>    &quot;&quot;&quot;Description of a JavaScript function, method or constructor.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    has_arguments = True
<span class="gd">-    doc_field_types = [TypedField(&#39;arguments&#39;, label=_(&#39;Arguments&#39;), names=</span>
<span class="gd">-        (&#39;argument&#39;, &#39;arg&#39;, &#39;parameter&#39;, &#39;param&#39;), typerolename=&#39;func&#39;,</span>
<span class="gd">-        typenames=(&#39;paramtype&#39;, &#39;type&#39;)), GroupedField(&#39;errors&#39;, label=_(</span>
<span class="gd">-        &#39;Throws&#39;), rolename=&#39;func&#39;, names=(&#39;throws&#39;,), can_collapse=True),</span>
<span class="gd">-        Field(&#39;returnvalue&#39;, label=_(&#39;Returns&#39;), has_arg=False, names=(</span>
<span class="gd">-        &#39;returns&#39;, &#39;return&#39;)), Field(&#39;returntype&#39;, label=_(&#39;Return type&#39;),</span>
<span class="gd">-        has_arg=False, names=(&#39;rtype&#39;,))]</span>
<span class="gi">+</span>
<span class="gi">+    doc_field_types = [</span>
<span class="gi">+        TypedField(&#39;arguments&#39;, label=_(&#39;Arguments&#39;),</span>
<span class="gi">+                   names=(&#39;argument&#39;, &#39;arg&#39;, &#39;parameter&#39;, &#39;param&#39;),</span>
<span class="gi">+                   typerolename=&#39;func&#39;, typenames=(&#39;paramtype&#39;, &#39;type&#39;)),</span>
<span class="gi">+        GroupedField(&#39;errors&#39;, label=_(&#39;Throws&#39;), rolename=&#39;func&#39;,</span>
<span class="gi">+                     names=(&#39;throws&#39;, ),</span>
<span class="gi">+                     can_collapse=True),</span>
<span class="gi">+        Field(&#39;returnvalue&#39;, label=_(&#39;Returns&#39;), has_arg=False,</span>
<span class="gi">+              names=(&#39;returns&#39;, &#39;return&#39;)),</span>
<span class="gi">+        Field(&#39;returntype&#39;, label=_(&#39;Return type&#39;), has_arg=False,</span>
<span class="gi">+              names=(&#39;rtype&#39;,)),</span>
<span class="gi">+    ]</span>


<span class="w"> </span>class JSConstructor(JSCallable):
<span class="w"> </span>    &quot;&quot;&quot;Like a callable but with a different prefix.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    allow_nesting = True

<span class="gi">+    def get_display_prefix(self) -&gt; list[Node]:</span>
<span class="gi">+        return [addnodes.desc_sig_keyword(&#39;class&#39;, &#39;class&#39;),</span>
<span class="gi">+                addnodes.desc_sig_space()]</span>
<span class="gi">+</span>

<span class="w"> </span>class JSModule(SphinxDirective):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -121,32 +293,216 @@ class JSModule(SphinxDirective):</span>

<span class="w"> </span>    :param mod_name: Module name
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    has_content = True
<span class="w"> </span>    required_arguments = 1
<span class="w"> </span>    optional_arguments = 0
<span class="w"> </span>    final_argument_whitespace = False
<span class="gd">-    option_spec: ClassVar[OptionSpec] = {&#39;no-index&#39;: directives.flag,</span>
<span class="gd">-        &#39;no-contents-entry&#39;: directives.flag, &#39;no-typesetting&#39;: directives.</span>
<span class="gd">-        flag, &#39;noindex&#39;: directives.flag, &#39;nocontentsentry&#39;: directives.flag}</span>
<span class="gi">+    option_spec: ClassVar[OptionSpec] = {</span>
<span class="gi">+        &#39;no-index&#39;: directives.flag,</span>
<span class="gi">+        &#39;no-contents-entry&#39;: directives.flag,</span>
<span class="gi">+        &#39;no-typesetting&#39;: directives.flag,</span>
<span class="gi">+        &#39;noindex&#39;: directives.flag,</span>
<span class="gi">+        &#39;nocontentsentry&#39;: directives.flag,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        mod_name = self.arguments[0].strip()</span>
<span class="gi">+        self.env.ref_context[&#39;js:module&#39;] = mod_name</span>
<span class="gi">+        no_index = &#39;no-index&#39; in self.options</span>
<span class="gi">+</span>
<span class="gi">+        content_nodes = self.parse_content_to_nodes(allow_section_headings=True)</span>
<span class="gi">+</span>
<span class="gi">+        ret: list[Node] = []</span>
<span class="gi">+        if not no_index:</span>
<span class="gi">+            domain = cast(JavaScriptDomain, self.env.get_domain(&#39;js&#39;))</span>
<span class="gi">+</span>
<span class="gi">+            node_id = make_id(self.env, self.state.document, &#39;module&#39;, mod_name)</span>
<span class="gi">+            domain.note_module(mod_name, node_id)</span>
<span class="gi">+            # Make a duplicate entry in &#39;objects&#39; to facilitate searching for</span>
<span class="gi">+            # the module in JavaScriptDomain.find_obj()</span>
<span class="gi">+            domain.note_object(mod_name, &#39;module&#39;, node_id,</span>
<span class="gi">+                               location=(self.env.docname, self.lineno))</span>
<span class="gi">+</span>
<span class="gi">+            # The node order is: index node first, then target node</span>
<span class="gi">+            indextext = _(&#39;%s (module)&#39;) % mod_name</span>
<span class="gi">+            inode = addnodes.index(entries=[(&#39;single&#39;, indextext, node_id, &#39;&#39;, None)])</span>
<span class="gi">+            ret.append(inode)</span>
<span class="gi">+            target = nodes.target(&#39;&#39;, &#39;&#39;, ids=[node_id], ismod=True)</span>
<span class="gi">+            self.state.document.note_explicit_target(target)</span>
<span class="gi">+            ret.append(target)</span>
<span class="gi">+        ret.extend(content_nodes)</span>
<span class="gi">+        return ret</span>


<span class="w"> </span>class JSXRefRole(XRefRole):
<span class="gd">-    pass</span>
<span class="gi">+    def process_link(self, env: BuildEnvironment, refnode: Element,</span>
<span class="gi">+                     has_explicit_title: bool, title: str, target: str) -&gt; tuple[str, str]:</span>
<span class="gi">+        # basically what sphinx.domains.python.PyXRefRole does</span>
<span class="gi">+        refnode[&#39;js:object&#39;] = env.ref_context.get(&#39;js:object&#39;)</span>
<span class="gi">+        refnode[&#39;js:module&#39;] = env.ref_context.get(&#39;js:module&#39;)</span>
<span class="gi">+        if not has_explicit_title:</span>
<span class="gi">+            title = title.lstrip(&#39;.&#39;)</span>
<span class="gi">+            target = target.lstrip(&#39;~&#39;)</span>
<span class="gi">+            if title[0:1] == &#39;~&#39;:</span>
<span class="gi">+                title = title[1:]</span>
<span class="gi">+                dot = title.rfind(&#39;.&#39;)</span>
<span class="gi">+                if dot != -1:</span>
<span class="gi">+                    title = title[dot + 1:]</span>
<span class="gi">+        if target[0:1] == &#39;.&#39;:</span>
<span class="gi">+            target = target[1:]</span>
<span class="gi">+            refnode[&#39;refspecific&#39;] = True</span>
<span class="gi">+        return title, target</span>


<span class="w"> </span>class JavaScriptDomain(Domain):
<span class="w"> </span>    &quot;&quot;&quot;JavaScript language domain.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name = &#39;js&#39;
<span class="w"> </span>    label = &#39;JavaScript&#39;
<span class="gd">-    object_types = {&#39;function&#39;: ObjType(_(&#39;function&#39;), &#39;func&#39;), &#39;method&#39;:</span>
<span class="gd">-        ObjType(_(&#39;method&#39;), &#39;meth&#39;), &#39;class&#39;: ObjType(_(&#39;class&#39;), &#39;class&#39;),</span>
<span class="gd">-        &#39;data&#39;: ObjType(_(&#39;data&#39;), &#39;data&#39;), &#39;attribute&#39;: ObjType(_(</span>
<span class="gd">-        &#39;attribute&#39;), &#39;attr&#39;), &#39;module&#39;: ObjType(_(&#39;module&#39;), &#39;mod&#39;)}</span>
<span class="gd">-    directives = {&#39;function&#39;: JSCallable, &#39;method&#39;: JSCallable, &#39;class&#39;:</span>
<span class="gd">-        JSConstructor, &#39;data&#39;: JSObject, &#39;attribute&#39;: JSObject, &#39;module&#39;:</span>
<span class="gd">-        JSModule}</span>
<span class="gd">-    roles = {&#39;func&#39;: JSXRefRole(fix_parens=True), &#39;meth&#39;: JSXRefRole(</span>
<span class="gd">-        fix_parens=True), &#39;class&#39;: JSXRefRole(fix_parens=True), &#39;data&#39;:</span>
<span class="gd">-        JSXRefRole(), &#39;attr&#39;: JSXRefRole(), &#39;mod&#39;: JSXRefRole()}</span>
<span class="gd">-    initial_data: dict[str, dict[str, tuple[str, str]]] = {&#39;objects&#39;: {},</span>
<span class="gd">-        &#39;modules&#39;: {}}</span>
<span class="gi">+    # if you add a new object type make sure to edit JSObject.get_index_string</span>
<span class="gi">+    object_types = {</span>
<span class="gi">+        &#39;function&#39;:  ObjType(_(&#39;function&#39;),  &#39;func&#39;),</span>
<span class="gi">+        &#39;method&#39;:    ObjType(_(&#39;method&#39;),    &#39;meth&#39;),</span>
<span class="gi">+        &#39;class&#39;:     ObjType(_(&#39;class&#39;),     &#39;class&#39;),</span>
<span class="gi">+        &#39;data&#39;:      ObjType(_(&#39;data&#39;),      &#39;data&#39;),</span>
<span class="gi">+        &#39;attribute&#39;: ObjType(_(&#39;attribute&#39;), &#39;attr&#39;),</span>
<span class="gi">+        &#39;module&#39;:    ObjType(_(&#39;module&#39;),    &#39;mod&#39;),</span>
<span class="gi">+    }</span>
<span class="gi">+    directives = {</span>
<span class="gi">+        &#39;function&#39;:  JSCallable,</span>
<span class="gi">+        &#39;method&#39;:    JSCallable,</span>
<span class="gi">+        &#39;class&#39;:     JSConstructor,</span>
<span class="gi">+        &#39;data&#39;:      JSObject,</span>
<span class="gi">+        &#39;attribute&#39;: JSObject,</span>
<span class="gi">+        &#39;module&#39;:    JSModule,</span>
<span class="gi">+    }</span>
<span class="gi">+    roles = {</span>
<span class="gi">+        &#39;func&#39;:  JSXRefRole(fix_parens=True),</span>
<span class="gi">+        &#39;meth&#39;:  JSXRefRole(fix_parens=True),</span>
<span class="gi">+        &#39;class&#39;: JSXRefRole(fix_parens=True),</span>
<span class="gi">+        &#39;data&#39;:  JSXRefRole(),</span>
<span class="gi">+        &#39;attr&#39;:  JSXRefRole(),</span>
<span class="gi">+        &#39;mod&#39;:   JSXRefRole(),</span>
<span class="gi">+    }</span>
<span class="gi">+    initial_data: dict[str, dict[str, tuple[str, str]]] = {</span>
<span class="gi">+        &#39;objects&#39;: {},  # fullname -&gt; docname, node_id, objtype</span>
<span class="gi">+        &#39;modules&#39;: {},  # modname  -&gt; docname, node_id</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def objects(self) -&gt; dict[str, tuple[str, str, str]]:</span>
<span class="gi">+        return self.data.setdefault(&#39;objects&#39;, {})  # fullname -&gt; docname, node_id, objtype</span>
<span class="gi">+</span>
<span class="gi">+    def note_object(self, fullname: str, objtype: str, node_id: str,</span>
<span class="gi">+                    location: Any = None) -&gt; None:</span>
<span class="gi">+        if fullname in self.objects:</span>
<span class="gi">+            docname = self.objects[fullname][0]</span>
<span class="gi">+            logger.warning(__(&#39;duplicate %s description of %s, other %s in %s&#39;),</span>
<span class="gi">+                           objtype, fullname, objtype, docname, location=location)</span>
<span class="gi">+        self.objects[fullname] = (self.env.docname, node_id, objtype)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def modules(self) -&gt; dict[str, tuple[str, str]]:</span>
<span class="gi">+        return self.data.setdefault(&#39;modules&#39;, {})  # modname -&gt; docname, node_id</span>
<span class="gi">+</span>
<span class="gi">+    def note_module(self, modname: str, node_id: str) -&gt; None:</span>
<span class="gi">+        self.modules[modname] = (self.env.docname, node_id)</span>
<span class="gi">+</span>
<span class="gi">+    def clear_doc(self, docname: str) -&gt; None:</span>
<span class="gi">+        for fullname, (pkg_docname, _node_id, _l) in list(self.objects.items()):</span>
<span class="gi">+            if pkg_docname == docname:</span>
<span class="gi">+                del self.objects[fullname]</span>
<span class="gi">+        for modname, (pkg_docname, _node_id) in list(self.modules.items()):</span>
<span class="gi">+            if pkg_docname == docname:</span>
<span class="gi">+                del self.modules[modname]</span>
<span class="gi">+</span>
<span class="gi">+    def merge_domaindata(self, docnames: list[str], otherdata: dict[str, Any]) -&gt; None:</span>
<span class="gi">+        # XXX check duplicates</span>
<span class="gi">+        for fullname, (fn, node_id, objtype) in otherdata[&#39;objects&#39;].items():</span>
<span class="gi">+            if fn in docnames:</span>
<span class="gi">+                self.objects[fullname] = (fn, node_id, objtype)</span>
<span class="gi">+        for mod_name, (pkg_docname, node_id) in otherdata[&#39;modules&#39;].items():</span>
<span class="gi">+            if pkg_docname in docnames:</span>
<span class="gi">+                self.modules[mod_name] = (pkg_docname, node_id)</span>
<span class="gi">+</span>
<span class="gi">+    def find_obj(</span>
<span class="gi">+        self,</span>
<span class="gi">+        env: BuildEnvironment,</span>
<span class="gi">+        mod_name: str,</span>
<span class="gi">+        prefix: str,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        typ: str | None,</span>
<span class="gi">+        searchorder: int = 0,</span>
<span class="gi">+    ) -&gt; tuple[str | None, tuple[str, str, str] | None]:</span>
<span class="gi">+        if name[-2:] == &#39;()&#39;:</span>
<span class="gi">+            name = name[:-2]</span>
<span class="gi">+</span>
<span class="gi">+        searches = []</span>
<span class="gi">+        if mod_name and prefix:</span>
<span class="gi">+            searches.append(f&#39;{mod_name}.{prefix}.{name}&#39;)</span>
<span class="gi">+        if mod_name:</span>
<span class="gi">+            searches.append(f&#39;{mod_name}.{name}&#39;)</span>
<span class="gi">+        if prefix:</span>
<span class="gi">+            searches.append(f&#39;{prefix}.{name}&#39;)</span>
<span class="gi">+        searches.append(name)</span>
<span class="gi">+</span>
<span class="gi">+        if searchorder == 0:</span>
<span class="gi">+            searches.reverse()</span>
<span class="gi">+</span>
<span class="gi">+        newname = None</span>
<span class="gi">+        object_ = None</span>
<span class="gi">+        for search_name in searches:</span>
<span class="gi">+            if search_name in self.objects:</span>
<span class="gi">+                newname = search_name</span>
<span class="gi">+                object_ = self.objects[search_name]</span>
<span class="gi">+</span>
<span class="gi">+        return newname, object_</span>
<span class="gi">+</span>
<span class="gi">+    def resolve_xref(self, env: BuildEnvironment, fromdocname: str, builder: Builder,</span>
<span class="gi">+                     typ: str, target: str, node: pending_xref, contnode: Element,</span>
<span class="gi">+                     ) -&gt; Element | None:</span>
<span class="gi">+        mod_name = node.get(&#39;js:module&#39;)</span>
<span class="gi">+        prefix = node.get(&#39;js:object&#39;)</span>
<span class="gi">+        searchorder = 1 if node.hasattr(&#39;refspecific&#39;) else 0</span>
<span class="gi">+        name, obj = self.find_obj(env, mod_name, prefix, target, typ, searchorder)</span>
<span class="gi">+        if not obj:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return make_refnode(builder, fromdocname, obj[0], obj[1], contnode, name)</span>
<span class="gi">+</span>
<span class="gi">+    def resolve_any_xref(self, env: BuildEnvironment, fromdocname: str, builder: Builder,</span>
<span class="gi">+                         target: str, node: pending_xref, contnode: Element,</span>
<span class="gi">+                         ) -&gt; list[tuple[str, Element]]:</span>
<span class="gi">+        mod_name = node.get(&#39;js:module&#39;)</span>
<span class="gi">+        prefix = node.get(&#39;js:object&#39;)</span>
<span class="gi">+        name, obj = self.find_obj(env, mod_name, prefix, target, None, 1)</span>
<span class="gi">+        if not obj:</span>
<span class="gi">+            return []</span>
<span class="gi">+        return [(&#39;js:&#39; + self.role_for_objtype(obj[2]),  # type: ignore[operator]</span>
<span class="gi">+                 make_refnode(builder, fromdocname, obj[0], obj[1], contnode, name))]</span>
<span class="gi">+</span>
<span class="gi">+    def get_objects(self) -&gt; Iterator[tuple[str, str, str, str, str, int]]:</span>
<span class="gi">+        for refname, (docname, node_id, typ) in list(self.objects.items()):</span>
<span class="gi">+            yield refname, refname, typ, docname, node_id, 1</span>
<span class="gi">+</span>
<span class="gi">+    def get_full_qualified_name(self, node: Element) -&gt; str | None:</span>
<span class="gi">+        modname = node.get(&#39;js:module&#39;)</span>
<span class="gi">+        prefix = node.get(&#39;js:object&#39;)</span>
<span class="gi">+        target = node.get(&#39;reftarget&#39;)</span>
<span class="gi">+        if target is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;.&#39;.join(filter(None, [modname, prefix, target]))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_domain(JavaScriptDomain)</span>
<span class="gi">+    app.add_config_value(</span>
<span class="gi">+        &#39;javascript_maximum_signature_line_length&#39;, None, &#39;env&#39;, {int, type(None)},</span>
<span class="gi">+    )</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;env_version&#39;: 3,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/domains/math.py b/sphinx/domains/math.py</span>
<span class="gh">index 18f76a695..afa36062d 100644</span>
<span class="gd">--- a/sphinx/domains/math.py</span>
<span class="gi">+++ b/sphinx/domains/math.py</span>
<span class="gu">@@ -1,32 +1,158 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The math domain.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.nodes import Element, Node, make_id, system_message
<span class="gi">+</span>
<span class="w"> </span>from sphinx.domains import Domain
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.roles import XRefRole
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.nodes import make_refnode
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Iterable
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.addnodes import pending_xref
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.builders import Builder
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="w"> </span>class MathReferenceRole(XRefRole):
<span class="gd">-    pass</span>
<span class="gi">+    def result_nodes(self, document: nodes.document, env: BuildEnvironment, node: Element,</span>
<span class="gi">+                     is_ref: bool) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+        node[&#39;refdomain&#39;] = &#39;math&#39;</span>
<span class="gi">+        return [node], []</span>


<span class="w"> </span>class MathDomain(Domain):
<span class="w"> </span>    &quot;&quot;&quot;Mathematics domain.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name = &#39;math&#39;
<span class="w"> </span>    label = &#39;mathematics&#39;
<span class="gd">-    initial_data: dict[str, Any] = {&#39;objects&#39;: {}, &#39;has_equations&#39;: {}}</span>
<span class="gd">-    dangling_warnings = {&#39;eq&#39;: &#39;equation not found: %(target)s&#39;}</span>
<span class="gd">-    enumerable_nodes = {nodes.math_block: (&#39;displaymath&#39;, None)}</span>
<span class="gd">-    roles = {&#39;numref&#39;: MathReferenceRole()}</span>
<span class="gi">+</span>
<span class="gi">+    initial_data: dict[str, Any] = {</span>
<span class="gi">+        &#39;objects&#39;: {},  # labelid -&gt; (docname, eqno)</span>
<span class="gi">+        &#39;has_equations&#39;: {},  # docname -&gt; bool</span>
<span class="gi">+    }</span>
<span class="gi">+    dangling_warnings = {</span>
<span class="gi">+        &#39;eq&#39;: &#39;equation not found: %(target)s&#39;,</span>
<span class="gi">+    }</span>
<span class="gi">+    enumerable_nodes = {  # node_class -&gt; (figtype, title_getter)</span>
<span class="gi">+        nodes.math_block: (&#39;displaymath&#39;, None),</span>
<span class="gi">+    }</span>
<span class="gi">+    roles = {</span>
<span class="gi">+        &#39;numref&#39;: MathReferenceRole(),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def equations(self) -&gt; dict[str, tuple[str, int]]:</span>
<span class="gi">+        return self.data.setdefault(&#39;objects&#39;, {})  # labelid -&gt; (docname, eqno)</span>
<span class="gi">+</span>
<span class="gi">+    def note_equation(self, docname: str, labelid: str, location: Any = None) -&gt; None:</span>
<span class="gi">+        if labelid in self.equations:</span>
<span class="gi">+            other = self.equations[labelid][0]</span>
<span class="gi">+            logger.warning(__(&#39;duplicate label of equation %s, other instance in %s&#39;),</span>
<span class="gi">+                           labelid, other, location=location)</span>
<span class="gi">+</span>
<span class="gi">+        self.equations[labelid] = (docname, self.env.new_serialno(&#39;eqno&#39;) + 1)</span>
<span class="gi">+</span>
<span class="gi">+    def get_equation_number_for(self, labelid: str) -&gt; int | None:</span>
<span class="gi">+        if labelid in self.equations:</span>
<span class="gi">+            return self.equations[labelid][1]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    def process_doc(self, env: BuildEnvironment, docname: str,</span>
<span class="gi">+                    document: nodes.document) -&gt; None:</span>
<span class="gi">+        def math_node(node: Node) -&gt; bool:</span>
<span class="gi">+            return isinstance(node, nodes.math | nodes.math_block)</span>
<span class="gi">+</span>
<span class="gi">+        self.data[&#39;has_equations&#39;][docname] = any(document.findall(math_node))</span>
<span class="gi">+</span>
<span class="gi">+    def clear_doc(self, docname: str) -&gt; None:</span>
<span class="gi">+        for equation_id, (doc, _eqno) in list(self.equations.items()):</span>
<span class="gi">+            if doc == docname:</span>
<span class="gi">+                del self.equations[equation_id]</span>
<span class="gi">+</span>
<span class="gi">+        self.data[&#39;has_equations&#39;].pop(docname, None)</span>
<span class="gi">+</span>
<span class="gi">+    def merge_domaindata(self, docnames: Iterable[str], otherdata: dict[str, Any]) -&gt; None:</span>
<span class="gi">+        for labelid, (doc, eqno) in otherdata[&#39;objects&#39;].items():</span>
<span class="gi">+            if doc in docnames:</span>
<span class="gi">+                self.equations[labelid] = (doc, eqno)</span>
<span class="gi">+</span>
<span class="gi">+        for docname in docnames:</span>
<span class="gi">+            self.data[&#39;has_equations&#39;][docname] = otherdata[&#39;has_equations&#39;][docname]</span>
<span class="gi">+</span>
<span class="gi">+    def resolve_xref(self, env: BuildEnvironment, fromdocname: str, builder: Builder,</span>
<span class="gi">+                     typ: str, target: str, node: pending_xref, contnode: Element,</span>
<span class="gi">+                     ) -&gt; Element | None:</span>
<span class="gi">+        assert typ in (&#39;eq&#39;, &#39;numref&#39;)</span>
<span class="gi">+        result = self.equations.get(target)</span>
<span class="gi">+        if result:</span>
<span class="gi">+            docname, number = result</span>
<span class="gi">+            # TODO: perhaps use rather a sphinx-core provided prefix here?</span>
<span class="gi">+            node_id = make_id(&#39;equation-%s&#39; % target)</span>
<span class="gi">+            if env.config.math_numfig and env.config.numfig:</span>
<span class="gi">+                if docname in env.toc_fignumbers:</span>
<span class="gi">+                    numbers = env.toc_fignumbers[docname][&#39;displaymath&#39;].get(node_id, ())</span>
<span class="gi">+                    eqno = &#39;.&#39;.join(map(str, numbers))</span>
<span class="gi">+                    eqno = env.config.math_numsep.join(eqno.rsplit(&#39;.&#39;, 1))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    eqno = &#39;&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                eqno = str(number)</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                eqref_format = env.config.math_eqref_format or &quot;({number})&quot;</span>
<span class="gi">+                title = nodes.Text(eqref_format.format(number=eqno))</span>
<span class="gi">+            except KeyError as exc:</span>
<span class="gi">+                logger.warning(__(&#39;Invalid math_eqref_format: %r&#39;), exc,</span>
<span class="gi">+                               location=node)</span>
<span class="gi">+                title = nodes.Text(&quot;(%d)&quot; % number)</span>
<span class="gi">+                title = nodes.Text(&quot;(%d)&quot; % number)</span>
<span class="gi">+            return make_refnode(builder, fromdocname, docname, node_id, title)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    def resolve_any_xref(self, env: BuildEnvironment, fromdocname: str, builder: Builder,</span>
<span class="gi">+                         target: str, node: pending_xref, contnode: Element,</span>
<span class="gi">+                         ) -&gt; list[tuple[str, Element]]:</span>
<span class="gi">+        refnode = self.resolve_xref(env, fromdocname, builder, &#39;eq&#39;, target, node, contnode)</span>
<span class="gi">+        if refnode is None:</span>
<span class="gi">+            return []</span>
<span class="gi">+        else:</span>
<span class="gi">+            return [(&#39;eq&#39;, refnode)]</span>
<span class="gi">+</span>
<span class="gi">+    def get_objects(self) -&gt; Iterable[tuple[str, str, str, str, str, int]]:</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    def has_equations(self, docname: str | None = None) -&gt; bool:</span>
<span class="gi">+        if not docname:</span>
<span class="gi">+            return any(self.data[&#39;has_equations&#39;].values())</span>
<span class="gi">+</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.data[&#39;has_equations&#39;].get(docname, False)</span>
<span class="gi">+            or any(map(self.has_equations, self.env.toctree_includes.get(docname, ())))</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_domain(MathDomain)</span>
<span class="gi">+    app.add_role(&#39;eq&#39;, MathReferenceRole(warn_dangling=True))</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;env_version&#39;: 2,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/domains/python/_annotations.py b/sphinx/domains/python/_annotations.py</span>
<span class="gh">index bc2418143..35525f6b1 100644</span>
<span class="gd">--- a/sphinx/domains/python/_annotations.py</span>
<span class="gi">+++ b/sphinx/domains/python/_annotations.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import ast
<span class="w"> </span>import functools
<span class="w"> </span>import operator
<span class="gu">@@ -6,60 +7,523 @@ import token</span>
<span class="w"> </span>from collections import deque
<span class="w"> </span>from inspect import Parameter
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.addnodes import desc_signature, pending_xref, pending_xref_condition
<span class="w"> </span>from sphinx.pycode.parser import Token, TokenProcessor
<span class="w"> </span>from sphinx.util.inspect import signature_from_str
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Iterable, Iterator
<span class="gi">+</span>
<span class="w"> </span>    from docutils.nodes import Element, Node
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.environment import BuildEnvironment


<span class="gd">-def parse_reftarget(reftarget: str, suppress_prefix: bool=False) -&gt;tuple[</span>
<span class="gd">-    str, str, str, bool]:</span>
<span class="gi">+def parse_reftarget(reftarget: str, suppress_prefix: bool = False,</span>
<span class="gi">+                    ) -&gt; tuple[str, str, str, bool]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a type string and return (reftype, reftarget, title, refspecific flag)&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    refspecific = False</span>
<span class="gi">+    if reftarget.startswith(&#39;.&#39;):</span>
<span class="gi">+        reftarget = reftarget[1:]</span>
<span class="gi">+        title = reftarget</span>
<span class="gi">+        refspecific = True</span>
<span class="gi">+    elif reftarget.startswith(&#39;~&#39;):</span>
<span class="gi">+        reftarget = reftarget[1:]</span>
<span class="gi">+        title = reftarget.split(&#39;.&#39;)[-1]</span>
<span class="gi">+    elif suppress_prefix:</span>
<span class="gi">+        title = reftarget.split(&#39;.&#39;)[-1]</span>
<span class="gi">+    elif reftarget.startswith(&#39;typing.&#39;):</span>
<span class="gi">+        title = reftarget[7:]</span>
<span class="gi">+    else:</span>
<span class="gi">+        title = reftarget</span>

<span class="gi">+    if reftarget == &#39;None&#39; or reftarget.startswith(&#39;typing.&#39;):</span>
<span class="gi">+        # typing module provides non-class types.  Obj reference is good to refer them.</span>
<span class="gi">+        reftype = &#39;obj&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        reftype = &#39;class&#39;</span>

<span class="gd">-def type_to_xref(target: str, env: BuildEnvironment, *, suppress_prefix:</span>
<span class="gd">-    bool=False) -&gt;addnodes.pending_xref:</span>
<span class="gi">+    return reftype, reftarget, title, refspecific</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def type_to_xref(target: str, env: BuildEnvironment, *,</span>
<span class="gi">+                 suppress_prefix: bool = False) -&gt; addnodes.pending_xref:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a type string to a cross reference node.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if env:</span>
<span class="gi">+        kwargs = {&#39;py:module&#39;: env.ref_context.get(&#39;py:module&#39;),</span>
<span class="gi">+                  &#39;py:class&#39;: env.ref_context.get(&#39;py:class&#39;)}</span>
<span class="gi">+    else:</span>
<span class="gi">+        kwargs = {}</span>
<span class="gi">+</span>
<span class="gi">+    reftype, target, title, refspecific = parse_reftarget(target, suppress_prefix)</span>

<span class="gi">+    if env.config.python_use_unqualified_type_names:</span>
<span class="gi">+        # Note: It would be better to use qualname to describe the object to support support</span>
<span class="gi">+        # nested classes.  But python domain can&#39;t access the real python object because this</span>
<span class="gi">+        # module should work not-dynamically.</span>
<span class="gi">+        shortname = title.split(&#39;.&#39;)[-1]</span>
<span class="gi">+        contnodes: list[Node] = [pending_xref_condition(&#39;&#39;, shortname, condition=&#39;resolved&#39;),</span>
<span class="gi">+                                 pending_xref_condition(&#39;&#39;, title, condition=&#39;*&#39;)]</span>
<span class="gi">+    else:</span>
<span class="gi">+        contnodes = [nodes.Text(title)]</span>

<span class="gd">-def _parse_annotation(annotation: str, env: BuildEnvironment) -&gt;list[Node]:</span>
<span class="gi">+    return pending_xref(&#39;&#39;, *contnodes,</span>
<span class="gi">+                        refdomain=&#39;py&#39;, reftype=reftype, reftarget=target,</span>
<span class="gi">+                        refspecific=refspecific, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _parse_annotation(annotation: str, env: BuildEnvironment) -&gt; list[Node]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse type annotation.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    short_literals = env.config.python_display_short_literal_types</span>

<span class="gi">+    def unparse(node: ast.AST) -&gt; list[Node]:</span>
<span class="gi">+        if isinstance(node, ast.Attribute):</span>
<span class="gi">+            return [nodes.Text(f&quot;{unparse(node.value)[0]}.{node.attr}&quot;)]</span>
<span class="gi">+        if isinstance(node, ast.BinOp):</span>
<span class="gi">+            result: list[Node] = unparse(node.left)</span>
<span class="gi">+            result.extend(unparse(node.op))</span>
<span class="gi">+            result.extend(unparse(node.right))</span>
<span class="gi">+            return result</span>
<span class="gi">+        if isinstance(node, ast.BitOr):</span>
<span class="gi">+            return [addnodes.desc_sig_space(),</span>
<span class="gi">+                    addnodes.desc_sig_punctuation(&#39;&#39;, &#39;|&#39;),</span>
<span class="gi">+                    addnodes.desc_sig_space()]</span>
<span class="gi">+        if isinstance(node, ast.Constant):</span>
<span class="gi">+            if node.value is Ellipsis:</span>
<span class="gi">+                return [addnodes.desc_sig_punctuation(&#39;&#39;, &quot;...&quot;)]</span>
<span class="gi">+            if isinstance(node.value, bool):</span>
<span class="gi">+                return [addnodes.desc_sig_keyword(&#39;&#39;, repr(node.value))]</span>
<span class="gi">+            if isinstance(node.value, int):</span>
<span class="gi">+                return [addnodes.desc_sig_literal_number(&#39;&#39;, repr(node.value))]</span>
<span class="gi">+            if isinstance(node.value, str):</span>
<span class="gi">+                return [addnodes.desc_sig_literal_string(&#39;&#39;, repr(node.value))]</span>
<span class="gi">+            else:</span>
<span class="gi">+                # handles None, which is further handled by type_to_xref later</span>
<span class="gi">+                # and fallback for other types that should be converted</span>
<span class="gi">+                return [nodes.Text(repr(node.value))]</span>
<span class="gi">+        if isinstance(node, ast.Expr):</span>
<span class="gi">+            return unparse(node.value)</span>
<span class="gi">+        if isinstance(node, ast.Invert):</span>
<span class="gi">+            return [addnodes.desc_sig_punctuation(&#39;&#39;, &#39;~&#39;)]</span>
<span class="gi">+        if isinstance(node, ast.USub):</span>
<span class="gi">+            return [addnodes.desc_sig_punctuation(&#39;&#39;, &#39;-&#39;)]</span>
<span class="gi">+        if isinstance(node, ast.List):</span>
<span class="gi">+            result = [addnodes.desc_sig_punctuation(&#39;&#39;, &#39;[&#39;)]</span>
<span class="gi">+            if node.elts:</span>
<span class="gi">+                # check if there are elements in node.elts to only pop the</span>
<span class="gi">+                # last element of result if the for-loop was run at least</span>
<span class="gi">+                # once</span>
<span class="gi">+                for elem in node.elts:</span>
<span class="gi">+                    result.extend(unparse(elem))</span>
<span class="gi">+                    result.append(addnodes.desc_sig_punctuation(&#39;&#39;, &#39;,&#39;))</span>
<span class="gi">+                    result.append(addnodes.desc_sig_space())</span>
<span class="gi">+                result.pop()</span>
<span class="gi">+                result.pop()</span>
<span class="gi">+            result.append(addnodes.desc_sig_punctuation(&#39;&#39;, &#39;]&#39;))</span>
<span class="gi">+            return result</span>
<span class="gi">+        if isinstance(node, ast.Module):</span>
<span class="gi">+            return functools.reduce(operator.iadd, (unparse(e) for e in node.body), [])</span>
<span class="gi">+        if isinstance(node, ast.Name):</span>
<span class="gi">+            return [nodes.Text(node.id)]</span>
<span class="gi">+        if isinstance(node, ast.Subscript):</span>
<span class="gi">+            if getattr(node.value, &#39;id&#39;, &#39;&#39;) in {&#39;Optional&#39;, &#39;Union&#39;}:</span>
<span class="gi">+                return _unparse_pep_604_annotation(node)</span>
<span class="gi">+            if short_literals and getattr(node.value, &#39;id&#39;, &#39;&#39;) == &#39;Literal&#39;:</span>
<span class="gi">+                return _unparse_pep_604_annotation(node)</span>
<span class="gi">+            result = unparse(node.value)</span>
<span class="gi">+            result.append(addnodes.desc_sig_punctuation(&#39;&#39;, &#39;[&#39;))</span>
<span class="gi">+            result.extend(unparse(node.slice))</span>
<span class="gi">+            result.append(addnodes.desc_sig_punctuation(&#39;&#39;, &#39;]&#39;))</span>

<span class="gd">-class _TypeParameterListParser(TokenProcessor):</span>
<span class="gi">+            # Wrap the Text nodes inside brackets by literal node if the subscript is a Literal</span>
<span class="gi">+            if result[0] in (&#39;Literal&#39;, &#39;typing.Literal&#39;):</span>
<span class="gi">+                for i, subnode in enumerate(result[1:], start=1):</span>
<span class="gi">+                    if isinstance(subnode, nodes.Text):</span>
<span class="gi">+                        result[i] = nodes.literal(&#39;&#39;, &#39;&#39;, subnode)</span>
<span class="gi">+            return result</span>
<span class="gi">+        if isinstance(node, ast.UnaryOp):</span>
<span class="gi">+            return unparse(node.op) + unparse(node.operand)</span>
<span class="gi">+        if isinstance(node, ast.Tuple):</span>
<span class="gi">+            if node.elts:</span>
<span class="gi">+                result = []</span>
<span class="gi">+                for elem in node.elts:</span>
<span class="gi">+                    result.extend(unparse(elem))</span>
<span class="gi">+                    result.append(addnodes.desc_sig_punctuation(&#39;&#39;, &#39;,&#39;))</span>
<span class="gi">+                    result.append(addnodes.desc_sig_space())</span>
<span class="gi">+                result.pop()</span>
<span class="gi">+                result.pop()</span>
<span class="gi">+            else:</span>
<span class="gi">+                result = [addnodes.desc_sig_punctuation(&#39;&#39;, &#39;(&#39;),</span>
<span class="gi">+                          addnodes.desc_sig_punctuation(&#39;&#39;, &#39;)&#39;)]</span>

<span class="gd">-    def __init__(self, sig: str) -&gt;None:</span>
<span class="gi">+            return result</span>
<span class="gi">+        if isinstance(node, ast.Call):</span>
<span class="gi">+            # Call nodes can be used in Annotated type metadata,</span>
<span class="gi">+            # for example Annotated[str, ArbitraryTypeValidator(str, len=10)]</span>
<span class="gi">+            args = []</span>
<span class="gi">+            for arg in node.args:</span>
<span class="gi">+                args += unparse(arg)</span>
<span class="gi">+                args.append(addnodes.desc_sig_punctuation(&#39;&#39;, &#39;,&#39;))</span>
<span class="gi">+                args.append(addnodes.desc_sig_space())</span>
<span class="gi">+            for kwd in node.keywords:</span>
<span class="gi">+                args.append(addnodes.desc_sig_name(kwd.arg, kwd.arg))  # type: ignore[arg-type]</span>
<span class="gi">+                args.append(addnodes.desc_sig_operator(&#39;&#39;, &#39;=&#39;))</span>
<span class="gi">+                args += unparse(kwd.value)</span>
<span class="gi">+                args.append(addnodes.desc_sig_punctuation(&#39;&#39;, &#39;,&#39;))</span>
<span class="gi">+                args.append(addnodes.desc_sig_space())</span>
<span class="gi">+            result = [</span>
<span class="gi">+                *unparse(node.func),</span>
<span class="gi">+                addnodes.desc_sig_punctuation(&#39;&#39;, &#39;(&#39;),</span>
<span class="gi">+                *args[:-2],  # skip the final comma and space</span>
<span class="gi">+                addnodes.desc_sig_punctuation(&#39;&#39;, &#39;)&#39;),</span>
<span class="gi">+            ]</span>
<span class="gi">+            return result</span>
<span class="gi">+        msg = f&#39;unsupported syntax: {node}&#39;</span>
<span class="gi">+        raise SyntaxError(msg)  # unsupported syntax</span>
<span class="gi">+</span>
<span class="gi">+    def _unparse_pep_604_annotation(node: ast.Subscript) -&gt; list[Node]:</span>
<span class="gi">+        subscript = node.slice</span>
<span class="gi">+</span>
<span class="gi">+        flattened: list[Node] = []</span>
<span class="gi">+        if isinstance(subscript, ast.Tuple):</span>
<span class="gi">+            flattened.extend(unparse(subscript.elts[0]))</span>
<span class="gi">+            for elt in subscript.elts[1:]:</span>
<span class="gi">+                flattened.extend(unparse(ast.BitOr()))</span>
<span class="gi">+                flattened.extend(unparse(elt))</span>
<span class="gi">+        else:</span>
<span class="gi">+            # e.g. a Union[] inside an Optional[]</span>
<span class="gi">+            flattened.extend(unparse(subscript))</span>
<span class="gi">+</span>
<span class="gi">+        if getattr(node.value, &#39;id&#39;, &#39;&#39;) == &#39;Optional&#39;:</span>
<span class="gi">+            flattened.extend(unparse(ast.BitOr()))</span>
<span class="gi">+            flattened.append(nodes.Text(&#39;None&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        return flattened</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        tree = ast.parse(annotation, type_comments=True)</span>
<span class="gi">+        result: list[Node] = []</span>
<span class="gi">+        for node in unparse(tree):</span>
<span class="gi">+            if isinstance(node, nodes.literal):</span>
<span class="gi">+                result.append(node[0])</span>
<span class="gi">+            elif isinstance(node, nodes.Text) and node.strip():</span>
<span class="gi">+                if (result and isinstance(result[-1], addnodes.desc_sig_punctuation) and</span>
<span class="gi">+                        result[-1].astext() == &#39;~&#39;):</span>
<span class="gi">+                    result.pop()</span>
<span class="gi">+                    result.append(type_to_xref(str(node), env, suppress_prefix=True))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    result.append(type_to_xref(str(node), env))</span>
<span class="gi">+            else:</span>
<span class="gi">+                result.append(node)</span>
<span class="gi">+        return result</span>
<span class="gi">+    except SyntaxError:</span>
<span class="gi">+        return [type_to_xref(annotation, env)]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class _TypeParameterListParser(TokenProcessor):</span>
<span class="gi">+    def __init__(self, sig: str) -&gt; None:</span>
<span class="w"> </span>        signature = sig.replace(&#39;\n&#39;, &#39;&#39;).strip()
<span class="w"> </span>        super().__init__([signature])
<span class="gi">+        # Each item is a tuple (name, kind, default, annotation) mimicking</span>
<span class="gi">+        # ``inspect.Parameter`` to allow default values on VAR_POSITIONAL</span>
<span class="gi">+        # or VAR_KEYWORD parameters.</span>
<span class="w"> </span>        self.type_params: list[tuple[str, int, Any, Any]] = []

<span class="gi">+    def fetch_type_param_spec(self) -&gt; list[Token]:</span>
<span class="gi">+        tokens = []</span>
<span class="gi">+        while current := self.fetch_token():</span>
<span class="gi">+            tokens.append(current)</span>
<span class="gi">+            for ldelim, rdelim in (&#39;(&#39;, &#39;)&#39;), (&#39;{&#39;, &#39;}&#39;), (&#39;[&#39;, &#39;]&#39;):</span>
<span class="gi">+                if current == [token.OP, ldelim]:</span>
<span class="gi">+                    tokens += self.fetch_until([token.OP, rdelim])</span>
<span class="gi">+                    break</span>
<span class="gi">+            else:</span>
<span class="gi">+                if current == token.INDENT:</span>
<span class="gi">+                    tokens += self.fetch_until(token.DEDENT)</span>
<span class="gi">+                elif current.match(</span>
<span class="gi">+                        [token.OP, &#39;:&#39;], [token.OP, &#39;=&#39;], [token.OP, &#39;,&#39;]):</span>
<span class="gi">+                    tokens.pop()</span>
<span class="gi">+                    break</span>
<span class="gi">+        return tokens</span>
<span class="gi">+</span>
<span class="gi">+    def parse(self) -&gt; None:</span>
<span class="gi">+        while current := self.fetch_token():</span>
<span class="gi">+            if current == token.NAME:</span>
<span class="gi">+                tp_name = current.value.strip()</span>
<span class="gi">+                if self.previous and self.previous.match([token.OP, &#39;*&#39;], [token.OP, &#39;**&#39;]):</span>
<span class="gi">+                    if self.previous == [token.OP, &#39;*&#39;]:</span>
<span class="gi">+                        tp_kind = Parameter.VAR_POSITIONAL</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        tp_kind = Parameter.VAR_KEYWORD  # type: ignore[assignment]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    tp_kind = Parameter.POSITIONAL_OR_KEYWORD  # type: ignore[assignment]</span>
<span class="gi">+</span>
<span class="gi">+                tp_ann: Any = Parameter.empty</span>
<span class="gi">+                tp_default: Any = Parameter.empty</span>
<span class="gi">+</span>
<span class="gi">+                current = self.fetch_token()</span>
<span class="gi">+                if current and current.match([token.OP, &#39;:&#39;], [token.OP, &#39;=&#39;]):</span>
<span class="gi">+                    if current == [token.OP, &#39;:&#39;]:</span>
<span class="gi">+                        tokens = self.fetch_type_param_spec()</span>
<span class="gi">+                        tp_ann = self._build_identifier(tokens)</span>
<span class="gi">+</span>
<span class="gi">+                    if self.current and self.current == [token.OP, &#39;=&#39;]:</span>
<span class="gi">+                        tokens = self.fetch_type_param_spec()</span>
<span class="gi">+                        tp_default = self._build_identifier(tokens)</span>

<span class="gd">-def _parse_type_list(tp_list: str, env: BuildEnvironment,</span>
<span class="gd">-    multi_line_parameter_list: bool=False) -&gt;addnodes.desc_type_parameter_list:</span>
<span class="gi">+                if tp_kind != Parameter.POSITIONAL_OR_KEYWORD and tp_ann != Parameter.empty:</span>
<span class="gi">+                    msg = (&#39;type parameter bound or constraint is not allowed &#39;</span>
<span class="gi">+                           f&#39;for {tp_kind.description} parameters&#39;)</span>
<span class="gi">+                    raise SyntaxError(msg)</span>
<span class="gi">+</span>
<span class="gi">+                type_param = (tp_name, tp_kind, tp_default, tp_ann)</span>
<span class="gi">+                self.type_params.append(type_param)</span>
<span class="gi">+</span>
<span class="gi">+    def _build_identifier(self, tokens: list[Token]) -&gt; str:</span>
<span class="gi">+        from itertools import chain, islice</span>
<span class="gi">+</span>
<span class="gi">+        def triplewise(iterable: Iterable[Token]) -&gt; Iterator[tuple[Token, ...]]:</span>
<span class="gi">+            # sliding_window(&#39;ABCDEFG&#39;, 4) --&gt; ABCD BCDE CDEF DEFG</span>
<span class="gi">+            it = iter(iterable)</span>
<span class="gi">+            window = deque(islice(it, 3), maxlen=3)</span>
<span class="gi">+            if len(window) == 3:</span>
<span class="gi">+                yield tuple(window)</span>
<span class="gi">+            for x in it:</span>
<span class="gi">+                window.append(x)</span>
<span class="gi">+                yield tuple(window)</span>
<span class="gi">+</span>
<span class="gi">+        idents: list[str] = []</span>
<span class="gi">+        tokens: Iterable[Token] = iter(tokens)  # type: ignore[no-redef]</span>
<span class="gi">+        # do not format opening brackets</span>
<span class="gi">+        for tok in tokens:</span>
<span class="gi">+            if not tok.match([token.OP, &#39;(&#39;], [token.OP, &#39;[&#39;], [token.OP, &#39;{&#39;]):</span>
<span class="gi">+                # check if the first non-delimiter character is an unpack operator</span>
<span class="gi">+                is_unpack_operator = tok.match([token.OP, &#39;*&#39;], [token.OP, [&#39;**&#39;]])</span>
<span class="gi">+                idents.append(self._pformat_token(tok, native=is_unpack_operator))</span>
<span class="gi">+                break</span>
<span class="gi">+            idents.append(tok.value)</span>
<span class="gi">+</span>
<span class="gi">+        # check the remaining tokens</span>
<span class="gi">+        stop = Token(token.ENDMARKER, &#39;&#39;, (-1, -1), (-1, -1), &#39;&lt;sentinel&gt;&#39;)</span>
<span class="gi">+        is_unpack_operator = False</span>
<span class="gi">+        for tok, op, after in triplewise(chain(tokens, [stop, stop])):</span>
<span class="gi">+            ident = self._pformat_token(tok, native=is_unpack_operator)</span>
<span class="gi">+            idents.append(ident)</span>
<span class="gi">+            # determine if the next token is an unpack operator depending</span>
<span class="gi">+            # on the left and right hand side of the operator symbol</span>
<span class="gi">+            is_unpack_operator = (</span>
<span class="gi">+                op.match([token.OP, &#39;*&#39;], [token.OP, &#39;**&#39;]) and not (</span>
<span class="gi">+                    tok.match(token.NAME, token.NUMBER, token.STRING,</span>
<span class="gi">+                              [token.OP, &#39;)&#39;], [token.OP, &#39;]&#39;], [token.OP, &#39;}&#39;])</span>
<span class="gi">+                    and after.match(token.NAME, token.NUMBER, token.STRING,</span>
<span class="gi">+                                    [token.OP, &#39;(&#39;], [token.OP, &#39;[&#39;], [token.OP, &#39;{&#39;])</span>
<span class="gi">+                )</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return &#39;&#39;.join(idents).strip()</span>
<span class="gi">+</span>
<span class="gi">+    def _pformat_token(self, tok: Token, native: bool = False) -&gt; str:</span>
<span class="gi">+        if native:</span>
<span class="gi">+            return tok.value</span>
<span class="gi">+</span>
<span class="gi">+        if tok.match(token.NEWLINE, token.ENDMARKER):</span>
<span class="gi">+            return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if tok.match([token.OP, &#39;:&#39;], [token.OP, &#39;,&#39;], [token.OP, &#39;#&#39;]):</span>
<span class="gi">+            return f&#39;{tok.value} &#39;</span>
<span class="gi">+</span>
<span class="gi">+        # Arithmetic operators are allowed because PEP 695 specifies the</span>
<span class="gi">+        # default type parameter to be *any* expression (so &quot;T1 &lt;&lt; T2&quot; is</span>
<span class="gi">+        # allowed if it makes sense). The caller is responsible to ensure</span>
<span class="gi">+        # that a multiplication operator (&quot;*&quot;) is not to be confused with</span>
<span class="gi">+        # an unpack operator (which will not be surrounded by spaces).</span>
<span class="gi">+        #</span>
<span class="gi">+        # The operators are ordered according to how likely they are to</span>
<span class="gi">+        # be used and for (possible) future implementations (e.g., &quot;&amp;&quot; for</span>
<span class="gi">+        # an intersection type).</span>
<span class="gi">+        if tok.match(</span>
<span class="gi">+            # Most likely operators to appear</span>
<span class="gi">+            [token.OP, &#39;=&#39;], [token.OP, &#39;|&#39;],</span>
<span class="gi">+            # Type composition (future compatibility)</span>
<span class="gi">+            [token.OP, &#39;&amp;&#39;], [token.OP, &#39;^&#39;], [token.OP, &#39;&lt;&#39;], [token.OP, &#39;&gt;&#39;],</span>
<span class="gi">+            # Unlikely type composition</span>
<span class="gi">+            [token.OP, &#39;+&#39;], [token.OP, &#39;-&#39;], [token.OP, &#39;*&#39;], [token.OP, &#39;**&#39;],</span>
<span class="gi">+            # Unlikely operators but included for completeness</span>
<span class="gi">+            [token.OP, &#39;@&#39;], [token.OP, &#39;/&#39;], [token.OP, &#39;//&#39;], [token.OP, &#39;%&#39;],</span>
<span class="gi">+            [token.OP, &#39;&lt;&lt;&#39;], [token.OP, &#39;&gt;&gt;&#39;], [token.OP, &#39;&gt;&gt;&gt;&#39;],</span>
<span class="gi">+            [token.OP, &#39;&lt;=&#39;], [token.OP, &#39;&gt;=&#39;], [token.OP, &#39;==&#39;], [token.OP, &#39;!=&#39;],</span>
<span class="gi">+        ):</span>
<span class="gi">+            return f&#39; {tok.value} &#39;</span>
<span class="gi">+</span>
<span class="gi">+        return tok.value</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _parse_type_list(</span>
<span class="gi">+    tp_list: str, env: BuildEnvironment,</span>
<span class="gi">+    multi_line_parameter_list: bool = False,</span>
<span class="gi">+) -&gt; addnodes.desc_type_parameter_list:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a list of type parameters according to PEP 695.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    type_params = addnodes.desc_type_parameter_list(tp_list)</span>
<span class="gi">+    type_params[&#39;multi_line_parameter_list&#39;] = multi_line_parameter_list</span>
<span class="gi">+    # formal parameter names are interpreted as type parameter names and</span>
<span class="gi">+    # type annotations are interpreted as type parameter bound or constraints</span>
<span class="gi">+    parser = _TypeParameterListParser(tp_list)</span>
<span class="gi">+    parser.parse()</span>
<span class="gi">+    for (tp_name, tp_kind, tp_default, tp_ann) in parser.type_params:</span>
<span class="gi">+        # no positional-only or keyword-only allowed in a type parameters list</span>
<span class="gi">+        if tp_kind in {Parameter.POSITIONAL_ONLY, Parameter.KEYWORD_ONLY}:</span>
<span class="gi">+            msg = (&#39;positional-only or keyword-only parameters &#39;</span>
<span class="gi">+                   &#39;are prohibited in type parameter lists&#39;)</span>
<span class="gi">+            raise SyntaxError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        node = addnodes.desc_type_parameter()</span>
<span class="gi">+        if tp_kind == Parameter.VAR_POSITIONAL:</span>
<span class="gi">+            node += addnodes.desc_sig_operator(&#39;&#39;, &#39;*&#39;)</span>
<span class="gi">+        elif tp_kind == Parameter.VAR_KEYWORD:</span>
<span class="gi">+            node += addnodes.desc_sig_operator(&#39;&#39;, &#39;**&#39;)</span>
<span class="gi">+        node += addnodes.desc_sig_name(&#39;&#39;, tp_name)</span>
<span class="gi">+</span>
<span class="gi">+        if tp_ann is not Parameter.empty:</span>
<span class="gi">+            annotation = _parse_annotation(tp_ann, env)</span>
<span class="gi">+            if not annotation:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            node += addnodes.desc_sig_punctuation(&#39;&#39;, &#39;:&#39;)</span>
<span class="gi">+            node += addnodes.desc_sig_space()</span>
<span class="gi">+</span>
<span class="gi">+            type_ann_expr = addnodes.desc_sig_name(&#39;&#39;, &#39;&#39;,</span>
<span class="gi">+                                                   *annotation)  # type: ignore[arg-type]</span>
<span class="gi">+            # a type bound is ``T: U`` whereas type constraints</span>
<span class="gi">+            # must be enclosed with parentheses. ``T: (U, V)``</span>
<span class="gi">+            if tp_ann.startswith(&#39;(&#39;) and tp_ann.endswith(&#39;)&#39;):</span>
<span class="gi">+                type_ann_text = type_ann_expr.astext()</span>
<span class="gi">+                if type_ann_text.startswith(&#39;(&#39;) and type_ann_text.endswith(&#39;)&#39;):</span>
<span class="gi">+                    node += type_ann_expr</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # surrounding braces are lost when using _parse_annotation()</span>
<span class="gi">+                    node += addnodes.desc_sig_punctuation(&#39;&#39;, &#39;(&#39;)</span>
<span class="gi">+                    node += type_ann_expr  # type constraint</span>
<span class="gi">+                    node += addnodes.desc_sig_punctuation(&#39;&#39;, &#39;)&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                node += type_ann_expr  # type bound</span>
<span class="gi">+</span>
<span class="gi">+        if tp_default is not Parameter.empty:</span>
<span class="gi">+            # Always surround &#39;=&#39; with spaces, even if there is no annotation</span>
<span class="gi">+            node += addnodes.desc_sig_space()</span>
<span class="gi">+            node += addnodes.desc_sig_operator(&#39;&#39;, &#39;=&#39;)</span>
<span class="gi">+            node += addnodes.desc_sig_space()</span>
<span class="gi">+            node += nodes.inline(&#39;&#39;, tp_default,</span>
<span class="gi">+                                 classes=[&#39;default_value&#39;],</span>
<span class="gi">+                                 support_smartquotes=False)</span>

<span class="gi">+        type_params += node</span>
<span class="gi">+    return type_params</span>

<span class="gd">-def _parse_arglist(arglist: str, env: BuildEnvironment,</span>
<span class="gd">-    multi_line_parameter_list: bool=False) -&gt;addnodes.desc_parameterlist:</span>
<span class="gi">+</span>
<span class="gi">+def _parse_arglist(</span>
<span class="gi">+    arglist: str, env: BuildEnvironment, multi_line_parameter_list: bool = False,</span>
<span class="gi">+) -&gt; addnodes.desc_parameterlist:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a list of arguments using AST parser&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    params = addnodes.desc_parameterlist(arglist)</span>
<span class="gi">+    params[&#39;multi_line_parameter_list&#39;] = multi_line_parameter_list</span>
<span class="gi">+    sig = signature_from_str(&#39;(%s)&#39; % arglist)</span>
<span class="gi">+    last_kind = None</span>
<span class="gi">+    for param in sig.parameters.values():</span>
<span class="gi">+        if param.kind != param.POSITIONAL_ONLY and last_kind == param.POSITIONAL_ONLY:</span>
<span class="gi">+            # PEP-570: Separator for Positional Only Parameter: /</span>
<span class="gi">+            params += addnodes.desc_parameter(&#39;&#39;, &#39;&#39;, addnodes.desc_sig_operator(&#39;&#39;, &#39;/&#39;))</span>
<span class="gi">+        if param.kind == param.KEYWORD_ONLY and last_kind in (param.POSITIONAL_OR_KEYWORD,</span>
<span class="gi">+                                                              param.POSITIONAL_ONLY,</span>
<span class="gi">+                                                              None):</span>
<span class="gi">+            # PEP-3102: Separator for Keyword Only Parameter: *</span>
<span class="gi">+            params += addnodes.desc_parameter(&#39;&#39;, &#39;&#39;, addnodes.desc_sig_operator(&#39;&#39;, &#39;*&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        node = addnodes.desc_parameter()</span>
<span class="gi">+        if param.kind == param.VAR_POSITIONAL:</span>
<span class="gi">+            node += addnodes.desc_sig_operator(&#39;&#39;, &#39;*&#39;)</span>
<span class="gi">+            node += addnodes.desc_sig_name(&#39;&#39;, param.name)</span>
<span class="gi">+        elif param.kind == param.VAR_KEYWORD:</span>
<span class="gi">+            node += addnodes.desc_sig_operator(&#39;&#39;, &#39;**&#39;)</span>
<span class="gi">+            node += addnodes.desc_sig_name(&#39;&#39;, param.name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            node += addnodes.desc_sig_name(&#39;&#39;, param.name)</span>
<span class="gi">+</span>
<span class="gi">+        if param.annotation is not param.empty:</span>
<span class="gi">+            children = _parse_annotation(param.annotation, env)</span>
<span class="gi">+            node += addnodes.desc_sig_punctuation(&#39;&#39;, &#39;:&#39;)</span>
<span class="gi">+            node += addnodes.desc_sig_space()</span>
<span class="gi">+            node += addnodes.desc_sig_name(&#39;&#39;, &#39;&#39;, *children)  # type: ignore[arg-type]</span>
<span class="gi">+        if param.default is not param.empty:</span>
<span class="gi">+            if param.annotation is not param.empty:</span>
<span class="gi">+                node += addnodes.desc_sig_space()</span>
<span class="gi">+                node += addnodes.desc_sig_operator(&#39;&#39;, &#39;=&#39;)</span>
<span class="gi">+                node += addnodes.desc_sig_space()</span>
<span class="gi">+            else:</span>
<span class="gi">+                node += addnodes.desc_sig_operator(&#39;&#39;, &#39;=&#39;)</span>
<span class="gi">+            node += nodes.inline(&#39;&#39;, param.default, classes=[&#39;default_value&#39;],</span>
<span class="gi">+                                 support_smartquotes=False)</span>
<span class="gi">+</span>
<span class="gi">+        params += node</span>
<span class="gi">+        last_kind = param.kind</span>
<span class="gi">+</span>
<span class="gi">+    if last_kind == Parameter.POSITIONAL_ONLY:</span>
<span class="gi">+        # PEP-570: Separator for Positional Only Parameter: /</span>
<span class="gi">+        params += addnodes.desc_parameter(&#39;&#39;, &#39;&#39;, addnodes.desc_sig_operator(&#39;&#39;, &#39;/&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    return params</span>


<span class="gd">-def _pseudo_parse_arglist(signode: desc_signature, arglist: str,</span>
<span class="gd">-    multi_line_parameter_list: bool=False) -&gt;None:</span>
<span class="gi">+def _pseudo_parse_arglist(</span>
<span class="gi">+    signode: desc_signature, arglist: str, multi_line_parameter_list: bool = False,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;&quot;Parse&quot; a list of arguments separated by commas.

<span class="w"> </span>    Arguments can have &quot;optional&quot; annotations given by enclosing them in
<span class="w"> </span>    brackets.  Currently, this will split at any comma, even if it&#39;s inside a
<span class="w"> </span>    string literal (e.g. default argument value).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    paramlist = addnodes.desc_parameterlist()</span>
<span class="gi">+    paramlist[&#39;multi_line_parameter_list&#39;] = multi_line_parameter_list</span>
<span class="gi">+    stack: list[Element] = [paramlist]</span>
<span class="gi">+    try:</span>
<span class="gi">+        for argument in arglist.split(&#39;,&#39;):</span>
<span class="gi">+            argument = argument.strip()</span>
<span class="gi">+            ends_open = ends_close = 0</span>
<span class="gi">+            while argument.startswith(&#39;[&#39;):</span>
<span class="gi">+                stack.append(addnodes.desc_optional())</span>
<span class="gi">+                stack[-2] += stack[-1]</span>
<span class="gi">+                argument = argument[1:].strip()</span>
<span class="gi">+            while argument.startswith(&#39;]&#39;):</span>
<span class="gi">+                stack.pop()</span>
<span class="gi">+                argument = argument[1:].strip()</span>
<span class="gi">+            while argument.endswith(&#39;]&#39;) and not argument.endswith(&#39;[]&#39;):</span>
<span class="gi">+                ends_close += 1</span>
<span class="gi">+                argument = argument[:-1].strip()</span>
<span class="gi">+            while argument.endswith(&#39;[&#39;):</span>
<span class="gi">+                ends_open += 1</span>
<span class="gi">+                argument = argument[:-1].strip()</span>
<span class="gi">+            if argument:</span>
<span class="gi">+                stack[-1] += addnodes.desc_parameter(</span>
<span class="gi">+                    &#39;&#39;, &#39;&#39;, addnodes.desc_sig_name(argument, argument))</span>
<span class="gi">+            while ends_open:</span>
<span class="gi">+                stack.append(addnodes.desc_optional())</span>
<span class="gi">+                stack[-2] += stack[-1]</span>
<span class="gi">+                ends_open -= 1</span>
<span class="gi">+            while ends_close:</span>
<span class="gi">+                stack.pop()</span>
<span class="gi">+                ends_close -= 1</span>
<span class="gi">+        if len(stack) != 1:</span>
<span class="gi">+            raise IndexError</span>
<span class="gi">+    except IndexError:</span>
<span class="gi">+        # if there are too few or too many elements on the stack, just give up</span>
<span class="gi">+        # and treat the whole argument list as one argument, discarding the</span>
<span class="gi">+        # already partially populated paramlist node</span>
<span class="gi">+        paramlist = addnodes.desc_parameterlist()</span>
<span class="gi">+        paramlist += addnodes.desc_parameter(arglist, arglist)</span>
<span class="gi">+        signode += paramlist</span>
<span class="gi">+    else:</span>
<span class="gi">+        signode += paramlist</span>
<span class="gh">diff --git a/sphinx/domains/python/_object.py b/sphinx/domains/python/_object.py</span>
<span class="gh">index 317998cba..bdd1fdc97 100644</span>
<span class="gd">--- a/sphinx/domains/python/_object.py</span>
<span class="gi">+++ b/sphinx/domains/python/_object.py</span>
<span class="gu">@@ -1,38 +1,128 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import contextlib
<span class="w"> </span>import re
<span class="w"> </span>from typing import TYPE_CHECKING, ClassVar
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.parsers.rst import directives
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.addnodes import desc_signature, pending_xref, pending_xref_condition
<span class="w"> </span>from sphinx.directives import ObjectDescription
<span class="gd">-from sphinx.domains.python._annotations import _parse_annotation, _parse_arglist, _parse_type_list, _pseudo_parse_arglist, parse_reftarget</span>
<span class="gi">+from sphinx.domains.python._annotations import (</span>
<span class="gi">+    _parse_annotation,</span>
<span class="gi">+    _parse_arglist,</span>
<span class="gi">+    _parse_type_list,</span>
<span class="gi">+    _pseudo_parse_arglist,</span>
<span class="gi">+    parse_reftarget,</span>
<span class="gi">+)</span>
<span class="w"> </span>from sphinx.locale import _
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.docfields import Field, GroupedField, TypedField
<span class="gd">-from sphinx.util.nodes import make_id</span>
<span class="gi">+from sphinx.util.nodes import (</span>
<span class="gi">+    make_id,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.nodes import Node
<span class="w"> </span>    from docutils.parsers.rst.states import Inliner
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="w"> </span>    from sphinx.util.typing import OptionSpec, TextlikeNode
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gi">+</span>
<span class="gi">+# REs for Python signatures</span>
<span class="w"> </span>py_sig_re = re.compile(
<span class="gd">-    &quot;&quot;&quot;^ ([\\w.]*\\.)?            # class name(s)</span>
<span class="gd">-          (\\w+)  \\s*             # thing name</span>
<span class="gd">-          (?: \\[\\s*(.*)\\s*])?    # optional: type parameters list</span>
<span class="gd">-          (?: \\(\\s*(.*)\\s*\\)     # optional: arguments</span>
<span class="gd">-           (?:\\s* -&gt; \\s* (.*))?  #           return annotation</span>
<span class="gi">+    r&#39;&#39;&#39;^ ([\w.]*\.)?            # class name(s)</span>
<span class="gi">+          (\w+)  \s*             # thing name</span>
<span class="gi">+          (?: \[\s*(.*)\s*])?    # optional: type parameters list</span>
<span class="gi">+          (?: \(\s*(.*)\s*\)     # optional: arguments</span>
<span class="gi">+           (?:\s* -&gt; \s* (.*))?  #           return annotation</span>
<span class="w"> </span>          )? $                   # and nothing more
<span class="gd">-          &quot;&quot;&quot;</span>
<span class="gd">-    , re.VERBOSE)</span>
<span class="gi">+          &#39;&#39;&#39;, re.VERBOSE)</span>


<span class="gi">+# This override allows our inline type specifiers to behave like :class: link</span>
<span class="gi">+# when it comes to handling &quot;.&quot; and &quot;~&quot; prefixes.</span>
<span class="w"> </span>class PyXrefMixin:
<span class="gi">+    def make_xref(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rolename: str,</span>
<span class="gi">+        domain: str,</span>
<span class="gi">+        target: str,</span>
<span class="gi">+        innernode: type[TextlikeNode] = nodes.emphasis,</span>
<span class="gi">+        contnode: Node | None = None,</span>
<span class="gi">+        env: BuildEnvironment | None = None,</span>
<span class="gi">+        inliner: Inliner | None = None,</span>
<span class="gi">+        location: Node | None = None,</span>
<span class="gi">+    ) -&gt; Node:</span>
<span class="gi">+        # we use inliner=None to make sure we get the old behaviour with a single</span>
<span class="gi">+        # pending_xref node</span>
<span class="gi">+        result = super().make_xref(rolename, domain, target,  # type: ignore[misc]</span>
<span class="gi">+                                   innernode, contnode,</span>
<span class="gi">+                                   env, inliner=None, location=None)</span>
<span class="gi">+        if isinstance(result, pending_xref):</span>
<span class="gi">+            assert env is not None</span>
<span class="gi">+            result[&#39;refspecific&#39;] = True</span>
<span class="gi">+            result[&#39;py:module&#39;] = env.ref_context.get(&#39;py:module&#39;)</span>
<span class="gi">+            result[&#39;py:class&#39;] = env.ref_context.get(&#39;py:class&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            reftype, reftarget, reftitle, _ = parse_reftarget(target)</span>
<span class="gi">+            if reftarget != reftitle:</span>
<span class="gi">+                result[&#39;reftype&#39;] = reftype</span>
<span class="gi">+                result[&#39;reftarget&#39;] = reftarget</span>
<span class="gi">+</span>
<span class="gi">+                result.clear()</span>
<span class="gi">+                result += innernode(reftitle, reftitle)  # type: ignore[call-arg]</span>
<span class="gi">+            elif env.config.python_use_unqualified_type_names:</span>
<span class="gi">+                children = result.children</span>
<span class="gi">+                result.clear()</span>
<span class="gi">+</span>
<span class="gi">+                shortname = target.split(&#39;.&#39;)[-1]</span>
<span class="gi">+                textnode = innernode(&#39;&#39;, shortname)  # type: ignore[call-arg]</span>
<span class="gi">+                contnodes = [pending_xref_condition(&#39;&#39;, &#39;&#39;, textnode, condition=&#39;resolved&#39;),</span>
<span class="gi">+                             pending_xref_condition(&#39;&#39;, &#39;&#39;, *children, condition=&#39;*&#39;)]</span>
<span class="gi">+                result.extend(contnodes)</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="w"> </span>    _delimiters_re = re.compile(
<span class="gd">-        &#39;(\\s*[\\[\\]\\(\\),](?:\\s*o[rf]\\s)?\\s*|\\s+o[rf]\\s+|\\s*\\|\\s*|\\.\\.\\.)&#39;</span>
<span class="gd">-        )</span>
<span class="gi">+        r&#39;(\s*[\[\]\(\),](?:\s*o[rf]\s)?\s*|\s+o[rf]\s+|\s*\|\s*|\.\.\.)&#39;</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def make_xrefs(</span>
<span class="gi">+        self,</span>
<span class="gi">+        rolename: str,</span>
<span class="gi">+        domain: str,</span>
<span class="gi">+        target: str,</span>
<span class="gi">+        innernode: type[TextlikeNode] = nodes.emphasis,</span>
<span class="gi">+        contnode: Node | None = None,</span>
<span class="gi">+        env: BuildEnvironment | None = None,</span>
<span class="gi">+        inliner: Inliner | None = None,</span>
<span class="gi">+        location: Node | None = None,</span>
<span class="gi">+    ) -&gt; list[Node]:</span>
<span class="gi">+        sub_targets = self._delimiters_re.split(target)</span>
<span class="gi">+</span>
<span class="gi">+        split_contnode = bool(contnode and contnode.astext() == target)</span>
<span class="gi">+</span>
<span class="gi">+        in_literal = False</span>
<span class="gi">+        results = []</span>
<span class="gi">+        for sub_target in filter(None, sub_targets):</span>
<span class="gi">+            if split_contnode:</span>
<span class="gi">+                contnode = nodes.Text(sub_target)</span>
<span class="gi">+</span>
<span class="gi">+            if in_literal or self._delimiters_re.match(sub_target):</span>
<span class="gi">+                results.append(contnode or innernode(sub_target, sub_target))  # type: ignore[call-arg]</span>
<span class="gi">+            else:</span>
<span class="gi">+                results.append(self.make_xref(rolename, domain, sub_target,</span>
<span class="gi">+                                              innernode, contnode, env, inliner, location))</span>
<span class="gi">+</span>
<span class="gi">+            if sub_target in {&#39;Literal&#39;, &#39;typing.Literal&#39;, &#39;~typing.Literal&#39;}:</span>
<span class="gi">+                in_literal = True</span>
<span class="gi">+</span>
<span class="gi">+        return results</span>


<span class="w"> </span>class PyField(PyXrefMixin, Field):
<span class="gu">@@ -54,41 +144,56 @@ class PyObject(ObjectDescription[tuple[str, str]]):</span>
<span class="w"> </span>    :cvar allow_nesting: Class is an object that allows for nested namespaces
<span class="w"> </span>    :vartype allow_nesting: bool
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    option_spec: ClassVar[OptionSpec] = {&#39;no-index&#39;: directives.flag,</span>
<span class="gd">-        &#39;no-index-entry&#39;: directives.flag, &#39;no-contents-entry&#39;: directives.</span>
<span class="gd">-        flag, &#39;no-typesetting&#39;: directives.flag, &#39;noindex&#39;: directives.flag,</span>
<span class="gd">-        &#39;noindexentry&#39;: directives.flag, &#39;nocontentsentry&#39;: directives.flag,</span>
<span class="gi">+</span>
<span class="gi">+    option_spec: ClassVar[OptionSpec] = {</span>
<span class="gi">+        &#39;no-index&#39;: directives.flag,</span>
<span class="gi">+        &#39;no-index-entry&#39;: directives.flag,</span>
<span class="gi">+        &#39;no-contents-entry&#39;: directives.flag,</span>
<span class="gi">+        &#39;no-typesetting&#39;: directives.flag,</span>
<span class="gi">+        &#39;noindex&#39;: directives.flag,</span>
<span class="gi">+        &#39;noindexentry&#39;: directives.flag,</span>
<span class="gi">+        &#39;nocontentsentry&#39;: directives.flag,</span>
<span class="w"> </span>        &#39;single-line-parameter-list&#39;: directives.flag,
<span class="gd">-        &#39;single-line-type-parameter-list&#39;: directives.flag, &#39;module&#39;:</span>
<span class="gd">-        directives.unchanged, &#39;canonical&#39;: directives.unchanged,</span>
<span class="gd">-        &#39;annotation&#39;: directives.unchanged}</span>
<span class="gd">-    doc_field_types = [PyTypedField(&#39;parameter&#39;, label=_(&#39;Parameters&#39;),</span>
<span class="gd">-        names=(&#39;param&#39;, &#39;parameter&#39;, &#39;arg&#39;, &#39;argument&#39;, &#39;keyword&#39;, &#39;kwarg&#39;,</span>
<span class="gd">-        &#39;kwparam&#39;), typerolename=&#39;class&#39;, typenames=(&#39;paramtype&#39;, &#39;type&#39;),</span>
<span class="gd">-        can_collapse=True), PyTypedField(&#39;variable&#39;, label=_(&#39;Variables&#39;),</span>
<span class="gd">-        names=(&#39;var&#39;, &#39;ivar&#39;, &#39;cvar&#39;), typerolename=&#39;class&#39;, typenames=(</span>
<span class="gd">-        &#39;vartype&#39;,), can_collapse=True), PyGroupedField(&#39;exceptions&#39;, label</span>
<span class="gd">-        =_(&#39;Raises&#39;), rolename=&#39;exc&#39;, names=(&#39;raises&#39;, &#39;raise&#39;, &#39;exception&#39;,</span>
<span class="gd">-        &#39;except&#39;), can_collapse=True), Field(&#39;returnvalue&#39;, label=_(</span>
<span class="gd">-        &#39;Returns&#39;), has_arg=False, names=(&#39;returns&#39;, &#39;return&#39;)), PyField(</span>
<span class="gd">-        &#39;returntype&#39;, label=_(&#39;Return type&#39;), has_arg=False, names=(&#39;rtype&#39;</span>
<span class="gd">-        ,), bodyrolename=&#39;class&#39;)]</span>
<span class="gi">+        &#39;single-line-type-parameter-list&#39;: directives.flag,</span>
<span class="gi">+        &#39;module&#39;: directives.unchanged,</span>
<span class="gi">+        &#39;canonical&#39;: directives.unchanged,</span>
<span class="gi">+        &#39;annotation&#39;: directives.unchanged,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    doc_field_types = [</span>
<span class="gi">+        PyTypedField(&#39;parameter&#39;, label=_(&#39;Parameters&#39;),</span>
<span class="gi">+                     names=(&#39;param&#39;, &#39;parameter&#39;, &#39;arg&#39;, &#39;argument&#39;,</span>
<span class="gi">+                            &#39;keyword&#39;, &#39;kwarg&#39;, &#39;kwparam&#39;),</span>
<span class="gi">+                     typerolename=&#39;class&#39;, typenames=(&#39;paramtype&#39;, &#39;type&#39;),</span>
<span class="gi">+                     can_collapse=True),</span>
<span class="gi">+        PyTypedField(&#39;variable&#39;, label=_(&#39;Variables&#39;),</span>
<span class="gi">+                     names=(&#39;var&#39;, &#39;ivar&#39;, &#39;cvar&#39;),</span>
<span class="gi">+                     typerolename=&#39;class&#39;, typenames=(&#39;vartype&#39;,),</span>
<span class="gi">+                     can_collapse=True),</span>
<span class="gi">+        PyGroupedField(&#39;exceptions&#39;, label=_(&#39;Raises&#39;), rolename=&#39;exc&#39;,</span>
<span class="gi">+                       names=(&#39;raises&#39;, &#39;raise&#39;, &#39;exception&#39;, &#39;except&#39;),</span>
<span class="gi">+                       can_collapse=True),</span>
<span class="gi">+        Field(&#39;returnvalue&#39;, label=_(&#39;Returns&#39;), has_arg=False,</span>
<span class="gi">+              names=(&#39;returns&#39;, &#39;return&#39;)),</span>
<span class="gi">+        PyField(&#39;returntype&#39;, label=_(&#39;Return type&#39;), has_arg=False,</span>
<span class="gi">+                names=(&#39;rtype&#39;,), bodyrolename=&#39;class&#39;),</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="w"> </span>    allow_nesting = False

<span class="gd">-    def get_signature_prefix(self, sig: str) -&gt;list[nodes.Node]:</span>
<span class="gi">+    def get_signature_prefix(self, sig: str) -&gt; list[nodes.Node]:</span>
<span class="w"> </span>        &quot;&quot;&quot;May return a prefix to put before the object name in the
<span class="w"> </span>        signature.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return []</span>

<span class="gd">-    def needs_arglist(self) -&gt;bool:</span>
<span class="gi">+    def needs_arglist(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;May return true if an empty argument list is to be generated even if
<span class="w"> </span>        the document contains none.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return False</span>

<span class="gd">-    def handle_signature(self, sig: str, signode: desc_signature) -&gt;tuple[</span>
<span class="gd">-        str, str]:</span>
<span class="gi">+    def handle_signature(self, sig: str, signode: desc_signature) -&gt; tuple[str, str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Transform a Python signature into RST nodes.

<span class="w"> </span>        Return (fully qualified name of the thing, classname if any).
<span class="gu">@@ -97,13 +202,155 @@ class PyObject(ObjectDescription[tuple[str, str]]):</span>
<span class="w"> </span>        * it is stripped from the displayed name if present
<span class="w"> </span>        * it is added to the full name (return value) if not present
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        m = py_sig_re.match(sig)</span>
<span class="gi">+        if m is None:</span>
<span class="gi">+            raise ValueError</span>
<span class="gi">+        prefix, name, tp_list, arglist, retann = m.groups()</span>
<span class="gi">+</span>
<span class="gi">+        # determine module and class name (if applicable), as well as full name</span>
<span class="gi">+        modname = self.options.get(&#39;module&#39;, self.env.ref_context.get(&#39;py:module&#39;))</span>
<span class="gi">+        classname = self.env.ref_context.get(&#39;py:class&#39;)</span>
<span class="gi">+        if classname:</span>
<span class="gi">+            add_module = False</span>
<span class="gi">+            if prefix and (prefix == classname or</span>
<span class="gi">+                           prefix.startswith(classname + &quot;.&quot;)):</span>
<span class="gi">+                fullname = prefix + name</span>
<span class="gi">+                # class name is given again in the signature</span>
<span class="gi">+                prefix = prefix[len(classname):].lstrip(&#39;.&#39;)</span>
<span class="gi">+            elif prefix:</span>
<span class="gi">+                # class name is given in the signature, but different</span>
<span class="gi">+                # (shouldn&#39;t happen)</span>
<span class="gi">+                fullname = classname + &#39;.&#39; + prefix + name</span>
<span class="gi">+            else:</span>
<span class="gi">+                # class name is not given in the signature</span>
<span class="gi">+                fullname = classname + &#39;.&#39; + name</span>
<span class="gi">+        else:</span>
<span class="gi">+            add_module = True</span>
<span class="gi">+            if prefix:</span>
<span class="gi">+                classname = prefix.rstrip(&#39;.&#39;)</span>
<span class="gi">+                fullname = prefix + name</span>
<span class="gi">+            else:</span>
<span class="gi">+                classname = &#39;&#39;</span>
<span class="gi">+                fullname = name</span>

<span class="gd">-    def get_index_text(self, modname: str, name: tuple[str, str]) -&gt;str:</span>
<span class="gi">+        signode[&#39;module&#39;] = modname</span>
<span class="gi">+        signode[&#39;class&#39;] = classname</span>
<span class="gi">+        signode[&#39;fullname&#39;] = fullname</span>
<span class="gi">+</span>
<span class="gi">+        max_len = (self.env.config.python_maximum_signature_line_length</span>
<span class="gi">+                   or self.env.config.maximum_signature_line_length</span>
<span class="gi">+                   or 0)</span>
<span class="gi">+</span>
<span class="gi">+        # determine if the function arguments (without its type parameters)</span>
<span class="gi">+        # should be formatted on a multiline or not by removing the width of</span>
<span class="gi">+        # the type parameters list (if any)</span>
<span class="gi">+        sig_len = len(sig)</span>
<span class="gi">+        tp_list_span = m.span(3)</span>
<span class="gi">+        multi_line_parameter_list = (</span>
<span class="gi">+            &#39;single-line-parameter-list&#39; not in self.options</span>
<span class="gi">+            and (sig_len - (tp_list_span[1] - tp_list_span[0])) &gt; max_len &gt; 0</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # determine whether the type parameter list must be wrapped or not</span>
<span class="gi">+        arglist_span = m.span(4)</span>
<span class="gi">+        multi_line_type_parameter_list = (</span>
<span class="gi">+            &#39;single-line-type-parameter-list&#39; not in self.options</span>
<span class="gi">+            and (sig_len - (arglist_span[1] - arglist_span[0])) &gt; max_len &gt; 0</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        sig_prefix = self.get_signature_prefix(sig)</span>
<span class="gi">+        if sig_prefix:</span>
<span class="gi">+            if type(sig_prefix) is str:</span>
<span class="gi">+                msg = (&quot;Python directive method get_signature_prefix()&quot;</span>
<span class="gi">+                       &quot; must return a list of nodes.&quot;</span>
<span class="gi">+                       f&quot; Return value was &#39;{sig_prefix}&#39;.&quot;)</span>
<span class="gi">+                raise TypeError(msg)</span>
<span class="gi">+            signode += addnodes.desc_annotation(str(sig_prefix), &#39;&#39;, *sig_prefix)</span>
<span class="gi">+</span>
<span class="gi">+        if prefix:</span>
<span class="gi">+            signode += addnodes.desc_addname(prefix, prefix)</span>
<span class="gi">+        elif modname and add_module and self.env.config.add_module_names:</span>
<span class="gi">+            nodetext = modname + &#39;.&#39;</span>
<span class="gi">+            signode += addnodes.desc_addname(nodetext, nodetext)</span>
<span class="gi">+</span>
<span class="gi">+        signode += addnodes.desc_name(name, name)</span>
<span class="gi">+</span>
<span class="gi">+        if tp_list:</span>
<span class="gi">+            try:</span>
<span class="gi">+                signode += _parse_type_list(tp_list, self.env, multi_line_type_parameter_list)</span>
<span class="gi">+            except Exception as exc:</span>
<span class="gi">+                logger.warning(&quot;could not parse tp_list (%r): %s&quot;, tp_list, exc,</span>
<span class="gi">+                               location=signode)</span>
<span class="gi">+</span>
<span class="gi">+        if arglist:</span>
<span class="gi">+            try:</span>
<span class="gi">+                signode += _parse_arglist(arglist, self.env, multi_line_parameter_list)</span>
<span class="gi">+            except SyntaxError:</span>
<span class="gi">+                # fallback to parse arglist original parser</span>
<span class="gi">+                # (this may happen if the argument list is incorrectly used</span>
<span class="gi">+                # as a list of bases when documenting a class)</span>
<span class="gi">+                # it supports to represent optional arguments (ex. &quot;func(foo [, bar])&quot;)</span>
<span class="gi">+                _pseudo_parse_arglist(signode, arglist, multi_line_parameter_list)</span>
<span class="gi">+            except (NotImplementedError, ValueError) as exc:</span>
<span class="gi">+                # duplicated parameter names raise ValueError and not a SyntaxError</span>
<span class="gi">+                logger.warning(&quot;could not parse arglist (%r): %s&quot;, arglist, exc,</span>
<span class="gi">+                               location=signode)</span>
<span class="gi">+                _pseudo_parse_arglist(signode, arglist, multi_line_parameter_list)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self.needs_arglist():</span>
<span class="gi">+                # for callables, add an empty parameter list</span>
<span class="gi">+                signode += addnodes.desc_parameterlist()</span>
<span class="gi">+</span>
<span class="gi">+        if retann:</span>
<span class="gi">+            children = _parse_annotation(retann, self.env)</span>
<span class="gi">+            signode += addnodes.desc_returns(retann, &#39;&#39;, *children)</span>
<span class="gi">+</span>
<span class="gi">+        anno = self.options.get(&#39;annotation&#39;)</span>
<span class="gi">+        if anno:</span>
<span class="gi">+            signode += addnodes.desc_annotation(&#39; &#39; + anno, &#39;&#39;,</span>
<span class="gi">+                                                addnodes.desc_sig_space(),</span>
<span class="gi">+                                                nodes.Text(anno))</span>
<span class="gi">+</span>
<span class="gi">+        return fullname, prefix</span>
<span class="gi">+</span>
<span class="gi">+    def _object_hierarchy_parts(self, sig_node: desc_signature) -&gt; tuple[str, ...]:</span>
<span class="gi">+        if &#39;fullname&#39; not in sig_node:</span>
<span class="gi">+            return ()</span>
<span class="gi">+        modname = sig_node.get(&#39;module&#39;)</span>
<span class="gi">+        fullname = sig_node[&#39;fullname&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        if modname:</span>
<span class="gi">+            return (modname, *fullname.split(&#39;.&#39;))</span>
<span class="gi">+        else:</span>
<span class="gi">+            return tuple(fullname.split(&#39;.&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    def get_index_text(self, modname: str, name: tuple[str, str]) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the text for the index entry of the object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        msg = &#39;must be implemented in subclasses&#39;</span>
<span class="gi">+        raise NotImplementedError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    def add_target_and_index(self, name_cls: tuple[str, str], sig: str,</span>
<span class="gi">+                             signode: desc_signature) -&gt; None:</span>
<span class="gi">+        modname = self.options.get(&#39;module&#39;, self.env.ref_context.get(&#39;py:module&#39;))</span>
<span class="gi">+        fullname = (modname + &#39;.&#39; if modname else &#39;&#39;) + name_cls[0]</span>
<span class="gi">+        node_id = make_id(self.env, self.state.document, &#39;&#39;, fullname)</span>
<span class="gi">+        signode[&#39;ids&#39;].append(node_id)</span>
<span class="gi">+        self.state.document.note_explicit_target(signode)</span>
<span class="gi">+</span>
<span class="gi">+        domain = self.env.domains[&#39;py&#39;]</span>
<span class="gi">+        domain.note_object(fullname, self.objtype, node_id, location=signode)</span>

<span class="gd">-    def before_content(self) -&gt;None:</span>
<span class="gi">+        canonical_name = self.options.get(&#39;canonical&#39;)</span>
<span class="gi">+        if canonical_name:</span>
<span class="gi">+            domain.note_object(canonical_name, self.objtype, node_id, aliased=True,</span>
<span class="gi">+                               location=signode)</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;no-index-entry&#39; not in self.options:</span>
<span class="gi">+            indextext = self.get_index_text(modname, name_cls)</span>
<span class="gi">+            if indextext:</span>
<span class="gi">+                self.indexnode[&#39;entries&#39;].append((&#39;single&#39;, indextext, node_id, &#39;&#39;, None))</span>
<span class="gi">+</span>
<span class="gi">+    def before_content(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handle object nesting before content

<span class="w"> </span>        :py:class:`PyObject` represents Python language constructs. For
<span class="gu">@@ -115,9 +362,28 @@ class PyObject(ObjectDescription[tuple[str, str]]):</span>
<span class="w"> </span>        only the most recent object is tracked. This object prefix name will be
<span class="w"> </span>        removed with :py:meth:`after_content`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        prefix = None</span>
<span class="gi">+        if self.names:</span>
<span class="gi">+            # fullname and name_prefix come from the `handle_signature` method.</span>
<span class="gi">+            # fullname represents the full object name that is constructed using</span>
<span class="gi">+            # object nesting and explicit prefixes. `name_prefix` is the</span>
<span class="gi">+            # explicit prefix given in a signature</span>
<span class="gi">+            (fullname, name_prefix) = self.names[-1]</span>
<span class="gi">+            if self.allow_nesting:</span>
<span class="gi">+                prefix = fullname</span>
<span class="gi">+            elif name_prefix:</span>
<span class="gi">+                prefix = name_prefix.strip(&#39;.&#39;)</span>
<span class="gi">+        if prefix:</span>
<span class="gi">+            self.env.ref_context[&#39;py:class&#39;] = prefix</span>
<span class="gi">+            if self.allow_nesting:</span>
<span class="gi">+                classes = self.env.ref_context.setdefault(&#39;py:classes&#39;, [])</span>
<span class="gi">+                classes.append(prefix)</span>
<span class="gi">+        if &#39;module&#39; in self.options:</span>
<span class="gi">+            modules = self.env.ref_context.setdefault(&#39;py:modules&#39;, [])</span>
<span class="gi">+            modules.append(self.env.ref_context.get(&#39;py:module&#39;))</span>
<span class="gi">+            self.env.ref_context[&#39;py:module&#39;] = self.options[&#39;module&#39;]</span>

<span class="gd">-    def after_content(self) -&gt;None:</span>
<span class="gi">+    def after_content(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handle object de-nesting after content

<span class="w"> </span>        If this class is a nestable object, removing the last nested class prefix
<span class="gu">@@ -127,4 +393,35 @@ class PyObject(ObjectDescription[tuple[str, str]]):</span>
<span class="w"> </span>        be altered as we didn&#39;t affect the nesting levels in
<span class="w"> </span>        :py:meth:`before_content`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        classes = self.env.ref_context.setdefault(&#39;py:classes&#39;, [])</span>
<span class="gi">+        if self.allow_nesting:</span>
<span class="gi">+            with contextlib.suppress(IndexError):</span>
<span class="gi">+                classes.pop()</span>
<span class="gi">+</span>
<span class="gi">+        self.env.ref_context[&#39;py:class&#39;] = (classes[-1] if len(classes) &gt; 0</span>
<span class="gi">+                                            else None)</span>
<span class="gi">+        if &#39;module&#39; in self.options:</span>
<span class="gi">+            modules = self.env.ref_context.setdefault(&#39;py:modules&#39;, [])</span>
<span class="gi">+            if modules:</span>
<span class="gi">+                self.env.ref_context[&#39;py:module&#39;] = modules.pop()</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.env.ref_context.pop(&#39;py:module&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def _toc_entry_name(self, sig_node: desc_signature) -&gt; str:</span>
<span class="gi">+        if not sig_node.get(&#39;_toc_parts&#39;):</span>
<span class="gi">+            return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        config = self.env.app.config</span>
<span class="gi">+        objtype = sig_node.parent.get(&#39;objtype&#39;)</span>
<span class="gi">+        if config.add_function_parentheses and objtype in {&#39;function&#39;, &#39;method&#39;}:</span>
<span class="gi">+            parens = &#39;()&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            parens = &#39;&#39;</span>
<span class="gi">+        *parents, name = sig_node[&#39;_toc_parts&#39;]</span>
<span class="gi">+        if config.toc_object_entries_show_parents == &#39;domain&#39;:</span>
<span class="gi">+            return sig_node.get(&#39;fullname&#39;, name) + parens</span>
<span class="gi">+        if config.toc_object_entries_show_parents == &#39;hide&#39;:</span>
<span class="gi">+            return name + parens</span>
<span class="gi">+        if config.toc_object_entries_show_parents == &#39;all&#39;:</span>
<span class="gi">+            return &#39;.&#39;.join([*parents, name + parens])</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gh">diff --git a/sphinx/domains/rst.py b/sphinx/domains/rst.py</span>
<span class="gh">index fb22cbab5..99d995d48 100644</span>
<span class="gd">--- a/sphinx/domains/rst.py</span>
<span class="gi">+++ b/sphinx/domains/rst.py</span>
<span class="gu">@@ -1,8 +1,12 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The reStructuredText domain.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from typing import TYPE_CHECKING, Any, ClassVar, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils.parsers.rst import directives
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.directives import ObjectDescription
<span class="w"> </span>from sphinx.domains import Domain, ObjType
<span class="gu">@@ -10,35 +14,99 @@ from sphinx.locale import _, __</span>
<span class="w"> </span>from sphinx.roles import XRefRole
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.nodes import make_id, make_refnode
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Iterator
<span class="gi">+</span>
<span class="w"> </span>    from docutils.nodes import Element
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.addnodes import desc_signature, pending_xref
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.builders import Builder
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata, OptionSpec
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gd">-dir_sig_re = re.compile(&#39;\\.\\. (.+?)::(.*)$&#39;)</span>
<span class="gi">+</span>
<span class="gi">+dir_sig_re = re.compile(r&#39;\.\. (.+?)::(.*)$&#39;)</span>


<span class="w"> </span>class ReSTMarkup(ObjectDescription[str]):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Description of generic reST markup.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    option_spec: ClassVar[OptionSpec] = {&#39;no-index&#39;: directives.flag,</span>
<span class="gd">-        &#39;no-index-entry&#39;: directives.flag, &#39;no-contents-entry&#39;: directives.</span>
<span class="gd">-        flag, &#39;no-typesetting&#39;: directives.flag, &#39;noindex&#39;: directives.flag,</span>
<span class="gd">-        &#39;noindexentry&#39;: directives.flag, &#39;nocontentsentry&#39;: directives.flag}</span>

<span class="gi">+    option_spec: ClassVar[OptionSpec] = {</span>
<span class="gi">+        &#39;no-index&#39;: directives.flag,</span>
<span class="gi">+        &#39;no-index-entry&#39;: directives.flag,</span>
<span class="gi">+        &#39;no-contents-entry&#39;: directives.flag,</span>
<span class="gi">+        &#39;no-typesetting&#39;: directives.flag,</span>
<span class="gi">+        &#39;noindex&#39;: directives.flag,</span>
<span class="gi">+        &#39;noindexentry&#39;: directives.flag,</span>
<span class="gi">+        &#39;nocontentsentry&#39;: directives.flag,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def add_target_and_index(self, name: str, sig: str, signode: desc_signature) -&gt; None:</span>
<span class="gi">+        node_id = make_id(self.env, self.state.document, self.objtype, name)</span>
<span class="gi">+        signode[&#39;ids&#39;].append(node_id)</span>
<span class="gi">+        self.state.document.note_explicit_target(signode)</span>
<span class="gi">+</span>
<span class="gi">+        domain = cast(ReSTDomain, self.env.get_domain(&#39;rst&#39;))</span>
<span class="gi">+        domain.note_object(self.objtype, name, node_id, location=signode)</span>

<span class="gd">-def parse_directive(d: str) -&gt;tuple[str, str]:</span>
<span class="gi">+        if &#39;no-index-entry&#39; not in self.options:</span>
<span class="gi">+            indextext = self.get_index_text(self.objtype, name)</span>
<span class="gi">+            if indextext:</span>
<span class="gi">+                self.indexnode[&#39;entries&#39;].append((&#39;single&#39;, indextext, node_id, &#39;&#39;, None))</span>
<span class="gi">+</span>
<span class="gi">+    def get_index_text(self, objectname: str, name: str) -&gt; str:</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def _object_hierarchy_parts(self, sig_node: desc_signature) -&gt; tuple[str, ...]:</span>
<span class="gi">+        if &#39;fullname&#39; not in sig_node:</span>
<span class="gi">+            return ()</span>
<span class="gi">+        directive_names = []</span>
<span class="gi">+        for parent in self.env.ref_context.get(&#39;rst:directives&#39;, ()):</span>
<span class="gi">+            directive_names += parent.split(&#39;:&#39;)</span>
<span class="gi">+        name = sig_node[&#39;fullname&#39;]</span>
<span class="gi">+        return tuple(directive_names + name.split(&#39;:&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    def _toc_entry_name(self, sig_node: desc_signature) -&gt; str:</span>
<span class="gi">+        if not sig_node.get(&#39;_toc_parts&#39;):</span>
<span class="gi">+            return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        config = self.env.app.config</span>
<span class="gi">+        objtype = sig_node.parent.get(&#39;objtype&#39;)</span>
<span class="gi">+        *parents, name = sig_node[&#39;_toc_parts&#39;]</span>
<span class="gi">+        if objtype == &#39;directive:option&#39;:</span>
<span class="gi">+            return f&#39;:{name}:&#39;</span>
<span class="gi">+        if config.toc_object_entries_show_parents in {&#39;domain&#39;, &#39;all&#39;}:</span>
<span class="gi">+            name = &#39;:&#39;.join(sig_node[&#39;_toc_parts&#39;])</span>
<span class="gi">+        if objtype == &#39;role&#39;:</span>
<span class="gi">+            return f&#39;:{name}:&#39;</span>
<span class="gi">+        if objtype == &#39;directive&#39;:</span>
<span class="gi">+            return f&#39;.. {name}::&#39;</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_directive(d: str) -&gt; tuple[str, str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a directive signature.

<span class="w"> </span>    Returns (directive, arguments) string tuple.  If no arguments are given,
<span class="w"> </span>    returns (directive, &#39;&#39;).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    dir = d.strip()</span>
<span class="gi">+    if not dir.startswith(&#39;.&#39;):</span>
<span class="gi">+        # Assume it is a directive without syntax</span>
<span class="gi">+        return (dir, &#39;&#39;)</span>
<span class="gi">+    m = dir_sig_re.match(dir)</span>
<span class="gi">+    if not m:</span>
<span class="gi">+        return (dir, &#39;&#39;)</span>
<span class="gi">+    parsed_dir, parsed_args = m.groups()</span>
<span class="gi">+    if parsed_args.strip():</span>
<span class="gi">+        return (parsed_dir.strip(), &#39; &#39; + parsed_args.strip())</span>
<span class="gi">+    else:</span>
<span class="gi">+        return (parsed_dir.strip(), &#39;&#39;)</span>


<span class="w"> </span>class ReSTDirective(ReSTMarkup):
<span class="gu">@@ -46,13 +114,88 @@ class ReSTDirective(ReSTMarkup):</span>
<span class="w"> </span>    Description of a reST directive.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def handle_signature(self, sig: str, signode: desc_signature) -&gt; str:</span>
<span class="gi">+        name, args = parse_directive(sig)</span>
<span class="gi">+        desc_name = f&#39;.. {name}::&#39;</span>
<span class="gi">+        signode[&#39;fullname&#39;] = name.strip()</span>
<span class="gi">+        signode += addnodes.desc_name(desc_name, desc_name)</span>
<span class="gi">+        if len(args) &gt; 0:</span>
<span class="gi">+            signode += addnodes.desc_addname(args, args)</span>
<span class="gi">+        return name</span>
<span class="gi">+</span>
<span class="gi">+    def get_index_text(self, objectname: str, name: str) -&gt; str:</span>
<span class="gi">+        return _(&#39;%s (directive)&#39;) % name</span>
<span class="gi">+</span>
<span class="gi">+    def before_content(self) -&gt; None:</span>
<span class="gi">+        if self.names:</span>
<span class="gi">+            directives = self.env.ref_context.setdefault(&#39;rst:directives&#39;, [])</span>
<span class="gi">+            directives.append(self.names[0])</span>
<span class="gi">+</span>
<span class="gi">+    def after_content(self) -&gt; None:</span>
<span class="gi">+        directives = self.env.ref_context.setdefault(&#39;rst:directives&#39;, [])</span>
<span class="gi">+        if directives:</span>
<span class="gi">+            directives.pop()</span>
<span class="gi">+</span>

<span class="w"> </span>class ReSTDirectiveOption(ReSTMarkup):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Description of an option for reST directive.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    option_spec: ClassVar[OptionSpec] = ReSTMarkup.option_spec.copy()
<span class="gd">-    option_spec.update({&#39;type&#39;: directives.unchanged})</span>
<span class="gi">+    option_spec.update({</span>
<span class="gi">+        &#39;type&#39;: directives.unchanged,</span>
<span class="gi">+    })</span>
<span class="gi">+</span>
<span class="gi">+    def handle_signature(self, sig: str, signode: desc_signature) -&gt; str:</span>
<span class="gi">+        try:</span>
<span class="gi">+            name, argument = re.split(r&#39;\s*:\s+&#39;, sig.strip(), maxsplit=1)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            name, argument = sig, None</span>
<span class="gi">+</span>
<span class="gi">+        desc_name = f&#39;:{name}:&#39;</span>
<span class="gi">+        signode[&#39;fullname&#39;] = name.strip()</span>
<span class="gi">+        signode += addnodes.desc_name(desc_name, desc_name)</span>
<span class="gi">+        if argument:</span>
<span class="gi">+            signode += addnodes.desc_annotation(&#39; &#39; + argument, &#39; &#39; + argument)</span>
<span class="gi">+        if self.options.get(&#39;type&#39;):</span>
<span class="gi">+            text = &#39; (%s)&#39; % self.options[&#39;type&#39;]</span>
<span class="gi">+            signode += addnodes.desc_annotation(text, text)</span>
<span class="gi">+        return name</span>
<span class="gi">+</span>
<span class="gi">+    def add_target_and_index(self, name: str, sig: str, signode: desc_signature) -&gt; None:</span>
<span class="gi">+        domain = cast(ReSTDomain, self.env.get_domain(&#39;rst&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        directive_name = self.current_directive</span>
<span class="gi">+        if directive_name:</span>
<span class="gi">+            prefix = f&#39;{self.objtype}-{directive_name}&#39;</span>
<span class="gi">+            objname = f&#39;{directive_name}:{name}&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            prefix = self.objtype</span>
<span class="gi">+            objname = name</span>
<span class="gi">+</span>
<span class="gi">+        node_id = make_id(self.env, self.state.document, prefix, name)</span>
<span class="gi">+        signode[&#39;ids&#39;].append(node_id)</span>
<span class="gi">+        self.state.document.note_explicit_target(signode)</span>
<span class="gi">+        domain.note_object(self.objtype, objname, node_id, location=signode)</span>
<span class="gi">+</span>
<span class="gi">+        if directive_name:</span>
<span class="gi">+            key = name[0].upper()</span>
<span class="gi">+            pair = [_(&#39;%s (directive)&#39;) % directive_name,</span>
<span class="gi">+                    _(&#39;:%s: (directive option)&#39;) % name]</span>
<span class="gi">+            self.indexnode[&#39;entries&#39;].append((&#39;pair&#39;, &#39;; &#39;.join(pair), node_id, &#39;&#39;, key))</span>
<span class="gi">+        else:</span>
<span class="gi">+            key = name[0].upper()</span>
<span class="gi">+            text = _(&#39;:%s: (directive option)&#39;) % name</span>
<span class="gi">+            self.indexnode[&#39;entries&#39;].append((&#39;single&#39;, text, node_id, &#39;&#39;, key))</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def current_directive(self) -&gt; str:</span>
<span class="gi">+        directives = self.env.ref_context.get(&#39;rst:directives&#39;)</span>
<span class="gi">+        if directives:</span>
<span class="gi">+            return directives[-1]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;&#39;</span>


<span class="w"> </span>class ReSTRole(ReSTMarkup):
<span class="gu">@@ -60,15 +203,102 @@ class ReSTRole(ReSTMarkup):</span>
<span class="w"> </span>    Description of a reST role.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def handle_signature(self, sig: str, signode: desc_signature) -&gt; str:</span>
<span class="gi">+        desc_name = f&#39;:{sig}:&#39;</span>
<span class="gi">+        signode[&#39;fullname&#39;] = sig.strip()</span>
<span class="gi">+        signode += addnodes.desc_name(desc_name, desc_name)</span>
<span class="gi">+        return sig</span>
<span class="gi">+</span>
<span class="gi">+    def get_index_text(self, objectname: str, name: str) -&gt; str:</span>
<span class="gi">+        return _(&#39;%s (role)&#39;) % name</span>
<span class="gi">+</span>

<span class="w"> </span>class ReSTDomain(Domain):
<span class="w"> </span>    &quot;&quot;&quot;ReStructuredText domain.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name = &#39;rst&#39;
<span class="w"> </span>    label = &#39;reStructuredText&#39;
<span class="gd">-    object_types = {&#39;directive&#39;: ObjType(_(&#39;directive&#39;), &#39;dir&#39;),</span>
<span class="gd">-        &#39;directive:option&#39;: ObjType(_(&#39;directive-option&#39;), &#39;dir&#39;), &#39;role&#39;:</span>
<span class="gd">-        ObjType(_(&#39;role&#39;), &#39;role&#39;)}</span>
<span class="gd">-    directives = {&#39;directive&#39;: ReSTDirective, &#39;directive:option&#39;:</span>
<span class="gd">-        ReSTDirectiveOption, &#39;role&#39;: ReSTRole}</span>
<span class="gd">-    roles = {&#39;dir&#39;: XRefRole(), &#39;role&#39;: XRefRole()}</span>
<span class="gd">-    initial_data: dict[str, dict[tuple[str, str], str]] = {&#39;objects&#39;: {}}</span>
<span class="gi">+</span>
<span class="gi">+    object_types = {</span>
<span class="gi">+        &#39;directive&#39;:        ObjType(_(&#39;directive&#39;),        &#39;dir&#39;),</span>
<span class="gi">+        &#39;directive:option&#39;: ObjType(_(&#39;directive-option&#39;), &#39;dir&#39;),</span>
<span class="gi">+        &#39;role&#39;:             ObjType(_(&#39;role&#39;),             &#39;role&#39;),</span>
<span class="gi">+    }</span>
<span class="gi">+    directives = {</span>
<span class="gi">+        &#39;directive&#39;: ReSTDirective,</span>
<span class="gi">+        &#39;directive:option&#39;: ReSTDirectiveOption,</span>
<span class="gi">+        &#39;role&#39;:      ReSTRole,</span>
<span class="gi">+    }</span>
<span class="gi">+    roles = {</span>
<span class="gi">+        &#39;dir&#39;:  XRefRole(),</span>
<span class="gi">+        &#39;role&#39;: XRefRole(),</span>
<span class="gi">+    }</span>
<span class="gi">+    initial_data: dict[str, dict[tuple[str, str], str]] = {</span>
<span class="gi">+        &#39;objects&#39;: {},  # fullname -&gt; docname, objtype</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def objects(self) -&gt; dict[tuple[str, str], tuple[str, str]]:</span>
<span class="gi">+        return self.data.setdefault(&#39;objects&#39;, {})  # (objtype, fullname) -&gt; (docname, node_id)</span>
<span class="gi">+</span>
<span class="gi">+    def note_object(self, objtype: str, name: str, node_id: str, location: Any = None) -&gt; None:</span>
<span class="gi">+        if (objtype, name) in self.objects:</span>
<span class="gi">+            docname, node_id = self.objects[objtype, name]</span>
<span class="gi">+            logger.warning(__(&#39;duplicate description of %s %s, other instance in %s&#39;),</span>
<span class="gi">+                           objtype, name, docname, location=location)</span>
<span class="gi">+</span>
<span class="gi">+        self.objects[objtype, name] = (self.env.docname, node_id)</span>
<span class="gi">+</span>
<span class="gi">+    def clear_doc(self, docname: str) -&gt; None:</span>
<span class="gi">+        for (typ, name), (doc, _node_id) in list(self.objects.items()):</span>
<span class="gi">+            if doc == docname:</span>
<span class="gi">+                del self.objects[typ, name]</span>
<span class="gi">+</span>
<span class="gi">+    def merge_domaindata(self, docnames: list[str], otherdata: dict[str, Any]) -&gt; None:</span>
<span class="gi">+        # XXX check duplicates</span>
<span class="gi">+        for (typ, name), (doc, node_id) in otherdata[&#39;objects&#39;].items():</span>
<span class="gi">+            if doc in docnames:</span>
<span class="gi">+                self.objects[typ, name] = (doc, node_id)</span>
<span class="gi">+</span>
<span class="gi">+    def resolve_xref(self, env: BuildEnvironment, fromdocname: str, builder: Builder,</span>
<span class="gi">+                     typ: str, target: str, node: pending_xref, contnode: Element,</span>
<span class="gi">+                     ) -&gt; Element | None:</span>
<span class="gi">+        objtypes = self.objtypes_for_role(typ)</span>
<span class="gi">+        if not objtypes:</span>
<span class="gi">+            return None</span>
<span class="gi">+        for objtype in objtypes:</span>
<span class="gi">+            result = self.objects.get((objtype, target))</span>
<span class="gi">+            if result:</span>
<span class="gi">+                todocname, node_id = result</span>
<span class="gi">+                return make_refnode(builder, fromdocname, todocname, node_id,</span>
<span class="gi">+                                    contnode, target + &#39; &#39; + objtype)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def resolve_any_xref(self, env: BuildEnvironment, fromdocname: str, builder: Builder,</span>
<span class="gi">+                         target: str, node: pending_xref, contnode: Element,</span>
<span class="gi">+                         ) -&gt; list[tuple[str, Element]]:</span>
<span class="gi">+        results: list[tuple[str, Element]] = []</span>
<span class="gi">+        for objtype in self.object_types:</span>
<span class="gi">+            result = self.objects.get((objtype, target))</span>
<span class="gi">+            if result:</span>
<span class="gi">+                todocname, node_id = result</span>
<span class="gi">+                results.append(</span>
<span class="gi">+                    (&#39;rst:&#39; + self.role_for_objtype(objtype),  # type: ignore[operator]</span>
<span class="gi">+                     make_refnode(builder, fromdocname, todocname, node_id,</span>
<span class="gi">+                                  contnode, target + &#39; &#39; + objtype)))</span>
<span class="gi">+        return results</span>
<span class="gi">+</span>
<span class="gi">+    def get_objects(self) -&gt; Iterator[tuple[str, str, str, str, str, int]]:</span>
<span class="gi">+        for (typ, name), (docname, node_id) in self.data[&#39;objects&#39;].items():</span>
<span class="gi">+            yield name, name, typ, docname, node_id, 1</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_domain(ReSTDomain)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;env_version&#39;: 2,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/environment/adapters/asset.py b/sphinx/environment/adapters/asset.py</span>
<span class="gh">index 524c29ad4..dc0cf7669 100644</span>
<span class="gd">--- a/sphinx/environment/adapters/asset.py</span>
<span class="gi">+++ b/sphinx/environment/adapters/asset.py</span>
<span class="gu">@@ -1,13 +1,16 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Assets adapter for sphinx.environment.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from sphinx.environment import BuildEnvironment
<span class="w"> </span>from sphinx.util._pathlib import _StrPath


<span class="w"> </span>class ImageAdapter:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, env: BuildEnvironment) -&gt;None:</span>
<span class="gi">+    def __init__(self, env: BuildEnvironment) -&gt; None:</span>
<span class="w"> </span>        self.env = env

<span class="gd">-    def get_original_image_uri(self, name: str) -&gt;str:</span>
<span class="gi">+    def get_original_image_uri(self, name: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the original image URI.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while _StrPath(name) in self.env.original_image_uri:</span>
<span class="gi">+            name = self.env.original_image_uri[_StrPath(name)]</span>
<span class="gi">+</span>
<span class="gi">+        return name</span>
<span class="gh">diff --git a/sphinx/environment/adapters/indexentries.py b/sphinx/environment/adapters/indexentries.py</span>
<span class="gh">index bb2768a33..64788f51a 100644</span>
<span class="gd">--- a/sphinx/environment/adapters/indexentries.py</span>
<span class="gi">+++ b/sphinx/environment/adapters/indexentries.py</span>
<span class="gu">@@ -1,58 +1,232 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Index entries adapters for sphinx.environment.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>import unicodedata
<span class="w"> </span>from itertools import groupby
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from sphinx.errors import NoUri
<span class="w"> </span>from sphinx.locale import _, __
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.index_entries import _split_into
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing import Literal, TypeAlias
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.builders import Builder
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="gi">+</span>
<span class="w"> </span>    _IndexEntryTarget: TypeAlias = tuple[str | None, str | Literal[False]]
<span class="w"> </span>    _IndexEntryTargets: TypeAlias = list[_IndexEntryTarget]
<span class="w"> </span>    _IndexEntryCategoryKey: TypeAlias = str | None
<span class="gd">-    _IndexEntrySubItems: TypeAlias = dict[str, tuple[_IndexEntryTargets,</span>
<span class="gd">-        _IndexEntryCategoryKey]]</span>
<span class="gd">-    _IndexEntry: TypeAlias = tuple[_IndexEntryTargets, _IndexEntrySubItems,</span>
<span class="gd">-        _IndexEntryCategoryKey]</span>
<span class="gi">+    _IndexEntrySubItems: TypeAlias = dict[</span>
<span class="gi">+        str,</span>
<span class="gi">+        tuple[_IndexEntryTargets, _IndexEntryCategoryKey],</span>
<span class="gi">+    ]</span>
<span class="gi">+    _IndexEntry: TypeAlias = tuple[</span>
<span class="gi">+        _IndexEntryTargets,</span>
<span class="gi">+        _IndexEntrySubItems,</span>
<span class="gi">+        _IndexEntryCategoryKey,</span>
<span class="gi">+    ]</span>
<span class="w"> </span>    _IndexEntryMap: TypeAlias = dict[str, _IndexEntry]
<span class="gd">-    _Index: TypeAlias = list[tuple[str, list[tuple[str, tuple[</span>
<span class="gd">-        _IndexEntryTargets, list[tuple[str, _IndexEntryTargets]],</span>
<span class="gd">-        _IndexEntryCategoryKey]]]]]</span>
<span class="gi">+    _Index: TypeAlias = list[</span>
<span class="gi">+        tuple[</span>
<span class="gi">+            str,</span>
<span class="gi">+            list[</span>
<span class="gi">+                tuple[</span>
<span class="gi">+                    str,</span>
<span class="gi">+                    tuple[</span>
<span class="gi">+                        _IndexEntryTargets,</span>
<span class="gi">+                        list[tuple[str, _IndexEntryTargets]],</span>
<span class="gi">+                        _IndexEntryCategoryKey</span>
<span class="gi">+                    ]</span>
<span class="gi">+                ]</span>
<span class="gi">+            ]</span>
<span class="gi">+        ]</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="w"> </span>class IndexEntries:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, env: BuildEnvironment) -&gt;None:</span>
<span class="gi">+    def __init__(self, env: BuildEnvironment) -&gt; None:</span>
<span class="w"> </span>        self.env = env
<span class="w"> </span>        self.builder: Builder

<span class="gd">-    def create_index(self, builder: Builder, group_entries: bool=True,</span>
<span class="gd">-        _fixre: re.Pattern[str]=re.compile(&#39;(.*) ([(][^()]*[)])&#39;)) -&gt;_Index:</span>
<span class="gi">+    def create_index(</span>
<span class="gi">+        self,</span>
<span class="gi">+        builder: Builder,</span>
<span class="gi">+        group_entries: bool = True,</span>
<span class="gi">+        _fixre: re.Pattern[str] = re.compile(r&#39;(.*) ([(][^()]*[)])&#39;),</span>
<span class="gi">+    ) -&gt; _Index:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create the real index from the collected index entries.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        new: _IndexEntryMap = {}</span>
<span class="gi">+</span>
<span class="gi">+        rel_uri: str | Literal[False]</span>
<span class="gi">+        index_domain = self.env.domains[&#39;index&#39;]</span>
<span class="gi">+        for docname, entries in index_domain.entries.items():</span>
<span class="gi">+            try:</span>
<span class="gi">+                rel_uri = builder.get_relative_uri(&#39;genindex&#39;, docname)</span>
<span class="gi">+            except NoUri:</span>
<span class="gi">+                rel_uri = False</span>
<span class="gi">+</span>
<span class="gi">+            # new entry types must be listed in directives/other.py!</span>
<span class="gi">+            for entry_type, value, target_id, main, category_key in entries:</span>
<span class="gi">+                uri = rel_uri is not False and f&#39;{rel_uri}#{target_id}&#39;</span>
<span class="gi">+                try:</span>
<span class="gi">+                    if entry_type == &#39;single&#39;:</span>
<span class="gi">+                        try:</span>
<span class="gi">+                            entry, sub_entry = _split_into(2, &#39;single&#39;, value)</span>
<span class="gi">+                        except ValueError:</span>
<span class="gi">+                            entry, = _split_into(1, &#39;single&#39;, value)</span>
<span class="gi">+                            sub_entry = &#39;&#39;</span>
<span class="gi">+                        _add_entry(entry, sub_entry, main,</span>
<span class="gi">+                                   dic=new, link=uri, key=category_key)</span>
<span class="gi">+                    elif entry_type == &#39;pair&#39;:</span>
<span class="gi">+                        first, second = _split_into(2, &#39;pair&#39;, value)</span>
<span class="gi">+                        _add_entry(first, second, main,</span>
<span class="gi">+                                   dic=new, link=uri, key=category_key)</span>
<span class="gi">+                        _add_entry(second, first, main,</span>
<span class="gi">+                                   dic=new, link=uri, key=category_key)</span>
<span class="gi">+                    elif entry_type == &#39;triple&#39;:</span>
<span class="gi">+                        first, second, third = _split_into(3, &#39;triple&#39;, value)</span>
<span class="gi">+                        _add_entry(first, second + &#39; &#39; + third, main,</span>
<span class="gi">+                                   dic=new, link=uri, key=category_key)</span>
<span class="gi">+                        _add_entry(second, third + &#39;, &#39; + first, main,</span>
<span class="gi">+                                   dic=new, link=uri, key=category_key)</span>
<span class="gi">+                        _add_entry(third, first + &#39; &#39; + second, main,</span>
<span class="gi">+                                   dic=new, link=uri, key=category_key)</span>
<span class="gi">+                    elif entry_type == &#39;see&#39;:</span>
<span class="gi">+                        first, second = _split_into(2, &#39;see&#39;, value)</span>
<span class="gi">+                        _add_entry(first, _(&#39;see %s&#39;) % second, None,</span>
<span class="gi">+                                   dic=new, link=False, key=category_key)</span>
<span class="gi">+                    elif entry_type == &#39;seealso&#39;:</span>
<span class="gi">+                        first, second = _split_into(2, &#39;see&#39;, value)</span>
<span class="gi">+                        _add_entry(first, _(&#39;see also %s&#39;) % second, None,</span>
<span class="gi">+                                   dic=new, link=False, key=category_key)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        logger.warning(__(&#39;unknown index entry type %r&#39;), entry_type,</span>
<span class="gi">+                                       location=docname)</span>
<span class="gi">+                except ValueError as err:</span>
<span class="gi">+                    logger.warning(str(err), location=docname)</span>

<span class="gi">+        for (targets, sub_items, _category_key) in new.values():</span>
<span class="gi">+            targets.sort(key=_key_func_0)</span>
<span class="gi">+            for (sub_targets, _sub_category_key) in sub_items.values():</span>
<span class="gi">+                sub_targets.sort(key=_key_func_0)</span>

<span class="gd">-def _key_func_0(entry: _IndexEntryTarget) -&gt;tuple[bool, str | Literal[False]]:</span>
<span class="gi">+        new_list: list[tuple[str, _IndexEntry]] = sorted(new.items(), key=_key_func_1)</span>
<span class="gi">+</span>
<span class="gi">+        if group_entries:</span>
<span class="gi">+            # fixup entries: transform</span>
<span class="gi">+            #   func() (in module foo)</span>
<span class="gi">+            #   func() (in module bar)</span>
<span class="gi">+            # into</span>
<span class="gi">+            #   func()</span>
<span class="gi">+            #     (in module foo)</span>
<span class="gi">+            #     (in module bar)</span>
<span class="gi">+            old_key = &#39;&#39;</span>
<span class="gi">+            old_sub_items: _IndexEntrySubItems = {}</span>
<span class="gi">+            i = 0</span>
<span class="gi">+            while i &lt; len(new_list):</span>
<span class="gi">+                key, (targets, sub_items, category_key) = new_list[i]</span>
<span class="gi">+                # cannot move if it has sub_items; structure gets too complex</span>
<span class="gi">+                if not sub_items:</span>
<span class="gi">+                    m = _fixre.match(key)</span>
<span class="gi">+                    if m:</span>
<span class="gi">+                        if old_key == m.group(1):</span>
<span class="gi">+                            # prefixes match: add entry as subitem of the</span>
<span class="gi">+                            # previous entry</span>
<span class="gi">+                            old_sub_items.setdefault(</span>
<span class="gi">+                                m.group(2), ([], category_key))[0].extend(targets)</span>
<span class="gi">+                            del new_list[i]</span>
<span class="gi">+                            continue</span>
<span class="gi">+                        old_key = m.group(1)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        old_key = key</span>
<span class="gi">+                old_sub_items = sub_items</span>
<span class="gi">+                i += 1</span>
<span class="gi">+</span>
<span class="gi">+        grouped = []</span>
<span class="gi">+        for (group_key, group) in groupby(new_list, _group_by_func):</span>
<span class="gi">+            group_list = []</span>
<span class="gi">+            for group_entry in group:</span>
<span class="gi">+                entry_key, (targets, sub_items, category_key) = group_entry</span>
<span class="gi">+                pairs = [</span>
<span class="gi">+                    (sub_key, sub_targets)</span>
<span class="gi">+                    for (sub_key, (sub_targets, _sub_category_key))</span>
<span class="gi">+                    in sub_items.items()</span>
<span class="gi">+                ]</span>
<span class="gi">+                pairs.sort(key=_key_func_2)</span>
<span class="gi">+                group_list.append((entry_key, (targets, pairs, category_key)))</span>
<span class="gi">+            grouped.append((group_key, group_list))</span>
<span class="gi">+        return grouped</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _add_entry(word: str, subword: str, main: str | None, *,</span>
<span class="gi">+               dic: _IndexEntryMap,</span>
<span class="gi">+               link: str | Literal[False], key: _IndexEntryCategoryKey) -&gt; None:</span>
<span class="gi">+    entry = dic.setdefault(word, ([], {}, key))</span>
<span class="gi">+    if subword:</span>
<span class="gi">+        targets = entry[1].setdefault(subword, ([], key))[0]</span>
<span class="gi">+    else:</span>
<span class="gi">+        targets = entry[0]</span>
<span class="gi">+    if link:</span>
<span class="gi">+        targets.append((main, link))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _key_func_0(entry: _IndexEntryTarget) -&gt; tuple[bool, str | Literal[False]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Sort the index entries for same keyword.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    main, uri = entry</span>
<span class="gi">+    return not main, uri  # show main entries at first</span>


<span class="gd">-def _key_func_1(entry: tuple[str, _IndexEntry]) -&gt;tuple[tuple[int, str], str]:</span>
<span class="gi">+def _key_func_1(entry: tuple[str, _IndexEntry]) -&gt; tuple[tuple[int, str], str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Sort the index entries&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    key, (_targets, _sub_items, category_key) = entry</span>
<span class="gi">+    if category_key:</span>
<span class="gi">+        # using the specified category key to sort</span>
<span class="gi">+        key = category_key</span>
<span class="gi">+    lc_key = unicodedata.normalize(&#39;NFD&#39;, key.lower())</span>
<span class="gi">+    if lc_key.startswith(&#39;\N{RIGHT-TO-LEFT MARK}&#39;):</span>
<span class="gi">+        lc_key = lc_key[1:]</span>
<span class="gi">+</span>
<span class="gi">+    if not lc_key[0:1].isalpha() and not lc_key.startswith(&#39;_&#39;):</span>
<span class="gi">+        # put symbols at the front of the index (0)</span>
<span class="gi">+        group = 0</span>
<span class="gi">+    else:</span>
<span class="gi">+        # put non-symbol characters at the following group (1)</span>
<span class="gi">+        group = 1</span>
<span class="gi">+    # ensure a deterministic order *within* letters by also sorting on</span>
<span class="gi">+    # the entry itself</span>
<span class="gi">+    return (group, lc_key), entry[0]</span>


<span class="gd">-def _key_func_2(entry: tuple[str, _IndexEntryTargets]) -&gt;str:</span>
<span class="gi">+def _key_func_2(entry: tuple[str, _IndexEntryTargets]) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Sort the sub-index entries&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    key = unicodedata.normalize(&#39;NFD&#39;, entry[0].lower())</span>
<span class="gi">+    if key.startswith(&#39;\N{RIGHT-TO-LEFT MARK}&#39;):</span>
<span class="gi">+        key = key[1:]</span>
<span class="gi">+    if key[0:1].isalpha() or key.startswith(&#39;_&#39;):</span>
<span class="gi">+        key = chr(127) + key</span>
<span class="gi">+    return key</span>


<span class="gd">-def _group_by_func(entry: tuple[str, _IndexEntry]) -&gt;str:</span>
<span class="gi">+def _group_by_func(entry: tuple[str, _IndexEntry]) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Group the entries by letter or category key.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    key, (targets, sub_items, category_key) = entry</span>
<span class="gi">+</span>
<span class="gi">+    if category_key is not None:</span>
<span class="gi">+        return category_key</span>
<span class="gi">+</span>
<span class="gi">+    # now calculate the key</span>
<span class="gi">+    if key.startswith(&#39;\N{RIGHT-TO-LEFT MARK}&#39;):</span>
<span class="gi">+        key = key[1:]</span>
<span class="gi">+    letter = unicodedata.normalize(&#39;NFD&#39;, key[0])[0].upper()</span>
<span class="gi">+    if letter.isalpha() or letter == &#39;_&#39;:</span>
<span class="gi">+        return letter</span>
<span class="gi">+</span>
<span class="gi">+    # get all other symbols under one heading</span>
<span class="gi">+    return _(&#39;Symbols&#39;)</span>
<span class="gh">diff --git a/sphinx/environment/adapters/toctree.py b/sphinx/environment/adapters/toctree.py</span>
<span class="gh">index e3afbc450..217cb0d41 100644</span>
<span class="gd">--- a/sphinx/environment/adapters/toctree.py</span>
<span class="gi">+++ b/sphinx/environment/adapters/toctree.py</span>
<span class="gu">@@ -1,53 +1,109 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Toctree adapter for sphinx.environment.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any, TypeVar
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.nodes import Element, Node
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.util import logging, url_re
<span class="w"> </span>from sphinx.util.matching import Matcher
<span class="w"> </span>from sphinx.util.nodes import _only_node_keep_children, clean_astext
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Iterable, Set
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.builders import Builder
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="w"> </span>    from sphinx.util.tags import Tags
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="gd">-def note_toctree(env: BuildEnvironment, docname: str, toctreenode: addnodes</span>
<span class="gd">-    .toctree) -&gt;None:</span>
<span class="gi">+def note_toctree(env: BuildEnvironment, docname: str, toctreenode: addnodes.toctree) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Note a TOC tree directive in a document and gather information about
<span class="w"> </span>    file relations from it.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if toctreenode[&#39;glob&#39;]:</span>
<span class="gi">+        env.glob_toctrees.add(docname)</span>
<span class="gi">+    if toctreenode.get(&#39;numbered&#39;):</span>
<span class="gi">+        env.numbered_toctrees.add(docname)</span>
<span class="gi">+    include_files = toctreenode[&#39;includefiles&#39;]</span>
<span class="gi">+    for include_file in include_files:</span>
<span class="gi">+        # note that if the included file is rebuilt, this one must be</span>
<span class="gi">+        # too (since the TOC of the included file could have changed)</span>
<span class="gi">+        env.files_to_rebuild.setdefault(include_file, set()).add(docname)</span>
<span class="gi">+    env.toctree_includes.setdefault(docname, []).extend(include_files)</span>


<span class="gd">-def document_toc(env: BuildEnvironment, docname: str, tags: Tags) -&gt;Node:</span>
<span class="gi">+def document_toc(env: BuildEnvironment, docname: str, tags: Tags) -&gt; Node:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the (local) table of contents for a document.

<span class="w"> </span>    Note that this is only the sections within the document.
<span class="w"> </span>    For a ToC tree that shows the document&#39;s place in the
<span class="w"> </span>    ToC structure, use `get_toctree_for`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    tocdepth = env.metadata[docname].get(&#39;tocdepth&#39;, 0)</span>
<span class="gi">+    try:</span>
<span class="gi">+        toc = _toctree_copy(env.tocs[docname], 2, tocdepth, False, tags)</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        # the document does not exist any more:</span>
<span class="gi">+        # return a dummy node that renders to nothing</span>
<span class="gi">+        return nodes.paragraph()</span>
<span class="gi">+</span>
<span class="gi">+    for node in toc.findall(nodes.reference):</span>
<span class="gi">+        node[&#39;refuri&#39;] = node[&#39;anchorname&#39;] or &#39;#&#39;</span>
<span class="gi">+    return toc</span>


<span class="gd">-def global_toctree_for_doc(env: BuildEnvironment, docname: str, builder:</span>
<span class="gd">-    Builder, collapse: bool=False, includehidden: bool=True, maxdepth: int=</span>
<span class="gd">-    0, titles_only: bool=False) -&gt;(Element | None):</span>
<span class="gi">+def global_toctree_for_doc(</span>
<span class="gi">+    env: BuildEnvironment,</span>
<span class="gi">+    docname: str,</span>
<span class="gi">+    builder: Builder,</span>
<span class="gi">+    collapse: bool = False,</span>
<span class="gi">+    includehidden: bool = True,</span>
<span class="gi">+    maxdepth: int = 0,</span>
<span class="gi">+    titles_only: bool = False,</span>
<span class="gi">+) -&gt; Element | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the global ToC tree at a given document.

<span class="w"> </span>    This gives the global ToC, with all ancestors and their siblings.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    resolved = (</span>
<span class="gi">+        _resolve_toctree(</span>
<span class="gi">+            env,</span>
<span class="gi">+            docname,</span>
<span class="gi">+            builder,</span>
<span class="gi">+            toctree_node,</span>
<span class="gi">+            prune=True,</span>
<span class="gi">+            maxdepth=int(maxdepth),</span>
<span class="gi">+            titles_only=titles_only,</span>
<span class="gi">+            collapse=collapse,</span>
<span class="gi">+            includehidden=includehidden,</span>
<span class="gi">+        )</span>
<span class="gi">+        for toctree_node in env.master_doctree.findall(addnodes.toctree)</span>
<span class="gi">+    )</span>
<span class="gi">+    toctrees = [</span>
<span class="gi">+        toctree for toctree in resolved if toctree is not None</span>
<span class="gi">+    ]</span>

<span class="gi">+    if not toctrees:</span>
<span class="gi">+        return None</span>
<span class="gi">+    result = toctrees[0]</span>
<span class="gi">+    for toctree in toctrees[1:]:</span>
<span class="gi">+        result.extend(toctree.children)</span>
<span class="gi">+    return result</span>

<span class="gd">-def _resolve_toctree(env: BuildEnvironment, docname: str, builder: Builder,</span>
<span class="gd">-    toctree: addnodes.toctree, *, prune: bool=True, maxdepth: int=0,</span>
<span class="gd">-    titles_only: bool=False, collapse: bool=False, includehidden: bool=False</span>
<span class="gd">-    ) -&gt;(Element | None):</span>
<span class="gi">+</span>
<span class="gi">+def _resolve_toctree(</span>
<span class="gi">+    env: BuildEnvironment, docname: str, builder: Builder, toctree: addnodes.toctree, *,</span>
<span class="gi">+    prune: bool = True, maxdepth: int = 0, titles_only: bool = False,</span>
<span class="gi">+    collapse: bool = False, includehidden: bool = False,</span>
<span class="gi">+) -&gt; Element | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Resolve a *toctree* node into individual bullet lists with titles
<span class="w"> </span>    as items, returning None (if no containing titles are found) or
<span class="w"> </span>    a new node.
<span class="gu">@@ -59,33 +115,407 @@ def _resolve_toctree(env: BuildEnvironment, docname: str, builder: Builder,</span>
<span class="w"> </span>    If *collapse* is True, all branches not containing docname will
<span class="w"> </span>    be collapsed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if toctree.get(&#39;hidden&#39;, False) and not includehidden:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    # For reading the following two helper function, it is useful to keep</span>
<span class="gi">+    # in mind the node structure of a toctree (using HTML-like node names</span>
<span class="gi">+    # for brevity):</span>
<span class="gi">+    #</span>
<span class="gi">+    # &lt;ul&gt;</span>
<span class="gi">+    #   &lt;li&gt;</span>
<span class="gi">+    #     &lt;p&gt;&lt;a&gt;&lt;/p&gt;</span>
<span class="gi">+    #     &lt;p&gt;&lt;a&gt;&lt;/p&gt;</span>
<span class="gi">+    #     ...</span>
<span class="gi">+    #     &lt;ul&gt;</span>
<span class="gi">+    #       ...</span>
<span class="gi">+    #     &lt;/ul&gt;</span>
<span class="gi">+    #   &lt;/li&gt;</span>
<span class="gi">+    # &lt;/ul&gt;</span>
<span class="gi">+    #</span>
<span class="gi">+    # The transformation is made in two passes in order to avoid</span>
<span class="gi">+    # interactions between marking and pruning the tree (see bug #1046).</span>
<span class="gi">+</span>
<span class="gi">+    toctree_ancestors = _get_toctree_ancestors(env.toctree_includes, docname)</span>
<span class="gi">+    included = Matcher(env.config.include_patterns)</span>
<span class="gi">+    excluded = Matcher(env.config.exclude_patterns)</span>

<span class="gi">+    maxdepth = maxdepth or toctree.get(&#39;maxdepth&#39;, -1)</span>
<span class="gi">+    if not titles_only and toctree.get(&#39;titlesonly&#39;, False):</span>
<span class="gi">+        titles_only = True</span>
<span class="gi">+    if not includehidden and toctree.get(&#39;includehidden&#39;, False):</span>
<span class="gi">+        includehidden = True</span>

<span class="gd">-def _entries_from_toctree(env: BuildEnvironment, prune: bool, titles_only:</span>
<span class="gd">-    bool, collapse: bool, includehidden: bool, tags: Tags,</span>
<span class="gd">-    toctree_ancestors: Set[str], included: Matcher, excluded: Matcher,</span>
<span class="gd">-    toctreenode: addnodes.toctree, parents: list[str], subtree: bool=False</span>
<span class="gd">-    ) -&gt;list[Element]:</span>
<span class="gi">+    tocentries = _entries_from_toctree(</span>
<span class="gi">+        env,</span>
<span class="gi">+        prune,</span>
<span class="gi">+        titles_only,</span>
<span class="gi">+        collapse,</span>
<span class="gi">+        includehidden,</span>
<span class="gi">+        builder.tags,</span>
<span class="gi">+        toctree_ancestors,</span>
<span class="gi">+        included,</span>
<span class="gi">+        excluded,</span>
<span class="gi">+        toctree,</span>
<span class="gi">+        [],</span>
<span class="gi">+    )</span>
<span class="gi">+    if not tocentries:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    newnode = addnodes.compact_paragraph(&#39;&#39;, &#39;&#39;)</span>
<span class="gi">+    if caption := toctree.attributes.get(&#39;caption&#39;):</span>
<span class="gi">+        caption_node = nodes.title(caption, &#39;&#39;, *[nodes.Text(caption)])</span>
<span class="gi">+        caption_node.line = toctree.line</span>
<span class="gi">+        caption_node.source = toctree.source</span>
<span class="gi">+        caption_node.rawsource = toctree[&#39;rawcaption&#39;]</span>
<span class="gi">+        if hasattr(toctree, &#39;uid&#39;):</span>
<span class="gi">+            # move uid to caption_node to translate it</span>
<span class="gi">+            caption_node.uid = toctree.uid  # type: ignore[attr-defined]</span>
<span class="gi">+            del toctree.uid</span>
<span class="gi">+        newnode.append(caption_node)</span>
<span class="gi">+    newnode.extend(tocentries)</span>
<span class="gi">+    newnode[&#39;toctree&#39;] = True</span>
<span class="gi">+</span>
<span class="gi">+    # prune the tree to maxdepth, also set toc depth and current classes</span>
<span class="gi">+    _toctree_add_classes(newnode, 1, docname)</span>
<span class="gi">+    newnode = _toctree_copy(newnode, 1, maxdepth if prune else 0, collapse, builder.tags)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(newnode[-1], nodes.Element) and len(newnode[-1]) == 0:  # No titles found</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    # set the target paths in the toctrees (they are not known at TOC</span>
<span class="gi">+    # generation time)</span>
<span class="gi">+    for refnode in newnode.findall(nodes.reference):</span>
<span class="gi">+        if url_re.match(refnode[&#39;refuri&#39;]) is None:</span>
<span class="gi">+            rel_uri = builder.get_relative_uri(docname, refnode[&#39;refuri&#39;])</span>
<span class="gi">+            refnode[&#39;refuri&#39;] = rel_uri + refnode[&#39;anchorname&#39;]</span>
<span class="gi">+    return newnode</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _entries_from_toctree(</span>
<span class="gi">+    env: BuildEnvironment,</span>
<span class="gi">+    prune: bool,</span>
<span class="gi">+    titles_only: bool,</span>
<span class="gi">+    collapse: bool,</span>
<span class="gi">+    includehidden: bool,</span>
<span class="gi">+    tags: Tags,</span>
<span class="gi">+    toctree_ancestors: Set[str],</span>
<span class="gi">+    included: Matcher,</span>
<span class="gi">+    excluded: Matcher,</span>
<span class="gi">+    toctreenode: addnodes.toctree,</span>
<span class="gi">+    parents: list[str],</span>
<span class="gi">+    subtree: bool = False,</span>
<span class="gi">+) -&gt; list[Element]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return TOC entries for a toctree node.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    entries: list[Element] = []</span>
<span class="gi">+    for (title, ref) in toctreenode[&#39;entries&#39;]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            toc, refdoc = _toctree_entry(</span>
<span class="gi">+                title, ref, env, prune, collapse, tags, toctree_ancestors,</span>
<span class="gi">+                included, excluded, toctreenode, parents,</span>
<span class="gi">+            )</span>
<span class="gi">+        except LookupError:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        # children of toc are:</span>
<span class="gi">+        # - list_item + compact_paragraph + (reference and subtoc)</span>
<span class="gi">+        # - only + subtoc</span>
<span class="gi">+        # - toctree</span>
<span class="gi">+        children: Iterable[nodes.Element] = toc.children  # type: ignore[assignment]</span>
<span class="gi">+</span>
<span class="gi">+        # if titles_only is given, only keep the main title and</span>
<span class="gi">+        # sub-toctrees</span>
<span class="gi">+        if titles_only:</span>
<span class="gi">+            # delete everything but the toplevel title(s)</span>
<span class="gi">+            # and toctrees</span>
<span class="gi">+            for top_level in children:</span>
<span class="gi">+                # nodes with length 1 don&#39;t have any children anyway</span>
<span class="gi">+                if len(top_level) &gt; 1:</span>
<span class="gi">+                    if subtrees := list(top_level.findall(addnodes.toctree)):</span>
<span class="gi">+                        top_level[1][:] = subtrees  # type: ignore[index]</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        top_level.pop(1)</span>
<span class="gi">+        # resolve all sub-toctrees</span>
<span class="gi">+        for sub_toc_node in list(toc.findall(addnodes.toctree)):</span>
<span class="gi">+            if sub_toc_node.get(&#39;hidden&#39;, False) and not includehidden:</span>
<span class="gi">+                continue</span>
<span class="gi">+            for i, entry in enumerate(</span>
<span class="gi">+                _entries_from_toctree(</span>
<span class="gi">+                    env,</span>
<span class="gi">+                    prune,</span>
<span class="gi">+                    titles_only,</span>
<span class="gi">+                    collapse,</span>
<span class="gi">+                    includehidden,</span>
<span class="gi">+                    tags,</span>
<span class="gi">+                    toctree_ancestors,</span>
<span class="gi">+                    included,</span>
<span class="gi">+                    excluded,</span>
<span class="gi">+                    sub_toc_node,</span>
<span class="gi">+                    [refdoc, *parents],</span>
<span class="gi">+                    subtree=True,</span>
<span class="gi">+                ),</span>
<span class="gi">+                start=sub_toc_node.parent.index(sub_toc_node) + 1,</span>
<span class="gi">+            ):</span>
<span class="gi">+                sub_toc_node.parent.insert(i, entry)</span>
<span class="gi">+            sub_toc_node.parent.remove(sub_toc_node)</span>
<span class="gi">+</span>
<span class="gi">+        entries.extend(children)</span>
<span class="gi">+</span>
<span class="gi">+    if not subtree:</span>
<span class="gi">+        ret = nodes.bullet_list()</span>
<span class="gi">+        ret += entries</span>
<span class="gi">+        return [ret]</span>
<span class="gi">+</span>
<span class="gi">+    return entries</span>
<span class="gi">+</span>

<span class="gi">+def _toctree_entry(</span>
<span class="gi">+    title: str,</span>
<span class="gi">+    ref: str,</span>
<span class="gi">+    env: BuildEnvironment,</span>
<span class="gi">+    prune: bool,</span>
<span class="gi">+    collapse: bool,</span>
<span class="gi">+    tags: Tags,</span>
<span class="gi">+    toctree_ancestors: Set[str],</span>
<span class="gi">+    included: Matcher,</span>
<span class="gi">+    excluded: Matcher,</span>
<span class="gi">+    toctreenode: addnodes.toctree,</span>
<span class="gi">+    parents: list[str],</span>
<span class="gi">+) -&gt; tuple[Element, str]:</span>
<span class="gi">+    from sphinx.domains.std import StandardDomain</span>

<span class="gd">-def _toctree_add_classes(node: Element, depth: int, docname: str) -&gt;None:</span>
<span class="gi">+    try:</span>
<span class="gi">+        refdoc = &#39;&#39;</span>
<span class="gi">+        if url_re.match(ref):</span>
<span class="gi">+            toc = _toctree_url_entry(title, ref)</span>
<span class="gi">+        elif ref == &#39;self&#39;:</span>
<span class="gi">+            toc = _toctree_self_entry(title, toctreenode[&#39;parent&#39;], env.titles)</span>
<span class="gi">+        elif ref in StandardDomain._virtual_doc_names:</span>
<span class="gi">+            toc = _toctree_generated_entry(title, ref)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if ref in parents:</span>
<span class="gi">+                logger.warning(__(&#39;circular toctree references &#39;</span>
<span class="gi">+                                  &#39;detected, ignoring: %s &lt;- %s&#39;),</span>
<span class="gi">+                               ref, &#39; &lt;- &#39;.join(parents),</span>
<span class="gi">+                               location=ref, type=&#39;toc&#39;, subtype=&#39;circular&#39;)</span>
<span class="gi">+                msg = &#39;circular reference&#39;</span>
<span class="gi">+                raise LookupError(msg)</span>
<span class="gi">+</span>
<span class="gi">+            toc, refdoc = _toctree_standard_entry(</span>
<span class="gi">+                title,</span>
<span class="gi">+                ref,</span>
<span class="gi">+                env.metadata[ref].get(&#39;tocdepth&#39;, 0),</span>
<span class="gi">+                env.tocs[ref],</span>
<span class="gi">+                toctree_ancestors,</span>
<span class="gi">+                prune,</span>
<span class="gi">+                collapse,</span>
<span class="gi">+                tags,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if not toc.children:</span>
<span class="gi">+            # empty toc means: no titles will show up in the toctree</span>
<span class="gi">+            logger.warning(__(&#39;toctree contains reference to document %r that &#39;</span>
<span class="gi">+                              &quot;doesn&#39;t have a title: no link will be generated&quot;),</span>
<span class="gi">+                           ref, location=toctreenode, type=&#39;toc&#39;, subtype=&#39;no_title&#39;)</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        # this is raised if the included file does not exist</span>
<span class="gi">+        ref_path = str(env.doc2path(ref, False))</span>
<span class="gi">+        if excluded(ref_path):</span>
<span class="gi">+            message = __(&#39;toctree contains reference to excluded document %r&#39;)</span>
<span class="gi">+        elif not included(ref_path):</span>
<span class="gi">+            message = __(&#39;toctree contains reference to non-included document %r&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            message = __(&#39;toctree contains reference to nonexisting document %r&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        logger.warning(message, ref, location=toctreenode)</span>
<span class="gi">+        raise</span>
<span class="gi">+    return toc, refdoc</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _toctree_url_entry(title: str, ref: str) -&gt; nodes.bullet_list:</span>
<span class="gi">+    if title is None:</span>
<span class="gi">+        title = ref</span>
<span class="gi">+    reference = nodes.reference(&#39;&#39;, &#39;&#39;, internal=False,</span>
<span class="gi">+                                refuri=ref, anchorname=&#39;&#39;,</span>
<span class="gi">+                                *[nodes.Text(title)])</span>
<span class="gi">+    para = addnodes.compact_paragraph(&#39;&#39;, &#39;&#39;, reference)</span>
<span class="gi">+    item = nodes.list_item(&#39;&#39;, para)</span>
<span class="gi">+    toc = nodes.bullet_list(&#39;&#39;, item)</span>
<span class="gi">+    return toc</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _toctree_self_entry(</span>
<span class="gi">+    title: str, ref: str, titles: dict[str, nodes.title],</span>
<span class="gi">+) -&gt; nodes.bullet_list:</span>
<span class="gi">+    # &#39;self&#39; refers to the document from which this</span>
<span class="gi">+    # toctree originates</span>
<span class="gi">+    if not title:</span>
<span class="gi">+        title = clean_astext(titles[ref])</span>
<span class="gi">+    reference = nodes.reference(&#39;&#39;, &#39;&#39;, internal=True,</span>
<span class="gi">+                                refuri=ref,</span>
<span class="gi">+                                anchorname=&#39;&#39;,</span>
<span class="gi">+                                *[nodes.Text(title)])</span>
<span class="gi">+    para = addnodes.compact_paragraph(&#39;&#39;, &#39;&#39;, reference)</span>
<span class="gi">+    item = nodes.list_item(&#39;&#39;, para)</span>
<span class="gi">+    # don&#39;t show subitems</span>
<span class="gi">+    toc = nodes.bullet_list(&#39;&#39;, item)</span>
<span class="gi">+    return toc</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _toctree_generated_entry(title: str, ref: str) -&gt; nodes.bullet_list:</span>
<span class="gi">+    from sphinx.domains.std import StandardDomain</span>
<span class="gi">+</span>
<span class="gi">+    docname, sectionname = StandardDomain._virtual_doc_names[ref]</span>
<span class="gi">+    if not title:</span>
<span class="gi">+        title = sectionname</span>
<span class="gi">+    reference = nodes.reference(&#39;&#39;, title, internal=True,</span>
<span class="gi">+                                refuri=docname, anchorname=&#39;&#39;)</span>
<span class="gi">+    para = addnodes.compact_paragraph(&#39;&#39;, &#39;&#39;, reference)</span>
<span class="gi">+    item = nodes.list_item(&#39;&#39;, para)</span>
<span class="gi">+    # don&#39;t show subitems</span>
<span class="gi">+    toc = nodes.bullet_list(&#39;&#39;, item)</span>
<span class="gi">+    return toc</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _toctree_standard_entry(</span>
<span class="gi">+    title: str,</span>
<span class="gi">+    ref: str,</span>
<span class="gi">+    maxdepth: int,</span>
<span class="gi">+    toc: nodes.bullet_list,</span>
<span class="gi">+    toctree_ancestors: Set[str],</span>
<span class="gi">+    prune: bool,</span>
<span class="gi">+    collapse: bool,</span>
<span class="gi">+    tags: Tags,</span>
<span class="gi">+) -&gt; tuple[nodes.bullet_list, str]:</span>
<span class="gi">+    refdoc = ref</span>
<span class="gi">+    if ref in toctree_ancestors and (not prune or maxdepth &lt;= 0):</span>
<span class="gi">+        toc = toc.deepcopy()</span>
<span class="gi">+    else:</span>
<span class="gi">+        toc = _toctree_copy(toc, 2, maxdepth, collapse, tags)</span>
<span class="gi">+</span>
<span class="gi">+    if title and toc.children and len(toc.children) == 1:</span>
<span class="gi">+        child = toc.children[0]</span>
<span class="gi">+        for refnode in child.findall(nodes.reference):</span>
<span class="gi">+            if refnode[&#39;refuri&#39;] == ref and not refnode[&#39;anchorname&#39;]:</span>
<span class="gi">+                refnode.children[:] = [nodes.Text(title)]</span>
<span class="gi">+    return toc, refdoc</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _toctree_add_classes(node: Element, depth: int, docname: str) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Add &#39;toctree-l%d&#39; and &#39;current&#39; classes to the toctree.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for subnode in node.children:</span>
<span class="gi">+        if isinstance(subnode, addnodes.compact_paragraph | nodes.list_item):</span>
<span class="gi">+            # for &lt;p&gt; and &lt;li&gt;, indicate the depth level and recurse</span>
<span class="gi">+            subnode[&#39;classes&#39;].append(f&#39;toctree-l{depth - 1}&#39;)</span>
<span class="gi">+            _toctree_add_classes(subnode, depth, docname)</span>
<span class="gi">+        elif isinstance(subnode, nodes.bullet_list):</span>
<span class="gi">+            # for &lt;ul&gt;, just recurse</span>
<span class="gi">+            _toctree_add_classes(subnode, depth + 1, docname)</span>
<span class="gi">+        elif isinstance(subnode, nodes.reference):</span>
<span class="gi">+            # for &lt;a&gt;, identify which entries point to the current</span>
<span class="gi">+            # document and therefore may not be collapsed</span>
<span class="gi">+            if subnode[&#39;refuri&#39;] == docname:</span>
<span class="gi">+                if not subnode[&#39;anchorname&#39;]:</span>
<span class="gi">+                    # give the whole branch a &#39;current&#39; class</span>
<span class="gi">+                    # (useful for styling it differently)</span>
<span class="gi">+                    branchnode: Element = subnode</span>
<span class="gi">+                    while branchnode:</span>
<span class="gi">+                        branchnode[&#39;classes&#39;].append(&#39;current&#39;)</span>
<span class="gi">+                        branchnode = branchnode.parent</span>
<span class="gi">+                # mark the list_item as &quot;on current page&quot;</span>
<span class="gi">+                if subnode.parent.parent.get(&#39;iscurrent&#39;):</span>
<span class="gi">+                    # but only if it&#39;s not already done</span>
<span class="gi">+                    return</span>
<span class="gi">+                while subnode:</span>
<span class="gi">+                    subnode[&#39;iscurrent&#39;] = True</span>
<span class="gi">+                    subnode = subnode.parent</span>


<span class="w"> </span>ET = TypeVar(&#39;ET&#39;, bound=Element)


<span class="gd">-def _toctree_copy(node: ET, depth: int, maxdepth: int, collapse: bool, tags:</span>
<span class="gd">-    Tags) -&gt;ET:</span>
<span class="gi">+def _toctree_copy(node: ET, depth: int, maxdepth: int, collapse: bool, tags: Tags) -&gt; ET:</span>
<span class="w"> </span>    &quot;&quot;&quot;Utility: Cut and deep-copy a TOC at a specified depth.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    keep_bullet_list_sub_nodes = (depth &lt;= 1</span>
<span class="gi">+                                  or ((depth &lt;= maxdepth or maxdepth &lt;= 0)</span>
<span class="gi">+                                      and (not collapse or &#39;iscurrent&#39; in node)))</span>

<span class="gi">+    copy = node.copy()</span>
<span class="gi">+    for subnode in node.children:</span>
<span class="gi">+        if isinstance(subnode, addnodes.compact_paragraph | nodes.list_item):</span>
<span class="gi">+            # for &lt;p&gt; and &lt;li&gt;, just recurse</span>
<span class="gi">+            copy.append(_toctree_copy(subnode, depth, maxdepth, collapse, tags))</span>
<span class="gi">+        elif isinstance(subnode, nodes.bullet_list):</span>
<span class="gi">+            # for &lt;ul&gt;, copy if the entry is top-level</span>
<span class="gi">+            # or, copy if the depth is within bounds and;</span>
<span class="gi">+            # collapsing is disabled or the sub-entry&#39;s parent is &#39;current&#39;.</span>
<span class="gi">+            # The boolean is constant so is calculated outwith the loop.</span>
<span class="gi">+            if keep_bullet_list_sub_nodes:</span>
<span class="gi">+                copy.append(_toctree_copy(subnode, depth + 1, maxdepth, collapse, tags))</span>
<span class="gi">+        elif isinstance(subnode, addnodes.toctree):</span>
<span class="gi">+            # copy sub toctree nodes for later processing</span>
<span class="gi">+            copy.append(subnode.copy())</span>
<span class="gi">+        elif isinstance(subnode, addnodes.only):</span>
<span class="gi">+            # only keep children if the only node matches the tags</span>
<span class="gi">+            if _only_node_keep_children(subnode, tags):</span>
<span class="gi">+                for child in subnode.children:</span>
<span class="gi">+                    copy.append(_toctree_copy(</span>
<span class="gi">+                        child, depth, maxdepth, collapse, tags,  # type: ignore[type-var]</span>
<span class="gi">+                    ))</span>
<span class="gi">+        elif isinstance(subnode, nodes.reference | nodes.title):</span>
<span class="gi">+            # deep copy references and captions</span>
<span class="gi">+            sub_node_copy = subnode.copy()</span>
<span class="gi">+            sub_node_copy.children = [child.deepcopy() for child in subnode.children]</span>
<span class="gi">+            for child in sub_node_copy.children:</span>
<span class="gi">+                child.parent = sub_node_copy</span>
<span class="gi">+            copy.append(sub_node_copy)</span>
<span class="gi">+        else:</span>
<span class="gi">+            msg = f&#39;Unexpected node type {subnode.__class__.__name__!r}!&#39;</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gi">+    return copy</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_toctree_ancestors(</span>
<span class="gi">+    toctree_includes: dict[str, list[str]], docname: str,</span>
<span class="gi">+) -&gt; Set[str]:</span>
<span class="gi">+    parent: dict[str, str] = {}</span>
<span class="gi">+    for p, children in toctree_includes.items():</span>
<span class="gi">+        parent |= dict.fromkeys(children, p)</span>
<span class="gi">+    ancestors: list[str] = []</span>
<span class="gi">+    d = docname</span>
<span class="gi">+    while d in parent and d not in ancestors:</span>
<span class="gi">+        ancestors.append(d)</span>
<span class="gi">+        d = parent[d]</span>
<span class="gi">+    # use dict keys for ordered set operations</span>
<span class="gi">+    return dict.fromkeys(ancestors).keys()</span>

<span class="gd">-class TocTree:</span>

<span class="gd">-    def __init__(self, env: BuildEnvironment) -&gt;None:</span>
<span class="gi">+class TocTree:</span>
<span class="gi">+    def __init__(self, env: BuildEnvironment) -&gt; None:</span>
<span class="w"> </span>        self.env = env
<span class="gi">+</span>
<span class="gi">+    def note(self, docname: str, toctreenode: addnodes.toctree) -&gt; None:</span>
<span class="gi">+        note_toctree(self.env, docname, toctreenode)</span>
<span class="gi">+</span>
<span class="gi">+    def resolve(self, docname: str, builder: Builder, toctree: addnodes.toctree,</span>
<span class="gi">+                prune: bool = True, maxdepth: int = 0, titles_only: bool = False,</span>
<span class="gi">+                collapse: bool = False, includehidden: bool = False) -&gt; Element | None:</span>
<span class="gi">+        return _resolve_toctree(</span>
<span class="gi">+            self.env, docname, builder, toctree,</span>
<span class="gi">+            prune=prune,</span>
<span class="gi">+            maxdepth=maxdepth,</span>
<span class="gi">+            titles_only=titles_only,</span>
<span class="gi">+            collapse=collapse,</span>
<span class="gi">+            includehidden=includehidden,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_toctree_ancestors(self, docname: str) -&gt; list[str]:</span>
<span class="gi">+        return [*_get_toctree_ancestors(self.env.toctree_includes, docname)]</span>
<span class="gi">+</span>
<span class="gi">+    def get_toc_for(self, docname: str, builder: Builder) -&gt; Node:</span>
<span class="gi">+        return document_toc(self.env, docname, self.env.app.builder.tags)</span>
<span class="gi">+</span>
<span class="gi">+    def get_toctree_for(</span>
<span class="gi">+        self, docname: str, builder: Builder, collapse: bool, **kwargs: Any,</span>
<span class="gi">+    ) -&gt; Element | None:</span>
<span class="gi">+        return global_toctree_for_doc(self.env, docname, builder, collapse=collapse, **kwargs)</span>
<span class="gh">diff --git a/sphinx/environment/collectors/asset.py b/sphinx/environment/collectors/asset.py</span>
<span class="gh">index 7fe3a334b..368e47732 100644</span>
<span class="gd">--- a/sphinx/environment/collectors/asset.py</span>
<span class="gi">+++ b/sphinx/environment/collectors/asset.py</span>
<span class="gu">@@ -1,36 +1,148 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The image collector for sphinx.environment.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>from glob import glob
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.utils import relative_path
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.environment.collectors import EnvironmentCollector
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.i18n import get_image_filename_for_language, search_image_for_language
<span class="w"> </span>from sphinx.util.images import guess_mimetype
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.nodes import Node
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="w"> </span>class ImageCollector(EnvironmentCollector):
<span class="w"> </span>    &quot;&quot;&quot;Image files collector for sphinx.environment.&quot;&quot;&quot;

<span class="gd">-    def process_doc(self, app: Sphinx, doctree: nodes.document) -&gt;None:</span>
<span class="gi">+    def clear_doc(self, app: Sphinx, env: BuildEnvironment, docname: str) -&gt; None:</span>
<span class="gi">+        env.images.purge_doc(docname)</span>
<span class="gi">+</span>
<span class="gi">+    def merge_other(self, app: Sphinx, env: BuildEnvironment,</span>
<span class="gi">+                    docnames: set[str], other: BuildEnvironment) -&gt; None:</span>
<span class="gi">+        env.images.merge_other(docnames, other.images)</span>
<span class="gi">+</span>
<span class="gi">+    def process_doc(self, app: Sphinx, doctree: nodes.document) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Process and rewrite image URIs.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        docname = app.env.docname</span>
<span class="gi">+</span>
<span class="gi">+        for node in doctree.findall(nodes.image):</span>
<span class="gi">+            # Map the mimetype to the corresponding image.  The writer may</span>
<span class="gi">+            # choose the best image from these candidates.  The special key * is</span>
<span class="gi">+            # set if there is only single candidate to be used by a writer.</span>
<span class="gi">+            # The special key ? is set for nonlocal URIs.</span>
<span class="gi">+            candidates: dict[str, str] = {}</span>
<span class="gi">+            node[&#39;candidates&#39;] = candidates</span>
<span class="gi">+            imguri = node[&#39;uri&#39;]</span>
<span class="gi">+            if imguri.startswith(&#39;data:&#39;):</span>
<span class="gi">+                candidates[&#39;?&#39;] = imguri</span>
<span class="gi">+                continue</span>
<span class="gi">+            if imguri.find(&#39;://&#39;) != -1:</span>
<span class="gi">+                candidates[&#39;?&#39;] = imguri</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if imguri.endswith(os.extsep + &#39;*&#39;):</span>
<span class="gi">+                # Update `node[&#39;uri&#39;]` to a relative path from srcdir</span>
<span class="gi">+                # from a relative path from current document.</span>
<span class="gi">+                rel_imgpath, full_imgpath = app.env.relfn2path(imguri, docname)</span>
<span class="gi">+                node[&#39;uri&#39;] = rel_imgpath</span>
<span class="gi">+</span>
<span class="gi">+                # Search language-specific figures at first</span>
<span class="gi">+                i18n_imguri = get_image_filename_for_language(imguri, app.env)</span>
<span class="gi">+                _, full_i18n_imgpath = app.env.relfn2path(i18n_imguri, docname)</span>
<span class="gi">+                self.collect_candidates(app.env, full_i18n_imgpath, candidates, node)</span>
<span class="gi">+</span>
<span class="gi">+                self.collect_candidates(app.env, full_imgpath, candidates, node)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # substitute imguri by figure_language_filename</span>
<span class="gi">+                # (ex. foo.png -&gt; foo.en.png)</span>
<span class="gi">+                imguri = search_image_for_language(imguri, app.env)</span>
<span class="gi">+</span>
<span class="gi">+                # Update `node[&#39;uri&#39;]` to a relative path from srcdir</span>
<span class="gi">+                # from a relative path from current document.</span>
<span class="gi">+                original_uri = node[&#39;uri&#39;]</span>
<span class="gi">+                node[&#39;uri&#39;], _ = app.env.relfn2path(imguri, docname)</span>
<span class="gi">+                candidates[&#39;*&#39;] = node[&#39;uri&#39;]</span>
<span class="gi">+                if node[&#39;uri&#39;] != original_uri:</span>
<span class="gi">+                    node[&#39;original_uri&#39;] = original_uri</span>
<span class="gi">+</span>
<span class="gi">+            # map image paths to unique image names (so that they can be put</span>
<span class="gi">+            # into a single directory)</span>
<span class="gi">+            for imgpath in candidates.values():</span>
<span class="gi">+                app.env.dependencies[docname].add(imgpath)</span>
<span class="gi">+                if not os.access(path.join(app.srcdir, imgpath), os.R_OK):</span>
<span class="gi">+                    logger.warning(__(&#39;image file not readable: %s&#39;), imgpath,</span>
<span class="gi">+                                   location=node, type=&#39;image&#39;, subtype=&#39;not_readable&#39;)</span>
<span class="gi">+                    continue</span>
<span class="gi">+                app.env.images.add_file(docname, imgpath)</span>
<span class="gi">+</span>
<span class="gi">+    def collect_candidates(self, env: BuildEnvironment, imgpath: str,</span>
<span class="gi">+                           candidates: dict[str, str], node: Node) -&gt; None:</span>
<span class="gi">+        globbed: dict[str, list[str]] = {}</span>
<span class="gi">+        for filename in glob(imgpath):</span>
<span class="gi">+            new_imgpath = relative_path(path.join(env.srcdir, &#39;dummy&#39;),</span>
<span class="gi">+                                        filename)</span>
<span class="gi">+            try:</span>
<span class="gi">+                mimetype = guess_mimetype(filename)</span>
<span class="gi">+                if mimetype is None:</span>
<span class="gi">+                    basename, suffix = path.splitext(filename)</span>
<span class="gi">+                    mimetype = &#39;image/x-&#39; + suffix[1:]</span>
<span class="gi">+                if mimetype not in candidates:</span>
<span class="gi">+                    globbed.setdefault(mimetype, []).append(new_imgpath)</span>
<span class="gi">+            except OSError as err:</span>
<span class="gi">+                logger.warning(__(&#39;image file %s not readable: %s&#39;), filename, err,</span>
<span class="gi">+                               location=node, type=&#39;image&#39;, subtype=&#39;not_readable&#39;)</span>
<span class="gi">+        for key, files in globbed.items():</span>
<span class="gi">+            candidates[key] = min(files, key=len)  # select by similarity</span>


<span class="w"> </span>class DownloadFileCollector(EnvironmentCollector):
<span class="w"> </span>    &quot;&quot;&quot;Download files collector for sphinx.environment.&quot;&quot;&quot;

<span class="gd">-    def process_doc(self, app: Sphinx, doctree: nodes.document) -&gt;None:</span>
<span class="gi">+    def clear_doc(self, app: Sphinx, env: BuildEnvironment, docname: str) -&gt; None:</span>
<span class="gi">+        env.dlfiles.purge_doc(docname)</span>
<span class="gi">+</span>
<span class="gi">+    def merge_other(self, app: Sphinx, env: BuildEnvironment,</span>
<span class="gi">+                    docnames: set[str], other: BuildEnvironment) -&gt; None:</span>
<span class="gi">+        env.dlfiles.merge_other(docnames, other.dlfiles)</span>
<span class="gi">+</span>
<span class="gi">+    def process_doc(self, app: Sphinx, doctree: nodes.document) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Process downloadable file paths.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for node in doctree.findall(addnodes.download_reference):</span>
<span class="gi">+            targetname = node[&#39;reftarget&#39;]</span>
<span class="gi">+            if &#39;://&#39; in targetname:</span>
<span class="gi">+                node[&#39;refuri&#39;] = targetname</span>
<span class="gi">+            else:</span>
<span class="gi">+                rel_filename, filename = app.env.relfn2path(targetname, app.env.docname)</span>
<span class="gi">+                app.env.dependencies[app.env.docname].add(rel_filename)</span>
<span class="gi">+                if not os.access(filename, os.R_OK):</span>
<span class="gi">+                    logger.warning(__(&#39;download file not readable: %s&#39;), filename,</span>
<span class="gi">+                                   location=node, type=&#39;download&#39;, subtype=&#39;not_readable&#39;)</span>
<span class="gi">+                    continue</span>
<span class="gi">+                node[&#39;filename&#39;] = app.env.dlfiles.add_file(app.env.docname, rel_filename)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_env_collector(ImageCollector)</span>
<span class="gi">+    app.add_env_collector(DownloadFileCollector)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/environment/collectors/dependencies.py b/sphinx/environment/collectors/dependencies.py</span>
<span class="gh">index 25637aa67..33b54b824 100644</span>
<span class="gd">--- a/sphinx/environment/collectors/dependencies.py</span>
<span class="gi">+++ b/sphinx/environment/collectors/dependencies.py</span>
<span class="gu">@@ -1,13 +1,19 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The dependencies collector components for sphinx.environment.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from docutils.utils import relative_path
<span class="gi">+</span>
<span class="w"> </span>from sphinx.environment.collectors import EnvironmentCollector
<span class="w"> </span>from sphinx.util.osutil import fs_encoding
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gu">@@ -16,6 +22,37 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>class DependenciesCollector(EnvironmentCollector):
<span class="w"> </span>    &quot;&quot;&quot;dependencies collector for sphinx.environment.&quot;&quot;&quot;

<span class="gd">-    def process_doc(self, app: Sphinx, doctree: nodes.document) -&gt;None:</span>
<span class="gi">+    def clear_doc(self, app: Sphinx, env: BuildEnvironment, docname: str) -&gt; None:</span>
<span class="gi">+        env.dependencies.pop(docname, None)</span>
<span class="gi">+</span>
<span class="gi">+    def merge_other(self, app: Sphinx, env: BuildEnvironment,</span>
<span class="gi">+                    docnames: set[str], other: BuildEnvironment) -&gt; None:</span>
<span class="gi">+        for docname in docnames:</span>
<span class="gi">+            if docname in other.dependencies:</span>
<span class="gi">+                env.dependencies[docname] = other.dependencies[docname]</span>
<span class="gi">+</span>
<span class="gi">+    def process_doc(self, app: Sphinx, doctree: nodes.document) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Process docutils-generated dependency info.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cwd = os.getcwd()</span>
<span class="gi">+        frompath = path.join(path.normpath(app.srcdir), &#39;dummy&#39;)</span>
<span class="gi">+        deps = doctree.settings.record_dependencies</span>
<span class="gi">+        if not deps:</span>
<span class="gi">+            return</span>
<span class="gi">+        for dep in deps.list:</span>
<span class="gi">+            # the dependency path is relative to the working dir, so get</span>
<span class="gi">+            # one relative to the srcdir</span>
<span class="gi">+            if isinstance(dep, bytes):</span>
<span class="gi">+                dep = dep.decode(fs_encoding)</span>
<span class="gi">+            relpath = relative_path(frompath,</span>
<span class="gi">+                                    path.normpath(path.join(cwd, dep)))</span>
<span class="gi">+            app.env.dependencies[app.env.docname].add(relpath)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_env_collector(DependenciesCollector)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/environment/collectors/metadata.py b/sphinx/environment/collectors/metadata.py</span>
<span class="gh">index 199b4eb5e..bef35119e 100644</span>
<span class="gd">--- a/sphinx/environment/collectors/metadata.py</span>
<span class="gi">+++ b/sphinx/environment/collectors/metadata.py</span>
<span class="gu">@@ -1,8 +1,13 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The metadata collector components for sphinx.environment.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>from sphinx.environment.collectors import EnvironmentCollector
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="gu">@@ -12,9 +17,55 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>class MetadataCollector(EnvironmentCollector):
<span class="w"> </span>    &quot;&quot;&quot;metadata collector for sphinx.environment.&quot;&quot;&quot;

<span class="gd">-    def process_doc(self, app: Sphinx, doctree: nodes.document) -&gt;None:</span>
<span class="gi">+    def clear_doc(self, app: Sphinx, env: BuildEnvironment, docname: str) -&gt; None:</span>
<span class="gi">+        env.metadata.pop(docname, None)</span>
<span class="gi">+</span>
<span class="gi">+    def merge_other(self, app: Sphinx, env: BuildEnvironment,</span>
<span class="gi">+                    docnames: set[str], other: BuildEnvironment) -&gt; None:</span>
<span class="gi">+        for docname in docnames:</span>
<span class="gi">+            env.metadata[docname] = other.metadata[docname]</span>
<span class="gi">+</span>
<span class="gi">+    def process_doc(self, app: Sphinx, doctree: nodes.document) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Process the docinfo part of the doctree as metadata.

<span class="w"> </span>        Keep processing minimal -- just return what docutils says.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        index = doctree.first_child_not_matching_class(nodes.PreBibliographic)  # type: ignore[arg-type]</span>
<span class="gi">+        if index is None:</span>
<span class="gi">+            return</span>
<span class="gi">+        elif isinstance(doctree[index], nodes.docinfo):</span>
<span class="gi">+            md = app.env.metadata[app.env.docname]</span>
<span class="gi">+            for node in doctree[index]:  # type: ignore[attr-defined]</span>
<span class="gi">+                # nodes are multiply inherited...</span>
<span class="gi">+                if isinstance(node, nodes.authors):</span>
<span class="gi">+                    authors = cast(list[nodes.author], node)</span>
<span class="gi">+                    md[&#39;authors&#39;] = [author.astext() for author in authors]</span>
<span class="gi">+                elif isinstance(node, nodes.field):</span>
<span class="gi">+                    assert len(node) == 2</span>
<span class="gi">+                    field_name = cast(nodes.field_name, node[0])</span>
<span class="gi">+                    field_body = cast(nodes.field_body, node[1])</span>
<span class="gi">+                    md[field_name.astext()] = field_body.astext()</span>
<span class="gi">+                elif isinstance(node, nodes.TextElement):</span>
<span class="gi">+                    # other children must be TextElement</span>
<span class="gi">+                    # see: https://docutils.sourceforge.io/docs/ref/doctree.html#bibliographic-elements  # NoQA: E501</span>
<span class="gi">+                    md[node.__class__.__name__] = node.astext()</span>
<span class="gi">+</span>
<span class="gi">+            for name, value in md.items():</span>
<span class="gi">+                if name == &#39;tocdepth&#39;:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        value = int(value)</span>
<span class="gi">+                    except ValueError:</span>
<span class="gi">+                        value = 0</span>
<span class="gi">+                    md[name] = value</span>
<span class="gi">+</span>
<span class="gi">+            doctree.pop(index)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_env_collector(MetadataCollector)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/environment/collectors/title.py b/sphinx/environment/collectors/title.py</span>
<span class="gh">index 640a7a3a2..76e3f0379 100644</span>
<span class="gd">--- a/sphinx/environment/collectors/title.py</span>
<span class="gi">+++ b/sphinx/environment/collectors/title.py</span>
<span class="gu">@@ -1,9 +1,14 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The title collector components for sphinx.environment.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>from sphinx.environment.collectors import EnvironmentCollector
<span class="w"> </span>from sphinx.transforms import SphinxContentsFilter
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="gu">@@ -13,8 +18,45 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>class TitleCollector(EnvironmentCollector):
<span class="w"> </span>    &quot;&quot;&quot;title collector for sphinx.environment.&quot;&quot;&quot;

<span class="gd">-    def process_doc(self, app: Sphinx, doctree: nodes.document) -&gt;None:</span>
<span class="gi">+    def clear_doc(self, app: Sphinx, env: BuildEnvironment, docname: str) -&gt; None:</span>
<span class="gi">+        env.titles.pop(docname, None)</span>
<span class="gi">+        env.longtitles.pop(docname, None)</span>
<span class="gi">+</span>
<span class="gi">+    def merge_other(self, app: Sphinx, env: BuildEnvironment,</span>
<span class="gi">+                    docnames: set[str], other: BuildEnvironment) -&gt; None:</span>
<span class="gi">+        for docname in docnames:</span>
<span class="gi">+            env.titles[docname] = other.titles[docname]</span>
<span class="gi">+            env.longtitles[docname] = other.longtitles[docname]</span>
<span class="gi">+</span>
<span class="gi">+    def process_doc(self, app: Sphinx, doctree: nodes.document) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a title node to the document (just copy the first section title),
<span class="w"> </span>        and store that title in the environment.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        titlenode = nodes.title()</span>
<span class="gi">+        longtitlenode = titlenode</span>
<span class="gi">+        # explicit title set with title directive; use this only for</span>
<span class="gi">+        # the &lt;title&gt; tag in HTML output</span>
<span class="gi">+        if &#39;title&#39; in doctree:</span>
<span class="gi">+            longtitlenode = nodes.title()</span>
<span class="gi">+            longtitlenode += nodes.Text(doctree[&#39;title&#39;])</span>
<span class="gi">+        # look for first section title and use that as the title</span>
<span class="gi">+        for node in doctree.findall(nodes.section):</span>
<span class="gi">+            visitor = SphinxContentsFilter(doctree)</span>
<span class="gi">+            node[0].walkabout(visitor)</span>
<span class="gi">+            titlenode += visitor.get_entry_text()  # type: ignore[no-untyped-call]</span>
<span class="gi">+            break</span>
<span class="gi">+        else:</span>
<span class="gi">+            # document has no title</span>
<span class="gi">+            titlenode += nodes.Text(doctree.get(&#39;title&#39;, &#39;&lt;no title&gt;&#39;))</span>
<span class="gi">+        app.env.titles[app.env.docname] = titlenode</span>
<span class="gi">+        app.env.longtitles[app.env.docname] = longtitlenode</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_env_collector(TitleCollector)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/environment/collectors/toctree.py b/sphinx/environment/collectors/toctree.py</span>
<span class="gh">index c429eda00..e3f80f251 100644</span>
<span class="gd">--- a/sphinx/environment/collectors/toctree.py</span>
<span class="gi">+++ b/sphinx/environment/collectors/toctree.py</span>
<span class="gu">@@ -1,33 +1,369 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Toctree collector for sphinx.environment.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, TypeVar, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.environment.adapters.toctree import note_toctree
<span class="w"> </span>from sphinx.environment.collectors import EnvironmentCollector
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.transforms import SphinxContentsFilter
<span class="w"> </span>from sphinx.util import logging, url_re
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Sequence
<span class="gi">+</span>
<span class="w"> </span>    from docutils.nodes import Element, Node
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gi">+</span>
<span class="w"> </span>N = TypeVar(&#39;N&#39;)
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="w"> </span>class TocTreeCollector(EnvironmentCollector):
<span class="gi">+    def clear_doc(self, app: Sphinx, env: BuildEnvironment, docname: str) -&gt; None:</span>
<span class="gi">+        env.tocs.pop(docname, None)</span>
<span class="gi">+        env.toc_secnumbers.pop(docname, None)</span>
<span class="gi">+        env.toc_fignumbers.pop(docname, None)</span>
<span class="gi">+        env.toc_num_entries.pop(docname, None)</span>
<span class="gi">+        env.toctree_includes.pop(docname, None)</span>
<span class="gi">+        env.glob_toctrees.discard(docname)</span>
<span class="gi">+        env.numbered_toctrees.discard(docname)</span>
<span class="gi">+</span>
<span class="gi">+        for subfn, fnset in list(env.files_to_rebuild.items()):</span>
<span class="gi">+            fnset.discard(docname)</span>
<span class="gi">+            if not fnset:</span>
<span class="gi">+                del env.files_to_rebuild[subfn]</span>
<span class="gi">+</span>
<span class="gi">+    def merge_other(self, app: Sphinx, env: BuildEnvironment, docnames: set[str],</span>
<span class="gi">+                    other: BuildEnvironment) -&gt; None:</span>
<span class="gi">+        for docname in docnames:</span>
<span class="gi">+            env.tocs[docname] = other.tocs[docname]</span>
<span class="gi">+            env.toc_num_entries[docname] = other.toc_num_entries[docname]</span>
<span class="gi">+            if docname in other.toctree_includes:</span>
<span class="gi">+                env.toctree_includes[docname] = other.toctree_includes[docname]</span>
<span class="gi">+            if docname in other.glob_toctrees:</span>
<span class="gi">+                env.glob_toctrees.add(docname)</span>
<span class="gi">+            if docname in other.numbered_toctrees:</span>
<span class="gi">+                env.numbered_toctrees.add(docname)</span>
<span class="gi">+</span>
<span class="gi">+        for subfn, fnset in other.files_to_rebuild.items():</span>
<span class="gi">+            env.files_to_rebuild.setdefault(subfn, set()).update(fnset &amp; set(docnames))</span>

<span class="gd">-    def process_doc(self, app: Sphinx, doctree: nodes.document) -&gt;None:</span>
<span class="gi">+    def process_doc(self, app: Sphinx, doctree: nodes.document) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Build a TOC from the doctree and store it in the inventory.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        docname = app.env.docname</span>
<span class="gi">+        numentries = [0]  # nonlocal again...</span>

<span class="gd">-    def assign_section_numbers(self, env: BuildEnvironment) -&gt;list[str]:</span>
<span class="gi">+        def build_toc(</span>
<span class="gi">+            node: Element | Sequence[Element],</span>
<span class="gi">+            depth: int = 1,</span>
<span class="gi">+        ) -&gt; nodes.bullet_list | None:</span>
<span class="gi">+            # list of table of contents entries</span>
<span class="gi">+            entries: list[Element] = []</span>
<span class="gi">+            for sectionnode in node:</span>
<span class="gi">+                # find all toctree nodes in this section and add them</span>
<span class="gi">+                # to the toc (just copying the toctree node which is then</span>
<span class="gi">+                # resolved in self.get_and_resolve_doctree)</span>
<span class="gi">+                if isinstance(sectionnode, nodes.section):</span>
<span class="gi">+                    title = sectionnode[0]</span>
<span class="gi">+                    # copy the contents of the section title, but without references</span>
<span class="gi">+                    # and unnecessary stuff</span>
<span class="gi">+                    visitor = SphinxContentsFilter(doctree)</span>
<span class="gi">+                    title.walkabout(visitor)</span>
<span class="gi">+                    nodetext = visitor.get_entry_text()  # type: ignore[no-untyped-call]</span>
<span class="gi">+                    anchorname = _make_anchor_name(sectionnode[&#39;ids&#39;], numentries)</span>
<span class="gi">+                    # make these nodes:</span>
<span class="gi">+                    # list_item -&gt; compact_paragraph -&gt; reference</span>
<span class="gi">+                    reference = nodes.reference(</span>
<span class="gi">+                        &#39;&#39;, &#39;&#39;, internal=True, refuri=docname,</span>
<span class="gi">+                        anchorname=anchorname, *nodetext)</span>
<span class="gi">+                    para = addnodes.compact_paragraph(&#39;&#39;, &#39;&#39;, reference)</span>
<span class="gi">+                    item: Element = nodes.list_item(&#39;&#39;, para)</span>
<span class="gi">+                    sub_item = build_toc(sectionnode, depth + 1)</span>
<span class="gi">+                    if sub_item:</span>
<span class="gi">+                        item += sub_item</span>
<span class="gi">+                    entries.append(item)</span>
<span class="gi">+                # Wrap items under an ``.. only::`` directive in a node for</span>
<span class="gi">+                # post-processing</span>
<span class="gi">+                elif isinstance(sectionnode, addnodes.only):</span>
<span class="gi">+                    onlynode = addnodes.only(expr=sectionnode[&#39;expr&#39;])</span>
<span class="gi">+                    blist = build_toc(sectionnode, depth)</span>
<span class="gi">+                    if blist:</span>
<span class="gi">+                        onlynode += blist.children</span>
<span class="gi">+                        entries.append(onlynode)</span>
<span class="gi">+                # check within the section for other node types</span>
<span class="gi">+                elif isinstance(sectionnode, nodes.Element):</span>
<span class="gi">+                    # cache of parent node -&gt; list item</span>
<span class="gi">+                    memo_parents: dict[nodes.Element, nodes.list_item] = {}</span>
<span class="gi">+                    toctreenode: nodes.Node</span>
<span class="gi">+                    for toctreenode in sectionnode.findall():</span>
<span class="gi">+                        if isinstance(toctreenode, nodes.section):</span>
<span class="gi">+                            continue</span>
<span class="gi">+                        if isinstance(toctreenode, addnodes.toctree):</span>
<span class="gi">+                            item = toctreenode.copy()</span>
<span class="gi">+                            entries.append(item)</span>
<span class="gi">+                            # important: do the inventory stuff</span>
<span class="gi">+                            note_toctree(app.env, docname, toctreenode)</span>
<span class="gi">+                        # add object signatures within a section to the ToC</span>
<span class="gi">+                        elif isinstance(toctreenode, addnodes.desc):</span>
<span class="gi">+                            # The desc has one or more nested desc_signature,</span>
<span class="gi">+                            # and then a desc_content, which again may have desc nodes.</span>
<span class="gi">+                            # Thus, desc is the one we can bubble up to through parents.</span>
<span class="gi">+                            entry: nodes.list_item | None = None</span>
<span class="gi">+                            for sig_node in toctreenode:</span>
<span class="gi">+                                if not isinstance(sig_node, addnodes.desc_signature):</span>
<span class="gi">+                                    continue</span>
<span class="gi">+                                # Skip if no name set</span>
<span class="gi">+                                if not sig_node.get(&#39;_toc_name&#39;, &#39;&#39;):</span>
<span class="gi">+                                    continue</span>
<span class="gi">+                                # Skip if explicitly disabled</span>
<span class="gi">+                                if sig_node.parent.get(&#39;no-contents-entry&#39;):</span>
<span class="gi">+                                    continue</span>
<span class="gi">+                                # Skip entries with no ID (e.g. with :no-index: set)</span>
<span class="gi">+                                ids = sig_node[&#39;ids&#39;]</span>
<span class="gi">+                                if not ids:</span>
<span class="gi">+                                    continue</span>
<span class="gi">+</span>
<span class="gi">+                                anchorname = _make_anchor_name(ids, numentries)</span>
<span class="gi">+</span>
<span class="gi">+                                reference = nodes.reference(</span>
<span class="gi">+                                    &#39;&#39;, &#39;&#39;, nodes.literal(&#39;&#39;, sig_node[&#39;_toc_name&#39;]),</span>
<span class="gi">+                                    internal=True, refuri=docname, anchorname=anchorname)</span>
<span class="gi">+                                para = addnodes.compact_paragraph(&#39;&#39;, &#39;&#39;, reference,</span>
<span class="gi">+                                                                  skip_section_number=True)</span>
<span class="gi">+                                entry = nodes.list_item(&#39;&#39;, para)</span>
<span class="gi">+</span>
<span class="gi">+                                # Find parent node</span>
<span class="gi">+                                parent = sig_node.parent</span>
<span class="gi">+                                while parent not in memo_parents and parent != sectionnode:</span>
<span class="gi">+                                    parent = parent.parent</span>
<span class="gi">+                                # Note, it may both be the limit and in memo_parents,</span>
<span class="gi">+                                # prefer memo_parents, so we get the nesting.</span>
<span class="gi">+                                if parent in memo_parents:</span>
<span class="gi">+                                    root_entry = memo_parents[parent]</span>
<span class="gi">+                                    if isinstance(root_entry[-1], nodes.bullet_list):</span>
<span class="gi">+                                        root_entry[-1].append(entry)</span>
<span class="gi">+                                    else:</span>
<span class="gi">+                                        root_entry.append(nodes.bullet_list(&#39;&#39;, entry))</span>
<span class="gi">+                                else:</span>
<span class="gi">+                                    assert parent == sectionnode</span>
<span class="gi">+                                    entries.append(entry)</span>
<span class="gi">+</span>
<span class="gi">+                            # Save the latest desc_signature as the one we put sub entries in.</span>
<span class="gi">+                            # If there are multiple signatures, then the latest is used.</span>
<span class="gi">+                            if entry is not None:</span>
<span class="gi">+                                # are there any desc nodes without desc_signature nodes?</span>
<span class="gi">+                                memo_parents[toctreenode] = entry</span>
<span class="gi">+</span>
<span class="gi">+            if entries:</span>
<span class="gi">+                return nodes.bullet_list(&#39;&#39;, *entries)</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        toc = build_toc(doctree)</span>
<span class="gi">+        if toc:</span>
<span class="gi">+            app.env.tocs[docname] = toc</span>
<span class="gi">+        else:</span>
<span class="gi">+            app.env.tocs[docname] = nodes.bullet_list(&#39;&#39;)</span>
<span class="gi">+        app.env.toc_num_entries[docname] = numentries[0]</span>
<span class="gi">+</span>
<span class="gi">+    def get_updated_docs(self, app: Sphinx, env: BuildEnvironment) -&gt; list[str]:</span>
<span class="gi">+        return self.assign_section_numbers(env) + self.assign_figure_numbers(env)</span>
<span class="gi">+</span>
<span class="gi">+    def assign_section_numbers(self, env: BuildEnvironment) -&gt; list[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Assign a section number to each heading under a numbered toctree.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # a list of all docnames whose section numbers changed</span>
<span class="gi">+        rewrite_needed = []</span>
<span class="gi">+</span>
<span class="gi">+        assigned: set[str] = set()</span>
<span class="gi">+        old_secnumbers = env.toc_secnumbers</span>
<span class="gi">+        env.toc_secnumbers = {}</span>
<span class="gi">+</span>
<span class="gi">+        def _walk_toc(</span>
<span class="gi">+            node: Element,</span>
<span class="gi">+            secnums: dict[str, tuple[int, ...]],</span>
<span class="gi">+            depth: int,</span>
<span class="gi">+            titlenode: nodes.title | None = None,</span>
<span class="gi">+        ) -&gt; None:</span>
<span class="gi">+            # titlenode is the title of the document, it will get assigned a</span>
<span class="gi">+            # secnumber too, so that it shows up in next/prev/parent rellinks</span>
<span class="gi">+            for subnode in node.children:</span>
<span class="gi">+                if isinstance(subnode, nodes.bullet_list):</span>
<span class="gi">+                    numstack.append(0)</span>
<span class="gi">+                    _walk_toc(subnode, secnums, depth - 1, titlenode)</span>
<span class="gi">+                    numstack.pop()</span>
<span class="gi">+                    titlenode = None</span>
<span class="gi">+                elif isinstance(subnode, nodes.list_item):  # NoQA: SIM114</span>
<span class="gi">+                    _walk_toc(subnode, secnums, depth, titlenode)</span>
<span class="gi">+                    titlenode = None</span>
<span class="gi">+                elif isinstance(subnode, addnodes.only):</span>
<span class="gi">+                    # at this stage we don&#39;t know yet which sections are going</span>
<span class="gi">+                    # to be included; just include all of them, even if it leads</span>
<span class="gi">+                    # to gaps in the numbering</span>
<span class="gi">+                    _walk_toc(subnode, secnums, depth, titlenode)</span>
<span class="gi">+                    titlenode = None</span>
<span class="gi">+                elif isinstance(subnode, addnodes.compact_paragraph):</span>
<span class="gi">+                    if &#39;skip_section_number&#39; in subnode:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    numstack[-1] += 1</span>
<span class="gi">+                    reference = cast(nodes.reference, subnode[0])</span>
<span class="gi">+                    if depth &gt; 0:</span>
<span class="gi">+                        number = numstack.copy()</span>
<span class="gi">+                        secnums[reference[&#39;anchorname&#39;]] = tuple(numstack)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        number = None</span>
<span class="gi">+                        secnums[reference[&#39;anchorname&#39;]] = ()</span>
<span class="gi">+                    reference[&#39;secnumber&#39;] = number</span>
<span class="gi">+                    if titlenode:</span>
<span class="gi">+                        titlenode[&#39;secnumber&#39;] = number</span>
<span class="gi">+                        titlenode = None</span>
<span class="gi">+                elif isinstance(subnode, addnodes.toctree):</span>
<span class="gi">+                    _walk_toctree(subnode, depth)</span>
<span class="gi">+</span>
<span class="gi">+        def _walk_toctree(toctreenode: addnodes.toctree, depth: int) -&gt; None:</span>
<span class="gi">+            if depth == 0:</span>
<span class="gi">+                return</span>
<span class="gi">+            for (_title, ref) in toctreenode[&#39;entries&#39;]:</span>
<span class="gi">+                if url_re.match(ref) or ref == &#39;self&#39;:</span>
<span class="gi">+                    # don&#39;t mess with those</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if ref in assigned:</span>
<span class="gi">+                    logger.warning(__(&#39;%s is already assigned section numbers &#39;</span>
<span class="gi">+                                      &#39;(nested numbered toctree?)&#39;), ref,</span>
<span class="gi">+                                   location=toctreenode, type=&#39;toc&#39;, subtype=&#39;secnum&#39;)</span>
<span class="gi">+                elif ref in env.tocs:</span>
<span class="gi">+                    secnums: dict[str, tuple[int, ...]] = {}</span>
<span class="gi">+                    env.toc_secnumbers[ref] = secnums</span>
<span class="gi">+                    assigned.add(ref)</span>
<span class="gi">+                    _walk_toc(env.tocs[ref], secnums, depth, env.titles.get(ref))</span>
<span class="gi">+                    if secnums != old_secnumbers.get(ref):</span>
<span class="gi">+                        rewrite_needed.append(ref)</span>
<span class="gi">+</span>
<span class="gi">+        for docname in env.numbered_toctrees:</span>
<span class="gi">+            assigned.add(docname)</span>
<span class="gi">+            doctree = env.get_doctree(docname)</span>
<span class="gi">+            for toctreenode in doctree.findall(addnodes.toctree):</span>
<span class="gi">+                depth = toctreenode.get(&#39;numbered&#39;, 0)</span>
<span class="gi">+                if depth:</span>
<span class="gi">+                    # every numbered toctree gets new numbering</span>
<span class="gi">+                    numstack = [0]</span>
<span class="gi">+                    _walk_toctree(toctreenode, depth)</span>

<span class="gd">-    def assign_figure_numbers(self, env: BuildEnvironment) -&gt;list[str]:</span>
<span class="gi">+        return rewrite_needed</span>
<span class="gi">+</span>
<span class="gi">+    def assign_figure_numbers(self, env: BuildEnvironment) -&gt; list[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Assign a figure number to each figure under a numbered toctree.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        generated_docnames = frozenset(env.domains[&#39;std&#39;]._virtual_doc_names)</span>
<span class="gi">+</span>
<span class="gi">+        rewrite_needed = []</span>
<span class="gi">+</span>
<span class="gi">+        assigned: set[str] = set()</span>
<span class="gi">+        old_fignumbers = env.toc_fignumbers</span>
<span class="gi">+        env.toc_fignumbers = {}</span>
<span class="gi">+        fignum_counter: dict[str, dict[tuple[int, ...], int]] = {}</span>
<span class="gi">+</span>
<span class="gi">+        def get_figtype(node: Node) -&gt; str | None:</span>
<span class="gi">+            for domain in env.domains.values():</span>
<span class="gi">+                figtype = domain.get_enumerable_node_type(node)</span>
<span class="gi">+                if (domain.name == &#39;std&#39;</span>
<span class="gi">+                        and not domain.get_numfig_title(node)):  # type: ignore[attr-defined]  # NoQA: E501</span>
<span class="gi">+                    # Skip if uncaptioned node</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                if figtype:</span>
<span class="gi">+                    return figtype</span>
<span class="gi">+</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        def get_section_number(docname: str, section: nodes.section) -&gt; tuple[int, ...]:</span>
<span class="gi">+            anchorname = &#39;#&#39; + section[&#39;ids&#39;][0]</span>
<span class="gi">+            secnumbers = env.toc_secnumbers.get(docname, {})</span>
<span class="gi">+            if anchorname in secnumbers:</span>
<span class="gi">+                secnum = secnumbers.get(anchorname)</span>
<span class="gi">+            else:</span>
<span class="gi">+                secnum = secnumbers.get(&#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            return secnum or ()</span>
<span class="gi">+</span>
<span class="gi">+        def get_next_fignumber(figtype: str, secnum: tuple[int, ...]) -&gt; tuple[int, ...]:</span>
<span class="gi">+            counter = fignum_counter.setdefault(figtype, {})</span>
<span class="gi">+</span>
<span class="gi">+            secnum = secnum[:env.config.numfig_secnum_depth]</span>
<span class="gi">+            counter[secnum] = counter.get(secnum, 0) + 1</span>
<span class="gi">+            return (*secnum, counter[secnum])</span>
<span class="gi">+</span>
<span class="gi">+        def register_fignumber(docname: str, secnum: tuple[int, ...],</span>
<span class="gi">+                               figtype: str, fignode: Element) -&gt; None:</span>
<span class="gi">+            env.toc_fignumbers.setdefault(docname, {})</span>
<span class="gi">+            fignumbers = env.toc_fignumbers[docname].setdefault(figtype, {})</span>
<span class="gi">+            figure_id = fignode[&#39;ids&#39;][0]</span>
<span class="gi">+</span>
<span class="gi">+            fignumbers[figure_id] = get_next_fignumber(figtype, secnum)</span>
<span class="gi">+</span>
<span class="gi">+        def _walk_doctree(docname: str, doctree: Element, secnum: tuple[int, ...]) -&gt; None:</span>
<span class="gi">+            nonlocal generated_docnames</span>
<span class="gi">+            for subnode in doctree.children:</span>
<span class="gi">+                if isinstance(subnode, nodes.section):</span>
<span class="gi">+                    next_secnum = get_section_number(docname, subnode)</span>
<span class="gi">+                    if next_secnum:</span>
<span class="gi">+                        _walk_doctree(docname, subnode, next_secnum)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        _walk_doctree(docname, subnode, secnum)</span>
<span class="gi">+                elif isinstance(subnode, addnodes.toctree):</span>
<span class="gi">+                    for _title, subdocname in subnode[&#39;entries&#39;]:</span>
<span class="gi">+                        if url_re.match(subdocname) or subdocname == &#39;self&#39;:</span>
<span class="gi">+                            # don&#39;t mess with those</span>
<span class="gi">+                            continue</span>
<span class="gi">+                        if subdocname in generated_docnames:</span>
<span class="gi">+                            # or these</span>
<span class="gi">+                            continue</span>
<span class="gi">+</span>
<span class="gi">+                        _walk_doc(subdocname, secnum)</span>
<span class="gi">+                elif isinstance(subnode, nodes.Element):</span>
<span class="gi">+                    figtype = get_figtype(subnode)</span>
<span class="gi">+                    if figtype and subnode[&#39;ids&#39;]:</span>
<span class="gi">+                        register_fignumber(docname, secnum, figtype, subnode)</span>
<span class="gi">+</span>
<span class="gi">+                    _walk_doctree(docname, subnode, secnum)</span>
<span class="gi">+</span>
<span class="gi">+        def _walk_doc(docname: str, secnum: tuple[int, ...]) -&gt; None:</span>
<span class="gi">+            if docname not in assigned:</span>
<span class="gi">+                assigned.add(docname)</span>
<span class="gi">+                doctree = env.get_doctree(docname)</span>
<span class="gi">+                _walk_doctree(docname, doctree, secnum)</span>
<span class="gi">+</span>
<span class="gi">+        if env.config.numfig:</span>
<span class="gi">+            _walk_doc(env.config.root_doc, ())</span>
<span class="gi">+            for docname, fignums in env.toc_fignumbers.items():</span>
<span class="gi">+                if fignums != old_fignumbers.get(docname):</span>
<span class="gi">+                    rewrite_needed.append(docname)</span>
<span class="gi">+</span>
<span class="gi">+        return rewrite_needed</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_anchor_name(ids: list[str], num_entries: list[int]) -&gt; str:</span>
<span class="gi">+    if not num_entries[0]:</span>
<span class="gi">+        # for the very first toc entry, don&#39;t add an anchor</span>
<span class="gi">+        # as it is the file&#39;s title anyway</span>
<span class="gi">+        anchorname = &#39;&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        anchorname = &#39;#&#39; + ids[0]</span>
<span class="gi">+    num_entries[0] += 1</span>
<span class="gi">+    return anchorname</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_env_collector(TocTreeCollector)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/errors.py b/sphinx/errors.py</span>
<span class="gh">index 9ce41ec6f..c0339b4e9 100644</span>
<span class="gd">--- a/sphinx/errors.py</span>
<span class="gi">+++ b/sphinx/errors.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Contains SphinxError and a few subclasses.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import Any


<span class="gu">@@ -23,37 +25,49 @@ class SphinxError(Exception):</span>
<span class="w"> </span>       exception to a string (&quot;category: message&quot;).  Should be set accordingly
<span class="w"> </span>       in subclasses.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    category = &#39;Sphinx error&#39;


<span class="w"> </span>class SphinxWarning(SphinxError):
<span class="w"> </span>    &quot;&quot;&quot;Warning, treated as error.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    category = &#39;Warning, treated as error&#39;


<span class="w"> </span>class ApplicationError(SphinxError):
<span class="w"> </span>    &quot;&quot;&quot;Application initialization error.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    category = &#39;Application error&#39;


<span class="w"> </span>class ExtensionError(SphinxError):
<span class="w"> </span>    &quot;&quot;&quot;Extension error.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, message: str, orig_exc: (Exception | None)=None,</span>
<span class="gd">-        modname: (str | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        message: str,</span>
<span class="gi">+        orig_exc: Exception | None = None,</span>
<span class="gi">+        modname: str | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        super().__init__(message)
<span class="w"> </span>        self.message = message
<span class="w"> </span>        self.orig_exc = orig_exc
<span class="w"> </span>        self.modname = modname

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    @property</span>
<span class="gi">+    def category(self) -&gt; str:  # type: ignore[override]</span>
<span class="gi">+        if self.modname:</span>
<span class="gi">+            return &#39;Extension error (%s)&#39; % self.modname</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;Extension error&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        if self.orig_exc:
<span class="gd">-            return (</span>
<span class="gd">-                f&#39;{self.__class__.__name__}({self.message!r}, {self.orig_exc!r})&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+            return f&#39;{self.__class__.__name__}({self.message!r}, {self.orig_exc!r})&#39;</span>
<span class="w"> </span>        return f&#39;{self.__class__.__name__}({self.message!r})&#39;

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        parent_str = super().__str__()
<span class="w"> </span>        if self.orig_exc:
<span class="w"> </span>            return f&#39;{parent_str} (exception: {self.orig_exc})&#39;
<span class="gu">@@ -62,45 +76,51 @@ class ExtensionError(SphinxError):</span>

<span class="w"> </span>class BuildEnvironmentError(SphinxError):
<span class="w"> </span>    &quot;&quot;&quot;BuildEnvironment error.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    category = &#39;BuildEnvironment error&#39;


<span class="w"> </span>class ConfigError(SphinxError):
<span class="w"> </span>    &quot;&quot;&quot;Configuration error.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    category = &#39;Configuration error&#39;


<span class="w"> </span>class DocumentError(SphinxError):
<span class="w"> </span>    &quot;&quot;&quot;Document error.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    category = &#39;Document error&#39;


<span class="w"> </span>class ThemeError(SphinxError):
<span class="w"> </span>    &quot;&quot;&quot;Theme error.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    category = &#39;Theme error&#39;


<span class="w"> </span>class VersionRequirementError(SphinxError):
<span class="w"> </span>    &quot;&quot;&quot;Incompatible Sphinx version error.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    category = &#39;Sphinx version error&#39;


<span class="w"> </span>class SphinxParallelError(SphinxError):
<span class="w"> </span>    &quot;&quot;&quot;Sphinx parallel build error.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    category = &#39;Sphinx parallel build error&#39;

<span class="gd">-    def __init__(self, message: str, traceback: Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, message: str, traceback: Any) -&gt; None:</span>
<span class="w"> </span>        self.message = message
<span class="w"> </span>        self.traceback = traceback

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return self.message


<span class="w"> </span>class PycodeError(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Pycode Python source code analyser error.&quot;&quot;&quot;

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        res = self.args[0]
<span class="w"> </span>        if len(self.args) &gt; 1:
<span class="w"> </span>            res += &#39; (exception was: %r)&#39; % self.args[1]
<span class="gu">@@ -111,9 +131,11 @@ class NoUri(Exception):</span>
<span class="w"> </span>    &quot;&quot;&quot;Raised by builder.get_relative_uri() or from missing-reference handlers
<span class="w"> </span>    if there is no URI available.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class FiletypeNotFoundError(Exception):
<span class="w"> </span>    &quot;&quot;&quot;Raised by get_filetype() if a filename matches no source suffix.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass
<span class="gh">diff --git a/sphinx/events.py b/sphinx/events.py</span>
<span class="gh">index f40abbefa..17de456f0 100644</span>
<span class="gd">--- a/sphinx/events.py</span>
<span class="gi">+++ b/sphinx/events.py</span>
<span class="gu">@@ -2,19 +2,25 @@</span>

<span class="w"> </span>Gracefully adapted from the TextPress system by Armin.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from operator import attrgetter
<span class="w"> </span>from typing import TYPE_CHECKING, NamedTuple, overload
<span class="gi">+</span>
<span class="w"> </span>from sphinx.errors import ExtensionError, SphinxError
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.inspect import safe_getattr
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Callable, Iterable, Sequence, Set
<span class="w"> </span>    from pathlib import Path
<span class="w"> </span>    from typing import Any, Literal
<span class="gi">+</span>
<span class="w"> </span>    from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>    from sphinx import addnodes
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.builders import Builder
<span class="gu">@@ -22,6 +28,8 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>    from sphinx.domains import Domain
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="w"> </span>    from sphinx.ext.todo import todo_node
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="gu">@@ -31,49 +39,409 @@ class EventListener(NamedTuple):</span>
<span class="w"> </span>    priority: int


<span class="gd">-core_events = {&#39;config-inited&#39;: &#39;config&#39;, &#39;builder-inited&#39;: &#39;&#39;,</span>
<span class="gi">+# List of all known core events. Maps name to arguments description.</span>
<span class="gi">+core_events = {</span>
<span class="gi">+    &#39;config-inited&#39;: &#39;config&#39;,</span>
<span class="gi">+    &#39;builder-inited&#39;: &#39;&#39;,</span>
<span class="w"> </span>    &#39;env-get-outdated&#39;: &#39;env, added, changed, removed&#39;,
<span class="gd">-    &#39;env-before-read-docs&#39;: &#39;env, docnames&#39;, &#39;env-purge-doc&#39;:</span>
<span class="gd">-    &#39;env, docname&#39;, &#39;source-read&#39;: &#39;docname, source text&#39;, &#39;include-read&#39;:</span>
<span class="gd">-    &#39;relative path, parent docname, source text&#39;, &#39;doctree-read&#39;:</span>
<span class="gd">-    &#39;the doctree before being pickled&#39;, &#39;env-merge-info&#39;:</span>
<span class="gd">-    &#39;env, read docnames, other env instance&#39;, &#39;env-updated&#39;: &#39;env&#39;,</span>
<span class="gd">-    &#39;env-get-updated&#39;: &#39;env&#39;, &#39;env-check-consistency&#39;: &#39;env&#39;,</span>
<span class="gd">-    &#39;write-started&#39;: &#39;builder&#39;, &#39;doctree-resolved&#39;: &#39;doctree, docname&#39;,</span>
<span class="gd">-    &#39;missing-reference&#39;: &#39;env, node, contnode&#39;, &#39;warn-missing-reference&#39;:</span>
<span class="gd">-    &#39;domain, node&#39;, &#39;build-finished&#39;: &#39;exception&#39;}</span>
<span class="gi">+    &#39;env-before-read-docs&#39;: &#39;env, docnames&#39;,</span>
<span class="gi">+    &#39;env-purge-doc&#39;: &#39;env, docname&#39;,</span>
<span class="gi">+    &#39;source-read&#39;: &#39;docname, source text&#39;,</span>
<span class="gi">+    &#39;include-read&#39;: &#39;relative path, parent docname, source text&#39;,</span>
<span class="gi">+    &#39;doctree-read&#39;: &#39;the doctree before being pickled&#39;,</span>
<span class="gi">+    &#39;env-merge-info&#39;: &#39;env, read docnames, other env instance&#39;,</span>
<span class="gi">+    &#39;env-updated&#39;: &#39;env&#39;,</span>
<span class="gi">+    &#39;env-get-updated&#39;: &#39;env&#39;,</span>
<span class="gi">+    &#39;env-check-consistency&#39;: &#39;env&#39;,</span>
<span class="gi">+    &#39;write-started&#39;: &#39;builder&#39;,</span>
<span class="gi">+    &#39;doctree-resolved&#39;: &#39;doctree, docname&#39;,</span>
<span class="gi">+    &#39;missing-reference&#39;: &#39;env, node, contnode&#39;,</span>
<span class="gi">+    &#39;warn-missing-reference&#39;: &#39;domain, node&#39;,</span>
<span class="gi">+    &#39;build-finished&#39;: &#39;exception&#39;,</span>
<span class="gi">+}</span>


<span class="w"> </span>class EventManager:
<span class="w"> </span>    &quot;&quot;&quot;Event manager for Sphinx.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, app: Sphinx) -&gt;None:</span>
<span class="gi">+    def __init__(self, app: Sphinx) -&gt; None:</span>
<span class="w"> </span>        self.app = app
<span class="w"> </span>        self.events = core_events.copy()
<span class="w"> </span>        self.listeners: dict[str, list[EventListener]] = defaultdict(list)
<span class="w"> </span>        self.next_listener_id = 0

<span class="gd">-    def add(self, name: str) -&gt;None:</span>
<span class="gi">+    def add(self, name: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Register a custom Sphinx event.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if name in self.events:</span>
<span class="gi">+            raise ExtensionError(__(&#39;Event %r already present&#39;) % name)</span>
<span class="gi">+        self.events[name] = &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # ---- Core events -------------------------------------------------------</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;config-inited&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, Config], None],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;builder-inited&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx], None],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;env-get-outdated&#39;],</span>
<span class="gi">+        callback: Callable[</span>
<span class="gi">+            [Sphinx, BuildEnvironment, Set[str], Set[str], Set[str]], Sequence[str]</span>
<span class="gi">+        ],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;env-before-read-docs&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, BuildEnvironment, list[str]], None],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;env-purge-doc&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, BuildEnvironment, str], None],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;source-read&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, str, list[str]], None],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;include-read&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, Path, str, list[str]], None],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;doctree-read&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, nodes.document], None],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;env-merge-info&#39;],</span>
<span class="gi">+        callback: Callable[</span>
<span class="gi">+            [Sphinx, BuildEnvironment, list[str], BuildEnvironment], None</span>
<span class="gi">+        ],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;env-updated&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, BuildEnvironment], str],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;env-get-updated&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, BuildEnvironment], Iterable[str]],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;env-check-consistency&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, BuildEnvironment], None],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;write-started&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, Builder], None],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;doctree-resolved&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, nodes.document, str], None],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>

<span class="gd">-    def connect(self, name: str, callback: Callable, priority: int) -&gt;int:</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;missing-reference&#39;],</span>
<span class="gi">+        callback: Callable[</span>
<span class="gi">+            [Sphinx, BuildEnvironment, addnodes.pending_xref, nodes.TextElement],</span>
<span class="gi">+            nodes.reference | None,</span>
<span class="gi">+        ],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;warn-missing-reference&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, Domain, addnodes.pending_xref], bool | None],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;build-finished&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, Exception | None], None],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    # ---- Events from builtin builders --------------------------------------</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;html-collect-pages&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx], Iterable[tuple[str, dict[str, Any], str]]],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;html-page-context&#39;],</span>
<span class="gi">+        callback: Callable[</span>
<span class="gi">+            [Sphinx, str, str, dict[str, Any], nodes.document], str | None</span>
<span class="gi">+        ],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;linkcheck-process-uri&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, str], str | None],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    # ---- Events from builtin extensions-- ----------------------------------</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;object-description-transform&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, str, str, addnodes.desc_content], None],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    # ---- Events from first-party extensions --------------------------------</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;autodoc-process-docstring&#39;],</span>
<span class="gi">+        callback: Callable[</span>
<span class="gi">+            [</span>
<span class="gi">+                Sphinx,</span>
<span class="gi">+                Literal[</span>
<span class="gi">+                    &#39;module&#39;, &#39;class&#39;, &#39;exception&#39;, &#39;function&#39;, &#39;method&#39;, &#39;attribute&#39;</span>
<span class="gi">+                ],</span>
<span class="gi">+                str,</span>
<span class="gi">+                Any,</span>
<span class="gi">+                dict[str, bool],</span>
<span class="gi">+                Sequence[str],</span>
<span class="gi">+            ],</span>
<span class="gi">+            None,</span>
<span class="gi">+        ],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;autodoc-before-process-signature&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, Any, bool], None],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;autodoc-process-signature&#39;],</span>
<span class="gi">+        callback: Callable[</span>
<span class="gi">+            [</span>
<span class="gi">+                Sphinx,</span>
<span class="gi">+                Literal[</span>
<span class="gi">+                    &#39;module&#39;, &#39;class&#39;, &#39;exception&#39;, &#39;function&#39;, &#39;method&#39;, &#39;attribute&#39;</span>
<span class="gi">+                ],</span>
<span class="gi">+                str,</span>
<span class="gi">+                Any,</span>
<span class="gi">+                dict[str, bool],</span>
<span class="gi">+                str | None,</span>
<span class="gi">+                str | None,</span>
<span class="gi">+            ],</span>
<span class="gi">+            tuple[str | None, str | None] | None,</span>
<span class="gi">+        ],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;autodoc-process-bases&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, str, Any, dict[str, bool], list[str]], None],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;autodoc-skip-member&#39;],</span>
<span class="gi">+        callback: Callable[</span>
<span class="gi">+            [</span>
<span class="gi">+                Sphinx,</span>
<span class="gi">+                Literal[</span>
<span class="gi">+                    &#39;module&#39;, &#39;class&#39;, &#39;exception&#39;, &#39;function&#39;, &#39;method&#39;, &#39;attribute&#39;</span>
<span class="gi">+                ],</span>
<span class="gi">+                str,</span>
<span class="gi">+                Any,</span>
<span class="gi">+                bool,</span>
<span class="gi">+                dict[str, bool],</span>
<span class="gi">+            ],</span>
<span class="gi">+            bool,</span>
<span class="gi">+        ],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;todo-defined&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, todo_node], None],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;viewcode-find-source&#39;],</span>
<span class="gi">+        callback: Callable[</span>
<span class="gi">+            [Sphinx, str],</span>
<span class="gi">+            tuple[str, dict[str, tuple[Literal[&#39;class&#39;, &#39;def&#39;, &#39;other&#39;], int, int]]],</span>
<span class="gi">+        ],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: Literal[&#39;viewcode-follow-imported&#39;],</span>
<span class="gi">+        callback: Callable[[Sphinx, str, str], str | None],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    # ---- Catch-all ---------------------------------------------------------</span>
<span class="gi">+</span>
<span class="gi">+    @overload</span>
<span class="gi">+    def connect(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        callback: Callable[..., Any],</span>
<span class="gi">+        priority: int,</span>
<span class="gi">+    ) -&gt; int: ...</span>
<span class="gi">+</span>
<span class="gi">+    def connect(self, name: str, callback: Callable, priority: int) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Connect a handler to specific event.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if name not in self.events:</span>
<span class="gi">+            raise ExtensionError(__(&#39;Unknown event name: %s&#39;) % name)</span>

<span class="gd">-    def disconnect(self, listener_id: int) -&gt;None:</span>
<span class="gi">+        listener_id = self.next_listener_id</span>
<span class="gi">+        self.next_listener_id += 1</span>
<span class="gi">+        self.listeners[name].append(EventListener(listener_id, callback, priority))</span>
<span class="gi">+        return listener_id</span>
<span class="gi">+</span>
<span class="gi">+    def disconnect(self, listener_id: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Disconnect a handler.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for listeners in self.listeners.values():</span>
<span class="gi">+            for listener in listeners.copy():</span>
<span class="gi">+                if listener.id == listener_id:</span>
<span class="gi">+                    listeners.remove(listener)</span>

<span class="gd">-    def emit(self, name: str, *args: Any, allowed_exceptions: tuple[type[</span>
<span class="gd">-        Exception], ...]=()) -&gt;list:</span>
<span class="gi">+    def emit(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        *args: Any,</span>
<span class="gi">+        allowed_exceptions: tuple[type[Exception], ...] = (),</span>
<span class="gi">+    ) -&gt; list:</span>
<span class="w"> </span>        &quot;&quot;&quot;Emit a Sphinx event.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # not every object likes to be repr()&#39;d (think</span>
<span class="gi">+        # random stuff coming via autodoc)</span>
<span class="gi">+        try:</span>
<span class="gi">+            repr_args = repr(args)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            logger.debug(&#39;[app] emitting event: %r%s&#39;, name, repr_args)</span>
<span class="gi">+</span>
<span class="gi">+        results = []</span>
<span class="gi">+        listeners = sorted(self.listeners[name], key=attrgetter(&#39;priority&#39;))</span>
<span class="gi">+        for listener in listeners:</span>
<span class="gi">+            try:</span>
<span class="gi">+                results.append(listener.handler(self.app, *args))</span>
<span class="gi">+            except allowed_exceptions:</span>
<span class="gi">+                # pass through the errors specified as *allowed_exceptions*</span>
<span class="gi">+                raise</span>
<span class="gi">+            except SphinxError:</span>
<span class="gi">+                raise</span>
<span class="gi">+            except Exception as exc:</span>
<span class="gi">+                if self.app.pdb:</span>
<span class="gi">+                    # Just pass through the error, so that it can be debugged.</span>
<span class="gi">+                    raise</span>
<span class="gi">+                modname = safe_getattr(listener.handler, &#39;__module__&#39;, None)</span>
<span class="gi">+                raise ExtensionError(</span>
<span class="gi">+                    __(&#39;Handler %r for event %r threw an exception&#39;)</span>
<span class="gi">+                    % (listener.handler, name),</span>
<span class="gi">+                    exc,</span>
<span class="gi">+                    modname=modname,</span>
<span class="gi">+                ) from exc</span>
<span class="gi">+        return results</span>

<span class="gd">-    def emit_firstresult(self, name: str, *args: Any, allowed_exceptions:</span>
<span class="gd">-        tuple[type[Exception], ...]=()) -&gt;Any:</span>
<span class="gi">+    def emit_firstresult(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        *args: Any,</span>
<span class="gi">+        allowed_exceptions: tuple[type[Exception], ...] = (),</span>
<span class="gi">+    ) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Emit a Sphinx event and returns first result.

<span class="w"> </span>        This returns the result of the first handler that doesn&#39;t return ``None``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for result in self.emit(name, *args, allowed_exceptions=allowed_exceptions):</span>
<span class="gi">+            if result is not None:</span>
<span class="gi">+                return result</span>
<span class="gi">+        return None</span>
<span class="gh">diff --git a/sphinx/ext/apidoc.py b/sphinx/ext/apidoc.py</span>
<span class="gh">index 255a1c96b..e08c0b1e9 100644</span>
<span class="gd">--- a/sphinx/ext/apidoc.py</span>
<span class="gi">+++ b/sphinx/ext/apidoc.py</span>
<span class="gu">@@ -8,7 +8,9 @@ This is derived from the &quot;sphinx-autopackage&quot; script, which is:</span>
<span class="w"> </span>Copyright 2008 Socit des arts technologiques (SAT),
<span class="w"> </span>https://sat.qc.ca/
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import argparse
<span class="w"> </span>import fnmatch
<span class="w"> </span>import glob
<span class="gu">@@ -21,6 +23,7 @@ from importlib.machinery import EXTENSION_SUFFIXES</span>
<span class="w"> </span>from os import path
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Protocol
<span class="gi">+</span>
<span class="w"> </span>import sphinx.locale
<span class="w"> </span>from sphinx import __display_version__, package_dir
<span class="w"> </span>from sphinx.cmd.quickstart import EXTENSIONS
<span class="gu">@@ -28,109 +31,568 @@ from sphinx.locale import __</span>
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.osutil import FileAvoidWrite, ensuredir
<span class="w"> </span>from sphinx.util.template import ReSTRenderer
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Iterator, Sequence
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gi">+</span>
<span class="gi">+# automodule options</span>
<span class="w"> </span>if &#39;SPHINX_APIDOC_OPTIONS&#39; in os.environ:
<span class="w"> </span>    OPTIONS = os.environ[&#39;SPHINX_APIDOC_OPTIONS&#39;].split(&#39;,&#39;)
<span class="w"> </span>else:
<span class="gd">-    OPTIONS = [&#39;members&#39;, &#39;undoc-members&#39;, &#39;show-inheritance&#39;]</span>
<span class="gd">-PY_SUFFIXES = &#39;.py&#39;, &#39;.pyx&#39;, *tuple(EXTENSION_SUFFIXES)</span>
<span class="gi">+    OPTIONS = [</span>
<span class="gi">+        &#39;members&#39;,</span>
<span class="gi">+        &#39;undoc-members&#39;,</span>
<span class="gi">+        # &#39;inherited-members&#39;, # disabled because there&#39;s a bug in sphinx</span>
<span class="gi">+        &#39;show-inheritance&#39;,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+PY_SUFFIXES = (&#39;.py&#39;, &#39;.pyx&#39;, *tuple(EXTENSION_SUFFIXES))</span>
<span class="gi">+</span>
<span class="w"> </span>template_dir = path.join(package_dir, &#39;templates&#39;, &#39;apidoc&#39;)


<span class="gd">-def is_initpy(filename: (str | Path)) -&gt;bool:</span>
<span class="gi">+def is_initpy(filename: str | Path) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check *filename* is __init__ file or not.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    basename = Path(filename).name</span>
<span class="gi">+    return any(</span>
<span class="gi">+        basename == &#39;__init__&#39; + suffix</span>
<span class="gi">+        for suffix in sorted(PY_SUFFIXES, key=len, reverse=True)</span>
<span class="gi">+    )</span>


<span class="gd">-def module_join(*modnames: (str | None)) -&gt;str:</span>
<span class="gi">+def module_join(*modnames: str | None) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Join module names with dots.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return &#39;.&#39;.join(filter(None, modnames))</span>


<span class="gd">-def is_packagedir(dirname: (str | None)=None, files: (list[str] | None)=None</span>
<span class="gd">-    ) -&gt;bool:</span>
<span class="gi">+def is_packagedir(dirname: str | None = None, files: list[str] | None = None) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check given *files* contains __init__ file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    if files is dirname is None:</span>
<span class="gi">+        return False</span>

<span class="gd">-def write_file(name: str, text: str, opts: CliOptions) -&gt;Path:</span>
<span class="gd">-    &quot;&quot;&quot;Write the output file for module/package &lt;name&gt;.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    if files is None:</span>
<span class="gi">+        files = os.listdir(dirname)</span>
<span class="gi">+    return any(f for f in files if is_initpy(f))</span>


<span class="gd">-def create_module_file(package: (str | None), basename: str, opts:</span>
<span class="gd">-    CliOptions, user_template_dir: (str | None)=None) -&gt;Path:</span>
<span class="gi">+def write_file(name: str, text: str, opts: CliOptions) -&gt; Path:</span>
<span class="gi">+    &quot;&quot;&quot;Write the output file for module/package &lt;name&gt;.&quot;&quot;&quot;</span>
<span class="gi">+    fname = Path(opts.destdir, f&#39;{name}.{opts.suffix}&#39;)</span>
<span class="gi">+    if opts.dryrun:</span>
<span class="gi">+        if not opts.quiet:</span>
<span class="gi">+            logger.info(__(&#39;Would create file %s.&#39;), fname)</span>
<span class="gi">+        return fname</span>
<span class="gi">+    if not opts.force and fname.is_file():</span>
<span class="gi">+        if not opts.quiet:</span>
<span class="gi">+            logger.info(__(&#39;File %s already exists, skipping.&#39;), fname)</span>
<span class="gi">+    else:</span>
<span class="gi">+        if not opts.quiet:</span>
<span class="gi">+            logger.info(__(&#39;Creating file %s.&#39;), fname)</span>
<span class="gi">+        with FileAvoidWrite(fname) as f:</span>
<span class="gi">+            f.write(text)</span>
<span class="gi">+    return fname</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def create_module_file(</span>
<span class="gi">+    package: str | None,</span>
<span class="gi">+    basename: str,</span>
<span class="gi">+    opts: CliOptions,</span>
<span class="gi">+    user_template_dir: str | None = None,</span>
<span class="gi">+) -&gt; Path:</span>
<span class="w"> </span>    &quot;&quot;&quot;Build the text of the file and write the file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def create_package_file(root: str, master_package: (str | None), subroot:</span>
<span class="gd">-    str, py_files: list[str], opts: CliOptions, subs: list[str],</span>
<span class="gd">-    is_namespace: bool, excludes: Sequence[re.Pattern[str]]=(),</span>
<span class="gd">-    user_template_dir: (str | None)=None) -&gt;list[Path]:</span>
<span class="gi">+    options = copy(OPTIONS)</span>
<span class="gi">+    if opts.includeprivate and &#39;private-members&#39; not in options:</span>
<span class="gi">+        options.append(&#39;private-members&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    qualname = module_join(package, basename)</span>
<span class="gi">+    context = {</span>
<span class="gi">+        &#39;show_headings&#39;: not opts.noheadings,</span>
<span class="gi">+        &#39;basename&#39;: basename,</span>
<span class="gi">+        &#39;qualname&#39;: qualname,</span>
<span class="gi">+        &#39;automodule_options&#39;: options,</span>
<span class="gi">+    }</span>
<span class="gi">+    if user_template_dir is not None:</span>
<span class="gi">+        template_path = [user_template_dir, template_dir]</span>
<span class="gi">+    else:</span>
<span class="gi">+        template_path = [template_dir]</span>
<span class="gi">+    text = ReSTRenderer(template_path).render(&#39;module.rst.jinja&#39;, context)</span>
<span class="gi">+    return write_file(qualname, text, opts)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def create_package_file(</span>
<span class="gi">+    root: str,</span>
<span class="gi">+    master_package: str | None,</span>
<span class="gi">+    subroot: str,</span>
<span class="gi">+    py_files: list[str],</span>
<span class="gi">+    opts: CliOptions,</span>
<span class="gi">+    subs: list[str],</span>
<span class="gi">+    is_namespace: bool,</span>
<span class="gi">+    excludes: Sequence[re.Pattern[str]] = (),</span>
<span class="gi">+    user_template_dir: str | None = None,</span>
<span class="gi">+) -&gt; list[Path]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Build the text of the file and write the file.

<span class="w"> </span>    Also create submodules if necessary.

<span class="w"> </span>    :returns: list of written files
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def create_modules_toc_file(modules: list[str], opts: CliOptions, name: str</span>
<span class="gd">-    =&#39;modules&#39;, user_template_dir: (str | None)=None) -&gt;Path:</span>
<span class="gi">+    # build a list of sub packages (directories containing an __init__ file)</span>
<span class="gi">+    subpackages = [</span>
<span class="gi">+        module_join(master_package, subroot, pkgname)</span>
<span class="gi">+        for pkgname in subs</span>
<span class="gi">+        if not is_skipped_package(Path(root, pkgname), opts, excludes)</span>
<span class="gi">+    ]</span>
<span class="gi">+    # build a list of sub modules</span>
<span class="gi">+    submodules = [</span>
<span class="gi">+        sub.split(&#39;.&#39;)[0]</span>
<span class="gi">+        for sub in py_files</span>
<span class="gi">+        if not is_skipped_module(Path(root, sub), opts, excludes) and not is_initpy(sub)</span>
<span class="gi">+    ]</span>
<span class="gi">+    submodules = sorted(set(submodules))</span>
<span class="gi">+    submodules = [</span>
<span class="gi">+        module_join(master_package, subroot, modname) for modname in submodules</span>
<span class="gi">+    ]</span>
<span class="gi">+    options = copy(OPTIONS)</span>
<span class="gi">+    if opts.includeprivate and &#39;private-members&#39; not in options:</span>
<span class="gi">+        options.append(&#39;private-members&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    pkgname = module_join(master_package, subroot)</span>
<span class="gi">+    context = {</span>
<span class="gi">+        &#39;pkgname&#39;: pkgname,</span>
<span class="gi">+        &#39;subpackages&#39;: subpackages,</span>
<span class="gi">+        &#39;submodules&#39;: submodules,</span>
<span class="gi">+        &#39;is_namespace&#39;: is_namespace,</span>
<span class="gi">+        &#39;modulefirst&#39;: opts.modulefirst,</span>
<span class="gi">+        &#39;separatemodules&#39;: opts.separatemodules,</span>
<span class="gi">+        &#39;automodule_options&#39;: options,</span>
<span class="gi">+        &#39;show_headings&#39;: not opts.noheadings,</span>
<span class="gi">+        &#39;maxdepth&#39;: opts.maxdepth,</span>
<span class="gi">+    }</span>
<span class="gi">+    if user_template_dir is not None:</span>
<span class="gi">+        template_path = [user_template_dir, template_dir]</span>
<span class="gi">+    else:</span>
<span class="gi">+        template_path = [template_dir]</span>
<span class="gi">+</span>
<span class="gi">+    written: list[Path] = []</span>
<span class="gi">+</span>
<span class="gi">+    text = ReSTRenderer(template_path).render(&#39;package.rst.jinja&#39;, context)</span>
<span class="gi">+    written.append(write_file(pkgname, text, opts))</span>
<span class="gi">+</span>
<span class="gi">+    if submodules and opts.separatemodules:</span>
<span class="gi">+        written.extend([</span>
<span class="gi">+            create_module_file(None, submodule, opts, user_template_dir)</span>
<span class="gi">+            for submodule in submodules</span>
<span class="gi">+        ])</span>
<span class="gi">+</span>
<span class="gi">+    return written</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def create_modules_toc_file(</span>
<span class="gi">+    modules: list[str],</span>
<span class="gi">+    opts: CliOptions,</span>
<span class="gi">+    name: str = &#39;modules&#39;,</span>
<span class="gi">+    user_template_dir: str | None = None,</span>
<span class="gi">+) -&gt; Path:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create the module&#39;s index.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def is_skipped_package(dirname: (str | Path), opts: CliOptions, excludes:</span>
<span class="gd">-    Sequence[re.Pattern[str]]=()) -&gt;bool:</span>
<span class="gi">+    modules.sort()</span>
<span class="gi">+    prev_module = &#39;&#39;</span>
<span class="gi">+    for module in modules.copy():</span>
<span class="gi">+        # look if the module is a subpackage and, if yes, ignore it</span>
<span class="gi">+        if module.startswith(prev_module + &#39;.&#39;):</span>
<span class="gi">+            modules.remove(module)</span>
<span class="gi">+        else:</span>
<span class="gi">+            prev_module = module</span>
<span class="gi">+</span>
<span class="gi">+    context = {</span>
<span class="gi">+        &#39;header&#39;: opts.header,</span>
<span class="gi">+        &#39;maxdepth&#39;: opts.maxdepth,</span>
<span class="gi">+        &#39;docnames&#39;: modules,</span>
<span class="gi">+    }</span>
<span class="gi">+    if user_template_dir is not None:</span>
<span class="gi">+        template_path = [user_template_dir, template_dir]</span>
<span class="gi">+    else:</span>
<span class="gi">+        template_path = [template_dir]</span>
<span class="gi">+    text = ReSTRenderer(template_path).render(&#39;toc.rst.jinja&#39;, context)</span>
<span class="gi">+    return write_file(name, text, opts)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_skipped_package(</span>
<span class="gi">+    dirname: str | Path, opts: CliOptions, excludes: Sequence[re.Pattern[str]] = ()</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if we want to skip this module.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not Path(dirname).is_dir():</span>
<span class="gi">+        return False</span>

<span class="gi">+    files = glob.glob(str(Path(dirname, &#39;*.py&#39;)))</span>
<span class="gi">+    regular_package = any(f for f in files if is_initpy(f))</span>
<span class="gi">+    if not regular_package and not opts.implicit_namespaces:</span>
<span class="gi">+        # *dirname* is not both a regular package and an implicit namespace package</span>
<span class="gi">+        return True</span>

<span class="gd">-def is_skipped_module(filename: (str | Path), opts: CliOptions, _excludes:</span>
<span class="gd">-    Sequence[re.Pattern[str]]) -&gt;bool:</span>
<span class="gd">-    &quot;&quot;&quot;Check if we want to skip this module.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    # Check there is some showable module inside package</span>
<span class="gi">+    return all(is_excluded(Path(dirname, f), excludes) for f in files)</span>


<span class="gd">-def walk(rootpath: str, excludes: Sequence[re.Pattern[str]], opts: CliOptions</span>
<span class="gd">-    ) -&gt;Iterator[tuple[str, list[str], list[str]]]:</span>
<span class="gi">+def is_skipped_module(</span>
<span class="gi">+    filename: str | Path, opts: CliOptions, _excludes: Sequence[re.Pattern[str]]</span>
<span class="gi">+) -&gt; bool:</span>
<span class="gi">+    &quot;&quot;&quot;Check if we want to skip this module.&quot;&quot;&quot;</span>
<span class="gi">+    filename = Path(filename)</span>
<span class="gi">+    if not filename.exists():</span>
<span class="gi">+        # skip if the file doesn&#39;t exist</span>
<span class="gi">+        return True</span>
<span class="gi">+    # skip if the module has a &quot;private&quot; name</span>
<span class="gi">+    return filename.name.startswith(&#39;_&#39;) and not opts.includeprivate</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def walk(</span>
<span class="gi">+    rootpath: str,</span>
<span class="gi">+    excludes: Sequence[re.Pattern[str]],</span>
<span class="gi">+    opts: CliOptions,</span>
<span class="gi">+) -&gt; Iterator[tuple[str, list[str], list[str]]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Walk through the directory and list files and subdirectories up.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def has_child_module(rootpath: str, excludes: Sequence[re.Pattern[str]],</span>
<span class="gd">-    opts: CliOptions) -&gt;bool:</span>
<span class="gi">+    for root, subs, files in os.walk(rootpath, followlinks=opts.followlinks):</span>
<span class="gi">+        # document only Python module files (that aren&#39;t excluded)</span>
<span class="gi">+        files = sorted(</span>
<span class="gi">+            f</span>
<span class="gi">+            for f in files</span>
<span class="gi">+            if f.endswith(PY_SUFFIXES) and not is_excluded(Path(root, f), excludes)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # remove hidden (&#39;.&#39;) and private (&#39;_&#39;) directories, as well as</span>
<span class="gi">+        # excluded dirs</span>
<span class="gi">+        if opts.includeprivate:</span>
<span class="gi">+            exclude_prefixes: tuple[str, ...] = (&#39;.&#39;,)</span>
<span class="gi">+        else:</span>
<span class="gi">+            exclude_prefixes = (&#39;.&#39;, &#39;_&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        subs[:] = sorted(</span>
<span class="gi">+            sub</span>
<span class="gi">+            for sub in subs</span>
<span class="gi">+            if not sub.startswith(exclude_prefixes)</span>
<span class="gi">+            and not is_excluded(Path(root, sub), excludes)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        yield root, subs, files</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def has_child_module(</span>
<span class="gi">+    rootpath: str, excludes: Sequence[re.Pattern[str]], opts: CliOptions</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check the given directory contains child module/s (at least one).&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return any(files for _root, _subs, files in walk(rootpath, excludes, opts))</span>


<span class="gd">-def recurse_tree(rootpath: str, excludes: Sequence[re.Pattern[str]], opts:</span>
<span class="gd">-    CliOptions, user_template_dir: (str | None)=None) -&gt;tuple[list[Path],</span>
<span class="gd">-    list[str]]:</span>
<span class="gi">+def recurse_tree(</span>
<span class="gi">+    rootpath: str,</span>
<span class="gi">+    excludes: Sequence[re.Pattern[str]],</span>
<span class="gi">+    opts: CliOptions,</span>
<span class="gi">+    user_template_dir: str | None = None,</span>
<span class="gi">+) -&gt; tuple[list[Path], list[str]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Look for every file in the directory tree and create the corresponding
<span class="w"> </span>    ReST files.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def is_excluded(root: (str | Path), excludes: Sequence[re.Pattern[str]]</span>
<span class="gd">-    ) -&gt;bool:</span>
<span class="gi">+    # check if the base directory is a package and get its name</span>
<span class="gi">+    if is_packagedir(rootpath) or opts.implicit_namespaces:</span>
<span class="gi">+        root_package = rootpath.split(path.sep)[-1]</span>
<span class="gi">+    else:</span>
<span class="gi">+        # otherwise, the base is a directory with packages</span>
<span class="gi">+        root_package = None</span>
<span class="gi">+</span>
<span class="gi">+    toplevels = []</span>
<span class="gi">+    written_files = []</span>
<span class="gi">+    for root, subs, files in walk(rootpath, excludes, opts):</span>
<span class="gi">+        is_pkg = is_packagedir(None, files)</span>
<span class="gi">+        is_namespace = not is_pkg and opts.implicit_namespaces</span>
<span class="gi">+        if is_pkg:</span>
<span class="gi">+            for f in files.copy():</span>
<span class="gi">+                if is_initpy(f):</span>
<span class="gi">+                    files.remove(f)</span>
<span class="gi">+                    files.insert(0, f)</span>
<span class="gi">+        elif root != rootpath:</span>
<span class="gi">+            # only accept non-package at toplevel unless using implicit namespaces</span>
<span class="gi">+            if not opts.implicit_namespaces:</span>
<span class="gi">+                subs.clear()</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+        if is_pkg or is_namespace:</span>
<span class="gi">+            # we are in a package with something to document</span>
<span class="gi">+            if subs or len(files) &gt; 1 or not is_skipped_package(root, opts):</span>
<span class="gi">+                subpackage = (</span>
<span class="gi">+                    root[len(rootpath) :].lstrip(path.sep).replace(path.sep, &#39;.&#39;)</span>
<span class="gi">+                )</span>
<span class="gi">+                # if this is not a namespace or</span>
<span class="gi">+                # a namespace and there is something there to document</span>
<span class="gi">+                if not is_namespace or has_child_module(root, excludes, opts):</span>
<span class="gi">+                    written_files.extend(</span>
<span class="gi">+                        create_package_file(</span>
<span class="gi">+                            root,</span>
<span class="gi">+                            root_package,</span>
<span class="gi">+                            subpackage,</span>
<span class="gi">+                            files,</span>
<span class="gi">+                            opts,</span>
<span class="gi">+                            subs,</span>
<span class="gi">+                            is_namespace,</span>
<span class="gi">+                            excludes,</span>
<span class="gi">+                            user_template_dir,</span>
<span class="gi">+                        )</span>
<span class="gi">+                    )</span>
<span class="gi">+                    toplevels.append(module_join(root_package, subpackage))</span>
<span class="gi">+        else:</span>
<span class="gi">+            # if we are at the root level, we don&#39;t require it to be a package</span>
<span class="gi">+            assert root == rootpath</span>
<span class="gi">+            assert root_package is None</span>
<span class="gi">+            for py_file in files:</span>
<span class="gi">+                if not is_skipped_module(Path(rootpath, py_file), opts, excludes):</span>
<span class="gi">+                    module = py_file.split(&#39;.&#39;)[0]</span>
<span class="gi">+                    written_files.append(</span>
<span class="gi">+                        create_module_file(</span>
<span class="gi">+                            root_package, module, opts, user_template_dir</span>
<span class="gi">+                        )</span>
<span class="gi">+                    )</span>
<span class="gi">+                    toplevels.append(module)</span>
<span class="gi">+</span>
<span class="gi">+    return written_files, toplevels</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_excluded(root: str | Path, excludes: Sequence[re.Pattern[str]]) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the directory is in the exclude list.

<span class="w"> </span>    Note: by having trailing slashes, we avoid common prefix issues, like
<span class="w"> </span>          e.g. an exclude &quot;foo&quot; also accidentally excluding &quot;foobar&quot;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    root_str = str(root)</span>
<span class="gi">+    return any(exclude.match(root_str) for exclude in excludes)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_parser() -&gt; argparse.ArgumentParser:</span>
<span class="gi">+    parser = argparse.ArgumentParser(</span>
<span class="gi">+        usage=&#39;%(prog)s [OPTIONS] -o &lt;OUTPUT_PATH&gt; &lt;MODULE_PATH&gt; [EXCLUDE_PATTERN, ...]&#39;,</span>
<span class="gi">+        epilog=__(&#39;For more information, visit &lt;https://www.sphinx-doc.org/&gt;.&#39;),</span>
<span class="gi">+        description=__(&quot;&quot;&quot;</span>
<span class="gi">+Look recursively in &lt;MODULE_PATH&gt; for Python modules and packages and create</span>
<span class="gi">+one reST file with automodule directives per package in the &lt;OUTPUT_PATH&gt;.</span>
<span class="gi">+</span>
<span class="gi">+The &lt;EXCLUDE_PATTERN&gt;s can be file and/or directory patterns that will be</span>
<span class="gi">+excluded from generation.</span>
<span class="gi">+</span>
<span class="gi">+Note: By default this script will not overwrite already created files.&quot;&quot;&quot;),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;--version&#39;,</span>
<span class="gi">+        action=&#39;version&#39;,</span>
<span class="gi">+        dest=&#39;show_version&#39;,</span>
<span class="gi">+        version=&#39;%%(prog)s %s&#39; % __display_version__,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    parser.add_argument(&#39;module_path&#39;, help=__(&#39;path to module to document&#39;))</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;exclude_pattern&#39;,</span>
<span class="gi">+        nargs=&#39;*&#39;,</span>
<span class="gi">+        help=__(</span>
<span class="gi">+            &#39;fnmatch-style file and/or directory patterns to exclude from generation&#39;</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;-o&#39;,</span>
<span class="gi">+        &#39;--output-dir&#39;,</span>
<span class="gi">+        action=&#39;store&#39;,</span>
<span class="gi">+        dest=&#39;destdir&#39;,</span>
<span class="gi">+        required=True,</span>
<span class="gi">+        help=__(&#39;directory to place all output&#39;),</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;-q&#39;,</span>
<span class="gi">+        action=&#39;store_true&#39;,</span>
<span class="gi">+        dest=&#39;quiet&#39;,</span>
<span class="gi">+        help=__(&#39;no output on stdout, just warnings on stderr&#39;),</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;-d&#39;,</span>
<span class="gi">+        &#39;--maxdepth&#39;,</span>
<span class="gi">+        action=&#39;store&#39;,</span>
<span class="gi">+        dest=&#39;maxdepth&#39;,</span>
<span class="gi">+        type=int,</span>
<span class="gi">+        default=4,</span>
<span class="gi">+        help=__(&#39;maximum depth of submodules to show in the TOC (default: 4)&#39;),</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;-f&#39;,</span>
<span class="gi">+        &#39;--force&#39;,</span>
<span class="gi">+        action=&#39;store_true&#39;,</span>
<span class="gi">+        dest=&#39;force&#39;,</span>
<span class="gi">+        help=__(&#39;overwrite existing files&#39;),</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;-l&#39;,</span>
<span class="gi">+        &#39;--follow-links&#39;,</span>
<span class="gi">+        action=&#39;store_true&#39;,</span>
<span class="gi">+        dest=&#39;followlinks&#39;,</span>
<span class="gi">+        default=False,</span>
<span class="gi">+        help=__(</span>
<span class="gi">+            &#39;follow symbolic links. Powerful when combined with collective.recipe.omelette.&#39;</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;-n&#39;,</span>
<span class="gi">+        &#39;--dry-run&#39;,</span>
<span class="gi">+        action=&#39;store_true&#39;,</span>
<span class="gi">+        dest=&#39;dryrun&#39;,</span>
<span class="gi">+        help=__(&#39;run the script without creating files&#39;),</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;-e&#39;,</span>
<span class="gi">+        &#39;--separate&#39;,</span>
<span class="gi">+        action=&#39;store_true&#39;,</span>
<span class="gi">+        dest=&#39;separatemodules&#39;,</span>
<span class="gi">+        help=__(&#39;put documentation for each module on its own page&#39;),</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;-P&#39;,</span>
<span class="gi">+        &#39;--private&#39;,</span>
<span class="gi">+        action=&#39;store_true&#39;,</span>
<span class="gi">+        dest=&#39;includeprivate&#39;,</span>
<span class="gi">+        help=__(&#39;include &quot;_private&quot; modules&#39;),</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;--tocfile&#39;,</span>
<span class="gi">+        action=&#39;store&#39;,</span>
<span class="gi">+        dest=&#39;tocfile&#39;,</span>
<span class="gi">+        default=&#39;modules&#39;,</span>
<span class="gi">+        help=__(&#39;filename of table of contents (default: modules)&#39;),</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;-T&#39;,</span>
<span class="gi">+        &#39;--no-toc&#39;,</span>
<span class="gi">+        action=&#39;store_false&#39;,</span>
<span class="gi">+        dest=&#39;tocfile&#39;,</span>
<span class="gi">+        help=__(&quot;don&#39;t create a table of contents file&quot;),</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;-E&#39;,</span>
<span class="gi">+        &#39;--no-headings&#39;,</span>
<span class="gi">+        action=&#39;store_true&#39;,</span>
<span class="gi">+        dest=&#39;noheadings&#39;,</span>
<span class="gi">+        help=__(</span>
<span class="gi">+            &quot;don&#39;t create headings for the module/package &quot;</span>
<span class="gi">+            &#39;packages (e.g. when the docstrings already &#39;</span>
<span class="gi">+            &#39;contain them)&#39;</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;-M&#39;,</span>
<span class="gi">+        &#39;--module-first&#39;,</span>
<span class="gi">+        action=&#39;store_true&#39;,</span>
<span class="gi">+        dest=&#39;modulefirst&#39;,</span>
<span class="gi">+        help=__(&#39;put module documentation before submodule documentation&#39;),</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;--implicit-namespaces&#39;,</span>
<span class="gi">+        action=&#39;store_true&#39;,</span>
<span class="gi">+        dest=&#39;implicit_namespaces&#39;,</span>
<span class="gi">+        help=__(</span>
<span class="gi">+            &#39;interpret module paths according to PEP-0420 implicit namespaces specification&#39;</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;-s&#39;,</span>
<span class="gi">+        &#39;--suffix&#39;,</span>
<span class="gi">+        action=&#39;store&#39;,</span>
<span class="gi">+        dest=&#39;suffix&#39;,</span>
<span class="gi">+        default=&#39;rst&#39;,</span>
<span class="gi">+        help=__(&#39;file suffix (default: rst)&#39;),</span>
<span class="gi">+    )</span>
<span class="gi">+    exclusive_group = parser.add_mutually_exclusive_group()</span>
<span class="gi">+    exclusive_group.add_argument(</span>
<span class="gi">+        &#39;--remove-old&#39;,</span>
<span class="gi">+        action=&#39;store_true&#39;,</span>
<span class="gi">+        dest=&#39;remove_old&#39;,</span>
<span class="gi">+        help=__(</span>
<span class="gi">+            &#39;Remove existing files in the output directory that were not generated&#39;</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+    exclusive_group.add_argument(</span>
<span class="gi">+        &#39;-F&#39;,</span>
<span class="gi">+        &#39;--full&#39;,</span>
<span class="gi">+        action=&#39;store_true&#39;,</span>
<span class="gi">+        dest=&#39;full&#39;,</span>
<span class="gi">+        help=__(&#39;generate a full project with sphinx-quickstart&#39;),</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;-a&#39;,</span>
<span class="gi">+        &#39;--append-syspath&#39;,</span>
<span class="gi">+        action=&#39;store_true&#39;,</span>
<span class="gi">+        dest=&#39;append_syspath&#39;,</span>
<span class="gi">+        help=__(&#39;append module_path to sys.path, used when --full is given&#39;),</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;-H&#39;,</span>
<span class="gi">+        &#39;--doc-project&#39;,</span>
<span class="gi">+        action=&#39;store&#39;,</span>
<span class="gi">+        dest=&#39;header&#39;,</span>
<span class="gi">+        help=__(&#39;project name (default: root module name)&#39;),</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;-A&#39;,</span>
<span class="gi">+        &#39;--doc-author&#39;,</span>
<span class="gi">+        action=&#39;store&#39;,</span>
<span class="gi">+        dest=&#39;author&#39;,</span>
<span class="gi">+        help=__(&#39;project author(s), used when --full is given&#39;),</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;-V&#39;,</span>
<span class="gi">+        &#39;--doc-version&#39;,</span>
<span class="gi">+        action=&#39;store&#39;,</span>
<span class="gi">+        dest=&#39;version&#39;,</span>
<span class="gi">+        help=__(&#39;project version, used when --full is given&#39;),</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;-R&#39;,</span>
<span class="gi">+        &#39;--doc-release&#39;,</span>
<span class="gi">+        action=&#39;store&#39;,</span>
<span class="gi">+        dest=&#39;release&#39;,</span>
<span class="gi">+        help=__(</span>
<span class="gi">+            &#39;project release, used when --full is given, defaults to --doc-version&#39;</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    group = parser.add_argument_group(__(&#39;extension options&#39;))</span>
<span class="gi">+    group.add_argument(</span>
<span class="gi">+        &#39;--extensions&#39;,</span>
<span class="gi">+        metavar=&#39;EXTENSIONS&#39;,</span>
<span class="gi">+        dest=&#39;extensions&#39;,</span>
<span class="gi">+        action=&#39;append&#39;,</span>
<span class="gi">+        help=__(&#39;enable arbitrary extensions&#39;),</span>
<span class="gi">+    )</span>
<span class="gi">+    for ext in EXTENSIONS:</span>
<span class="gi">+        group.add_argument(</span>
<span class="gi">+            &#39;--ext-%s&#39; % ext,</span>
<span class="gi">+            action=&#39;append_const&#39;,</span>
<span class="gi">+            const=&#39;sphinx.ext.%s&#39; % ext,</span>
<span class="gi">+            dest=&#39;extensions&#39;,</span>
<span class="gi">+            help=__(&#39;enable %s extension&#39;) % ext,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    group = parser.add_argument_group(__(&#39;Project templating&#39;))</span>
<span class="gi">+    group.add_argument(</span>
<span class="gi">+        &#39;-t&#39;,</span>
<span class="gi">+        &#39;--templatedir&#39;,</span>
<span class="gi">+        metavar=&#39;TEMPLATEDIR&#39;,</span>
<span class="gi">+        dest=&#39;templatedir&#39;,</span>
<span class="gi">+        help=__(&#39;template directory for template files&#39;),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return parser</span>


<span class="w"> </span>class CliOptions(Protocol):
<span class="w"> </span>    &quot;&quot;&quot;Arguments parsed from the command line.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    module_path: str
<span class="w"> </span>    exclude_pattern: list[str]
<span class="w"> </span>    destdir: str
<span class="gu">@@ -157,10 +619,104 @@ class CliOptions(Protocol):</span>
<span class="w"> </span>    remove_old: bool


<span class="gd">-def main(argv: Sequence[str]=(), /) -&gt;int:</span>
<span class="gi">+def main(argv: Sequence[str] = (), /) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse and check the command line arguments.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+    locale.setlocale(locale.LC_ALL, &#39;&#39;)</span>
<span class="gi">+    sphinx.locale.init_console()</span>
<span class="gi">+</span>
<span class="gi">+    parser = get_parser()</span>
<span class="gi">+    args: CliOptions = parser.parse_args(argv or sys.argv[1:])</span>
<span class="gi">+</span>
<span class="gi">+    rootpath = path.abspath(args.module_path)</span>
<span class="gi">+</span>
<span class="gi">+    # normalize opts</span>
<span class="gi">+</span>
<span class="gi">+    if args.header is None:</span>
<span class="gi">+        args.header = rootpath.split(path.sep)[-1]</span>
<span class="gi">+    if args.suffix.startswith(&#39;.&#39;):</span>
<span class="gi">+        args.suffix = args.suffix[1:]</span>
<span class="gi">+    if not Path(rootpath).is_dir():</span>
<span class="gi">+        logger.error(__(&#39;%s is not a directory.&#39;), rootpath)</span>
<span class="gi">+        raise SystemExit(1)</span>
<span class="gi">+    if not args.dryrun:</span>
<span class="gi">+        ensuredir(args.destdir)</span>
<span class="gi">+    excludes = tuple(</span>
<span class="gi">+        re.compile(fnmatch.translate(path.abspath(exclude)))</span>
<span class="gi">+        for exclude in dict.fromkeys(args.exclude_pattern)</span>
<span class="gi">+    )</span>
<span class="gi">+    written_files, modules = recurse_tree(rootpath, excludes, args, args.templatedir)</span>
<span class="gi">+</span>
<span class="gi">+    if args.full:</span>
<span class="gi">+        from sphinx.cmd import quickstart as qs</span>
<span class="gi">+</span>
<span class="gi">+        modules.sort()</span>
<span class="gi">+        prev_module = &#39;&#39;</span>
<span class="gi">+        text = &#39;&#39;</span>
<span class="gi">+        for module in modules:</span>
<span class="gi">+            if module.startswith(prev_module + &#39;.&#39;):</span>
<span class="gi">+                continue</span>
<span class="gi">+            prev_module = module</span>
<span class="gi">+            text += &#39;   %s\n&#39; % module</span>
<span class="gi">+        d: dict[str, Any] = {</span>
<span class="gi">+            &#39;path&#39;: args.destdir,</span>
<span class="gi">+            &#39;sep&#39;: False,</span>
<span class="gi">+            &#39;dot&#39;: &#39;_&#39;,</span>
<span class="gi">+            &#39;project&#39;: args.header,</span>
<span class="gi">+            &#39;author&#39;: args.author or &#39;Author&#39;,</span>
<span class="gi">+            &#39;version&#39;: args.version or &#39;&#39;,</span>
<span class="gi">+            &#39;release&#39;: args.release or args.version or &#39;&#39;,</span>
<span class="gi">+            &#39;suffix&#39;: &#39;.&#39; + args.suffix,</span>
<span class="gi">+            &#39;master&#39;: &#39;index&#39;,</span>
<span class="gi">+            &#39;epub&#39;: True,</span>
<span class="gi">+            &#39;extensions&#39;: [</span>
<span class="gi">+                &#39;sphinx.ext.autodoc&#39;,</span>
<span class="gi">+                &#39;sphinx.ext.viewcode&#39;,</span>
<span class="gi">+                &#39;sphinx.ext.todo&#39;,</span>
<span class="gi">+            ],</span>
<span class="gi">+            &#39;makefile&#39;: True,</span>
<span class="gi">+            &#39;batchfile&#39;: True,</span>
<span class="gi">+            &#39;make_mode&#39;: True,</span>
<span class="gi">+            &#39;mastertocmaxdepth&#39;: args.maxdepth,</span>
<span class="gi">+            &#39;mastertoctree&#39;: text,</span>
<span class="gi">+            &#39;language&#39;: &#39;en&#39;,</span>
<span class="gi">+            &#39;module_path&#39;: rootpath,</span>
<span class="gi">+            &#39;append_syspath&#39;: args.append_syspath,</span>
<span class="gi">+        }</span>
<span class="gi">+        if args.extensions:</span>
<span class="gi">+            d[&#39;extensions&#39;].extend(args.extensions)</span>
<span class="gi">+        if args.quiet:</span>
<span class="gi">+            d[&#39;quiet&#39;] = True</span>
<span class="gi">+</span>
<span class="gi">+        for ext in d[&#39;extensions&#39;][:]:</span>
<span class="gi">+            if &#39;,&#39; in ext:</span>
<span class="gi">+                d[&#39;extensions&#39;].remove(ext)</span>
<span class="gi">+                d[&#39;extensions&#39;].extend(ext.split(&#39;,&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        if not args.dryrun:</span>
<span class="gi">+            qs.generate(</span>
<span class="gi">+                d, silent=True, overwrite=args.force, templatedir=args.templatedir</span>
<span class="gi">+            )</span>
<span class="gi">+    elif args.tocfile:</span>
<span class="gi">+        written_files.append(</span>
<span class="gi">+            create_modules_toc_file(modules, args, args.tocfile, args.templatedir)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if args.remove_old and not args.dryrun:</span>
<span class="gi">+        for existing in Path(args.destdir).glob(f&#39;**/*.{args.suffix}&#39;):</span>
<span class="gi">+            if existing not in written_files:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    existing.unlink()</span>
<span class="gi">+                except OSError as exc:</span>
<span class="gi">+                    logger.warning(</span>
<span class="gi">+                        __(&#39;Failed to remove %s: %s&#39;),</span>
<span class="gi">+                        existing,</span>
<span class="gi">+                        exc.strerror,</span>
<span class="gi">+                        type=&#39;autodoc&#39;,</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+    return 0</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# So program can be started with &quot;python -m sphinx.apidoc ...&quot;</span>
<span class="w"> </span>if __name__ == &#39;__main__&#39;:
<span class="w"> </span>    raise SystemExit(main(sys.argv[1:]))
<span class="gh">diff --git a/sphinx/ext/autodoc/directive.py b/sphinx/ext/autodoc/directive.py</span>
<span class="gh">index cbc59b16f..66b42a67d 100644</span>
<span class="gd">--- a/sphinx/ext/autodoc/directive.py</span>
<span class="gi">+++ b/sphinx/ext/autodoc/directive.py</span>
<span class="gu">@@ -1,43 +1,53 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from collections.abc import Callable
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.statemachine import StringList
<span class="w"> </span>from docutils.utils import Reporter, assemble_option_dict
<span class="gi">+</span>
<span class="w"> </span>from sphinx.ext.autodoc import Documenter, Options
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.docutils import SphinxDirective, switch_source_input
<span class="w"> </span>from sphinx.util.parsing import nested_parse_to_nodes
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.nodes import Node
<span class="w"> </span>    from docutils.parsers.rst.states import RSTState
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.config import Config
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# common option names for autodoc directives</span>
<span class="w"> </span>AUTODOC_DEFAULT_OPTIONS = [&#39;members&#39;, &#39;undoc-members&#39;, &#39;inherited-members&#39;,
<span class="gd">-    &#39;show-inheritance&#39;, &#39;private-members&#39;, &#39;special-members&#39;,</span>
<span class="gd">-    &#39;ignore-module-all&#39;, &#39;exclude-members&#39;, &#39;member-order&#39;,</span>
<span class="gd">-    &#39;imported-members&#39;, &#39;class-doc-from&#39;, &#39;no-value&#39;]</span>
<span class="gd">-AUTODOC_EXTENDABLE_OPTIONS = [&#39;members&#39;, &#39;private-members&#39;,</span>
<span class="gd">-    &#39;special-members&#39;, &#39;exclude-members&#39;]</span>
<span class="gi">+                           &#39;show-inheritance&#39;, &#39;private-members&#39;, &#39;special-members&#39;,</span>
<span class="gi">+                           &#39;ignore-module-all&#39;, &#39;exclude-members&#39;, &#39;member-order&#39;,</span>
<span class="gi">+                           &#39;imported-members&#39;, &#39;class-doc-from&#39;, &#39;no-value&#39;]</span>
<span class="gi">+</span>
<span class="gi">+AUTODOC_EXTENDABLE_OPTIONS = [&#39;members&#39;, &#39;private-members&#39;, &#39;special-members&#39;,</span>
<span class="gi">+                              &#39;exclude-members&#39;]</span>


<span class="w"> </span>class DummyOptionSpec(dict[str, Callable[[str], str]]):
<span class="w"> </span>    &quot;&quot;&quot;An option_spec allows any options.&quot;&quot;&quot;

<span class="gd">-    def __bool__(self) -&gt;bool:</span>
<span class="gi">+    def __bool__(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Behaves like some options are defined.&quot;&quot;&quot;
<span class="w"> </span>        return True

<span class="gd">-    def __getitem__(self, _key: str) -&gt;Callable[[str], str]:</span>
<span class="gi">+    def __getitem__(self, _key: str) -&gt; Callable[[str], str]:</span>
<span class="w"> </span>        return lambda x: x


<span class="w"> </span>class DocumenterBridge:
<span class="w"> </span>    &quot;&quot;&quot;A parameters container for Documenters.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, env: BuildEnvironment, reporter: (Reporter | None),</span>
<span class="gd">-        options: Options, lineno: int, state: Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, env: BuildEnvironment, reporter: Reporter | None, options: Options,</span>
<span class="gi">+                 lineno: int, state: Any) -&gt; None:</span>
<span class="w"> </span>        self.env = env
<span class="w"> </span>        self._reporter = reporter
<span class="w"> </span>        self.genopt = options
<span class="gu">@@ -47,16 +57,44 @@ class DocumenterBridge:</span>
<span class="w"> </span>        self.state = state


<span class="gd">-def process_documenter_options(documenter: type[Documenter], config: Config,</span>
<span class="gd">-    options: dict[str, str]) -&gt;Options:</span>
<span class="gi">+def process_documenter_options(</span>
<span class="gi">+    documenter: type[Documenter], config: Config, options: dict[str, str],</span>
<span class="gi">+) -&gt; Options:</span>
<span class="w"> </span>    &quot;&quot;&quot;Recognize options of Documenter from user input.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    default_options = config.autodoc_default_options</span>
<span class="gi">+    for name in AUTODOC_DEFAULT_OPTIONS:</span>
<span class="gi">+        if name not in documenter.option_spec:</span>
<span class="gi">+            continue</span>
<span class="gi">+        negated = options.pop(&#39;no-&#39; + name, True) is None</span>
<span class="gi">+        if name in default_options and not negated:</span>
<span class="gi">+            if name in options and isinstance(default_options[name], str):</span>
<span class="gi">+                # take value from options if present or extend it</span>
<span class="gi">+                # with autodoc_default_options if necessary</span>
<span class="gi">+                if name in AUTODOC_EXTENDABLE_OPTIONS:</span>
<span class="gi">+                    if options[name] is not None and options[name].startswith(&#39;+&#39;):</span>
<span class="gi">+                        options[name] = f&#39;{default_options[name]},{options[name][1:]}&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                options[name] = default_options[name]</span>
<span class="gi">+</span>
<span class="gi">+        elif options.get(name) is not None:</span>
<span class="gi">+            # remove &#39;+&#39; from option argument if there&#39;s nothing to merge it with</span>
<span class="gi">+            options[name] = options[name].lstrip(&#39;+&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    return Options(assemble_option_dict(options.items(), documenter.option_spec))</span>


<span class="gd">-def parse_generated_content(state: RSTState, content: StringList,</span>
<span class="gd">-    documenter: Documenter) -&gt;list[Node]:</span>
<span class="gi">+def parse_generated_content(state: RSTState, content: StringList, documenter: Documenter,</span>
<span class="gi">+                            ) -&gt; list[Node]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse an item of content generated by Documenter.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with switch_source_input(state, content):</span>
<span class="gi">+        if documenter.titles_allowed:</span>
<span class="gi">+            return nested_parse_to_nodes(state, content)</span>
<span class="gi">+</span>
<span class="gi">+        node = nodes.paragraph()</span>
<span class="gi">+        # necessary so that the child nodes get the right source/line set</span>
<span class="gi">+        node.document = state.document</span>
<span class="gi">+        state.nested_parse(content, 0, node, match_titles=False)</span>
<span class="gi">+        return node.children</span>


<span class="w"> </span>class AutodocDirective(SphinxDirective):
<span class="gu">@@ -65,8 +103,49 @@ class AutodocDirective(SphinxDirective):</span>
<span class="w"> </span>    It invokes a Documenter upon running. After the processing, it parses and returns
<span class="w"> </span>    the content generated by Documenter.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    option_spec = DummyOptionSpec()
<span class="w"> </span>    has_content = True
<span class="w"> </span>    required_arguments = 1
<span class="w"> </span>    optional_arguments = 0
<span class="w"> </span>    final_argument_whitespace = True
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        reporter = self.state.document.reporter</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            source, lineno = reporter.get_source_and_line(  # type: ignore[attr-defined]</span>
<span class="gi">+                self.lineno)</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            source, lineno = (None, None)</span>
<span class="gi">+        logger.debug(&#39;[autodoc] %s:%s: input:\n%s&#39;, source, lineno, self.block_text)</span>
<span class="gi">+</span>
<span class="gi">+        # look up target Documenter</span>
<span class="gi">+        objtype = self.name[4:]  # strip prefix (auto-).</span>
<span class="gi">+        doccls = self.env.app.registry.documenters[objtype]</span>
<span class="gi">+</span>
<span class="gi">+        # process the options with the selected documenter&#39;s option_spec</span>
<span class="gi">+        try:</span>
<span class="gi">+            documenter_options = process_documenter_options(doccls, self.config, self.options)</span>
<span class="gi">+        except (KeyError, ValueError, TypeError) as exc:</span>
<span class="gi">+            # an option is either unknown or has a wrong type</span>
<span class="gi">+            logger.error(&#39;An option to %s is either unknown or has an invalid value: %s&#39;,</span>
<span class="gi">+                         self.name, exc, location=(self.env.docname, lineno))</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        # generate the output</span>
<span class="gi">+        params = DocumenterBridge(self.env, reporter, documenter_options, lineno, self.state)</span>
<span class="gi">+        documenter = doccls(params, self.arguments[0])</span>
<span class="gi">+        documenter.generate(more_content=self.content)</span>
<span class="gi">+        if not params.result:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        logger.debug(&#39;[autodoc] output:\n%s&#39;, &#39;\n&#39;.join(params.result))</span>
<span class="gi">+</span>
<span class="gi">+        # record all filenames as dependencies -- this will at least</span>
<span class="gi">+        # partially make automatic invalidation possible</span>
<span class="gi">+        for fn in params.record_dependencies:</span>
<span class="gi">+            self.state.document.settings.record_dependencies.add(fn)</span>
<span class="gi">+</span>
<span class="gi">+        result = parse_generated_content(self.state, params.result, documenter)</span>
<span class="gi">+        return result</span>
<span class="gh">diff --git a/sphinx/ext/autodoc/importer.py b/sphinx/ext/autodoc/importer.py</span>
<span class="gh">index efb94f8f3..ebdaa9848 100644</span>
<span class="gd">--- a/sphinx/ext/autodoc/importer.py</span>
<span class="gi">+++ b/sphinx/ext/autodoc/importer.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Importer utilities for autodoc&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import contextlib
<span class="w"> </span>import importlib
<span class="w"> </span>import os
<span class="gu">@@ -8,22 +10,36 @@ import traceback</span>
<span class="w"> </span>import typing
<span class="w"> </span>from enum import Enum
<span class="w"> </span>from typing import TYPE_CHECKING, NamedTuple
<span class="gi">+</span>
<span class="w"> </span>from sphinx.errors import PycodeError
<span class="w"> </span>from sphinx.ext.autodoc.mock import ismock, undecorate
<span class="w"> </span>from sphinx.pycode import ModuleAnalyzer
<span class="w"> </span>from sphinx.util import logging
<span class="gd">-from sphinx.util.inspect import getannotations, getmro, getslots, isclass, isenumclass, safe_getattr, unwrap_all</span>
<span class="gi">+from sphinx.util.inspect import (</span>
<span class="gi">+    getannotations,</span>
<span class="gi">+    getmro,</span>
<span class="gi">+    getslots,</span>
<span class="gi">+    isclass,</span>
<span class="gi">+    isenumclass,</span>
<span class="gi">+    safe_getattr,</span>
<span class="gi">+    unwrap_all,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Callable, Iterator, Mapping
<span class="w"> </span>    from types import ModuleType
<span class="w"> </span>    from typing import Any
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.ext.autodoc import ObjectMember
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="gd">-def _filter_enum_dict(enum_class: type[Enum], attrgetter: Callable[[Any,</span>
<span class="gd">-    str, Any], Any], enum_class_dict: Mapping[str, object]) -&gt;Iterator[tuple</span>
<span class="gd">-    [str, type, Any]]:</span>
<span class="gi">+def _filter_enum_dict(</span>
<span class="gi">+    enum_class: type[Enum],</span>
<span class="gi">+    attrgetter: Callable[[Any, str, Any], Any],</span>
<span class="gi">+    enum_class_dict: Mapping[str, object],</span>
<span class="gi">+) -&gt; Iterator[tuple[str, type, Any]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Find the attributes to document of an enumeration class.

<span class="w"> </span>    The output consists of triplets ``(attribute name, defining class, value)``
<span class="gu">@@ -31,29 +47,201 @@ def _filter_enum_dict(enum_class: type[Enum], attrgetter: Callable[[Any,</span>
<span class="w"> </span>    but with different defining class. The order of occurrence is guided by
<span class="w"> </span>    the MRO of *enum_class*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # attributes that were found on a mixin type or the data type</span>
<span class="gi">+    candidate_in_mro: set[str] = set()</span>
<span class="gi">+    # sunder names that were picked up (and thereby allowed to be redefined)</span>
<span class="gi">+    # see: https://docs.python.org/3/howto/enum.html#supported-dunder-names</span>
<span class="gi">+    sunder_names = {&#39;_name_&#39;, &#39;_value_&#39;, &#39;_missing_&#39;, &#39;_order_&#39;, &#39;_generate_next_value_&#39;}</span>
<span class="gi">+    # attributes that can be picked up on a mixin type or the enum&#39;s data type</span>
<span class="gi">+    public_names = {&#39;name&#39;, &#39;value&#39;, *object.__dict__, *sunder_names}</span>
<span class="gi">+    # names that are ignored by default</span>
<span class="gi">+    ignore_names = Enum.__dict__.keys() - public_names</span>
<span class="gi">+</span>
<span class="gi">+    def is_native_api(obj: object, name: str) -&gt; bool:</span>
<span class="gi">+        &quot;&quot;&quot;Check whether *obj* is the same as ``Enum.__dict__[name]``.&quot;&quot;&quot;</span>
<span class="gi">+        return unwrap_all(obj) is unwrap_all(Enum.__dict__[name])</span>
<span class="gi">+</span>
<span class="gi">+    def should_ignore(name: str, value: Any) -&gt; bool:</span>
<span class="gi">+        if name in sunder_names:</span>
<span class="gi">+            return is_native_api(value, name)</span>
<span class="gi">+        return name in ignore_names</span>
<span class="gi">+</span>
<span class="gi">+    sentinel = object()</span>
<span class="gi">+</span>
<span class="gi">+    def query(name: str, defining_class: type) -&gt; tuple[str, type, Any] | None:</span>
<span class="gi">+        value = attrgetter(enum_class, name, sentinel)</span>
<span class="gi">+        if value is not sentinel:</span>
<span class="gi">+            return (name, defining_class, value)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    # attributes defined on a parent type, possibly shadowed later by</span>
<span class="gi">+    # the attributes defined directly inside the enumeration class</span>
<span class="gi">+    for parent in enum_class.__mro__:</span>
<span class="gi">+        if parent in {enum_class, Enum, object}:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        parent_dict = attrgetter(parent, &#39;__dict__&#39;, {})</span>
<span class="gi">+        for name, value in parent_dict.items():</span>
<span class="gi">+            if should_ignore(name, value):</span>
<span class="gi">+                continue</span>

<span class="gi">+            candidate_in_mro.add(name)</span>
<span class="gi">+            if (item := query(name, parent)) is not None:</span>
<span class="gi">+                yield item</span>

<span class="gd">-def mangle(subject: Any, name: str) -&gt;str:</span>
<span class="gi">+    # exclude members coming from the native Enum unless</span>
<span class="gi">+    # they were redefined on a mixin type or the data type</span>
<span class="gi">+    excluded_members = Enum.__dict__.keys() - candidate_in_mro</span>
<span class="gi">+    yield from filter(None, (query(name, enum_class) for name in enum_class_dict</span>
<span class="gi">+                             if name not in excluded_members))</span>
<span class="gi">+</span>
<span class="gi">+    # check if allowed members from ``Enum`` were redefined at the enum level</span>
<span class="gi">+    special_names = sunder_names | public_names</span>
<span class="gi">+    special_names &amp;= enum_class_dict.keys()</span>
<span class="gi">+    special_names &amp;= Enum.__dict__.keys()</span>
<span class="gi">+    for name in special_names:</span>
<span class="gi">+        if (</span>
<span class="gi">+            not is_native_api(enum_class_dict[name], name)</span>
<span class="gi">+            and (item := query(name, enum_class)) is not None</span>
<span class="gi">+        ):</span>
<span class="gi">+            yield item</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def mangle(subject: Any, name: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Mangle the given name.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        if isclass(subject) and name.startswith(&#39;__&#39;) and not name.endswith(&#39;__&#39;):</span>
<span class="gi">+            return f&quot;_{subject.__name__}{name}&quot;</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        pass</span>

<span class="gi">+    return name</span>

<span class="gd">-def unmangle(subject: Any, name: str) -&gt;(str | None):</span>
<span class="gi">+</span>
<span class="gi">+def unmangle(subject: Any, name: str) -&gt; str | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Unmangle the given name.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        if isclass(subject) and not name.endswith(&#39;__&#39;):</span>
<span class="gi">+            prefix = &quot;_%s__&quot; % subject.__name__</span>
<span class="gi">+            if name.startswith(prefix):</span>
<span class="gi">+                return name.replace(prefix, &quot;__&quot;, 1)</span>
<span class="gi">+            else:</span>
<span class="gi">+                for cls in subject.__mro__:</span>
<span class="gi">+                    prefix = &quot;_%s__&quot; % cls.__name__</span>
<span class="gi">+                    if name.startswith(prefix):</span>
<span class="gi">+                        # mangled attribute defined in parent class</span>
<span class="gi">+                        return None</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    return name</span>


<span class="gd">-def import_module(modname: str) -&gt;Any:</span>
<span class="gi">+def import_module(modname: str) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Call importlib.import_module(modname), convert exceptions to ImportError.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return importlib.import_module(modname)</span>
<span class="gi">+    except BaseException as exc:</span>
<span class="gi">+        # Importing modules may cause any side effects, including</span>
<span class="gi">+        # SystemExit, so we need to catch all errors.</span>
<span class="gi">+        raise ImportError(exc, traceback.format_exc()) from exc</span>


<span class="gd">-def _reload_module(module: ModuleType) -&gt;Any:</span>
<span class="gi">+def _reload_module(module: ModuleType) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Call importlib.reload(module), convert exceptions to ImportError
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return importlib.reload(module)</span>
<span class="gi">+    except BaseException as exc:</span>
<span class="gi">+        # Importing modules may cause any side effects, including</span>
<span class="gi">+        # SystemExit, so we need to catch all errors.</span>
<span class="gi">+        raise ImportError(exc, traceback.format_exc()) from exc</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def import_object(modname: str, objpath: list[str], objtype: str = &#39;&#39;,</span>
<span class="gi">+                  attrgetter: Callable[[Any, str], Any] = safe_getattr) -&gt; Any:</span>
<span class="gi">+    if objpath:</span>
<span class="gi">+        logger.debug(&#39;[autodoc] from %s import %s&#39;, modname, &#39;.&#39;.join(objpath))</span>
<span class="gi">+    else:</span>
<span class="gi">+        logger.debug(&#39;[autodoc] import %s&#39;, modname)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        module = None</span>
<span class="gi">+        exc_on_importing = None</span>
<span class="gi">+        objpath = objpath.copy()</span>
<span class="gi">+        while module is None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                original_module_names = frozenset(sys.modules)</span>
<span class="gi">+                module = import_module(modname)</span>
<span class="gi">+                if os.environ.get(&#39;SPHINX_AUTODOC_RELOAD_MODULES&#39;):</span>
<span class="gi">+                    new_modules = [m for m in sys.modules if m not in original_module_names]</span>
<span class="gi">+                    # Try reloading modules with ``typing.TYPE_CHECKING == True``.</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        typing.TYPE_CHECKING = True</span>
<span class="gi">+                        # Ignore failures; we&#39;ve already successfully loaded these modules</span>
<span class="gi">+                        with contextlib.suppress(ImportError, KeyError):</span>
<span class="gi">+                            for m in new_modules:</span>
<span class="gi">+                                _reload_module(sys.modules[m])</span>
<span class="gi">+                    finally:</span>
<span class="gi">+                        typing.TYPE_CHECKING = False</span>
<span class="gi">+                    module = sys.modules[modname]</span>
<span class="gi">+                logger.debug(&#39;[autodoc] import %s =&gt; %r&#39;, modname, module)</span>
<span class="gi">+            except ImportError as exc:</span>
<span class="gi">+                logger.debug(&#39;[autodoc] import %s =&gt; failed&#39;, modname)</span>
<span class="gi">+                exc_on_importing = exc</span>
<span class="gi">+                if &#39;.&#39; in modname:</span>
<span class="gi">+                    # retry with parent module</span>
<span class="gi">+                    modname, name = modname.rsplit(&#39;.&#39;, 1)</span>
<span class="gi">+                    objpath.insert(0, name)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise</span>
<span class="gi">+</span>
<span class="gi">+        obj = module</span>
<span class="gi">+        parent = None</span>
<span class="gi">+        object_name = None</span>
<span class="gi">+        for attrname in objpath:</span>
<span class="gi">+            parent = obj</span>
<span class="gi">+            logger.debug(&#39;[autodoc] getattr(_, %r)&#39;, attrname)</span>
<span class="gi">+            mangled_name = mangle(obj, attrname)</span>
<span class="gi">+            obj = attrgetter(obj, mangled_name)</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                logger.debug(&#39;[autodoc] =&gt; %r&#39;, obj)</span>
<span class="gi">+            except TypeError:</span>
<span class="gi">+                # fallback of failure on logging for broken object</span>
<span class="gi">+                # refs: https://github.com/sphinx-doc/sphinx/issues/9095</span>
<span class="gi">+                logger.debug(&#39;[autodoc] =&gt; %r&#39;, (obj,))</span>
<span class="gi">+</span>
<span class="gi">+            object_name = attrname</span>
<span class="gi">+        return [module, parent, object_name, obj]</span>
<span class="gi">+    except (AttributeError, ImportError) as exc:</span>
<span class="gi">+        if isinstance(exc, AttributeError) and exc_on_importing:</span>
<span class="gi">+            # restore ImportError</span>
<span class="gi">+            exc = exc_on_importing</span>
<span class="gi">+</span>
<span class="gi">+        if objpath:</span>
<span class="gi">+            errmsg = (&#39;autodoc: failed to import %s %r from module %r&#39; %</span>
<span class="gi">+                      (objtype, &#39;.&#39;.join(objpath), modname))</span>
<span class="gi">+        else:</span>
<span class="gi">+            errmsg = f&#39;autodoc: failed to import {objtype} {modname!r}&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(exc, ImportError):</span>
<span class="gi">+            # import_module() raises ImportError having real exception obj and</span>
<span class="gi">+            # traceback</span>
<span class="gi">+            real_exc, traceback_msg = exc.args</span>
<span class="gi">+            if isinstance(real_exc, SystemExit):</span>
<span class="gi">+                errmsg += (&#39;; the module executes module level statement &#39;</span>
<span class="gi">+                           &#39;and it might call sys.exit().&#39;)</span>
<span class="gi">+            elif isinstance(real_exc, ImportError) and real_exc.args:</span>
<span class="gi">+                errmsg += &#39;; the following exception was raised:\n%s&#39; % real_exc.args[0]</span>
<span class="gi">+            else:</span>
<span class="gi">+                errmsg += &#39;; the following exception was raised:\n%s&#39; % traceback_msg</span>
<span class="gi">+        else:</span>
<span class="gi">+            errmsg += &#39;; the following exception was raised:\n%s&#39; % traceback.format_exc()</span>
<span class="gi">+</span>
<span class="gi">+        logger.debug(errmsg)</span>
<span class="gi">+        raise ImportError(errmsg) from exc</span>


<span class="w"> </span>class Attribute(NamedTuple):
<span class="gu">@@ -62,13 +250,157 @@ class Attribute(NamedTuple):</span>
<span class="w"> </span>    value: Any


<span class="gd">-def get_object_members(subject: Any, objpath: list[str], attrgetter:</span>
<span class="gd">-    Callable, analyzer: (ModuleAnalyzer | None)=None) -&gt;dict[str, Attribute]:</span>
<span class="gi">+def get_object_members(</span>
<span class="gi">+    subject: Any,</span>
<span class="gi">+    objpath: list[str],</span>
<span class="gi">+    attrgetter: Callable,</span>
<span class="gi">+    analyzer: ModuleAnalyzer | None = None,</span>
<span class="gi">+) -&gt; dict[str, Attribute]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get members and attributes of target object.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from sphinx.ext.autodoc import INSTANCEATTR</span>
<span class="gi">+</span>
<span class="gi">+    # the members directly defined in the class</span>
<span class="gi">+    obj_dict = attrgetter(subject, &#39;__dict__&#39;, {})</span>
<span class="gi">+</span>
<span class="gi">+    members: dict[str, Attribute] = {}</span>
<span class="gi">+</span>
<span class="gi">+    # enum members</span>
<span class="gi">+    if isenumclass(subject):</span>
<span class="gi">+        for name, defining_class, value in _filter_enum_dict(subject, attrgetter, obj_dict):</span>
<span class="gi">+            # the order of occurrence of *name* matches the subject&#39;s MRO,</span>
<span class="gi">+            # allowing inherited attributes to be shadowed correctly</span>
<span class="gi">+            if unmangled := unmangle(defining_class, name):</span>
<span class="gi">+                members[unmangled] = Attribute(unmangled, defining_class is subject, value)</span>
<span class="gi">+</span>
<span class="gi">+    # members in __slots__</span>
<span class="gi">+    try:</span>
<span class="gi">+        subject___slots__ = getslots(subject)</span>
<span class="gi">+        if subject___slots__:</span>
<span class="gi">+            from sphinx.ext.autodoc import SLOTSATTR</span>
<span class="gi">+</span>
<span class="gi">+            for name in subject___slots__:</span>
<span class="gi">+                members[name] = Attribute(name, True, SLOTSATTR)</span>
<span class="gi">+    except (TypeError, ValueError):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    # other members</span>
<span class="gi">+    for name in dir(subject):</span>
<span class="gi">+        try:</span>
<span class="gi">+            value = attrgetter(subject, name)</span>
<span class="gi">+            directly_defined = name in obj_dict</span>
<span class="gi">+            unmangled = unmangle(subject, name)</span>
<span class="gi">+            if unmangled and unmangled not in members:</span>
<span class="gi">+                members[unmangled] = Attribute(unmangled, directly_defined, value)</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+    # annotation only member (ex. attr: int)</span>
<span class="gi">+    for cls in getmro(subject):</span>
<span class="gi">+        for name in getannotations(cls):</span>
<span class="gi">+            unmangled = unmangle(cls, name)</span>
<span class="gi">+            if unmangled and unmangled not in members:</span>
<span class="gi">+                members[unmangled] = Attribute(unmangled, cls is subject, INSTANCEATTR)</span>
<span class="gi">+</span>
<span class="gi">+    if analyzer:</span>
<span class="gi">+        # append instance attributes (cf. self.attr1) if analyzer knows</span>
<span class="gi">+        namespace = &#39;.&#39;.join(objpath)</span>
<span class="gi">+        for (ns, name) in analyzer.find_attr_docs():</span>
<span class="gi">+            if namespace == ns and name not in members:</span>
<span class="gi">+                members[name] = Attribute(name, True, INSTANCEATTR)</span>
<span class="gi">+</span>
<span class="gi">+    return members</span>


<span class="w"> </span>def get_class_members(subject: Any, objpath: Any, attrgetter: Callable,
<span class="gd">-    inherit_docstrings: bool=True) -&gt;dict[str, ObjectMember]:</span>
<span class="gi">+                      inherit_docstrings: bool = True) -&gt; dict[str, ObjectMember]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get members and attributes of target class.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from sphinx.ext.autodoc import INSTANCEATTR, ObjectMember</span>
<span class="gi">+</span>
<span class="gi">+    # the members directly defined in the class</span>
<span class="gi">+    obj_dict = attrgetter(subject, &#39;__dict__&#39;, {})</span>
<span class="gi">+</span>
<span class="gi">+    members: dict[str, ObjectMember] = {}</span>
<span class="gi">+</span>
<span class="gi">+    # enum members</span>
<span class="gi">+    if isenumclass(subject):</span>
<span class="gi">+        for name, defining_class, value in _filter_enum_dict(subject, attrgetter, obj_dict):</span>
<span class="gi">+            # the order of occurrence of *name* matches the subject&#39;s MRO,</span>
<span class="gi">+            # allowing inherited attributes to be shadowed correctly</span>
<span class="gi">+            if unmangled := unmangle(defining_class, name):</span>
<span class="gi">+                members[unmangled] = ObjectMember(unmangled, value, class_=defining_class)</span>
<span class="gi">+</span>
<span class="gi">+    # members in __slots__</span>
<span class="gi">+    try:</span>
<span class="gi">+        subject___slots__ = getslots(subject)</span>
<span class="gi">+        if subject___slots__:</span>
<span class="gi">+            from sphinx.ext.autodoc import SLOTSATTR</span>
<span class="gi">+</span>
<span class="gi">+            for name, docstring in subject___slots__.items():</span>
<span class="gi">+                members[name] = ObjectMember(name, SLOTSATTR, class_=subject,</span>
<span class="gi">+                                             docstring=docstring)</span>
<span class="gi">+    except (TypeError, ValueError):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    # other members</span>
<span class="gi">+    for name in dir(subject):</span>
<span class="gi">+        try:</span>
<span class="gi">+            value = attrgetter(subject, name)</span>
<span class="gi">+            if ismock(value):</span>
<span class="gi">+                value = undecorate(value)</span>
<span class="gi">+</span>
<span class="gi">+            unmangled = unmangle(subject, name)</span>
<span class="gi">+            if unmangled and unmangled not in members:</span>
<span class="gi">+                if name in obj_dict:</span>
<span class="gi">+                    members[unmangled] = ObjectMember(unmangled, value, class_=subject)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    members[unmangled] = ObjectMember(unmangled, value)</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        for cls in getmro(subject):</span>
<span class="gi">+            try:</span>
<span class="gi">+                modname = safe_getattr(cls, &#39;__module__&#39;)</span>
<span class="gi">+                qualname = safe_getattr(cls, &#39;__qualname__&#39;)</span>
<span class="gi">+                analyzer = ModuleAnalyzer.for_module(modname)</span>
<span class="gi">+                analyzer.analyze()</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                qualname = None</span>
<span class="gi">+                analyzer = None</span>
<span class="gi">+            except PycodeError:</span>
<span class="gi">+                analyzer = None</span>
<span class="gi">+</span>
<span class="gi">+            # annotation only member (ex. attr: int)</span>
<span class="gi">+            for name in getannotations(cls):</span>
<span class="gi">+                unmangled = unmangle(cls, name)</span>
<span class="gi">+                if unmangled and unmangled not in members:</span>
<span class="gi">+                    if analyzer and (qualname, unmangled) in analyzer.attr_docs:</span>
<span class="gi">+                        docstring = &#39;\n&#39;.join(analyzer.attr_docs[qualname, unmangled])</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        docstring = None</span>
<span class="gi">+</span>
<span class="gi">+                    members[unmangled] = ObjectMember(unmangled, INSTANCEATTR, class_=cls,</span>
<span class="gi">+                                                      docstring=docstring)</span>
<span class="gi">+</span>
<span class="gi">+            # append or complete instance attributes (cf. self.attr1) if analyzer knows</span>
<span class="gi">+            if analyzer:</span>
<span class="gi">+                for (ns, name), docstring in analyzer.attr_docs.items():</span>
<span class="gi">+                    if ns == qualname and name not in members:</span>
<span class="gi">+                        # otherwise unknown instance attribute</span>
<span class="gi">+                        members[name] = ObjectMember(name, INSTANCEATTR, class_=cls,</span>
<span class="gi">+                                                     docstring=&#39;\n&#39;.join(docstring))</span>
<span class="gi">+                    elif (ns == qualname and docstring and</span>
<span class="gi">+                          isinstance(members[name], ObjectMember) and</span>
<span class="gi">+                          not members[name].docstring):</span>
<span class="gi">+                        if cls != subject and not inherit_docstrings:</span>
<span class="gi">+                            # If we are in the MRO of the class and not the class itself,</span>
<span class="gi">+                            # and we do not want to inherit docstrings, then skip setting</span>
<span class="gi">+                            # the docstring below</span>
<span class="gi">+                            continue</span>
<span class="gi">+                        # attribute is already known, because dir(subject) enumerates it.</span>
<span class="gi">+                        # But it has no docstring yet</span>
<span class="gi">+                        members[name].docstring = &#39;\n&#39;.join(docstring)</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    return members</span>
<span class="gh">diff --git a/sphinx/ext/autodoc/mock.py b/sphinx/ext/autodoc/mock.py</span>
<span class="gh">index 2a6922a24..265f45057 100644</span>
<span class="gd">--- a/sphinx/ext/autodoc/mock.py</span>
<span class="gi">+++ b/sphinx/ext/autodoc/mock.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;mock for autodoc&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import contextlib
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="gu">@@ -7,124 +9,195 @@ from importlib.abc import Loader, MetaPathFinder</span>
<span class="w"> </span>from importlib.machinery import ModuleSpec
<span class="w"> </span>from types import MethodType, ModuleType
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.inspect import isboundmethod, safe_getattr
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Iterator, Sequence
<span class="w"> </span>    from typing import Any
<span class="gi">+</span>
<span class="w"> </span>    from typing_extensions import TypeIs
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="w"> </span>class _MockObject:
<span class="w"> </span>    &quot;&quot;&quot;Used by autodoc_mock_imports.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __display_name__ = &#39;_MockObject&#39;
<span class="w"> </span>    __name__ = &#39;&#39;
<span class="w"> </span>    __sphinx_mock__ = True
<span class="w"> </span>    __sphinx_decorator_args__: tuple[Any, ...] = ()

<span class="gd">-    def __new__(cls, *args: Any, **kwargs: Any) -&gt;Any:</span>
<span class="gi">+    def __new__(cls, *args: Any, **kwargs: Any) -&gt; Any:</span>
<span class="w"> </span>        if len(args) == 3 and isinstance(args[1], tuple):
<span class="w"> </span>            superclass = args[1][-1].__class__
<span class="w"> </span>            if superclass is cls:
<span class="gi">+                # subclassing MockObject</span>
<span class="w"> </span>                return _make_subclass(args[0], superclass.__display_name__,
<span class="gd">-                    superclass=superclass, attributes=args[2])</span>
<span class="gi">+                                      superclass=superclass, attributes=args[2])</span>
<span class="gi">+</span>
<span class="w"> </span>        return super().__new__(cls)

<span class="gd">-    def __init__(self, *args: Any, **kwargs: Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        self.__qualname__ = self.__name__

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return 0

<span class="gd">-    def __contains__(self, key: str) -&gt;bool:</span>
<span class="gi">+    def __contains__(self, key: str) -&gt; bool:</span>
<span class="w"> </span>        return False

<span class="gd">-    def __iter__(self) -&gt;Iterator[Any]:</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[Any]:</span>
<span class="w"> </span>        return iter(())

<span class="gd">-    def __mro_entries__(self, bases: tuple[Any, ...]) -&gt;tuple[type, ...]:</span>
<span class="gd">-        return self.__class__,</span>
<span class="gi">+    def __mro_entries__(self, bases: tuple[Any, ...]) -&gt; tuple[type, ...]:</span>
<span class="gi">+        return (self.__class__,)</span>

<span class="gd">-    def __getitem__(self, key: Any) -&gt;_MockObject:</span>
<span class="gd">-        return _make_subclass(str(key), self.__display_name__, self.__class__)(</span>
<span class="gd">-            )</span>
<span class="gi">+    def __getitem__(self, key: Any) -&gt; _MockObject:</span>
<span class="gi">+        return _make_subclass(str(key), self.__display_name__, self.__class__)()</span>

<span class="gd">-    def __getattr__(self, key: str) -&gt;_MockObject:</span>
<span class="gi">+    def __getattr__(self, key: str) -&gt; _MockObject:</span>
<span class="w"> </span>        return _make_subclass(key, self.__display_name__, self.__class__)()

<span class="gd">-    def __call__(self, *args: Any, **kwargs: Any) -&gt;Any:</span>
<span class="gi">+    def __call__(self, *args: Any, **kwargs: Any) -&gt; Any:</span>
<span class="w"> </span>        call = self.__class__()
<span class="w"> </span>        call.__sphinx_decorator_args__ = args
<span class="w"> </span>        return call

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return self.__display_name__


<span class="gi">+def _make_subclass(name: str, module: str, superclass: Any = _MockObject,</span>
<span class="gi">+                   attributes: Any = None, decorator_args: tuple[Any, ...] = ()) -&gt; Any:</span>
<span class="gi">+    attrs = {&#39;__module__&#39;: module,</span>
<span class="gi">+             &#39;__display_name__&#39;: module + &#39;.&#39; + name,</span>
<span class="gi">+             &#39;__name__&#39;: name,</span>
<span class="gi">+             &#39;__sphinx_decorator_args__&#39;: decorator_args}</span>
<span class="gi">+    attrs.update(attributes or {})</span>
<span class="gi">+</span>
<span class="gi">+    return type(name, (superclass,), attrs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class _MockModule(ModuleType):
<span class="w"> </span>    &quot;&quot;&quot;Used by autodoc_mock_imports.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __file__ = os.devnull
<span class="w"> </span>    __sphinx_mock__ = True

<span class="gd">-    def __init__(self, name: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, name: str) -&gt; None:</span>
<span class="w"> </span>        super().__init__(name)
<span class="w"> </span>        self.__all__: list[str] = []
<span class="w"> </span>        self.__path__: list[str] = []

<span class="gd">-    def __getattr__(self, name: str) -&gt;_MockObject:</span>
<span class="gi">+    def __getattr__(self, name: str) -&gt; _MockObject:</span>
<span class="w"> </span>        return _make_subclass(name, self.__name__)()

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return self.__name__


<span class="w"> </span>class MockLoader(Loader):
<span class="w"> </span>    &quot;&quot;&quot;A loader for mocking.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, finder: MockFinder) -&gt;None:</span>
<span class="gi">+    def __init__(self, finder: MockFinder) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.finder = finder

<span class="gi">+    def create_module(self, spec: ModuleSpec) -&gt; ModuleType:</span>
<span class="gi">+        logger.debug(&#39;[autodoc] adding a mock module as %s!&#39;, spec.name)</span>
<span class="gi">+        self.finder.mocked_modules.append(spec.name)</span>
<span class="gi">+        return _MockModule(spec.name)</span>
<span class="gi">+</span>
<span class="gi">+    def exec_module(self, module: ModuleType) -&gt; None:</span>
<span class="gi">+        pass  # nothing to do</span>
<span class="gi">+</span>

<span class="w"> </span>class MockFinder(MetaPathFinder):
<span class="w"> </span>    &quot;&quot;&quot;A finder for mocking.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, modnames: list[str]) -&gt;None:</span>
<span class="gi">+    def __init__(self, modnames: list[str]) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.modnames = modnames
<span class="w"> </span>        self.loader = MockLoader(self)
<span class="w"> </span>        self.mocked_modules: list[str] = []

<span class="gd">-    def invalidate_caches(self) -&gt;None:</span>
<span class="gi">+    def find_spec(self, fullname: str, path: Sequence[bytes | str] | None,</span>
<span class="gi">+                  target: ModuleType | None = None) -&gt; ModuleSpec | None:</span>
<span class="gi">+        for modname in self.modnames:</span>
<span class="gi">+            # check if fullname is (or is a descendant of) one of our targets</span>
<span class="gi">+            if modname == fullname or fullname.startswith(modname + &#39;.&#39;):</span>
<span class="gi">+                return ModuleSpec(fullname, self.loader)</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def invalidate_caches(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Invalidate mocked modules on sys.modules.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for modname in self.mocked_modules:</span>
<span class="gi">+            sys.modules.pop(modname, None)</span>


<span class="w"> </span>@contextlib.contextmanager
<span class="gd">-def mock(modnames: list[str]) -&gt;Iterator[None]:</span>
<span class="gi">+def mock(modnames: list[str]) -&gt; Iterator[None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Insert mock modules during context::

<span class="w"> </span>    with mock([&#39;target.module.name&#39;]):
<span class="w"> </span>        # mock modules are enabled here
<span class="w"> </span>        ...
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    finder = MockFinder(modnames)</span>
<span class="gi">+    try:</span>
<span class="gi">+        sys.meta_path.insert(0, finder)</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        sys.meta_path.remove(finder)</span>
<span class="gi">+        finder.invalidate_caches()</span>


<span class="gd">-def ismockmodule(subject: Any) -&gt;TypeIs[_MockModule]:</span>
<span class="gi">+def ismockmodule(subject: Any) -&gt; TypeIs[_MockModule]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the object is a mocked module.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(subject, _MockModule)</span>


<span class="gd">-def ismock(subject: Any) -&gt;bool:</span>
<span class="gi">+def ismock(subject: Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the object is mocked.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # check the object has &#39;__sphinx_mock__&#39; attribute</span>
<span class="gi">+    try:</span>
<span class="gi">+        if safe_getattr(subject, &#39;__sphinx_mock__&#39;, None) is None:</span>
<span class="gi">+            return False</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    # check the object is mocked module</span>
<span class="gi">+    if isinstance(subject, _MockModule):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    # check the object is bound method</span>
<span class="gi">+    if isinstance(subject, MethodType) and isboundmethod(subject):</span>
<span class="gi">+        tmp_subject = subject.__func__</span>
<span class="gi">+    else:</span>
<span class="gi">+        tmp_subject = subject</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        # check the object is mocked object</span>
<span class="gi">+        __mro__ = safe_getattr(type(tmp_subject), &#39;__mro__&#39;, [])</span>
<span class="gi">+        if len(__mro__) &gt; 2 and __mro__[-2] is _MockObject:</span>
<span class="gi">+            # A mocked object has a MRO that ends with (..., _MockObject, object).</span>
<span class="gi">+            return True</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    return False</span>


<span class="gd">-def undecorate(subject: _MockObject) -&gt;Any:</span>
<span class="gi">+def undecorate(subject: _MockObject) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Unwrap mock if *subject* is decorated by mocked object.

<span class="w"> </span>    If not decorated, returns given *subject* itself.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if ismock(subject) and subject.__sphinx_decorator_args__:</span>
<span class="gi">+        return subject.__sphinx_decorator_args__[0]</span>
<span class="gi">+    else:</span>
<span class="gi">+        return subject</span>
<span class="gh">diff --git a/sphinx/ext/autodoc/preserve_defaults.py b/sphinx/ext/autodoc/preserve_defaults.py</span>
<span class="gh">index fc27cde55..824293424 100644</span>
<span class="gd">--- a/sphinx/ext/autodoc/preserve_defaults.py</span>
<span class="gi">+++ b/sphinx/ext/autodoc/preserve_defaults.py</span>
<span class="gu">@@ -3,52 +3,198 @@</span>
<span class="w"> </span>Preserve the default argument values of function signatures in source code
<span class="w"> </span>and keep them not evaluated for readability.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import ast
<span class="w"> </span>import inspect
<span class="w"> </span>import types
<span class="w"> </span>import warnings
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>import sphinx
<span class="w"> </span>from sphinx.deprecation import RemovedInSphinx90Warning
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.pycode.ast import unparse as ast_unparse
<span class="w"> </span>from sphinx.util import logging
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing import Any
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gd">-_LAMBDA_NAME = (lambda : None).__name__</span>
<span class="gi">+_LAMBDA_NAME = (lambda: None).__name__</span>


<span class="w"> </span>class DefaultValue:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, name: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, name: str) -&gt; None:</span>
<span class="w"> </span>        self.name = name

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return self.name


<span class="gd">-def get_function_def(obj: Any) -&gt;(ast.FunctionDef | None):</span>
<span class="gi">+def get_function_def(obj: Any) -&gt; ast.FunctionDef | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get FunctionDef object from living object.

<span class="w"> </span>    This tries to parse original code for living object and returns
<span class="w"> </span>    AST node for given *obj*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    warnings.warn(&#39;sphinx.ext.autodoc.preserve_defaults.get_function_def is&#39;</span>
<span class="gi">+                  &#39; deprecated and scheduled for removal in Sphinx 9.&#39;</span>
<span class="gi">+                  &#39; Use sphinx.ext.autodoc.preserve_defaults._get_arguments() to&#39;</span>
<span class="gi">+                  &#39; extract AST arguments objects from a lambda or regular&#39;</span>
<span class="gi">+                  &#39; function.&#39;, RemovedInSphinx90Warning, stacklevel=2)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        source = inspect.getsource(obj)</span>
<span class="gi">+        if source.startswith((&#39; &#39;, &#39;\t&#39;)):</span>
<span class="gi">+            # subject is placed inside class or block.  To read its docstring,</span>
<span class="gi">+            # this adds if-block before the declaration.</span>
<span class="gi">+            module = ast.parse(&#39;if True:\n&#39; + source)</span>
<span class="gi">+            return module.body[0].body[0]  # type: ignore[attr-defined]</span>
<span class="gi">+        else:</span>
<span class="gi">+            module = ast.parse(source)</span>
<span class="gi">+            return module.body[0]  # type: ignore[return-value]</span>
<span class="gi">+    except (OSError, TypeError):  # failed to load source code</span>
<span class="gi">+        return None</span>


<span class="gd">-def _get_arguments(obj: Any, /) -&gt;(ast.arguments | None):</span>
<span class="gi">+def _get_arguments(obj: Any, /) -&gt; ast.arguments | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse &#39;ast.arguments&#39; from an object.

<span class="w"> </span>    This tries to parse the original code for an object and returns
<span class="w"> </span>    an &#39;ast.arguments&#39; node.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        source = inspect.getsource(obj)</span>
<span class="gi">+        if source.startswith((&#39; &#39;, &#39;\t&#39;)):</span>
<span class="gi">+            # &#39;obj&#39; is in some indented block.</span>
<span class="gi">+            module = ast.parse(&#39;if True:\n&#39; + source)</span>
<span class="gi">+            subject = module.body[0].body[0]  # type: ignore[attr-defined]</span>
<span class="gi">+        else:</span>
<span class="gi">+            module = ast.parse(source)</span>
<span class="gi">+            subject = module.body[0]</span>
<span class="gi">+    except (OSError, TypeError):</span>
<span class="gi">+        # bail; failed to load source for &#39;obj&#39;.</span>
<span class="gi">+        return None</span>
<span class="gi">+    except SyntaxError:</span>
<span class="gi">+        if _is_lambda(obj):</span>
<span class="gi">+            # Most likely a multi-line arising from detecting a lambda, e.g.:</span>
<span class="gi">+            #</span>
<span class="gi">+            # class Egg:</span>
<span class="gi">+            #     x = property(</span>
<span class="gi">+            #         lambda self: 1, doc=&quot;...&quot;)</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        # Other syntax errors that are not due to the fact that we are</span>
<span class="gi">+        # documenting a lambda function are propagated</span>
<span class="gi">+        # (in particular if a lambda is renamed by the user).</span>
<span class="gi">+        raise</span>
<span class="gi">+</span>
<span class="gi">+    return _get_arguments_inner(subject)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_lambda(x: Any, /) -&gt; bool:</span>
<span class="gi">+    return isinstance(x, types.LambdaType) and x.__name__ == _LAMBDA_NAME</span>


<span class="gd">-def update_defvalue(app: Sphinx, obj: Any, bound_method: bool) -&gt;None:</span>
<span class="gi">+def _get_arguments_inner(x: Any, /) -&gt; ast.arguments | None:</span>
<span class="gi">+    if isinstance(x, ast.AsyncFunctionDef | ast.FunctionDef | ast.Lambda):</span>
<span class="gi">+        return x.args</span>
<span class="gi">+    if isinstance(x, ast.Assign | ast.AnnAssign):</span>
<span class="gi">+        return _get_arguments_inner(x.value)</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_default_value(lines: list[str], position: ast.expr) -&gt; str | None:</span>
<span class="gi">+    try:</span>
<span class="gi">+        if position.lineno == position.end_lineno:</span>
<span class="gi">+            line = lines[position.lineno - 1]</span>
<span class="gi">+            return line[position.col_offset:position.end_col_offset]</span>
<span class="gi">+        else:</span>
<span class="gi">+            # multiline value is not supported now</span>
<span class="gi">+            return None</span>
<span class="gi">+    except (AttributeError, IndexError):</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def update_defvalue(app: Sphinx, obj: Any, bound_method: bool) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Update defvalue info of *obj* using type_comments.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not app.config.autodoc_preserve_defaults:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        lines = inspect.getsource(obj).splitlines()</span>
<span class="gi">+        if lines[0].startswith((&#39; &#39;, &#39;\t&#39;)):</span>
<span class="gi">+            # insert a dummy line to follow what _get_arguments() does.</span>
<span class="gi">+            lines.insert(0, &#39;&#39;)</span>
<span class="gi">+    except (OSError, TypeError):</span>
<span class="gi">+        lines = []</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        args = _get_arguments(obj)</span>
<span class="gi">+    except SyntaxError:</span>
<span class="gi">+        return</span>
<span class="gi">+    if args is None:</span>
<span class="gi">+        # If the object is a built-in, we won&#39;t be always able to recover</span>
<span class="gi">+        # the function definition and its arguments. This happens if *obj*</span>
<span class="gi">+        # is the `__init__` method generated automatically for dataclasses.</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    if not args.defaults and not args.kw_defaults:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        if bound_method and inspect.ismethod(obj) and hasattr(obj, &#39;__func__&#39;):</span>
<span class="gi">+            sig = inspect.signature(obj.__func__)</span>
<span class="gi">+        else:</span>
<span class="gi">+            sig = inspect.signature(obj)</span>
<span class="gi">+        defaults = list(args.defaults)</span>
<span class="gi">+        kw_defaults = list(args.kw_defaults)</span>
<span class="gi">+        parameters = list(sig.parameters.values())</span>
<span class="gi">+        for i, param in enumerate(parameters):</span>
<span class="gi">+            if param.default is param.empty:</span>
<span class="gi">+                if param.kind == param.KEYWORD_ONLY:</span>
<span class="gi">+                    # Consume kw_defaults for kwonly args</span>
<span class="gi">+                    kw_defaults.pop(0)</span>
<span class="gi">+            else:</span>
<span class="gi">+                if param.kind in (param.POSITIONAL_ONLY, param.POSITIONAL_OR_KEYWORD):</span>
<span class="gi">+                    default = defaults.pop(0)</span>
<span class="gi">+                    value = get_default_value(lines, default)</span>
<span class="gi">+                    if value is None:</span>
<span class="gi">+                        value = ast_unparse(default)</span>
<span class="gi">+                    parameters[i] = param.replace(default=DefaultValue(value))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    default = kw_defaults.pop(0)  # type: ignore[assignment]</span>
<span class="gi">+                    value = get_default_value(lines, default)</span>
<span class="gi">+                    if value is None:</span>
<span class="gi">+                        value = ast_unparse(default)</span>
<span class="gi">+                    parameters[i] = param.replace(default=DefaultValue(value))</span>
<span class="gi">+</span>
<span class="gi">+        sig = sig.replace(parameters=parameters)</span>
<span class="gi">+        try:</span>
<span class="gi">+            obj.__signature__ = sig</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            # __signature__ can&#39;t be set directly on bound methods.</span>
<span class="gi">+            obj.__dict__[&#39;__signature__&#39;] = sig</span>
<span class="gi">+    except (AttributeError, TypeError):</span>
<span class="gi">+        # Failed to update signature (e.g. built-in or extension types).</span>
<span class="gi">+        # For user-defined functions, &quot;obj&quot; may not have __dict__,</span>
<span class="gi">+        # e.g. when decorated with a class that defines __slots__.</span>
<span class="gi">+        # In this case, we can&#39;t set __signature__.</span>
<span class="gi">+        return</span>
<span class="gi">+    except NotImplementedError as exc:  # failed to ast_unparse()</span>
<span class="gi">+        logger.warning(__(&quot;Failed to parse a default argument value for %r: %s&quot;), obj, exc)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_config_value(&#39;autodoc_preserve_defaults&#39;, False, &#39;env&#39;)</span>
<span class="gi">+    app.connect(&#39;autodoc-before-process-signature&#39;, update_defvalue)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: sphinx.__display_version__,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/ext/autodoc/type_comment.py b/sphinx/ext/autodoc/type_comment.py</span>
<span class="gh">index 545663871..e0a5a63b9 100644</span>
<span class="gd">--- a/sphinx/ext/autodoc/type_comment.py</span>
<span class="gi">+++ b/sphinx/ext/autodoc/type_comment.py</span>
<span class="gu">@@ -1,43 +1,141 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Update annotations info of living objects using type_comments.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import ast
<span class="w"> </span>from inspect import Parameter, Signature, getsource
<span class="w"> </span>from typing import TYPE_CHECKING, Any, cast
<span class="gi">+</span>
<span class="w"> </span>import sphinx
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.pycode.ast import unparse as ast_unparse
<span class="w"> </span>from sphinx.util import inspect, logging
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Sequence
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="gd">-def not_suppressed(argtypes: Sequence[ast.expr]=()) -&gt;bool:</span>
<span class="gi">+def not_suppressed(argtypes: Sequence[ast.expr] = ()) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check given *argtypes* is suppressed type_comment or not.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(argtypes) == 0:  # no argtypees</span>
<span class="gi">+        return False</span>
<span class="gi">+    if len(argtypes) == 1:</span>
<span class="gi">+        arg = argtypes[0]</span>
<span class="gi">+        if isinstance(arg, ast.Constant) and arg.value is ...:  # suppressed</span>
<span class="gi">+            return False</span>
<span class="gi">+    # not suppressed</span>
<span class="gi">+    return True</span>


<span class="w"> </span>def signature_from_ast(node: ast.FunctionDef, bound_method: bool,
<span class="gd">-    type_comment: ast.FunctionDef) -&gt;Signature:</span>
<span class="gi">+                       type_comment: ast.FunctionDef) -&gt; Signature:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a Signature object for the given *node*.

<span class="w"> </span>    :param bound_method: Specify *node* is a bound method or not
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    params = []</span>
<span class="gi">+    for arg in node.args.posonlyargs:</span>
<span class="gi">+        param = Parameter(arg.arg, Parameter.POSITIONAL_ONLY, annotation=arg.type_comment)</span>
<span class="gi">+        params.append(param)</span>
<span class="gi">+</span>
<span class="gi">+    for arg in node.args.args:</span>
<span class="gi">+        param = Parameter(arg.arg, Parameter.POSITIONAL_OR_KEYWORD,</span>
<span class="gi">+                          annotation=arg.type_comment or Parameter.empty)</span>
<span class="gi">+        params.append(param)</span>
<span class="gi">+</span>
<span class="gi">+    if node.args.vararg:</span>
<span class="gi">+        param = Parameter(node.args.vararg.arg, Parameter.VAR_POSITIONAL,</span>
<span class="gi">+                          annotation=node.args.vararg.type_comment or Parameter.empty)</span>
<span class="gi">+        params.append(param)</span>
<span class="gi">+</span>
<span class="gi">+    for arg in node.args.kwonlyargs:</span>
<span class="gi">+        param = Parameter(arg.arg, Parameter.KEYWORD_ONLY,</span>
<span class="gi">+                          annotation=arg.type_comment or Parameter.empty)</span>
<span class="gi">+        params.append(param)</span>

<span class="gi">+    if node.args.kwarg:</span>
<span class="gi">+        param = Parameter(node.args.kwarg.arg, Parameter.VAR_KEYWORD,</span>
<span class="gi">+                          annotation=node.args.kwarg.type_comment or Parameter.empty)</span>
<span class="gi">+        params.append(param)</span>

<span class="gd">-def get_type_comment(obj: Any, bound_method: bool=False) -&gt;(Signature | None):</span>
<span class="gi">+    # Remove first parameter when *obj* is bound_method</span>
<span class="gi">+    if bound_method and params:</span>
<span class="gi">+        params.pop(0)</span>
<span class="gi">+</span>
<span class="gi">+    # merge type_comment into signature</span>
<span class="gi">+    if not_suppressed(type_comment.argtypes):  # type: ignore[attr-defined]</span>
<span class="gi">+        for i, param in enumerate(params):</span>
<span class="gi">+            params[i] = param.replace(</span>
<span class="gi">+                annotation=type_comment.argtypes[i])  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="gi">+    if node.returns:</span>
<span class="gi">+        return Signature(params, return_annotation=node.returns)</span>
<span class="gi">+    elif type_comment.returns:</span>
<span class="gi">+        return Signature(params, return_annotation=ast_unparse(type_comment.returns))</span>
<span class="gi">+    else:</span>
<span class="gi">+        return Signature(params)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_type_comment(obj: Any, bound_method: bool = False) -&gt; Signature | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get type_comment&#39;ed FunctionDef object from living object.

<span class="w"> </span>    This tries to parse original code for living object and returns
<span class="w"> </span>    Signature for given *obj*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        source = getsource(obj)</span>
<span class="gi">+        if source.startswith((&#39; &#39;, r&#39;\t&#39;)):</span>
<span class="gi">+            # subject is placed inside class or block.  To read its docstring,</span>
<span class="gi">+            # this adds if-block before the declaration.</span>
<span class="gi">+            module = ast.parse(&#39;if True:\n&#39; + source, type_comments=True)</span>
<span class="gi">+            subject = cast(</span>
<span class="gi">+                ast.FunctionDef, module.body[0].body[0],  # type: ignore[attr-defined]</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            module = ast.parse(source, type_comments=True)</span>
<span class="gi">+            subject = cast(ast.FunctionDef, module.body[0])</span>
<span class="gi">+</span>
<span class="gi">+        type_comment = getattr(subject, &quot;type_comment&quot;, None)</span>
<span class="gi">+        if type_comment:</span>
<span class="gi">+            function = ast.parse(type_comment, mode=&#39;func_type&#39;, type_comments=True)</span>
<span class="gi">+            return signature_from_ast(</span>
<span class="gi">+                subject, bound_method, function,  # type: ignore[arg-type]</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+    except (OSError, TypeError):  # failed to load source code</span>
<span class="gi">+        return None</span>
<span class="gi">+    except SyntaxError:  # failed to parse type_comments</span>
<span class="gi">+        return None</span>


<span class="gd">-def update_annotations_using_type_comments(app: Sphinx, obj: Any,</span>
<span class="gd">-    bound_method: bool) -&gt;None:</span>
<span class="gi">+def update_annotations_using_type_comments(app: Sphinx, obj: Any, bound_method: bool) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Update annotations info of *obj* using type_comments.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        type_sig = get_type_comment(obj, bound_method)</span>
<span class="gi">+        if type_sig:</span>
<span class="gi">+            sig = inspect.signature(obj, bound_method)</span>
<span class="gi">+            for param in sig.parameters.values():</span>
<span class="gi">+                if param.name not in obj.__annotations__:</span>
<span class="gi">+                    annotation = type_sig.parameters[param.name].annotation</span>
<span class="gi">+                    if annotation is not Parameter.empty:</span>
<span class="gi">+                        obj.__annotations__[param.name] = ast_unparse(annotation)</span>
<span class="gi">+</span>
<span class="gi">+            if &#39;return&#39; not in obj.__annotations__:</span>
<span class="gi">+                obj.__annotations__[&#39;return&#39;] = type_sig.return_annotation</span>
<span class="gi">+    except KeyError as exc:</span>
<span class="gi">+        logger.warning(__(&quot;Failed to update signature for %r: parameter not found: %s&quot;),</span>
<span class="gi">+                       obj, exc)</span>
<span class="gi">+    except NotImplementedError as exc:  # failed to ast.unparse()</span>
<span class="gi">+        logger.warning(__(&quot;Failed to parse type_comment for %r: %s&quot;), obj, exc)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.connect(&#39;autodoc-before-process-signature&#39;, update_annotations_using_type_comments)</span>
<span class="gi">+</span>
<span class="gi">+    return {&#39;version&#39;: sphinx.__display_version__, &#39;parallel_read_safe&#39;: True}</span>
<span class="gh">diff --git a/sphinx/ext/autodoc/typehints.py b/sphinx/ext/autodoc/typehints.py</span>
<span class="gh">index 97ed01df9..ed8860cb7 100644</span>
<span class="gd">--- a/sphinx/ext/autodoc/typehints.py</span>
<span class="gi">+++ b/sphinx/ext/autodoc/typehints.py</span>
<span class="gu">@@ -1,20 +1,220 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Generating content for autodoc using typehints&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from collections.abc import Iterable
<span class="w"> </span>from typing import TYPE_CHECKING, Any, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>import sphinx
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.util import inspect
<span class="w"> </span>from sphinx.util.typing import ExtensionMetadata, stringify_annotation
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.nodes import Element
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.ext.autodoc import Options


<span class="w"> </span>def record_typehints(app: Sphinx, objtype: str, name: str, obj: Any,
<span class="gd">-    options: Options, args: str, retann: str) -&gt;None:</span>
<span class="gi">+                     options: Options, args: str, retann: str) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Record type hints to env object.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if app.config.autodoc_typehints_format == &#39;short&#39;:</span>
<span class="gi">+        mode = &#39;smart&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        mode = &#39;fully-qualified&#39;</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        if callable(obj):</span>
<span class="gi">+            annotations = app.env.temp_data.setdefault(&#39;annotations&#39;, {})</span>
<span class="gi">+            annotation = annotations.setdefault(name, {})</span>
<span class="gi">+            sig = inspect.signature(obj, type_aliases=app.config.autodoc_type_aliases)</span>
<span class="gi">+            for param in sig.parameters.values():</span>
<span class="gi">+                if param.annotation is not param.empty:</span>
<span class="gi">+                    annotation[param.name] = stringify_annotation(param.annotation, mode)  # type: ignore[arg-type]</span>
<span class="gi">+            if sig.return_annotation is not sig.empty:</span>
<span class="gi">+                annotation[&#39;return&#39;] = stringify_annotation(sig.return_annotation, mode)  # type: ignore[arg-type]</span>
<span class="gi">+    except (TypeError, ValueError):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def merge_typehints(app: Sphinx, domain: str, objtype: str, contentnode: Element) -&gt; None:</span>
<span class="gi">+    if domain != &#39;py&#39;:</span>
<span class="gi">+        return</span>
<span class="gi">+    if app.config.autodoc_typehints not in (&#39;both&#39;, &#39;description&#39;):</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        signature = cast(addnodes.desc_signature, contentnode.parent[0])</span>
<span class="gi">+        if signature[&#39;module&#39;]:</span>
<span class="gi">+            fullname = f&#39;{signature[&quot;module&quot;]}.{signature[&quot;fullname&quot;]}&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            fullname = signature[&#39;fullname&#39;]</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        # signature node does not have valid context info for the target object</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    annotations = app.env.temp_data.get(&#39;annotations&#39;, {})</span>
<span class="gi">+    if annotations.get(fullname, {}):</span>
<span class="gi">+        field_lists = [n for n in contentnode if isinstance(n, nodes.field_list)]</span>
<span class="gi">+        if field_lists == []:</span>
<span class="gi">+            field_list = insert_field_list(contentnode)</span>
<span class="gi">+            field_lists.append(field_list)</span>
<span class="gi">+</span>
<span class="gi">+        for field_list in field_lists:</span>
<span class="gi">+            if app.config.autodoc_typehints_description_target == &quot;all&quot;:</span>
<span class="gi">+                if objtype == &#39;class&#39;:</span>
<span class="gi">+                    modify_field_list(field_list, annotations[fullname], suppress_rtype=True)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    modify_field_list(field_list, annotations[fullname])</span>
<span class="gi">+            elif app.config.autodoc_typehints_description_target == &quot;documented_params&quot;:</span>
<span class="gi">+                augment_descriptions_with_types(</span>
<span class="gi">+                    field_list, annotations[fullname], force_rtype=True,</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                augment_descriptions_with_types(</span>
<span class="gi">+                    field_list, annotations[fullname], force_rtype=False,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def insert_field_list(node: Element) -&gt; nodes.field_list:</span>
<span class="gi">+    field_list = nodes.field_list()</span>
<span class="gi">+    desc = [n for n in node if isinstance(n, addnodes.desc)]</span>
<span class="gi">+    if desc:</span>
<span class="gi">+        # insert just before sub object descriptions (ex. methods, nested classes, etc.)</span>
<span class="gi">+        index = node.index(desc[0])</span>
<span class="gi">+        node.insert(index - 1, [field_list])</span>
<span class="gi">+    else:</span>
<span class="gi">+        node += field_list</span>
<span class="gi">+</span>
<span class="gi">+    return field_list</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def modify_field_list(node: nodes.field_list, annotations: dict[str, str],</span>
<span class="gi">+                      suppress_rtype: bool = False) -&gt; None:</span>
<span class="gi">+    arguments: dict[str, dict[str, bool]] = {}</span>
<span class="gi">+    fields = cast(Iterable[nodes.field], node)</span>
<span class="gi">+    for field in fields:</span>
<span class="gi">+        field_name = field[0].astext()</span>
<span class="gi">+        parts = re.split(&#39; +&#39;, field_name)</span>
<span class="gi">+        if parts[0] == &#39;param&#39;:</span>
<span class="gi">+            if len(parts) == 2:</span>
<span class="gi">+                # :param xxx:</span>
<span class="gi">+                arg = arguments.setdefault(parts[1], {})</span>
<span class="gi">+                arg[&#39;param&#39;] = True</span>
<span class="gi">+            elif len(parts) &gt; 2:</span>
<span class="gi">+                # :param xxx yyy:</span>
<span class="gi">+                name = &#39; &#39;.join(parts[2:])</span>
<span class="gi">+                arg = arguments.setdefault(name, {})</span>
<span class="gi">+                arg[&#39;param&#39;] = True</span>
<span class="gi">+                arg[&#39;type&#39;] = True</span>
<span class="gi">+        elif parts[0] == &#39;type&#39;:</span>
<span class="gi">+            name = &#39; &#39;.join(parts[1:])</span>
<span class="gi">+            arg = arguments.setdefault(name, {})</span>
<span class="gi">+            arg[&#39;type&#39;] = True</span>
<span class="gi">+        elif parts[0] == &#39;rtype&#39;:</span>
<span class="gi">+            arguments[&#39;return&#39;] = {&#39;type&#39;: True}</span>
<span class="gi">+</span>
<span class="gi">+    for name, annotation in annotations.items():</span>
<span class="gi">+        if name == &#39;return&#39;:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;*&#39; + name in arguments:</span>
<span class="gi">+            name = &#39;*&#39; + name</span>
<span class="gi">+            arguments.get(name)</span>
<span class="gi">+        elif &#39;**&#39; + name in arguments:</span>
<span class="gi">+            name = &#39;**&#39; + name</span>
<span class="gi">+            arguments.get(name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            arg = arguments.get(name, {})</span>
<span class="gi">+</span>
<span class="gi">+        if not arg.get(&#39;type&#39;):</span>
<span class="gi">+            field = nodes.field()</span>
<span class="gi">+            field += nodes.field_name(&#39;&#39;, &#39;type &#39; + name)</span>
<span class="gi">+            field += nodes.field_body(&#39;&#39;, nodes.paragraph(&#39;&#39;, annotation))</span>
<span class="gi">+            node += field</span>
<span class="gi">+        if not arg.get(&#39;param&#39;):</span>
<span class="gi">+            field = nodes.field()</span>
<span class="gi">+            field += nodes.field_name(&#39;&#39;, &#39;param &#39; + name)</span>
<span class="gi">+            field += nodes.field_body(&#39;&#39;, nodes.paragraph(&#39;&#39;, &#39;&#39;))</span>
<span class="gi">+            node += field</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;return&#39; in annotations and &#39;return&#39; not in arguments:</span>
<span class="gi">+        annotation = annotations[&#39;return&#39;]</span>
<span class="gi">+        if annotation == &#39;None&#39; and suppress_rtype:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        field = nodes.field()</span>
<span class="gi">+        field += nodes.field_name(&#39;&#39;, &#39;rtype&#39;)</span>
<span class="gi">+        field += nodes.field_body(&#39;&#39;, nodes.paragraph(&#39;&#39;, annotation))</span>
<span class="gi">+        node += field</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def augment_descriptions_with_types(</span>
<span class="gi">+    node: nodes.field_list,</span>
<span class="gi">+    annotations: dict[str, str],</span>
<span class="gi">+    force_rtype: bool,</span>
<span class="gi">+) -&gt; None:</span>
<span class="gi">+    fields = cast(Iterable[nodes.field], node)</span>
<span class="gi">+    has_description: set[str] = set()</span>
<span class="gi">+    has_type: set[str] = set()</span>
<span class="gi">+    for field in fields:</span>
<span class="gi">+        field_name = field[0].astext()</span>
<span class="gi">+        parts = re.split(&#39; +&#39;, field_name)</span>
<span class="gi">+        if parts[0] == &#39;param&#39;:</span>
<span class="gi">+            if len(parts) == 2:</span>
<span class="gi">+                # :param xxx:</span>
<span class="gi">+                has_description.add(parts[1])</span>
<span class="gi">+            elif len(parts) &gt; 2:</span>
<span class="gi">+                # :param xxx yyy:</span>
<span class="gi">+                name = &#39; &#39;.join(parts[2:])</span>
<span class="gi">+                has_description.add(name)</span>
<span class="gi">+                has_type.add(name)</span>
<span class="gi">+        elif parts[0] == &#39;type&#39;:</span>
<span class="gi">+            name = &#39; &#39;.join(parts[1:])</span>
<span class="gi">+            has_type.add(name)</span>
<span class="gi">+        elif parts[0] in (&#39;return&#39;, &#39;returns&#39;):</span>
<span class="gi">+            has_description.add(&#39;return&#39;)</span>
<span class="gi">+        elif parts[0] == &#39;rtype&#39;:</span>
<span class="gi">+            has_type.add(&#39;return&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # Add &#39;type&#39; for parameters with a description but no declared type.</span>
<span class="gi">+    for name, annotation in annotations.items():</span>
<span class="gi">+        if name in (&#39;return&#39;, &#39;returns&#39;):</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;*&#39; + name in has_description:</span>
<span class="gi">+            name = &#39;*&#39; + name</span>
<span class="gi">+        elif &#39;**&#39; + name in has_description:</span>
<span class="gi">+            name = &#39;**&#39; + name</span>
<span class="gi">+</span>
<span class="gi">+        if name in has_description and name not in has_type:</span>
<span class="gi">+            field = nodes.field()</span>
<span class="gi">+            field += nodes.field_name(&#39;&#39;, &#39;type &#39; + name)</span>
<span class="gi">+            field += nodes.field_body(&#39;&#39;, nodes.paragraph(&#39;&#39;, annotation))</span>
<span class="gi">+            node += field</span>
<span class="gi">+</span>
<span class="gi">+    # Add &#39;rtype&#39; if &#39;return&#39; is present and &#39;rtype&#39; isn&#39;t.</span>
<span class="gi">+    if &#39;return&#39; in annotations:</span>
<span class="gi">+        rtype = annotations[&#39;return&#39;]</span>
<span class="gi">+        if &#39;return&#39; not in has_type and (&#39;return&#39; in has_description or</span>
<span class="gi">+                                         (force_rtype and rtype != &quot;None&quot;)):</span>
<span class="gi">+            field = nodes.field()</span>
<span class="gi">+            field += nodes.field_name(&#39;&#39;, &#39;rtype&#39;)</span>
<span class="gi">+            field += nodes.field_body(&#39;&#39;, nodes.paragraph(&#39;&#39;, rtype))</span>
<span class="gi">+            node += field</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.connect(&#39;autodoc-process-signature&#39;, record_typehints)</span>
<span class="gi">+    app.connect(&#39;object-description-transform&#39;, merge_typehints)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: sphinx.__display_version__,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/ext/autosectionlabel.py b/sphinx/ext/autosectionlabel.py</span>
<span class="gh">index c617cb79e..c1eb46bf0 100644</span>
<span class="gd">--- a/sphinx/ext/autosectionlabel.py</span>
<span class="gi">+++ b/sphinx/ext/autosectionlabel.py</span>
<span class="gu">@@ -1,14 +1,70 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Allow reference sections by :ref: role using its title.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>import sphinx
<span class="w"> </span>from sphinx.domains.std import StandardDomain
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.nodes import clean_astext
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.nodes import Node
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_node_depth(node: Node) -&gt; int:</span>
<span class="gi">+    i = 0</span>
<span class="gi">+    cur_node = node</span>
<span class="gi">+    while cur_node.parent != node.document:</span>
<span class="gi">+        cur_node = cur_node.parent</span>
<span class="gi">+        i += 1</span>
<span class="gi">+    return i</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def register_sections_as_label(app: Sphinx, document: Node) -&gt; None:</span>
<span class="gi">+    domain = cast(StandardDomain, app.env.get_domain(&#39;std&#39;))</span>
<span class="gi">+    for node in document.findall(nodes.section):</span>
<span class="gi">+        if (app.config.autosectionlabel_maxdepth and</span>
<span class="gi">+                get_node_depth(node) &gt;= app.config.autosectionlabel_maxdepth):</span>
<span class="gi">+            continue</span>
<span class="gi">+        labelid = node[&#39;ids&#39;][0]</span>
<span class="gi">+        docname = app.env.docname</span>
<span class="gi">+        title = cast(nodes.title, node[0])</span>
<span class="gi">+        ref_name = getattr(title, &#39;rawsource&#39;, title.astext())</span>
<span class="gi">+        if app.config.autosectionlabel_prefix_document:</span>
<span class="gi">+            name = nodes.fully_normalize_name(docname + &#39;:&#39; + ref_name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            name = nodes.fully_normalize_name(ref_name)</span>
<span class="gi">+        sectname = clean_astext(title)</span>
<span class="gi">+</span>
<span class="gi">+        logger.debug(__(&#39;section &quot;%s&quot; gets labeled as &quot;%s&quot;&#39;),</span>
<span class="gi">+                     ref_name, name,</span>
<span class="gi">+                     location=node, type=&#39;autosectionlabel&#39;, subtype=docname)</span>
<span class="gi">+        if name in domain.labels:</span>
<span class="gi">+            logger.warning(__(&#39;duplicate label %s, other instance in %s&#39;),</span>
<span class="gi">+                           name, app.env.doc2path(domain.labels[name][0]),</span>
<span class="gi">+                           location=node, type=&#39;autosectionlabel&#39;, subtype=docname)</span>
<span class="gi">+</span>
<span class="gi">+        domain.anonlabels[name] = docname, labelid</span>
<span class="gi">+        domain.labels[name] = docname, labelid, sectname</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_config_value(&#39;autosectionlabel_prefix_document&#39;, False, &#39;env&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;autosectionlabel_maxdepth&#39;, None, &#39;env&#39;)</span>
<span class="gi">+    app.connect(&#39;doctree-read&#39;, register_sections_as_label)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: sphinx.__display_version__,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/ext/autosummary/generate.py b/sphinx/ext/autosummary/generate.py</span>
<span class="gh">index eb7b16602..b6f31be9b 100644</span>
<span class="gd">--- a/sphinx/ext/autosummary/generate.py</span>
<span class="gi">+++ b/sphinx/ext/autosummary/generate.py</span>
<span class="gu">@@ -11,7 +11,9 @@ Example Makefile rule::</span>
<span class="w"> </span>   generate:
<span class="w"> </span>           sphinx-autogen -o source/generated source/*.rst
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import argparse
<span class="w"> </span>import importlib
<span class="w"> </span>import inspect
<span class="gu">@@ -24,15 +26,22 @@ import sys</span>
<span class="w"> </span>from os import path
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import TYPE_CHECKING, Any, NamedTuple
<span class="gi">+</span>
<span class="w"> </span>from jinja2 import TemplateNotFound
<span class="w"> </span>from jinja2.sandbox import SandboxedEnvironment
<span class="gi">+</span>
<span class="w"> </span>import sphinx.locale
<span class="w"> </span>from sphinx import __display_version__, package_dir
<span class="w"> </span>from sphinx.builders import Builder
<span class="w"> </span>from sphinx.config import Config
<span class="w"> </span>from sphinx.errors import PycodeError
<span class="w"> </span>from sphinx.ext.autodoc.importer import import_module
<span class="gd">-from sphinx.ext.autosummary import ImportExceptionGroup, get_documenter, import_by_name, import_ivar_by_name</span>
<span class="gi">+from sphinx.ext.autosummary import (</span>
<span class="gi">+    ImportExceptionGroup,</span>
<span class="gi">+    get_documenter,</span>
<span class="gi">+    import_by_name,</span>
<span class="gi">+    import_ivar_by_name,</span>
<span class="gi">+)</span>
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.pycode import ModuleAnalyzer
<span class="w"> </span>from sphinx.registry import SphinxComponentRegistry
<span class="gu">@@ -40,18 +49,21 @@ from sphinx.util import logging, rst</span>
<span class="w"> </span>from sphinx.util.inspect import getall, safe_getattr
<span class="w"> </span>from sphinx.util.osutil import ensuredir
<span class="w"> </span>from sphinx.util.template import SphinxTemplateLoader
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Sequence, Set
<span class="w"> </span>    from gettext import NullTranslations
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.ext.autodoc import Documenter
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="w"> </span>class DummyApplication:
<span class="w"> </span>    &quot;&quot;&quot;Dummy Application class for sphinx-autogen command.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, translator: NullTranslations) -&gt;None:</span>
<span class="gi">+    def __init__(self, translator: NullTranslations) -&gt; None:</span>
<span class="w"> </span>        self.config = Config()
<span class="w"> </span>        self.registry = SphinxComponentRegistry()
<span class="w"> </span>        self.messagelog: list[str] = []
<span class="gu">@@ -60,10 +72,14 @@ class DummyApplication:</span>
<span class="w"> </span>        self.verbosity = 0
<span class="w"> </span>        self._warncount = 0
<span class="w"> </span>        self._exception_on_warning = False
<span class="gi">+</span>
<span class="w"> </span>        self.config.add(&#39;autosummary_context&#39;, {}, &#39;env&#39;, ())
<span class="w"> </span>        self.config.add(&#39;autosummary_filename_map&#39;, {}, &#39;env&#39;, ())
<span class="w"> </span>        self.config.add(&#39;autosummary_ignore_module_all&#39;, True, &#39;env&#39;, bool)

<span class="gi">+    def emit_firstresult(self, *args: Any) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>

<span class="w"> </span>class AutosummaryEntry(NamedTuple):
<span class="w"> </span>    name: str
<span class="gu">@@ -72,31 +88,82 @@ class AutosummaryEntry(NamedTuple):</span>
<span class="w"> </span>    recursive: bool


<span class="gi">+def setup_documenters(app: Any) -&gt; None:</span>
<span class="gi">+    from sphinx.ext.autodoc import (</span>
<span class="gi">+        AttributeDocumenter,</span>
<span class="gi">+        ClassDocumenter,</span>
<span class="gi">+        DataDocumenter,</span>
<span class="gi">+        DecoratorDocumenter,</span>
<span class="gi">+        ExceptionDocumenter,</span>
<span class="gi">+        FunctionDocumenter,</span>
<span class="gi">+        MethodDocumenter,</span>
<span class="gi">+        ModuleDocumenter,</span>
<span class="gi">+        PropertyDocumenter,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    documenters: list[type[Documenter]] = [</span>
<span class="gi">+        ModuleDocumenter,</span>
<span class="gi">+        ClassDocumenter,</span>
<span class="gi">+        ExceptionDocumenter,</span>
<span class="gi">+        DataDocumenter,</span>
<span class="gi">+        FunctionDocumenter,</span>
<span class="gi">+        MethodDocumenter,</span>
<span class="gi">+        AttributeDocumenter,</span>
<span class="gi">+        DecoratorDocumenter,</span>
<span class="gi">+        PropertyDocumenter,</span>
<span class="gi">+    ]</span>
<span class="gi">+    for documenter in documenters:</span>
<span class="gi">+        app.registry.add_documenter(documenter.objtype, documenter)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _underline(title: str, line: str = &#39;=&#39;) -&gt; str:</span>
<span class="gi">+    if &#39;\n&#39; in title:</span>
<span class="gi">+        msg = &#39;Can only underline single lines&#39;</span>
<span class="gi">+        raise ValueError(msg)</span>
<span class="gi">+    return title + &#39;\n&#39; + line * len(title)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class AutosummaryRenderer:
<span class="w"> </span>    &quot;&quot;&quot;A helper class for rendering.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, app: Sphinx) -&gt;None:</span>
<span class="gi">+    def __init__(self, app: Sphinx) -&gt; None:</span>
<span class="w"> </span>        if isinstance(app, Builder):
<span class="w"> </span>            msg = &#39;Expected a Sphinx application object!&#39;
<span class="w"> </span>            raise ValueError(msg)
<span class="gd">-        system_templates_path = [os.path.join(package_dir, &#39;ext&#39;,</span>
<span class="gd">-            &#39;autosummary&#39;, &#39;templates&#39;)]</span>
<span class="gd">-        loader = SphinxTemplateLoader(app.srcdir, app.config.templates_path,</span>
<span class="gd">-            system_templates_path)</span>
<span class="gi">+</span>
<span class="gi">+        system_templates_path = [</span>
<span class="gi">+            os.path.join(package_dir, &#39;ext&#39;, &#39;autosummary&#39;, &#39;templates&#39;)</span>
<span class="gi">+        ]</span>
<span class="gi">+        loader = SphinxTemplateLoader(</span>
<span class="gi">+            app.srcdir, app.config.templates_path, system_templates_path</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        self.env = SandboxedEnvironment(loader=loader)
<span class="w"> </span>        self.env.filters[&#39;escape&#39;] = rst.escape
<span class="w"> </span>        self.env.filters[&#39;e&#39;] = rst.escape
<span class="w"> </span>        self.env.filters[&#39;underline&#39;] = _underline
<span class="gi">+</span>
<span class="w"> </span>        if app.translator:
<span class="w"> </span>            self.env.add_extension(&#39;jinja2.ext.i18n&#39;)
<span class="gd">-            self.env.install_gettext_translations(app.translator)</span>
<span class="gi">+            # ``install_gettext_translations`` is injected by the ``jinja2.ext.i18n`` extension</span>
<span class="gi">+            self.env.install_gettext_translations(app.translator)  # type: ignore[attr-defined]</span>

<span class="gd">-    def render(self, template_name: str, context: dict[str, Any]) -&gt;str:</span>
<span class="gi">+    def render(self, template_name: str, context: dict[str, Any]) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Render a template file.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            template = self.env.get_template(template_name)</span>
<span class="gi">+        except TemplateNotFound:</span>
<span class="gi">+            try:</span>
<span class="gi">+                # objtype is given as template_name</span>
<span class="gi">+                template = self.env.get_template(&#39;autosummary/%s.rst&#39; % template_name)</span>
<span class="gi">+            except TemplateNotFound:</span>
<span class="gi">+                # fallback to base.rst</span>
<span class="gi">+                template = self.env.get_template(&#39;autosummary/base.rst&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        return template.render(context)</span>


<span class="gd">-def _split_full_qualified_name(name: str) -&gt;tuple[str | None, str]:</span>
<span class="gi">+def _split_full_qualified_name(name: str) -&gt; tuple[str | None, str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Split full qualified name to a pair of modname and qualname.

<span class="w"> </span>    A qualname is an abbreviation for &quot;Qualified name&quot; introduced at PEP-3155
<span class="gu">@@ -110,59 +177,500 @@ def _split_full_qualified_name(name: str) -&gt;tuple[str | None, str]:</span>
<span class="w"> </span>              Therefore you need to mock 3rd party modules if needed before
<span class="w"> </span>              calling this function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parts = name.split(&#39;.&#39;)</span>
<span class="gi">+    for i, _part in enumerate(parts, 1):</span>
<span class="gi">+        try:</span>
<span class="gi">+            modname = &#39;.&#39;.join(parts[:i])</span>
<span class="gi">+            importlib.import_module(modname)</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            if parts[: i - 1]:</span>
<span class="gi">+                return &#39;.&#39;.join(parts[: i - 1]), &#39;.&#39;.join(parts[i - 1 :])</span>
<span class="gi">+            else:</span>
<span class="gi">+                return None, &#39;.&#39;.join(parts)</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            pass</span>

<span class="gi">+    return name, &#39;&#39;</span>

<span class="gd">-class ModuleScanner:</span>

<span class="gd">-    def __init__(self, app: Any, obj: Any) -&gt;None:</span>
<span class="gi">+# -- Generating output ---------------------------------------------------------</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class ModuleScanner:</span>
<span class="gi">+    def __init__(self, app: Any, obj: Any) -&gt; None:</span>
<span class="w"> </span>        self.app = app
<span class="w"> </span>        self.object = obj

<span class="gd">-</span>
<span class="gd">-def members_of(obj: Any, conf: Config) -&gt;Sequence[str]:</span>
<span class="gi">+    def get_object_type(self, name: str, value: Any) -&gt; str:</span>
<span class="gi">+        return get_documenter(self.app, value, self.object).objtype</span>
<span class="gi">+</span>
<span class="gi">+    def is_skipped(self, name: str, value: Any, objtype: str) -&gt; bool:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.app.emit_firstresult(</span>
<span class="gi">+                &#39;autodoc-skip-member&#39;, objtype, name, value, False, {}</span>
<span class="gi">+            )</span>
<span class="gi">+        except Exception as exc:</span>
<span class="gi">+            logger.warning(</span>
<span class="gi">+                __(</span>
<span class="gi">+                    &#39;autosummary: failed to determine %r to be documented, &#39;</span>
<span class="gi">+                    &#39;the following exception was raised:\n%s&#39;</span>
<span class="gi">+                ),</span>
<span class="gi">+                name,</span>
<span class="gi">+                exc,</span>
<span class="gi">+                type=&#39;autosummary&#39;,</span>
<span class="gi">+            )</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    def scan(self, imported_members: bool) -&gt; list[str]:</span>
<span class="gi">+        members = []</span>
<span class="gi">+        try:</span>
<span class="gi">+            analyzer = ModuleAnalyzer.for_module(self.object.__name__)</span>
<span class="gi">+            attr_docs = analyzer.find_attr_docs()</span>
<span class="gi">+        except PycodeError:</span>
<span class="gi">+            attr_docs = {}</span>
<span class="gi">+</span>
<span class="gi">+        for name in members_of(self.object, self.app.config):</span>
<span class="gi">+            try:</span>
<span class="gi">+                value = safe_getattr(self.object, name)</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                value = None</span>
<span class="gi">+</span>
<span class="gi">+            objtype = self.get_object_type(name, value)</span>
<span class="gi">+            if self.is_skipped(name, value, objtype):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                if (&#39;&#39;, name) in attr_docs:</span>
<span class="gi">+                    imported = False</span>
<span class="gi">+                elif inspect.ismodule(value):  # NoQA: SIM114</span>
<span class="gi">+                    imported = True</span>
<span class="gi">+                elif safe_getattr(value, &#39;__module__&#39;) != self.object.__name__:</span>
<span class="gi">+                    imported = True</span>
<span class="gi">+                else:</span>
<span class="gi">+                    imported = False</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                imported = False</span>
<span class="gi">+</span>
<span class="gi">+            respect_module_all = not self.app.config.autosummary_ignore_module_all</span>
<span class="gi">+            if (</span>
<span class="gi">+                # list all members up</span>
<span class="gi">+                imported_members</span>
<span class="gi">+                # list not-imported members</span>
<span class="gi">+                or imported is False</span>
<span class="gi">+                # list members that have __all__ set</span>
<span class="gi">+                or (respect_module_all and &#39;__all__&#39; in dir(self.object))</span>
<span class="gi">+            ):</span>
<span class="gi">+                members.append(name)</span>
<span class="gi">+</span>
<span class="gi">+        return members</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def members_of(obj: Any, conf: Config) -&gt; Sequence[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the members of ``obj``, possibly ignoring the ``__all__`` module attribute

<span class="w"> </span>    Follows the ``conf.autosummary_ignore_module_all`` setting.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _get_module_attrs(name: str, members: Any) -&gt;tuple[list[str], list[str]]:</span>
<span class="gi">+    if conf.autosummary_ignore_module_all:</span>
<span class="gi">+        return dir(obj)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return getall(obj) or dir(obj)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def generate_autosummary_content(</span>
<span class="gi">+    name: str,</span>
<span class="gi">+    obj: Any,</span>
<span class="gi">+    parent: Any,</span>
<span class="gi">+    template: AutosummaryRenderer,</span>
<span class="gi">+    template_name: str,</span>
<span class="gi">+    imported_members: bool,</span>
<span class="gi">+    app: Any,</span>
<span class="gi">+    recursive: bool,</span>
<span class="gi">+    context: dict[str, Any],</span>
<span class="gi">+    modname: str | None = None,</span>
<span class="gi">+    qualname: str | None = None,</span>
<span class="gi">+) -&gt; str:</span>
<span class="gi">+    doc = get_documenter(app, obj, parent)</span>
<span class="gi">+</span>
<span class="gi">+    ns: dict[str, Any] = {}</span>
<span class="gi">+    ns.update(context)</span>
<span class="gi">+</span>
<span class="gi">+    if doc.objtype == &#39;module&#39;:</span>
<span class="gi">+        scanner = ModuleScanner(app, obj)</span>
<span class="gi">+        ns[&#39;members&#39;] = scanner.scan(imported_members)</span>
<span class="gi">+</span>
<span class="gi">+        respect_module_all = not app.config.autosummary_ignore_module_all</span>
<span class="gi">+        imported_members = imported_members or (</span>
<span class="gi">+            &#39;__all__&#39; in dir(obj) and respect_module_all</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        ns[&#39;functions&#39;], ns[&#39;all_functions&#39;] = _get_members(</span>
<span class="gi">+            doc, app, obj, {&#39;function&#39;}, imported=imported_members</span>
<span class="gi">+        )</span>
<span class="gi">+        ns[&#39;classes&#39;], ns[&#39;all_classes&#39;] = _get_members(</span>
<span class="gi">+            doc, app, obj, {&#39;class&#39;}, imported=imported_members</span>
<span class="gi">+        )</span>
<span class="gi">+        ns[&#39;exceptions&#39;], ns[&#39;all_exceptions&#39;] = _get_members(</span>
<span class="gi">+            doc, app, obj, {&#39;exception&#39;}, imported=imported_members</span>
<span class="gi">+        )</span>
<span class="gi">+        ns[&#39;attributes&#39;], ns[&#39;all_attributes&#39;] = _get_module_attrs(name, ns[&#39;members&#39;])</span>
<span class="gi">+        ispackage = hasattr(obj, &#39;__path__&#39;)</span>
<span class="gi">+        if ispackage and recursive:</span>
<span class="gi">+            # Use members that are not modules as skip list, because it would then mean</span>
<span class="gi">+            # that module was overwritten in the package namespace</span>
<span class="gi">+            skip = (</span>
<span class="gi">+                ns[&#39;all_functions&#39;]</span>
<span class="gi">+                + ns[&#39;all_classes&#39;]</span>
<span class="gi">+                + ns[&#39;all_exceptions&#39;]</span>
<span class="gi">+                + ns[&#39;all_attributes&#39;]</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            # If respect_module_all and module has a __all__ attribute, first get</span>
<span class="gi">+            # modules that were explicitly imported. Next, find the rest with the</span>
<span class="gi">+            # get_modules method, but only put in &quot;public&quot; modules that are in the</span>
<span class="gi">+            # __all__ list</span>
<span class="gi">+            #</span>
<span class="gi">+            # Otherwise, use get_modules method normally</span>
<span class="gi">+            if respect_module_all and &#39;__all__&#39; in dir(obj):</span>
<span class="gi">+                imported_modules, all_imported_modules = _get_members(</span>
<span class="gi">+                    doc, app, obj, {&#39;module&#39;}, imported=True</span>
<span class="gi">+                )</span>
<span class="gi">+                skip += all_imported_modules</span>
<span class="gi">+                public_members = getall(obj)</span>
<span class="gi">+            else:</span>
<span class="gi">+                imported_modules, all_imported_modules = [], []</span>
<span class="gi">+                public_members = None</span>
<span class="gi">+</span>
<span class="gi">+            modules, all_modules = _get_modules(</span>
<span class="gi">+                obj, skip=skip, name=name, public_members=public_members</span>
<span class="gi">+            )</span>
<span class="gi">+            ns[&#39;modules&#39;] = imported_modules + modules</span>
<span class="gi">+            ns[&#39;all_modules&#39;] = all_imported_modules + all_modules</span>
<span class="gi">+    elif doc.objtype == &#39;class&#39;:</span>
<span class="gi">+        ns[&#39;members&#39;] = dir(obj)</span>
<span class="gi">+        ns[&#39;inherited_members&#39;] = set(dir(obj)) - set(obj.__dict__.keys())</span>
<span class="gi">+        ns[&#39;methods&#39;], ns[&#39;all_methods&#39;] = _get_members(</span>
<span class="gi">+            doc, app, obj, {&#39;method&#39;}, include_public={&#39;__init__&#39;}</span>
<span class="gi">+        )</span>
<span class="gi">+        ns[&#39;attributes&#39;], ns[&#39;all_attributes&#39;] = _get_members(</span>
<span class="gi">+            doc, app, obj, {&#39;attribute&#39;, &#39;property&#39;}</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if modname is None or qualname is None:</span>
<span class="gi">+        modname, qualname = _split_full_qualified_name(name)</span>
<span class="gi">+</span>
<span class="gi">+    if doc.objtype in (&#39;method&#39;, &#39;attribute&#39;, &#39;property&#39;):</span>
<span class="gi">+        ns[&#39;class&#39;] = qualname.rsplit(&#39;.&#39;, 1)[0]</span>
<span class="gi">+</span>
<span class="gi">+    if doc.objtype == &#39;class&#39;:</span>
<span class="gi">+        shortname = qualname</span>
<span class="gi">+    else:</span>
<span class="gi">+        shortname = qualname.rsplit(&#39;.&#39;, 1)[-1]</span>
<span class="gi">+</span>
<span class="gi">+    ns[&#39;fullname&#39;] = name</span>
<span class="gi">+    ns[&#39;module&#39;] = modname</span>
<span class="gi">+    ns[&#39;objname&#39;] = qualname</span>
<span class="gi">+    ns[&#39;name&#39;] = shortname</span>
<span class="gi">+</span>
<span class="gi">+    ns[&#39;objtype&#39;] = doc.objtype</span>
<span class="gi">+    ns[&#39;underline&#39;] = len(name) * &#39;=&#39;</span>
<span class="gi">+</span>
<span class="gi">+    if template_name:</span>
<span class="gi">+        return template.render(template_name, ns)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return template.render(doc.objtype, ns)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _skip_member(app: Sphinx, obj: Any, name: str, objtype: str) -&gt; bool:</span>
<span class="gi">+    try:</span>
<span class="gi">+        return app.emit_firstresult(</span>
<span class="gi">+            &#39;autodoc-skip-member&#39;, objtype, name, obj, False, {}</span>
<span class="gi">+        )</span>
<span class="gi">+    except Exception as exc:</span>
<span class="gi">+        logger.warning(</span>
<span class="gi">+            __(</span>
<span class="gi">+                &#39;autosummary: failed to determine %r to be documented, &#39;</span>
<span class="gi">+                &#39;the following exception was raised:\n%s&#39;</span>
<span class="gi">+            ),</span>
<span class="gi">+            name,</span>
<span class="gi">+            exc,</span>
<span class="gi">+            type=&#39;autosummary&#39;,</span>
<span class="gi">+        )</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_class_members(obj: Any) -&gt; dict[str, Any]:</span>
<span class="gi">+    members = sphinx.ext.autodoc.importer.get_class_members(obj, None, safe_getattr)</span>
<span class="gi">+    return {name: member.object for name, member in members.items()}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_module_members(app: Sphinx, obj: Any) -&gt; dict[str, Any]:</span>
<span class="gi">+    members = {}</span>
<span class="gi">+    for name in members_of(obj, app.config):</span>
<span class="gi">+        try:</span>
<span class="gi">+            members[name] = safe_getattr(obj, name)</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            continue</span>
<span class="gi">+    return members</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_all_members(doc: type[Documenter], app: Sphinx, obj: Any) -&gt; dict[str, Any]:</span>
<span class="gi">+    if doc.objtype == &#39;module&#39;:</span>
<span class="gi">+        return _get_module_members(app, obj)</span>
<span class="gi">+    elif doc.objtype == &#39;class&#39;:</span>
<span class="gi">+        return _get_class_members(obj)</span>
<span class="gi">+    return {}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_members(</span>
<span class="gi">+    doc: type[Documenter],</span>
<span class="gi">+    app: Sphinx,</span>
<span class="gi">+    obj: Any,</span>
<span class="gi">+    types: set[str],</span>
<span class="gi">+    *,</span>
<span class="gi">+    include_public: Set[str] = frozenset(),</span>
<span class="gi">+    imported: bool = True,</span>
<span class="gi">+) -&gt; tuple[list[str], list[str]]:</span>
<span class="gi">+    items: list[str] = []</span>
<span class="gi">+    public: list[str] = []</span>
<span class="gi">+</span>
<span class="gi">+    all_members = _get_all_members(doc, app, obj)</span>
<span class="gi">+    for name, value in all_members.items():</span>
<span class="gi">+        documenter = get_documenter(app, value, obj)</span>
<span class="gi">+        if documenter.objtype in types:</span>
<span class="gi">+            # skip imported members if expected</span>
<span class="gi">+            if imported or getattr(value, &#39;__module__&#39;, None) == obj.__name__:</span>
<span class="gi">+                skipped = _skip_member(app, value, name, documenter.objtype)</span>
<span class="gi">+                if skipped is True:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                elif skipped is False:</span>
<span class="gi">+                    # show the member forcedly</span>
<span class="gi">+                    items.append(name)</span>
<span class="gi">+                    public.append(name)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    items.append(name)</span>
<span class="gi">+                    if name in include_public or not name.startswith(&#39;_&#39;):</span>
<span class="gi">+                        # considers member as public</span>
<span class="gi">+                        public.append(name)</span>
<span class="gi">+    return public, items</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_module_attrs(name: str, members: Any) -&gt; tuple[list[str], list[str]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Find module attributes with docstrings.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def generate_autosummary_docs(sources: list[str], output_dir: (str | os.</span>
<span class="gd">-    PathLike[str] | None)=None, suffix: str=&#39;.rst&#39;, base_path: (str | os.</span>
<span class="gd">-    PathLike[str] | None)=None, imported_members: bool=False, app: (Sphinx |</span>
<span class="gd">-    None)=None, overwrite: bool=True, encoding: str=&#39;utf-8&#39;) -&gt;list[Path]:</span>
<span class="gi">+    attrs, public = [], []</span>
<span class="gi">+    try:</span>
<span class="gi">+        analyzer = ModuleAnalyzer.for_module(name)</span>
<span class="gi">+        attr_docs = analyzer.find_attr_docs()</span>
<span class="gi">+        for namespace, attr_name in attr_docs:</span>
<span class="gi">+            if namespace == &#39;&#39; and attr_name in members:</span>
<span class="gi">+                attrs.append(attr_name)</span>
<span class="gi">+                if not attr_name.startswith(&#39;_&#39;):</span>
<span class="gi">+                    public.append(attr_name)</span>
<span class="gi">+    except PycodeError:</span>
<span class="gi">+        pass  # give up if ModuleAnalyzer fails to parse code</span>
<span class="gi">+    return public, attrs</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _get_modules(</span>
<span class="gi">+    obj: Any,</span>
<span class="gi">+    *,</span>
<span class="gi">+    skip: Sequence[str],</span>
<span class="gi">+    name: str,</span>
<span class="gi">+    public_members: Sequence[str] | None = None,</span>
<span class="gi">+) -&gt; tuple[list[str], list[str]]:</span>
<span class="gi">+    items: list[str] = []</span>
<span class="gi">+    public: list[str] = []</span>
<span class="gi">+    for _, modname, _ispkg in pkgutil.iter_modules(obj.__path__):</span>
<span class="gi">+        if modname in skip:</span>
<span class="gi">+            # module was overwritten in __init__.py, so not accessible</span>
<span class="gi">+            continue</span>
<span class="gi">+        fullname = f&#39;{name}.{modname}&#39;</span>
<span class="gi">+        try:</span>
<span class="gi">+            module = import_module(fullname)</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            if module and hasattr(module, &#39;__sphinx_mock__&#39;):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+        items.append(modname)</span>
<span class="gi">+        if public_members is not None:</span>
<span class="gi">+            if modname in public_members:</span>
<span class="gi">+                public.append(modname)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if not modname.startswith(&#39;_&#39;):</span>
<span class="gi">+                public.append(modname)</span>
<span class="gi">+    return public, items</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def generate_autosummary_docs(</span>
<span class="gi">+    sources: list[str],</span>
<span class="gi">+    output_dir: str | os.PathLike[str] | None = None,</span>
<span class="gi">+    suffix: str = &#39;.rst&#39;,</span>
<span class="gi">+    base_path: str | os.PathLike[str] | None = None,</span>
<span class="gi">+    imported_members: bool = False,</span>
<span class="gi">+    app: Sphinx | None = None,</span>
<span class="gi">+    overwrite: bool = True,</span>
<span class="gi">+    encoding: str = &#39;utf-8&#39;,</span>
<span class="gi">+) -&gt; list[Path]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate autosummary documentation for the given sources.

<span class="w"> </span>    :returns: list of generated files (both new and existing ones)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def find_autosummary_in_files(filenames: list[str]) -&gt;list[AutosummaryEntry]:</span>
<span class="gi">+    assert app is not None, &#39;app is required&#39;</span>
<span class="gi">+</span>
<span class="gi">+    showed_sources = sorted(sources)</span>
<span class="gi">+    if len(showed_sources) &gt; 20:</span>
<span class="gi">+        showed_sources = showed_sources[:10] + [&#39;...&#39;] + showed_sources[-10:]</span>
<span class="gi">+    logger.info(</span>
<span class="gi">+        __(&#39;[autosummary] generating autosummary for: %s&#39;), &#39;, &#39;.join(showed_sources)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if output_dir:</span>
<span class="gi">+        logger.info(__(&#39;[autosummary] writing to %s&#39;), output_dir)</span>
<span class="gi">+</span>
<span class="gi">+    if base_path is not None:</span>
<span class="gi">+        sources = [os.path.join(base_path, filename) for filename in sources]</span>
<span class="gi">+</span>
<span class="gi">+    template = AutosummaryRenderer(app)</span>
<span class="gi">+</span>
<span class="gi">+    # read</span>
<span class="gi">+    items = find_autosummary_in_files(sources)</span>
<span class="gi">+</span>
<span class="gi">+    # keep track of new files</span>
<span class="gi">+    new_files: list[Path] = []</span>
<span class="gi">+    all_files: list[Path] = []</span>
<span class="gi">+</span>
<span class="gi">+    filename_map = app.config.autosummary_filename_map</span>
<span class="gi">+</span>
<span class="gi">+    # write</span>
<span class="gi">+    for entry in sorted(set(items), key=str):</span>
<span class="gi">+        if entry.path is None:</span>
<span class="gi">+            # The corresponding autosummary:: directive did not have</span>
<span class="gi">+            # a :toctree: option</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        path = output_dir or os.path.abspath(entry.path)</span>
<span class="gi">+        ensuredir(path)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            name, obj, parent, modname = import_by_name(entry.name)</span>
<span class="gi">+            qualname = name.replace(modname + &#39;.&#39;, &#39;&#39;)</span>
<span class="gi">+        except ImportExceptionGroup as exc:</span>
<span class="gi">+            try:</span>
<span class="gi">+                # try to import as an instance attribute</span>
<span class="gi">+                name, obj, parent, modname = import_ivar_by_name(entry.name)</span>
<span class="gi">+                qualname = name.replace(modname + &#39;.&#39;, &#39;&#39;)</span>
<span class="gi">+            except ImportError as exc2:</span>
<span class="gi">+                if exc2.__cause__:</span>
<span class="gi">+                    exceptions: list[BaseException] = [*exc.exceptions, exc2.__cause__]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    exceptions = [*exc.exceptions, exc2]</span>
<span class="gi">+</span>
<span class="gi">+                errors = list({f&#39;* {type(e).__name__}: {e}&#39; for e in exceptions})</span>
<span class="gi">+                logger.warning(</span>
<span class="gi">+                    __(&#39;[autosummary] failed to import %s.\nPossible hints:\n%s&#39;),</span>
<span class="gi">+                    entry.name,</span>
<span class="gi">+                    &#39;\n&#39;.join(errors),</span>
<span class="gi">+                )</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+        context: dict[str, Any] = {**app.config.autosummary_context}</span>
<span class="gi">+</span>
<span class="gi">+        content = generate_autosummary_content(</span>
<span class="gi">+            name,</span>
<span class="gi">+            obj,</span>
<span class="gi">+            parent,</span>
<span class="gi">+            template,</span>
<span class="gi">+            entry.template,</span>
<span class="gi">+            imported_members,</span>
<span class="gi">+            app,</span>
<span class="gi">+            entry.recursive,</span>
<span class="gi">+            context,</span>
<span class="gi">+            modname,</span>
<span class="gi">+            qualname,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        file_path = Path(path, filename_map.get(name, name) + suffix)</span>
<span class="gi">+        all_files.append(file_path)</span>
<span class="gi">+        if file_path.is_file():</span>
<span class="gi">+            with file_path.open(encoding=encoding) as f:</span>
<span class="gi">+                old_content = f.read()</span>
<span class="gi">+</span>
<span class="gi">+            if content == old_content:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if overwrite:  # content has changed</span>
<span class="gi">+                with file_path.open(&#39;w&#39;, encoding=encoding) as f:</span>
<span class="gi">+                    f.write(content)</span>
<span class="gi">+                new_files.append(file_path)</span>
<span class="gi">+        else:</span>
<span class="gi">+            with open(file_path, &#39;w&#39;, encoding=encoding) as f:</span>
<span class="gi">+                f.write(content)</span>
<span class="gi">+            new_files.append(file_path)</span>
<span class="gi">+</span>
<span class="gi">+    # descend recursively to new files</span>
<span class="gi">+    if new_files:</span>
<span class="gi">+        all_files.extend(</span>
<span class="gi">+            generate_autosummary_docs(</span>
<span class="gi">+                [str(f) for f in new_files],</span>
<span class="gi">+                output_dir=output_dir,</span>
<span class="gi">+                suffix=suffix,</span>
<span class="gi">+                base_path=base_path,</span>
<span class="gi">+                imported_members=imported_members,</span>
<span class="gi">+                app=app,</span>
<span class="gi">+                overwrite=overwrite,</span>
<span class="gi">+            )</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return all_files</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# -- Finding documented entries in files ---------------------------------------</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def find_autosummary_in_files(filenames: list[str]) -&gt; list[AutosummaryEntry]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Find out what items are documented in source/*.rst.

<span class="w"> </span>    See `find_autosummary_in_lines`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def find_autosummary_in_docstring(name: str, filename: (str | None)=None</span>
<span class="gd">-    ) -&gt;list[AutosummaryEntry]:</span>
<span class="gi">+    documented: list[AutosummaryEntry] = []</span>
<span class="gi">+    for filename in filenames:</span>
<span class="gi">+        with open(filename, encoding=&#39;utf-8&#39;, errors=&#39;ignore&#39;) as f:</span>
<span class="gi">+            lines = f.read().splitlines()</span>
<span class="gi">+            documented.extend(find_autosummary_in_lines(lines, filename=filename))</span>
<span class="gi">+    return documented</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def find_autosummary_in_docstring(</span>
<span class="gi">+    name: str,</span>
<span class="gi">+    filename: str | None = None,</span>
<span class="gi">+) -&gt; list[AutosummaryEntry]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Find out what items are documented in the given object&#39;s docstring.

<span class="w"> </span>    See `find_autosummary_in_lines`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def find_autosummary_in_lines(lines: list[str], module: (str | None)=None,</span>
<span class="gd">-    filename: (str | None)=None) -&gt;list[AutosummaryEntry]:</span>
<span class="gi">+    try:</span>
<span class="gi">+        real_name, obj, parent, modname = import_by_name(name)</span>
<span class="gi">+        lines = pydoc.getdoc(obj).splitlines()</span>
<span class="gi">+        return find_autosummary_in_lines(lines, module=name, filename=filename)</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        pass</span>
<span class="gi">+    except ImportExceptionGroup as exc:</span>
<span class="gi">+        errors = &#39;\n&#39;.join({f&#39;* {type(e).__name__}: {e}&#39; for e in exc.exceptions})</span>
<span class="gi">+        logger.warning(f&#39;Failed to import {name}.\nPossible hints:\n{errors}&#39;)  # NoQA: G004</span>
<span class="gi">+    except SystemExit:</span>
<span class="gi">+        logger.warning(</span>
<span class="gi">+            &quot;Failed to import &#39;%s&#39;; the module executes module level &quot;</span>
<span class="gi">+            &#39;statement and it might call sys.exit().&#39;,</span>
<span class="gi">+            name,</span>
<span class="gi">+        )</span>
<span class="gi">+    return []</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def find_autosummary_in_lines(</span>
<span class="gi">+    lines: list[str],</span>
<span class="gi">+    module: str | None = None,</span>
<span class="gi">+    filename: str | None = None,</span>
<span class="gi">+) -&gt; list[AutosummaryEntry]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Find out what items appear in autosummary:: directives in the
<span class="w"> </span>    given lines.

<span class="gu">@@ -173,7 +681,203 @@ def find_autosummary_in_lines(lines: list[str], module: (str | None)=None,</span>
<span class="w"> </span>    *template* ``None`` if the directive does not have the
<span class="w"> </span>    corresponding options set.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    autosummary_re = re.compile(r&#39;^(\s*)\.\.\s+autosummary::\s*&#39;)</span>
<span class="gi">+    automodule_re = re.compile(r&#39;^\s*\.\.\s+automodule::\s*([A-Za-z0-9_.]+)\s*$&#39;)</span>
<span class="gi">+    module_re = re.compile(r&#39;^\s*\.\.\s+(current)?module::\s*([a-zA-Z0-9_.]+)\s*$&#39;)</span>
<span class="gi">+    autosummary_item_re = re.compile(r&#39;^\s+(~?[_a-zA-Z][a-zA-Z0-9_.]*)\s*.*?&#39;)</span>
<span class="gi">+    recursive_arg_re = re.compile(r&#39;^\s+:recursive:\s*$&#39;)</span>
<span class="gi">+    toctree_arg_re = re.compile(r&#39;^\s+:toctree:\s*(.*?)\s*$&#39;)</span>
<span class="gi">+    template_arg_re = re.compile(r&#39;^\s+:template:\s*(.*?)\s*$&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    documented: list[AutosummaryEntry] = []</span>
<span class="gi">+</span>
<span class="gi">+    recursive = False</span>
<span class="gi">+    toctree: str | None = None</span>
<span class="gi">+    template = &#39;&#39;</span>
<span class="gi">+    current_module = module</span>
<span class="gi">+    in_autosummary = False</span>
<span class="gi">+    base_indent = &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    for line in lines:</span>
<span class="gi">+        if in_autosummary:</span>
<span class="gi">+            m = recursive_arg_re.match(line)</span>
<span class="gi">+            if m:</span>
<span class="gi">+                recursive = True</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            m = toctree_arg_re.match(line)</span>
<span class="gi">+            if m:</span>
<span class="gi">+                toctree = m.group(1)</span>
<span class="gi">+                if filename:</span>
<span class="gi">+                    toctree = os.path.join(os.path.dirname(filename), toctree)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            m = template_arg_re.match(line)</span>
<span class="gi">+            if m:</span>
<span class="gi">+                template = m.group(1).strip()</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if line.strip().startswith(&#39;:&#39;):</span>
<span class="gi">+                continue  # skip options</span>
<span class="gi">+</span>
<span class="gi">+            m = autosummary_item_re.match(line)</span>
<span class="gi">+            if m:</span>
<span class="gi">+                name = m.group(1).strip()</span>
<span class="gi">+                if name.startswith(&#39;~&#39;):</span>
<span class="gi">+                    name = name[1:]</span>
<span class="gi">+                if current_module and not name.startswith(current_module + &#39;.&#39;):</span>
<span class="gi">+                    name = f&#39;{current_module}.{name}&#39;</span>
<span class="gi">+                documented.append(AutosummaryEntry(name, toctree, template, recursive))</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if not line.strip() or line.startswith(base_indent + &#39; &#39;):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            in_autosummary = False</span>
<span class="gi">+</span>
<span class="gi">+        m = autosummary_re.match(line)</span>
<span class="gi">+        if m:</span>
<span class="gi">+            in_autosummary = True</span>
<span class="gi">+            base_indent = m.group(1)</span>
<span class="gi">+            recursive = False</span>
<span class="gi">+            toctree = None</span>
<span class="gi">+            template = &#39;&#39;</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        m = automodule_re.search(line)</span>
<span class="gi">+        if m:</span>
<span class="gi">+            current_module = m.group(1).strip()</span>
<span class="gi">+            # recurse into the automodule docstring</span>
<span class="gi">+            documented.extend(</span>
<span class="gi">+                find_autosummary_in_docstring(current_module, filename=filename)</span>
<span class="gi">+            )</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        m = module_re.match(line)</span>
<span class="gi">+        if m:</span>
<span class="gi">+            current_module = m.group(2)</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+    return documented</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_parser() -&gt; argparse.ArgumentParser:</span>
<span class="gi">+    parser = argparse.ArgumentParser(</span>
<span class="gi">+        usage=&#39;%(prog)s [OPTIONS] &lt;SOURCE_FILE&gt;...&#39;,</span>
<span class="gi">+        epilog=__(&#39;For more information, visit &lt;https://www.sphinx-doc.org/&gt;.&#39;),</span>
<span class="gi">+        description=__(&quot;&quot;&quot;</span>
<span class="gi">+Generate ReStructuredText using autosummary directives.</span>
<span class="gi">+</span>
<span class="gi">+sphinx-autogen is a frontend to sphinx.ext.autosummary.generate. It generates</span>
<span class="gi">+the reStructuredText files from the autosummary directives contained in the</span>
<span class="gi">+given input files.</span>
<span class="gi">+</span>
<span class="gi">+The format of the autosummary directive is documented in the</span>
<span class="gi">+``sphinx.ext.autosummary`` Python module and can be read using::</span>
<span class="gi">+</span>
<span class="gi">+  pydoc sphinx.ext.autosummary</span>
<span class="gi">+&quot;&quot;&quot;),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;--version&#39;,</span>
<span class="gi">+        action=&#39;version&#39;,</span>
<span class="gi">+        dest=&#39;show_version&#39;,</span>
<span class="gi">+        version=&#39;%%(prog)s %s&#39; % __display_version__,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;source_file&#39;, nargs=&#39;+&#39;, help=__(&#39;source files to generate rST files for&#39;)</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;-o&#39;,</span>
<span class="gi">+        &#39;--output-dir&#39;,</span>
<span class="gi">+        action=&#39;store&#39;,</span>
<span class="gi">+        dest=&#39;output_dir&#39;,</span>
<span class="gi">+        help=__(&#39;directory to place all output in&#39;),</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;-s&#39;,</span>
<span class="gi">+        &#39;--suffix&#39;,</span>
<span class="gi">+        action=&#39;store&#39;,</span>
<span class="gi">+        dest=&#39;suffix&#39;,</span>
<span class="gi">+        default=&#39;rst&#39;,</span>
<span class="gi">+        help=__(&#39;default suffix for files (default: %(default)s)&#39;),</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;-t&#39;,</span>
<span class="gi">+        &#39;--templates&#39;,</span>
<span class="gi">+        action=&#39;store&#39;,</span>
<span class="gi">+        dest=&#39;templates&#39;,</span>
<span class="gi">+        default=None,</span>
<span class="gi">+        help=__(&#39;custom template directory (default: %(default)s)&#39;),</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;-i&#39;,</span>
<span class="gi">+        &#39;--imported-members&#39;,</span>
<span class="gi">+        action=&#39;store_true&#39;,</span>
<span class="gi">+        dest=&#39;imported_members&#39;,</span>
<span class="gi">+        default=False,</span>
<span class="gi">+        help=__(&#39;document imported members (default: %(default)s)&#39;),</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;-a&#39;,</span>
<span class="gi">+        &#39;--respect-module-all&#39;,</span>
<span class="gi">+        action=&#39;store_true&#39;,</span>
<span class="gi">+        dest=&#39;respect_module_all&#39;,</span>
<span class="gi">+        default=False,</span>
<span class="gi">+        help=__(</span>
<span class="gi">+            &#39;document exactly the members in module __all__ attribute. &#39;</span>
<span class="gi">+            &#39;(default: %(default)s)&#39;</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+    parser.add_argument(</span>
<span class="gi">+        &#39;--remove-old&#39;,</span>
<span class="gi">+        action=&#39;store_true&#39;,</span>
<span class="gi">+        dest=&#39;remove_old&#39;,</span>
<span class="gi">+        default=False,</span>
<span class="gi">+        help=__(</span>
<span class="gi">+            &#39;Remove existing files in the output directory that were not generated&#39;</span>
<span class="gi">+        ),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return parser</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def main(argv: Sequence[str] = (), /) -&gt; None:</span>
<span class="gi">+    locale.setlocale(locale.LC_ALL, &#39;&#39;)</span>
<span class="gi">+    sphinx.locale.init_console()</span>
<span class="gi">+</span>
<span class="gi">+    app = DummyApplication(sphinx.locale.get_translator())</span>
<span class="gi">+    logging.setup(app, sys.stdout, sys.stderr)  # type: ignore[arg-type]</span>
<span class="gi">+    setup_documenters(app)</span>
<span class="gi">+    args = get_parser().parse_args(argv or sys.argv[1:])</span>
<span class="gi">+</span>
<span class="gi">+    if args.templates:</span>
<span class="gi">+        app.config.templates_path.append(path.abspath(args.templates))</span>
<span class="gi">+    app.config.autosummary_ignore_module_all = not args.respect_module_all</span>
<span class="gi">+</span>
<span class="gi">+    written_files = generate_autosummary_docs(</span>
<span class="gi">+        args.source_file,</span>
<span class="gi">+        args.output_dir,</span>
<span class="gi">+        &#39;.&#39; + args.suffix,</span>
<span class="gi">+        imported_members=args.imported_members,</span>
<span class="gi">+        app=app,  # type: ignore[arg-type]</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    if args.remove_old:</span>
<span class="gi">+        for existing in Path(args.output_dir).glob(f&#39;**/*.{args.suffix}&#39;):</span>
<span class="gi">+            if existing not in written_files:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    existing.unlink()</span>
<span class="gi">+                except OSError as exc:</span>
<span class="gi">+                    logger.warning(</span>
<span class="gi">+                        __(&#39;Failed to remove %s: %s&#39;),</span>
<span class="gi">+                        existing,</span>
<span class="gi">+                        exc.strerror,</span>
<span class="gi">+                        type=&#39;autosummary&#39;,</span>
<span class="gi">+                    )</span>


<span class="w"> </span>if __name__ == &#39;__main__&#39;:
<span class="gh">diff --git a/sphinx/ext/coverage.py b/sphinx/ext/coverage.py</span>
<span class="gh">index 9e50f8dea..c075e9548 100644</span>
<span class="gd">--- a/sphinx/ext/coverage.py</span>
<span class="gi">+++ b/sphinx/ext/coverage.py</span>
<span class="gu">@@ -3,7 +3,9 @@</span>
<span class="w"> </span>Mostly written by Josip Dzolonga for the Google Highly Open Participation
<span class="w"> </span>contest.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import glob
<span class="w"> </span>import inspect
<span class="w"> </span>import pickle
<span class="gu">@@ -13,21 +15,59 @@ import sys</span>
<span class="w"> </span>from importlib import import_module
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import IO, TYPE_CHECKING, Any, TextIO
<span class="gi">+</span>
<span class="w"> </span>import sphinx
<span class="w"> </span>from sphinx.builders import Builder
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.console import red
<span class="w"> </span>from sphinx.util.inspect import safe_getattr
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Iterable, Iterator, Sequence, Set
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="gd">-def _load_modules(mod_name: str, ignored_module_exps: Iterable[re.Pattern[str]]</span>
<span class="gd">-    ) -&gt;Set[str]:</span>
<span class="gi">+# utility</span>
<span class="gi">+def write_header(f: IO[str], text: str, char: str = &#39;-&#39;) -&gt; None:</span>
<span class="gi">+    f.write(text + &#39;\n&#39;)</span>
<span class="gi">+    f.write(char * len(text) + &#39;\n\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def compile_regex_list(name: str, exps: str) -&gt; list[re.Pattern[str]]:</span>
<span class="gi">+    lst = []</span>
<span class="gi">+    for exp in exps:</span>
<span class="gi">+        try:</span>
<span class="gi">+            lst.append(re.compile(exp))</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            logger.warning(__(&#39;invalid regex %r in %s&#39;), exp, name)</span>
<span class="gi">+    return lst</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _write_table(table: list[list[str]]) -&gt; Iterator[str]:</span>
<span class="gi">+    sizes = [max(len(x[column]) for x in table) + 1 for column in range(len(table[0]))]</span>
<span class="gi">+</span>
<span class="gi">+    yield _add_line(sizes, &#39;-&#39;)</span>
<span class="gi">+    yield from _add_row(sizes, table[0], &#39;=&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    for row in table[1:]:</span>
<span class="gi">+        yield from _add_row(sizes, row, &#39;-&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _add_line(sizes: list[int], separator: str) -&gt; str:</span>
<span class="gi">+    return &#39;+&#39; + &#39;&#39;.join((separator * (size + 1)) + &#39;+&#39; for size in sizes)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _add_row(col_widths: list[int], columns: list[str], separator: str) -&gt; Iterator[str]:</span>
<span class="gi">+    yield &#39;&#39;.join(f&#39;| {column: &lt;{col_widths[i]}}&#39; for i, column in enumerate(columns)) + &#39;|&#39;</span>
<span class="gi">+    yield _add_line(col_widths, separator)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _load_modules(mod_name: str, ignored_module_exps: Iterable[re.Pattern[str]]) -&gt; Set[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Recursively load all submodules.

<span class="w"> </span>    :param mod_name: The name of a module to load submodules for.
<span class="gu">@@ -37,12 +77,36 @@ def _load_modules(mod_name: str, ignored_module_exps: Iterable[re.Pattern[str]]</span>
<span class="w"> </span>    :raises ImportError: If the module indicated by ``mod_name`` could not be
<span class="w"> </span>        loaded.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if any(exp.match(mod_name) for exp in ignored_module_exps):</span>
<span class="gi">+        return set()</span>
<span class="gi">+</span>
<span class="gi">+    # This can raise an exception, which must be handled by the caller.</span>
<span class="gi">+    mod = import_module(mod_name)</span>
<span class="gi">+    modules = {mod_name}</span>
<span class="gi">+    if mod.__spec__ is None:</span>
<span class="gi">+        return modules</span>
<span class="gi">+</span>
<span class="gi">+    search_locations = mod.__spec__.submodule_search_locations</span>
<span class="gi">+    for (_, sub_mod_name, sub_mod_ispkg) in pkgutil.iter_modules(search_locations):</span>
<span class="gi">+        if sub_mod_name == &#39;__main__&#39;:</span>
<span class="gi">+            continue</span>

<span class="gi">+        if sub_mod_ispkg:</span>
<span class="gi">+            modules |= _load_modules(f&#39;{mod_name}.{sub_mod_name}&#39;, ignored_module_exps)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if any(exp.match(sub_mod_name) for exp in ignored_module_exps):</span>
<span class="gi">+                continue</span>
<span class="gi">+            modules.add(f&#39;{mod_name}.{sub_mod_name}&#39;)</span>

<span class="gd">-def _determine_py_coverage_modules(coverage_modules: Sequence[str],</span>
<span class="gd">-    seen_modules: Set[str], ignored_module_exps: Iterable[re.Pattern[str]],</span>
<span class="gd">-    py_undoc: dict[str, dict[str, Any]]) -&gt;list[str]:</span>
<span class="gi">+    return modules</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _determine_py_coverage_modules(</span>
<span class="gi">+    coverage_modules: Sequence[str],</span>
<span class="gi">+    seen_modules: Set[str],</span>
<span class="gi">+    ignored_module_exps: Iterable[re.Pattern[str]],</span>
<span class="gi">+    py_undoc: dict[str, dict[str, Any]],</span>
<span class="gi">+) -&gt; list[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a sorted list of modules to check for coverage.

<span class="w"> </span>    Figure out which of the two operating modes to use:
<span class="gu">@@ -58,18 +122,375 @@ def _determine_py_coverage_modules(coverage_modules: Sequence[str],</span>
<span class="w"> </span>      modules that are documented will be noted. This will therefore identify both
<span class="w"> </span>      missing modules and missing objects, but it requires manual configuration.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not coverage_modules:</span>
<span class="gi">+        return sorted(seen_modules)</span>
<span class="gi">+</span>
<span class="gi">+    modules: set[str] = set()</span>
<span class="gi">+    for mod_name in coverage_modules:</span>
<span class="gi">+        try:</span>
<span class="gi">+            modules |= _load_modules(mod_name, ignored_module_exps)</span>
<span class="gi">+        except ImportError as err:</span>
<span class="gi">+            # TODO(stephenfin): Define a subtype for all logs in this module</span>
<span class="gi">+            logger.warning(__(&#39;module %s could not be imported: %s&#39;), mod_name, err)</span>
<span class="gi">+            py_undoc[mod_name] = {&#39;error&#39;: err}</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+    # if there are additional modules then we warn but continue scanning</span>
<span class="gi">+    if additional_modules := seen_modules - modules:</span>
<span class="gi">+        logger.warning(</span>
<span class="gi">+            __(&#39;the following modules are documented but were not specified &#39;</span>
<span class="gi">+               &#39;in coverage_modules: %s&#39;),</span>
<span class="gi">+            &#39;, &#39;.join(additional_modules),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # likewise, if there are missing modules we warn but continue scanning</span>
<span class="gi">+    if missing_modules := modules - seen_modules:</span>
<span class="gi">+        logger.warning(</span>
<span class="gi">+            __(&#39;the following modules are specified in coverage_modules &#39;</span>
<span class="gi">+               &#39;but were not documented&#39;),</span>
<span class="gi">+            &#39;, &#39;.join(missing_modules),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return sorted(modules)</span>


<span class="w"> </span>class CoverageBuilder(Builder):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Evaluates coverage of code in the documentation.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name = &#39;coverage&#39;
<span class="gd">-    epilog = __(</span>
<span class="gd">-        &#39;Testing of coverage in the sources finished, look at the results in %(outdir)s&#39;</span>
<span class="gd">-         + path.sep + &#39;python.txt.&#39;)</span>
<span class="gi">+    epilog = __(&#39;Testing of coverage in the sources finished, look at the &#39;</span>
<span class="gi">+                &#39;results in %(outdir)s&#39; + path.sep + &#39;python.txt.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def init(self) -&gt; None:</span>
<span class="gi">+        self.c_sourcefiles: list[str] = []</span>
<span class="gi">+        for pattern in self.config.coverage_c_path:</span>
<span class="gi">+            pattern = path.join(self.srcdir, pattern)</span>
<span class="gi">+            self.c_sourcefiles.extend(glob.glob(pattern))</span>
<span class="gi">+</span>
<span class="gi">+        self.c_regexes: list[tuple[str, re.Pattern[str]]] = []</span>
<span class="gi">+        for (name, exp) in self.config.coverage_c_regexes.items():</span>
<span class="gi">+            try:</span>
<span class="gi">+                self.c_regexes.append((name, re.compile(exp)))</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                logger.warning(__(&#39;invalid regex %r in coverage_c_regexes&#39;), exp)</span>
<span class="gi">+</span>
<span class="gi">+        self.c_ignorexps: dict[str, list[re.Pattern[str]]] = {}</span>
<span class="gi">+        for (name, exps) in self.config.coverage_ignore_c_items.items():</span>
<span class="gi">+            self.c_ignorexps[name] = compile_regex_list(&#39;coverage_ignore_c_items&#39;,</span>
<span class="gi">+                                                        exps)</span>
<span class="gi">+        self.mod_ignorexps = compile_regex_list(&#39;coverage_ignore_modules&#39;,</span>
<span class="gi">+                                                self.config.coverage_ignore_modules)</span>
<span class="gi">+        self.cls_ignorexps = compile_regex_list(&#39;coverage_ignore_classes&#39;,</span>
<span class="gi">+                                                self.config.coverage_ignore_classes)</span>
<span class="gi">+        self.fun_ignorexps = compile_regex_list(&#39;coverage_ignore_functions&#39;,</span>
<span class="gi">+                                                self.config.coverage_ignore_functions)</span>
<span class="gi">+        self.py_ignorexps = compile_regex_list(&#39;coverage_ignore_pyobjects&#39;,</span>
<span class="gi">+                                               self.config.coverage_ignore_pyobjects)</span>
<span class="gi">+</span>
<span class="gi">+    def get_outdated_docs(self) -&gt; str:</span>
<span class="gi">+        return &#39;coverage overview&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def write(self, *ignored: Any) -&gt; None:</span>
<span class="gi">+        self.py_undoc: dict[str, dict[str, Any]] = {}</span>
<span class="gi">+        self.py_undocumented: dict[str, Set[str]] = {}</span>
<span class="gi">+        self.py_documented: dict[str, Set[str]] = {}</span>
<span class="gi">+        self.build_py_coverage()</span>
<span class="gi">+        self.write_py_coverage()</span>

<span class="gd">-    def _write_py_statistics(self, op: TextIO) -&gt;None:</span>
<span class="gi">+        self.c_undoc: dict[str, Set[tuple[str, str]]] = {}</span>
<span class="gi">+        self.build_c_coverage()</span>
<span class="gi">+        self.write_c_coverage()</span>
<span class="gi">+</span>
<span class="gi">+    def build_c_coverage(self) -&gt; None:</span>
<span class="gi">+        c_objects = {}</span>
<span class="gi">+        for obj in self.env.domains[&#39;c&#39;].get_objects():</span>
<span class="gi">+            c_objects[obj[2]] = obj[1]</span>
<span class="gi">+        for filename in self.c_sourcefiles:</span>
<span class="gi">+            undoc: set[tuple[str, str]] = set()</span>
<span class="gi">+            with open(filename, encoding=&quot;utf-8&quot;) as f:</span>
<span class="gi">+                for line in f:</span>
<span class="gi">+                    for key, regex in self.c_regexes:</span>
<span class="gi">+                        match = regex.match(line)</span>
<span class="gi">+                        if match:</span>
<span class="gi">+                            name = match.groups()[0]</span>
<span class="gi">+                            if key not in c_objects:</span>
<span class="gi">+                                undoc.add((key, name))</span>
<span class="gi">+                                continue</span>
<span class="gi">+</span>
<span class="gi">+                            if name not in c_objects[key]:</span>
<span class="gi">+                                for exp in self.c_ignorexps.get(key, []):</span>
<span class="gi">+                                    if exp.match(name):</span>
<span class="gi">+                                        break</span>
<span class="gi">+                                else:</span>
<span class="gi">+                                    undoc.add((key, name))</span>
<span class="gi">+                            continue</span>
<span class="gi">+            if undoc:</span>
<span class="gi">+                self.c_undoc[filename] = undoc</span>
<span class="gi">+</span>
<span class="gi">+    def write_c_coverage(self) -&gt; None:</span>
<span class="gi">+        output_file = path.join(self.outdir, &#39;c.txt&#39;)</span>
<span class="gi">+        with open(output_file, &#39;w&#39;, encoding=&quot;utf-8&quot;) as op:</span>
<span class="gi">+            if self.config.coverage_write_headline:</span>
<span class="gi">+                write_header(op, &#39;Undocumented C API elements&#39;, &#39;=&#39;)</span>
<span class="gi">+            op.write(&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            for filename, undoc in self.c_undoc.items():</span>
<span class="gi">+                write_header(op, filename)</span>
<span class="gi">+                for typ, name in sorted(undoc):</span>
<span class="gi">+                    op.write(&#39; * %-50s [%9s]\n&#39; % (name, typ))</span>
<span class="gi">+                    if self.config.coverage_show_missing_items:</span>
<span class="gi">+                        if self.app.quiet:</span>
<span class="gi">+                            logger.warning(__(&#39;undocumented c api: %s [%s] in file %s&#39;),</span>
<span class="gi">+                                           name, typ, filename)</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            logger.info(red(&#39;undocumented  &#39;) + &#39;c   &#39; + &#39;api       &#39; +</span>
<span class="gi">+                                        &#39;%-30s&#39; % (name + &quot; [%9s]&quot; % typ) +</span>
<span class="gi">+                                        red(&#39; - in file &#39;) + filename)</span>
<span class="gi">+                op.write(&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def ignore_pyobj(self, full_name: str) -&gt; bool:</span>
<span class="gi">+        return any(</span>
<span class="gi">+            exp.search(full_name)</span>
<span class="gi">+            for exp in self.py_ignorexps</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def build_py_coverage(self) -&gt; None:</span>
<span class="gi">+        seen_objects = frozenset(self.env.domaindata[&#39;py&#39;][&#39;objects&#39;])</span>
<span class="gi">+        seen_modules = frozenset(self.env.domaindata[&#39;py&#39;][&#39;modules&#39;])</span>
<span class="gi">+</span>
<span class="gi">+        skip_undoc = self.config.coverage_skip_undoc_in_source</span>
<span class="gi">+</span>
<span class="gi">+        modules = _determine_py_coverage_modules(</span>
<span class="gi">+            self.config.coverage_modules, seen_modules, self.mod_ignorexps, self.py_undoc,</span>
<span class="gi">+        )</span>
<span class="gi">+        for mod_name in modules:</span>
<span class="gi">+            ignore = False</span>
<span class="gi">+            for exp in self.mod_ignorexps:</span>
<span class="gi">+                if exp.match(mod_name):</span>
<span class="gi">+                    ignore = True</span>
<span class="gi">+                    break</span>
<span class="gi">+            if ignore or self.ignore_pyobj(mod_name):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                mod = import_module(mod_name)</span>
<span class="gi">+            except ImportError as err:</span>
<span class="gi">+                logger.warning(__(&#39;module %s could not be imported: %s&#39;), mod_name, err)</span>
<span class="gi">+                self.py_undoc[mod_name] = {&#39;error&#39;: err}</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            documented_objects: set[str] = set()</span>
<span class="gi">+            undocumented_objects: set[str] = set()</span>
<span class="gi">+</span>
<span class="gi">+            funcs = []</span>
<span class="gi">+            classes: dict[str, list[str]] = {}</span>
<span class="gi">+</span>
<span class="gi">+            for name, obj in inspect.getmembers(mod):</span>
<span class="gi">+                # diverse module attributes are ignored:</span>
<span class="gi">+                if name[0] == &#39;_&#39;:</span>
<span class="gi">+                    # begins in an underscore</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if not hasattr(obj, &#39;__module__&#39;):</span>
<span class="gi">+                    # cannot be attributed to a module</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if obj.__module__ != mod_name:</span>
<span class="gi">+                    # is not defined in this module</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                full_name = f&#39;{mod_name}.{name}&#39;</span>
<span class="gi">+                if self.ignore_pyobj(full_name):</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                if inspect.isfunction(obj):</span>
<span class="gi">+                    if full_name not in seen_objects:</span>
<span class="gi">+                        for exp in self.fun_ignorexps:</span>
<span class="gi">+                            if exp.match(name):</span>
<span class="gi">+                                break</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            if skip_undoc and not obj.__doc__:</span>
<span class="gi">+                                continue</span>
<span class="gi">+                            funcs.append(name)</span>
<span class="gi">+                            undocumented_objects.add(full_name)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        documented_objects.add(full_name)</span>
<span class="gi">+                elif inspect.isclass(obj):</span>
<span class="gi">+                    for exp in self.cls_ignorexps:</span>
<span class="gi">+                        if exp.match(name):</span>
<span class="gi">+                            break</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        if full_name not in seen_objects:</span>
<span class="gi">+                            if skip_undoc and not obj.__doc__:</span>
<span class="gi">+                                continue</span>
<span class="gi">+                            # not documented at all</span>
<span class="gi">+                            classes[name] = []</span>
<span class="gi">+                            continue</span>
<span class="gi">+</span>
<span class="gi">+                        attrs: list[str] = []</span>
<span class="gi">+</span>
<span class="gi">+                        for attr_name in dir(obj):</span>
<span class="gi">+                            if attr_name not in obj.__dict__:</span>
<span class="gi">+                                continue</span>
<span class="gi">+                            try:</span>
<span class="gi">+                                attr = safe_getattr(obj, attr_name)</span>
<span class="gi">+                            except AttributeError:</span>
<span class="gi">+                                continue</span>
<span class="gi">+                            if not (inspect.ismethod(attr) or</span>
<span class="gi">+                                    inspect.isfunction(attr)):</span>
<span class="gi">+                                continue</span>
<span class="gi">+                            if attr_name[0] == &#39;_&#39;:</span>
<span class="gi">+                                # starts with an underscore, ignore it</span>
<span class="gi">+                                continue</span>
<span class="gi">+                            if skip_undoc and not attr.__doc__:</span>
<span class="gi">+                                # skip methods without docstring if wished</span>
<span class="gi">+                                continue</span>
<span class="gi">+                            full_attr_name = f&#39;{full_name}.{attr_name}&#39;</span>
<span class="gi">+                            if self.ignore_pyobj(full_attr_name):</span>
<span class="gi">+                                continue</span>
<span class="gi">+                            if full_attr_name not in seen_objects:</span>
<span class="gi">+                                attrs.append(attr_name)</span>
<span class="gi">+                                undocumented_objects.add(full_attr_name)</span>
<span class="gi">+                            else:</span>
<span class="gi">+                                documented_objects.add(full_attr_name)</span>
<span class="gi">+</span>
<span class="gi">+                        if attrs:</span>
<span class="gi">+                            # some attributes are undocumented</span>
<span class="gi">+                            classes[name] = attrs</span>
<span class="gi">+</span>
<span class="gi">+            self.py_undoc[mod_name] = {&#39;funcs&#39;: funcs, &#39;classes&#39;: classes}</span>
<span class="gi">+            self.py_undocumented[mod_name] = undocumented_objects</span>
<span class="gi">+            self.py_documented[mod_name] = documented_objects</span>
<span class="gi">+</span>
<span class="gi">+    def _write_py_statistics(self, op: TextIO) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Outputs the table of ``op``.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        all_modules = frozenset(self.py_documented.keys() | self.py_undocumented.keys())</span>
<span class="gi">+        all_objects: Set[str] = set()</span>
<span class="gi">+        all_documented_objects: Set[str] = set()</span>
<span class="gi">+        for module in all_modules:</span>
<span class="gi">+            all_objects |= self.py_documented[module] | self.py_undocumented[module]</span>
<span class="gi">+            all_documented_objects |= self.py_documented[module]</span>
<span class="gi">+</span>
<span class="gi">+        # prepare tabular</span>
<span class="gi">+        table = [[&#39;Module&#39;, &#39;Coverage&#39;, &#39;Undocumented&#39;]]</span>
<span class="gi">+        for module in sorted(all_modules):</span>
<span class="gi">+            module_objects = self.py_documented[module] | self.py_undocumented[module]</span>
<span class="gi">+            if len(module_objects):</span>
<span class="gi">+                value = 100.0 * len(self.py_documented[module]) / len(module_objects)</span>
<span class="gi">+            else:</span>
<span class="gi">+                value = 100.0</span>
<span class="gi">+</span>
<span class="gi">+            table.append([module, &#39;%.2f%%&#39; % value, &#39;%d&#39; % len(self.py_undocumented[module])])</span>
<span class="gi">+</span>
<span class="gi">+        if all_objects:</span>
<span class="gi">+            table.append([</span>
<span class="gi">+                &#39;TOTAL&#39;,</span>
<span class="gi">+                f&#39;{100 * len(all_documented_objects) / len(all_objects):.2f}%&#39;,</span>
<span class="gi">+                f&#39;{len(all_objects) - len(all_documented_objects)}&#39;,</span>
<span class="gi">+            ])</span>
<span class="gi">+        else:</span>
<span class="gi">+            table.append([&#39;TOTAL&#39;, &#39;100&#39;, &#39;0&#39;])</span>
<span class="gi">+</span>
<span class="gi">+        for line in _write_table(table):</span>
<span class="gi">+            op.write(f&#39;{line}\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def write_py_coverage(self) -&gt; None:</span>
<span class="gi">+        output_file = path.join(self.outdir, &#39;python.txt&#39;)</span>
<span class="gi">+        failed = []</span>
<span class="gi">+        with open(output_file, &#39;w&#39;, encoding=&quot;utf-8&quot;) as op:</span>
<span class="gi">+            if self.config.coverage_write_headline:</span>
<span class="gi">+                write_header(op, &#39;Undocumented Python objects&#39;, &#39;=&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            if self.config.coverage_statistics_to_stdout:</span>
<span class="gi">+                self._write_py_statistics(sys.stdout)</span>
<span class="gi">+</span>
<span class="gi">+            if self.config.coverage_statistics_to_report:</span>
<span class="gi">+                write_header(op, &#39;Statistics&#39;)</span>
<span class="gi">+                self._write_py_statistics(op)</span>
<span class="gi">+                op.write(&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            keys = sorted(self.py_undoc.keys())</span>
<span class="gi">+            for name in keys:</span>
<span class="gi">+                undoc = self.py_undoc[name]</span>
<span class="gi">+                if &#39;error&#39; in undoc:</span>
<span class="gi">+                    failed.append((name, undoc[&#39;error&#39;]))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if not undoc[&#39;classes&#39;] and not undoc[&#39;funcs&#39;]:</span>
<span class="gi">+                        continue</span>
<span class="gi">+</span>
<span class="gi">+                    write_header(op, name)</span>
<span class="gi">+                    if undoc[&#39;funcs&#39;]:</span>
<span class="gi">+                        op.write(&#39;Functions:\n&#39;)</span>
<span class="gi">+                        op.writelines(&#39; * %s\n&#39; % x for x in undoc[&#39;funcs&#39;])</span>
<span class="gi">+                        if self.config.coverage_show_missing_items:</span>
<span class="gi">+                            if self.app.quiet:</span>
<span class="gi">+                                for func in undoc[&#39;funcs&#39;]:</span>
<span class="gi">+                                    logger.warning(</span>
<span class="gi">+                                        __(&#39;undocumented python function: %s :: %s&#39;),</span>
<span class="gi">+                                        name, func)</span>
<span class="gi">+                            else:</span>
<span class="gi">+                                for func in undoc[&#39;funcs&#39;]:</span>
<span class="gi">+                                    logger.info(red(&#39;undocumented  &#39;) + &#39;py  &#39; + &#39;function  &#39; +</span>
<span class="gi">+                                                &#39;%-30s&#39; % func + red(&#39; - in module &#39;) + name)</span>
<span class="gi">+                        op.write(&#39;\n&#39;)</span>
<span class="gi">+                    if undoc[&#39;classes&#39;]:</span>
<span class="gi">+                        op.write(&#39;Classes:\n&#39;)</span>
<span class="gi">+                        for class_name, methods in sorted(</span>
<span class="gi">+                                undoc[&#39;classes&#39;].items()):</span>
<span class="gi">+                            if not methods:</span>
<span class="gi">+                                op.write(&#39; * %s\n&#39; % class_name)</span>
<span class="gi">+                                if self.config.coverage_show_missing_items:</span>
<span class="gi">+                                    if self.app.quiet:</span>
<span class="gi">+                                        logger.warning(</span>
<span class="gi">+                                            __(&#39;undocumented python class: %s :: %s&#39;),</span>
<span class="gi">+                                            name, class_name)</span>
<span class="gi">+                                    else:</span>
<span class="gi">+                                        logger.info(red(&#39;undocumented  &#39;) + &#39;py  &#39; +</span>
<span class="gi">+                                                    &#39;class     &#39; + &#39;%-30s&#39; % class_name +</span>
<span class="gi">+                                                    red(&#39; - in module &#39;) + name)</span>
<span class="gi">+                            else:</span>
<span class="gi">+                                op.write(&#39; * %s -- missing methods:\n\n&#39; % class_name)</span>
<span class="gi">+                                op.writelines(&#39;   - %s\n&#39; % x for x in methods)</span>
<span class="gi">+                                if self.config.coverage_show_missing_items:</span>
<span class="gi">+                                    if self.app.quiet:</span>
<span class="gi">+                                        for meth in methods:</span>
<span class="gi">+                                            logger.warning(</span>
<span class="gi">+                                                __(&#39;undocumented python method:&#39;</span>
<span class="gi">+                                                   &#39; %s :: %s :: %s&#39;),</span>
<span class="gi">+                                                name, class_name, meth)</span>
<span class="gi">+                                    else:</span>
<span class="gi">+                                        for meth in methods:</span>
<span class="gi">+                                            logger.info(red(&#39;undocumented  &#39;) + &#39;py  &#39; +</span>
<span class="gi">+                                                        &#39;method    &#39; + &#39;%-30s&#39; %</span>
<span class="gi">+                                                        (class_name + &#39;.&#39; + meth) +</span>
<span class="gi">+                                                        red(&#39; - in module &#39;) + name)</span>
<span class="gi">+                        op.write(&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            if failed:</span>
<span class="gi">+                write_header(op, &#39;Modules that failed to import&#39;)</span>
<span class="gi">+                op.writelines(&#39; * %s -- %s\n&#39; % x for x in failed)</span>
<span class="gi">+</span>
<span class="gi">+    def finish(self) -&gt; None:</span>
<span class="gi">+        # dump the coverage data to a pickle file too</span>
<span class="gi">+        picklepath = path.join(self.outdir, &#39;undoc.pickle&#39;)</span>
<span class="gi">+        with open(picklepath, &#39;wb&#39;) as dumpfile:</span>
<span class="gi">+            pickle.dump((self.py_undoc, self.c_undoc,</span>
<span class="gi">+                         self.py_undocumented, self.py_documented), dumpfile)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_builder(CoverageBuilder)</span>
<span class="gi">+    app.add_config_value(&#39;coverage_modules&#39;, (), &#39;&#39;, types={tuple, list})</span>
<span class="gi">+    app.add_config_value(&#39;coverage_ignore_modules&#39;, [], &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;coverage_ignore_functions&#39;, [], &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;coverage_ignore_classes&#39;, [], &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;coverage_ignore_pyobjects&#39;, [], &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;coverage_c_path&#39;, [], &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;coverage_c_regexes&#39;, {}, &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;coverage_ignore_c_items&#39;, {}, &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;coverage_write_headline&#39;, True, &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;coverage_statistics_to_report&#39;, True, &#39;&#39;, bool)</span>
<span class="gi">+    app.add_config_value(&#39;coverage_statistics_to_stdout&#39;, True, &#39;&#39;, bool)</span>
<span class="gi">+    app.add_config_value(&#39;coverage_skip_undoc_in_source&#39;, False, &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;coverage_show_missing_items&#39;, False, &#39;&#39;)</span>
<span class="gi">+    return {&#39;version&#39;: sphinx.__display_version__, &#39;parallel_read_safe&#39;: True}</span>
<span class="gh">diff --git a/sphinx/ext/doctest.py b/sphinx/ext/doctest.py</span>
<span class="gh">index 46e4ad53d..ba451208a 100644</span>
<span class="gd">--- a/sphinx/ext/doctest.py</span>
<span class="gi">+++ b/sphinx/ext/doctest.py</span>
<span class="gu">@@ -2,7 +2,9 @@</span>

<span class="w"> </span>The extension automatically execute code snippets and checks their results.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import doctest
<span class="w"> </span>import re
<span class="w"> </span>import sys
<span class="gu">@@ -10,10 +12,12 @@ import time</span>
<span class="w"> </span>from io import StringIO
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING, Any, ClassVar
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.parsers.rst import directives
<span class="w"> </span>from packaging.specifiers import InvalidSpecifier, SpecifierSet
<span class="w"> </span>from packaging.version import Version
<span class="gi">+</span>
<span class="w"> </span>import sphinx
<span class="w"> </span>from sphinx.builders import Builder
<span class="w"> </span>from sphinx.locale import __
<span class="gu">@@ -21,17 +25,23 @@ from sphinx.util import logging</span>
<span class="w"> </span>from sphinx.util.console import bold
<span class="w"> </span>from sphinx.util.docutils import SphinxDirective
<span class="w"> </span>from sphinx.util.osutil import relpath
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Callable, Iterable, Sequence
<span class="gi">+</span>
<span class="w"> </span>    from docutils.nodes import Element, Node, TextElement
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata, OptionSpec
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gd">-blankline_re = re.compile(&#39;^\\s*&lt;BLANKLINE&gt;&#39;, re.MULTILINE)</span>
<span class="gd">-doctestopt_re = re.compile(&#39;#\\s*doctest:.+$&#39;, re.MULTILINE)</span>
<span class="gi">+</span>
<span class="gi">+blankline_re = re.compile(r&#39;^\s*&lt;BLANKLINE&gt;&#39;, re.MULTILINE)</span>
<span class="gi">+doctestopt_re = re.compile(r&#39;#\s*doctest:.+$&#39;, re.MULTILINE)</span>


<span class="gd">-def is_allowed_version(spec: str, version: str) -&gt;bool:</span>
<span class="gi">+def is_allowed_version(spec: str, version: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check `spec` satisfies `version` or not.

<span class="w"> </span>    This obeys PEP-440 specifiers:
<span class="gu">@@ -46,107 +56,525 @@ def is_allowed_version(spec: str, version: str) -&gt;bool:</span>
<span class="w"> </span>        &gt;&gt;&gt; is_allowed_version(&#39;&gt;3.2, &lt;4.0&#39;, &#39;3.3&#39;)
<span class="w"> </span>        True
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return Version(version) in SpecifierSet(spec)</span>


<span class="gi">+# set up the necessary directives</span>
<span class="gi">+</span>
<span class="w"> </span>class TestDirective(SphinxDirective):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Base class for doctest-related directives.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    has_content = True
<span class="w"> </span>    required_arguments = 0
<span class="w"> </span>    optional_arguments = 1
<span class="w"> </span>    final_argument_whitespace = True

<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        # use ordinary docutils nodes for test code: they get special attributes</span>
<span class="gi">+        # so that our builder recognizes them, and the other builders are happy.</span>
<span class="gi">+        code = &#39;\n&#39;.join(self.content)</span>
<span class="gi">+        test = None</span>
<span class="gi">+        if self.name == &#39;doctest&#39;:</span>
<span class="gi">+            if &#39;&lt;BLANKLINE&gt;&#39; in code:</span>
<span class="gi">+                # convert &lt;BLANKLINE&gt;s to ordinary blank lines for presentation</span>
<span class="gi">+                test = code</span>
<span class="gi">+                code = blankline_re.sub(&#39;&#39;, code)</span>
<span class="gi">+            if doctestopt_re.search(code) and &#39;no-trim-doctest-flags&#39; not in self.options:</span>
<span class="gi">+                if not test:</span>
<span class="gi">+                    test = code</span>
<span class="gi">+                code = doctestopt_re.sub(&#39;&#39;, code)</span>
<span class="gi">+        nodetype: type[TextElement] = nodes.literal_block</span>
<span class="gi">+        if self.name in (&#39;testsetup&#39;, &#39;testcleanup&#39;) or &#39;hide&#39; in self.options:</span>
<span class="gi">+            nodetype = nodes.comment</span>
<span class="gi">+        if self.arguments:</span>
<span class="gi">+            groups = [x.strip() for x in self.arguments[0].split(&#39;,&#39;)]</span>
<span class="gi">+        else:</span>
<span class="gi">+            groups = [&#39;default&#39;]</span>
<span class="gi">+        node = nodetype(code, code, testnodetype=self.name, groups=groups)</span>
<span class="gi">+        self.set_source_info(node)</span>
<span class="gi">+        if test is not None:</span>
<span class="gi">+            # only save if it differs from code</span>
<span class="gi">+            node[&#39;test&#39;] = test</span>
<span class="gi">+        if self.name == &#39;doctest&#39;:</span>
<span class="gi">+            node[&#39;language&#39;] = &#39;pycon&#39;</span>
<span class="gi">+        elif self.name == &#39;testcode&#39;:</span>
<span class="gi">+            node[&#39;language&#39;] = &#39;python&#39;</span>
<span class="gi">+        elif self.name == &#39;testoutput&#39;:</span>
<span class="gi">+            # don&#39;t try to highlight output</span>
<span class="gi">+            node[&#39;language&#39;] = &#39;none&#39;</span>
<span class="gi">+        node[&#39;options&#39;] = {}</span>
<span class="gi">+        if self.name in (&#39;doctest&#39;, &#39;testoutput&#39;) and &#39;options&#39; in self.options:</span>
<span class="gi">+            # parse doctest-like output comparison flags</span>
<span class="gi">+            option_strings = self.options[&#39;options&#39;].replace(&#39;,&#39;, &#39; &#39;).split()</span>
<span class="gi">+            for option in option_strings:</span>
<span class="gi">+                prefix, option_name = option[0], option[1:]</span>
<span class="gi">+                if prefix not in &#39;+-&#39;:</span>
<span class="gi">+                    self.state.document.reporter.warning(</span>
<span class="gi">+                        __(&quot;missing &#39;+&#39; or &#39;-&#39; in &#39;%s&#39; option.&quot;) % option,</span>
<span class="gi">+                        line=self.lineno)</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if option_name not in doctest.OPTIONFLAGS_BY_NAME:</span>
<span class="gi">+                    self.state.document.reporter.warning(</span>
<span class="gi">+                        __(&quot;&#39;%s&#39; is not a valid option.&quot;) % option_name,</span>
<span class="gi">+                        line=self.lineno)</span>
<span class="gi">+                    continue</span>
<span class="gi">+                flag = doctest.OPTIONFLAGS_BY_NAME[option[1:]]</span>
<span class="gi">+                node[&#39;options&#39;][flag] = (option[0] == &#39;+&#39;)</span>
<span class="gi">+        if self.name == &#39;doctest&#39; and &#39;pyversion&#39; in self.options:</span>
<span class="gi">+            try:</span>
<span class="gi">+                spec = self.options[&#39;pyversion&#39;]</span>
<span class="gi">+                python_version = &#39;.&#39;.join(map(str, sys.version_info[:3]))</span>
<span class="gi">+                if not is_allowed_version(spec, python_version):</span>
<span class="gi">+                    flag = doctest.OPTIONFLAGS_BY_NAME[&#39;SKIP&#39;]</span>
<span class="gi">+                    node[&#39;options&#39;][flag] = True  # Skip the test</span>
<span class="gi">+            except InvalidSpecifier:</span>
<span class="gi">+                self.state.document.reporter.warning(</span>
<span class="gi">+                    __(&quot;&#39;%s&#39; is not a valid pyversion option&quot;) % spec,</span>
<span class="gi">+                    line=self.lineno)</span>
<span class="gi">+        if &#39;skipif&#39; in self.options:</span>
<span class="gi">+            node[&#39;skipif&#39;] = self.options[&#39;skipif&#39;]</span>
<span class="gi">+        if &#39;trim-doctest-flags&#39; in self.options:</span>
<span class="gi">+            node[&#39;trim_flags&#39;] = True</span>
<span class="gi">+        elif &#39;no-trim-doctest-flags&#39; in self.options:</span>
<span class="gi">+            node[&#39;trim_flags&#39;] = False</span>
<span class="gi">+        return [node]</span>
<span class="gi">+</span>

<span class="w"> </span>class TestsetupDirective(TestDirective):
<span class="gd">-    option_spec: ClassVar[OptionSpec] = {&#39;skipif&#39;: directives.</span>
<span class="gd">-        unchanged_required}</span>
<span class="gi">+    option_spec: ClassVar[OptionSpec] = {</span>
<span class="gi">+        &#39;skipif&#39;: directives.unchanged_required,</span>
<span class="gi">+    }</span>


<span class="w"> </span>class TestcleanupDirective(TestDirective):
<span class="gd">-    option_spec: ClassVar[OptionSpec] = {&#39;skipif&#39;: directives.</span>
<span class="gd">-        unchanged_required}</span>
<span class="gi">+    option_spec: ClassVar[OptionSpec] = {</span>
<span class="gi">+        &#39;skipif&#39;: directives.unchanged_required,</span>
<span class="gi">+    }</span>


<span class="w"> </span>class DoctestDirective(TestDirective):
<span class="gd">-    option_spec: ClassVar[OptionSpec] = {&#39;hide&#39;: directives.flag,</span>
<span class="gd">-        &#39;no-trim-doctest-flags&#39;: directives.flag, &#39;options&#39;: directives.</span>
<span class="gd">-        unchanged, &#39;pyversion&#39;: directives.unchanged_required, &#39;skipif&#39;:</span>
<span class="gd">-        directives.unchanged_required, &#39;trim-doctest-flags&#39;: directives.flag}</span>
<span class="gi">+    option_spec: ClassVar[OptionSpec] = {</span>
<span class="gi">+        &#39;hide&#39;: directives.flag,</span>
<span class="gi">+        &#39;no-trim-doctest-flags&#39;: directives.flag,</span>
<span class="gi">+        &#39;options&#39;: directives.unchanged,</span>
<span class="gi">+        &#39;pyversion&#39;: directives.unchanged_required,</span>
<span class="gi">+        &#39;skipif&#39;: directives.unchanged_required,</span>
<span class="gi">+        &#39;trim-doctest-flags&#39;: directives.flag,</span>
<span class="gi">+    }</span>


<span class="w"> </span>class TestcodeDirective(TestDirective):
<span class="gd">-    option_spec: ClassVar[OptionSpec] = {&#39;hide&#39;: directives.flag,</span>
<span class="gd">-        &#39;no-trim-doctest-flags&#39;: directives.flag, &#39;pyversion&#39;: directives.</span>
<span class="gd">-        unchanged_required, &#39;skipif&#39;: directives.unchanged_required,</span>
<span class="gd">-        &#39;trim-doctest-flags&#39;: directives.flag}</span>
<span class="gi">+    option_spec: ClassVar[OptionSpec] = {</span>
<span class="gi">+        &#39;hide&#39;: directives.flag,</span>
<span class="gi">+        &#39;no-trim-doctest-flags&#39;: directives.flag,</span>
<span class="gi">+        &#39;pyversion&#39;: directives.unchanged_required,</span>
<span class="gi">+        &#39;skipif&#39;: directives.unchanged_required,</span>
<span class="gi">+        &#39;trim-doctest-flags&#39;: directives.flag,</span>
<span class="gi">+    }</span>


<span class="w"> </span>class TestoutputDirective(TestDirective):
<span class="gd">-    option_spec: ClassVar[OptionSpec] = {&#39;hide&#39;: directives.flag,</span>
<span class="gd">-        &#39;no-trim-doctest-flags&#39;: directives.flag, &#39;options&#39;: directives.</span>
<span class="gd">-        unchanged, &#39;pyversion&#39;: directives.unchanged_required, &#39;skipif&#39;:</span>
<span class="gd">-        directives.unchanged_required, &#39;trim-doctest-flags&#39;: directives.flag}</span>
<span class="gi">+    option_spec: ClassVar[OptionSpec] = {</span>
<span class="gi">+        &#39;hide&#39;: directives.flag,</span>
<span class="gi">+        &#39;no-trim-doctest-flags&#39;: directives.flag,</span>
<span class="gi">+        &#39;options&#39;: directives.unchanged,</span>
<span class="gi">+        &#39;pyversion&#39;: directives.unchanged_required,</span>
<span class="gi">+        &#39;skipif&#39;: directives.unchanged_required,</span>
<span class="gi">+        &#39;trim-doctest-flags&#39;: directives.flag,</span>
<span class="gi">+    }</span>


<span class="w"> </span>parser = doctest.DocTestParser()


<span class="gd">-class TestGroup:</span>
<span class="gi">+# helper classes</span>

<span class="gd">-    def __init__(self, name: str) -&gt;None:</span>
<span class="gi">+class TestGroup:</span>
<span class="gi">+    def __init__(self, name: str) -&gt; None:</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.setup: list[TestCode] = []
<span class="w"> </span>        self.tests: list[list[TestCode] | tuple[TestCode, None]] = []
<span class="w"> </span>        self.cleanup: list[TestCode] = []

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;TestGroup(name={self.name!r}, setup={self.setup!r}, cleanup={self.cleanup!r}, tests={self.tests!r})&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+    def add_code(self, code: TestCode, prepend: bool = False) -&gt; None:</span>
<span class="gi">+        if code.type == &#39;testsetup&#39;:</span>
<span class="gi">+            if prepend:</span>
<span class="gi">+                self.setup.insert(0, code)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.setup.append(code)</span>
<span class="gi">+        elif code.type == &#39;testcleanup&#39;:</span>
<span class="gi">+            self.cleanup.append(code)</span>
<span class="gi">+        elif code.type == &#39;doctest&#39;:</span>
<span class="gi">+            self.tests.append([code])</span>
<span class="gi">+        elif code.type == &#39;testcode&#39;:</span>
<span class="gi">+            # &quot;testoutput&quot; may replace the second element</span>
<span class="gi">+            self.tests.append((code, None))</span>
<span class="gi">+        elif code.type == &#39;testoutput&#39;:</span>
<span class="gi">+            if self.tests:</span>
<span class="gi">+                latest_test = self.tests[-1]</span>
<span class="gi">+                if len(latest_test) == 2:</span>
<span class="gi">+                    self.tests[-1] = [latest_test[0], code]</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise RuntimeError(__(&#39;invalid TestCode type&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return (f&#39;TestGroup(name={self.name!r}, setup={self.setup!r}, &#39;</span>
<span class="gi">+                f&#39;cleanup={self.cleanup!r}, tests={self.tests!r})&#39;)</span>


<span class="w"> </span>class TestCode:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, code: str, type: str, filename: str, lineno: int,</span>
<span class="gd">-        options: (dict | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, code: str, type: str, filename: str,</span>
<span class="gi">+                 lineno: int, options: dict | None = None) -&gt; None:</span>
<span class="w"> </span>        self.code = code
<span class="w"> </span>        self.type = type
<span class="w"> </span>        self.filename = filename
<span class="w"> </span>        self.lineno = lineno
<span class="w"> </span>        self.options = options or {}

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;TestCode({self.code!r}, {self.type!r}, filename={self.filename!r}, lineno={self.lineno!r}, options={self.options!r})&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return (f&#39;TestCode({self.code!r}, {self.type!r}, filename={self.filename!r}, &#39;</span>
<span class="gi">+                f&#39;lineno={self.lineno!r}, options={self.options!r})&#39;)</span>


<span class="w"> </span>class SphinxDocTestRunner(doctest.DocTestRunner):
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gi">+    def summarize(self, out: Callable, verbose: bool | None = None,  # type: ignore[override]</span>
<span class="gi">+                  ) -&gt; tuple[int, int]:</span>
<span class="gi">+        string_io = StringIO()</span>
<span class="gi">+        old_stdout = sys.stdout</span>
<span class="gi">+        sys.stdout = string_io</span>
<span class="gi">+        try:</span>
<span class="gi">+            res = super().summarize(verbose)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            sys.stdout = old_stdout</span>
<span class="gi">+        out(string_io.getvalue())</span>
<span class="gi">+        return res</span>
<span class="gi">+</span>
<span class="gi">+    def _DocTestRunner__patched_linecache_getlines(self, filename: str,</span>
<span class="gi">+                                                   module_globals: Any = None) -&gt; Any:</span>
<span class="gi">+        # this is overridden from DocTestRunner adding the try-except below</span>
<span class="gi">+        m = self._DocTestRunner__LINECACHE_FILENAME_RE.match(  # type: ignore[attr-defined]</span>
<span class="gi">+            filename)</span>
<span class="gi">+        if m and m.group(&#39;name&#39;) == self.test.name:</span>
<span class="gi">+            try:</span>
<span class="gi">+                example = self.test.examples[int(m.group(&#39;examplenum&#39;))]</span>
<span class="gi">+            # because we compile multiple doctest blocks with the same name</span>
<span class="gi">+            # (viz. the group name) this might, for outer stack frames in a</span>
<span class="gi">+            # traceback, get the wrong test which might not have enough examples</span>
<span class="gi">+            except IndexError:</span>
<span class="gi">+                pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                return example.source.splitlines(True)</span>
<span class="gi">+        return self.save_linecache_getlines(  # type: ignore[attr-defined]</span>
<span class="gi">+            filename, module_globals)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# the new builder -- use sphinx-build.py -b doctest to run</span>

<span class="w"> </span>class DocTestBuilder(Builder):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Runs test snippets in the documentation.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name = &#39;doctest&#39;</span>
<span class="gd">-    epilog = __(</span>
<span class="gd">-        &#39;Testing of doctests in the sources finished, look at the results in %(outdir)s/output.txt.&#39;</span>
<span class="gd">-        )</span>

<span class="gd">-    def __del__(self) -&gt;None:</span>
<span class="gi">+    name = &#39;doctest&#39;</span>
<span class="gi">+    epilog = __(&#39;Testing of doctests in the sources finished, look at the &#39;</span>
<span class="gi">+                &#39;results in %(outdir)s/output.txt.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def init(self) -&gt; None:</span>
<span class="gi">+        # default options</span>
<span class="gi">+        self.opt = self.config.doctest_default_flags</span>
<span class="gi">+</span>
<span class="gi">+        # HACK HACK HACK</span>
<span class="gi">+        # doctest compiles its snippets with type &#39;single&#39;. That is nice</span>
<span class="gi">+        # for doctest examples but unusable for multi-statement code such</span>
<span class="gi">+        # as setup code -- to be able to use doctest error reporting with</span>
<span class="gi">+        # that code nevertheless, we monkey-patch the &quot;compile&quot; it uses.</span>
<span class="gi">+        doctest.compile = self.compile  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="gi">+        sys.path[0:0] = self.config.doctest_path</span>
<span class="gi">+</span>
<span class="gi">+        self.type = &#39;single&#39;</span>
<span class="gi">+</span>
<span class="gi">+        self.total_failures = 0</span>
<span class="gi">+        self.total_tries = 0</span>
<span class="gi">+        self.setup_failures = 0</span>
<span class="gi">+        self.setup_tries = 0</span>
<span class="gi">+        self.cleanup_failures = 0</span>
<span class="gi">+        self.cleanup_tries = 0</span>
<span class="gi">+</span>
<span class="gi">+        date = time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        outpath = self.outdir.joinpath(&#39;output.txt&#39;)</span>
<span class="gi">+        self.outfile = outpath.open(&#39;w&#39;, encoding=&#39;utf-8&#39;)  # NoQA: SIM115</span>
<span class="gi">+        self.outfile.write((&#39;Results of doctest builder run on %s\n&#39;</span>
<span class="gi">+                            &#39;==================================%s\n&#39;) %</span>
<span class="gi">+                           (date, &#39;=&#39; * len(date)))</span>
<span class="gi">+</span>
<span class="gi">+    def __del__(self) -&gt; None:</span>
<span class="gi">+        # free resources upon destruction (the file handler might not be</span>
<span class="gi">+        # closed if the builder is never used)</span>
<span class="w"> </span>        if hasattr(self, &#39;outfile&#39;):
<span class="w"> </span>            self.outfile.close()

<span class="gd">-    def get_filename_for_node(self, node: Node, docname: str) -&gt;str:</span>
<span class="gi">+    def _out(self, text: str) -&gt; None:</span>
<span class="gi">+        logger.info(text, nonl=True)</span>
<span class="gi">+        self.outfile.write(text)</span>
<span class="gi">+</span>
<span class="gi">+    def _warn_out(self, text: str) -&gt; None:</span>
<span class="gi">+        if self.app.quiet:</span>
<span class="gi">+            logger.warning(text)</span>
<span class="gi">+        else:</span>
<span class="gi">+            logger.info(text, nonl=True)</span>
<span class="gi">+        self.outfile.write(text)</span>
<span class="gi">+</span>
<span class="gi">+    def get_target_uri(self, docname: str, typ: str | None = None) -&gt; str:</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def get_outdated_docs(self) -&gt; set[str]:</span>
<span class="gi">+        return self.env.found_docs</span>
<span class="gi">+</span>
<span class="gi">+    def finish(self) -&gt; None:</span>
<span class="gi">+        # write executive summary</span>
<span class="gi">+        def s(v: int) -&gt; str:</span>
<span class="gi">+            return &#39;s&#39; if v != 1 else &#39;&#39;</span>
<span class="gi">+        repl = (self.total_tries, s(self.total_tries),</span>
<span class="gi">+                self.total_failures, s(self.total_failures),</span>
<span class="gi">+                self.setup_failures, s(self.setup_failures),</span>
<span class="gi">+                self.cleanup_failures, s(self.cleanup_failures))</span>
<span class="gi">+        self._out(&#39;&#39;&#39;</span>
<span class="gi">+Doctest summary</span>
<span class="gi">+===============</span>
<span class="gi">+%5d test%s</span>
<span class="gi">+%5d failure%s in tests</span>
<span class="gi">+%5d failure%s in setup code</span>
<span class="gi">+%5d failure%s in cleanup code</span>
<span class="gi">+&#39;&#39;&#39; % repl)</span>
<span class="gi">+        self.outfile.close()</span>
<span class="gi">+</span>
<span class="gi">+        if self.total_failures or self.setup_failures or self.cleanup_failures:</span>
<span class="gi">+            self.app.statuscode = 1</span>
<span class="gi">+</span>
<span class="gi">+    def write(self, build_docnames: Iterable[str] | None, updated_docnames: Sequence[str],</span>
<span class="gi">+              method: str = &#39;update&#39;) -&gt; None:</span>
<span class="gi">+        if build_docnames is None:</span>
<span class="gi">+            build_docnames = sorted(self.env.all_docs)</span>
<span class="gi">+</span>
<span class="gi">+        logger.info(bold(&#39;running tests...&#39;))</span>
<span class="gi">+        for docname in build_docnames:</span>
<span class="gi">+            # no need to resolve the doctree</span>
<span class="gi">+            doctree = self.env.get_doctree(docname)</span>
<span class="gi">+            self.test_doc(docname, doctree)</span>
<span class="gi">+</span>
<span class="gi">+    def get_filename_for_node(self, node: Node, docname: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Try to get the file which actually contains the doctest, not the
<span class="w"> </span>        filename of the document it&#39;s included in.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            filename = relpath(node.source, self.env.srcdir).rsplit(&#39;:docstring of &#39;, maxsplit=1)[0]  # type: ignore[arg-type]  # noqa: E501</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            filename = str(self.env.doc2path(docname, False))</span>
<span class="gi">+        return filename</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def get_line_number(node: Node) -&gt;(int | None):</span>
<span class="gi">+    def get_line_number(node: Node) -&gt; int | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get the real line number or admit we don&#39;t know.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # TODO:  Work out how to store or calculate real (file-relative)</span>
<span class="gi">+        #       line numbers for doctest blocks in docstrings.</span>
<span class="gi">+        if &#39;:docstring of &#39; in path.basename(node.source or &#39;&#39;):</span>
<span class="gi">+            # The line number is given relative to the stripped docstring,</span>
<span class="gi">+            # not the file.  This is correct where it is set, in</span>
<span class="gi">+            # `docutils.nodes.Node.setup_child`, but Sphinx should report</span>
<span class="gi">+            # relative to the file, not the docstring.</span>
<span class="gi">+            return None</span>
<span class="gi">+        if node.line is not None:</span>
<span class="gi">+            # TODO: find the root cause of this off by one error.</span>
<span class="gi">+            return node.line - 1</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def skipped(self, node: Element) -&gt; bool:</span>
<span class="gi">+        if &#39;skipif&#39; not in node:</span>
<span class="gi">+            return False</span>
<span class="gi">+        else:</span>
<span class="gi">+            condition = node[&#39;skipif&#39;]</span>
<span class="gi">+            context: dict[str, Any] = {}</span>
<span class="gi">+            if self.config.doctest_global_setup:</span>
<span class="gi">+                exec(self.config.doctest_global_setup, context)  # NoQA: S102</span>
<span class="gi">+            should_skip = eval(condition, context)  # NoQA: S307</span>
<span class="gi">+            if self.config.doctest_global_cleanup:</span>
<span class="gi">+                exec(self.config.doctest_global_cleanup, context)  # NoQA: S102</span>
<span class="gi">+            return should_skip</span>
<span class="gi">+</span>
<span class="gi">+    def test_doc(self, docname: str, doctree: Node) -&gt; None:</span>
<span class="gi">+        groups: dict[str, TestGroup] = {}</span>
<span class="gi">+        add_to_all_groups = []</span>
<span class="gi">+        self.setup_runner = SphinxDocTestRunner(verbose=False,</span>
<span class="gi">+                                                optionflags=self.opt)</span>
<span class="gi">+        self.test_runner = SphinxDocTestRunner(verbose=False,</span>
<span class="gi">+                                               optionflags=self.opt)</span>
<span class="gi">+        self.cleanup_runner = SphinxDocTestRunner(verbose=False,</span>
<span class="gi">+                                                  optionflags=self.opt)</span>
<span class="gi">+</span>
<span class="gi">+        self.test_runner._fakeout = self.setup_runner._fakeout  # type: ignore[attr-defined]</span>
<span class="gi">+        self.cleanup_runner._fakeout = self.setup_runner._fakeout  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="gi">+        if self.config.doctest_test_doctest_blocks:</span>
<span class="gi">+            def condition(node: Node) -&gt; bool:</span>
<span class="gi">+                return (isinstance(node, nodes.literal_block | nodes.comment) and</span>
<span class="gi">+                        &#39;testnodetype&#39; in node) or \</span>
<span class="gi">+                    isinstance(node, nodes.doctest_block)</span>
<span class="gi">+        else:</span>
<span class="gi">+            def condition(node: Node) -&gt; bool:</span>
<span class="gi">+                return isinstance(node, nodes.literal_block | nodes.comment) \</span>
<span class="gi">+                    and &#39;testnodetype&#39; in node</span>
<span class="gi">+        for node in doctree.findall(condition):</span>
<span class="gi">+            if self.skipped(node):  # type: ignore[arg-type]</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            source = node[&#39;test&#39;] if &#39;test&#39; in node else node.astext()  # type: ignore[index, operator]</span>
<span class="gi">+            filename = self.get_filename_for_node(node, docname)</span>
<span class="gi">+            line_number = self.get_line_number(node)</span>
<span class="gi">+            if not source:</span>
<span class="gi">+                logger.warning(__(&#39;no code/output in %s block at %s:%s&#39;),</span>
<span class="gi">+                               node.get(&#39;testnodetype&#39;, &#39;doctest&#39;),  # type: ignore[attr-defined]</span>
<span class="gi">+                               filename, line_number)</span>
<span class="gi">+            code = TestCode(source, type=node.get(&#39;testnodetype&#39;, &#39;doctest&#39;),  # type: ignore[attr-defined]</span>
<span class="gi">+                            filename=filename, lineno=line_number,  # type: ignore[arg-type]</span>
<span class="gi">+                            options=node.get(&#39;options&#39;))  # type: ignore[attr-defined]</span>
<span class="gi">+            node_groups = node.get(&#39;groups&#39;, [&#39;default&#39;])  # type: ignore[attr-defined]</span>
<span class="gi">+            if &#39;*&#39; in node_groups:</span>
<span class="gi">+                add_to_all_groups.append(code)</span>
<span class="gi">+                continue</span>
<span class="gi">+            for groupname in node_groups:</span>
<span class="gi">+                if groupname not in groups:</span>
<span class="gi">+                    groups[groupname] = TestGroup(groupname)</span>
<span class="gi">+                groups[groupname].add_code(code)</span>
<span class="gi">+        for code in add_to_all_groups:</span>
<span class="gi">+            for group in groups.values():</span>
<span class="gi">+                group.add_code(code)</span>
<span class="gi">+        if self.config.doctest_global_setup:</span>
<span class="gi">+            code = TestCode(self.config.doctest_global_setup,</span>
<span class="gi">+                            &#39;testsetup&#39;, filename=&#39;&lt;global_setup&gt;&#39;, lineno=0)</span>
<span class="gi">+            for group in groups.values():</span>
<span class="gi">+                group.add_code(code, prepend=True)</span>
<span class="gi">+        if self.config.doctest_global_cleanup:</span>
<span class="gi">+            code = TestCode(self.config.doctest_global_cleanup,</span>
<span class="gi">+                            &#39;testcleanup&#39;, filename=&#39;&lt;global_cleanup&gt;&#39;, lineno=0)</span>
<span class="gi">+            for group in groups.values():</span>
<span class="gi">+                group.add_code(code)</span>
<span class="gi">+        if not groups:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        show_successes = self.config.doctest_show_successes</span>
<span class="gi">+        if show_successes:</span>
<span class="gi">+            self._out(&#39;\n&#39;</span>
<span class="gi">+                      f&#39;Document: {docname}\n&#39;</span>
<span class="gi">+                      f&#39;----------{&quot;-&quot; * len(docname)}\n&#39;)</span>
<span class="gi">+        for group in groups.values():</span>
<span class="gi">+            self.test_group(group)</span>
<span class="gi">+        # Separately count results from setup code</span>
<span class="gi">+        res_f, res_t = self.setup_runner.summarize(self._out, verbose=False)</span>
<span class="gi">+        self.setup_failures += res_f</span>
<span class="gi">+        self.setup_tries += res_t</span>
<span class="gi">+        if self.test_runner.tries:</span>
<span class="gi">+            res_f, res_t = self.test_runner.summarize(</span>
<span class="gi">+                self._out, verbose=show_successes)</span>
<span class="gi">+            self.total_failures += res_f</span>
<span class="gi">+            self.total_tries += res_t</span>
<span class="gi">+        if self.cleanup_runner.tries:</span>
<span class="gi">+            res_f, res_t = self.cleanup_runner.summarize(</span>
<span class="gi">+                self._out, verbose=show_successes)</span>
<span class="gi">+            self.cleanup_failures += res_f</span>
<span class="gi">+            self.cleanup_tries += res_t</span>
<span class="gi">+</span>
<span class="gi">+    def compile(self, code: str, name: str, type: str, flags: Any, dont_inherit: bool) -&gt; Any:</span>
<span class="gi">+        return compile(code, name, self.type, flags, dont_inherit)</span>
<span class="gi">+</span>
<span class="gi">+    def test_group(self, group: TestGroup) -&gt; None:</span>
<span class="gi">+        ns: dict = {}</span>
<span class="gi">+</span>
<span class="gi">+        def run_setup_cleanup(runner: Any, testcodes: list[TestCode], what: Any) -&gt; bool:</span>
<span class="gi">+            examples = []</span>
<span class="gi">+            for testcode in testcodes:</span>
<span class="gi">+                example = doctest.Example(testcode.code, &#39;&#39;, lineno=testcode.lineno)</span>
<span class="gi">+                examples.append(example)</span>
<span class="gi">+            if not examples:</span>
<span class="gi">+                return True</span>
<span class="gi">+            # simulate a doctest with the code</span>
<span class="gi">+            sim_doctest = doctest.DocTest(examples, {},</span>
<span class="gi">+                                          f&#39;{group.name} ({what} code)&#39;,</span>
<span class="gi">+                                          testcodes[0].filename, 0, None)</span>
<span class="gi">+            sim_doctest.globs = ns</span>
<span class="gi">+            old_f = runner.failures</span>
<span class="gi">+            self.type = &#39;exec&#39;  # the snippet may contain multiple statements</span>
<span class="gi">+            runner.run(sim_doctest, out=self._warn_out, clear_globs=False)</span>
<span class="gi">+            return runner.failures &lt;= old_f</span>
<span class="gi">+</span>
<span class="gi">+        # run the setup code</span>
<span class="gi">+        if not run_setup_cleanup(self.setup_runner, group.setup, &#39;setup&#39;):</span>
<span class="gi">+            # if setup failed, don&#39;t run the group</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # run the tests</span>
<span class="gi">+        for code in group.tests:</span>
<span class="gi">+            if len(code) == 1:</span>
<span class="gi">+                # ordinary doctests (code/output interleaved)</span>
<span class="gi">+                try:</span>
<span class="gi">+                    test = parser.get_doctest(code[0].code, {}, group.name,</span>
<span class="gi">+                                              code[0].filename, code[0].lineno)</span>
<span class="gi">+                except Exception:</span>
<span class="gi">+                    logger.warning(__(&#39;ignoring invalid doctest code: %r&#39;), code[0].code,</span>
<span class="gi">+                                   location=(code[0].filename, code[0].lineno))</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if not test.examples:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                for example in test.examples:</span>
<span class="gi">+                    # apply directive&#39;s comparison options</span>
<span class="gi">+                    new_opt = code[0].options.copy()</span>
<span class="gi">+                    new_opt.update(example.options)</span>
<span class="gi">+                    example.options = new_opt</span>
<span class="gi">+                self.type = &#39;single&#39;  # as for ordinary doctests</span>
<span class="gi">+            else:</span>
<span class="gi">+                # testcode and output separate</span>
<span class="gi">+                output = code[1].code if code[1] else &#39;&#39;</span>
<span class="gi">+                options = code[1].options if code[1] else {}</span>
<span class="gi">+                # disable &lt;BLANKLINE&gt; processing as it is not needed</span>
<span class="gi">+                options[doctest.DONT_ACCEPT_BLANKLINE] = True</span>
<span class="gi">+                # find out if we&#39;re testing an exception</span>
<span class="gi">+                m = parser._EXCEPTION_RE.match(output)  # type: ignore[attr-defined]</span>
<span class="gi">+                if m:</span>
<span class="gi">+                    exc_msg = m.group(&#39;msg&#39;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    exc_msg = None</span>
<span class="gi">+                example = doctest.Example(code[0].code, output, exc_msg=exc_msg,</span>
<span class="gi">+                                          lineno=code[0].lineno, options=options)</span>
<span class="gi">+                test = doctest.DocTest([example], {}, group.name,</span>
<span class="gi">+                                       code[0].filename, code[0].lineno, None)</span>
<span class="gi">+                self.type = &#39;exec&#39;  # multiple statements again</span>
<span class="gi">+            # DocTest.__init__ copies the globs namespace, which we don&#39;t want</span>
<span class="gi">+            test.globs = ns</span>
<span class="gi">+            # also don&#39;t clear the globs namespace after running the doctest</span>
<span class="gi">+            self.test_runner.run(test, out=self._warn_out, clear_globs=False)</span>
<span class="gi">+</span>
<span class="gi">+        # run the cleanup</span>
<span class="gi">+        run_setup_cleanup(self.cleanup_runner, group.cleanup, &#39;cleanup&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_directive(&#39;testsetup&#39;, TestsetupDirective)</span>
<span class="gi">+    app.add_directive(&#39;testcleanup&#39;, TestcleanupDirective)</span>
<span class="gi">+    app.add_directive(&#39;doctest&#39;, DoctestDirective)</span>
<span class="gi">+    app.add_directive(&#39;testcode&#39;, TestcodeDirective)</span>
<span class="gi">+    app.add_directive(&#39;testoutput&#39;, TestoutputDirective)</span>
<span class="gi">+    app.add_builder(DocTestBuilder)</span>
<span class="gi">+    # this config value adds to sys.path</span>
<span class="gi">+    app.add_config_value(&#39;doctest_show_successes&#39;, True, &#39;&#39;, bool)</span>
<span class="gi">+    app.add_config_value(&#39;doctest_path&#39;, [], &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;doctest_test_doctest_blocks&#39;, &#39;default&#39;, &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;doctest_global_setup&#39;, &#39;&#39;, &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;doctest_global_cleanup&#39;, &#39;&#39;, &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(</span>
<span class="gi">+        &#39;doctest_default_flags&#39;,</span>
<span class="gi">+        doctest.DONT_ACCEPT_TRUE_FOR_1 | doctest.ELLIPSIS | doctest.IGNORE_EXCEPTION_DETAIL,</span>
<span class="gi">+        &#39;&#39;)</span>
<span class="gi">+    return {&#39;version&#39;: sphinx.__display_version__, &#39;parallel_read_safe&#39;: True}</span>
<span class="gh">diff --git a/sphinx/ext/duration.py b/sphinx/ext/duration.py</span>
<span class="gh">index 9080b706a..1053856e0 100644</span>
<span class="gd">--- a/sphinx/ext/duration.py</span>
<span class="gi">+++ b/sphinx/ext/duration.py</span>
<span class="gu">@@ -1,47 +1,100 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Measure document reading durations.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import time
<span class="w"> </span>from itertools import islice
<span class="w"> </span>from operator import itemgetter
<span class="w"> </span>from typing import TYPE_CHECKING, cast
<span class="gi">+</span>
<span class="w"> </span>import sphinx
<span class="w"> </span>from sphinx.domains import Domain
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.util import logging
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing import TypedDict
<span class="gi">+</span>
<span class="w"> </span>    from docutils import nodes
<span class="gd">-    from sphinx.application import Sphinx</span>

<span class="gi">+    from sphinx.application import Sphinx</span>

<span class="w"> </span>    class _DurationDomainData(TypedDict):
<span class="w"> </span>        reading_durations: dict[str, float]
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="w"> </span>class DurationDomain(Domain):
<span class="w"> </span>    &quot;&quot;&quot;A domain for durations of Sphinx processing.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    name = &#39;duration&#39;

<span class="gi">+    @property</span>
<span class="gi">+    def reading_durations(self) -&gt; dict[str, float]:</span>
<span class="gi">+        return self.data.setdefault(&#39;reading_durations&#39;, {})</span>

<span class="gd">-def on_builder_inited(app: Sphinx) -&gt;None:</span>
<span class="gi">+    def note_reading_duration(self, duration: float) -&gt; None:</span>
<span class="gi">+        self.reading_durations[self.env.docname] = duration</span>
<span class="gi">+</span>
<span class="gi">+    def clear(self) -&gt; None:</span>
<span class="gi">+        self.reading_durations.clear()</span>
<span class="gi">+</span>
<span class="gi">+    def clear_doc(self, docname: str) -&gt; None:</span>
<span class="gi">+        self.reading_durations.pop(docname, None)</span>
<span class="gi">+</span>
<span class="gi">+    def merge_domaindata(self, docnames: list[str], otherdata: _DurationDomainData) -&gt; None:  # type: ignore[override]</span>
<span class="gi">+        other_reading_durations = otherdata.get(&#39;reading_durations&#39;, {})</span>
<span class="gi">+        docnames_set = frozenset(docnames)</span>
<span class="gi">+        for docname, duration in other_reading_durations.items():</span>
<span class="gi">+            if docname in docnames_set:</span>
<span class="gi">+                self.reading_durations[docname] = duration</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def on_builder_inited(app: Sphinx) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Initialize DurationDomain on bootstrap.

<span class="w"> </span>    This clears the results of the last build.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    domain = cast(DurationDomain, app.env.get_domain(&#39;duration&#39;))</span>
<span class="gi">+    domain.clear()</span>


<span class="gd">-def on_source_read(app: Sphinx, docname: str, content: list[str]) -&gt;None:</span>
<span class="gi">+def on_source_read(app: Sphinx, docname: str, content: list[str]) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Start to measure reading duration.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    app.env.temp_data[&#39;started_at&#39;] = time.monotonic()</span>


<span class="gd">-def on_doctree_read(app: Sphinx, doctree: nodes.document) -&gt;None:</span>
<span class="gi">+def on_doctree_read(app: Sphinx, doctree: nodes.document) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Record a reading duration.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    started_at = app.env.temp_data[&#39;started_at&#39;]</span>
<span class="gi">+    duration = time.monotonic() - started_at</span>
<span class="gi">+    domain = cast(DurationDomain, app.env.get_domain(&#39;duration&#39;))</span>
<span class="gi">+    domain.note_reading_duration(duration)</span>


<span class="gd">-def on_build_finished(app: Sphinx, error: Exception) -&gt;None:</span>
<span class="gi">+def on_build_finished(app: Sphinx, error: Exception) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Display duration ranking on the current build.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    domain = cast(DurationDomain, app.env.get_domain(&#39;duration&#39;))</span>
<span class="gi">+    if not domain.reading_durations:</span>
<span class="gi">+        return</span>
<span class="gi">+    durations = sorted(domain.reading_durations.items(), key=itemgetter(1), reverse=True)</span>
<span class="gi">+</span>
<span class="gi">+    logger.info(&#39;&#39;)</span>
<span class="gi">+    logger.info(__(&#39;====================== slowest reading durations =======================&#39;))</span>
<span class="gi">+    for docname, d in islice(durations, 5):</span>
<span class="gi">+        logger.info(f&#39;{d:.3f} {docname}&#39;)  # NoQA: G004</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; dict[str, bool | str]:</span>
<span class="gi">+    app.add_domain(DurationDomain)</span>
<span class="gi">+    app.connect(&#39;builder-inited&#39;, on_builder_inited)</span>
<span class="gi">+    app.connect(&#39;source-read&#39;, on_source_read)</span>
<span class="gi">+    app.connect(&#39;doctree-read&#39;, on_doctree_read)</span>
<span class="gi">+    app.connect(&#39;build-finished&#39;, on_build_finished)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: sphinx.__display_version__,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/ext/extlinks.py b/sphinx/ext/extlinks.py</span>
<span class="gh">index beb4a5e4b..68c1385af 100644</span>
<span class="gd">--- a/sphinx/ext/extlinks.py</span>
<span class="gi">+++ b/sphinx/ext/extlinks.py</span>
<span class="gu">@@ -16,21 +16,29 @@ You can also give an explicit caption, e.g. :exmpl:`Foo &lt;foo&gt;`.</span>

<span class="w"> </span>Both, the url string and the caption string must escape ``%`` as ``%%``.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes, utils
<span class="gi">+</span>
<span class="w"> </span>import sphinx
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.transforms.post_transforms import SphinxPostTransform
<span class="w"> </span>from sphinx.util import logging, rst
<span class="w"> </span>from sphinx.util.nodes import split_explicit_title
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Sequence
<span class="gi">+</span>
<span class="w"> </span>    from docutils.nodes import Node, system_message
<span class="w"> </span>    from docutils.parsers.rst.states import Inliner
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata, RoleFunction
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="gu">@@ -40,11 +48,80 @@ class ExternalLinksChecker(SphinxPostTransform):</span>

<span class="w"> </span>    We treat each ``reference`` node without ``internal`` attribute as an external link.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    default_priority = 500

<span class="gd">-    def check_uri(self, refnode: nodes.reference) -&gt;None:</span>
<span class="gi">+    def run(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        if not self.config.extlinks_detect_hardcoded_links:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        for refnode in self.document.findall(nodes.reference):</span>
<span class="gi">+            self.check_uri(refnode)</span>
<span class="gi">+</span>
<span class="gi">+    def check_uri(self, refnode: nodes.reference) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        If the URI in ``refnode`` has a replacement in ``extlinks``,
<span class="w"> </span>        emit a warning with a replacement suggestion.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if &#39;internal&#39; in refnode or &#39;refuri&#39; not in refnode:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        uri = refnode[&#39;refuri&#39;]</span>
<span class="gi">+        title = refnode.astext()</span>
<span class="gi">+</span>
<span class="gi">+        for alias, (base_uri, _caption) in self.app.config.extlinks.items():</span>
<span class="gi">+            uri_pattern = re.compile(re.escape(base_uri).replace(&#39;%s&#39;, &#39;(?P&lt;value&gt;.+)&#39;))</span>
<span class="gi">+</span>
<span class="gi">+            match = uri_pattern.match(uri)</span>
<span class="gi">+            if (</span>
<span class="gi">+                match and</span>
<span class="gi">+                match.groupdict().get(&#39;value&#39;) and</span>
<span class="gi">+                &#39;/&#39; not in match.groupdict()[&#39;value&#39;]</span>
<span class="gi">+            ):</span>
<span class="gi">+                # build a replacement suggestion</span>
<span class="gi">+                msg = __(&#39;hardcoded link %r could be replaced by an extlink &#39;</span>
<span class="gi">+                         &#39;(try using %r instead)&#39;)</span>
<span class="gi">+                value = match.groupdict().get(&#39;value&#39;)</span>
<span class="gi">+                if uri != title:</span>
<span class="gi">+                    replacement = f&quot;:{alias}:`{rst.escape(title)} &lt;{value}&gt;`&quot;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    replacement = f&quot;:{alias}:`{value}`&quot;</span>
<span class="gi">+                logger.warning(msg, uri, replacement, location=refnode)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make_link_role(name: str, base_url: str, caption: str) -&gt; RoleFunction:</span>
<span class="gi">+    # Check whether we have base_url and caption strings have an &#39;%s&#39; for</span>
<span class="gi">+    # expansion.  If not, fall back to the old behaviour and use the string as</span>
<span class="gi">+    # a prefix.</span>
<span class="gi">+    # Remark: It is an implementation detail that we use Python&#39;s %-formatting.</span>
<span class="gi">+    # So far we only expose ``%s`` and require quoting of ``%`` using ``%%``.</span>
<span class="gi">+    def role(typ: str, rawtext: str, text: str, lineno: int,</span>
<span class="gi">+             inliner: Inliner, options: dict[str, Any] | None = None,</span>
<span class="gi">+             content: Sequence[str] = (),</span>
<span class="gi">+             ) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+        text = utils.unescape(text)</span>
<span class="gi">+        has_explicit_title, title, part = split_explicit_title(text)</span>
<span class="gi">+        full_url = base_url % part</span>
<span class="gi">+        if not has_explicit_title:</span>
<span class="gi">+            if caption is None:</span>
<span class="gi">+                title = full_url</span>
<span class="gi">+            else:</span>
<span class="gi">+                title = caption % part</span>
<span class="gi">+        pnode = nodes.reference(title, title, internal=False, refuri=full_url)</span>
<span class="gi">+        pnode[&quot;classes&quot;].append(f&quot;extlink-{name}&quot;)</span>
<span class="gi">+        return [pnode], []</span>
<span class="gi">+    return role</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup_link_roles(app: Sphinx) -&gt; None:</span>
<span class="gi">+    for name, (base_url, caption) in app.config.extlinks.items():</span>
<span class="gi">+        app.add_role(name, make_link_role(name, base_url, caption))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_config_value(&#39;extlinks&#39;, {}, &#39;env&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;extlinks_detect_hardcoded_links&#39;, False, &#39;env&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    app.connect(&#39;builder-inited&#39;, setup_link_roles)</span>
<span class="gi">+    app.add_post_transform(ExternalLinksChecker)</span>
<span class="gi">+    return {&#39;version&#39;: sphinx.__display_version__, &#39;parallel_read_safe&#39;: True}</span>
<span class="gh">diff --git a/sphinx/ext/githubpages.py b/sphinx/ext/githubpages.py</span>
<span class="gh">index 67d37a5bc..aac47975a 100644</span>
<span class="gd">--- a/sphinx/ext/githubpages.py</span>
<span class="gi">+++ b/sphinx/ext/githubpages.py</span>
<span class="gu">@@ -1,22 +1,26 @@</span>
<span class="w"> </span>&quot;&quot;&quot;To publish HTML docs at GitHub Pages, create .nojekyll file.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import contextlib
<span class="w"> </span>import os
<span class="w"> </span>import urllib.parse
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>import sphinx
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata


<span class="gd">-def _get_domain_from_url(url: str) -&gt;str:</span>
<span class="gi">+def _get_domain_from_url(url: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the domain from a URL.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return url and urllib.parse.urlparse(url).hostname or &#39;&#39;</span>


<span class="gd">-def create_nojekyll_and_cname(app: Sphinx, env: BuildEnvironment) -&gt;None:</span>
<span class="gi">+def create_nojekyll_and_cname(app: Sphinx, env: BuildEnvironment) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Manage the ``.nojekyll`` and ``CNAME`` files for GitHub Pages.

<span class="w"> </span>    For HTML-format builders (e.g. &#39;html&#39;, &#39;dirhtml&#39;) we unconditionally create
<span class="gu">@@ -31,4 +35,24 @@ def create_nojekyll_and_cname(app: Sphinx, env: BuildEnvironment) -&gt;None:</span>
<span class="w"> </span>    requires a CNAME file, we remove any existing ``CNAME`` files from the
<span class="w"> </span>    output directory.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if app.builder.format != &#39;html&#39;:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    app.builder.outdir.joinpath(&#39;.nojekyll&#39;).touch()</span>
<span class="gi">+    cname_path = os.path.join(app.builder.outdir, &#39;CNAME&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    domain = _get_domain_from_url(app.config.html_baseurl)</span>
<span class="gi">+    # Filter out GitHub Pages domains, as they do not require CNAME files.</span>
<span class="gi">+    if domain and not domain.endswith(&quot;.github.io&quot;):</span>
<span class="gi">+        with open(cname_path, &#39;w&#39;, encoding=&quot;utf-8&quot;) as f:</span>
<span class="gi">+            # NOTE: don&#39;t write a trailing newline. The `CNAME` file that&#39;s</span>
<span class="gi">+            # auto-generated by the GitHub UI doesn&#39;t have one.</span>
<span class="gi">+            f.write(domain)</span>
<span class="gi">+    else:</span>
<span class="gi">+        with contextlib.suppress(FileNotFoundError):</span>
<span class="gi">+            os.unlink(cname_path)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.connect(&#39;env-updated&#39;, create_nojekyll_and_cname)</span>
<span class="gi">+    return {&#39;version&#39;: sphinx.__display_version__, &#39;parallel_read_safe&#39;: True}</span>
<span class="gh">diff --git a/sphinx/ext/graphviz.py b/sphinx/ext/graphviz.py</span>
<span class="gh">index 5333534bf..af636c747 100644</span>
<span class="gd">--- a/sphinx/ext/graphviz.py</span>
<span class="gi">+++ b/sphinx/ext/graphviz.py</span>
<span class="gu">@@ -1,6 +1,8 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Allow graphviz-formatted graphs to be included inline in generated documents.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import posixpath
<span class="w"> </span>import re
<span class="w"> </span>import subprocess
<span class="gu">@@ -11,8 +13,10 @@ from os import path</span>
<span class="w"> </span>from subprocess import CalledProcessError
<span class="w"> </span>from typing import TYPE_CHECKING, Any, ClassVar
<span class="w"> </span>from urllib.parse import urlsplit, urlunsplit
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.parsers.rst import directives
<span class="gi">+</span>
<span class="w"> </span>import sphinx
<span class="w"> </span>from sphinx.errors import SphinxError
<span class="w"> </span>from sphinx.locale import _, __
<span class="gu">@@ -21,8 +25,10 @@ from sphinx.util.docutils import SphinxDirective</span>
<span class="w"> </span>from sphinx.util.i18n import search_image_for_language
<span class="w"> </span>from sphinx.util.nodes import set_source_info
<span class="w"> </span>from sphinx.util.osutil import ensuredir
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.nodes import Node
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.config import Config
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata, OptionSpec
<span class="gu">@@ -31,6 +37,7 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>    from sphinx.writers.manpage import ManualPageTranslator
<span class="w"> </span>    from sphinx.writers.texinfo import TexinfoTranslator
<span class="w"> </span>    from sphinx.writers.text import TextTranslator
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="gu">@@ -40,64 +47,424 @@ class GraphvizError(SphinxError):</span>

<span class="w"> </span>class ClickableMapDefinition:
<span class="w"> </span>    &quot;&quot;&quot;A manipulator for clickable map file of graphviz.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    maptag_re = re.compile(&#39;&lt;map id=&quot;(.*?)&quot;&#39;)
<span class="w"> </span>    href_re = re.compile(&#39;href=&quot;.*?&quot;&#39;)

<span class="gd">-    def __init__(self, filename: str, content: str, dot: str=&#39;&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, filename: str, content: str, dot: str = &#39;&#39;) -&gt; None:</span>
<span class="w"> </span>        self.id: str | None = None
<span class="w"> </span>        self.filename = filename
<span class="w"> </span>        self.content = content.splitlines()
<span class="w"> </span>        self.clickable: list[str] = []
<span class="gi">+</span>
<span class="w"> </span>        self.parse(dot=dot)

<span class="gd">-    def generate_clickable_map(self) -&gt;str:</span>
<span class="gi">+    def parse(self, dot: str) -&gt; None:</span>
<span class="gi">+        matched = self.maptag_re.match(self.content[0])</span>
<span class="gi">+        if not matched:</span>
<span class="gi">+            raise GraphvizError(&#39;Invalid clickable map file found: %s&#39; % self.filename)</span>
<span class="gi">+</span>
<span class="gi">+        self.id = matched.group(1)</span>
<span class="gi">+        if self.id == &#39;%3&#39;:</span>
<span class="gi">+            # graphviz generates wrong ID if graph name not specified</span>
<span class="gi">+            # https://gitlab.com/graphviz/graphviz/issues/1327</span>
<span class="gi">+            hashed = sha1(dot.encode(), usedforsecurity=False).hexdigest()</span>
<span class="gi">+            self.id = &#39;grapviz%s&#39; % hashed[-10:]</span>
<span class="gi">+            self.content[0] = self.content[0].replace(&#39;%3&#39;, self.id)</span>
<span class="gi">+</span>
<span class="gi">+        for line in self.content:</span>
<span class="gi">+            if self.href_re.search(line):</span>
<span class="gi">+                self.clickable.append(line)</span>
<span class="gi">+</span>
<span class="gi">+    def generate_clickable_map(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate clickable map tags if clickable item exists.

<span class="w"> </span>        If not exists, this only returns empty string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.clickable:</span>
<span class="gi">+            return &#39;\n&#39;.join((self.content[0], *self.clickable, self.content[-1]))</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;&#39;</span>


<span class="w"> </span>class graphviz(nodes.General, nodes.Inline, nodes.Element):
<span class="w"> </span>    pass


<span class="gi">+def figure_wrapper(directive: SphinxDirective, node: graphviz, caption: str) -&gt; nodes.figure:</span>
<span class="gi">+    figure_node = nodes.figure(&#39;&#39;, node)</span>
<span class="gi">+    if &#39;align&#39; in node:</span>
<span class="gi">+        figure_node[&#39;align&#39;] = node.attributes.pop(&#39;align&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    inodes, messages = directive.parse_inline(caption)</span>
<span class="gi">+    caption_node = nodes.caption(caption, &#39;&#39;, *inodes)</span>
<span class="gi">+    caption_node.extend(messages)</span>
<span class="gi">+    set_source_info(directive, caption_node)</span>
<span class="gi">+    figure_node += caption_node</span>
<span class="gi">+    return figure_node</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def align_spec(argument: Any) -&gt; str:</span>
<span class="gi">+    return directives.choice(argument, (&#39;left&#39;, &#39;center&#39;, &#39;right&#39;))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class Graphviz(SphinxDirective):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Directive to insert arbitrary dot markup.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    has_content = True
<span class="w"> </span>    required_arguments = 0
<span class="w"> </span>    optional_arguments = 1
<span class="w"> </span>    final_argument_whitespace = False
<span class="gd">-    option_spec: ClassVar[OptionSpec] = {&#39;alt&#39;: directives.unchanged,</span>
<span class="gd">-        &#39;align&#39;: align_spec, &#39;caption&#39;: directives.unchanged, &#39;layout&#39;:</span>
<span class="gd">-        directives.unchanged, &#39;graphviz_dot&#39;: directives.unchanged, &#39;name&#39;:</span>
<span class="gd">-        directives.unchanged, &#39;class&#39;: directives.class_option}</span>
<span class="gi">+    option_spec: ClassVar[OptionSpec] = {</span>
<span class="gi">+        &#39;alt&#39;: directives.unchanged,</span>
<span class="gi">+        &#39;align&#39;: align_spec,</span>
<span class="gi">+        &#39;caption&#39;: directives.unchanged,</span>
<span class="gi">+        &#39;layout&#39;: directives.unchanged,</span>
<span class="gi">+        &#39;graphviz_dot&#39;: directives.unchanged,  # an old alias of `layout` option</span>
<span class="gi">+        &#39;name&#39;: directives.unchanged,</span>
<span class="gi">+        &#39;class&#39;: directives.class_option,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        if self.arguments:</span>
<span class="gi">+            document = self.state.document</span>
<span class="gi">+            if self.content:</span>
<span class="gi">+                return [document.reporter.warning(</span>
<span class="gi">+                    __(&#39;Graphviz directive cannot have both content and &#39;</span>
<span class="gi">+                       &#39;a filename argument&#39;), line=self.lineno)]</span>
<span class="gi">+            argument = search_image_for_language(self.arguments[0], self.env)</span>
<span class="gi">+            rel_filename, filename = self.env.relfn2path(argument)</span>
<span class="gi">+            self.env.note_dependency(rel_filename)</span>
<span class="gi">+            try:</span>
<span class="gi">+                with open(filename, encoding=&#39;utf-8&#39;) as fp:</span>
<span class="gi">+                    dotcode = fp.read()</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                return [document.reporter.warning(</span>
<span class="gi">+                    __(&#39;External Graphviz file %r not found or reading &#39;</span>
<span class="gi">+                       &#39;it failed&#39;) % filename, line=self.lineno)]</span>
<span class="gi">+        else:</span>
<span class="gi">+            dotcode = &#39;\n&#39;.join(self.content)</span>
<span class="gi">+            rel_filename = None</span>
<span class="gi">+            if not dotcode.strip():</span>
<span class="gi">+                return [self.state_machine.reporter.warning(</span>
<span class="gi">+                    __(&#39;Ignoring &quot;graphviz&quot; directive without content.&#39;),</span>
<span class="gi">+                    line=self.lineno)]</span>
<span class="gi">+        node = graphviz()</span>
<span class="gi">+        node[&#39;code&#39;] = dotcode</span>
<span class="gi">+        node[&#39;options&#39;] = {&#39;docname&#39;: self.env.docname}</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;graphviz_dot&#39; in self.options:</span>
<span class="gi">+            node[&#39;options&#39;][&#39;graphviz_dot&#39;] = self.options[&#39;graphviz_dot&#39;]</span>
<span class="gi">+        if &#39;layout&#39; in self.options:</span>
<span class="gi">+            node[&#39;options&#39;][&#39;graphviz_dot&#39;] = self.options[&#39;layout&#39;]</span>
<span class="gi">+        if &#39;alt&#39; in self.options:</span>
<span class="gi">+            node[&#39;alt&#39;] = self.options[&#39;alt&#39;]</span>
<span class="gi">+        if &#39;align&#39; in self.options:</span>
<span class="gi">+            node[&#39;align&#39;] = self.options[&#39;align&#39;]</span>
<span class="gi">+        if &#39;class&#39; in self.options:</span>
<span class="gi">+            node[&#39;classes&#39;] = self.options[&#39;class&#39;]</span>
<span class="gi">+        if rel_filename:</span>
<span class="gi">+            node[&#39;filename&#39;] = rel_filename</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;caption&#39; not in self.options:</span>
<span class="gi">+            self.add_name(node)</span>
<span class="gi">+            return [node]</span>
<span class="gi">+        else:</span>
<span class="gi">+            figure = figure_wrapper(self, node, self.options[&#39;caption&#39;])</span>
<span class="gi">+            self.add_name(figure)</span>
<span class="gi">+            return [figure]</span>


<span class="w"> </span>class GraphvizSimple(SphinxDirective):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Directive to insert arbitrary dot markup.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    has_content = True
<span class="w"> </span>    required_arguments = 1
<span class="w"> </span>    optional_arguments = 0
<span class="w"> </span>    final_argument_whitespace = False
<span class="gd">-    option_spec: ClassVar[OptionSpec] = {&#39;alt&#39;: directives.unchanged,</span>
<span class="gd">-        &#39;align&#39;: align_spec, &#39;caption&#39;: directives.unchanged, &#39;layout&#39;:</span>
<span class="gd">-        directives.unchanged, &#39;graphviz_dot&#39;: directives.unchanged, &#39;name&#39;:</span>
<span class="gd">-        directives.unchanged, &#39;class&#39;: directives.class_option}</span>
<span class="gi">+    option_spec: ClassVar[OptionSpec] = {</span>
<span class="gi">+        &#39;alt&#39;: directives.unchanged,</span>
<span class="gi">+        &#39;align&#39;: align_spec,</span>
<span class="gi">+        &#39;caption&#39;: directives.unchanged,</span>
<span class="gi">+        &#39;layout&#39;: directives.unchanged,</span>
<span class="gi">+        &#39;graphviz_dot&#39;: directives.unchanged,  # an old alias of `layout` option</span>
<span class="gi">+        &#39;name&#39;: directives.unchanged,</span>
<span class="gi">+        &#39;class&#39;: directives.class_option,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        node = graphviz()</span>
<span class="gi">+        node[&#39;code&#39;] = &#39;%s %s {\n%s\n}\n&#39; % \</span>
<span class="gi">+                       (self.name, self.arguments[0], &#39;\n&#39;.join(self.content))</span>
<span class="gi">+        node[&#39;options&#39;] = {&#39;docname&#39;: self.env.docname}</span>
<span class="gi">+        if &#39;graphviz_dot&#39; in self.options:</span>
<span class="gi">+            node[&#39;options&#39;][&#39;graphviz_dot&#39;] = self.options[&#39;graphviz_dot&#39;]</span>
<span class="gi">+        if &#39;layout&#39; in self.options:</span>
<span class="gi">+            node[&#39;options&#39;][&#39;graphviz_dot&#39;] = self.options[&#39;layout&#39;]</span>
<span class="gi">+        if &#39;alt&#39; in self.options:</span>
<span class="gi">+            node[&#39;alt&#39;] = self.options[&#39;alt&#39;]</span>
<span class="gi">+        if &#39;align&#39; in self.options:</span>
<span class="gi">+            node[&#39;align&#39;] = self.options[&#39;align&#39;]</span>
<span class="gi">+        if &#39;class&#39; in self.options:</span>
<span class="gi">+            node[&#39;classes&#39;] = self.options[&#39;class&#39;]</span>

<span class="gi">+        if &#39;caption&#39; not in self.options:</span>
<span class="gi">+            self.add_name(node)</span>
<span class="gi">+            return [node]</span>
<span class="gi">+        else:</span>
<span class="gi">+            figure = figure_wrapper(self, node, self.options[&#39;caption&#39;])</span>
<span class="gi">+            self.add_name(figure)</span>
<span class="gi">+            return [figure]</span>

<span class="gd">-def fix_svg_relative_paths(self: (HTML5Translator | LaTeXTranslator |</span>
<span class="gd">-    TexinfoTranslator), filepath: str) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+def fix_svg_relative_paths(self: HTML5Translator | LaTeXTranslator | TexinfoTranslator,</span>
<span class="gi">+                           filepath: str) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Change relative links in generated svg files to be relative to imgpath.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    tree = ET.parse(filepath)  # NoQA: S314</span>
<span class="gi">+    root = tree.getroot()</span>
<span class="gi">+    ns = {&#39;svg&#39;: &#39;http://www.w3.org/2000/svg&#39;, &#39;xlink&#39;: &#39;http://www.w3.org/1999/xlink&#39;}</span>
<span class="gi">+    href_name = &#39;{http://www.w3.org/1999/xlink}href&#39;</span>
<span class="gi">+    modified = False</span>
<span class="gi">+</span>
<span class="gi">+    for element in chain(</span>
<span class="gi">+        root.findall(&#39;.//svg:image[@xlink:href]&#39;, ns),</span>
<span class="gi">+        root.findall(&#39;.//svg:a[@xlink:href]&#39;, ns),</span>
<span class="gi">+    ):</span>
<span class="gi">+        scheme, hostname, rel_uri, query, fragment = urlsplit(element.attrib[href_name])</span>
<span class="gi">+        if hostname:</span>
<span class="gi">+            # not a relative link</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        docname = self.builder.env.path2doc(self.document[&quot;source&quot;])</span>
<span class="gi">+        if docname is None:</span>
<span class="gi">+            # This shouldn&#39;t happen!</span>
<span class="gi">+            continue</span>
<span class="gi">+        doc_dir = self.builder.app.outdir.joinpath(docname).resolve().parent</span>

<span class="gi">+        old_path = doc_dir / rel_uri</span>
<span class="gi">+        img_path = doc_dir / self.builder.imgpath</span>
<span class="gi">+        new_path = path.relpath(old_path, start=img_path)</span>
<span class="gi">+        modified_url = urlunsplit((scheme, hostname, new_path, query, fragment))</span>

<span class="gd">-def render_dot(self: (HTML5Translator | LaTeXTranslator | TexinfoTranslator</span>
<span class="gd">-    ), code: str, options: dict, format: str, prefix: str=&#39;graphviz&#39;,</span>
<span class="gd">-    filename: (str | None)=None) -&gt;tuple[str | None, str | None]:</span>
<span class="gi">+        element.set(href_name, modified_url)</span>
<span class="gi">+        modified = True</span>
<span class="gi">+</span>
<span class="gi">+    if modified:</span>
<span class="gi">+        tree.write(filepath)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def render_dot(self: HTML5Translator | LaTeXTranslator | TexinfoTranslator,</span>
<span class="gi">+               code: str, options: dict, format: str,</span>
<span class="gi">+               prefix: str = &#39;graphviz&#39;, filename: str | None = None,</span>
<span class="gi">+               ) -&gt; tuple[str | None, str | None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Render graphviz code into a PNG or PDF output file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    graphviz_dot = options.get(&#39;graphviz_dot&#39;, self.builder.config.graphviz_dot)</span>
<span class="gi">+    if not graphviz_dot:</span>
<span class="gi">+        raise GraphvizError(</span>
<span class="gi">+            __(&#39;graphviz_dot executable path must be set! %r&#39;) % graphviz_dot,</span>
<span class="gi">+        )</span>
<span class="gi">+    hashkey = (code + str(options) + str(graphviz_dot) +</span>
<span class="gi">+               str(self.builder.config.graphviz_dot_args)).encode()</span>
<span class="gi">+</span>
<span class="gi">+    fname = f&#39;{prefix}-{sha1(hashkey, usedforsecurity=False).hexdigest()}.{format}&#39;</span>
<span class="gi">+    relfn = posixpath.join(self.builder.imgpath, fname)</span>
<span class="gi">+    outfn = path.join(self.builder.outdir, self.builder.imagedir, fname)</span>
<span class="gi">+</span>
<span class="gi">+    if path.isfile(outfn):</span>
<span class="gi">+        return relfn, outfn</span>
<span class="gi">+</span>
<span class="gi">+    if (hasattr(self.builder, &#39;_graphviz_warned_dot&#39;) and</span>
<span class="gi">+       self.builder._graphviz_warned_dot.get(graphviz_dot)):</span>
<span class="gi">+        return None, None</span>
<span class="gi">+</span>
<span class="gi">+    ensuredir(path.dirname(outfn))</span>
<span class="gi">+</span>
<span class="gi">+    dot_args = [graphviz_dot]</span>
<span class="gi">+    dot_args.extend(self.builder.config.graphviz_dot_args)</span>
<span class="gi">+    dot_args.extend([&#39;-T&#39; + format, &#39;-o&#39; + outfn])</span>
<span class="gi">+</span>
<span class="gi">+    docname = options.get(&#39;docname&#39;, &#39;index&#39;)</span>
<span class="gi">+    if filename:</span>
<span class="gi">+        cwd = path.dirname(path.join(self.builder.srcdir, filename))</span>
<span class="gi">+    else:</span>
<span class="gi">+        cwd = path.dirname(path.join(self.builder.srcdir, docname))</span>
<span class="gi">+</span>
<span class="gi">+    if format == &#39;png&#39;:</span>
<span class="gi">+        dot_args.extend([&#39;-Tcmapx&#39;, &#39;-o%s.map&#39; % outfn])</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        ret = subprocess.run(dot_args, input=code.encode(), capture_output=True,</span>
<span class="gi">+                             cwd=cwd, check=True)</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        logger.warning(__(&#39;dot command %r cannot be run (needed for graphviz &#39;</span>
<span class="gi">+                          &#39;output), check the graphviz_dot setting&#39;), graphviz_dot)</span>
<span class="gi">+        if not hasattr(self.builder, &#39;_graphviz_warned_dot&#39;):</span>
<span class="gi">+            self.builder._graphviz_warned_dot = {}  # type: ignore[union-attr]</span>
<span class="gi">+        self.builder._graphviz_warned_dot[graphviz_dot] = True</span>
<span class="gi">+        return None, None</span>
<span class="gi">+    except CalledProcessError as exc:</span>
<span class="gi">+        raise GraphvizError(__(&#39;dot exited with error:\n[stderr]\n%r\n&#39;</span>
<span class="gi">+                               &#39;[stdout]\n%r&#39;) % (exc.stderr, exc.stdout)) from exc</span>
<span class="gi">+    if not path.isfile(outfn):</span>
<span class="gi">+        raise GraphvizError(__(&#39;dot did not produce an output file:\n[stderr]\n%r\n&#39;</span>
<span class="gi">+                               &#39;[stdout]\n%r&#39;) % (ret.stderr, ret.stdout))</span>
<span class="gi">+</span>
<span class="gi">+    if format == &#39;svg&#39;:</span>
<span class="gi">+        fix_svg_relative_paths(self, outfn)</span>
<span class="gi">+</span>
<span class="gi">+    return relfn, outfn</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def render_dot_html(self: HTML5Translator, node: graphviz, code: str, options: dict,</span>
<span class="gi">+                    prefix: str = &#39;graphviz&#39;, imgcls: str | None = None,</span>
<span class="gi">+                    alt: str | None = None, filename: str | None = None,</span>
<span class="gi">+                    ) -&gt; tuple[str, str]:</span>
<span class="gi">+    format = self.builder.config.graphviz_output_format</span>
<span class="gi">+    try:</span>
<span class="gi">+        if format not in (&#39;png&#39;, &#39;svg&#39;):</span>
<span class="gi">+            raise GraphvizError(__(&quot;graphviz_output_format must be one of &#39;png&#39;, &quot;</span>
<span class="gi">+                                   &quot;&#39;svg&#39;, but is %r&quot;) % format)</span>
<span class="gi">+        fname, outfn = render_dot(self, code, options, format, prefix, filename)</span>
<span class="gi">+    except GraphvizError as exc:</span>
<span class="gi">+        logger.warning(__(&#39;dot code %r: %s&#39;), code, exc)</span>
<span class="gi">+        raise nodes.SkipNode from exc</span>
<span class="gi">+</span>
<span class="gi">+    classes = [imgcls, &#39;graphviz&#39;, *node.get(&#39;classes&#39;, [])]</span>
<span class="gi">+    imgcls = &#39; &#39;.join(filter(None, classes))</span>
<span class="gi">+</span>
<span class="gi">+    if fname is None:</span>
<span class="gi">+        self.body.append(self.encode(code))</span>
<span class="gi">+    else:</span>
<span class="gi">+        if alt is None:</span>
<span class="gi">+            alt = node.get(&#39;alt&#39;, self.encode(code).strip())</span>
<span class="gi">+        if &#39;align&#39; in node:</span>
<span class="gi">+            self.body.append(&#39;&lt;div align=&quot;%s&quot; class=&quot;align-%s&quot;&gt;&#39; %</span>
<span class="gi">+                             (node[&#39;align&#39;], node[&#39;align&#39;]))</span>
<span class="gi">+        if format == &#39;svg&#39;:</span>
<span class="gi">+            self.body.append(&#39;&lt;div class=&quot;graphviz&quot;&gt;&#39;)</span>
<span class="gi">+            self.body.append(&#39;&lt;object data=&quot;%s&quot; type=&quot;image/svg+xml&quot; class=&quot;%s&quot;&gt;\n&#39; %</span>
<span class="gi">+                             (fname, imgcls))</span>
<span class="gi">+            self.body.append(&#39;&lt;p class=&quot;warning&quot;&gt;%s&lt;/p&gt;&#39; % alt)</span>
<span class="gi">+            self.body.append(&#39;&lt;/object&gt;&lt;/div&gt;\n&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert outfn is not None</span>
<span class="gi">+            with open(outfn + &#39;.map&#39;, encoding=&#39;utf-8&#39;) as mapfile:</span>
<span class="gi">+                imgmap = ClickableMapDefinition(outfn + &#39;.map&#39;, mapfile.read(), dot=code)</span>
<span class="gi">+                if imgmap.clickable:</span>
<span class="gi">+                    # has a map</span>
<span class="gi">+                    self.body.append(&#39;&lt;div class=&quot;graphviz&quot;&gt;&#39;)</span>
<span class="gi">+                    self.body.append(&#39;&lt;img src=&quot;%s&quot; alt=&quot;%s&quot; usemap=&quot;#%s&quot; class=&quot;%s&quot; /&gt;&#39; %</span>
<span class="gi">+                                     (fname, alt, imgmap.id, imgcls))</span>
<span class="gi">+                    self.body.append(&#39;&lt;/div&gt;\n&#39;)</span>
<span class="gi">+                    self.body.append(imgmap.generate_clickable_map())</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # nothing in image map</span>
<span class="gi">+                    self.body.append(&#39;&lt;div class=&quot;graphviz&quot;&gt;&#39;)</span>
<span class="gi">+                    self.body.append(&#39;&lt;img src=&quot;%s&quot; alt=&quot;%s&quot; class=&quot;%s&quot; /&gt;&#39; %</span>
<span class="gi">+                                     (fname, alt, imgcls))</span>
<span class="gi">+                    self.body.append(&#39;&lt;/div&gt;\n&#39;)</span>
<span class="gi">+        if &#39;align&#39; in node:</span>
<span class="gi">+            self.body.append(&#39;&lt;/div&gt;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def html_visit_graphviz(self: HTML5Translator, node: graphviz) -&gt; None:</span>
<span class="gi">+    render_dot_html(self, node, node[&#39;code&#39;], node[&#39;options&#39;], filename=node.get(&#39;filename&#39;))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def render_dot_latex(self: LaTeXTranslator, node: graphviz, code: str,</span>
<span class="gi">+                     options: dict, prefix: str = &#39;graphviz&#39;, filename: str | None = None,</span>
<span class="gi">+                     ) -&gt; None:</span>
<span class="gi">+    try:</span>
<span class="gi">+        fname, outfn = render_dot(self, code, options, &#39;pdf&#39;, prefix, filename)</span>
<span class="gi">+    except GraphvizError as exc:</span>
<span class="gi">+        logger.warning(__(&#39;dot code %r: %s&#39;), code, exc)</span>
<span class="gi">+        raise nodes.SkipNode from exc</span>
<span class="gi">+</span>
<span class="gi">+    is_inline = self.is_inline(node)</span>
<span class="gi">+</span>
<span class="gi">+    if not is_inline:</span>
<span class="gi">+        pre = &#39;&#39;</span>
<span class="gi">+        post = &#39;&#39;</span>
<span class="gi">+        if &#39;align&#39; in node:</span>
<span class="gi">+            if node[&#39;align&#39;] == &#39;left&#39;:</span>
<span class="gi">+                pre = &#39;{&#39;</span>
<span class="gi">+                post = r&#39;\hspace*{\fill}}&#39;</span>
<span class="gi">+            elif node[&#39;align&#39;] == &#39;right&#39;:</span>
<span class="gi">+                pre = r&#39;{\hspace*{\fill}&#39;</span>
<span class="gi">+                post = &#39;}&#39;</span>
<span class="gi">+            elif node[&#39;align&#39;] == &#39;center&#39;:</span>
<span class="gi">+                pre = r&#39;{\hfill&#39;</span>
<span class="gi">+                post = r&#39;\hspace*{\fill}}&#39;</span>
<span class="gi">+        self.body.append(&#39;\n%s&#39; % pre)</span>
<span class="gi">+</span>
<span class="gi">+    self.body.append(r&#39;\sphinxincludegraphics[]{%s}&#39; % fname)</span>
<span class="gi">+</span>
<span class="gi">+    if not is_inline:</span>
<span class="gi">+        self.body.append(&#39;%s\n&#39; % post)</span>
<span class="gi">+</span>
<span class="gi">+    raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def latex_visit_graphviz(self: LaTeXTranslator, node: graphviz) -&gt; None:</span>
<span class="gi">+    render_dot_latex(self, node, node[&#39;code&#39;], node[&#39;options&#39;], filename=node.get(&#39;filename&#39;))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def render_dot_texinfo(self: TexinfoTranslator, node: graphviz, code: str,</span>
<span class="gi">+                       options: dict, prefix: str = &#39;graphviz&#39;) -&gt; None:</span>
<span class="gi">+    try:</span>
<span class="gi">+        fname, outfn = render_dot(self, code, options, &#39;png&#39;, prefix)</span>
<span class="gi">+    except GraphvizError as exc:</span>
<span class="gi">+        logger.warning(__(&#39;dot code %r: %s&#39;), code, exc)</span>
<span class="gi">+        raise nodes.SkipNode from exc</span>
<span class="gi">+    if fname is not None:</span>
<span class="gi">+        self.body.append(&#39;@image{%s,,,[graphviz],png}\n&#39; % fname[:-4])</span>
<span class="gi">+    raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def texinfo_visit_graphviz(self: TexinfoTranslator, node: graphviz) -&gt; None:</span>
<span class="gi">+    render_dot_texinfo(self, node, node[&#39;code&#39;], node[&#39;options&#39;])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def text_visit_graphviz(self: TextTranslator, node: graphviz) -&gt; None:</span>
<span class="gi">+    if &#39;alt&#39; in node.attributes:</span>
<span class="gi">+        self.add_text(_(&#39;[graph: %s]&#39;) % node[&#39;alt&#39;])</span>
<span class="gi">+    else:</span>
<span class="gi">+        self.add_text(_(&#39;[graph]&#39;))</span>
<span class="gi">+    raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def man_visit_graphviz(self: ManualPageTranslator, node: graphviz) -&gt; None:</span>
<span class="gi">+    if &#39;alt&#39; in node.attributes:</span>
<span class="gi">+        self.body.append(_(&#39;[graph: %s]&#39;) % node[&#39;alt&#39;])</span>
<span class="gi">+    else:</span>
<span class="gi">+        self.body.append(_(&#39;[graph]&#39;))</span>
<span class="gi">+    raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def on_config_inited(_app: Sphinx, config: Config) -&gt; None:</span>
<span class="gi">+    css_path = path.join(sphinx.package_dir, &#39;templates&#39;, &#39;graphviz&#39;, &#39;graphviz.css&#39;)</span>
<span class="gi">+    config.html_static_path.append(css_path)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_node(graphviz,</span>
<span class="gi">+                 html=(html_visit_graphviz, None),</span>
<span class="gi">+                 latex=(latex_visit_graphviz, None),</span>
<span class="gi">+                 texinfo=(texinfo_visit_graphviz, None),</span>
<span class="gi">+                 text=(text_visit_graphviz, None),</span>
<span class="gi">+                 man=(man_visit_graphviz, None))</span>
<span class="gi">+    app.add_directive(&#39;graphviz&#39;, Graphviz)</span>
<span class="gi">+    app.add_directive(&#39;graph&#39;, GraphvizSimple)</span>
<span class="gi">+    app.add_directive(&#39;digraph&#39;, GraphvizSimple)</span>
<span class="gi">+    app.add_config_value(&#39;graphviz_dot&#39;, &#39;dot&#39;, &#39;html&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;graphviz_dot_args&#39;, [], &#39;html&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;graphviz_output_format&#39;, &#39;png&#39;, &#39;html&#39;)</span>
<span class="gi">+    app.add_css_file(&#39;graphviz.css&#39;)</span>
<span class="gi">+    app.connect(&#39;config-inited&#39;, on_config_inited)</span>
<span class="gi">+    return {&#39;version&#39;: sphinx.__display_version__, &#39;parallel_read_safe&#39;: True}</span>
<span class="gh">diff --git a/sphinx/ext/ifconfig.py b/sphinx/ext/ifconfig.py</span>
<span class="gh">index 97b3f6272..17331a0bd 100644</span>
<span class="gd">--- a/sphinx/ext/ifconfig.py</span>
<span class="gi">+++ b/sphinx/ext/ifconfig.py</span>
<span class="gu">@@ -13,13 +13,19 @@ The argument for ``ifconfig`` is a plain Python expression, evaluated in the</span>
<span class="w"> </span>namespace of the project configuration (that is, all variables from
<span class="w"> </span>``conf.py`` are available.)
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, ClassVar
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>import sphinx
<span class="w"> </span>from sphinx.util.docutils import SphinxDirective
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.nodes import Node
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata, OptionSpec

<span class="gu">@@ -29,8 +35,46 @@ class ifconfig(nodes.Element):</span>


<span class="w"> </span>class IfConfig(SphinxDirective):
<span class="gi">+</span>
<span class="w"> </span>    has_content = True
<span class="w"> </span>    required_arguments = 1
<span class="w"> </span>    optional_arguments = 0
<span class="w"> </span>    final_argument_whitespace = True
<span class="w"> </span>    option_spec: ClassVar[OptionSpec] = {}
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        node = ifconfig()</span>
<span class="gi">+        node.document = self.state.document</span>
<span class="gi">+        self.set_source_info(node)</span>
<span class="gi">+        node[&#39;expr&#39;] = self.arguments[0]</span>
<span class="gi">+        node += self.parse_content_to_nodes(allow_section_headings=True)</span>
<span class="gi">+        return [node]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def process_ifconfig_nodes(app: Sphinx, doctree: nodes.document, docname: str) -&gt; None:</span>
<span class="gi">+    ns = {confval.name: confval.value for confval in app.config}</span>
<span class="gi">+    ns.update(app.config.__dict__.copy())</span>
<span class="gi">+    ns[&#39;builder&#39;] = app.builder.name</span>
<span class="gi">+    for node in list(doctree.findall(ifconfig)):</span>
<span class="gi">+        try:</span>
<span class="gi">+            res = eval(node[&#39;expr&#39;], ns)  # NoQA: S307</span>
<span class="gi">+        except Exception as err:</span>
<span class="gi">+            # handle exceptions in a clean fashion</span>
<span class="gi">+            from traceback import format_exception_only</span>
<span class="gi">+            msg = &#39;&#39;.join(format_exception_only(err.__class__, err))</span>
<span class="gi">+            newnode = doctree.reporter.error(&#39;Exception occurred in &#39;</span>
<span class="gi">+                                             &#39;ifconfig expression: \n%s&#39; %</span>
<span class="gi">+                                             msg, base_node=node)</span>
<span class="gi">+            node.replace_self(newnode)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if not res:</span>
<span class="gi">+                node.replace_self([])</span>
<span class="gi">+            else:</span>
<span class="gi">+                node.replace_self(node.children)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_node(ifconfig)</span>
<span class="gi">+    app.add_directive(&#39;ifconfig&#39;, IfConfig)</span>
<span class="gi">+    app.connect(&#39;doctree-resolved&#39;, process_ifconfig_nodes)</span>
<span class="gi">+    return {&#39;version&#39;: sphinx.__display_version__, &#39;parallel_read_safe&#39;: True}</span>
<span class="gh">diff --git a/sphinx/ext/imgconverter.py b/sphinx/ext/imgconverter.py</span>
<span class="gh">index 9c69dd116..e960dd28f 100644</span>
<span class="gd">--- a/sphinx/ext/imgconverter.py</span>
<span class="gi">+++ b/sphinx/ext/imgconverter.py</span>
<span class="gu">@@ -1,29 +1,96 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Image converter extension for Sphinx&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import subprocess
<span class="w"> </span>import sys
<span class="w"> </span>from subprocess import CalledProcessError
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>import sphinx
<span class="w"> </span>from sphinx.errors import ExtensionError
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.transforms.post_transforms.images import ImageConverter
<span class="w"> </span>from sphinx.util import logging
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="w"> </span>class ImagemagickConverter(ImageConverter):
<span class="gd">-    conversion_rules = [(&#39;image/svg+xml&#39;, &#39;image/png&#39;), (&#39;image/gif&#39;,</span>
<span class="gd">-        &#39;image/png&#39;), (&#39;application/pdf&#39;, &#39;image/png&#39;), (</span>
<span class="gd">-        &#39;application/illustrator&#39;, &#39;image/png&#39;), (&#39;image/webp&#39;, &#39;image/png&#39;)]</span>
<span class="gi">+    conversion_rules = [</span>
<span class="gi">+        (&#39;image/svg+xml&#39;, &#39;image/png&#39;),</span>
<span class="gi">+        (&#39;image/gif&#39;, &#39;image/png&#39;),</span>
<span class="gi">+        (&#39;application/pdf&#39;, &#39;image/png&#39;),</span>
<span class="gi">+        (&#39;application/illustrator&#39;, &#39;image/png&#39;),</span>
<span class="gi">+        (&#39;image/webp&#39;, &#39;image/png&#39;),</span>
<span class="gi">+    ]</span>

<span class="gd">-    def is_available(self) -&gt;bool:</span>
<span class="gi">+    def is_available(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Confirms the converter is available or not.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            args = [self.config.image_converter, &#39;-version&#39;]</span>
<span class="gi">+            logger.debug(&#39;Invoking %r ...&#39;, args)</span>
<span class="gi">+            subprocess.run(args, capture_output=True, check=True)</span>
<span class="gi">+            return True</span>
<span class="gi">+        except OSError as exc:</span>
<span class="gi">+            logger.warning(__(</span>
<span class="gi">+                &quot;Unable to run the image conversion command %r. &quot;</span>
<span class="gi">+                &quot;&#39;sphinx.ext.imgconverter&#39; requires ImageMagick by default. &quot;</span>
<span class="gi">+                &quot;Ensure it is installed, or set the &#39;image_converter&#39; option &quot;</span>
<span class="gi">+                &quot;to a custom conversion command.\n\n&quot;</span>
<span class="gi">+                &quot;Traceback: %s&quot;,</span>
<span class="gi">+            ), self.config.image_converter, exc)</span>
<span class="gi">+            return False</span>
<span class="gi">+        except CalledProcessError as exc:</span>
<span class="gi">+            logger.warning(__(&#39;convert exited with error:\n&#39;</span>
<span class="gi">+                              &#39;[stderr]\n%r\n[stdout]\n%r&#39;),</span>
<span class="gi">+                           exc.stderr, exc.stdout)</span>
<span class="gi">+            return False</span>

<span class="gd">-    def convert(self, _from: str, _to: str) -&gt;bool:</span>
<span class="gi">+    def convert(self, _from: str, _to: str) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Converts the image to expected one.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            # append an index 0 to source filename to pick up the first frame</span>
<span class="gi">+            # (or first page) of image (ex. Animation GIF, PDF)</span>
<span class="gi">+            _from += &#39;[0]&#39;</span>
<span class="gi">+</span>
<span class="gi">+            args = ([</span>
<span class="gi">+                self.config.image_converter, *self.config.image_converter_args, _from, _to,</span>
<span class="gi">+            ])</span>
<span class="gi">+            logger.debug(&#39;Invoking %r ...&#39;, args)</span>
<span class="gi">+            subprocess.run(args, capture_output=True, check=True)</span>
<span class="gi">+            return True</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            logger.warning(__(&#39;convert command %r cannot be run, &#39;</span>
<span class="gi">+                              &#39;check the image_converter setting&#39;),</span>
<span class="gi">+                           self.config.image_converter)</span>
<span class="gi">+            return False</span>
<span class="gi">+        except CalledProcessError as exc:</span>
<span class="gi">+            raise ExtensionError(__(&#39;convert exited with error:\n&#39;</span>
<span class="gi">+                                    &#39;[stderr]\n%r\n[stdout]\n%r&#39;) %</span>
<span class="gi">+                                 (exc.stderr, exc.stdout)) from exc</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_post_transform(ImagemagickConverter)</span>
<span class="gi">+    if sys.platform == &#39;win32&#39;:</span>
<span class="gi">+        # On Windows, we use Imagemagik v7 by default to avoid the trouble for</span>
<span class="gi">+        # convert.exe bundled with Windows.</span>
<span class="gi">+        app.add_config_value(&#39;image_converter&#39;, &#39;magick&#39;, &#39;env&#39;)</span>
<span class="gi">+        app.add_config_value(&#39;image_converter_args&#39;, [&#39;convert&#39;], &#39;env&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # On other platform, we use Imagemagick v6 by default.  Especially,</span>
<span class="gi">+        # Debian/Ubuntu are still based of v6.  So we can&#39;t use &quot;magick&quot; command</span>
<span class="gi">+        # for these platforms.</span>
<span class="gi">+        app.add_config_value(&#39;image_converter&#39;, &#39;convert&#39;, &#39;env&#39;)</span>
<span class="gi">+        app.add_config_value(&#39;image_converter_args&#39;, [], &#39;env&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: sphinx.__display_version__,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/ext/imgmath.py b/sphinx/ext/imgmath.py</span>
<span class="gh">index 666d084f5..58da35bfc 100644</span>
<span class="gd">--- a/sphinx/ext/imgmath.py</span>
<span class="gi">+++ b/sphinx/ext/imgmath.py</span>
<span class="gu">@@ -1,6 +1,9 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Render math in HTML via dvipng or dvisvgm.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>__all__ = ()
<span class="gi">+</span>
<span class="w"> </span>import base64
<span class="w"> </span>import contextlib
<span class="w"> </span>import re
<span class="gu">@@ -11,7 +14,9 @@ from hashlib import sha1</span>
<span class="w"> </span>from os import path
<span class="w"> </span>from subprocess import CalledProcessError
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>import sphinx
<span class="w"> </span>from sphinx import package_dir
<span class="w"> </span>from sphinx.errors import SphinxError
<span class="gu">@@ -21,23 +26,29 @@ from sphinx.util.math import get_node_equation_number, wrap_displaymath</span>
<span class="w"> </span>from sphinx.util.osutil import ensuredir
<span class="w"> </span>from sphinx.util.png import read_png_depth, write_png_depth
<span class="w"> </span>from sphinx.util.template import LaTeXRenderer
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    import os
<span class="gi">+</span>
<span class="w"> </span>    from docutils.nodes import Element
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.builders import Builder
<span class="w"> </span>    from sphinx.config import Config
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="w"> </span>    from sphinx.writers.html5 import HTML5Translator
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gi">+</span>
<span class="w"> </span>templates_path = path.join(package_dir, &#39;templates&#39;, &#39;imgmath&#39;)


<span class="w"> </span>class MathExtError(SphinxError):
<span class="w"> </span>    category = &#39;Math extension error&#39;

<span class="gd">-    def __init__(self, msg: str, stderr: (str | None)=None, stdout: (str |</span>
<span class="gd">-        None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, msg: str, stderr: str | None = None, stdout: str | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if stderr:
<span class="w"> </span>            msg += &#39;\n[stderr]\n&#39; + stderr
<span class="w"> </span>        if stdout:
<span class="gu">@@ -49,64 +60,173 @@ class InvokeError(SphinxError):</span>
<span class="w"> </span>    &quot;&quot;&quot;errors on invoking converters.&quot;&quot;&quot;


<span class="gd">-SUPPORT_FORMAT = &#39;png&#39;, &#39;svg&#39;</span>
<span class="gd">-depth_re = re.compile(&#39;\\[\\d+ depth=(-?\\d+)\\]&#39;)</span>
<span class="gd">-depthsvg_re = re.compile(&#39;.*, depth=(.*)pt&#39;)</span>
<span class="gd">-depthsvgcomment_re = re.compile(&#39;&lt;!-- DEPTH=(-?\\d+) --&gt;&#39;)</span>
<span class="gi">+SUPPORT_FORMAT = (&#39;png&#39;, &#39;svg&#39;)</span>
<span class="gi">+</span>
<span class="gi">+depth_re = re.compile(r&#39;\[\d+ depth=(-?\d+)\]&#39;)</span>
<span class="gi">+depthsvg_re = re.compile(r&#39;.*, depth=(.*)pt&#39;)</span>
<span class="gi">+depthsvgcomment_re = re.compile(r&#39;&lt;!-- DEPTH=(-?\d+) --&gt;&#39;)</span>


<span class="gd">-def read_svg_depth(filename: str) -&gt;(int | None):</span>
<span class="gi">+def read_svg_depth(filename: str) -&gt; int | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Read the depth from comment at last line of SVG file
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open(filename, encoding=&quot;utf-8&quot;) as f:</span>
<span class="gi">+        for line in f:  # NoQA: B007</span>
<span class="gi">+            pass</span>
<span class="gi">+        # Only last line is checked</span>
<span class="gi">+        matched = depthsvgcomment_re.match(line)</span>
<span class="gi">+        if matched:</span>
<span class="gi">+            return int(matched.group(1))</span>
<span class="gi">+        return None</span>


<span class="gd">-def write_svg_depth(filename: str, depth: int) -&gt;None:</span>
<span class="gi">+def write_svg_depth(filename: str, depth: int) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Write the depth to SVG file as a comment at end of file
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open(filename, &#39;a&#39;, encoding=&quot;utf-8&quot;) as f:</span>
<span class="gi">+        f.write(&#39;\n&lt;!-- DEPTH=%s --&gt;&#39; % depth)</span>


<span class="gd">-def generate_latex_macro(image_format: str, math: str, config: Config,</span>
<span class="gd">-    confdir: (str | os.PathLike[str])=&#39;&#39;) -&gt;str:</span>
<span class="gi">+def generate_latex_macro(image_format: str,</span>
<span class="gi">+                         math: str,</span>
<span class="gi">+                         config: Config,</span>
<span class="gi">+                         confdir: str | os.PathLike[str] = &#39;&#39;) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate LaTeX macro.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    variables = {</span>
<span class="gi">+        &#39;fontsize&#39;: config.imgmath_font_size,</span>
<span class="gi">+        &#39;baselineskip&#39;: int(round(config.imgmath_font_size * 1.2)),</span>
<span class="gi">+        &#39;preamble&#39;: config.imgmath_latex_preamble,</span>
<span class="gi">+        # the dvips option is important when imgmath_latex in [&quot;xelatex&quot;, &quot;tectonic&quot;],</span>
<span class="gi">+        # it has no impact when imgmath_latex=&quot;latex&quot;</span>
<span class="gi">+        &#39;tightpage&#39;: &#39;&#39; if image_format == &#39;png&#39; else &#39;,dvips,tightpage&#39;,</span>
<span class="gi">+        &#39;math&#39;: math,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    if config.imgmath_use_preview:</span>
<span class="gi">+        template_name = &#39;preview.tex&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        template_name = &#39;template.tex&#39;</span>

<span class="gi">+    for template_dir in config.templates_path:</span>
<span class="gi">+        for template_suffix in (&#39;.jinja&#39;, &#39;_t&#39;):</span>
<span class="gi">+            template = path.join(confdir, template_dir, template_name + template_suffix)</span>
<span class="gi">+            if path.exists(template):</span>
<span class="gi">+                return LaTeXRenderer().render(template, variables)</span>

<span class="gd">-def ensure_tempdir(builder: Builder) -&gt;str:</span>
<span class="gi">+    return LaTeXRenderer(templates_path).render(template_name + &#39;.jinja&#39;, variables)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ensure_tempdir(builder: Builder) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create temporary directory.

<span class="w"> </span>    use only one tempdir per build -- the use of a directory is cleaner
<span class="w"> </span>    than using temporary files, since we can clean up everything at once
<span class="w"> </span>    just removing the whole directory (see cleanup_tempdir)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not hasattr(builder, &#39;_imgmath_tempdir&#39;):</span>
<span class="gi">+        builder._imgmath_tempdir = tempfile.mkdtemp()  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="gi">+    return builder._imgmath_tempdir  # type: ignore[attr-defined]</span>


<span class="gd">-def compile_math(latex: str, builder: Builder) -&gt;str:</span>
<span class="gi">+def compile_math(latex: str, builder: Builder) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Compile LaTeX macros for math to DVI.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    tempdir = ensure_tempdir(builder)</span>
<span class="gi">+    filename = path.join(tempdir, &#39;math.tex&#39;)</span>
<span class="gi">+    with open(filename, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:</span>
<span class="gi">+        f.write(latex)</span>
<span class="gi">+</span>
<span class="gi">+    imgmath_latex_name = path.basename(builder.config.imgmath_latex)</span>
<span class="gi">+</span>
<span class="gi">+    # build latex command; old versions of latex don&#39;t have the</span>
<span class="gi">+    # --output-directory option, so we have to manually chdir to the</span>
<span class="gi">+    # temp dir to run it.</span>
<span class="gi">+    command = [builder.config.imgmath_latex]</span>
<span class="gi">+    if imgmath_latex_name != &#39;tectonic&#39;:</span>
<span class="gi">+        command.append(&#39;--interaction=nonstopmode&#39;)</span>
<span class="gi">+    # add custom args from the config file</span>
<span class="gi">+    command.extend(builder.config.imgmath_latex_args)</span>
<span class="gi">+    command.append(&#39;math.tex&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        subprocess.run(command, capture_output=True, cwd=tempdir, check=True,</span>
<span class="gi">+                       encoding=&#39;ascii&#39;)</span>
<span class="gi">+        if imgmath_latex_name in {&#39;xelatex&#39;, &#39;tectonic&#39;}:</span>
<span class="gi">+            return path.join(tempdir, &#39;math.xdv&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return path.join(tempdir, &#39;math.dvi&#39;)</span>
<span class="gi">+    except OSError as exc:</span>
<span class="gi">+        logger.warning(__(&#39;LaTeX command %r cannot be run (needed for math &#39;</span>
<span class="gi">+                          &#39;display), check the imgmath_latex setting&#39;),</span>
<span class="gi">+                       builder.config.imgmath_latex)</span>
<span class="gi">+        raise InvokeError from exc</span>
<span class="gi">+    except CalledProcessError as exc:</span>
<span class="gi">+        msg = &#39;latex exited with error&#39;</span>
<span class="gi">+        raise MathExtError(msg, exc.stderr, exc.stdout) from exc</span>


<span class="gd">-def convert_dvi_to_image(command: list[str], name: str) -&gt;tuple[str, str]:</span>
<span class="gi">+def convert_dvi_to_image(command: list[str], name: str) -&gt; tuple[str, str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert DVI file to specific image format.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        ret = subprocess.run(command, capture_output=True, check=True, encoding=&#39;ascii&#39;)</span>
<span class="gi">+        return ret.stdout, ret.stderr</span>
<span class="gi">+    except OSError as exc:</span>
<span class="gi">+        logger.warning(__(&#39;%s command %r cannot be run (needed for math &#39;</span>
<span class="gi">+                          &#39;display), check the imgmath_%s setting&#39;),</span>
<span class="gi">+                       name, command[0], name)</span>
<span class="gi">+        raise InvokeError from exc</span>
<span class="gi">+    except CalledProcessError as exc:</span>
<span class="gi">+        raise MathExtError(&#39;%s exited with error&#39; % name, exc.stderr, exc.stdout) from exc</span>


<span class="gd">-def convert_dvi_to_png(dvipath: str, builder: Builder, out_path: str) -&gt;(int |</span>
<span class="gd">-    None):</span>
<span class="gi">+def convert_dvi_to_png(dvipath: str, builder: Builder, out_path: str) -&gt; int | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert DVI file to PNG image.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    name = &#39;dvipng&#39;</span>
<span class="gi">+    command = [builder.config.imgmath_dvipng, &#39;-o&#39;, out_path, &#39;-T&#39;, &#39;tight&#39;, &#39;-z9&#39;]</span>
<span class="gi">+    command.extend(builder.config.imgmath_dvipng_args)</span>
<span class="gi">+    if builder.config.imgmath_use_preview:</span>
<span class="gi">+        command.append(&#39;--depth&#39;)</span>
<span class="gi">+    command.append(dvipath)</span>

<span class="gi">+    stdout, stderr = convert_dvi_to_image(command, name)</span>

<span class="gd">-def convert_dvi_to_svg(dvipath: str, builder: Builder, out_path: str) -&gt;(int |</span>
<span class="gd">-    None):</span>
<span class="gi">+    depth = None</span>
<span class="gi">+    if builder.config.imgmath_use_preview:</span>
<span class="gi">+        for line in stdout.splitlines():</span>
<span class="gi">+            matched = depth_re.match(line)</span>
<span class="gi">+            if matched:</span>
<span class="gi">+                depth = int(matched.group(1))</span>
<span class="gi">+                write_png_depth(out_path, depth)</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+    return depth</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def convert_dvi_to_svg(dvipath: str, builder: Builder, out_path: str) -&gt; int | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert DVI file to SVG image.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    name = &#39;dvisvgm&#39;</span>
<span class="gi">+    command = [builder.config.imgmath_dvisvgm, &#39;-o&#39;, out_path]</span>
<span class="gi">+    command.extend(builder.config.imgmath_dvisvgm_args)</span>
<span class="gi">+    command.append(dvipath)</span>
<span class="gi">+</span>
<span class="gi">+    stdout, stderr = convert_dvi_to_image(command, name)</span>
<span class="gi">+</span>
<span class="gi">+    depth = None</span>
<span class="gi">+    if builder.config.imgmath_use_preview:</span>
<span class="gi">+        for line in stderr.splitlines():  # not stdout !</span>
<span class="gi">+            matched = depthsvg_re.match(line)</span>
<span class="gi">+            if matched:</span>
<span class="gi">+                depth = round(float(matched.group(1)) * 100 / 72.27)  # assume 100ppi</span>
<span class="gi">+                write_svg_depth(out_path, depth)</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+    return depth</span>


<span class="gd">-def render_math(self: HTML5Translator, math: str) -&gt;tuple[str | None, int |</span>
<span class="gd">-    None]:</span>
<span class="gi">+def render_math(</span>
<span class="gi">+    self: HTML5Translator,</span>
<span class="gi">+    math: str,</span>
<span class="gi">+) -&gt; tuple[str | None, int | None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Render the LaTeX math expression *math* using latex and dvipng or
<span class="w"> </span>    dvisvgm.

<span class="gu">@@ -120,4 +240,170 @@ def render_math(self: HTML5Translator, math: str) -&gt;tuple[str | None, int |</span>
<span class="w"> </span>    docs successfully).  If the programs are there, however, they may not fail
<span class="w"> </span>    since that indicates a problem in the math source.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    image_format = self.builder.config.imgmath_image_format.lower()</span>
<span class="gi">+    if image_format not in SUPPORT_FORMAT:</span>
<span class="gi">+        unsupported_format_msg = &#39;imgmath_image_format must be either &quot;png&quot; or &quot;svg&quot;&#39;</span>
<span class="gi">+        raise MathExtError(unsupported_format_msg)</span>
<span class="gi">+</span>
<span class="gi">+    latex = generate_latex_macro(image_format,</span>
<span class="gi">+                                 math,</span>
<span class="gi">+                                 self.builder.config,</span>
<span class="gi">+                                 self.builder.confdir)</span>
<span class="gi">+</span>
<span class="gi">+    filename = f&quot;{sha1(latex.encode(), usedforsecurity=False).hexdigest()}.{image_format}&quot;</span>
<span class="gi">+    generated_path = path.join(self.builder.outdir, self.builder.imagedir, &#39;math&#39;, filename)</span>
<span class="gi">+    ensuredir(path.dirname(generated_path))</span>
<span class="gi">+    if path.isfile(generated_path):</span>
<span class="gi">+        if image_format == &#39;png&#39;:</span>
<span class="gi">+            depth = read_png_depth(generated_path)</span>
<span class="gi">+        elif image_format == &#39;svg&#39;:</span>
<span class="gi">+            depth = read_svg_depth(generated_path)</span>
<span class="gi">+        return generated_path, depth</span>
<span class="gi">+</span>
<span class="gi">+    # if latex or dvipng (dvisvgm) has failed once, don&#39;t bother to try again</span>
<span class="gi">+    if hasattr(self.builder, &#39;_imgmath_warned_latex&#39;) or \</span>
<span class="gi">+       hasattr(self.builder, &#39;_imgmath_warned_image_translator&#39;):</span>
<span class="gi">+        return None, None</span>
<span class="gi">+</span>
<span class="gi">+    # .tex -&gt; .dvi</span>
<span class="gi">+    try:</span>
<span class="gi">+        dvipath = compile_math(latex, self.builder)</span>
<span class="gi">+    except InvokeError:</span>
<span class="gi">+        self.builder._imgmath_warned_latex = True  # type: ignore[attr-defined]</span>
<span class="gi">+        return None, None</span>
<span class="gi">+</span>
<span class="gi">+    # .dvi -&gt; .png/.svg</span>
<span class="gi">+    try:</span>
<span class="gi">+        if image_format == &#39;png&#39;:</span>
<span class="gi">+            depth = convert_dvi_to_png(dvipath, self.builder, generated_path)</span>
<span class="gi">+        elif image_format == &#39;svg&#39;:</span>
<span class="gi">+            depth = convert_dvi_to_svg(dvipath, self.builder, generated_path)</span>
<span class="gi">+    except InvokeError:</span>
<span class="gi">+        self.builder._imgmath_warned_image_translator = True  # type: ignore[attr-defined]</span>
<span class="gi">+        return None, None</span>
<span class="gi">+</span>
<span class="gi">+    return generated_path, depth</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def render_maths_to_base64(image_format: str, generated_path: str) -&gt; str:</span>
<span class="gi">+    with open(generated_path, &quot;rb&quot;) as f:</span>
<span class="gi">+        encoded = base64.b64encode(f.read()).decode(encoding=&#39;utf-8&#39;)</span>
<span class="gi">+    if image_format == &#39;png&#39;:</span>
<span class="gi">+        return f&#39;data:image/png;base64,{encoded}&#39;</span>
<span class="gi">+    if image_format == &#39;svg&#39;:</span>
<span class="gi">+        return f&#39;data:image/svg+xml;base64,{encoded}&#39;</span>
<span class="gi">+    unsupported_format_msg = &#39;imgmath_image_format must be either &quot;png&quot; or &quot;svg&quot;&#39;</span>
<span class="gi">+    raise MathExtError(unsupported_format_msg)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def clean_up_files(app: Sphinx, exc: Exception) -&gt; None:</span>
<span class="gi">+    if exc:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    if hasattr(app.builder, &#39;_imgmath_tempdir&#39;):</span>
<span class="gi">+        with contextlib.suppress(Exception):</span>
<span class="gi">+            shutil.rmtree(app.builder._imgmath_tempdir)</span>
<span class="gi">+</span>
<span class="gi">+    if app.builder.config.imgmath_embed:</span>
<span class="gi">+        # in embed mode, the images are still generated in the math output dir</span>
<span class="gi">+        # to be shared across workers, but are not useful to the final document</span>
<span class="gi">+        with contextlib.suppress(Exception):</span>
<span class="gi">+            shutil.rmtree(path.join(app.builder.outdir, app.builder.imagedir, &#39;math&#39;))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_tooltip(self: HTML5Translator, node: Element) -&gt; str:</span>
<span class="gi">+    if self.builder.config.imgmath_add_tooltips:</span>
<span class="gi">+        return &#39; alt=&quot;%s&quot;&#39; % self.encode(node.astext()).strip()</span>
<span class="gi">+    return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def html_visit_math(self: HTML5Translator, node: nodes.math) -&gt; None:</span>
<span class="gi">+    try:</span>
<span class="gi">+        rendered_path, depth = render_math(self, &#39;$&#39; + node.astext() + &#39;$&#39;)</span>
<span class="gi">+    except MathExtError as exc:</span>
<span class="gi">+        msg = str(exc)</span>
<span class="gi">+        sm = nodes.system_message(msg, type=&#39;WARNING&#39;, level=2,</span>
<span class="gi">+                                  backrefs=[], source=node.astext())</span>
<span class="gi">+        sm.walkabout(self)</span>
<span class="gi">+        logger.warning(__(&#39;display latex %r: %s&#39;), node.astext(), msg)</span>
<span class="gi">+        raise nodes.SkipNode from exc</span>
<span class="gi">+</span>
<span class="gi">+    if rendered_path is None:</span>
<span class="gi">+        # something failed -- use text-only as a bad substitute</span>
<span class="gi">+        self.body.append(&#39;&lt;span class=&quot;math&quot;&gt;%s&lt;/span&gt;&#39; %</span>
<span class="gi">+                         self.encode(node.astext()).strip())</span>
<span class="gi">+    else:</span>
<span class="gi">+        if self.builder.config.imgmath_embed:</span>
<span class="gi">+            image_format = self.builder.config.imgmath_image_format.lower()</span>
<span class="gi">+            img_src = render_maths_to_base64(image_format, rendered_path)</span>
<span class="gi">+        else:</span>
<span class="gi">+            bname = path.basename(rendered_path)</span>
<span class="gi">+            relative_path = path.join(self.builder.imgpath, &#39;math&#39;, bname)</span>
<span class="gi">+            img_src = relative_path.replace(path.sep, &#39;/&#39;)</span>
<span class="gi">+        c = f&#39;&lt;img class=&quot;math&quot; src=&quot;{img_src}&quot;&#39; + get_tooltip(self, node)</span>
<span class="gi">+        if depth is not None:</span>
<span class="gi">+            c += f&#39; style=&quot;vertical-align: {-depth:d}px&quot;&#39;</span>
<span class="gi">+        self.body.append(c + &#39;/&gt;&#39;)</span>
<span class="gi">+    raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def html_visit_displaymath(self: HTML5Translator, node: nodes.math_block) -&gt; None:</span>
<span class="gi">+    if node[&#39;nowrap&#39;]:</span>
<span class="gi">+        latex = node.astext()</span>
<span class="gi">+    else:</span>
<span class="gi">+        latex = wrap_displaymath(node.astext(), None, False)</span>
<span class="gi">+    try:</span>
<span class="gi">+        rendered_path, depth = render_math(self, latex)</span>
<span class="gi">+    except MathExtError as exc:</span>
<span class="gi">+        msg = str(exc)</span>
<span class="gi">+        sm = nodes.system_message(msg, type=&#39;WARNING&#39;, level=2,</span>
<span class="gi">+                                  backrefs=[], source=node.astext())</span>
<span class="gi">+        sm.walkabout(self)</span>
<span class="gi">+        logger.warning(__(&#39;inline latex %r: %s&#39;), node.astext(), msg)</span>
<span class="gi">+        raise nodes.SkipNode from exc</span>
<span class="gi">+    self.body.append(self.starttag(node, &#39;div&#39;, CLASS=&#39;math&#39;))</span>
<span class="gi">+    self.body.append(&#39;&lt;p&gt;&#39;)</span>
<span class="gi">+    if node[&#39;number&#39;]:</span>
<span class="gi">+        number = get_node_equation_number(self, node)</span>
<span class="gi">+        self.body.append(&#39;&lt;span class=&quot;eqno&quot;&gt;(%s)&#39; % number)</span>
<span class="gi">+        self.add_permalink_ref(node, _(&#39;Link to this equation&#39;))</span>
<span class="gi">+        self.body.append(&#39;&lt;/span&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if rendered_path is None:</span>
<span class="gi">+        # something failed -- use text-only as a bad substitute</span>
<span class="gi">+        self.body.append(&#39;&lt;span class=&quot;math&quot;&gt;%s&lt;/span&gt;&lt;/p&gt;\n&lt;/div&gt;&#39; %</span>
<span class="gi">+                         self.encode(node.astext()).strip())</span>
<span class="gi">+    else:</span>
<span class="gi">+        if self.builder.config.imgmath_embed:</span>
<span class="gi">+            image_format = self.builder.config.imgmath_image_format.lower()</span>
<span class="gi">+            img_src = render_maths_to_base64(image_format, rendered_path)</span>
<span class="gi">+        else:</span>
<span class="gi">+            bname = path.basename(rendered_path)</span>
<span class="gi">+            relative_path = path.join(self.builder.imgpath, &#39;math&#39;, bname)</span>
<span class="gi">+            img_src = relative_path.replace(path.sep, &#39;/&#39;)</span>
<span class="gi">+        self.body.append(f&#39;&lt;img src=&quot;{img_src}&quot;&#39; + get_tooltip(self, node) +</span>
<span class="gi">+                         &#39;/&gt;&lt;/p&gt;\n&lt;/div&gt;&#39;)</span>
<span class="gi">+    raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_html_math_renderer(&#39;imgmath&#39;,</span>
<span class="gi">+                               (html_visit_math, None),</span>
<span class="gi">+                               (html_visit_displaymath, None))</span>
<span class="gi">+</span>
<span class="gi">+    app.add_config_value(&#39;imgmath_image_format&#39;, &#39;png&#39;, &#39;html&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;imgmath_dvipng&#39;, &#39;dvipng&#39;, &#39;html&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;imgmath_dvisvgm&#39;, &#39;dvisvgm&#39;, &#39;html&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;imgmath_latex&#39;, &#39;latex&#39;, &#39;html&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;imgmath_use_preview&#39;, False, &#39;html&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;imgmath_dvipng_args&#39;,</span>
<span class="gi">+                         [&#39;-gamma&#39;, &#39;1.5&#39;, &#39;-D&#39;, &#39;110&#39;, &#39;-bg&#39;, &#39;Transparent&#39;],</span>
<span class="gi">+                         &#39;html&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;imgmath_dvisvgm_args&#39;, [&#39;--no-fonts&#39;], &#39;html&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;imgmath_latex_args&#39;, [], &#39;html&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;imgmath_latex_preamble&#39;, &#39;&#39;, &#39;html&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;imgmath_add_tooltips&#39;, True, &#39;html&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;imgmath_font_size&#39;, 12, &#39;html&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;imgmath_embed&#39;, False, &#39;html&#39;, bool)</span>
<span class="gi">+    app.connect(&#39;build-finished&#39;, clean_up_files)</span>
<span class="gi">+    return {&#39;version&#39;: sphinx.__display_version__, &#39;parallel_read_safe&#39;: True}</span>
<span class="gh">diff --git a/sphinx/ext/inheritance_diagram.py b/sphinx/ext/inheritance_diagram.py</span>
<span class="gh">index 2bd75f19c..7f8d9c9c6 100644</span>
<span class="gd">--- a/sphinx/ext/inheritance_diagram.py</span>
<span class="gi">+++ b/sphinx/ext/inheritance_diagram.py</span>
<span class="gu">@@ -1,4 +1,4 @@</span>
<span class="gd">-&quot;&quot;&quot;Defines a docutils directive for inserting inheritance diagrams.</span>
<span class="gi">+r&quot;&quot;&quot;Defines a docutils directive for inserting inheritance diagrams.</span>

<span class="w"> </span>Provide the directive with one or more classes or modules (separated
<span class="w"> </span>by whitespace).  For modules, all of the classes in that module will
<span class="gu">@@ -19,15 +19,17 @@ Example::</span>
<span class="w"> </span>   Produces a graph like the following:

<span class="w"> </span>               A
<span class="gd">-              / \\</span>
<span class="gi">+              / \</span>
<span class="w"> </span>             B   C
<span class="gd">-            / \\ /</span>
<span class="gi">+            / \ /</span>
<span class="w"> </span>           E   D

<span class="w"> </span>The graph is inserted as a PNG+image map into HTML and a PDF in
<span class="w"> </span>LaTeX.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import builtins
<span class="w"> </span>import hashlib
<span class="w"> </span>import inspect
<span class="gu">@@ -36,41 +38,95 @@ from collections.abc import Iterable, Sequence</span>
<span class="w"> </span>from importlib import import_module
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING, Any, ClassVar, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.parsers.rst import directives
<span class="gi">+</span>
<span class="w"> </span>import sphinx
<span class="w"> </span>from sphinx import addnodes
<span class="gd">-from sphinx.ext.graphviz import figure_wrapper, graphviz, render_dot_html, render_dot_latex, render_dot_texinfo</span>
<span class="gi">+from sphinx.ext.graphviz import (</span>
<span class="gi">+    figure_wrapper,</span>
<span class="gi">+    graphviz,</span>
<span class="gi">+    render_dot_html,</span>
<span class="gi">+    render_dot_latex,</span>
<span class="gi">+    render_dot_texinfo,</span>
<span class="gi">+)</span>
<span class="w"> </span>from sphinx.util.docutils import SphinxDirective
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.nodes import Node
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata, OptionSpec
<span class="w"> </span>    from sphinx.writers.html5 import HTML5Translator
<span class="w"> </span>    from sphinx.writers.latex import LaTeXTranslator
<span class="w"> </span>    from sphinx.writers.texinfo import TexinfoTranslator
<span class="gd">-module_sig_re = re.compile(</span>
<span class="gd">-    &quot;&quot;&quot;^(?:([\\w.]*)\\.)?  # module names</span>
<span class="gd">-                           (\\w+)  \\s* $          # class/final module name</span>
<span class="gd">-                           &quot;&quot;&quot;</span>
<span class="gd">-    , re.VERBOSE)</span>
<span class="gd">-py_builtins = [obj for obj in vars(builtins).values() if inspect.isclass(obj)]</span>

<span class="gi">+module_sig_re = re.compile(r&#39;&#39;&#39;^(?:([\w.]*)\.)?  # module names</span>
<span class="gi">+                           (\w+)  \s* $          # class/final module name</span>
<span class="gi">+                           &#39;&#39;&#39;, re.VERBOSE)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+py_builtins = [obj for obj in vars(builtins).values()</span>
<span class="gi">+               if inspect.isclass(obj)]</span>

<span class="gd">-def try_import(objname: str) -&gt;Any:</span>
<span class="gi">+</span>
<span class="gi">+def try_import(objname: str) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Import a object or module using *name* and *currentmodule*.
<span class="w"> </span>    *name* should be a relative name from *currentmodule* or
<span class="w"> </span>    a fully-qualified name.

<span class="w"> </span>    Returns imported object or module.  If failed, returns None value.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return import_module(objname)</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        # Relative import</span>
<span class="gi">+        return None</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        matched = module_sig_re.match(objname)</span>
<span class="gi">+</span>
<span class="gi">+        if not matched:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        modname, attrname = matched.groups()</span>

<span class="gi">+        if modname is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        try:</span>
<span class="gi">+            module = import_module(modname)</span>
<span class="gi">+            return getattr(module, attrname, None)</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            return None</span>

<span class="gd">-def import_classes(name: str, currmodule: str) -&gt;Any:</span>
<span class="gi">+</span>
<span class="gi">+def import_classes(name: str, currmodule: str) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Import a class using its fully-qualified *name*.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    target = None</span>
<span class="gi">+</span>
<span class="gi">+    # import class or module using currmodule</span>
<span class="gi">+    if currmodule:</span>
<span class="gi">+        target = try_import(currmodule + &#39;.&#39; + name)</span>
<span class="gi">+</span>
<span class="gi">+    # import class or module without currmodule</span>
<span class="gi">+    if target is None:</span>
<span class="gi">+        target = try_import(name)</span>
<span class="gi">+</span>
<span class="gi">+    if target is None:</span>
<span class="gi">+        raise InheritanceException(</span>
<span class="gi">+            &#39;Could not import class or module %r specified for &#39;</span>
<span class="gi">+            &#39;inheritance diagram&#39; % name)</span>
<span class="gi">+</span>
<span class="gi">+    if inspect.isclass(target):</span>
<span class="gi">+        # If imported object is a class, just return it</span>
<span class="gi">+        return [target]</span>
<span class="gi">+    elif inspect.ismodule(target):</span>
<span class="gi">+        # If imported object is a module, return classes defined on it</span>
<span class="gi">+        return [cls for cls in target.__dict__.values()</span>
<span class="gi">+                if inspect.isclass(cls) and cls.__module__ == target.__name__]</span>
<span class="gi">+    raise InheritanceException(&#39;%r specified for inheritance diagram is &#39;</span>
<span class="gi">+                               &#39;not a class or module&#39; % name)</span>


<span class="w"> </span>class InheritanceException(Exception):
<span class="gu">@@ -84,10 +140,10 @@ class InheritanceGraph:</span>
<span class="w"> </span>    graphviz dot graph from them.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, class_names: list[str], currmodule: str,</span>
<span class="gd">-        show_builtins: bool=False, private_bases: bool=False, parts: int=0,</span>
<span class="gd">-        aliases: (dict[str, str] | None)=None, top_classes: Sequence[Any]=()</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(self, class_names: list[str], currmodule: str, show_builtins: bool = False,</span>
<span class="gi">+                 private_bases: bool = False, parts: int = 0,</span>
<span class="gi">+                 aliases: dict[str, str] | None = None, top_classes: Sequence[Any] = (),</span>
<span class="gi">+                 ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;*class_names* is a list of child classes to show bases from.

<span class="w"> </span>        If *show_builtins* is True, then Python builtins will be shown
<span class="gu">@@ -96,19 +152,21 @@ class InheritanceGraph:</span>
<span class="w"> </span>        self.class_names = class_names
<span class="w"> </span>        classes = self._import_classes(class_names, currmodule)
<span class="w"> </span>        self.class_info = self._class_info(classes, show_builtins,
<span class="gd">-            private_bases, parts, aliases, top_classes)</span>
<span class="gi">+                                           private_bases, parts, aliases, top_classes)</span>
<span class="w"> </span>        if not self.class_info:
<span class="w"> </span>            msg = &#39;No classes found for inheritance diagram&#39;
<span class="w"> </span>            raise InheritanceException(msg)

<span class="gd">-    def _import_classes(self, class_names: list[str], currmodule: str) -&gt;list[</span>
<span class="gd">-        Any]:</span>
<span class="gi">+    def _import_classes(self, class_names: list[str], currmodule: str) -&gt; list[Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Import a list of classes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _class_info(self, classes: list[Any], show_builtins: bool,</span>
<span class="gd">-        private_bases: bool, parts: int, aliases: (dict[str, str] | None),</span>
<span class="gd">-        top_classes: Sequence[Any]) -&gt;list[tuple[str, str, list[str], str]]:</span>
<span class="gi">+        classes: list[Any] = []</span>
<span class="gi">+        for name in class_names:</span>
<span class="gi">+            classes.extend(import_classes(name, currmodule))</span>
<span class="gi">+        return classes</span>
<span class="gi">+</span>
<span class="gi">+    def _class_info(self, classes: list[Any], show_builtins: bool, private_bases: bool,</span>
<span class="gi">+                    parts: int, aliases: dict[str, str] | None, top_classes: Sequence[Any],</span>
<span class="gi">+                    ) -&gt; list[tuple[str, str, list[str], str]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return name and bases for all classes that are ancestors of
<span class="w"> </span>        *classes*.

<span class="gu">@@ -124,32 +182,105 @@ class InheritanceGraph:</span>
<span class="w"> </span>        *top_classes* gives the name(s) of the top most ancestor class to
<span class="w"> </span>        traverse to. Multiple names can be specified separated by comma.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def class_name(self, cls: Any, parts: int=0, aliases: (dict[str, str] |</span>
<span class="gd">-        None)=None) -&gt;str:</span>
<span class="gi">+        all_classes = {}</span>
<span class="gi">+</span>
<span class="gi">+        def recurse(cls: Any) -&gt; None:</span>
<span class="gi">+            if not show_builtins and cls in py_builtins:</span>
<span class="gi">+                return</span>
<span class="gi">+            if not private_bases and cls.__name__.startswith(&#39;_&#39;):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            nodename = self.class_name(cls, parts, aliases)</span>
<span class="gi">+            fullname = self.class_name(cls, 0, aliases)</span>
<span class="gi">+</span>
<span class="gi">+            # Use first line of docstring as tooltip, if available</span>
<span class="gi">+            tooltip = None</span>
<span class="gi">+            try:</span>
<span class="gi">+                if cls.__doc__:</span>
<span class="gi">+                    doc = cls.__doc__.strip().split(&quot;\n&quot;)[0]</span>
<span class="gi">+                    if doc:</span>
<span class="gi">+                        tooltip = &#39;&quot;%s&quot;&#39; % doc.replace(&#39;&quot;&#39;, &#39;\\&quot;&#39;)</span>
<span class="gi">+            except Exception:  # might raise AttributeError for strange classes</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+            baselist: list[str] = []</span>
<span class="gi">+            all_classes[cls] = (nodename, fullname, baselist, tooltip)</span>
<span class="gi">+</span>
<span class="gi">+            if fullname in top_classes:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            for base in cls.__bases__:</span>
<span class="gi">+                if not show_builtins and base in py_builtins:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if not private_bases and base.__name__.startswith(&#39;_&#39;):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                baselist.append(self.class_name(base, parts, aliases))</span>
<span class="gi">+                if base not in all_classes:</span>
<span class="gi">+                    recurse(base)</span>
<span class="gi">+</span>
<span class="gi">+        for cls in classes:</span>
<span class="gi">+            recurse(cls)</span>
<span class="gi">+</span>
<span class="gi">+        return list(all_classes.values())  # type: ignore[arg-type]</span>
<span class="gi">+</span>
<span class="gi">+    def class_name(</span>
<span class="gi">+        self, cls: Any, parts: int = 0, aliases: dict[str, str] | None = None,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Given a class object, return a fully-qualified name.

<span class="w"> </span>        This works for things I&#39;ve tested in matplotlib so far, but may not be
<span class="w"> </span>        completely general.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_all_class_names(self) -&gt;list[str]:</span>
<span class="gi">+        module = cls.__module__</span>
<span class="gi">+        if module in (&#39;__builtin__&#39;, &#39;builtins&#39;):</span>
<span class="gi">+            fullname = cls.__name__</span>
<span class="gi">+        else:</span>
<span class="gi">+            fullname = f&#39;{module}.{cls.__qualname__}&#39;</span>
<span class="gi">+        if parts == 0:</span>
<span class="gi">+            result = fullname</span>
<span class="gi">+        else:</span>
<span class="gi">+            name_parts = fullname.split(&#39;.&#39;)</span>
<span class="gi">+            result = &#39;.&#39;.join(name_parts[-parts:])</span>
<span class="gi">+        if aliases is not None and result in aliases:</span>
<span class="gi">+            return aliases[result]</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def get_all_class_names(self) -&gt; list[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get all of the class names involved in the graph.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-    default_graph_attrs = {&#39;rankdir&#39;: &#39;LR&#39;, &#39;size&#39;: &#39;&quot;8.0, 12.0&quot;&#39;,</span>
<span class="gd">-        &#39;bgcolor&#39;: &#39;transparent&#39;}</span>
<span class="gd">-    default_node_attrs = {&#39;shape&#39;: &#39;box&#39;, &#39;fontsize&#39;: 10, &#39;height&#39;: 0.25,</span>
<span class="gd">-        &#39;fontname&#39;:</span>
<span class="gd">-        &#39;&quot;Vera Sans, DejaVu Sans, Liberation Sans, Arial, Helvetica, sans&quot;&#39;,</span>
<span class="gd">-        &#39;style&#39;: &#39;&quot;setlinewidth(0.5),filled&quot;&#39;, &#39;fillcolor&#39;: &#39;white&#39;}</span>
<span class="gd">-    default_edge_attrs = {&#39;arrowsize&#39;: 0.5, &#39;style&#39;: &#39;&quot;setlinewidth(0.5)&quot;&#39;}</span>
<span class="gd">-</span>
<span class="gd">-    def generate_dot(self, name: str, urls: (dict[str, str] | None)=None,</span>
<span class="gd">-        env: (BuildEnvironment | None)=None, graph_attrs: (dict | None)=</span>
<span class="gd">-        None, node_attrs: (dict | None)=None, edge_attrs: (dict | None)=None</span>
<span class="gd">-        ) -&gt;str:</span>
<span class="gi">+        return [fullname for (_, fullname, _, _) in self.class_info]</span>
<span class="gi">+</span>
<span class="gi">+    # These are the default attrs for graphviz</span>
<span class="gi">+    default_graph_attrs = {</span>
<span class="gi">+        &#39;rankdir&#39;: &#39;LR&#39;,</span>
<span class="gi">+        &#39;size&#39;: &#39;&quot;8.0, 12.0&quot;&#39;,</span>
<span class="gi">+        &#39;bgcolor&#39;: &#39;transparent&#39;,</span>
<span class="gi">+    }</span>
<span class="gi">+    default_node_attrs = {</span>
<span class="gi">+        &#39;shape&#39;: &#39;box&#39;,</span>
<span class="gi">+        &#39;fontsize&#39;: 10,</span>
<span class="gi">+        &#39;height&#39;: 0.25,</span>
<span class="gi">+        &#39;fontname&#39;: &#39;&quot;Vera Sans, DejaVu Sans, Liberation Sans, &#39;</span>
<span class="gi">+                    &#39;Arial, Helvetica, sans&quot;&#39;,</span>
<span class="gi">+        &#39;style&#39;: &#39;&quot;setlinewidth(0.5),filled&quot;&#39;,</span>
<span class="gi">+        &#39;fillcolor&#39;: &#39;white&#39;,</span>
<span class="gi">+    }</span>
<span class="gi">+    default_edge_attrs = {</span>
<span class="gi">+        &#39;arrowsize&#39;: 0.5,</span>
<span class="gi">+        &#39;style&#39;: &#39;&quot;setlinewidth(0.5)&quot;&#39;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def _format_node_attrs(self, attrs: dict[str, Any]) -&gt; str:</span>
<span class="gi">+        return &#39;,&#39;.join(f&#39;{k}={v}&#39; for k, v in sorted(attrs.items()))</span>
<span class="gi">+</span>
<span class="gi">+    def _format_graph_attrs(self, attrs: dict[str, Any]) -&gt; str:</span>
<span class="gi">+        return &#39;&#39;.join(f&#39;{k}={v};\n&#39; for k, v in sorted(attrs.items()))</span>
<span class="gi">+</span>
<span class="gi">+    def generate_dot(self, name: str, urls: dict[str, str] | None = None,</span>
<span class="gi">+                     env: BuildEnvironment | None = None,</span>
<span class="gi">+                     graph_attrs: dict | None = None,</span>
<span class="gi">+                     node_attrs: dict | None = None,</span>
<span class="gi">+                     edge_attrs: dict | None = None,</span>
<span class="gi">+                     ) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generate a graphviz dot graph from the classes that were passed in
<span class="w"> </span>        to __init__.

<span class="gu">@@ -160,13 +291,51 @@ class InheritanceGraph:</span>
<span class="w"> </span>        *graph_attrs*, *node_attrs*, *edge_attrs* are dictionaries containing
<span class="w"> </span>        key/value pairs to pass on as graphviz properties.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if urls is None:</span>
<span class="gi">+            urls = {}</span>
<span class="gi">+        g_attrs = self.default_graph_attrs.copy()</span>
<span class="gi">+        n_attrs = self.default_node_attrs.copy()</span>
<span class="gi">+        e_attrs = self.default_edge_attrs.copy()</span>
<span class="gi">+        if graph_attrs is not None:</span>
<span class="gi">+            g_attrs.update(graph_attrs)</span>
<span class="gi">+        if node_attrs is not None:</span>
<span class="gi">+            n_attrs.update(node_attrs)</span>
<span class="gi">+        if edge_attrs is not None:</span>
<span class="gi">+            e_attrs.update(edge_attrs)</span>
<span class="gi">+        if env:</span>
<span class="gi">+            g_attrs.update(env.config.inheritance_graph_attrs)</span>
<span class="gi">+            n_attrs.update(env.config.inheritance_node_attrs)</span>
<span class="gi">+            e_attrs.update(env.config.inheritance_edge_attrs)</span>
<span class="gi">+</span>
<span class="gi">+        res: list[str] = [</span>
<span class="gi">+            f&#39;digraph {name} {{\n&#39;,</span>
<span class="gi">+            self._format_graph_attrs(g_attrs),</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        for name, fullname, bases, tooltip in sorted(self.class_info):</span>
<span class="gi">+            # Write the node</span>
<span class="gi">+            this_node_attrs = n_attrs.copy()</span>
<span class="gi">+            if fullname in urls:</span>
<span class="gi">+                this_node_attrs[&quot;URL&quot;] = &#39;&quot;%s&quot;&#39; % urls[fullname]</span>
<span class="gi">+                this_node_attrs[&quot;target&quot;] = &#39;&quot;_top&quot;&#39;</span>
<span class="gi">+            if tooltip:</span>
<span class="gi">+                this_node_attrs[&quot;tooltip&quot;] = tooltip</span>
<span class="gi">+            res.append(&#39;  &quot;%s&quot; [%s];\n&#39; % (name, self._format_node_attrs(this_node_attrs)))</span>
<span class="gi">+</span>
<span class="gi">+            # Write the edges</span>
<span class="gi">+            res.extend(</span>
<span class="gi">+                &#39;  &quot;%s&quot; -&gt; &quot;%s&quot; [%s];\n&#39; % (base_name, name, self._format_node_attrs(e_attrs))</span>
<span class="gi">+                for base_name in bases</span>
<span class="gi">+            )</span>
<span class="gi">+        res.append(&quot;}\n&quot;)</span>
<span class="gi">+        return &quot;&quot;.join(res)</span>


<span class="w"> </span>class inheritance_diagram(graphviz):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    A docutils node to use as a placeholder for the inheritance diagram.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="gu">@@ -174,35 +343,152 @@ class InheritanceDiagram(SphinxDirective):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Run when the inheritance_diagram directive is first encountered.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    has_content = False
<span class="w"> </span>    required_arguments = 1
<span class="w"> </span>    optional_arguments = 0
<span class="w"> </span>    final_argument_whitespace = True
<span class="gd">-    option_spec: ClassVar[OptionSpec] = {&#39;parts&#39;: int, &#39;private-bases&#39;:</span>
<span class="gd">-        directives.flag, &#39;caption&#39;: directives.unchanged, &#39;top-classes&#39;:</span>
<span class="gd">-        directives.unchanged_required}</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def html_visit_inheritance_diagram(self: HTML5Translator, node:</span>
<span class="gd">-    inheritance_diagram) -&gt;None:</span>
<span class="gi">+    option_spec: ClassVar[OptionSpec] = {</span>
<span class="gi">+        &#39;parts&#39;: int,</span>
<span class="gi">+        &#39;private-bases&#39;: directives.flag,</span>
<span class="gi">+        &#39;caption&#39;: directives.unchanged,</span>
<span class="gi">+        &#39;top-classes&#39;: directives.unchanged_required,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        node = inheritance_diagram()</span>
<span class="gi">+        node.document = self.state.document</span>
<span class="gi">+        class_names = self.arguments[0].split()</span>
<span class="gi">+        class_role = self.env.get_domain(&#39;py&#39;).role(&#39;class&#39;)</span>
<span class="gi">+        # Store the original content for use as a hash</span>
<span class="gi">+        node[&#39;parts&#39;] = self.options.get(&#39;parts&#39;, 0)</span>
<span class="gi">+        node[&#39;content&#39;] = &#39;, &#39;.join(class_names)</span>
<span class="gi">+        node[&#39;top-classes&#39;] = []</span>
<span class="gi">+        for cls in self.options.get(&#39;top-classes&#39;, &#39;&#39;).split(&#39;,&#39;):</span>
<span class="gi">+            cls = cls.strip()</span>
<span class="gi">+            if cls:</span>
<span class="gi">+                node[&#39;top-classes&#39;].append(cls)</span>
<span class="gi">+</span>
<span class="gi">+        # Create a graph starting with the list of classes</span>
<span class="gi">+        try:</span>
<span class="gi">+            graph = InheritanceGraph(</span>
<span class="gi">+                class_names, self.env.ref_context.get(&#39;py:module&#39;),  # type: ignore[arg-type]</span>
<span class="gi">+                parts=node[&#39;parts&#39;],</span>
<span class="gi">+                private_bases=&#39;private-bases&#39; in self.options,</span>
<span class="gi">+                aliases=self.config.inheritance_alias,</span>
<span class="gi">+                top_classes=node[&#39;top-classes&#39;])</span>
<span class="gi">+        except InheritanceException as err:</span>
<span class="gi">+            return [node.document.reporter.warning(err, line=self.lineno)]</span>
<span class="gi">+</span>
<span class="gi">+        # Create xref nodes for each target of the graph&#39;s image map and</span>
<span class="gi">+        # add them to the doc tree so that Sphinx can resolve the</span>
<span class="gi">+        # references to real URLs later.  These nodes will eventually be</span>
<span class="gi">+        # removed from the doctree after we&#39;re done with them.</span>
<span class="gi">+        for name in graph.get_all_class_names():</span>
<span class="gi">+            refnodes, x = class_role(  # type: ignore[misc]</span>
<span class="gi">+                &#39;class&#39;, &#39;:class:`%s`&#39; % name, name, 0, self.state.inliner)</span>
<span class="gi">+            node.extend(refnodes)</span>
<span class="gi">+        # Store the graph object so we can use it to generate the</span>
<span class="gi">+        # dot file later</span>
<span class="gi">+        node[&#39;graph&#39;] = graph</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;caption&#39; not in self.options:</span>
<span class="gi">+            self.add_name(node)</span>
<span class="gi">+            return [node]</span>
<span class="gi">+        else:</span>
<span class="gi">+            figure = figure_wrapper(self, node, self.options[&#39;caption&#39;])</span>
<span class="gi">+            self.add_name(figure)</span>
<span class="gi">+            return [figure]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_graph_hash(node: inheritance_diagram) -&gt; str:</span>
<span class="gi">+    encoded = (node[&#39;content&#39;] + str(node[&#39;parts&#39;])).encode()</span>
<span class="gi">+    return hashlib.md5(encoded, usedforsecurity=False).hexdigest()[-10:]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def html_visit_inheritance_diagram(self: HTML5Translator, node: inheritance_diagram) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Output the graph for HTML.  This will insert a PNG with clickable
<span class="w"> </span>    image map.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def latex_visit_inheritance_diagram(self: LaTeXTranslator, node:</span>
<span class="gd">-    inheritance_diagram) -&gt;None:</span>
<span class="gi">+    graph = node[&#39;graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    graph_hash = get_graph_hash(node)</span>
<span class="gi">+    name = &#39;inheritance%s&#39; % graph_hash</span>
<span class="gi">+</span>
<span class="gi">+    # Create a mapping from fully-qualified class names to URLs.</span>
<span class="gi">+    graphviz_output_format = self.builder.env.config.graphviz_output_format.upper()</span>
<span class="gi">+    current_filename = path.basename(self.builder.current_docname + self.builder.out_suffix)</span>
<span class="gi">+    urls = {}</span>
<span class="gi">+    pending_xrefs = cast(Iterable[addnodes.pending_xref], node)</span>
<span class="gi">+    for child in pending_xrefs:</span>
<span class="gi">+        if child.get(&#39;refuri&#39;) is not None:</span>
<span class="gi">+            # Construct the name from the URI if the reference is external via intersphinx</span>
<span class="gi">+            if not child.get(&#39;internal&#39;, True):</span>
<span class="gi">+                refname = child[&#39;refuri&#39;].rsplit(&#39;#&#39;, 1)[-1]</span>
<span class="gi">+            else:</span>
<span class="gi">+                refname = child[&#39;reftitle&#39;]</span>
<span class="gi">+</span>
<span class="gi">+            urls[refname] = child.get(&#39;refuri&#39;)</span>
<span class="gi">+        elif child.get(&#39;refid&#39;) is not None:</span>
<span class="gi">+            if graphviz_output_format == &#39;SVG&#39;:</span>
<span class="gi">+                urls[child[&#39;reftitle&#39;]] = current_filename + &#39;#&#39; + child.get(&#39;refid&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                urls[child[&#39;reftitle&#39;]] = &#39;#&#39; + child.get(&#39;refid&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    dotcode = graph.generate_dot(name, urls, env=self.builder.env)</span>
<span class="gi">+    render_dot_html(self, node, dotcode, {}, &#39;inheritance&#39;, &#39;inheritance&#39;,</span>
<span class="gi">+                    alt=&#39;Inheritance diagram of &#39; + node[&#39;content&#39;])</span>
<span class="gi">+    raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def latex_visit_inheritance_diagram(self: LaTeXTranslator, node: inheritance_diagram) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Output the graph for LaTeX.  This will insert a PDF.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    graph = node[&#39;graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    graph_hash = get_graph_hash(node)</span>
<span class="gi">+    name = &#39;inheritance%s&#39; % graph_hash</span>

<span class="gi">+    dotcode = graph.generate_dot(name, env=self.builder.env,</span>
<span class="gi">+                                 graph_attrs={&#39;size&#39;: &#39;&quot;6.0,6.0&quot;&#39;})</span>
<span class="gi">+    render_dot_latex(self, node, dotcode, {}, &#39;inheritance&#39;)</span>
<span class="gi">+    raise nodes.SkipNode</span>

<span class="gd">-def texinfo_visit_inheritance_diagram(self: TexinfoTranslator, node:</span>
<span class="gd">-    inheritance_diagram) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+def texinfo_visit_inheritance_diagram(self: TexinfoTranslator, node: inheritance_diagram,</span>
<span class="gi">+                                      ) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Output the graph for Texinfo.  This will insert a PNG.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    graph = node[&#39;graph&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    graph_hash = get_graph_hash(node)</span>
<span class="gi">+    name = &#39;inheritance%s&#39; % graph_hash</span>
<span class="gi">+</span>
<span class="gi">+    dotcode = graph.generate_dot(name, env=self.builder.env,</span>
<span class="gi">+                                 graph_attrs={&#39;size&#39;: &#39;&quot;6.0,6.0&quot;&#39;})</span>
<span class="gi">+    render_dot_texinfo(self, node, dotcode, {}, &#39;inheritance&#39;)</span>
<span class="gi">+    raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def skip(self: nodes.NodeVisitor, node: inheritance_diagram) -&gt; None:</span>
<span class="gi">+    raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.setup_extension(&#39;sphinx.ext.graphviz&#39;)</span>
<span class="gi">+    app.add_node(</span>
<span class="gi">+        inheritance_diagram,</span>
<span class="gi">+        latex=(latex_visit_inheritance_diagram, None),</span>
<span class="gi">+        html=(html_visit_inheritance_diagram, None),</span>
<span class="gi">+        text=(skip, None),</span>
<span class="gi">+        man=(skip, None),</span>
<span class="gi">+        texinfo=(texinfo_visit_inheritance_diagram, None))</span>
<span class="gi">+    app.add_directive(&#39;inheritance-diagram&#39;, InheritanceDiagram)</span>
<span class="gi">+    app.add_config_value(&#39;inheritance_graph_attrs&#39;, {}, &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;inheritance_node_attrs&#39;, {}, &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;inheritance_edge_attrs&#39;, {}, &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;inheritance_alias&#39;, {}, &#39;&#39;)</span>
<span class="gi">+    return {&#39;version&#39;: sphinx.__display_version__, &#39;parallel_read_safe&#39;: True}</span>
<span class="gh">diff --git a/sphinx/ext/intersphinx/_cli.py b/sphinx/ext/intersphinx/_cli.py</span>
<span class="gh">index 65410871f..25ec6ca7c 100644</span>
<span class="gd">--- a/sphinx/ext/intersphinx/_cli.py</span>
<span class="gi">+++ b/sphinx/ext/intersphinx/_cli.py</span>
<span class="gu">@@ -1,9 +1,45 @@</span>
<span class="w"> </span>&quot;&quot;&quot;This module provides contains the code for intersphinx command-line utilities.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="w"> </span>from sphinx.ext.intersphinx._load import _fetch_inventory


<span class="gd">-def inspect_main(argv: list[str], /) -&gt;int:</span>
<span class="gi">+def inspect_main(argv: list[str], /) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Debug functionality to print out an inventory&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(argv) &lt; 1:</span>
<span class="gi">+        print(&#39;Print out an inventory file.\n&#39;</span>
<span class="gi">+              &#39;Error: must specify local path or URL to an inventory file.&#39;,</span>
<span class="gi">+              file=sys.stderr)</span>
<span class="gi">+        return 1</span>
<span class="gi">+</span>
<span class="gi">+    class MockConfig:</span>
<span class="gi">+        intersphinx_timeout: int | None = None</span>
<span class="gi">+        tls_verify = False</span>
<span class="gi">+        tls_cacerts: str | dict[str, str] | None = None</span>
<span class="gi">+        user_agent: str = &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        filename = argv[0]</span>
<span class="gi">+        inv_data = _fetch_inventory(</span>
<span class="gi">+            target_uri=&#39;&#39;,</span>
<span class="gi">+            inv_location=filename,</span>
<span class="gi">+            config=MockConfig(),  # type: ignore[arg-type]</span>
<span class="gi">+            srcdir=&#39;&#39;  # type: ignore[arg-type]</span>
<span class="gi">+        )</span>
<span class="gi">+        for key in sorted(inv_data or {}):</span>
<span class="gi">+            print(key)</span>
<span class="gi">+            inv_entries = sorted(inv_data[key].items())</span>
<span class="gi">+            for entry, (_proj, _ver, url_path, display_name) in inv_entries:</span>
<span class="gi">+                display_name = display_name * (display_name != &#39;-&#39;)</span>
<span class="gi">+                print(f&#39;    {entry:&lt;40} {display_name:&lt;40}: {url_path}&#39;)</span>
<span class="gi">+    except ValueError as exc:</span>
<span class="gi">+        print(exc.args[0] % exc.args[1:], file=sys.stderr)</span>
<span class="gi">+        return 1</span>
<span class="gi">+    except Exception as exc:</span>
<span class="gi">+        print(f&#39;Unknown error: {exc!r}&#39;, file=sys.stderr)</span>
<span class="gi">+        return 1</span>
<span class="gi">+    else:</span>
<span class="gi">+        return 0</span>
<span class="gh">diff --git a/sphinx/ext/intersphinx/_load.py b/sphinx/ext/intersphinx/_load.py</span>
<span class="gh">index 021469d71..1973de379 100644</span>
<span class="gd">--- a/sphinx/ext/intersphinx/_load.py</span>
<span class="gi">+++ b/sphinx/ext/intersphinx/_load.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;This module contains the code for loading intersphinx inventories.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import concurrent.futures
<span class="w"> </span>import functools
<span class="w"> </span>import posixpath
<span class="gu">@@ -8,22 +10,31 @@ from operator import itemgetter</span>
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="w"> </span>from urllib.parse import urlsplit, urlunsplit
<span class="gi">+</span>
<span class="w"> </span>from sphinx.builders.html import INVENTORY_FILENAME
<span class="w"> </span>from sphinx.errors import ConfigError
<span class="w"> </span>from sphinx.ext.intersphinx._shared import LOGGER, InventoryAdapter, _IntersphinxProject
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.util import requests
<span class="w"> </span>from sphinx.util.inventory import InventoryFile
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pathlib import Path
<span class="w"> </span>    from typing import IO
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.config import Config
<span class="gd">-    from sphinx.ext.intersphinx._shared import IntersphinxMapping, InventoryCacheEntry, InventoryLocation, InventoryName, InventoryURI</span>
<span class="gi">+    from sphinx.ext.intersphinx._shared import (</span>
<span class="gi">+        IntersphinxMapping,</span>
<span class="gi">+        InventoryCacheEntry,</span>
<span class="gi">+        InventoryLocation,</span>
<span class="gi">+        InventoryName,</span>
<span class="gi">+        InventoryURI,</span>
<span class="gi">+    )</span>
<span class="w"> </span>    from sphinx.util.typing import Inventory


<span class="gd">-def validate_intersphinx_mapping(app: Sphinx, config: Config) -&gt;None:</span>
<span class="gi">+def validate_intersphinx_mapping(app: Sphinx, config: Config) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Validate and normalise :confval:`intersphinx_mapping`.

<span class="w"> </span>    Ensure that:
<span class="gu">@@ -35,29 +46,269 @@ def validate_intersphinx_mapping(app: Sphinx, config: Config) -&gt;None:</span>
<span class="w"> </span>    * The second element of each value pair (inventory locations)
<span class="w"> </span>      is a tuple of non-empty strings or None.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # URIs should NOT be duplicated, otherwise different builds may use</span>
<span class="gi">+    # different project names (and thus, the build are no more reproducible)</span>
<span class="gi">+    # depending on which one is inserted last in the cache.</span>
<span class="gi">+    seen: dict[InventoryURI, InventoryName] = {}</span>
<span class="gi">+</span>
<span class="gi">+    errors = 0</span>
<span class="gi">+    for name, value in config.intersphinx_mapping.copy().items():</span>
<span class="gi">+        # ensure that intersphinx projects are always named</span>
<span class="gi">+        if not isinstance(name, str) or not name:</span>
<span class="gi">+            errors += 1</span>
<span class="gi">+            msg = __(</span>
<span class="gi">+                &#39;Invalid intersphinx project identifier `%r` in intersphinx_mapping. &#39;</span>
<span class="gi">+                &#39;Project identifiers must be non-empty strings.&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+            LOGGER.error(msg, name)</span>
<span class="gi">+            del config.intersphinx_mapping[name]</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        # ensure values are properly formatted</span>
<span class="gi">+        if not isinstance(value, (tuple | list)):</span>
<span class="gi">+            errors += 1</span>
<span class="gi">+            msg = __(</span>
<span class="gi">+                &#39;Invalid value `%r` in intersphinx_mapping[%r]. &#39;</span>
<span class="gi">+                &#39;Expected a two-element tuple or list.&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+            LOGGER.error(msg, value, name)</span>
<span class="gi">+            del config.intersphinx_mapping[name]</span>
<span class="gi">+            continue</span>
<span class="gi">+        try:</span>
<span class="gi">+            uri, inv = value</span>
<span class="gi">+        except (TypeError, ValueError, Exception):</span>
<span class="gi">+            errors += 1</span>
<span class="gi">+            msg = __(</span>
<span class="gi">+                &#39;Invalid value `%r` in intersphinx_mapping[%r]. &#39;</span>
<span class="gi">+                &#39;Values must be a (target URI, inventory locations) pair.&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+            LOGGER.error(msg, value, name)</span>
<span class="gi">+            del config.intersphinx_mapping[name]</span>
<span class="gi">+            continue</span>

<span class="gi">+        # ensure target URIs are non-empty and unique</span>
<span class="gi">+        if not uri or not isinstance(uri, str):</span>
<span class="gi">+            errors += 1</span>
<span class="gi">+            msg = __(&#39;Invalid target URI value `%r` in intersphinx_mapping[%r][0]. &#39;</span>
<span class="gi">+                     &#39;Target URIs must be unique non-empty strings.&#39;)</span>
<span class="gi">+            LOGGER.error(msg, uri, name)</span>
<span class="gi">+            del config.intersphinx_mapping[name]</span>
<span class="gi">+            continue</span>
<span class="gi">+        if uri in seen:</span>
<span class="gi">+            errors += 1</span>
<span class="gi">+            msg = __(</span>
<span class="gi">+                &#39;Invalid target URI value `%r` in intersphinx_mapping[%r][0]. &#39;</span>
<span class="gi">+                &#39;Target URIs must be unique (other instance in intersphinx_mapping[%r]).&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+            LOGGER.error(msg, uri, name, seen[uri])</span>
<span class="gi">+            del config.intersphinx_mapping[name]</span>
<span class="gi">+            continue</span>
<span class="gi">+        seen[uri] = name</span>

<span class="gd">-def load_mappings(app: Sphinx) -&gt;None:</span>
<span class="gi">+        # ensure inventory locations are None or non-empty</span>
<span class="gi">+        targets: list[InventoryLocation] = []</span>
<span class="gi">+        for target in (inv if isinstance(inv, (tuple | list)) else (inv,)):</span>
<span class="gi">+            if target is None or target and isinstance(target, str):</span>
<span class="gi">+                targets.append(target)</span>
<span class="gi">+            else:</span>
<span class="gi">+                errors += 1</span>
<span class="gi">+                msg = __(</span>
<span class="gi">+                    &#39;Invalid inventory location value `%r` in intersphinx_mapping[%r][1]. &#39;</span>
<span class="gi">+                    &#39;Inventory locations must be non-empty strings or None.&#39;</span>
<span class="gi">+                )</span>
<span class="gi">+                LOGGER.error(msg, target, name)</span>
<span class="gi">+                del config.intersphinx_mapping[name]</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+        config.intersphinx_mapping[name] = (name, (uri, tuple(targets)))</span>
<span class="gi">+</span>
<span class="gi">+    if errors == 1:</span>
<span class="gi">+        msg = __(&#39;Invalid `intersphinx_mapping` configuration (1 error).&#39;)</span>
<span class="gi">+        raise ConfigError(msg)</span>
<span class="gi">+    if errors &gt; 1:</span>
<span class="gi">+        msg = __(&#39;Invalid `intersphinx_mapping` configuration (%s errors).&#39;)</span>
<span class="gi">+        raise ConfigError(msg % errors)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def load_mappings(app: Sphinx) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Load all intersphinx mappings into the environment.

<span class="w"> </span>    The intersphinx mappings are expected to be normalized.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    now = int(time.time())</span>
<span class="gi">+    inventories = InventoryAdapter(app.builder.env)</span>
<span class="gi">+    intersphinx_cache: dict[InventoryURI, InventoryCacheEntry] = inventories.cache</span>
<span class="gi">+    intersphinx_mapping: IntersphinxMapping = app.config.intersphinx_mapping</span>
<span class="gi">+</span>
<span class="gi">+    projects = []</span>
<span class="gi">+    for name, (uri, locations) in intersphinx_mapping.values():</span>
<span class="gi">+        try:</span>
<span class="gi">+            project = _IntersphinxProject(name=name, target_uri=uri, locations=locations)</span>
<span class="gi">+        except ValueError as err:</span>
<span class="gi">+            msg = __(&#39;An invalid intersphinx_mapping entry was added after normalisation.&#39;)</span>
<span class="gi">+            raise ConfigError(msg) from err</span>
<span class="gi">+        else:</span>
<span class="gi">+            projects.append(project)</span>
<span class="gi">+</span>
<span class="gi">+    expected_uris = {project.target_uri for project in projects}</span>
<span class="gi">+    for uri in frozenset(intersphinx_cache):</span>
<span class="gi">+        if intersphinx_cache[uri][0] not in intersphinx_mapping:</span>
<span class="gi">+            # Remove all cached entries that are no longer in `intersphinx_mapping`.</span>
<span class="gi">+            del intersphinx_cache[uri]</span>
<span class="gi">+        elif uri not in expected_uris:</span>
<span class="gi">+            # Remove cached entries with a different target URI</span>
<span class="gi">+            # than the one in `intersphinx_mapping`.</span>
<span class="gi">+            # This happens when the URI in `intersphinx_mapping` is changed.</span>
<span class="gi">+            del intersphinx_cache[uri]</span>

<span class="gi">+    with concurrent.futures.ThreadPoolExecutor() as pool:</span>
<span class="gi">+        futures = [</span>
<span class="gi">+            pool.submit(</span>
<span class="gi">+                _fetch_inventory_group,</span>
<span class="gi">+                project=project,</span>
<span class="gi">+                cache=intersphinx_cache,</span>
<span class="gi">+                now=now,</span>
<span class="gi">+                config=app.config,</span>
<span class="gi">+                srcdir=app.srcdir,</span>
<span class="gi">+            )</span>
<span class="gi">+            for project in projects</span>
<span class="gi">+        ]</span>
<span class="gi">+        updated = [f.result() for f in concurrent.futures.as_completed(futures)]</span>

<span class="gd">-def fetch_inventory(app: Sphinx, uri: InventoryURI, inv: str) -&gt;Inventory:</span>
<span class="gi">+    if any(updated):</span>
<span class="gi">+        # clear the local inventories</span>
<span class="gi">+        inventories.clear()</span>
<span class="gi">+</span>
<span class="gi">+        # Duplicate values in different inventories will shadow each</span>
<span class="gi">+        # other; which one will override which can vary between builds.</span>
<span class="gi">+        #</span>
<span class="gi">+        # In an attempt to make this more consistent,</span>
<span class="gi">+        # we sort the named inventories in the cache</span>
<span class="gi">+        # by their name and expiry time ``(NAME, EXPIRY)``.</span>
<span class="gi">+        by_name_and_time = itemgetter(0, 1)  # 0: name, 1: expiry</span>
<span class="gi">+        cache_values = sorted(intersphinx_cache.values(), key=by_name_and_time)</span>
<span class="gi">+        for name, _expiry, invdata in cache_values:</span>
<span class="gi">+            inventories.named_inventory[name] = invdata</span>
<span class="gi">+            for objtype, objects in invdata.items():</span>
<span class="gi">+                inventories.main_inventory.setdefault(objtype, {}).update(objects)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _fetch_inventory_group(</span>
<span class="gi">+    *,</span>
<span class="gi">+    project: _IntersphinxProject,</span>
<span class="gi">+    cache: dict[InventoryURI, InventoryCacheEntry],</span>
<span class="gi">+    now: int,</span>
<span class="gi">+    config: Config,</span>
<span class="gi">+    srcdir: Path,</span>
<span class="gi">+) -&gt; bool:</span>
<span class="gi">+    if config.intersphinx_cache_limit &lt; 0:</span>
<span class="gi">+        cache_time = now - config.intersphinx_cache_limit * 86400</span>
<span class="gi">+    else:</span>
<span class="gi">+        cache_time = 0</span>
<span class="gi">+</span>
<span class="gi">+    updated = False</span>
<span class="gi">+    failures = []</span>
<span class="gi">+</span>
<span class="gi">+    for location in project.locations:</span>
<span class="gi">+        # location is either None or a non-empty string</span>
<span class="gi">+        inv = f&#39;{project.target_uri}/{INVENTORY_FILENAME}&#39; if location is None else location</span>
<span class="gi">+</span>
<span class="gi">+        # decide whether the inventory must be read: always read local</span>
<span class="gi">+        # files; remote ones only if the cache time is expired</span>
<span class="gi">+        if (</span>
<span class="gi">+            &#39;://&#39; not in inv</span>
<span class="gi">+            or project.target_uri not in cache</span>
<span class="gi">+            or cache[project.target_uri][1] &lt; cache_time</span>
<span class="gi">+        ):</span>
<span class="gi">+            LOGGER.info(__(&quot;loading intersphinx inventory &#39;%s&#39; from %s ...&quot;),</span>
<span class="gi">+                        project.name, _get_safe_url(inv))</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                invdata = _fetch_inventory(</span>
<span class="gi">+                    target_uri=project.target_uri,</span>
<span class="gi">+                    inv_location=inv,</span>
<span class="gi">+                    config=config,</span>
<span class="gi">+                    srcdir=srcdir,</span>
<span class="gi">+                )</span>
<span class="gi">+            except Exception as err:</span>
<span class="gi">+                failures.append(err.args)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if invdata:</span>
<span class="gi">+                cache[project.target_uri] = project.name, now, invdata</span>
<span class="gi">+                updated = True</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+    if not failures:</span>
<span class="gi">+        pass</span>
<span class="gi">+    elif len(failures) &lt; len(project.locations):</span>
<span class="gi">+        LOGGER.info(__(&#39;encountered some issues with some of the inventories,&#39;</span>
<span class="gi">+                       &#39; but they had working alternatives:&#39;))</span>
<span class="gi">+        for fail in failures:</span>
<span class="gi">+            LOGGER.info(*fail)</span>
<span class="gi">+    else:</span>
<span class="gi">+        issues = &#39;\n&#39;.join(f[0] % f[1:] for f in failures)</span>
<span class="gi">+        LOGGER.warning(__(&#39;failed to reach any of the inventories &#39;</span>
<span class="gi">+                          &#39;with the following issues:&#39;) + &#39;\n&#39; + issues)</span>
<span class="gi">+    return updated</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def fetch_inventory(app: Sphinx, uri: InventoryURI, inv: str) -&gt; Inventory:</span>
<span class="w"> </span>    &quot;&quot;&quot;Fetch, parse and return an intersphinx inventory file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _fetch_inventory(</span>
<span class="gi">+        target_uri=uri,</span>
<span class="gi">+        inv_location=inv,</span>
<span class="gi">+        config=app.config,</span>
<span class="gi">+        srcdir=app.srcdir,</span>
<span class="gi">+    )</span>


<span class="gd">-def _fetch_inventory(*, target_uri: InventoryURI, inv_location: str, config:</span>
<span class="gd">-    Config, srcdir: Path) -&gt;Inventory:</span>
<span class="gi">+def _fetch_inventory(</span>
<span class="gi">+    *, target_uri: InventoryURI, inv_location: str, config: Config, srcdir: Path,</span>
<span class="gi">+) -&gt; Inventory:</span>
<span class="w"> </span>    &quot;&quot;&quot;Fetch, parse and return an intersphinx inventory file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # both *target_uri* (base URI of the links to generate)</span>
<span class="gi">+    # and *inv_location* (actual location of the inventory file)</span>
<span class="gi">+    # can be local or remote URIs</span>
<span class="gi">+    if &#39;://&#39; in target_uri:</span>
<span class="gi">+        # case: inv URI points to remote resource; strip any existing auth</span>
<span class="gi">+        target_uri = _strip_basic_auth(target_uri)</span>
<span class="gi">+    try:</span>
<span class="gi">+        if &#39;://&#39; in inv_location:</span>
<span class="gi">+            f = _read_from_url(inv_location, config=config)</span>
<span class="gi">+        else:</span>
<span class="gi">+            f = open(path.join(srcdir, inv_location), &#39;rb&#39;)  # NoQA: SIM115</span>
<span class="gi">+    except Exception as err:</span>
<span class="gi">+        err.args = (&#39;intersphinx inventory %r not fetchable due to %s: %s&#39;,</span>
<span class="gi">+                    inv_location, err.__class__, str(err))</span>
<span class="gi">+        raise</span>
<span class="gi">+    try:</span>
<span class="gi">+        if hasattr(f, &#39;url&#39;):</span>
<span class="gi">+            new_inv_location = f.url</span>
<span class="gi">+            if inv_location != new_inv_location:</span>
<span class="gi">+                msg = __(&#39;intersphinx inventory has moved: %s -&gt; %s&#39;)</span>
<span class="gi">+                LOGGER.info(msg, inv_location, new_inv_location)</span>
<span class="gi">+</span>
<span class="gi">+                if target_uri in {</span>
<span class="gi">+                    inv_location,</span>
<span class="gi">+                    path.dirname(inv_location),</span>
<span class="gi">+                    path.dirname(inv_location) + &#39;/&#39;</span>
<span class="gi">+                }:</span>
<span class="gi">+                    target_uri = path.dirname(new_inv_location)</span>
<span class="gi">+        with f:</span>
<span class="gi">+            try:</span>
<span class="gi">+                invdata = InventoryFile.load(f, target_uri, posixpath.join)</span>
<span class="gi">+            except ValueError as exc:</span>
<span class="gi">+                raise ValueError(&#39;unknown or unsupported inventory version: %r&#39; % exc) from exc</span>
<span class="gi">+    except Exception as err:</span>
<span class="gi">+        err.args = (&#39;intersphinx inventory %r not readable due to %s: %s&#39;,</span>
<span class="gi">+                    inv_location, err.__class__.__name__, str(err))</span>
<span class="gi">+        raise</span>
<span class="gi">+    else:</span>
<span class="gi">+        return invdata</span>


<span class="gd">-def _get_safe_url(url: str) -&gt;str:</span>
<span class="gi">+def _get_safe_url(url: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Gets version of *url* with basic auth passwords obscured. This function
<span class="w"> </span>    returns results suitable for printing and logging.

<span class="gu">@@ -69,10 +320,20 @@ def _get_safe_url(url: str) -&gt;str:</span>
<span class="w"> </span>    :return: *url* with password removed
<span class="w"> </span>    :rtype: ``str``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parts = urlsplit(url)</span>
<span class="gi">+    if parts.username is None:</span>
<span class="gi">+        return url</span>
<span class="gi">+    else:</span>
<span class="gi">+        frags = list(parts)</span>
<span class="gi">+        if parts.port:</span>
<span class="gi">+            frags[1] = f&#39;{parts.username}@{parts.hostname}:{parts.port}&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            frags[1] = f&#39;{parts.username}@{parts.hostname}&#39;</span>
<span class="gi">+</span>
<span class="gi">+        return urlunsplit(frags)</span>


<span class="gd">-def _strip_basic_auth(url: str) -&gt;str:</span>
<span class="gi">+def _strip_basic_auth(url: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns *url* with basic auth credentials removed. Also returns the
<span class="w"> </span>    basic auth username and password if they&#39;re present in *url*.

<span class="gu">@@ -86,10 +347,14 @@ def _strip_basic_auth(url: str) -&gt;str:</span>
<span class="w"> </span>    :return: *url* with any basic auth creds removed
<span class="w"> </span>    :rtype: ``str``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    frags = list(urlsplit(url))</span>
<span class="gi">+    # swap out &#39;user[:pass]@hostname&#39; for &#39;hostname&#39;</span>
<span class="gi">+    if &#39;@&#39; in frags[1]:</span>
<span class="gi">+        frags[1] = frags[1].split(&#39;@&#39;)[1]</span>
<span class="gi">+    return urlunsplit(frags)</span>


<span class="gd">-def _read_from_url(url: str, *, config: Config) -&gt;IO:</span>
<span class="gi">+def _read_from_url(url: str, *, config: Config) -&gt; IO:</span>
<span class="w"> </span>    &quot;&quot;&quot;Reads data from *url* with an HTTP *GET*.

<span class="w"> </span>    This function supports fetching from resources which use basic HTTP auth as
<span class="gu">@@ -105,4 +370,12 @@ def _read_from_url(url: str, *, config: Config) -&gt;IO:</span>
<span class="w"> </span>    :return: data read from resource described by *url*
<span class="w"> </span>    :rtype: ``file``-like object
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    r = requests.get(url, stream=True, timeout=config.intersphinx_timeout,</span>
<span class="gi">+                     _user_agent=config.user_agent,</span>
<span class="gi">+                     _tls_info=(config.tls_verify, config.tls_cacerts))</span>
<span class="gi">+    r.raise_for_status()</span>
<span class="gi">+    r.raw.url = r.url</span>
<span class="gi">+    # decode content-body based on the header.</span>
<span class="gi">+    # ref: https://github.com/psf/requests/issues/2155</span>
<span class="gi">+    r.raw.read = functools.partial(r.raw.read, decode_content=True)</span>
<span class="gi">+    return r.raw</span>
<span class="gh">diff --git a/sphinx/ext/intersphinx/_resolve.py b/sphinx/ext/intersphinx/_resolve.py</span>
<span class="gh">index 37f1281fc..35a8c12bc 100644</span>
<span class="gd">--- a/sphinx/ext/intersphinx/_resolve.py</span>
<span class="gi">+++ b/sphinx/ext/intersphinx/_resolve.py</span>
<span class="gu">@@ -1,10 +1,14 @@</span>
<span class="w"> </span>&quot;&quot;&quot;This module provides logic for resolving references to intersphinx targets.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import posixpath
<span class="w"> </span>import re
<span class="w"> </span>from typing import TYPE_CHECKING, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.utils import relative_path
<span class="gi">+</span>
<span class="w"> </span>from sphinx.addnodes import pending_xref
<span class="w"> </span>from sphinx.deprecation import _deprecation_warning
<span class="w"> </span>from sphinx.errors import ExtensionError
<span class="gu">@@ -12,12 +16,15 @@ from sphinx.ext.intersphinx._shared import LOGGER, InventoryAdapter</span>
<span class="w"> </span>from sphinx.locale import _, __
<span class="w"> </span>from sphinx.transforms.post_transforms import ReferencesResolver
<span class="w"> </span>from sphinx.util.docutils import CustomReSTDispatcher, SphinxRole
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Iterable
<span class="w"> </span>    from types import ModuleType
<span class="w"> </span>    from typing import Any
<span class="gi">+</span>
<span class="w"> </span>    from docutils.nodes import Node, TextElement, system_message
<span class="w"> </span>    from docutils.utils import Reporter
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.domains import Domain
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="gu">@@ -25,30 +32,199 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>    from sphinx.util.typing import Inventory, InventoryItem, RoleFunction


<span class="gd">-def resolve_reference_in_inventory(env: BuildEnvironment, inv_name:</span>
<span class="gd">-    InventoryName, node: pending_xref, contnode: TextElement) -&gt;(nodes.</span>
<span class="gd">-    reference | None):</span>
<span class="gi">+def _create_element_from_result(domain: Domain, inv_name: InventoryName | None,</span>
<span class="gi">+                                data: InventoryItem,</span>
<span class="gi">+                                node: pending_xref, contnode: TextElement) -&gt; nodes.reference:</span>
<span class="gi">+    proj, version, uri, dispname = data</span>
<span class="gi">+    if &#39;://&#39; not in uri and node.get(&#39;refdoc&#39;):</span>
<span class="gi">+        # get correct path in case of subdirectories</span>
<span class="gi">+        uri = posixpath.join(relative_path(node[&#39;refdoc&#39;], &#39;.&#39;), uri)</span>
<span class="gi">+    if version:</span>
<span class="gi">+        reftitle = _(&#39;(in %s v%s)&#39;) % (proj, version)</span>
<span class="gi">+    else:</span>
<span class="gi">+        reftitle = _(&#39;(in %s)&#39;) % (proj,)</span>
<span class="gi">+    newnode = nodes.reference(&#39;&#39;, &#39;&#39;, internal=False, refuri=uri, reftitle=reftitle)</span>
<span class="gi">+    if node.get(&#39;refexplicit&#39;):</span>
<span class="gi">+        # use whatever title was given</span>
<span class="gi">+        newnode.append(contnode)</span>
<span class="gi">+    elif dispname == &#39;-&#39; or (domain.name == &#39;std&#39; and node[&#39;reftype&#39;] == &#39;keyword&#39;):</span>
<span class="gi">+        # use whatever title was given, but strip prefix</span>
<span class="gi">+        title = contnode.astext()</span>
<span class="gi">+        if inv_name is not None and title.startswith(inv_name + &#39;:&#39;):</span>
<span class="gi">+            newnode.append(contnode.__class__(title[len(inv_name) + 1:],</span>
<span class="gi">+                                              title[len(inv_name) + 1:]))</span>
<span class="gi">+        else:</span>
<span class="gi">+            newnode.append(contnode)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # else use the given display name (used for :ref:)</span>
<span class="gi">+        newnode.append(contnode.__class__(dispname, dispname))</span>
<span class="gi">+    return newnode</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _resolve_reference_in_domain_by_target(</span>
<span class="gi">+        inv_name: InventoryName | None, inventory: Inventory,</span>
<span class="gi">+        domain: Domain, objtypes: Iterable[str],</span>
<span class="gi">+        target: str,</span>
<span class="gi">+        node: pending_xref, contnode: TextElement) -&gt; nodes.reference | None:</span>
<span class="gi">+    for objtype in objtypes:</span>
<span class="gi">+        if objtype not in inventory:</span>
<span class="gi">+            # Continue if there&#39;s nothing of this kind in the inventory</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if target in inventory[objtype]:</span>
<span class="gi">+            # Case sensitive match, use it</span>
<span class="gi">+            data = inventory[objtype][target]</span>
<span class="gi">+        elif objtype in {&#39;std:label&#39;, &#39;std:term&#39;}:</span>
<span class="gi">+            # Some types require case insensitive matches:</span>
<span class="gi">+            # * &#39;term&#39;: https://github.com/sphinx-doc/sphinx/issues/9291</span>
<span class="gi">+            # * &#39;label&#39;: https://github.com/sphinx-doc/sphinx/issues/12008</span>
<span class="gi">+            target_lower = target.lower()</span>
<span class="gi">+            insensitive_matches = list(filter(lambda k: k.lower() == target_lower,</span>
<span class="gi">+                                              inventory[objtype].keys()))</span>
<span class="gi">+            if len(insensitive_matches) &gt; 1:</span>
<span class="gi">+                data_items = {inventory[objtype][match] for match in insensitive_matches}</span>
<span class="gi">+                inv_descriptor = inv_name or &#39;main_inventory&#39;</span>
<span class="gi">+                if len(data_items) == 1:  # these are duplicates; relatively innocuous</span>
<span class="gi">+                    LOGGER.debug(__(&quot;inventory &#39;%s&#39;: duplicate matches found for %s:%s&quot;),</span>
<span class="gi">+                                 inv_descriptor, objtype, target,</span>
<span class="gi">+                                 type=&#39;intersphinx&#39;,  subtype=&#39;external&#39;, location=node)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    LOGGER.warning(__(&quot;inventory &#39;%s&#39;: multiple matches found for %s:%s&quot;),</span>
<span class="gi">+                                   inv_descriptor, objtype, target,</span>
<span class="gi">+                                   type=&#39;intersphinx&#39;,  subtype=&#39;external&#39;, location=node)</span>
<span class="gi">+            if insensitive_matches:</span>
<span class="gi">+                data = inventory[objtype][insensitive_matches[0]]</span>
<span class="gi">+            else:</span>
<span class="gi">+                # No case insensitive match either, continue to the next candidate</span>
<span class="gi">+                continue</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Could reach here if we&#39;re not a term but have a case insensitive match.</span>
<span class="gi">+            # This is a fix for terms specifically, but potentially should apply to</span>
<span class="gi">+            # other types.</span>
<span class="gi">+            continue</span>
<span class="gi">+        return _create_element_from_result(domain, inv_name, data, node, contnode)</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _resolve_reference_in_domain(env: BuildEnvironment,</span>
<span class="gi">+                                 inv_name: InventoryName | None, inventory: Inventory,</span>
<span class="gi">+                                 honor_disabled_refs: bool,</span>
<span class="gi">+                                 domain: Domain, objtypes: Iterable[str],</span>
<span class="gi">+                                 node: pending_xref, contnode: TextElement,</span>
<span class="gi">+                                 ) -&gt; nodes.reference | None:</span>
<span class="gi">+    obj_types: dict[str, None] = {}.fromkeys(objtypes)</span>
<span class="gi">+</span>
<span class="gi">+    # we adjust the object types for backwards compatibility</span>
<span class="gi">+    if domain.name == &#39;std&#39; and &#39;cmdoption&#39; in obj_types:</span>
<span class="gi">+        # cmdoptions were stored as std:option until Sphinx 1.6</span>
<span class="gi">+        obj_types[&#39;option&#39;] = None</span>
<span class="gi">+    if domain.name == &#39;py&#39; and &#39;attribute&#39; in obj_types:</span>
<span class="gi">+        # properties are stored as py:method since Sphinx 2.1</span>
<span class="gi">+        obj_types[&#39;method&#39;] = None</span>
<span class="gi">+</span>
<span class="gi">+    # the inventory contains domain:type as objtype</span>
<span class="gi">+    domain_name = domain.name</span>
<span class="gi">+    obj_types = {f&#39;{domain_name}:{obj_type}&#39;: None for obj_type in obj_types}</span>
<span class="gi">+</span>
<span class="gi">+    # now that the objtypes list is complete we can remove the disabled ones</span>
<span class="gi">+    if honor_disabled_refs:</span>
<span class="gi">+        disabled = set(env.config.intersphinx_disabled_reftypes)</span>
<span class="gi">+        obj_types = {obj_type: None</span>
<span class="gi">+                     for obj_type in obj_types</span>
<span class="gi">+                     if obj_type not in disabled}</span>
<span class="gi">+</span>
<span class="gi">+    objtypes = [*obj_types.keys()]</span>
<span class="gi">+</span>
<span class="gi">+    # without qualification</span>
<span class="gi">+    res = _resolve_reference_in_domain_by_target(inv_name, inventory, domain, objtypes,</span>
<span class="gi">+                                                 node[&#39;reftarget&#39;], node, contnode)</span>
<span class="gi">+    if res is not None:</span>
<span class="gi">+        return res</span>
<span class="gi">+</span>
<span class="gi">+    # try with qualification of the current scope instead</span>
<span class="gi">+    full_qualified_name = domain.get_full_qualified_name(node)</span>
<span class="gi">+    if full_qualified_name is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    return _resolve_reference_in_domain_by_target(inv_name, inventory, domain, objtypes,</span>
<span class="gi">+                                                  full_qualified_name, node, contnode)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _resolve_reference(env: BuildEnvironment,</span>
<span class="gi">+                       inv_name: InventoryName | None, inventory: Inventory,</span>
<span class="gi">+                       honor_disabled_refs: bool,</span>
<span class="gi">+                       node: pending_xref, contnode: TextElement) -&gt; nodes.reference | None:</span>
<span class="gi">+    # disabling should only be done if no inventory is given</span>
<span class="gi">+    honor_disabled_refs = honor_disabled_refs and inv_name is None</span>
<span class="gi">+    intersphinx_disabled_reftypes = env.config.intersphinx_disabled_reftypes</span>
<span class="gi">+</span>
<span class="gi">+    if honor_disabled_refs and &#39;*&#39; in intersphinx_disabled_reftypes:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    typ = node[&#39;reftype&#39;]</span>
<span class="gi">+    if typ == &#39;any&#39;:</span>
<span class="gi">+        for domain_name, domain in env.domains.items():</span>
<span class="gi">+            if honor_disabled_refs and f&#39;{domain_name}:*&#39; in intersphinx_disabled_reftypes:</span>
<span class="gi">+                continue</span>
<span class="gi">+            objtypes: Iterable[str] = domain.object_types.keys()</span>
<span class="gi">+            res = _resolve_reference_in_domain(env, inv_name, inventory,</span>
<span class="gi">+                                               honor_disabled_refs,</span>
<span class="gi">+                                               domain, objtypes,</span>
<span class="gi">+                                               node, contnode)</span>
<span class="gi">+            if res is not None:</span>
<span class="gi">+                return res</span>
<span class="gi">+        return None</span>
<span class="gi">+    else:</span>
<span class="gi">+        domain_name = node.get(&#39;refdomain&#39;)</span>
<span class="gi">+        if not domain_name:</span>
<span class="gi">+            # only objects in domains are in the inventory</span>
<span class="gi">+            return None</span>
<span class="gi">+        if honor_disabled_refs and f&#39;{domain_name}:*&#39; in intersphinx_disabled_reftypes:</span>
<span class="gi">+            return None</span>
<span class="gi">+        domain = env.get_domain(domain_name)</span>
<span class="gi">+        objtypes = domain.objtypes_for_role(typ) or ()</span>
<span class="gi">+        if not objtypes:</span>
<span class="gi">+            return None</span>
<span class="gi">+        return _resolve_reference_in_domain(env, inv_name, inventory,</span>
<span class="gi">+                                            honor_disabled_refs,</span>
<span class="gi">+                                            domain, objtypes,</span>
<span class="gi">+                                            node, contnode)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def inventory_exists(env: BuildEnvironment, inv_name: InventoryName) -&gt; bool:</span>
<span class="gi">+    return inv_name in InventoryAdapter(env).named_inventory</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def resolve_reference_in_inventory(env: BuildEnvironment,</span>
<span class="gi">+                                   inv_name: InventoryName,</span>
<span class="gi">+                                   node: pending_xref, contnode: TextElement,</span>
<span class="gi">+                                   ) -&gt; nodes.reference | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Attempt to resolve a missing reference via intersphinx references.

<span class="w"> </span>    Resolution is tried in the given inventory with the target as is.

<span class="w"> </span>    Requires ``inventory_exists(env, inv_name)``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert inventory_exists(env, inv_name)</span>
<span class="gi">+    return _resolve_reference(env, inv_name, InventoryAdapter(env).named_inventory[inv_name],</span>
<span class="gi">+                              False, node, contnode)</span>


<span class="w"> </span>def resolve_reference_any_inventory(env: BuildEnvironment,
<span class="gd">-    honor_disabled_refs: bool, node: pending_xref, contnode: TextElement) -&gt;(</span>
<span class="gd">-    nodes.reference | None):</span>
<span class="gi">+                                    honor_disabled_refs: bool,</span>
<span class="gi">+                                    node: pending_xref, contnode: TextElement,</span>
<span class="gi">+                                    ) -&gt; nodes.reference | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Attempt to resolve a missing reference via intersphinx references.

<span class="w"> </span>    Resolution is tried with the target as is in any inventory.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _resolve_reference(env, None, InventoryAdapter(env).main_inventory,</span>
<span class="gi">+                              honor_disabled_refs,</span>
<span class="gi">+                              node, contnode)</span>


<span class="gd">-def resolve_reference_detect_inventory(env: BuildEnvironment, node:</span>
<span class="gd">-    pending_xref, contnode: TextElement) -&gt;(nodes.reference | None):</span>
<span class="gi">+def resolve_reference_detect_inventory(env: BuildEnvironment,</span>
<span class="gi">+                                       node: pending_xref, contnode: TextElement,</span>
<span class="gi">+                                       ) -&gt; nodes.reference | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Attempt to resolve a missing reference via intersphinx references.

<span class="w"> </span>    Resolution is tried first with the target as is in any inventory.
<span class="gu">@@ -56,13 +232,28 @@ def resolve_reference_detect_inventory(env: BuildEnvironment, node:</span>
<span class="w"> </span>    to form ``inv_name:newtarget``. If ``inv_name`` is a named inventory, then resolution
<span class="w"> </span>    is tried in that inventory with the new target.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # ordinary direct lookup, use data as is</span>
<span class="gi">+    res = resolve_reference_any_inventory(env, True, node, contnode)</span>
<span class="gi">+    if res is not None:</span>
<span class="gi">+        return res</span>
<span class="gi">+</span>
<span class="gi">+    # try splitting the target into &#39;inv_name:target&#39;</span>
<span class="gi">+    target = node[&#39;reftarget&#39;]</span>
<span class="gi">+    if &#39;:&#39; not in target:</span>
<span class="gi">+        return None</span>
<span class="gi">+    inv_name, newtarget = target.split(&#39;:&#39;, 1)</span>
<span class="gi">+    if not inventory_exists(env, inv_name):</span>
<span class="gi">+        return None</span>
<span class="gi">+    node[&#39;reftarget&#39;] = newtarget</span>
<span class="gi">+    res_inv = resolve_reference_in_inventory(env, inv_name, node, contnode)</span>
<span class="gi">+    node[&#39;reftarget&#39;] = target</span>
<span class="gi">+    return res_inv</span>


<span class="gd">-def missing_reference(app: Sphinx, env: BuildEnvironment, node:</span>
<span class="gd">-    pending_xref, contnode: TextElement) -&gt;(nodes.reference | None):</span>
<span class="gi">+def missing_reference(app: Sphinx, env: BuildEnvironment, node: pending_xref,</span>
<span class="gi">+                      contnode: TextElement) -&gt; nodes.reference | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Attempt to resolve a missing reference via intersphinx references.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return resolve_reference_detect_inventory(env, node, contnode)</span>


<span class="w"> </span>class IntersphinxDispatcher(CustomReSTDispatcher):
<span class="gu">@@ -71,15 +262,120 @@ class IntersphinxDispatcher(CustomReSTDispatcher):</span>
<span class="w"> </span>    This enables :external:***:/:external+***: roles on parsing reST document.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def role(</span>
<span class="gi">+        self, role_name: str, language_module: ModuleType, lineno: int, reporter: Reporter,</span>
<span class="gi">+    ) -&gt; tuple[RoleFunction, list[system_message]]:</span>
<span class="gi">+        if len(role_name) &gt; 9 and role_name.startswith((&#39;external:&#39;, &#39;external+&#39;)):</span>
<span class="gi">+            return IntersphinxRole(role_name), []</span>
<span class="gi">+        else:</span>
<span class="gi">+            return super().role(role_name, language_module, lineno, reporter)</span>
<span class="gi">+</span>

<span class="w"> </span>class IntersphinxRole(SphinxRole):
<span class="gd">-    _re_inv_ref = re.compile(&#39;(\\+([^:]+))?:(.*)&#39;)</span>
<span class="gi">+    # group 1: just for the optionality of the inventory name</span>
<span class="gi">+    # group 2: the inventory name (optional)</span>
<span class="gi">+    # group 3: the domain:role or role part</span>
<span class="gi">+    _re_inv_ref = re.compile(r&#39;(\+([^:]+))?:(.*)&#39;)</span>

<span class="gd">-    def __init__(self, orig_name: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, orig_name: str) -&gt; None:</span>
<span class="w"> </span>        self.orig_name = orig_name

<span class="gd">-    def get_inventory_and_name_suffix(self, name: str) -&gt;tuple[str | None, str</span>
<span class="gd">-        ]:</span>
<span class="gi">+    def run(self) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+        assert self.name == self.orig_name.lower()</span>
<span class="gi">+        inventory, name_suffix = self.get_inventory_and_name_suffix(self.orig_name)</span>
<span class="gi">+        if inventory and not inventory_exists(self.env, inventory):</span>
<span class="gi">+            self._emit_warning(</span>
<span class="gi">+                __(&#39;inventory for external cross-reference not found: %r&#39;), inventory</span>
<span class="gi">+            )</span>
<span class="gi">+            return [], []</span>
<span class="gi">+</span>
<span class="gi">+        domain_name, role_name = self._get_domain_role(name_suffix)</span>
<span class="gi">+</span>
<span class="gi">+        if role_name is None:</span>
<span class="gi">+            self._emit_warning(</span>
<span class="gi">+                __(&#39;invalid external cross-reference suffix: %r&#39;), name_suffix</span>
<span class="gi">+            )</span>
<span class="gi">+            return [], []</span>
<span class="gi">+</span>
<span class="gi">+        # attempt to find a matching role function</span>
<span class="gi">+        role_func: RoleFunction | None</span>
<span class="gi">+</span>
<span class="gi">+        if domain_name is not None:</span>
<span class="gi">+            # the user specified a domain, so we only check that</span>
<span class="gi">+            if (domain := self.env.domains.get(domain_name)) is None:</span>
<span class="gi">+                self._emit_warning(</span>
<span class="gi">+                    __(&#39;domain for external cross-reference not found: %r&#39;), domain_name</span>
<span class="gi">+                )</span>
<span class="gi">+                return [], []</span>
<span class="gi">+            if (role_func := domain.roles.get(role_name)) is None:</span>
<span class="gi">+                msg = &#39;role for external cross-reference not found in domain %r: %r&#39;</span>
<span class="gi">+                if (</span>
<span class="gi">+                    object_types := domain.object_types.get(role_name)</span>
<span class="gi">+                ) is not None and object_types.roles:</span>
<span class="gi">+                    self._emit_warning(</span>
<span class="gi">+                        __(f&#39;{msg} (perhaps you meant one of: %s)&#39;),</span>
<span class="gi">+                        domain_name,</span>
<span class="gi">+                        role_name,</span>
<span class="gi">+                        self._concat_strings(object_types.roles),</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self._emit_warning(__(msg), domain_name, role_name)</span>
<span class="gi">+                return [], []</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            # the user did not specify a domain,</span>
<span class="gi">+            # so we check first the default (if available) then standard domains</span>
<span class="gi">+            domains: list[Domain] = []</span>
<span class="gi">+            if default_domain := self.env.temp_data.get(&#39;default_domain&#39;):</span>
<span class="gi">+                domains.append(default_domain)</span>
<span class="gi">+            if (</span>
<span class="gi">+                std_domain := self.env.domains.get(&#39;std&#39;)</span>
<span class="gi">+            ) is not None and std_domain not in domains:</span>
<span class="gi">+                domains.append(std_domain)</span>
<span class="gi">+</span>
<span class="gi">+            role_func = None</span>
<span class="gi">+            for domain in domains:</span>
<span class="gi">+                if (role_func := domain.roles.get(role_name)) is not None:</span>
<span class="gi">+                    domain_name = domain.name</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+            if role_func is None or domain_name is None:</span>
<span class="gi">+                domains_str = self._concat_strings(d.name for d in domains)</span>
<span class="gi">+                msg = &#39;role for external cross-reference not found in domains %s: %r&#39;</span>
<span class="gi">+                possible_roles: set[str] = set()</span>
<span class="gi">+                for d in domains:</span>
<span class="gi">+                    if o := d.object_types.get(role_name):</span>
<span class="gi">+                        possible_roles.update(f&#39;{d.name}:{r}&#39; for r in o.roles)</span>
<span class="gi">+                if possible_roles:</span>
<span class="gi">+                    msg = f&#39;{msg} (perhaps you meant one of: %s)&#39;</span>
<span class="gi">+                    self._emit_warning(</span>
<span class="gi">+                        __(msg),</span>
<span class="gi">+                        domains_str,</span>
<span class="gi">+                        role_name,</span>
<span class="gi">+                        self._concat_strings(possible_roles),</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self._emit_warning(__(msg), domains_str, role_name)</span>
<span class="gi">+                return [], []</span>
<span class="gi">+</span>
<span class="gi">+        result, messages = role_func(</span>
<span class="gi">+            f&#39;{domain_name}:{role_name}&#39;,</span>
<span class="gi">+            self.rawtext,</span>
<span class="gi">+            self.text,</span>
<span class="gi">+            self.lineno,</span>
<span class="gi">+            self.inliner,</span>
<span class="gi">+            self.options,</span>
<span class="gi">+            self.content,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        for node in result:</span>
<span class="gi">+            if isinstance(node, pending_xref):</span>
<span class="gi">+                node[&#39;intersphinx&#39;] = True</span>
<span class="gi">+                node[&#39;inventory&#39;] = inventory</span>
<span class="gi">+</span>
<span class="gi">+        return result, messages</span>
<span class="gi">+</span>
<span class="gi">+    def get_inventory_and_name_suffix(self, name: str) -&gt; tuple[str | None, str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Extract an inventory name (if any) and ``domain+name`` suffix from a role *name*.
<span class="w"> </span>        and the domain+name suffix.

<span class="gu">@@ -90,21 +386,94 @@ class IntersphinxRole(SphinxRole):</span>
<span class="w"> </span>        - ``external:name`` -- any inventory and domain, explicit name.
<span class="w"> </span>        - ``external:domain:name`` -- any inventory, explicit domain and name.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        assert name.startswith(&#39;external&#39;), name</span>
<span class="gi">+        suffix = name[9:]</span>
<span class="gi">+        if name[8] == &#39;+&#39;:</span>
<span class="gi">+            inv_name, suffix = suffix.split(&#39;:&#39;, 1)</span>
<span class="gi">+            return inv_name, suffix</span>
<span class="gi">+        elif name[8] == &#39;:&#39;:</span>
<span class="gi">+            return None, suffix</span>
<span class="gi">+        else:</span>
<span class="gi">+            msg = f&#39;Malformed :external: role name: {name}&#39;</span>
<span class="gi">+            raise ValueError(msg)</span>

<span class="gd">-    def _get_domain_role(self, name: str) -&gt;tuple[str | None, str | None]:</span>
<span class="gi">+    def _get_domain_role(self, name: str) -&gt; tuple[str | None, str | None]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert the *name* string into a domain and a role name.

<span class="w"> </span>        - If *name* contains no ``:``, return ``(None, name)``.
<span class="w"> </span>        - If *name* contains a single ``:``, the domain/role is split on this.
<span class="w"> </span>        - If *name* contains multiple ``:``, return ``(None, None)``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        names = name.split(&#39;:&#39;)</span>
<span class="gi">+        if len(names) == 1:</span>
<span class="gi">+            return None, names[0]</span>
<span class="gi">+        elif len(names) == 2:</span>
<span class="gi">+            return names[0], names[1]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None, None</span>
<span class="gi">+</span>
<span class="gi">+    def _emit_warning(self, msg: str, /, *args: Any) -&gt; None:</span>
<span class="gi">+        LOGGER.warning(</span>
<span class="gi">+            msg,</span>
<span class="gi">+            *args,</span>
<span class="gi">+            type=&#39;intersphinx&#39;,</span>
<span class="gi">+            subtype=&#39;external&#39;,</span>
<span class="gi">+            location=(self.env.docname, self.lineno),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _concat_strings(self, strings: Iterable[str]) -&gt; str:</span>
<span class="gi">+        return &#39;, &#39;.join(f&#39;{s!r}&#39; for s in sorted(strings))</span>
<span class="gi">+</span>
<span class="gi">+    # deprecated methods</span>

<span class="gd">-    def invoke_role(self, role: tuple[str, str]) -&gt;tuple[list[Node], list[</span>
<span class="gd">-        system_message]]:</span>
<span class="gi">+    def get_role_name(self, name: str) -&gt; tuple[str, str] | None:</span>
<span class="gi">+        _deprecation_warning(</span>
<span class="gi">+            __name__, f&#39;{self.__class__.__name__}.get_role_name&#39;, &#39;&#39;, remove=(9, 0)</span>
<span class="gi">+        )</span>
<span class="gi">+        names = name.split(&#39;:&#39;)</span>
<span class="gi">+        if len(names) == 1:</span>
<span class="gi">+            # role</span>
<span class="gi">+            default_domain = self.env.temp_data.get(&#39;default_domain&#39;)</span>
<span class="gi">+            domain = default_domain.name if default_domain else None</span>
<span class="gi">+            role = names[0]</span>
<span class="gi">+        elif len(names) == 2:</span>
<span class="gi">+            # domain:role:</span>
<span class="gi">+            domain = names[0]</span>
<span class="gi">+            role = names[1]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        if domain and self.is_existent_role(domain, role):</span>
<span class="gi">+            return (domain, role)</span>
<span class="gi">+        elif self.is_existent_role(&#39;std&#39;, role):</span>
<span class="gi">+            return (&#39;std&#39;, role)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    def is_existent_role(self, domain_name: str, role_name: str) -&gt; bool:</span>
<span class="gi">+        _deprecation_warning(</span>
<span class="gi">+            __name__, f&#39;{self.__class__.__name__}.is_existent_role&#39;, &#39;&#39;, remove=(9, 0)</span>
<span class="gi">+        )</span>
<span class="gi">+        try:</span>
<span class="gi">+            domain = self.env.get_domain(domain_name)</span>
<span class="gi">+            return role_name in domain.roles</span>
<span class="gi">+        except ExtensionError:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    def invoke_role(self, role: tuple[str, str]) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Invoke the role described by a ``(domain, role name)`` pair.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        _deprecation_warning(</span>
<span class="gi">+            __name__, f&#39;{self.__class__.__name__}.invoke_role&#39;, &#39;&#39;, remove=(9, 0)</span>
<span class="gi">+        )</span>
<span class="gi">+        domain = self.env.get_domain(role[0])</span>
<span class="gi">+        if domain:</span>
<span class="gi">+            role_func = domain.role(role[1])</span>
<span class="gi">+            assert role_func is not None</span>
<span class="gi">+</span>
<span class="gi">+            return role_func(&#39;:&#39;.join(role), self.rawtext, self.text, self.lineno,</span>
<span class="gi">+                             self.inliner, self.options, self.content)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return [], []</span>


<span class="w"> </span>class IntersphinxRoleResolver(ReferencesResolver):
<span class="gu">@@ -112,13 +481,35 @@ class IntersphinxRoleResolver(ReferencesResolver):</span>

<span class="w"> </span>    This resolves pending_xref nodes generated by :intersphinx:***: role.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    default_priority = ReferencesResolver.default_priority - 1

<span class="gi">+    def run(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        for node in self.document.findall(pending_xref):</span>
<span class="gi">+            if &#39;intersphinx&#39; not in node:</span>
<span class="gi">+                continue</span>
<span class="gi">+            contnode = cast(nodes.TextElement, node[0].deepcopy())</span>
<span class="gi">+            inv_name = node[&#39;inventory&#39;]</span>
<span class="gi">+            if inv_name is not None:</span>
<span class="gi">+                assert inventory_exists(self.env, inv_name)</span>
<span class="gi">+                newnode = resolve_reference_in_inventory(self.env, inv_name, node, contnode)</span>
<span class="gi">+            else:</span>
<span class="gi">+                newnode = resolve_reference_any_inventory(self.env, False, node, contnode)</span>
<span class="gi">+            if newnode is None:</span>
<span class="gi">+                typ = node[&#39;reftype&#39;]</span>
<span class="gi">+                msg = (__(&#39;external %s:%s reference target not found: %s&#39;) %</span>
<span class="gi">+                       (node[&#39;refdomain&#39;], typ, node[&#39;reftarget&#39;]))</span>
<span class="gi">+                LOGGER.warning(msg, location=node, type=&#39;ref&#39;, subtype=typ)</span>
<span class="gi">+                node.replace_self(contnode)</span>
<span class="gi">+            else:</span>
<span class="gi">+                node.replace_self(newnode)</span>
<span class="gi">+</span>

<span class="gd">-def install_dispatcher(app: Sphinx, docname: str, source: list[str]) -&gt;None:</span>
<span class="gi">+def install_dispatcher(app: Sphinx, docname: str, source: list[str]) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Enable IntersphinxDispatcher.

<span class="w"> </span>    .. note:: The installed dispatcher will be uninstalled on disabling sphinx_domain
<span class="w"> </span>              automatically.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    dispatcher = IntersphinxDispatcher()</span>
<span class="gi">+    dispatcher.enable()</span>
<span class="gh">diff --git a/sphinx/ext/intersphinx/_shared.py b/sphinx/ext/intersphinx/_shared.py</span>
<span class="gh">index 56a5986a5..36c73786f 100644</span>
<span class="gd">--- a/sphinx/ext/intersphinx/_shared.py</span>
<span class="gi">+++ b/sphinx/ext/intersphinx/_shared.py</span>
<span class="gu">@@ -1,36 +1,68 @@</span>
<span class="w"> </span>&quot;&quot;&quot;This module contains code shared between intersphinx modules.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Final, NoReturn
<span class="gi">+</span>
<span class="w"> </span>from sphinx.util import logging
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Sequence
<span class="w"> </span>    from typing import TypeAlias
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="w"> </span>    from sphinx.util.typing import Inventory
<span class="gi">+</span>
<span class="gi">+    #: The inventory project URL to which links are resolved.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: This value is unique in :confval:`intersphinx_mapping`.</span>
<span class="w"> </span>    InventoryURI = str
<span class="gi">+</span>
<span class="gi">+    #: The inventory (non-empty) name.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: It is unique and in bijection with an inventory remote URL.</span>
<span class="w"> </span>    InventoryName = str
<span class="gi">+</span>
<span class="gi">+    #: A target (local or remote) containing the inventory data to fetch.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: Empty strings are not expected and ``None`` indicates the default</span>
<span class="gi">+    #: inventory file name :data:`~sphinx.builder.html.INVENTORY_FILENAME`.</span>
<span class="w"> </span>    InventoryLocation = str | None
<span class="gi">+</span>
<span class="gi">+    #: Inventory cache entry. The integer field is the cache expiration time.</span>
<span class="w"> </span>    InventoryCacheEntry: TypeAlias = tuple[InventoryName, int, Inventory]
<span class="gd">-    IntersphinxMapping = dict[InventoryName, tuple[InventoryName, tuple[</span>
<span class="gd">-        InventoryURI, tuple[InventoryLocation, ...]]]]</span>
<span class="gd">-LOGGER: Final[logging.SphinxLoggerAdapter] = logging.getLogger(</span>
<span class="gd">-    &#39;sphinx.ext.intersphinx&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    #: The type of :confval:`intersphinx_mapping` *after* normalisation.</span>
<span class="gi">+    IntersphinxMapping = dict[</span>
<span class="gi">+        InventoryName,</span>
<span class="gi">+        tuple[InventoryName, tuple[InventoryURI, tuple[InventoryLocation, ...]]],</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+LOGGER: Final[logging.SphinxLoggerAdapter] = logging.getLogger(&#39;sphinx.ext.intersphinx&#39;)</span>


<span class="w"> </span>class _IntersphinxProject:
<span class="w"> </span>    name: InventoryName
<span class="w"> </span>    target_uri: InventoryURI
<span class="w"> </span>    locations: tuple[InventoryLocation, ...]
<span class="gd">-    __slots__ = {&#39;name&#39;:</span>
<span class="gd">-        &#39;The inventory name. It is unique and in bijection with an remote inventory URL.&#39;</span>
<span class="gd">-        , &#39;target_uri&#39;:</span>
<span class="gd">-        &#39;The inventory project URL to which links are resolved. It is unique and in bijection with an inventory name.&#39;</span>
<span class="gd">-        , &#39;locations&#39;:</span>
<span class="gd">-        &#39;A tuple of local or remote targets containing the inventory data to fetch. None indicates the default inventory file name.&#39;</span>
<span class="gd">-        }</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, *, name: InventoryName, target_uri: InventoryURI,</span>
<span class="gd">-        locations: Sequence[InventoryLocation]) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = {</span>
<span class="gi">+        &#39;name&#39;:       &#39;The inventory name. &#39;</span>
<span class="gi">+                      &#39;It is unique and in bijection with an remote inventory URL.&#39;,</span>
<span class="gi">+        &#39;target_uri&#39;: &#39;The inventory project URL to which links are resolved. &#39;</span>
<span class="gi">+                      &#39;It is unique and in bijection with an inventory name.&#39;,</span>
<span class="gi">+        &#39;locations&#39;:  &#39;A tuple of local or remote targets containing &#39;</span>
<span class="gi">+                      &#39;the inventory data to fetch. &#39;</span>
<span class="gi">+                      &#39;None indicates the default inventory file name.&#39;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        name: InventoryName,</span>
<span class="gi">+        target_uri: InventoryURI,</span>
<span class="gi">+        locations: Sequence[InventoryLocation],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        if not name or not isinstance(name, str):
<span class="w"> </span>            msg = &#39;name must be a non-empty string&#39;
<span class="w"> </span>            raise ValueError(msg)
<span class="gu">@@ -40,33 +72,39 @@ class _IntersphinxProject:</span>
<span class="w"> </span>        if not locations or not isinstance(locations, tuple):
<span class="w"> </span>            msg = &#39;locations must be a non-empty tuple&#39;
<span class="w"> </span>            raise ValueError(msg)
<span class="gd">-        if any(location is not None and (not location or not isinstance(</span>
<span class="gd">-            location, str)) for location in locations):</span>
<span class="gi">+        if any(</span>
<span class="gi">+            location is not None and (not location or not isinstance(location, str))</span>
<span class="gi">+            for location in locations</span>
<span class="gi">+        ):</span>
<span class="w"> </span>            msg = &#39;locations must be a tuple of strings or None&#39;
<span class="w"> </span>            raise ValueError(msg)
<span class="w"> </span>        object.__setattr__(self, &#39;name&#39;, name)
<span class="w"> </span>        object.__setattr__(self, &#39;target_uri&#39;, target_uri)
<span class="w"> </span>        object.__setattr__(self, &#39;locations&#39;, tuple(locations))

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;{self.__class__.__name__}(name={self.name!r}, target_uri={self.target_uri!r}, locations={self.locations!r})&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return (f&#39;{self.__class__.__name__}(&#39;</span>
<span class="gi">+                f&#39;name={self.name!r}, &#39;</span>
<span class="gi">+                f&#39;target_uri={self.target_uri!r}, &#39;</span>
<span class="gi">+                f&#39;locations={self.locations!r})&#39;)</span>

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, _IntersphinxProject):
<span class="w"> </span>            return NotImplemented
<span class="gd">-        return (self.name == other.name and self.target_uri == other.</span>
<span class="gd">-            target_uri and self.locations == other.locations)</span>
<span class="gi">+        return (</span>
<span class="gi">+            self.name == other.name</span>
<span class="gi">+            and self.target_uri == other.target_uri</span>
<span class="gi">+            and self.locations == other.locations</span>
<span class="gi">+        )</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.name, self.target_uri, self.locations))

<span class="gd">-    def __setattr__(self, key: str, value: Any) -&gt;NoReturn:</span>
<span class="gi">+    def __setattr__(self, key: str, value: Any) -&gt; NoReturn:</span>
<span class="w"> </span>        msg = f&#39;{self.__class__.__name__} is immutable&#39;
<span class="w"> </span>        raise AttributeError(msg)

<span class="gd">-    def __delattr__(self, key: str) -&gt;NoReturn:</span>
<span class="gi">+    def __delattr__(self, key: str) -&gt; NoReturn:</span>
<span class="w"> </span>        msg = f&#39;{self.__class__.__name__} is immutable&#39;
<span class="w"> </span>        raise AttributeError(msg)

<span class="gu">@@ -74,15 +112,18 @@ class _IntersphinxProject:</span>
<span class="w"> </span>class InventoryAdapter:
<span class="w"> </span>    &quot;&quot;&quot;Inventory adapter for environment&quot;&quot;&quot;

<span class="gd">-    def __init__(self, env: BuildEnvironment) -&gt;None:</span>
<span class="gi">+    def __init__(self, env: BuildEnvironment) -&gt; None:</span>
<span class="w"> </span>        self.env = env
<span class="gi">+</span>
<span class="w"> </span>        if not hasattr(env, &#39;intersphinx_cache&#39;):
<span class="gd">-            self.env.intersphinx_cache = {}</span>
<span class="gd">-            self.env.intersphinx_inventory = {}</span>
<span class="gd">-            self.env.intersphinx_named_inventory = {}</span>
<span class="gi">+            # initial storage when fetching inventories before processing</span>
<span class="gi">+            self.env.intersphinx_cache = {}  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="gi">+            self.env.intersphinx_inventory = {}  # type: ignore[attr-defined]</span>
<span class="gi">+            self.env.intersphinx_named_inventory = {}  # type: ignore[attr-defined]</span>

<span class="w"> </span>    @property
<span class="gd">-    def cache(self) -&gt;dict[InventoryURI, InventoryCacheEntry]:</span>
<span class="gi">+    def cache(self) -&gt; dict[InventoryURI, InventoryCacheEntry]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Intersphinx cache.

<span class="w"> </span>        - Key is the URI of the remote inventory.
<span class="gu">@@ -90,4 +131,16 @@ class InventoryAdapter:</span>
<span class="w"> </span>        - Element two is a time value for cache invalidation, an integer.
<span class="w"> </span>        - Element three is the loaded remote inventory of type :class:`!Inventory`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.env.intersphinx_cache  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def main_inventory(self) -&gt; Inventory:</span>
<span class="gi">+        return self.env.intersphinx_inventory  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def named_inventory(self) -&gt; dict[InventoryName, Inventory]:</span>
<span class="gi">+        return self.env.intersphinx_named_inventory  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="gi">+    def clear(self) -&gt; None:</span>
<span class="gi">+        self.env.intersphinx_inventory.clear()  # type: ignore[attr-defined]</span>
<span class="gi">+        self.env.intersphinx_named_inventory.clear()  # type: ignore[attr-defined]</span>
<span class="gh">diff --git a/sphinx/ext/linkcode.py b/sphinx/ext/linkcode.py</span>
<span class="gh">index 87aa9c120..93118cd67 100644</span>
<span class="gd">--- a/sphinx/ext/linkcode.py</span>
<span class="gi">+++ b/sphinx/ext/linkcode.py</span>
<span class="gu">@@ -1,16 +1,78 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Add external links to module code in Python object descriptions.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>import sphinx
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.errors import SphinxError
<span class="w"> </span>from sphinx.locale import _
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.nodes import Node
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata


<span class="w"> </span>class LinkcodeError(SphinxError):
<span class="gd">-    category = &#39;linkcode error&#39;</span>
<span class="gi">+    category = &quot;linkcode error&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def doctree_read(app: Sphinx, doctree: Node) -&gt; None:</span>
<span class="gi">+    env = app.builder.env</span>
<span class="gi">+</span>
<span class="gi">+    resolve_target = getattr(env.config, &#39;linkcode_resolve&#39;, None)</span>
<span class="gi">+    if not callable(env.config.linkcode_resolve):</span>
<span class="gi">+        msg = &#39;Function `linkcode_resolve` is not given in conf.py&#39;</span>
<span class="gi">+        raise LinkcodeError(msg)</span>
<span class="gi">+    assert resolve_target is not None  # for mypy</span>
<span class="gi">+</span>
<span class="gi">+    domain_keys = {</span>
<span class="gi">+        &#39;py&#39;: [&#39;module&#39;, &#39;fullname&#39;],</span>
<span class="gi">+        &#39;c&#39;: [&#39;names&#39;],</span>
<span class="gi">+        &#39;cpp&#39;: [&#39;names&#39;],</span>
<span class="gi">+        &#39;js&#39;: [&#39;object&#39;, &#39;fullname&#39;],</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    for objnode in list(doctree.findall(addnodes.desc)):</span>
<span class="gi">+        domain = objnode.get(&#39;domain&#39;)</span>
<span class="gi">+        uris: set[str] = set()</span>
<span class="gi">+        for signode in objnode:</span>
<span class="gi">+            if not isinstance(signode, addnodes.desc_signature):</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Convert signode to a specified format</span>
<span class="gi">+            info = {}</span>
<span class="gi">+            for key in domain_keys.get(domain, []):</span>
<span class="gi">+                value = signode.get(key)</span>
<span class="gi">+                if not value:</span>
<span class="gi">+                    value = &#39;&#39;</span>
<span class="gi">+                info[key] = value</span>
<span class="gi">+            if not info:</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Call user code to resolve the link</span>
<span class="gi">+            uri = resolve_target(domain, info)</span>
<span class="gi">+            if not uri:</span>
<span class="gi">+                # no source</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if uri in uris or not uri:</span>
<span class="gi">+                # only one link per name, please</span>
<span class="gi">+                continue</span>
<span class="gi">+            uris.add(uri)</span>
<span class="gi">+</span>
<span class="gi">+            inline = nodes.inline(&#39;&#39;, _(&#39;[source]&#39;), classes=[&#39;viewcode-link&#39;])</span>
<span class="gi">+            onlynode = addnodes.only(expr=&#39;html&#39;)</span>
<span class="gi">+            onlynode += nodes.reference(&#39;&#39;, &#39;&#39;, inline, internal=False, refuri=uri)</span>
<span class="gi">+            signode += onlynode</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.connect(&#39;doctree-read&#39;, doctree_read)</span>
<span class="gi">+    app.add_config_value(&#39;linkcode_resolve&#39;, None, &#39;&#39;)</span>
<span class="gi">+    return {&#39;version&#39;: sphinx.__display_version__, &#39;parallel_read_safe&#39;: True}</span>
<span class="gh">diff --git a/sphinx/ext/mathjax.py b/sphinx/ext/mathjax.py</span>
<span class="gh">index 807fbc111..f67f87fed 100644</span>
<span class="gd">--- a/sphinx/ext/mathjax.py</span>
<span class="gi">+++ b/sphinx/ext/mathjax.py</span>
<span class="gu">@@ -4,19 +4,124 @@ This requires the MathJax JavaScript library on your webserver/computer.</span>

<span class="w"> </span>.. _MathJax: https://www.mathjax.org/
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import json
<span class="w"> </span>from typing import TYPE_CHECKING, Any, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>import sphinx
<span class="w"> </span>from sphinx.builders.html import StandaloneHTMLBuilder
<span class="w"> </span>from sphinx.domains.math import MathDomain
<span class="w"> </span>from sphinx.errors import ExtensionError
<span class="w"> </span>from sphinx.locale import _
<span class="w"> </span>from sphinx.util.math import get_node_equation_number
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="w"> </span>    from sphinx.writers.html5 import HTML5Translator
<span class="gi">+</span>
<span class="gi">+# more information for mathjax secure url is here:</span>
<span class="gi">+# https://docs.mathjax.org/en/latest/web/start.html#using-mathjax-from-a-content-delivery-network-cdn</span>
<span class="w"> </span>MATHJAX_URL = &#39;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js&#39;
<span class="gi">+</span>
<span class="w"> </span>logger = sphinx.util.logging.getLogger(__name__)
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def html_visit_math(self: HTML5Translator, node: nodes.math) -&gt; None:</span>
<span class="gi">+    self.body.append(self.starttag(node, &#39;span&#39;, &#39;&#39;, CLASS=&#39;math notranslate nohighlight&#39;))</span>
<span class="gi">+    self.body.append(self.builder.config.mathjax_inline[0] +</span>
<span class="gi">+                     self.encode(node.astext()) +</span>
<span class="gi">+                     self.builder.config.mathjax_inline[1] + &#39;&lt;/span&gt;&#39;)</span>
<span class="gi">+    raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def html_visit_displaymath(self: HTML5Translator, node: nodes.math_block) -&gt; None:</span>
<span class="gi">+    self.body.append(self.starttag(node, &#39;div&#39;, CLASS=&#39;math notranslate nohighlight&#39;))</span>
<span class="gi">+    if node[&#39;nowrap&#39;]:</span>
<span class="gi">+        self.body.append(self.encode(node.astext()))</span>
<span class="gi">+        self.body.append(&#39;&lt;/div&gt;&#39;)</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    # necessary to e.g. set the id property correctly</span>
<span class="gi">+    if node[&#39;number&#39;]:</span>
<span class="gi">+        number = get_node_equation_number(self, node)</span>
<span class="gi">+        self.body.append(&#39;&lt;span class=&quot;eqno&quot;&gt;(%s)&#39; % number)</span>
<span class="gi">+        self.add_permalink_ref(node, _(&#39;Link to this equation&#39;))</span>
<span class="gi">+        self.body.append(&#39;&lt;/span&gt;&#39;)</span>
<span class="gi">+    self.body.append(self.builder.config.mathjax_display[0])</span>
<span class="gi">+    parts = [prt for prt in node.astext().split(&#39;\n\n&#39;) if prt.strip()]</span>
<span class="gi">+    if len(parts) &gt; 1:  # Add alignment if there are more than 1 equation</span>
<span class="gi">+        self.body.append(r&#39; \begin{align}\begin{aligned}&#39;)</span>
<span class="gi">+    for i, part in enumerate(parts):</span>
<span class="gi">+        part = self.encode(part)</span>
<span class="gi">+        if r&#39;\\&#39; in part:</span>
<span class="gi">+            self.body.append(r&#39;\begin{split}&#39; + part + r&#39;\end{split}&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.body.append(part)</span>
<span class="gi">+        if i &lt; len(parts) - 1:  # append new line if not the last equation</span>
<span class="gi">+            self.body.append(r&#39;\\&#39;)</span>
<span class="gi">+    if len(parts) &gt; 1:  # Add alignment if there are more than 1 equation</span>
<span class="gi">+        self.body.append(r&#39;\end{aligned}\end{align} &#39;)</span>
<span class="gi">+    self.body.append(self.builder.config.mathjax_display[1])</span>
<span class="gi">+    self.body.append(&#39;&lt;/div&gt;\n&#39;)</span>
<span class="gi">+    raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def install_mathjax(app: Sphinx, pagename: str, templatename: str, context: dict[str, Any],</span>
<span class="gi">+                    event_arg: Any) -&gt; None:</span>
<span class="gi">+    if (</span>
<span class="gi">+        app.builder.format != &#39;html&#39; or</span>
<span class="gi">+        app.builder.math_renderer_name != &#39;mathjax&#39;  # type: ignore[attr-defined]</span>
<span class="gi">+    ):</span>
<span class="gi">+        return</span>
<span class="gi">+    if not app.config.mathjax_path:</span>
<span class="gi">+        msg = &#39;mathjax_path config value must be set for the mathjax extension to work&#39;</span>
<span class="gi">+        raise ExtensionError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    domain = cast(MathDomain, app.env.get_domain(&#39;math&#39;))</span>
<span class="gi">+    builder = cast(StandaloneHTMLBuilder, app.builder)</span>
<span class="gi">+    if app.registry.html_assets_policy == &#39;always&#39; or domain.has_equations(pagename):</span>
<span class="gi">+        # Enable mathjax only if equations exists</span>
<span class="gi">+        if app.config.mathjax2_config:</span>
<span class="gi">+            if app.config.mathjax_path == MATHJAX_URL:</span>
<span class="gi">+                logger.warning(</span>
<span class="gi">+                    &#39;mathjax_config/mathjax2_config does not work &#39;</span>
<span class="gi">+                    &#39;for the current MathJax version, use mathjax3_config instead&#39;)</span>
<span class="gi">+            body = &#39;MathJax.Hub.Config(%s)&#39; % json.dumps(app.config.mathjax2_config)</span>
<span class="gi">+            builder.add_js_file(&#39;&#39;, type=&#39;text/x-mathjax-config&#39;, body=body)</span>
<span class="gi">+        if app.config.mathjax3_config:</span>
<span class="gi">+            body = &#39;window.MathJax = %s&#39; % json.dumps(app.config.mathjax3_config)</span>
<span class="gi">+            builder.add_js_file(&#39;&#39;, body=body)</span>
<span class="gi">+</span>
<span class="gi">+        options = {}</span>
<span class="gi">+        if app.config.mathjax_options:</span>
<span class="gi">+            options.update(app.config.mathjax_options)</span>
<span class="gi">+        if &#39;async&#39; not in options and &#39;defer&#39; not in options:</span>
<span class="gi">+            if app.config.mathjax3_config:</span>
<span class="gi">+                # Load MathJax v3 via &quot;defer&quot; method</span>
<span class="gi">+                options[&#39;defer&#39;] = &#39;defer&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Load other MathJax via &quot;async&quot; method</span>
<span class="gi">+                options[&#39;async&#39;] = &#39;async&#39;</span>
<span class="gi">+        builder.add_js_file(app.config.mathjax_path, **options)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_html_math_renderer(&#39;mathjax&#39;,</span>
<span class="gi">+                               (html_visit_math, None),</span>
<span class="gi">+                               (html_visit_displaymath, None))</span>
<span class="gi">+</span>
<span class="gi">+    app.add_config_value(&#39;mathjax_path&#39;, MATHJAX_URL, &#39;html&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;mathjax_options&#39;, {}, &#39;html&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;mathjax_inline&#39;, [r&#39;\(&#39;, r&#39;\)&#39;], &#39;html&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;mathjax_display&#39;, [r&#39;\[&#39;, r&#39;\]&#39;], &#39;html&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;mathjax_config&#39;, None, &#39;html&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;mathjax2_config&#39;, lambda c: c.mathjax_config, &#39;html&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;mathjax3_config&#39;, None, &#39;html&#39;)</span>
<span class="gi">+    app.connect(&#39;html-page-context&#39;, install_mathjax)</span>
<span class="gi">+</span>
<span class="gi">+    return {&#39;version&#39;: sphinx.__display_version__, &#39;parallel_read_safe&#39;: True}</span>
<span class="gh">diff --git a/sphinx/ext/napoleon/docstring.py b/sphinx/ext/napoleon/docstring.py</span>
<span class="gh">index 9ee30cfc5..cc3c7f4ce 100644</span>
<span class="gd">--- a/sphinx/ext/napoleon/docstring.py</span>
<span class="gi">+++ b/sphinx/ext/napoleon/docstring.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Classes for docstring parsing and formatting.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import collections
<span class="w"> </span>import contextlib
<span class="w"> </span>import inspect
<span class="gu">@@ -7,33 +9,47 @@ import re</span>
<span class="w"> </span>from functools import partial
<span class="w"> </span>from itertools import starmap
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from sphinx.locale import _, __
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.typing import get_type_hints, stringify_annotation
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Callable, Iterator
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.config import Config as SphinxConfig
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gd">-_directive_regex = re.compile(&#39;\\.\\. \\S+::&#39;)</span>
<span class="gd">-_google_section_regex = re.compile(&#39;^(\\s|\\w)+:\\s*$&#39;)</span>
<span class="gd">-_google_typed_arg_regex = re.compile(&#39;(.+?)\\(\\s*(.*[^\\s]+)\\s*\\)&#39;)</span>
<span class="gd">-_numpy_section_regex = re.compile(&#39;^[=\\-`:\\\&#39;&quot;~^_*+#&lt;&gt;]{2,}\\s*$&#39;)</span>
<span class="gd">-_single_colon_regex = re.compile(&#39;(?&lt;!:):(?!:)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+_directive_regex = re.compile(r&#39;\.\. \S+::&#39;)</span>
<span class="gi">+_google_section_regex = re.compile(r&#39;^(\s|\w)+:\s*$&#39;)</span>
<span class="gi">+_google_typed_arg_regex = re.compile(r&#39;(.+?)\(\s*(.*[^\s]+)\s*\)&#39;)</span>
<span class="gi">+_numpy_section_regex = re.compile(r&#39;^[=\-`:\&#39;&quot;~^_*+#&lt;&gt;]{2,}\s*$&#39;)</span>
<span class="gi">+_single_colon_regex = re.compile(r&#39;(?&lt;!:):(?!:)&#39;)</span>
<span class="w"> </span>_xref_or_code_regex = re.compile(
<span class="gd">-    &#39;((?::(?:[a-zA-Z0-9]+[\\-_+:.])*[a-zA-Z0-9]+:`.+?`)|(?:``.+?``)|(?::meta .+:.*)|(?:`.+?\\s*(?&lt;!\\x00)&lt;.*?&gt;`))&#39;</span>
<span class="gd">-    )</span>
<span class="gi">+    r&#39;((?::(?:[a-zA-Z0-9]+[\-_+:.])*[a-zA-Z0-9]+:`.+?`)|&#39;</span>
<span class="gi">+    r&#39;(?:``.+?``)|&#39;</span>
<span class="gi">+    r&#39;(?::meta .+:.*)|&#39;</span>
<span class="gi">+    r&#39;(?:`.+?\s*(?&lt;!\x00)&lt;.*?&gt;`))&#39;)</span>
<span class="w"> </span>_xref_regex = re.compile(
<span class="gd">-    &#39;(?:(?::(?:[a-zA-Z0-9]+[\\-_+:.])*[a-zA-Z0-9]+:)?`.+?`)&#39;)</span>
<span class="gd">-_bullet_list_regex = re.compile(&#39;^(\\*|\\+|\\-)(\\s+\\S|\\s*$)&#39;)</span>
<span class="gi">+    r&#39;(?:(?::(?:[a-zA-Z0-9]+[\-_+:.])*[a-zA-Z0-9]+:)?`.+?`)&#39;,</span>
<span class="gi">+)</span>
<span class="gi">+_bullet_list_regex = re.compile(r&#39;^(\*|\+|\-)(\s+\S|\s*$)&#39;)</span>
<span class="w"> </span>_enumerated_list_regex = re.compile(
<span class="gd">-    &#39;^(?P&lt;paren&gt;\\()?(\\d+|#|[ivxlcdm]+|[IVXLCDM]+|[a-zA-Z])(?(paren)\\)|\\.)(\\s+\\S|\\s*$)&#39;</span>
<span class="gd">-    )</span>
<span class="gi">+    r&#39;^(?P&lt;paren&gt;\()?&#39;</span>
<span class="gi">+    r&#39;(\d+|#|[ivxlcdm]+|[IVXLCDM]+|[a-zA-Z])&#39;</span>
<span class="gi">+    r&#39;(?(paren)\)|\.)(\s+\S|\s*$)&#39;)</span>
<span class="w"> </span>_token_regex = re.compile(
<span class="gd">-    &#39;(,\\sor\\s|\\sor\\s|\\sof\\s|:\\s|\\sto\\s|,\\sand\\s|\\sand\\s|,\\s|[{]|[}]|&quot;(?:\\\\&quot;|[^&quot;])*&quot;|\&#39;(?:\\\\\&#39;|[^\&#39;])*\&#39;)&#39;</span>
<span class="gd">-    )</span>
<span class="gd">-_default_regex = re.compile(&#39;^default[^_0-9A-Za-z].*$&#39;)</span>
<span class="gd">-_SINGLETONS = &#39;None&#39;, &#39;True&#39;, &#39;False&#39;, &#39;Ellipsis&#39;</span>
<span class="gi">+    r&quot;(,\sor\s|\sor\s|\sof\s|:\s|\sto\s|,\sand\s|\sand\s|,\s&quot;</span>
<span class="gi">+    r&quot;|[{]|[}]&quot;</span>
<span class="gi">+    r&#39;|&quot;(?:\\&quot;|[^&quot;])*&quot;&#39;</span>
<span class="gi">+    r&quot;|&#39;(?:\\&#39;|[^&#39;])*&#39;)&quot;,</span>
<span class="gi">+)</span>
<span class="gi">+_default_regex = re.compile(</span>
<span class="gi">+    r&quot;^default[^_0-9A-Za-z].*$&quot;,</span>
<span class="gi">+)</span>
<span class="gi">+_SINGLETONS = (&quot;None&quot;, &quot;True&quot;, &quot;False&quot;, &quot;Ellipsis&quot;)</span>


<span class="w"> </span>class Deque(collections.deque):
<span class="gu">@@ -42,20 +58,30 @@ class Deque(collections.deque):</span>

<span class="w"> </span>    The `.Deque.get` and `.Deque.next` methods are added.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    sentinel = object()

<span class="gd">-    def get(self, n: int) -&gt;Any:</span>
<span class="gi">+    def get(self, n: int) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Return the nth element of the stack, or ``self.sentinel`` if n is
<span class="w"> </span>        greater than the stack size.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self[n] if n &lt; len(self) else self.sentinel</span>
<span class="gi">+</span>
<span class="gi">+    def next(self) -&gt; Any:</span>
<span class="gi">+        if self:</span>
<span class="gi">+            return super().popleft()</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise StopIteration</span>


<span class="gd">-def _convert_type_spec(_type: str, translations: (dict[str, str] | None)=None</span>
<span class="gd">-    ) -&gt;str:</span>
<span class="gi">+def _convert_type_spec(_type: str, translations: dict[str, str] | None = None) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert type specification to reference in reST.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if translations is not None and _type in translations:</span>
<span class="gi">+        return translations[_type]</span>
<span class="gi">+    if _type == &#39;None&#39;:</span>
<span class="gi">+        return &#39;:py:obj:`None`&#39;</span>
<span class="gi">+    return f&#39;:py:class:`{_type}`&#39;</span>


<span class="w"> </span>class GoogleDocstring:
<span class="gu">@@ -120,13 +146,20 @@ class GoogleDocstring:</span>
<span class="w"> </span>    &lt;BLANKLINE&gt;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    _name_rgx = re.compile(</span>
<span class="gd">-        &#39;^\\s*((?::(?P&lt;role&gt;\\S+):)?`(?P&lt;name&gt;~?[a-zA-Z0-9_.-]+)`| (?P&lt;name2&gt;~?[a-zA-Z0-9_.-]+))\\s*&#39;</span>
<span class="gd">-        , re.VERBOSE)</span>

<span class="gd">-    def __init__(self, docstring: (str | list[str]), config: (SphinxConfig |</span>
<span class="gd">-        None)=None, app: (Sphinx | None)=None, what: str=&#39;&#39;, name: str=&#39;&#39;,</span>
<span class="gd">-        obj: Any=None, options: Any=None) -&gt;None:</span>
<span class="gi">+    _name_rgx = re.compile(r&quot;^\s*((?::(?P&lt;role&gt;\S+):)?`(?P&lt;name&gt;~?[a-zA-Z0-9_.-]+)`|&quot;</span>
<span class="gi">+                           r&quot; (?P&lt;name2&gt;~?[a-zA-Z0-9_.-]+))\s*&quot;, re.VERBOSE)</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        docstring: str | list[str],</span>
<span class="gi">+        config: SphinxConfig | None = None,</span>
<span class="gi">+        app: Sphinx | None = None,</span>
<span class="gi">+        what: str = &#39;&#39;,</span>
<span class="gi">+        name: str = &#39;&#39;,</span>
<span class="gi">+        obj: Any = None,</span>
<span class="gi">+        options: Any = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self._app = app
<span class="w"> </span>        if config:
<span class="w"> </span>            self._config = config
<span class="gu">@@ -134,7 +167,9 @@ class GoogleDocstring:</span>
<span class="w"> </span>            self._config = app.config
<span class="w"> </span>        else:
<span class="w"> </span>            from sphinx.ext.napoleon import Config
<span class="gd">-            self._config = Config()</span>
<span class="gi">+</span>
<span class="gi">+            self._config = Config()  # type: ignore[assignment]</span>
<span class="gi">+</span>
<span class="w"> </span>        if not what:
<span class="w"> </span>            if inspect.isclass(obj):
<span class="w"> </span>                what = &#39;class&#39;
<span class="gu">@@ -144,6 +179,7 @@ class GoogleDocstring:</span>
<span class="w"> </span>                what = &#39;function&#39;
<span class="w"> </span>            else:
<span class="w"> </span>                what = &#39;object&#39;
<span class="gi">+</span>
<span class="w"> </span>        self._what = what
<span class="w"> </span>        self._name = name
<span class="w"> </span>        self._obj = obj
<span class="gu">@@ -159,43 +195,48 @@ class GoogleDocstring:</span>
<span class="w"> </span>        if not hasattr(self, &#39;_directive_sections&#39;):
<span class="w"> </span>            self._directive_sections: list[str] = []
<span class="w"> </span>        if not hasattr(self, &#39;_sections&#39;):
<span class="gd">-            self._sections: dict[str, Callable] = {&#39;args&#39;: self.</span>
<span class="gd">-                _parse_parameters_section, &#39;arguments&#39;: self.</span>
<span class="gd">-                _parse_parameters_section, &#39;attention&#39;: partial(self.</span>
<span class="gd">-                _parse_admonition, &#39;attention&#39;), &#39;attributes&#39;: self.</span>
<span class="gd">-                _parse_attributes_section, &#39;caution&#39;: partial(self.</span>
<span class="gd">-                _parse_admonition, &#39;caution&#39;), &#39;danger&#39;: partial(self.</span>
<span class="gd">-                _parse_admonition, &#39;danger&#39;), &#39;error&#39;: partial(self.</span>
<span class="gd">-                _parse_admonition, &#39;error&#39;), &#39;example&#39;: self.</span>
<span class="gd">-                _parse_examples_section, &#39;examples&#39;: self.</span>
<span class="gd">-                _parse_examples_section, &#39;hint&#39;: partial(self.</span>
<span class="gd">-                _parse_admonition, &#39;hint&#39;), &#39;important&#39;: partial(self.</span>
<span class="gd">-                _parse_admonition, &#39;important&#39;), &#39;keyword args&#39;: self.</span>
<span class="gd">-                _parse_keyword_arguments_section, &#39;keyword arguments&#39;: self</span>
<span class="gd">-                ._parse_keyword_arguments_section, &#39;methods&#39;: self.</span>
<span class="gd">-                _parse_methods_section, &#39;note&#39;: partial(self.</span>
<span class="gd">-                _parse_admonition, &#39;note&#39;), &#39;notes&#39;: self.</span>
<span class="gd">-                _parse_notes_section, &#39;other parameters&#39;: self.</span>
<span class="gd">-                _parse_other_parameters_section, &#39;parameters&#39;: self.</span>
<span class="gd">-                _parse_parameters_section, &#39;receive&#39;: self.</span>
<span class="gd">-                _parse_receives_section, &#39;receives&#39;: self.</span>
<span class="gd">-                _parse_receives_section, &#39;return&#39;: self.</span>
<span class="gd">-                _parse_returns_section, &#39;returns&#39;: self.</span>
<span class="gd">-                _parse_returns_section, &#39;raise&#39;: self._parse_raises_section,</span>
<span class="gd">-                &#39;raises&#39;: self._parse_raises_section, &#39;references&#39;: self.</span>
<span class="gd">-                _parse_references_section, &#39;see also&#39;: self.</span>
<span class="gd">-                _parse_see_also_section, &#39;tip&#39;: partial(self.</span>
<span class="gd">-                _parse_admonition, &#39;tip&#39;), &#39;todo&#39;: partial(self.</span>
<span class="gd">-                _parse_admonition, &#39;todo&#39;), &#39;warning&#39;: partial(self.</span>
<span class="gd">-                _parse_admonition, &#39;warning&#39;), &#39;warnings&#39;: partial(self.</span>
<span class="gd">-                _parse_admonition, &#39;warning&#39;), &#39;warn&#39;: self.</span>
<span class="gd">-                _parse_warns_section, &#39;warns&#39;: self._parse_warns_section,</span>
<span class="gd">-                &#39;yield&#39;: self._parse_yields_section, &#39;yields&#39;: self.</span>
<span class="gd">-                _parse_yields_section}</span>
<span class="gi">+            self._sections: dict[str, Callable] = {</span>
<span class="gi">+                &#39;args&#39;: self._parse_parameters_section,</span>
<span class="gi">+                &#39;arguments&#39;: self._parse_parameters_section,</span>
<span class="gi">+                &#39;attention&#39;: partial(self._parse_admonition, &#39;attention&#39;),</span>
<span class="gi">+                &#39;attributes&#39;: self._parse_attributes_section,</span>
<span class="gi">+                &#39;caution&#39;: partial(self._parse_admonition, &#39;caution&#39;),</span>
<span class="gi">+                &#39;danger&#39;: partial(self._parse_admonition, &#39;danger&#39;),</span>
<span class="gi">+                &#39;error&#39;: partial(self._parse_admonition, &#39;error&#39;),</span>
<span class="gi">+                &#39;example&#39;: self._parse_examples_section,</span>
<span class="gi">+                &#39;examples&#39;: self._parse_examples_section,</span>
<span class="gi">+                &#39;hint&#39;: partial(self._parse_admonition, &#39;hint&#39;),</span>
<span class="gi">+                &#39;important&#39;: partial(self._parse_admonition, &#39;important&#39;),</span>
<span class="gi">+                &#39;keyword args&#39;: self._parse_keyword_arguments_section,</span>
<span class="gi">+                &#39;keyword arguments&#39;: self._parse_keyword_arguments_section,</span>
<span class="gi">+                &#39;methods&#39;: self._parse_methods_section,</span>
<span class="gi">+                &#39;note&#39;: partial(self._parse_admonition, &#39;note&#39;),</span>
<span class="gi">+                &#39;notes&#39;: self._parse_notes_section,</span>
<span class="gi">+                &#39;other parameters&#39;: self._parse_other_parameters_section,</span>
<span class="gi">+                &#39;parameters&#39;: self._parse_parameters_section,</span>
<span class="gi">+                &#39;receive&#39;: self._parse_receives_section,</span>
<span class="gi">+                &#39;receives&#39;: self._parse_receives_section,</span>
<span class="gi">+                &#39;return&#39;: self._parse_returns_section,</span>
<span class="gi">+                &#39;returns&#39;: self._parse_returns_section,</span>
<span class="gi">+                &#39;raise&#39;: self._parse_raises_section,</span>
<span class="gi">+                &#39;raises&#39;: self._parse_raises_section,</span>
<span class="gi">+                &#39;references&#39;: self._parse_references_section,</span>
<span class="gi">+                &#39;see also&#39;: self._parse_see_also_section,</span>
<span class="gi">+                &#39;tip&#39;: partial(self._parse_admonition, &#39;tip&#39;),</span>
<span class="gi">+                &#39;todo&#39;: partial(self._parse_admonition, &#39;todo&#39;),</span>
<span class="gi">+                &#39;warning&#39;: partial(self._parse_admonition, &#39;warning&#39;),</span>
<span class="gi">+                &#39;warnings&#39;: partial(self._parse_admonition, &#39;warning&#39;),</span>
<span class="gi">+                &#39;warn&#39;: self._parse_warns_section,</span>
<span class="gi">+                &#39;warns&#39;: self._parse_warns_section,</span>
<span class="gi">+                &#39;yield&#39;: self._parse_yields_section,</span>
<span class="gi">+                &#39;yields&#39;: self._parse_yields_section,</span>
<span class="gi">+            }</span>
<span class="gi">+</span>
<span class="w"> </span>        self._load_custom_sections()
<span class="gi">+</span>
<span class="w"> </span>        self._parse()

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the parsed docstring in reStructuredText format.

<span class="w"> </span>        Returns
<span class="gu">@@ -206,7 +247,7 @@ class GoogleDocstring:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        return &#39;\n&#39;.join(self.lines())

<span class="gd">-    def lines(self) -&gt;list[str]:</span>
<span class="gi">+    def lines(self) -&gt; list[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the parsed lines of the docstring in reStructuredText format.

<span class="w"> </span>        Returns
<span class="gu">@@ -215,7 +256,812 @@ class GoogleDocstring:</span>
<span class="w"> </span>            The lines of the docstring in a list.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._parsed_lines</span>
<span class="gi">+</span>
<span class="gi">+    def _consume_indented_block(self, indent: int = 1) -&gt; list[str]:</span>
<span class="gi">+        lines = []</span>
<span class="gi">+        line = self._lines.get(0)</span>
<span class="gi">+        while (</span>
<span class="gi">+            not self._is_section_break() and</span>
<span class="gi">+            (not line or self._is_indented(line, indent))</span>
<span class="gi">+        ):</span>
<span class="gi">+            lines.append(self._lines.next())</span>
<span class="gi">+            line = self._lines.get(0)</span>
<span class="gi">+        return lines</span>
<span class="gi">+</span>
<span class="gi">+    def _consume_contiguous(self) -&gt; list[str]:</span>
<span class="gi">+        lines = []</span>
<span class="gi">+        while (self._lines and</span>
<span class="gi">+               self._lines.get(0) and</span>
<span class="gi">+               not self._is_section_header()):</span>
<span class="gi">+            lines.append(self._lines.next())</span>
<span class="gi">+        return lines</span>
<span class="gi">+</span>
<span class="gi">+    def _consume_empty(self) -&gt; list[str]:</span>
<span class="gi">+        lines = []</span>
<span class="gi">+        line = self._lines.get(0)</span>
<span class="gi">+        while self._lines and not line:</span>
<span class="gi">+            lines.append(self._lines.next())</span>
<span class="gi">+            line = self._lines.get(0)</span>
<span class="gi">+        return lines</span>
<span class="gi">+</span>
<span class="gi">+    def _consume_field(self, parse_type: bool = True, prefer_type: bool = False,</span>
<span class="gi">+                       ) -&gt; tuple[str, str, list[str]]:</span>
<span class="gi">+        line = self._lines.next()</span>
<span class="gi">+</span>
<span class="gi">+        before, colon, after = self._partition_field_on_colon(line)</span>
<span class="gi">+        _name, _type, _desc = before, &#39;&#39;, after</span>
<span class="gi">+</span>
<span class="gi">+        if parse_type:</span>
<span class="gi">+            match = _google_typed_arg_regex.match(before)</span>
<span class="gi">+            if match:</span>
<span class="gi">+                _name = match.group(1).strip()</span>
<span class="gi">+                _type = match.group(2)</span>
<span class="gi">+</span>
<span class="gi">+        _name = self._escape_args_and_kwargs(_name)</span>
<span class="gi">+</span>
<span class="gi">+        if prefer_type and not _type:</span>
<span class="gi">+            _type, _name = _name, _type</span>
<span class="gi">+</span>
<span class="gi">+        if _type and self._config.napoleon_preprocess_types:</span>
<span class="gi">+            _type = _convert_type_spec(_type, self._config.napoleon_type_aliases or {})</span>
<span class="gi">+</span>
<span class="gi">+        indent = self._get_indent(line) + 1</span>
<span class="gi">+        _descs = [_desc, *self._dedent(self._consume_indented_block(indent))]</span>
<span class="gi">+        _descs = self.__class__(_descs, self._config).lines()</span>
<span class="gi">+        return _name, _type, _descs</span>
<span class="gi">+</span>
<span class="gi">+    def _consume_fields(self, parse_type: bool = True, prefer_type: bool = False,</span>
<span class="gi">+                        multiple: bool = False) -&gt; list[tuple[str, str, list[str]]]:</span>
<span class="gi">+        self._consume_empty()</span>
<span class="gi">+        fields: list[tuple[str, str, list[str]]] = []</span>
<span class="gi">+        while not self._is_section_break():</span>
<span class="gi">+            _name, _type, _desc = self._consume_field(parse_type, prefer_type)</span>
<span class="gi">+            if multiple and _name:</span>
<span class="gi">+                fields.extend((name.strip(), _type, _desc) for name in _name.split(&quot;,&quot;))</span>
<span class="gi">+            elif _name or _type or _desc:</span>
<span class="gi">+                fields.append((_name, _type, _desc))</span>
<span class="gi">+        return fields</span>
<span class="gi">+</span>
<span class="gi">+    def _consume_inline_attribute(self) -&gt; tuple[str, list[str]]:</span>
<span class="gi">+        line = self._lines.next()</span>
<span class="gi">+        _type, colon, _desc = self._partition_field_on_colon(line)</span>
<span class="gi">+        if not colon or not _desc:</span>
<span class="gi">+            _type, _desc = _desc, _type</span>
<span class="gi">+            _desc += colon</span>
<span class="gi">+        _descs = [_desc, *self._dedent(self._consume_to_end())]</span>
<span class="gi">+        _descs = self.__class__(_descs, self._config).lines()</span>
<span class="gi">+        return _type, _descs</span>
<span class="gi">+</span>
<span class="gi">+    def _consume_returns_section(self, preprocess_types: bool = False,</span>
<span class="gi">+                                 ) -&gt; list[tuple[str, str, list[str]]]:</span>
<span class="gi">+        lines = self._dedent(self._consume_to_next_section())</span>
<span class="gi">+        if lines:</span>
<span class="gi">+            before, colon, after = self._partition_field_on_colon(lines[0])</span>
<span class="gi">+            _name, _type, _desc = &#39;&#39;, &#39;&#39;, lines</span>
<span class="gi">+</span>
<span class="gi">+            if colon:</span>
<span class="gi">+                if after:</span>
<span class="gi">+                    _desc = [after] + lines[1:]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    _desc = lines[1:]</span>
<span class="gi">+</span>
<span class="gi">+                _type = before</span>
<span class="gi">+</span>
<span class="gi">+            if (_type and preprocess_types and</span>
<span class="gi">+                    self._config.napoleon_preprocess_types):</span>
<span class="gi">+                _type = _convert_type_spec(_type, self._config.napoleon_type_aliases or {})</span>
<span class="gi">+</span>
<span class="gi">+            _desc = self.__class__(_desc, self._config).lines()</span>
<span class="gi">+            return [(_name, _type, _desc)]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+    def _consume_usage_section(self) -&gt; list[str]:</span>
<span class="gi">+        lines = self._dedent(self._consume_to_next_section())</span>
<span class="gi">+        return lines</span>
<span class="gi">+</span>
<span class="gi">+    def _consume_section_header(self) -&gt; str:</span>
<span class="gi">+        section = self._lines.next()</span>
<span class="gi">+        stripped_section = section.strip(&#39;:&#39;)</span>
<span class="gi">+        if stripped_section.lower() in self._sections:</span>
<span class="gi">+            section = stripped_section</span>
<span class="gi">+        return section</span>
<span class="gi">+</span>
<span class="gi">+    def _consume_to_end(self) -&gt; list[str]:</span>
<span class="gi">+        lines = []</span>
<span class="gi">+        while self._lines:</span>
<span class="gi">+            lines.append(self._lines.next())</span>
<span class="gi">+        return lines</span>
<span class="gi">+</span>
<span class="gi">+    def _consume_to_next_section(self) -&gt; list[str]:</span>
<span class="gi">+        self._consume_empty()</span>
<span class="gi">+        lines = []</span>
<span class="gi">+        while not self._is_section_break():</span>
<span class="gi">+            lines.append(self._lines.next())</span>
<span class="gi">+        return lines + self._consume_empty()</span>
<span class="gi">+</span>
<span class="gi">+    def _dedent(self, lines: list[str], full: bool = False) -&gt; list[str]:</span>
<span class="gi">+        if full:</span>
<span class="gi">+            return [line.lstrip() for line in lines]</span>
<span class="gi">+        else:</span>
<span class="gi">+            min_indent = self._get_min_indent(lines)</span>
<span class="gi">+            return [line[min_indent:] for line in lines]</span>
<span class="gi">+</span>
<span class="gi">+    def _escape_args_and_kwargs(self, name: str) -&gt; str:</span>
<span class="gi">+        if name.endswith(&#39;_&#39;) and getattr(self._config, &#39;strip_signature_backslash&#39;, False):</span>
<span class="gi">+            name = name[:-1] + r&#39;\_&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if name[:2] == &#39;**&#39;:</span>
<span class="gi">+            return r&#39;\*\*&#39; + name[2:]</span>
<span class="gi">+        elif name[:1] == &#39;*&#39;:</span>
<span class="gi">+            return r&#39;\*&#39; + name[1:]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return name</span>
<span class="gi">+</span>
<span class="gi">+    def _fix_field_desc(self, desc: list[str]) -&gt; list[str]:</span>
<span class="gi">+        if self._is_list(desc):</span>
<span class="gi">+            desc = [&#39;&#39;, *desc]</span>
<span class="gi">+        elif desc[0].endswith(&#39;::&#39;):</span>
<span class="gi">+            desc_block = desc[1:]</span>
<span class="gi">+            indent = self._get_indent(desc[0])</span>
<span class="gi">+            block_indent = self._get_initial_indent(desc_block)</span>
<span class="gi">+            if block_indent &gt; indent:</span>
<span class="gi">+                desc = [&#39;&#39;, *desc]</span>
<span class="gi">+            else:</span>
<span class="gi">+                desc = [&#39;&#39;, desc[0], *self._indent(desc_block, 4)]</span>
<span class="gi">+        return desc</span>
<span class="gi">+</span>
<span class="gi">+    def _format_admonition(self, admonition: str, lines: list[str]) -&gt; list[str]:</span>
<span class="gi">+        lines = self._strip_empty(lines)</span>
<span class="gi">+        if len(lines) == 1:</span>
<span class="gi">+            return [f&#39;.. {admonition}:: {lines[0].strip()}&#39;, &#39;&#39;]</span>
<span class="gi">+        elif lines:</span>
<span class="gi">+            lines = self._indent(self._dedent(lines), 3)</span>
<span class="gi">+            return [&#39;.. %s::&#39; % admonition, &#39;&#39;, *lines, &#39;&#39;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return [&#39;.. %s::&#39; % admonition, &#39;&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    def _format_block(</span>
<span class="gi">+        self, prefix: str, lines: list[str], padding: str | None = None,</span>
<span class="gi">+    ) -&gt; list[str]:</span>
<span class="gi">+        if lines:</span>
<span class="gi">+            if padding is None:</span>
<span class="gi">+                padding = &#39; &#39; * len(prefix)</span>
<span class="gi">+            result_lines = []</span>
<span class="gi">+            for i, line in enumerate(lines):</span>
<span class="gi">+                if i == 0:</span>
<span class="gi">+                    result_lines.append((prefix + line).rstrip())</span>
<span class="gi">+                elif line:</span>
<span class="gi">+                    result_lines.append(padding + line)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    result_lines.append(&#39;&#39;)</span>
<span class="gi">+            return result_lines</span>
<span class="gi">+        else:</span>
<span class="gi">+            return [prefix]</span>
<span class="gi">+</span>
<span class="gi">+    def _format_docutils_params(self, fields: list[tuple[str, str, list[str]]],</span>
<span class="gi">+                                field_role: str = &#39;param&#39;, type_role: str = &#39;type&#39;,</span>
<span class="gi">+                                ) -&gt; list[str]:</span>
<span class="gi">+        lines = []</span>
<span class="gi">+        for _name, _type, _desc in fields:</span>
<span class="gi">+            _desc = self._strip_empty(_desc)</span>
<span class="gi">+            if any(_desc):</span>
<span class="gi">+                _desc = self._fix_field_desc(_desc)</span>
<span class="gi">+                field = f&#39;:{field_role} {_name}: &#39;</span>
<span class="gi">+                lines.extend(self._format_block(field, _desc))</span>
<span class="gi">+            else:</span>
<span class="gi">+                lines.append(f&#39;:{field_role} {_name}:&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            if _type:</span>
<span class="gi">+                lines.append(f&#39;:{type_role} {_name}: {_type}&#39;)</span>
<span class="gi">+        return [*lines, &#39;&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    def _format_field(self, _name: str, _type: str, _desc: list[str]) -&gt; list[str]:</span>
<span class="gi">+        _desc = self._strip_empty(_desc)</span>
<span class="gi">+        has_desc = any(_desc)</span>
<span class="gi">+        separator = &#39; -- &#39; if has_desc else &#39;&#39;</span>
<span class="gi">+        if _name:</span>
<span class="gi">+            if _type:</span>
<span class="gi">+                if &#39;`&#39; in _type:</span>
<span class="gi">+                    field = f&#39;**{_name}** ({_type}){separator}&#39;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    field = f&#39;**{_name}** (*{_type}*){separator}&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                field = f&#39;**{_name}**{separator}&#39;</span>
<span class="gi">+        elif _type:</span>
<span class="gi">+            if &#39;`&#39; in _type:</span>
<span class="gi">+                field = f&#39;{_type}{separator}&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                field = f&#39;*{_type}*{separator}&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            field = &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if has_desc:</span>
<span class="gi">+            _desc = self._fix_field_desc(_desc)</span>
<span class="gi">+            if _desc[0]:</span>
<span class="gi">+                return [field + _desc[0]] + _desc[1:]</span>
<span class="gi">+            else:</span>
<span class="gi">+                return [field, *_desc]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return [field]</span>
<span class="gi">+</span>
<span class="gi">+    def _format_fields(self, field_type: str, fields: list[tuple[str, str, list[str]]],</span>
<span class="gi">+                       ) -&gt; list[str]:</span>
<span class="gi">+        field_type = &#39;:%s:&#39; % field_type.strip()</span>
<span class="gi">+        padding = &#39; &#39; * len(field_type)</span>
<span class="gi">+        multi = len(fields) &gt; 1</span>
<span class="gi">+        lines: list[str] = []</span>
<span class="gi">+        for _name, _type, _desc in fields:</span>
<span class="gi">+            field = self._format_field(_name, _type, _desc)</span>
<span class="gi">+            if multi:</span>
<span class="gi">+                if lines:</span>
<span class="gi">+                    lines.extend(self._format_block(padding + &#39; * &#39;, field))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    lines.extend(self._format_block(field_type + &#39; * &#39;, field))</span>
<span class="gi">+            else:</span>
<span class="gi">+                lines.extend(self._format_block(field_type + &#39; &#39;, field))</span>
<span class="gi">+        if lines and lines[-1]:</span>
<span class="gi">+            lines.append(&#39;&#39;)</span>
<span class="gi">+        return lines</span>
<span class="gi">+</span>
<span class="gi">+    def _get_current_indent(self, peek_ahead: int = 0) -&gt; int:</span>
<span class="gi">+        line = self._lines.get(peek_ahead)</span>
<span class="gi">+        while line is not self._lines.sentinel:</span>
<span class="gi">+            if line:</span>
<span class="gi">+                return self._get_indent(line)</span>
<span class="gi">+            peek_ahead += 1</span>
<span class="gi">+            line = self._lines.get(peek_ahead)</span>
<span class="gi">+        return 0</span>
<span class="gi">+</span>
<span class="gi">+    def _get_indent(self, line: str) -&gt; int:</span>
<span class="gi">+        for i, s in enumerate(line):</span>
<span class="gi">+            if not s.isspace():</span>
<span class="gi">+                return i</span>
<span class="gi">+        return len(line)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_initial_indent(self, lines: list[str]) -&gt; int:</span>
<span class="gi">+        for line in lines:</span>
<span class="gi">+            if line:</span>
<span class="gi">+                return self._get_indent(line)</span>
<span class="gi">+        return 0</span>
<span class="gi">+</span>
<span class="gi">+    def _get_min_indent(self, lines: list[str]) -&gt; int:</span>
<span class="gi">+        min_indent = None</span>
<span class="gi">+        for line in lines:</span>
<span class="gi">+            if line:</span>
<span class="gi">+                indent = self._get_indent(line)</span>
<span class="gi">+                if min_indent is None or indent &lt; min_indent:</span>
<span class="gi">+                    min_indent = indent</span>
<span class="gi">+        return min_indent or 0</span>
<span class="gi">+</span>
<span class="gi">+    def _indent(self, lines: list[str], n: int = 4) -&gt; list[str]:</span>
<span class="gi">+        return [(&#39; &#39; * n) + line for line in lines]</span>
<span class="gi">+</span>
<span class="gi">+    def _is_indented(self, line: str, indent: int = 1) -&gt; bool:</span>
<span class="gi">+        for i, s in enumerate(line):  # NoQA: SIM110</span>
<span class="gi">+            if i &gt;= indent:</span>
<span class="gi">+                return True</span>
<span class="gi">+            elif not s.isspace():</span>
<span class="gi">+                return False</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def _is_list(self, lines: list[str]) -&gt; bool:</span>
<span class="gi">+        if not lines:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if _bullet_list_regex.match(lines[0]):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if _enumerated_list_regex.match(lines[0]):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if len(lines) &lt; 2 or lines[0].endswith(&#39;::&#39;):</span>
<span class="gi">+            return False</span>
<span class="gi">+        indent = self._get_indent(lines[0])</span>
<span class="gi">+        next_indent = indent</span>
<span class="gi">+        for line in lines[1:]:</span>
<span class="gi">+            if line:</span>
<span class="gi">+                next_indent = self._get_indent(line)</span>
<span class="gi">+                break</span>
<span class="gi">+        return next_indent &gt; indent</span>
<span class="gi">+</span>
<span class="gi">+    def _is_section_header(self) -&gt; bool:</span>
<span class="gi">+        section = self._lines.get(0).lower()</span>
<span class="gi">+        match = _google_section_regex.match(section)</span>
<span class="gi">+        if match and section.strip(&#39;:&#39;) in self._sections:</span>
<span class="gi">+            header_indent = self._get_indent(section)</span>
<span class="gi">+            section_indent = self._get_current_indent(peek_ahead=1)</span>
<span class="gi">+            return section_indent &gt; header_indent</span>
<span class="gi">+        elif self._directive_sections:</span>
<span class="gi">+            if _directive_regex.match(section):</span>
<span class="gi">+                for directive_section in self._directive_sections:</span>
<span class="gi">+                    if section.startswith(directive_section):</span>
<span class="gi">+                        return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def _is_section_break(self) -&gt; bool:</span>
<span class="gi">+        line = self._lines.get(0)</span>
<span class="gi">+        return (not self._lines or</span>
<span class="gi">+                self._is_section_header() or</span>
<span class="gi">+                (self._is_in_section and</span>
<span class="gi">+                    line and</span>
<span class="gi">+                    not self._is_indented(line, self._section_indent)))</span>
<span class="gi">+</span>
<span class="gi">+    def _load_custom_sections(self) -&gt; None:</span>
<span class="gi">+        if self._config.napoleon_custom_sections is not None:</span>
<span class="gi">+            for entry in self._config.napoleon_custom_sections:</span>
<span class="gi">+                if isinstance(entry, str):</span>
<span class="gi">+                    # if entry is just a label, add to sections list,</span>
<span class="gi">+                    # using generic section logic.</span>
<span class="gi">+                    self._sections[entry.lower()] = self._parse_custom_generic_section</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # otherwise, assume entry is container;</span>
<span class="gi">+                    if entry[1] == &quot;params_style&quot;:</span>
<span class="gi">+                        self._sections[entry[0].lower()] = \</span>
<span class="gi">+                            self._parse_custom_params_style_section</span>
<span class="gi">+                    elif entry[1] == &quot;returns_style&quot;:</span>
<span class="gi">+                        self._sections[entry[0].lower()] = \</span>
<span class="gi">+                            self._parse_custom_returns_style_section</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        # [0] is new section, [1] is the section to alias.</span>
<span class="gi">+                        # in the case of key mismatch, just handle as generic section.</span>
<span class="gi">+                        self._sections[entry[0].lower()] = \</span>
<span class="gi">+                            self._sections.get(entry[1].lower(),</span>
<span class="gi">+                                               self._parse_custom_generic_section)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse(self) -&gt; None:</span>
<span class="gi">+        self._parsed_lines = self._consume_empty()</span>
<span class="gi">+</span>
<span class="gi">+        if self._name and self._what in (&#39;attribute&#39;, &#39;data&#39;, &#39;property&#39;):</span>
<span class="gi">+            res: list[str] = []</span>
<span class="gi">+            with contextlib.suppress(StopIteration):</span>
<span class="gi">+                res = self._parse_attribute_docstring()</span>
<span class="gi">+</span>
<span class="gi">+            self._parsed_lines.extend(res)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        while self._lines:</span>
<span class="gi">+            if self._is_section_header():</span>
<span class="gi">+                try:</span>
<span class="gi">+                    section = self._consume_section_header()</span>
<span class="gi">+                    self._is_in_section = True</span>
<span class="gi">+                    self._section_indent = self._get_current_indent()</span>
<span class="gi">+                    if _directive_regex.match(section):</span>
<span class="gi">+                        lines = [section, *self._consume_to_next_section()]</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        lines = self._sections[section.lower()](section)</span>
<span class="gi">+                finally:</span>
<span class="gi">+                    self._is_in_section = False</span>
<span class="gi">+                    self._section_indent = 0</span>
<span class="gi">+            else:</span>
<span class="gi">+                if not self._parsed_lines:</span>
<span class="gi">+                    lines = self._consume_contiguous() + self._consume_empty()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    lines = self._consume_to_next_section()</span>
<span class="gi">+            self._parsed_lines.extend(lines)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_admonition(self, admonition: str, section: str) -&gt; list[str]:</span>
<span class="gi">+        # type (str, str) -&gt; List[str]</span>
<span class="gi">+        lines = self._consume_to_next_section()</span>
<span class="gi">+        return self._format_admonition(admonition, lines)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_attribute_docstring(self) -&gt; list[str]:</span>
<span class="gi">+        _type, _desc = self._consume_inline_attribute()</span>
<span class="gi">+        lines = self._format_field(&#39;&#39;, &#39;&#39;, _desc)</span>
<span class="gi">+        if _type:</span>
<span class="gi">+            lines.extend([&#39;&#39;, &#39;:type: %s&#39; % _type])</span>
<span class="gi">+        return lines</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_attributes_section(self, section: str) -&gt; list[str]:</span>
<span class="gi">+        lines = []</span>
<span class="gi">+        for _name, _type, _desc in self._consume_fields():</span>
<span class="gi">+            if not _type:</span>
<span class="gi">+                _type = self._lookup_annotation(_name)</span>
<span class="gi">+            if self._config.napoleon_use_ivar:</span>
<span class="gi">+                field = &#39;:ivar %s: &#39; % _name</span>
<span class="gi">+                lines.extend(self._format_block(field, _desc))</span>
<span class="gi">+                if _type:</span>
<span class="gi">+                    lines.append(f&#39;:vartype {_name}: {_type}&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                lines.append(&#39;.. attribute:: &#39; + _name)</span>
<span class="gi">+                if self._opt:</span>
<span class="gi">+                    if &#39;no-index&#39; in self._opt or &#39;noindex&#39; in self._opt:</span>
<span class="gi">+                        lines.append(&#39;   :no-index:&#39;)</span>
<span class="gi">+                lines.append(&#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+                fields = self._format_field(&#39;&#39;, &#39;&#39;, _desc)</span>
<span class="gi">+                lines.extend(self._indent(fields, 3))</span>
<span class="gi">+                if _type:</span>
<span class="gi">+                    lines.append(&#39;&#39;)</span>
<span class="gi">+                    lines.extend(self._indent([&#39;:type: %s&#39; % _type], 3))</span>
<span class="gi">+                lines.append(&#39;&#39;)</span>
<span class="gi">+        if self._config.napoleon_use_ivar:</span>
<span class="gi">+            lines.append(&#39;&#39;)</span>
<span class="gi">+        return lines</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_examples_section(self, section: str) -&gt; list[str]:</span>
<span class="gi">+        labels = {</span>
<span class="gi">+            &#39;example&#39;: _(&#39;Example&#39;),</span>
<span class="gi">+            &#39;examples&#39;: _(&#39;Examples&#39;),</span>
<span class="gi">+        }</span>
<span class="gi">+        use_admonition = self._config.napoleon_use_admonition_for_examples</span>
<span class="gi">+        label = labels.get(section.lower(), section)</span>
<span class="gi">+        return self._parse_generic_section(label, use_admonition)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_custom_generic_section(self, section: str) -&gt; list[str]:</span>
<span class="gi">+        # for now, no admonition for simple custom sections</span>
<span class="gi">+        return self._parse_generic_section(section, False)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_custom_params_style_section(self, section: str) -&gt; list[str]:</span>
<span class="gi">+        return self._format_fields(section, self._consume_fields())</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_custom_returns_style_section(self, section: str) -&gt; list[str]:</span>
<span class="gi">+        fields = self._consume_returns_section(preprocess_types=True)</span>
<span class="gi">+        return self._format_fields(section, fields)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_usage_section(self, section: str) -&gt; list[str]:</span>
<span class="gi">+        header = [&#39;.. rubric:: Usage:&#39;, &#39;&#39;]</span>
<span class="gi">+        block = [&#39;.. code-block:: python&#39;, &#39;&#39;]</span>
<span class="gi">+        lines = self._consume_usage_section()</span>
<span class="gi">+        lines = self._indent(lines, 3)</span>
<span class="gi">+        return header + block + lines + [&#39;&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_generic_section(self, section: str, use_admonition: bool) -&gt; list[str]:</span>
<span class="gi">+        lines = self._strip_empty(self._consume_to_next_section())</span>
<span class="gi">+        lines = self._dedent(lines)</span>
<span class="gi">+        if use_admonition:</span>
<span class="gi">+            header = &#39;.. admonition:: %s&#39; % section</span>
<span class="gi">+            lines = self._indent(lines, 3)</span>
<span class="gi">+        else:</span>
<span class="gi">+            header = &#39;.. rubric:: %s&#39; % section</span>
<span class="gi">+        if lines:</span>
<span class="gi">+            return [header, &#39;&#39;, *lines, &#39;&#39;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return [header, &#39;&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_keyword_arguments_section(self, section: str) -&gt; list[str]:</span>
<span class="gi">+        fields = self._consume_fields()</span>
<span class="gi">+        if self._config.napoleon_use_keyword:</span>
<span class="gi">+            return self._format_docutils_params(</span>
<span class="gi">+                fields,</span>
<span class="gi">+                field_role=&quot;keyword&quot;,</span>
<span class="gi">+                type_role=&quot;kwtype&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self._format_fields(_(&#39;Keyword Arguments&#39;), fields)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_methods_section(self, section: str) -&gt; list[str]:</span>
<span class="gi">+        lines: list[str] = []</span>
<span class="gi">+        for _name, _type, _desc in self._consume_fields(parse_type=False):</span>
<span class="gi">+            lines.append(&#39;.. method:: %s&#39; % _name)</span>
<span class="gi">+            if self._opt:</span>
<span class="gi">+                if &#39;no-index&#39; in self._opt or &#39;noindex&#39; in self._opt:</span>
<span class="gi">+                    lines.append(&#39;   :no-index:&#39;)</span>
<span class="gi">+            if _desc:</span>
<span class="gi">+                lines.extend([&#39;&#39;, *self._indent(_desc, 3)])</span>
<span class="gi">+            lines.append(&#39;&#39;)</span>
<span class="gi">+        return lines</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_notes_section(self, section: str) -&gt; list[str]:</span>
<span class="gi">+        use_admonition = self._config.napoleon_use_admonition_for_notes</span>
<span class="gi">+        return self._parse_generic_section(_(&#39;Notes&#39;), use_admonition)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_other_parameters_section(self, section: str) -&gt; list[str]:</span>
<span class="gi">+        if self._config.napoleon_use_param:</span>
<span class="gi">+            # Allow to declare multiple parameters at once (ex: x, y: int)</span>
<span class="gi">+            fields = self._consume_fields(multiple=True)</span>
<span class="gi">+            return self._format_docutils_params(fields)</span>
<span class="gi">+        else:</span>
<span class="gi">+            fields = self._consume_fields()</span>
<span class="gi">+            return self._format_fields(_(&#39;Other Parameters&#39;), fields)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_parameters_section(self, section: str) -&gt; list[str]:</span>
<span class="gi">+        if self._config.napoleon_use_param:</span>
<span class="gi">+            # Allow to declare multiple parameters at once (ex: x, y: int)</span>
<span class="gi">+            fields = self._consume_fields(multiple=True)</span>
<span class="gi">+            return self._format_docutils_params(fields)</span>
<span class="gi">+        else:</span>
<span class="gi">+            fields = self._consume_fields()</span>
<span class="gi">+            return self._format_fields(_(&#39;Parameters&#39;), fields)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_raises_section(self, section: str) -&gt; list[str]:</span>
<span class="gi">+        fields = self._consume_fields(parse_type=False, prefer_type=True)</span>
<span class="gi">+        lines: list[str] = []</span>
<span class="gi">+        for _name, _type, _desc in fields:</span>
<span class="gi">+            m = self._name_rgx.match(_type)</span>
<span class="gi">+            if m and m.group(&#39;name&#39;):</span>
<span class="gi">+                _type = m.group(&#39;name&#39;)</span>
<span class="gi">+            elif _xref_regex.match(_type):</span>
<span class="gi">+                pos = _type.find(&#39;`&#39;)</span>
<span class="gi">+                _type = _type[pos + 1:-1]</span>
<span class="gi">+            _type = &#39; &#39; + _type if _type else &#39;&#39;</span>
<span class="gi">+            _desc = self._strip_empty(_desc)</span>
<span class="gi">+            _descs = &#39; &#39; + &#39;\n    &#39;.join(_desc) if any(_desc) else &#39;&#39;</span>
<span class="gi">+            lines.append(f&#39;:raises{_type}:{_descs}&#39;)</span>
<span class="gi">+        if lines:</span>
<span class="gi">+            lines.append(&#39;&#39;)</span>
<span class="gi">+        return lines</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_receives_section(self, section: str) -&gt; list[str]:</span>
<span class="gi">+        if self._config.napoleon_use_param:</span>
<span class="gi">+            # Allow to declare multiple parameters at once (ex: x, y: int)</span>
<span class="gi">+            fields = self._consume_fields(multiple=True)</span>
<span class="gi">+            return self._format_docutils_params(fields)</span>
<span class="gi">+        else:</span>
<span class="gi">+            fields = self._consume_fields()</span>
<span class="gi">+            return self._format_fields(_(&#39;Receives&#39;), fields)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_references_section(self, section: str) -&gt; list[str]:</span>
<span class="gi">+        use_admonition = self._config.napoleon_use_admonition_for_references</span>
<span class="gi">+        return self._parse_generic_section(_(&#39;References&#39;), use_admonition)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_returns_section(self, section: str) -&gt; list[str]:</span>
<span class="gi">+        fields = self._consume_returns_section()</span>
<span class="gi">+        multi = len(fields) &gt; 1</span>
<span class="gi">+        use_rtype = False if multi else self._config.napoleon_use_rtype</span>
<span class="gi">+        lines: list[str] = []</span>
<span class="gi">+</span>
<span class="gi">+        for _name, _type, _desc in fields:</span>
<span class="gi">+            if use_rtype:</span>
<span class="gi">+                field = self._format_field(_name, &#39;&#39;, _desc)</span>
<span class="gi">+            else:</span>
<span class="gi">+                field = self._format_field(_name, _type, _desc)</span>
<span class="gi">+</span>
<span class="gi">+            if multi:</span>
<span class="gi">+                if lines:</span>
<span class="gi">+                    lines.extend(self._format_block(&#39;          * &#39;, field))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    lines.extend(self._format_block(&#39;:returns: * &#39;, field))</span>
<span class="gi">+            else:</span>
<span class="gi">+                if any(field):  # only add :returns: if there&#39;s something to say</span>
<span class="gi">+                    lines.extend(self._format_block(&#39;:returns: &#39;, field))</span>
<span class="gi">+                if _type and use_rtype:</span>
<span class="gi">+                    lines.extend([&#39;:rtype: %s&#39; % _type, &#39;&#39;])</span>
<span class="gi">+        if lines and lines[-1]:</span>
<span class="gi">+            lines.append(&#39;&#39;)</span>
<span class="gi">+        return lines</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_see_also_section(self, section: str) -&gt; list[str]:</span>
<span class="gi">+        return self._parse_admonition(&#39;seealso&#39;, section)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_warns_section(self, section: str) -&gt; list[str]:</span>
<span class="gi">+        return self._format_fields(_(&#39;Warns&#39;), self._consume_fields())</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_yields_section(self, section: str) -&gt; list[str]:</span>
<span class="gi">+        fields = self._consume_returns_section(preprocess_types=True)</span>
<span class="gi">+        return self._format_fields(_(&#39;Yields&#39;), fields)</span>
<span class="gi">+</span>
<span class="gi">+    def _partition_field_on_colon(self, line: str) -&gt; tuple[str, str, str]:</span>
<span class="gi">+        before_colon = []</span>
<span class="gi">+        after_colon = []</span>
<span class="gi">+        colon = &#39;&#39;</span>
<span class="gi">+        found_colon = False</span>
<span class="gi">+        for i, source in enumerate(_xref_or_code_regex.split(line)):</span>
<span class="gi">+            if found_colon:</span>
<span class="gi">+                after_colon.append(source)</span>
<span class="gi">+            else:</span>
<span class="gi">+                m = _single_colon_regex.search(source)</span>
<span class="gi">+                if (i % 2) == 0 and m:</span>
<span class="gi">+                    found_colon = True</span>
<span class="gi">+                    colon = source[m.start(): m.end()]</span>
<span class="gi">+                    before_colon.append(source[:m.start()])</span>
<span class="gi">+                    after_colon.append(source[m.end():])</span>
<span class="gi">+                else:</span>
<span class="gi">+                    before_colon.append(source)</span>
<span class="gi">+</span>
<span class="gi">+        return (&quot;&quot;.join(before_colon).strip(),</span>
<span class="gi">+                colon,</span>
<span class="gi">+                &quot;&quot;.join(after_colon).strip())</span>
<span class="gi">+</span>
<span class="gi">+    def _strip_empty(self, lines: list[str]) -&gt; list[str]:</span>
<span class="gi">+        if lines:</span>
<span class="gi">+            start = -1</span>
<span class="gi">+            for i, line in enumerate(lines):</span>
<span class="gi">+                if line:</span>
<span class="gi">+                    start = i</span>
<span class="gi">+                    break</span>
<span class="gi">+            if start == -1:</span>
<span class="gi">+                lines = []</span>
<span class="gi">+            end = -1</span>
<span class="gi">+            for i in reversed(range(len(lines))):</span>
<span class="gi">+                line = lines[i]</span>
<span class="gi">+                if line:</span>
<span class="gi">+                    end = i</span>
<span class="gi">+                    break</span>
<span class="gi">+            if start &gt; 0 or end + 1 &lt; len(lines):</span>
<span class="gi">+                lines = lines[start:end + 1]</span>
<span class="gi">+        return lines</span>
<span class="gi">+</span>
<span class="gi">+    def _lookup_annotation(self, _name: str) -&gt; str:</span>
<span class="gi">+        if self._config.napoleon_attr_annotations:</span>
<span class="gi">+            if self._what in (&quot;module&quot;, &quot;class&quot;, &quot;exception&quot;) and self._obj:</span>
<span class="gi">+                # cache the class annotations</span>
<span class="gi">+                if not hasattr(self, &quot;_annotations&quot;):</span>
<span class="gi">+                    localns = getattr(self._config, &quot;autodoc_type_aliases&quot;, {})</span>
<span class="gi">+                    localns.update(getattr(</span>
<span class="gi">+                                   self._config, &quot;napoleon_type_aliases&quot;, {},</span>
<span class="gi">+                                   ) or {})</span>
<span class="gi">+                    self._annotations = get_type_hints(self._obj, None, localns)</span>
<span class="gi">+                if _name in self._annotations:</span>
<span class="gi">+                    return stringify_annotation(self._annotations[_name],</span>
<span class="gi">+                                                &#39;fully-qualified-except-typing&#39;)</span>
<span class="gi">+        # No annotation found</span>
<span class="gi">+        return &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _recombine_set_tokens(tokens: list[str]) -&gt; list[str]:</span>
<span class="gi">+    token_queue = collections.deque(tokens)</span>
<span class="gi">+    keywords = (&quot;optional&quot;, &quot;default&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def takewhile_set(tokens: collections.deque[str]) -&gt; Iterator[str]:</span>
<span class="gi">+        open_braces = 0</span>
<span class="gi">+        previous_token = None</span>
<span class="gi">+        while True:</span>
<span class="gi">+            try:</span>
<span class="gi">+                token = tokens.popleft()</span>
<span class="gi">+            except IndexError:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            if token == &quot;, &quot;:</span>
<span class="gi">+                previous_token = token</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if not token.strip():</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if token in keywords:</span>
<span class="gi">+                tokens.appendleft(token)</span>
<span class="gi">+                if previous_token is not None:</span>
<span class="gi">+                    tokens.appendleft(previous_token)</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            if previous_token is not None:</span>
<span class="gi">+                yield previous_token</span>
<span class="gi">+                previous_token = None</span>
<span class="gi">+</span>
<span class="gi">+            if token == &quot;{&quot;:</span>
<span class="gi">+                open_braces += 1</span>
<span class="gi">+            elif token == &quot;}&quot;:</span>
<span class="gi">+                open_braces -= 1</span>
<span class="gi">+</span>
<span class="gi">+            yield token</span>
<span class="gi">+</span>
<span class="gi">+            if open_braces == 0:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+    def combine_set(tokens: collections.deque[str]) -&gt; Iterator[str]:</span>
<span class="gi">+        while True:</span>
<span class="gi">+            try:</span>
<span class="gi">+                token = tokens.popleft()</span>
<span class="gi">+            except IndexError:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            if token == &quot;{&quot;:</span>
<span class="gi">+                tokens.appendleft(&quot;{&quot;)</span>
<span class="gi">+                yield &quot;&quot;.join(takewhile_set(tokens))</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield token</span>
<span class="gi">+</span>
<span class="gi">+    return list(combine_set(token_queue))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _tokenize_type_spec(spec: str) -&gt; list[str]:</span>
<span class="gi">+    def postprocess(item: str) -&gt; list[str]:</span>
<span class="gi">+        if _default_regex.match(item):</span>
<span class="gi">+            default = item[:7]</span>
<span class="gi">+            # can&#39;t be separated by anything other than a single space</span>
<span class="gi">+            # for now</span>
<span class="gi">+            other = item[8:]</span>
<span class="gi">+</span>
<span class="gi">+            return [default, &quot; &quot;, other]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return [item]</span>
<span class="gi">+</span>
<span class="gi">+    tokens = [</span>
<span class="gi">+        item</span>
<span class="gi">+        for raw_token in _token_regex.split(spec)</span>
<span class="gi">+        for item in postprocess(raw_token)</span>
<span class="gi">+        if item</span>
<span class="gi">+    ]</span>
<span class="gi">+    return tokens</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _token_type(token: str, location: str | None = None) -&gt; str:</span>
<span class="gi">+    def is_numeric(token: str) -&gt; bool:</span>
<span class="gi">+        try:</span>
<span class="gi">+            # use complex to make sure every numeric value is detected as literal</span>
<span class="gi">+            complex(token)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            return False</span>
<span class="gi">+        else:</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+    if token.startswith(&quot; &quot;) or token.endswith(&quot; &quot;):</span>
<span class="gi">+        type_ = &quot;delimiter&quot;</span>
<span class="gi">+    elif (</span>
<span class="gi">+            is_numeric(token) or</span>
<span class="gi">+            (token.startswith(&quot;{&quot;) and token.endswith(&quot;}&quot;)) or</span>
<span class="gi">+            (token.startswith(&#39;&quot;&#39;) and token.endswith(&#39;&quot;&#39;)) or</span>
<span class="gi">+            (token.startswith(&quot;&#39;&quot;) and token.endswith(&quot;&#39;&quot;))</span>
<span class="gi">+    ):</span>
<span class="gi">+        type_ = &quot;literal&quot;</span>
<span class="gi">+    elif token.startswith(&quot;{&quot;):</span>
<span class="gi">+        logger.warning(</span>
<span class="gi">+            __(&quot;invalid value set (missing closing brace): %s&quot;),</span>
<span class="gi">+            token,</span>
<span class="gi">+            location=location,</span>
<span class="gi">+        )</span>
<span class="gi">+        type_ = &quot;literal&quot;</span>
<span class="gi">+    elif token.endswith(&quot;}&quot;):</span>
<span class="gi">+        logger.warning(</span>
<span class="gi">+            __(&quot;invalid value set (missing opening brace): %s&quot;),</span>
<span class="gi">+            token,</span>
<span class="gi">+            location=location,</span>
<span class="gi">+        )</span>
<span class="gi">+        type_ = &quot;literal&quot;</span>
<span class="gi">+    elif token.startswith((&quot;&#39;&quot;, &#39;&quot;&#39;)):</span>
<span class="gi">+        logger.warning(</span>
<span class="gi">+            __(&quot;malformed string literal (missing closing quote): %s&quot;),</span>
<span class="gi">+            token,</span>
<span class="gi">+            location=location,</span>
<span class="gi">+        )</span>
<span class="gi">+        type_ = &quot;literal&quot;</span>
<span class="gi">+    elif token.endswith((&quot;&#39;&quot;, &#39;&quot;&#39;)):</span>
<span class="gi">+        logger.warning(</span>
<span class="gi">+            __(&quot;malformed string literal (missing opening quote): %s&quot;),</span>
<span class="gi">+            token,</span>
<span class="gi">+            location=location,</span>
<span class="gi">+        )</span>
<span class="gi">+        type_ = &quot;literal&quot;</span>
<span class="gi">+    elif token in (&quot;optional&quot;, &quot;default&quot;):</span>
<span class="gi">+        # default is not a official keyword (yet) but supported by the</span>
<span class="gi">+        # reference implementation (numpydoc) and widely used</span>
<span class="gi">+        type_ = &quot;control&quot;</span>
<span class="gi">+    elif _xref_regex.match(token):</span>
<span class="gi">+        type_ = &quot;reference&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        type_ = &quot;obj&quot;</span>
<span class="gi">+</span>
<span class="gi">+    return type_</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _convert_numpy_type_spec(</span>
<span class="gi">+    _type: str, location: str | None = None, translations: dict | None = None,</span>
<span class="gi">+) -&gt; str:</span>
<span class="gi">+    if translations is None:</span>
<span class="gi">+        translations = {}</span>
<span class="gi">+</span>
<span class="gi">+    def convert_obj(obj: str, translations: dict[str, str], default_translation: str) -&gt; str:</span>
<span class="gi">+        translation = translations.get(obj, obj)</span>
<span class="gi">+</span>
<span class="gi">+        # use :class: (the default) only if obj is not a standard singleton</span>
<span class="gi">+        if translation in _SINGLETONS and default_translation == &quot;:class:`%s`&quot;:</span>
<span class="gi">+            default_translation = &quot;:obj:`%s`&quot;</span>
<span class="gi">+        elif translation == &quot;...&quot; and default_translation == &quot;:class:`%s`&quot;:</span>
<span class="gi">+            # allow referencing the builtin ...</span>
<span class="gi">+            default_translation = &quot;:obj:`%s &lt;Ellipsis&gt;`&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if _xref_regex.match(translation) is None:</span>
<span class="gi">+            translation = default_translation % translation</span>
<span class="gi">+</span>
<span class="gi">+        return translation</span>
<span class="gi">+</span>
<span class="gi">+    tokens = _tokenize_type_spec(_type)</span>
<span class="gi">+    combined_tokens = _recombine_set_tokens(tokens)</span>
<span class="gi">+    types = [</span>
<span class="gi">+        (token, _token_type(token, location))</span>
<span class="gi">+        for token in combined_tokens</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    converters = {</span>
<span class="gi">+        &quot;literal&quot;: lambda x: &quot;``%s``&quot; % x,</span>
<span class="gi">+        &quot;obj&quot;: lambda x: convert_obj(x, translations, &quot;:class:`%s`&quot;),</span>
<span class="gi">+        &quot;control&quot;: lambda x: &quot;*%s*&quot; % x,</span>
<span class="gi">+        &quot;delimiter&quot;: lambda x: x,</span>
<span class="gi">+        &quot;reference&quot;: lambda x: x,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    converted = &quot;&quot;.join(converters.get(type_)(token)  # type: ignore[misc]</span>
<span class="gi">+                        for token, type_ in types)</span>
<span class="gi">+</span>
<span class="gi">+    return converted</span>


<span class="w"> </span>class NumpyDocstring(GoogleDocstring):
<span class="gu">@@ -312,13 +1158,109 @@ class NumpyDocstring(GoogleDocstring):</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, docstring: (str | list[str]), config: (SphinxConfig |</span>
<span class="gd">-        None)=None, app: (Sphinx | None)=None, what: str=&#39;&#39;, name: str=&#39;&#39;,</span>
<span class="gd">-        obj: Any=None, options: Any=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        docstring: str | list[str],</span>
<span class="gi">+        config: SphinxConfig | None = None,</span>
<span class="gi">+        app: Sphinx | None = None,</span>
<span class="gi">+        what: str = &#39;&#39;,</span>
<span class="gi">+        name: str = &#39;&#39;,</span>
<span class="gi">+        obj: Any = None,</span>
<span class="gi">+        options: Any = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self._directive_sections = [&#39;.. index::&#39;]
<span class="w"> </span>        super().__init__(docstring, config, app, what, name, obj, options)

<span class="gd">-    def _parse_numpydoc_see_also_section(self, content: list[str]) -&gt;list[str]:</span>
<span class="gi">+    def _get_location(self) -&gt; str | None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            filepath = inspect.getfile(self._obj) if self._obj is not None else None</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            filepath = None</span>
<span class="gi">+        name = self._name</span>
<span class="gi">+</span>
<span class="gi">+        if filepath is None and name is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        elif filepath is None:</span>
<span class="gi">+            filepath = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        return f&quot;{filepath}:docstring of {name}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _escape_args_and_kwargs(self, name: str) -&gt; str:</span>
<span class="gi">+        func = super()._escape_args_and_kwargs</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;, &quot; in name:</span>
<span class="gi">+            return &quot;, &quot;.join(map(func, name.split(&quot;, &quot;)))</span>
<span class="gi">+        else:</span>
<span class="gi">+            return func(name)</span>
<span class="gi">+</span>
<span class="gi">+    def _consume_field(self, parse_type: bool = True, prefer_type: bool = False,</span>
<span class="gi">+                       ) -&gt; tuple[str, str, list[str]]:</span>
<span class="gi">+        line = self._lines.next()</span>
<span class="gi">+        if parse_type:</span>
<span class="gi">+            _name, _, _type = self._partition_field_on_colon(line)</span>
<span class="gi">+        else:</span>
<span class="gi">+            _name, _type = line, &#39;&#39;</span>
<span class="gi">+        _name, _type = _name.strip(), _type.strip()</span>
<span class="gi">+        _name = self._escape_args_and_kwargs(_name)</span>
<span class="gi">+</span>
<span class="gi">+        if parse_type and not _type:</span>
<span class="gi">+            _type = self._lookup_annotation(_name)</span>
<span class="gi">+</span>
<span class="gi">+        if prefer_type and not _type:</span>
<span class="gi">+            _type, _name = _name, _type</span>
<span class="gi">+</span>
<span class="gi">+        if self._config.napoleon_preprocess_types:</span>
<span class="gi">+            _type = _convert_numpy_type_spec(</span>
<span class="gi">+                _type,</span>
<span class="gi">+                location=self._get_location(),</span>
<span class="gi">+                translations=self._config.napoleon_type_aliases or {},</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        indent = self._get_indent(line) + 1</span>
<span class="gi">+        _desc = self._dedent(self._consume_indented_block(indent))</span>
<span class="gi">+        _desc = self.__class__(_desc, self._config).lines()</span>
<span class="gi">+        return _name, _type, _desc</span>
<span class="gi">+</span>
<span class="gi">+    def _consume_returns_section(self, preprocess_types: bool = False,</span>
<span class="gi">+                                 ) -&gt; list[tuple[str, str, list[str]]]:</span>
<span class="gi">+        return self._consume_fields(prefer_type=True)</span>
<span class="gi">+</span>
<span class="gi">+    def _consume_section_header(self) -&gt; str:</span>
<span class="gi">+        section = self._lines.next()</span>
<span class="gi">+        if not _directive_regex.match(section):</span>
<span class="gi">+            # Consume the header underline</span>
<span class="gi">+            self._lines.next()</span>
<span class="gi">+        return section</span>
<span class="gi">+</span>
<span class="gi">+    def _is_section_break(self) -&gt; bool:</span>
<span class="gi">+        line1, line2 = self._lines.get(0), self._lines.get(1)</span>
<span class="gi">+        return (not self._lines or</span>
<span class="gi">+                self._is_section_header() or</span>
<span class="gi">+                (line1 == line2 == &#39;&#39;) or</span>
<span class="gi">+                (self._is_in_section and</span>
<span class="gi">+                    line1 and</span>
<span class="gi">+                    not self._is_indented(line1, self._section_indent)))</span>
<span class="gi">+</span>
<span class="gi">+    def _is_section_header(self) -&gt; bool:</span>
<span class="gi">+        section, underline = self._lines.get(0), self._lines.get(1)</span>
<span class="gi">+        section = section.lower()</span>
<span class="gi">+        if section in self._sections and isinstance(underline, str):</span>
<span class="gi">+            return bool(_numpy_section_regex.match(underline))</span>
<span class="gi">+        elif self._directive_sections:</span>
<span class="gi">+            if _directive_regex.match(section):</span>
<span class="gi">+                for directive_section in self._directive_sections:</span>
<span class="gi">+                    if section.startswith(directive_section):</span>
<span class="gi">+                        return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_see_also_section(self, section: str) -&gt; list[str]:</span>
<span class="gi">+        lines = self._consume_to_next_section()</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._parse_numpydoc_see_also_section(lines)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            return self._format_admonition(&#39;seealso&#39;, lines)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_numpydoc_see_also_section(self, content: list[str]) -&gt; list[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Derived from the NumpyDoc implementation of _parse_see_also.

<span class="gu">@@ -330,4 +1272,94 @@ class NumpyDocstring(GoogleDocstring):</span>
<span class="w"> </span>        func_name1, func_name2, :meth:`func_name`, func_name3

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        items: list[tuple[str, list[str], str | None]] = []</span>
<span class="gi">+</span>
<span class="gi">+        def parse_item_name(text: str) -&gt; tuple[str, str | None]:</span>
<span class="gi">+            &quot;&quot;&quot;Match &#39;:role:`name`&#39; or &#39;name&#39;&quot;&quot;&quot;</span>
<span class="gi">+            m = self._name_rgx.match(text)</span>
<span class="gi">+            if m:</span>
<span class="gi">+                g = m.groups()</span>
<span class="gi">+                if g[1] is None:</span>
<span class="gi">+                    return g[3], None</span>
<span class="gi">+                else:</span>
<span class="gi">+                    return g[2], g[1]</span>
<span class="gi">+            raise ValueError(&quot;%s is not a item name&quot; % text)</span>
<span class="gi">+</span>
<span class="gi">+        def push_item(name: str | None, rest: list[str]) -&gt; None:</span>
<span class="gi">+            if not name:</span>
<span class="gi">+                return</span>
<span class="gi">+            name, role = parse_item_name(name)</span>
<span class="gi">+            items.append((name, rest.copy(), role))</span>
<span class="gi">+            rest.clear()</span>
<span class="gi">+</span>
<span class="gi">+        def translate(</span>
<span class="gi">+            func: str, description: list[str], role: str | None,</span>
<span class="gi">+        ) -&gt; tuple[str, list[str], str | None]:</span>
<span class="gi">+            translations = self._config.napoleon_type_aliases</span>
<span class="gi">+            if role is not None or not translations:</span>
<span class="gi">+                return func, description, role</span>
<span class="gi">+</span>
<span class="gi">+            translated = translations.get(func, func)</span>
<span class="gi">+            match = self._name_rgx.match(translated)</span>
<span class="gi">+            if not match:</span>
<span class="gi">+                return translated, description, role</span>
<span class="gi">+</span>
<span class="gi">+            groups = match.groupdict()</span>
<span class="gi">+            role = groups[&quot;role&quot;]</span>
<span class="gi">+            new_func = groups[&quot;name&quot;] or groups[&quot;name2&quot;]</span>
<span class="gi">+</span>
<span class="gi">+            return new_func, description, role</span>
<span class="gi">+</span>
<span class="gi">+        current_func = None</span>
<span class="gi">+        rest: list[str] = []</span>
<span class="gi">+</span>
<span class="gi">+        for line in content:</span>
<span class="gi">+            if not line.strip():</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            m = self._name_rgx.match(line)</span>
<span class="gi">+            if m and line[m.end():].strip().startswith(&#39;:&#39;):</span>
<span class="gi">+                push_item(current_func, rest)</span>
<span class="gi">+                current_func, line = line[:m.end()], line[m.end():]</span>
<span class="gi">+                rest = [line.split(&#39;:&#39;, 1)[1].strip()]</span>
<span class="gi">+                if not rest[0]:</span>
<span class="gi">+                    rest = []</span>
<span class="gi">+            elif not line.startswith(&#39; &#39;):</span>
<span class="gi">+                push_item(current_func, rest)</span>
<span class="gi">+                current_func = None</span>
<span class="gi">+                if &#39;,&#39; in line:</span>
<span class="gi">+                    for func in line.split(&#39;,&#39;):</span>
<span class="gi">+                        if func.strip():</span>
<span class="gi">+                            push_item(func, [])</span>
<span class="gi">+                elif line.strip():</span>
<span class="gi">+                    current_func = line</span>
<span class="gi">+            elif current_func is not None:</span>
<span class="gi">+                rest.append(line.strip())</span>
<span class="gi">+        push_item(current_func, rest)</span>
<span class="gi">+</span>
<span class="gi">+        if not items:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        # apply type aliases</span>
<span class="gi">+        items = list(starmap(translate, items))</span>
<span class="gi">+</span>
<span class="gi">+        lines: list[str] = []</span>
<span class="gi">+        last_had_desc = True</span>
<span class="gi">+        for name, desc, role in items:</span>
<span class="gi">+            if role:</span>
<span class="gi">+                link = f&#39;:{role}:`{name}`&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                link = &#39;:obj:`%s`&#39; % name</span>
<span class="gi">+            if desc or last_had_desc:</span>
<span class="gi">+                lines += [&#39;&#39;]</span>
<span class="gi">+                lines += [link]</span>
<span class="gi">+            else:</span>
<span class="gi">+                lines[-1] += &quot;, %s&quot; % link</span>
<span class="gi">+            if desc:</span>
<span class="gi">+                lines += self._indent([&#39; &#39;.join(desc)])</span>
<span class="gi">+                last_had_desc = True</span>
<span class="gi">+            else:</span>
<span class="gi">+                last_had_desc = False</span>
<span class="gi">+        lines += [&#39;&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        return self._format_admonition(&#39;seealso&#39;, lines)</span>
<span class="gh">diff --git a/sphinx/ext/todo.py b/sphinx/ext/todo.py</span>
<span class="gh">index 423cd2039..ac8e17fd5 100644</span>
<span class="gd">--- a/sphinx/ext/todo.py</span>
<span class="gi">+++ b/sphinx/ext/todo.py</span>
<span class="gu">@@ -4,13 +4,17 @@ Inclusion of todos can be switched of by a configuration variable.</span>
<span class="w"> </span>The todolist directive collects all todos of your project and lists them along
<span class="w"> </span>with a backlink to the original location.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import functools
<span class="w"> </span>import operator
<span class="w"> </span>from typing import TYPE_CHECKING, Any, ClassVar, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.parsers.rst import directives
<span class="w"> </span>from docutils.parsers.rst.directives.admonitions import BaseAdmonition
<span class="gi">+</span>
<span class="w"> </span>import sphinx
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.domains import Domain
<span class="gu">@@ -18,13 +22,16 @@ from sphinx.errors import NoUri</span>
<span class="w"> </span>from sphinx.locale import _, __
<span class="w"> </span>from sphinx.util import logging, texescape
<span class="w"> </span>from sphinx.util.docutils import SphinxDirective, new_document
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.nodes import Element, Node
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata, OptionSpec
<span class="w"> </span>    from sphinx.writers.html5 import HTML5Translator
<span class="w"> </span>    from sphinx.writers.latex import LaTeXTranslator
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="gu">@@ -36,46 +43,211 @@ class todolist(nodes.General, nodes.Element):</span>
<span class="w"> </span>    pass


<span class="gd">-class Todo(BaseAdmonition, SphinxDirective):</span>
<span class="gi">+class Todo(BaseAdmonition, SphinxDirective):  # type: ignore[misc]</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    A todo entry, displayed (if configured) in the form of an admonition.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    node_class = todo_node
<span class="w"> </span>    has_content = True
<span class="w"> </span>    required_arguments = 0
<span class="w"> </span>    optional_arguments = 0
<span class="w"> </span>    final_argument_whitespace = False
<span class="gd">-    option_spec: ClassVar[OptionSpec] = {&#39;class&#39;: directives.class_option,</span>
<span class="gd">-        &#39;name&#39;: directives.unchanged}</span>
<span class="gi">+    option_spec: ClassVar[OptionSpec] = {</span>
<span class="gi">+        &#39;class&#39;: directives.class_option,</span>
<span class="gi">+        &#39;name&#39;: directives.unchanged,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        if not self.options.get(&#39;class&#39;):</span>
<span class="gi">+            self.options[&#39;class&#39;] = [&#39;admonition-todo&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        (todo,) = super().run()</span>
<span class="gi">+        if isinstance(todo, nodes.system_message):</span>
<span class="gi">+            return [todo]</span>
<span class="gi">+        elif isinstance(todo, todo_node):</span>
<span class="gi">+            todo.insert(0, nodes.title(text=_(&#39;Todo&#39;)))</span>
<span class="gi">+            todo[&#39;docname&#39;] = self.env.docname</span>
<span class="gi">+            self.add_name(todo)</span>
<span class="gi">+            self.set_source_info(todo)</span>
<span class="gi">+            self.state.document.note_explicit_target(todo)</span>
<span class="gi">+            return [todo]</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise RuntimeError  # never reached here</span>


<span class="w"> </span>class TodoDomain(Domain):
<span class="w"> </span>    name = &#39;todo&#39;
<span class="w"> </span>    label = &#39;todo&#39;

<span class="gi">+    @property</span>
<span class="gi">+    def todos(self) -&gt; dict[str, list[todo_node]]:</span>
<span class="gi">+        return self.data.setdefault(&#39;todos&#39;, {})</span>
<span class="gi">+</span>
<span class="gi">+    def clear_doc(self, docname: str) -&gt; None:</span>
<span class="gi">+        self.todos.pop(docname, None)</span>
<span class="gi">+</span>
<span class="gi">+    def merge_domaindata(self, docnames: list[str], otherdata: dict[str, Any]) -&gt; None:</span>
<span class="gi">+        for docname in docnames:</span>
<span class="gi">+            self.todos[docname] = otherdata[&#39;todos&#39;][docname]</span>
<span class="gi">+</span>
<span class="gi">+    def process_doc(self, env: BuildEnvironment, docname: str,</span>
<span class="gi">+                    document: nodes.document) -&gt; None:</span>
<span class="gi">+        todos = self.todos.setdefault(docname, [])</span>
<span class="gi">+        for todo in document.findall(todo_node):</span>
<span class="gi">+            env.app.emit(&#39;todo-defined&#39;, todo)</span>
<span class="gi">+            todos.append(todo)</span>
<span class="gi">+</span>
<span class="gi">+            if env.config.todo_emit_warnings:</span>
<span class="gi">+                logger.warning(__(&quot;TODO entry found: %s&quot;), todo[1].astext(),</span>
<span class="gi">+                               location=todo)</span>
<span class="gi">+</span>

<span class="w"> </span>class TodoList(SphinxDirective):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    A list of all todo entries.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    has_content = False
<span class="w"> </span>    required_arguments = 0
<span class="w"> </span>    optional_arguments = 0
<span class="w"> </span>    final_argument_whitespace = False
<span class="w"> </span>    option_spec: ClassVar[OptionSpec] = {}

<span class="gi">+    def run(self) -&gt; list[Node]:</span>
<span class="gi">+        # Simply insert an empty todolist node which will be replaced later</span>
<span class="gi">+        # when process_todo_nodes is called</span>
<span class="gi">+        return [todolist(&#39;&#39;)]</span>

<span class="gd">-class TodoListProcessor:</span>

<span class="gd">-    def __init__(self, app: Sphinx, doctree: nodes.document, docname: str</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+class TodoListProcessor:</span>
<span class="gi">+    def __init__(self, app: Sphinx, doctree: nodes.document, docname: str) -&gt; None:</span>
<span class="w"> </span>        self.builder = app.builder
<span class="w"> </span>        self.config = app.config
<span class="w"> </span>        self.env = app.env
<span class="w"> </span>        self.domain = cast(TodoDomain, app.env.get_domain(&#39;todo&#39;))
<span class="w"> </span>        self.document = new_document(&#39;&#39;)
<span class="gi">+</span>
<span class="w"> </span>        self.process(doctree, docname)

<span class="gd">-    def resolve_reference(self, todo: todo_node, docname: str) -&gt;None:</span>
<span class="gi">+    def process(self, doctree: nodes.document, docname: str) -&gt; None:</span>
<span class="gi">+        todos: list[todo_node] = functools.reduce(</span>
<span class="gi">+            operator.iadd, self.domain.todos.values(), [])</span>
<span class="gi">+        for node in list(doctree.findall(todolist)):</span>
<span class="gi">+            if not self.config.todo_include_todos:</span>
<span class="gi">+                node.parent.remove(node)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if node.get(&#39;ids&#39;):</span>
<span class="gi">+                content: list[Element] = [nodes.target()]</span>
<span class="gi">+            else:</span>
<span class="gi">+                content = []</span>
<span class="gi">+</span>
<span class="gi">+            for todo in todos:</span>
<span class="gi">+                # Create a copy of the todo node</span>
<span class="gi">+                new_todo = todo.deepcopy()</span>
<span class="gi">+                new_todo[&#39;ids&#39;].clear()</span>
<span class="gi">+</span>
<span class="gi">+                self.resolve_reference(new_todo, docname)</span>
<span class="gi">+                content.append(new_todo)</span>
<span class="gi">+</span>
<span class="gi">+                todo_ref = self.create_todo_reference(todo, docname)</span>
<span class="gi">+                content.append(todo_ref)</span>
<span class="gi">+</span>
<span class="gi">+            node.replace_self(content)</span>
<span class="gi">+</span>
<span class="gi">+    def create_todo_reference(self, todo: todo_node, docname: str) -&gt; nodes.paragraph:</span>
<span class="gi">+        if self.config.todo_link_only:</span>
<span class="gi">+            description = _(&#39;&lt;&lt;original entry&gt;&gt;&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            description = (_(&#39;(The &lt;&lt;original entry&gt;&gt; is located in %s, line %d.)&#39;) %</span>
<span class="gi">+                           (todo.source, todo.line))</span>
<span class="gi">+</span>
<span class="gi">+        prefix = description[:description.find(&#39;&lt;&lt;&#39;)]</span>
<span class="gi">+        suffix = description[description.find(&#39;&gt;&gt;&#39;) + 2:]</span>
<span class="gi">+</span>
<span class="gi">+        para = nodes.paragraph(classes=[&#39;todo-source&#39;])</span>
<span class="gi">+        para += nodes.Text(prefix)</span>
<span class="gi">+</span>
<span class="gi">+        # Create a reference</span>
<span class="gi">+        linktext = nodes.emphasis(_(&#39;original entry&#39;), _(&#39;original entry&#39;))</span>
<span class="gi">+        reference = nodes.reference(&#39;&#39;, &#39;&#39;, linktext, internal=True)</span>
<span class="gi">+        try:</span>
<span class="gi">+            reference[&#39;refuri&#39;] = self.builder.get_relative_uri(docname, todo[&#39;docname&#39;])</span>
<span class="gi">+            reference[&#39;refuri&#39;] += &#39;#&#39; + todo[&#39;ids&#39;][0]</span>
<span class="gi">+        except NoUri:</span>
<span class="gi">+            # ignore if no URI can be determined, e.g. for LaTeX output</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        para += reference</span>
<span class="gi">+        para += nodes.Text(suffix)</span>
<span class="gi">+</span>
<span class="gi">+        return para</span>
<span class="gi">+</span>
<span class="gi">+    def resolve_reference(self, todo: todo_node, docname: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Resolve references in the todo content.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for node in todo.findall(addnodes.pending_xref):</span>
<span class="gi">+            if &#39;refdoc&#39; in node:</span>
<span class="gi">+                node[&#39;refdoc&#39;] = docname</span>
<span class="gi">+</span>
<span class="gi">+        # Note: To resolve references, it is needed to wrap it with document node</span>
<span class="gi">+        self.document += todo</span>
<span class="gi">+        self.env.resolve_references(self.document, docname, self.builder)</span>
<span class="gi">+        self.document.remove(todo)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def visit_todo_node(self: HTML5Translator, node: todo_node) -&gt; None:</span>
<span class="gi">+    if self.config.todo_include_todos:</span>
<span class="gi">+        self.visit_admonition(node)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def depart_todo_node(self: HTML5Translator, node: todo_node) -&gt; None:</span>
<span class="gi">+    self.depart_admonition(node)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def latex_visit_todo_node(self: LaTeXTranslator, node: todo_node) -&gt; None:</span>
<span class="gi">+    if self.config.todo_include_todos:</span>
<span class="gi">+        self.body.append(&#39;\n\\begin{sphinxtodo}{&#39;)</span>
<span class="gi">+        self.body.append(self.hypertarget_to(node))</span>
<span class="gi">+</span>
<span class="gi">+        title_node = cast(nodes.title, node[0])</span>
<span class="gi">+        title = texescape.escape(title_node.astext(), self.config.latex_engine)</span>
<span class="gi">+        self.body.append(&#39;%s:}&#39; % title)</span>
<span class="gi">+        self.no_latex_floats += 1</span>
<span class="gi">+        if self.table:</span>
<span class="gi">+            self.table.has_problematic = True</span>
<span class="gi">+        node.pop(0)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def latex_depart_todo_node(self: LaTeXTranslator, node: todo_node) -&gt; None:</span>
<span class="gi">+    self.body.append(&#39;\\end{sphinxtodo}\n&#39;)</span>
<span class="gi">+    self.no_latex_floats -= 1</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_event(&#39;todo-defined&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;todo_include_todos&#39;, False, &#39;html&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;todo_link_only&#39;, False, &#39;html&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;todo_emit_warnings&#39;, False, &#39;html&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    app.add_node(todolist)</span>
<span class="gi">+    app.add_node(todo_node,</span>
<span class="gi">+                 html=(visit_todo_node, depart_todo_node),</span>
<span class="gi">+                 latex=(latex_visit_todo_node, latex_depart_todo_node),</span>
<span class="gi">+                 text=(visit_todo_node, depart_todo_node),</span>
<span class="gi">+                 man=(visit_todo_node, depart_todo_node),</span>
<span class="gi">+                 texinfo=(visit_todo_node, depart_todo_node))</span>
<span class="gi">+</span>
<span class="gi">+    app.add_directive(&#39;todo&#39;, Todo)</span>
<span class="gi">+    app.add_directive(&#39;todolist&#39;, TodoList)</span>
<span class="gi">+    app.add_domain(TodoDomain)</span>
<span class="gi">+    app.connect(&#39;doctree-resolved&#39;, TodoListProcessor)</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: sphinx.__display_version__,</span>
<span class="gi">+        &#39;env_version&#39;: 2,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/ext/viewcode.py b/sphinx/ext/viewcode.py</span>
<span class="gh">index 2fc49bef8..9991cf5d4 100644</span>
<span class="gd">--- a/sphinx/ext/viewcode.py</span>
<span class="gi">+++ b/sphinx/ext/viewcode.py</span>
<span class="gu">@@ -1,13 +1,17 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Add links to module code in Python object descriptions.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import operator
<span class="w"> </span>import posixpath
<span class="w"> </span>import traceback
<span class="w"> </span>from importlib import import_module
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING, Any, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.nodes import Element, Node
<span class="gi">+</span>
<span class="w"> </span>import sphinx
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.builders.html import StandaloneHTMLBuilder
<span class="gu">@@ -18,13 +22,18 @@ from sphinx.util import logging</span>
<span class="w"> </span>from sphinx.util.display import status_iterator
<span class="w"> </span>from sphinx.util.nodes import make_refnode
<span class="w"> </span>from sphinx.util.osutil import _last_modified_time
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Iterable, Iterator
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.builders import Builder
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>OUTPUT_DIRNAME = &#39;_modules&#39;


<span class="gu">@@ -37,16 +46,318 @@ class viewcode_anchor(Element):</span>
<span class="w"> </span>    &quot;&quot;&quot;


<span class="gi">+def _get_full_modname(modname: str, attribute: str) -&gt; str | None:</span>
<span class="gi">+    try:</span>
<span class="gi">+        if modname is None:</span>
<span class="gi">+            # Prevents a TypeError: if the last getattr() call will return None</span>
<span class="gi">+            # then it&#39;s better to return it directly</span>
<span class="gi">+            return None</span>
<span class="gi">+        module = import_module(modname)</span>
<span class="gi">+</span>
<span class="gi">+        # Allow an attribute to have multiple parts and incidentally allow</span>
<span class="gi">+        # repeated .s in the attribute.</span>
<span class="gi">+        value = module</span>
<span class="gi">+        for attr in attribute.split(&#39;.&#39;):</span>
<span class="gi">+            if attr:</span>
<span class="gi">+                value = getattr(value, attr)</span>
<span class="gi">+</span>
<span class="gi">+        return getattr(value, &#39;__module__&#39;, None)</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        # sphinx.ext.viewcode can&#39;t follow class instance attribute</span>
<span class="gi">+        # then AttributeError logging output only verbose mode.</span>
<span class="gi">+        logger.verbose(&quot;Didn&#39;t find %s in %s&quot;, attribute, modname)</span>
<span class="gi">+        return None</span>
<span class="gi">+    except Exception as e:</span>
<span class="gi">+        # sphinx.ext.viewcode follow python domain directives.</span>
<span class="gi">+        # because of that, if there are no real modules exists that specified</span>
<span class="gi">+        # by py:function or other directives, viewcode emits a lot of warnings.</span>
<span class="gi">+        # It should be displayed only verbose mode.</span>
<span class="gi">+        logger.verbose(traceback.format_exc().rstrip())</span>
<span class="gi">+        logger.verbose(&#39;viewcode can\&#39;t import %s, failed with error &quot;%s&quot;&#39;, modname, e)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_supported_builder(builder: Builder) -&gt; bool:</span>
<span class="gi">+    if builder.format != &#39;html&#39;:</span>
<span class="gi">+        return False</span>
<span class="gi">+    if builder.name == &#39;singlehtml&#39;:</span>
<span class="gi">+        return False</span>
<span class="gi">+    return not (builder.name.startswith(&#39;epub&#39;) and not builder.config.viewcode_enable_epub)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def doctree_read(app: Sphinx, doctree: Node) -&gt; None:</span>
<span class="gi">+    env = app.builder.env</span>
<span class="gi">+    if not hasattr(env, &#39;_viewcode_modules&#39;):</span>
<span class="gi">+        env._viewcode_modules = {}  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="gi">+    def has_tag(modname: str, fullname: str, docname: str, refname: str) -&gt; bool:</span>
<span class="gi">+        entry = env._viewcode_modules.get(modname, None)  # type: ignore[attr-defined]</span>
<span class="gi">+        if entry is False:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        code_tags = app.emit_firstresult(&#39;viewcode-find-source&#39;, modname)</span>
<span class="gi">+        if code_tags is None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                analyzer = ModuleAnalyzer.for_module(modname)</span>
<span class="gi">+                analyzer.find_tags()</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                env._viewcode_modules[modname] = False  # type: ignore[attr-defined]</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+            code = analyzer.code</span>
<span class="gi">+            tags = analyzer.tags</span>
<span class="gi">+        else:</span>
<span class="gi">+            code, tags = code_tags</span>
<span class="gi">+</span>
<span class="gi">+        if entry is None or entry[0] != code:</span>
<span class="gi">+            entry = code, tags, {}, refname</span>
<span class="gi">+            env._viewcode_modules[modname] = entry  # type: ignore[attr-defined]</span>
<span class="gi">+        _, tags, used, _ = entry</span>
<span class="gi">+        if fullname in tags:</span>
<span class="gi">+            used[fullname] = docname</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    for objnode in list(doctree.findall(addnodes.desc)):</span>
<span class="gi">+        if objnode.get(&#39;domain&#39;) != &#39;py&#39;:</span>
<span class="gi">+            continue</span>
<span class="gi">+        names: set[str] = set()</span>
<span class="gi">+        for signode in objnode:</span>
<span class="gi">+            if not isinstance(signode, addnodes.desc_signature):</span>
<span class="gi">+                continue</span>
<span class="gi">+            modname = signode.get(&#39;module&#39;)</span>
<span class="gi">+            fullname = signode.get(&#39;fullname&#39;)</span>
<span class="gi">+            refname = modname</span>
<span class="gi">+            if env.config.viewcode_follow_imported_members:</span>
<span class="gi">+                new_modname = app.emit_firstresult(</span>
<span class="gi">+                    &#39;viewcode-follow-imported&#39;, modname, fullname,</span>
<span class="gi">+                )</span>
<span class="gi">+                if not new_modname:</span>
<span class="gi">+                    new_modname = _get_full_modname(modname, fullname)</span>
<span class="gi">+                modname = new_modname</span>
<span class="gi">+            if not modname:</span>
<span class="gi">+                continue</span>
<span class="gi">+            fullname = signode.get(&#39;fullname&#39;)</span>
<span class="gi">+            if not has_tag(modname, fullname, env.docname, refname):</span>
<span class="gi">+                continue</span>
<span class="gi">+            if fullname in names:</span>
<span class="gi">+                # only one link per name, please</span>
<span class="gi">+                continue</span>
<span class="gi">+            names.add(fullname)</span>
<span class="gi">+            pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace(&#39;.&#39;, &#39;/&#39;))</span>
<span class="gi">+            signode += viewcode_anchor(reftarget=pagename, refid=fullname, refdoc=env.docname)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def env_merge_info(app: Sphinx, env: BuildEnvironment, docnames: Iterable[str],</span>
<span class="gi">+                   other: BuildEnvironment) -&gt; None:</span>
<span class="gi">+    if not hasattr(other, &#39;_viewcode_modules&#39;):</span>
<span class="gi">+        return</span>
<span class="gi">+    # create a _viewcode_modules dict on the main environment</span>
<span class="gi">+    if not hasattr(env, &#39;_viewcode_modules&#39;):</span>
<span class="gi">+        env._viewcode_modules = {}  # type: ignore[attr-defined]</span>
<span class="gi">+    # now merge in the information from the subprocess</span>
<span class="gi">+    for modname, entry in other._viewcode_modules.items():</span>
<span class="gi">+        if modname not in env._viewcode_modules:  # type: ignore[attr-defined]</span>
<span class="gi">+            env._viewcode_modules[modname] = entry  # type: ignore[attr-defined]</span>
<span class="gi">+        else:</span>
<span class="gi">+            if env._viewcode_modules[modname]:  # type: ignore[attr-defined]</span>
<span class="gi">+                used = env._viewcode_modules[modname][2]  # type: ignore[attr-defined]</span>
<span class="gi">+                for fullname, docname in entry[2].items():</span>
<span class="gi">+                    if fullname not in used:</span>
<span class="gi">+                        used[fullname] = docname</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def env_purge_doc(app: Sphinx, env: BuildEnvironment, docname: str) -&gt; None:</span>
<span class="gi">+    modules = getattr(env, &#39;_viewcode_modules&#39;, {})</span>
<span class="gi">+</span>
<span class="gi">+    for modname, entry in list(modules.items()):</span>
<span class="gi">+        if entry is False:</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        code, tags, used, refname = entry</span>
<span class="gi">+        for fullname in list(used):</span>
<span class="gi">+            if used[fullname] == docname:</span>
<span class="gi">+                used.pop(fullname)</span>
<span class="gi">+</span>
<span class="gi">+        if len(used) == 0:</span>
<span class="gi">+            modules.pop(modname)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class ViewcodeAnchorTransform(SphinxPostTransform):
<span class="w"> </span>    &quot;&quot;&quot;Convert or remove viewcode_anchor nodes depends on builder.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    default_priority = 100

<span class="gi">+    def run(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        if is_supported_builder(self.app.builder):</span>
<span class="gi">+            self.convert_viewcode_anchors()</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.remove_viewcode_anchors()</span>
<span class="gi">+</span>
<span class="gi">+    def convert_viewcode_anchors(self) -&gt; None:</span>
<span class="gi">+        for node in self.document.findall(viewcode_anchor):</span>
<span class="gi">+            anchor = nodes.inline(&#39;&#39;, _(&#39;[source]&#39;), classes=[&#39;viewcode-link&#39;])</span>
<span class="gi">+            refnode = make_refnode(self.app.builder, node[&#39;refdoc&#39;], node[&#39;reftarget&#39;],</span>
<span class="gi">+                                   node[&#39;refid&#39;], anchor)</span>
<span class="gi">+            node.replace_self(refnode)</span>
<span class="gi">+</span>
<span class="gi">+    def remove_viewcode_anchors(self) -&gt; None:</span>
<span class="gi">+        for node in list(self.document.findall(viewcode_anchor)):</span>
<span class="gi">+            node.parent.remove(node)</span>

<span class="gd">-def get_module_filename(app: Sphinx, modname: str) -&gt;(str | None):</span>
<span class="gi">+</span>
<span class="gi">+def get_module_filename(app: Sphinx, modname: str) -&gt; str | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get module filename for *modname*.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    source_info = app.emit_firstresult(&#39;viewcode-find-source&#39;, modname)</span>
<span class="gi">+    if source_info:</span>
<span class="gi">+        return None</span>
<span class="gi">+    else:</span>
<span class="gi">+        try:</span>
<span class="gi">+            filename, source = ModuleAnalyzer.get_module_source(modname)</span>
<span class="gi">+            return filename</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return None</span>


<span class="gd">-def should_generate_module_page(app: Sphinx, modname: str) -&gt;bool:</span>
<span class="gi">+def should_generate_module_page(app: Sphinx, modname: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check generation of module page is needed.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    module_filename = get_module_filename(app, modname)</span>
<span class="gi">+    if module_filename is None:</span>
<span class="gi">+        # Always (re-)generate module page when module filename is not found.</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    builder = cast(StandaloneHTMLBuilder, app.builder)</span>
<span class="gi">+    basename = modname.replace(&#39;.&#39;, &#39;/&#39;) + builder.out_suffix</span>
<span class="gi">+    page_filename = path.join(app.outdir, &#39;_modules/&#39;, basename)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        if _last_modified_time(module_filename) &lt;= _last_modified_time(page_filename):</span>
<span class="gi">+            # generation is not needed if the HTML page is newer than module file.</span>
<span class="gi">+            return False</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def collect_pages(app: Sphinx) -&gt; Iterator[tuple[str, dict[str, Any], str]]:</span>
<span class="gi">+    env = app.builder.env</span>
<span class="gi">+    if not hasattr(env, &#39;_viewcode_modules&#39;):</span>
<span class="gi">+        return</span>
<span class="gi">+    if not is_supported_builder(app.builder):</span>
<span class="gi">+        return</span>
<span class="gi">+    highlighter = app.builder.highlighter  # type: ignore[attr-defined]</span>
<span class="gi">+    urito = app.builder.get_relative_uri</span>
<span class="gi">+</span>
<span class="gi">+    modnames = set(env._viewcode_modules)</span>
<span class="gi">+</span>
<span class="gi">+    for modname, entry in status_iterator(</span>
<span class="gi">+            sorted(env._viewcode_modules.items()),</span>
<span class="gi">+            __(&#39;highlighting module code... &#39;), &quot;blue&quot;,</span>
<span class="gi">+            len(env._viewcode_modules),</span>
<span class="gi">+            app.verbosity, operator.itemgetter(0)):</span>
<span class="gi">+        if not entry:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if not should_generate_module_page(app, modname):</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        code, tags, used, refname = entry</span>
<span class="gi">+        # construct a page name for the highlighted source</span>
<span class="gi">+        pagename = posixpath.join(OUTPUT_DIRNAME, modname.replace(&#39;.&#39;, &#39;/&#39;))</span>
<span class="gi">+        # highlight the source using the builder&#39;s highlighter</span>
<span class="gi">+        if env.config.highlight_language in {&#39;default&#39;, &#39;none&#39;}:</span>
<span class="gi">+            lexer = env.config.highlight_language</span>
<span class="gi">+        else:</span>
<span class="gi">+            lexer = &#39;python&#39;</span>
<span class="gi">+        linenos = &#39;inline&#39; * env.config.viewcode_line_numbers</span>
<span class="gi">+        highlighted = highlighter.highlight_block(code, lexer, linenos=linenos)</span>
<span class="gi">+        # split the code into lines</span>
<span class="gi">+        lines = highlighted.splitlines()</span>
<span class="gi">+        # split off wrap markup from the first line of the actual code</span>
<span class="gi">+        before, after = lines[0].split(&#39;&lt;pre&gt;&#39;)</span>
<span class="gi">+        lines[0:1] = [before + &#39;&lt;pre&gt;&#39;, after]</span>
<span class="gi">+        # nothing to do for the last line; it always starts with &lt;/pre&gt; anyway</span>
<span class="gi">+        # now that we have code lines (starting at index 1), insert anchors for</span>
<span class="gi">+        # the collected tags (HACK: this only works if the tag boundaries are</span>
<span class="gi">+        # properly nested!)</span>
<span class="gi">+        max_index = len(lines) - 1</span>
<span class="gi">+        link_text = _(&#39;[docs]&#39;)</span>
<span class="gi">+        for name, docname in used.items():</span>
<span class="gi">+            type, start, end = tags[name]</span>
<span class="gi">+            backlink = urito(pagename, docname) + &#39;#&#39; + refname + &#39;.&#39; + name</span>
<span class="gi">+            lines[start] = (f&#39;&lt;div class=&quot;viewcode-block&quot; id=&quot;{name}&quot;&gt;\n&#39;</span>
<span class="gi">+                            f&#39;&lt;a class=&quot;viewcode-back&quot; href=&quot;{backlink}&quot;&gt;{link_text}&lt;/a&gt;\n&#39;</span>
<span class="gi">+                            + lines[start])</span>
<span class="gi">+            lines[min(end, max_index)] += &#39;&lt;/div&gt;\n&#39;</span>
<span class="gi">+</span>
<span class="gi">+        # try to find parents (for submodules)</span>
<span class="gi">+        parents = []</span>
<span class="gi">+        parent = modname</span>
<span class="gi">+        while &#39;.&#39; in parent:</span>
<span class="gi">+            parent = parent.rsplit(&#39;.&#39;, 1)[0]</span>
<span class="gi">+            if parent in modnames:</span>
<span class="gi">+                parents.append({</span>
<span class="gi">+                    &#39;link&#39;: urito(pagename,</span>
<span class="gi">+                                  posixpath.join(OUTPUT_DIRNAME, parent.replace(&#39;.&#39;, &#39;/&#39;))),</span>
<span class="gi">+                    &#39;title&#39;: parent})</span>
<span class="gi">+        parents.append({&#39;link&#39;: urito(pagename, posixpath.join(OUTPUT_DIRNAME, &#39;index&#39;)),</span>
<span class="gi">+                        &#39;title&#39;: _(&#39;Module code&#39;)})</span>
<span class="gi">+        parents.reverse()</span>
<span class="gi">+        # putting it all together</span>
<span class="gi">+        context = {</span>
<span class="gi">+            &#39;parents&#39;: parents,</span>
<span class="gi">+            &#39;title&#39;: modname,</span>
<span class="gi">+            &#39;body&#39;: (_(&#39;&lt;h1&gt;Source code for %s&lt;/h1&gt;&#39;) % modname +</span>
<span class="gi">+                     &#39;\n&#39;.join(lines)),</span>
<span class="gi">+        }</span>
<span class="gi">+        yield (pagename, context, &#39;page.html&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if not modnames:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    html = [&#39;\n&#39;]</span>
<span class="gi">+    # the stack logic is needed for using nested lists for submodules</span>
<span class="gi">+    stack = [&#39;&#39;]</span>
<span class="gi">+    for modname in sorted(modnames):</span>
<span class="gi">+        if modname.startswith(stack[-1]):</span>
<span class="gi">+            stack.append(modname + &#39;.&#39;)</span>
<span class="gi">+            html.append(&#39;&lt;ul&gt;&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            stack.pop()</span>
<span class="gi">+            while not modname.startswith(stack[-1]):</span>
<span class="gi">+                stack.pop()</span>
<span class="gi">+                html.append(&#39;&lt;/ul&gt;&#39;)</span>
<span class="gi">+            stack.append(modname + &#39;.&#39;)</span>
<span class="gi">+        relative_uri = urito(posixpath.join(OUTPUT_DIRNAME, &#39;index&#39;),</span>
<span class="gi">+                             posixpath.join(OUTPUT_DIRNAME, modname.replace(&#39;.&#39;, &#39;/&#39;)))</span>
<span class="gi">+        html.append(f&#39;&lt;li&gt;&lt;a href=&quot;{relative_uri}&quot;&gt;{modname}&lt;/a&gt;&lt;/li&gt;\n&#39;)</span>
<span class="gi">+    html.append(&#39;&lt;/ul&gt;&#39; * (len(stack) - 1))</span>
<span class="gi">+    context = {</span>
<span class="gi">+        &#39;title&#39;: _(&#39;Overview: module code&#39;),</span>
<span class="gi">+        &#39;body&#39;: (_(&#39;&lt;h1&gt;All modules for which code is available&lt;/h1&gt;&#39;) +</span>
<span class="gi">+                 &#39;&#39;.join(html)),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    yield (posixpath.join(OUTPUT_DIRNAME, &#39;index&#39;), context, &#39;page.html&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_config_value(&#39;viewcode_import&#39;, None, &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;viewcode_enable_epub&#39;, False, &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;viewcode_follow_imported_members&#39;, True, &#39;&#39;)</span>
<span class="gi">+    app.add_config_value(&#39;viewcode_line_numbers&#39;, False, &#39;env&#39;, bool)</span>
<span class="gi">+    app.connect(&#39;doctree-read&#39;, doctree_read)</span>
<span class="gi">+    app.connect(&#39;env-merge-info&#39;, env_merge_info)</span>
<span class="gi">+    app.connect(&#39;env-purge-doc&#39;, env_purge_doc)</span>
<span class="gi">+    app.connect(&#39;html-collect-pages&#39;, collect_pages)</span>
<span class="gi">+    # app.add_config_value(&#39;viewcode_include_modules&#39;, [], &#39;env&#39;)</span>
<span class="gi">+    # app.add_config_value(&#39;viewcode_exclude_modules&#39;, [], &#39;env&#39;)</span>
<span class="gi">+    app.add_event(&#39;viewcode-find-source&#39;)</span>
<span class="gi">+    app.add_event(&#39;viewcode-follow-imported&#39;)</span>
<span class="gi">+    app.add_post_transform(ViewcodeAnchorTransform)</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: sphinx.__display_version__,</span>
<span class="gi">+        &#39;env_version&#39;: 1,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/extension.py b/sphinx/extension.py</span>
<span class="gh">index 816225dad..88b9d420a 100644</span>
<span class="gd">--- a/sphinx/extension.py</span>
<span class="gi">+++ b/sphinx/extension.py</span>
<span class="gu">@@ -1,29 +1,42 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Utilities for Sphinx extensions.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from packaging.version import InvalidVersion, Version
<span class="gi">+</span>
<span class="w"> </span>from sphinx.errors import VersionRequirementError
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.util import logging
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.config import Config
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="w"> </span>class Extension:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, name: str, module: Any, **kwargs: Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, name: str, module: Any, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.module = module
<span class="gd">-        self.metadata: ExtensionMetadata = kwargs</span>
<span class="gi">+        self.metadata: ExtensionMetadata = kwargs  # type: ignore[assignment]</span>
<span class="w"> </span>        self.version = kwargs.pop(&#39;version&#39;, &#39;unknown version&#39;)
<span class="gi">+</span>
<span class="gi">+        # The extension supports parallel read or not.  The default value</span>
<span class="gi">+        # is ``None``.  It means the extension does not tell the status.</span>
<span class="gi">+        # It will be warned on parallel reading.</span>
<span class="w"> </span>        self.parallel_read_safe = kwargs.pop(&#39;parallel_read_safe&#39;, None)
<span class="gi">+</span>
<span class="gi">+        # The extension supports parallel write or not.  The default value</span>
<span class="gi">+        # is ``True``.  Sphinx writes parallelly documents even if</span>
<span class="gi">+        # the extension does not tell its status.</span>
<span class="w"> </span>        self.parallel_write_safe = kwargs.pop(&#39;parallel_write_safe&#39;, True)


<span class="gd">-def verify_needs_extensions(app: Sphinx, config: Config) -&gt;None:</span>
<span class="gi">+def verify_needs_extensions(app: Sphinx, config: Config) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check that extensions mentioned in :confval:`needs_extensions` satisfy the version
<span class="w"> </span>    requirement, and warn if an extension is not loaded.

<span class="gu">@@ -32,4 +45,48 @@ def verify_needs_extensions(app: Sphinx, config: Config) -&gt;None:</span>
<span class="w"> </span>    :raises VersionRequirementError: if the version of an extension in
<span class="w"> </span>    :confval:`needs_extension` is unknown or older than the required version.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if config.needs_extensions is None:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    for extname, reqversion in config.needs_extensions.items():</span>
<span class="gi">+        extension = app.extensions.get(extname)</span>
<span class="gi">+        if extension is None:</span>
<span class="gi">+            logger.warning(</span>
<span class="gi">+                __(</span>
<span class="gi">+                    &#39;The %s extension is required by needs_extensions settings, &#39;</span>
<span class="gi">+                    &#39;but it is not loaded.&#39;</span>
<span class="gi">+                ),</span>
<span class="gi">+                extname,</span>
<span class="gi">+            )</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        fulfilled = True</span>
<span class="gi">+        if extension.version == &#39;unknown version&#39;:</span>
<span class="gi">+            fulfilled = False</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                if Version(reqversion) &gt; Version(extension.version):</span>
<span class="gi">+                    fulfilled = False</span>
<span class="gi">+            except InvalidVersion:</span>
<span class="gi">+                if reqversion &gt; extension.version:</span>
<span class="gi">+                    fulfilled = False</span>
<span class="gi">+</span>
<span class="gi">+        if not fulfilled:</span>
<span class="gi">+            raise VersionRequirementError(</span>
<span class="gi">+                __(</span>
<span class="gi">+                    &#39;This project needs the extension %s at least in &#39;</span>
<span class="gi">+                    &#39;version %s and therefore cannot be built with &#39;</span>
<span class="gi">+                    &#39;the loaded version (%s).&#39;</span>
<span class="gi">+                )</span>
<span class="gi">+                % (extname, reqversion, extension.version)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.connect(&#39;config-inited&#39;, verify_needs_extensions, priority=800)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/highlighting.py b/sphinx/highlighting.py</span>
<span class="gh">index bef0da9d0..c7ae15668 100644</span>
<span class="gd">--- a/sphinx/highlighting.py</span>
<span class="gi">+++ b/sphinx/highlighting.py</span>
<span class="gu">@@ -1,69 +1,113 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Highlight code blocks using Pygments.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from functools import partial
<span class="w"> </span>from importlib import import_module
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>import pygments
<span class="w"> </span>from pygments import highlight
<span class="w"> </span>from pygments.filters import ErrorToken
<span class="w"> </span>from pygments.formatters import HtmlFormatter, LatexFormatter
<span class="gd">-from pygments.lexers import CLexer, PythonConsoleLexer, PythonLexer, RstLexer, TextLexer, get_lexer_by_name, guess_lexer</span>
<span class="gi">+from pygments.lexers import (</span>
<span class="gi">+    CLexer,</span>
<span class="gi">+    PythonConsoleLexer,</span>
<span class="gi">+    PythonLexer,</span>
<span class="gi">+    RstLexer,</span>
<span class="gi">+    TextLexer,</span>
<span class="gi">+    get_lexer_by_name,</span>
<span class="gi">+    guess_lexer,</span>
<span class="gi">+)</span>
<span class="w"> </span>from pygments.styles import get_style_by_name
<span class="w"> </span>from pygments.util import ClassNotFound
<span class="gi">+</span>
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.pygments_styles import NoneStyle, SphinxStyle
<span class="w"> </span>from sphinx.util import logging, texescape
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from pygments.formatter import Formatter
<span class="w"> </span>    from pygments.lexer import Lexer
<span class="w"> </span>    from pygments.style import Style
<span class="gi">+</span>
<span class="w"> </span>if tuple(map(int, pygments.__version__.split(&#39;.&#39;)))[:2] &lt; (2, 18):
<span class="gd">-    from pygments.formatter import Formatter</span>
<span class="gd">-    Formatter.__class_getitem__ = classmethod(lambda cls, name: cls)</span>
<span class="gi">+    from pygments.formatter import Formatter  # NoQA: F811</span>
<span class="gi">+</span>
<span class="gi">+    Formatter.__class_getitem__ = classmethod(lambda cls, name: cls)  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gi">+</span>
<span class="w"> </span>lexers: dict[str, Lexer] = {}
<span class="gd">-lexer_classes: dict[str, type[Lexer] | partial[Lexer]] = {&#39;none&#39;: partial(</span>
<span class="gd">-    TextLexer, stripnl=False), &#39;python&#39;: partial(PythonLexer, stripnl=False</span>
<span class="gd">-    ), &#39;pycon&#39;: partial(PythonConsoleLexer, stripnl=False), &#39;rest&#39;: partial</span>
<span class="gd">-    (RstLexer, stripnl=False), &#39;c&#39;: partial(CLexer, stripnl=False)}</span>
<span class="gd">-escape_hl_chars = {ord(&#39;\\&#39;): &#39;\\PYGZbs{}&#39;, ord(&#39;{&#39;): &#39;\\PYGZob{}&#39;, ord(&#39;}&#39;</span>
<span class="gd">-    ): &#39;\\PYGZcb{}&#39;}</span>
<span class="gd">-_LATEX_ADD_STYLES = &quot;&quot;&quot;</span>
<span class="gi">+lexer_classes: dict[str, type[Lexer] | partial[Lexer]] = {</span>
<span class="gi">+    &#39;none&#39;: partial(TextLexer, stripnl=False),</span>
<span class="gi">+    &#39;python&#39;: partial(PythonLexer, stripnl=False),</span>
<span class="gi">+    &#39;pycon&#39;: partial(PythonConsoleLexer, stripnl=False),</span>
<span class="gi">+    &#39;rest&#39;: partial(RstLexer, stripnl=False),</span>
<span class="gi">+    &#39;c&#39;: partial(CLexer, stripnl=False),</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+escape_hl_chars = {</span>
<span class="gi">+    ord(&#39;\\&#39;): &#39;\\PYGZbs{}&#39;,</span>
<span class="gi">+    ord(&#39;{&#39;): &#39;\\PYGZob{}&#39;,</span>
<span class="gi">+    ord(&#39;}&#39;): &#39;\\PYGZcb{}&#39;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+# used if Pygments is available</span>
<span class="gi">+# MEMO: no use of \protected here to avoid having to do hyperref extras,</span>
<span class="gi">+# (if in future code highlighting in sectioning titles is activated):</span>
<span class="gi">+# the definitions here use only robust, protected or chardef tokens,</span>
<span class="gi">+# which are all known to the hyperref re-encoding for bookmarks.</span>
<span class="gi">+# The &quot; is troublesome because we would like to use \text\textquotedbl</span>
<span class="gi">+# but \textquotedbl is *defined to raise an error* (!) if the font</span>
<span class="gi">+# encoding is OT1.  This however could happen from &#39;fontenc&#39; key.</span>
<span class="gi">+# MEMO: the Pygments escapes with \char`\&lt;char&gt; syntax, if the document</span>
<span class="gi">+# uses old OT1 font encoding, work correctly only in monospace font.</span>
<span class="gi">+# MEMO: the Pygmentize output mark-up is always with a {} after.</span>
<span class="gi">+_LATEX_ADD_STYLES = r&quot;&quot;&quot;</span>
<span class="w"> </span>% Sphinx redefinitions
<span class="w"> </span>% Originally to obtain a straight single quote via package textcomp, then
<span class="w"> </span>% to fix problems for the 5.0.0 inline code highlighting (captions!).
<span class="gd">-% The \\text is from amstext, a dependency of sphinx.sty.  It is here only</span>
<span class="gi">+% The \text is from amstext, a dependency of sphinx.sty.  It is here only</span>
<span class="w"> </span>% to avoid build errors if for some reason expansion is in math mode.
<span class="gd">-\\def\\PYGZbs{\\text\\textbackslash}</span>
<span class="gd">-\\def\\PYGZus{\\_}</span>
<span class="gd">-\\def\\PYGZob{\\{}</span>
<span class="gd">-\\def\\PYGZcb{\\}}</span>
<span class="gd">-\\def\\PYGZca{\\text\\textasciicircum}</span>
<span class="gd">-\\def\\PYGZam{\\&amp;}</span>
<span class="gd">-\\def\\PYGZlt{\\text\\textless}</span>
<span class="gd">-\\def\\PYGZgt{\\text\\textgreater}</span>
<span class="gd">-\\def\\PYGZsh{\\#}</span>
<span class="gd">-\\def\\PYGZpc{\\%}</span>
<span class="gd">-\\def\\PYGZdl{\\$}</span>
<span class="gd">-\\def\\PYGZhy{\\sphinxhyphen}% defined in sphinxlatexstyletext.sty</span>
<span class="gd">-\\def\\PYGZsq{\\text\\textquotesingle}</span>
<span class="gd">-\\def\\PYGZdq{&quot;}</span>
<span class="gd">-\\def\\PYGZti{\\text\\textasciitilde}</span>
<span class="gd">-\\makeatletter</span>
<span class="gd">-% use \\protected to allow syntax highlighting in captions</span>
<span class="gd">-\\protected\\def\\PYG#1#2{\\PYG@reset\\PYG@toks#1+\\relax+{\\PYG@do{#2}}}</span>
<span class="gd">-\\makeatother</span>
<span class="gi">+\def\PYGZbs{\text\textbackslash}</span>
<span class="gi">+\def\PYGZus{\_}</span>
<span class="gi">+\def\PYGZob{\{}</span>
<span class="gi">+\def\PYGZcb{\}}</span>
<span class="gi">+\def\PYGZca{\text\textasciicircum}</span>
<span class="gi">+\def\PYGZam{\&amp;}</span>
<span class="gi">+\def\PYGZlt{\text\textless}</span>
<span class="gi">+\def\PYGZgt{\text\textgreater}</span>
<span class="gi">+\def\PYGZsh{\#}</span>
<span class="gi">+\def\PYGZpc{\%}</span>
<span class="gi">+\def\PYGZdl{\$}</span>
<span class="gi">+\def\PYGZhy{\sphinxhyphen}% defined in sphinxlatexstyletext.sty</span>
<span class="gi">+\def\PYGZsq{\text\textquotesingle}</span>
<span class="gi">+\def\PYGZdq{&quot;}</span>
<span class="gi">+\def\PYGZti{\text\textasciitilde}</span>
<span class="gi">+\makeatletter</span>
<span class="gi">+% use \protected to allow syntax highlighting in captions</span>
<span class="gi">+\protected\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+{\PYG@do{#2}}}</span>
<span class="gi">+\makeatother</span>
<span class="w"> </span>&quot;&quot;&quot;


<span class="w"> </span>class PygmentsBridge:
<span class="gi">+    # Set these attributes if you want to have different Pygments formatters</span>
<span class="gi">+    # than the default ones.</span>
<span class="w"> </span>    html_formatter = HtmlFormatter[str]
<span class="w"> </span>    latex_formatter = LatexFormatter[str]

<span class="gd">-    def __init__(self, dest: str=&#39;html&#39;, stylename: str=&#39;sphinx&#39;,</span>
<span class="gd">-        latex_engine: (str | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        dest: str = &#39;html&#39;,</span>
<span class="gi">+        stylename: str = &#39;sphinx&#39;,</span>
<span class="gi">+        latex_engine: str | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.dest = dest
<span class="w"> </span>        self.latex_engine = latex_engine
<span class="gi">+</span>
<span class="w"> </span>        style = self.get_style(stylename)
<span class="w"> </span>        self.formatter_args: dict[str, Any] = {&#39;style&#39;: style}
<span class="w"> </span>        if dest == &#39;html&#39;:
<span class="gu">@@ -71,3 +115,117 @@ class PygmentsBridge:</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self.formatter = self.latex_formatter
<span class="w"> </span>            self.formatter_args[&#39;commandprefix&#39;] = &#39;PYG&#39;
<span class="gi">+</span>
<span class="gi">+    def get_style(self, stylename: str) -&gt; type[Style]:</span>
<span class="gi">+        if not stylename or stylename == &#39;sphinx&#39;:</span>
<span class="gi">+            return SphinxStyle</span>
<span class="gi">+        elif stylename == &#39;none&#39;:</span>
<span class="gi">+            return NoneStyle</span>
<span class="gi">+        elif &#39;.&#39; in stylename:</span>
<span class="gi">+            module, stylename = stylename.rsplit(&#39;.&#39;, 1)</span>
<span class="gi">+            return getattr(import_module(module), stylename)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return get_style_by_name(stylename)</span>
<span class="gi">+</span>
<span class="gi">+    def get_formatter(self, **kwargs: Any) -&gt; Formatter:</span>
<span class="gi">+        kwargs.update(self.formatter_args)</span>
<span class="gi">+        return self.formatter(**kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def get_lexer(</span>
<span class="gi">+        self,</span>
<span class="gi">+        source: str,</span>
<span class="gi">+        lang: str,</span>
<span class="gi">+        opts: dict | None = None,</span>
<span class="gi">+        force: bool = False,</span>
<span class="gi">+        location: Any = None,</span>
<span class="gi">+    ) -&gt; Lexer:</span>
<span class="gi">+        if not opts:</span>
<span class="gi">+            opts = {}</span>
<span class="gi">+</span>
<span class="gi">+        # find out which lexer to use</span>
<span class="gi">+        if lang in {&#39;py&#39;, &#39;python&#39;, &#39;py3&#39;, &#39;python3&#39;, &#39;default&#39;}:</span>
<span class="gi">+            if source.startswith(&#39;&gt;&gt;&gt;&#39;):</span>
<span class="gi">+                # interactive session</span>
<span class="gi">+                lang = &#39;pycon&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                lang = &#39;python&#39;</span>
<span class="gi">+        if lang == &#39;pycon3&#39;:</span>
<span class="gi">+            lang = &#39;pycon&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if lang in lexers:</span>
<span class="gi">+            # just return custom lexers here (without installing raiseonerror filter)</span>
<span class="gi">+            return lexers[lang]</span>
<span class="gi">+        elif lang in lexer_classes:</span>
<span class="gi">+            lexer = lexer_classes[lang](**opts)</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                if lang == &#39;guess&#39;:</span>
<span class="gi">+                    lexer = guess_lexer(source, **opts)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    lexer = get_lexer_by_name(lang, **opts)</span>
<span class="gi">+            except ClassNotFound:</span>
<span class="gi">+                logger.warning(</span>
<span class="gi">+                    __(&#39;Pygments lexer name %r is not known&#39;), lang, location=location</span>
<span class="gi">+                )</span>
<span class="gi">+                lexer = lexer_classes[&#39;none&#39;](**opts)</span>
<span class="gi">+</span>
<span class="gi">+        if not force:</span>
<span class="gi">+            lexer.add_filter(&#39;raiseonerror&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        return lexer</span>
<span class="gi">+</span>
<span class="gi">+    def highlight_block(</span>
<span class="gi">+        self,</span>
<span class="gi">+        source: str,</span>
<span class="gi">+        lang: str,</span>
<span class="gi">+        opts: dict | None = None,</span>
<span class="gi">+        force: bool = False,</span>
<span class="gi">+        location: Any = None,</span>
<span class="gi">+        **kwargs: Any,</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        if not isinstance(source, str):</span>
<span class="gi">+            source = source.decode()</span>
<span class="gi">+</span>
<span class="gi">+        lexer = self.get_lexer(source, lang, opts, force, location)</span>
<span class="gi">+</span>
<span class="gi">+        # highlight via Pygments</span>
<span class="gi">+        formatter = self.get_formatter(**kwargs)</span>
<span class="gi">+        try:</span>
<span class="gi">+            hlsource = highlight(source, lexer, formatter)</span>
<span class="gi">+        except ErrorToken as err:</span>
<span class="gi">+            # this is most probably not the selected language,</span>
<span class="gi">+            # so let it pass un highlighted</span>
<span class="gi">+            if lang == &#39;default&#39;:</span>
<span class="gi">+                lang = &#39;none&#39;  # automatic highlighting failed.</span>
<span class="gi">+            else:</span>
<span class="gi">+                logger.warning(</span>
<span class="gi">+                    __(</span>
<span class="gi">+                        &#39;Lexing literal_block %r as &quot;%s&quot; resulted in an error at token: %r. &#39;</span>
<span class="gi">+                        &#39;Retrying in relaxed mode.&#39;</span>
<span class="gi">+                    ),</span>
<span class="gi">+                    source,</span>
<span class="gi">+                    lang,</span>
<span class="gi">+                    str(err),</span>
<span class="gi">+                    type=&#39;misc&#39;,</span>
<span class="gi">+                    subtype=&#39;highlighting_failure&#39;,</span>
<span class="gi">+                    location=location,</span>
<span class="gi">+                )</span>
<span class="gi">+                if force:</span>
<span class="gi">+                    lang = &#39;none&#39;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    force = True</span>
<span class="gi">+            lexer = self.get_lexer(source, lang, opts, force, location)</span>
<span class="gi">+            hlsource = highlight(source, lexer, formatter)</span>
<span class="gi">+</span>
<span class="gi">+        if self.dest == &#39;html&#39;:</span>
<span class="gi">+            return hlsource</span>
<span class="gi">+        else:</span>
<span class="gi">+            # MEMO: this is done to escape Unicode chars with non-Unicode engines</span>
<span class="gi">+            return texescape.hlescape(hlsource, self.latex_engine)</span>
<span class="gi">+</span>
<span class="gi">+    def get_stylesheet(self) -&gt; str:</span>
<span class="gi">+        formatter = self.get_formatter()</span>
<span class="gi">+        if self.dest == &#39;html&#39;:</span>
<span class="gi">+            return formatter.get_style_defs(&#39;.highlight&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return formatter.get_style_defs() + _LATEX_ADD_STYLES</span>
<span class="gh">diff --git a/sphinx/io.py b/sphinx/io.py</span>
<span class="gh">index 5f18053ac..31d64ca6d 100644</span>
<span class="gd">--- a/sphinx/io.py</span>
<span class="gi">+++ b/sphinx/io.py</span>
<span class="gu">@@ -1,50 +1,91 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Input/Output files&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from docutils.core import Publisher
<span class="w"> </span>from docutils.io import FileInput, Input, NullOutput
<span class="w"> </span>from docutils.readers import standalone
<span class="w"> </span>from docutils.transforms.references import DanglingReferences
<span class="w"> </span>from docutils.writers import UnfilteredWriter
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.transforms import AutoIndexUpgrader, DoctreeReadEvent, SphinxTransformer
<span class="gd">-from sphinx.transforms.i18n import Locale, PreserveTranslatableMessages, RemoveTranslatableInline</span>
<span class="gi">+from sphinx.transforms.i18n import (</span>
<span class="gi">+    Locale,</span>
<span class="gi">+    PreserveTranslatableMessages,</span>
<span class="gi">+    RemoveTranslatableInline,</span>
<span class="gi">+)</span>
<span class="w"> </span>from sphinx.transforms.references import SphinxDomains
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.docutils import LoggingReporter
<span class="w"> </span>from sphinx.versioning import UIDTransform
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils import nodes
<span class="w"> </span>    from docutils.frontend import Values
<span class="w"> </span>    from docutils.parsers import Parser
<span class="w"> </span>    from docutils.transforms import Transform
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="gd">-class SphinxBaseReader(standalone.Reader):</span>
<span class="gi">+class SphinxBaseReader(standalone.Reader):  # type: ignore[misc]</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    A base class of readers for Sphinx.

<span class="w"> </span>    This replaces reporter by Sphinx&#39;s on generating document.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    transforms: list[type[Transform]] = []

<span class="gd">-    def __init__(self, *args: Any, **kwargs: Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        from sphinx.application import Sphinx
<span class="gi">+</span>
<span class="w"> </span>        if len(args) &gt; 0 and isinstance(args[0], Sphinx):
<span class="w"> </span>            self._app = args[0]
<span class="w"> </span>            self._env = self._app.env
<span class="w"> </span>            args = args[1:]
<span class="gi">+</span>
<span class="w"> </span>        super().__init__(*args, **kwargs)

<span class="gd">-    def new_document(self) -&gt;nodes.document:</span>
<span class="gi">+    def setup(self, app: Sphinx) -&gt; None:</span>
<span class="gi">+        self._app = app  # hold application object only for compatibility</span>
<span class="gi">+        self._env = app.env</span>
<span class="gi">+</span>
<span class="gi">+    def get_transforms(self) -&gt; list[type[Transform]]:</span>
<span class="gi">+        transforms = super().get_transforms() + self.transforms</span>
<span class="gi">+</span>
<span class="gi">+        # remove transforms which is not needed for Sphinx</span>
<span class="gi">+        unused = [DanglingReferences]</span>
<span class="gi">+        for transform in unused:</span>
<span class="gi">+            if transform in transforms:</span>
<span class="gi">+                transforms.remove(transform)</span>
<span class="gi">+</span>
<span class="gi">+        return transforms</span>
<span class="gi">+</span>
<span class="gi">+    def new_document(self) -&gt; nodes.document:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Creates a new document object which has a special reporter object good
<span class="w"> </span>        for logging.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        document = super().new_document()</span>
<span class="gi">+        document.__class__ = addnodes.document  # replace the class with patched version</span>
<span class="gi">+</span>
<span class="gi">+        # substitute transformer</span>
<span class="gi">+        document.transformer = SphinxTransformer(document)</span>
<span class="gi">+        document.transformer.set_environment(self.settings.env)</span>
<span class="gi">+</span>
<span class="gi">+        # substitute reporter</span>
<span class="gi">+        reporter = document.reporter</span>
<span class="gi">+        document.reporter = LoggingReporter.from_reporter(reporter)</span>
<span class="gi">+</span>
<span class="gi">+        return document</span>


<span class="w"> </span>class SphinxStandaloneReader(SphinxBaseReader):
<span class="gu">@@ -52,9 +93,27 @@ class SphinxStandaloneReader(SphinxBaseReader):</span>
<span class="w"> </span>    A basic document reader for Sphinx.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def read_source(self, env: BuildEnvironment) -&gt;str:</span>
<span class="gi">+    def setup(self, app: Sphinx) -&gt; None:</span>
<span class="gi">+        self.transforms = self.transforms + app.registry.get_transforms()</span>
<span class="gi">+        super().setup(app)</span>
<span class="gi">+</span>
<span class="gi">+    def read(self, source: Input, parser: Parser, settings: Values) -&gt; nodes.document:  # type: ignore[type-arg]</span>
<span class="gi">+        self.source = source</span>
<span class="gi">+        if not self.parser:  # type: ignore[has-type]</span>
<span class="gi">+            self.parser = parser</span>
<span class="gi">+        self.settings = settings</span>
<span class="gi">+        self.input = self.read_source(settings.env)</span>
<span class="gi">+        self.parse()</span>
<span class="gi">+        return self.document</span>
<span class="gi">+</span>
<span class="gi">+    def read_source(self, env: BuildEnvironment) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Read content from source and do post-process.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        content = self.source.read()</span>
<span class="gi">+</span>
<span class="gi">+        # emit &quot;source-read&quot; event</span>
<span class="gi">+        arg = [content]</span>
<span class="gi">+        env.events.emit(&#39;source-read&#39;, env.docname, arg)</span>
<span class="gi">+        return arg[0]</span>


<span class="w"> </span>class SphinxI18nReader(SphinxBaseReader):
<span class="gu">@@ -66,20 +125,70 @@ class SphinxI18nReader(SphinxBaseReader):</span>
<span class="w"> </span>    Because the translated texts are partial and they don&#39;t have correct line numbers.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-</span>
<span class="gd">-class SphinxDummyWriter(UnfilteredWriter):</span>
<span class="gi">+    def setup(self, app: Sphinx) -&gt; None:</span>
<span class="gi">+        super().setup(app)</span>
<span class="gi">+</span>
<span class="gi">+        self.transforms = self.transforms + app.registry.get_transforms()</span>
<span class="gi">+        unused = [</span>
<span class="gi">+            PreserveTranslatableMessages,</span>
<span class="gi">+            Locale,</span>
<span class="gi">+            RemoveTranslatableInline,</span>
<span class="gi">+            AutoIndexUpgrader,</span>
<span class="gi">+            SphinxDomains,</span>
<span class="gi">+            DoctreeReadEvent,</span>
<span class="gi">+            UIDTransform,</span>
<span class="gi">+        ]</span>
<span class="gi">+        for transform in unused:</span>
<span class="gi">+            if transform in self.transforms:</span>
<span class="gi">+                self.transforms.remove(transform)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class SphinxDummyWriter(UnfilteredWriter):  # type: ignore[misc]</span>
<span class="w"> </span>    &quot;&quot;&quot;Dummy writer module used for generating doctree.&quot;&quot;&quot;
<span class="gd">-    supported = &#39;html&#39;,</span>

<span class="gi">+    supported = (&#39;html&#39;,)  # needed to keep &quot;meta&quot; nodes</span>
<span class="gi">+</span>
<span class="gi">+    def translate(self) -&gt; None:</span>
<span class="gi">+        pass</span>

<span class="gd">-def SphinxDummySourceClass(source: Any, *args: Any, **kwargs: Any) -&gt;Any:</span>
<span class="gi">+</span>
<span class="gi">+def SphinxDummySourceClass(source: Any, *args: Any, **kwargs: Any) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Bypass source object as is to cheat Publisher.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return source</span>


<span class="w"> </span>class SphinxFileInput(FileInput):
<span class="w"> </span>    &quot;&quot;&quot;A basic FileInput for Sphinx.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, *args: Any, **kwargs: Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        kwargs[&#39;error_handler&#39;] = &#39;sphinx&#39;
<span class="w"> </span>        super().__init__(*args, **kwargs)
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def create_publisher(app: Sphinx, filetype: str) -&gt; Publisher:</span>
<span class="gi">+    reader = SphinxStandaloneReader()</span>
<span class="gi">+    reader.setup(app)</span>
<span class="gi">+</span>
<span class="gi">+    parser = app.registry.create_source_parser(app, filetype)</span>
<span class="gi">+    if parser.__class__.__name__ == &#39;CommonMarkParser&#39; and parser.settings_spec == ():</span>
<span class="gi">+        # a workaround for recommonmark</span>
<span class="gi">+        #   If recommonmark.AutoStrictify is enabled, the parser invokes reST parser</span>
<span class="gi">+        #   internally.  But recommonmark-0.4.0 does not provide settings_spec for reST</span>
<span class="gi">+        #   parser.  As a workaround, this copies settings_spec for RSTParser to the</span>
<span class="gi">+        #   CommonMarkParser.</span>
<span class="gi">+        from docutils.parsers.rst import Parser as RSTParser</span>
<span class="gi">+</span>
<span class="gi">+        parser.settings_spec = RSTParser.settings_spec  # type: ignore[misc]</span>
<span class="gi">+</span>
<span class="gi">+    pub = Publisher(</span>
<span class="gi">+        reader=reader,</span>
<span class="gi">+        parser=parser,</span>
<span class="gi">+        writer=SphinxDummyWriter(),</span>
<span class="gi">+        source_class=SphinxFileInput,</span>
<span class="gi">+        destination=NullOutput(),</span>
<span class="gi">+    )</span>
<span class="gi">+    # Propagate exceptions by default when used programmatically:</span>
<span class="gi">+    defaults = {&#39;traceback&#39;: True, **app.env.settings}</span>
<span class="gi">+    # Set default settings</span>
<span class="gi">+    pub.get_settings(**defaults)</span>
<span class="gi">+    return pub</span>
<span class="gh">diff --git a/sphinx/jinja2glue.py b/sphinx/jinja2glue.py</span>
<span class="gh">index 6b3cabe75..0df58b52d 100644</span>
<span class="gd">--- a/sphinx/jinja2glue.py</span>
<span class="gi">+++ b/sphinx/jinja2glue.py</span>
<span class="gu">@@ -1,23 +1,43 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Glue code for the jinja2 templating engine.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>from os import path
<span class="w"> </span>from pprint import pformat
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from jinja2 import BaseLoader, FileSystemLoader, TemplateNotFound
<span class="w"> </span>from jinja2.sandbox import SandboxedEnvironment
<span class="w"> </span>from jinja2.utils import open_if_exists, pass_context
<span class="gi">+</span>
<span class="w"> </span>from sphinx.application import TemplateBridge
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.osutil import _last_modified_time
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Callable, Iterator
<span class="gi">+</span>
<span class="w"> </span>    from jinja2.environment import Environment
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.builders import Builder
<span class="w"> </span>    from sphinx.theming import Theme


<span class="gd">-def _todim(val: (int | str)) -&gt;str:</span>
<span class="gi">+def _tobool(val: str) -&gt; bool:</span>
<span class="gi">+    if isinstance(val, str):</span>
<span class="gi">+        return val.lower() in (&#39;true&#39;, &#39;1&#39;, &#39;yes&#39;, &#39;on&#39;)</span>
<span class="gi">+    return bool(val)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _toint(val: str) -&gt; int:</span>
<span class="gi">+    try:</span>
<span class="gi">+        return int(val)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        return 0</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _todim(val: int | str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Make val a css dimension. In particular the following transformations
<span class="w"> </span>    are performed:
<span class="gu">@@ -28,23 +48,66 @@ def _todim(val: (int | str)) -&gt;str:</span>

<span class="w"> </span>    Everything else is returned unchanged.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if val is None:</span>
<span class="gi">+        return &#39;initial&#39;</span>
<span class="gi">+    elif str(val).isdigit():</span>
<span class="gi">+        return &#39;0&#39; if int(val) == 0 else &#39;%spx&#39; % val</span>
<span class="gi">+    return val  # type: ignore[return-value]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _slice_index(values: list, slices: int) -&gt; Iterator[list]:</span>
<span class="gi">+    seq = values.copy()</span>
<span class="gi">+    length = 0</span>
<span class="gi">+    for value in values:</span>
<span class="gi">+        length += 1 + len(value[1][1])  # count includes subitems</span>
<span class="gi">+    items_per_slice = length // slices</span>
<span class="gi">+    offset = 0</span>
<span class="gi">+    for slice_number in range(slices):</span>
<span class="gi">+        count = 0</span>
<span class="gi">+        start = offset</span>
<span class="gi">+        if slices == slice_number + 1:  # last column</span>
<span class="gi">+            offset = len(seq)  # NoQA: SIM113</span>
<span class="gi">+        else:</span>
<span class="gi">+            for value in values[offset:]:</span>
<span class="gi">+                count += 1 + len(value[1][1])</span>
<span class="gi">+                offset += 1</span>
<span class="gi">+                if count &gt;= items_per_slice:</span>
<span class="gi">+                    break</span>
<span class="gi">+        yield seq[start:offset]</span>


<span class="gd">-def accesskey(context: Any, key: str) -&gt;str:</span>
<span class="gi">+def accesskey(context: Any, key: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Helper to output each access key only once.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &#39;_accesskeys&#39; not in context:</span>
<span class="gi">+        context.vars[&#39;_accesskeys&#39;] = {}</span>
<span class="gi">+    if key and key not in context.vars[&#39;_accesskeys&#39;]:</span>
<span class="gi">+        context.vars[&#39;_accesskeys&#39;][key] = 1</span>
<span class="gi">+        return &#39;accesskey=&quot;%s&quot;&#39; % key</span>
<span class="gi">+    return &#39;&#39;</span>


<span class="w"> </span>class idgen:
<span class="gd">-</span>
<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self.id = 0

<span class="gd">-    def __next__(self) -&gt;int:</span>
<span class="gi">+    def current(self) -&gt; int:</span>
<span class="gi">+        return self.id</span>
<span class="gi">+</span>
<span class="gi">+    def __next__(self) -&gt; int:</span>
<span class="w"> </span>        self.id += 1
<span class="w"> </span>        return self.id
<span class="gd">-    next = __next__</span>
<span class="gi">+</span>
<span class="gi">+    next = __next__  # Python 2/Jinja compatibility</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@pass_context</span>
<span class="gi">+def warning(context: dict, message: str, *args: Any, **kwargs: Any) -&gt; str:</span>
<span class="gi">+    if &#39;pagename&#39; in context:</span>
<span class="gi">+        filename = context.get(&#39;pagename&#39;) + context.get(&#39;file_suffix&#39;, &#39;&#39;)</span>
<span class="gi">+        message = f&#39;in rendering {filename}: {message}&#39;</span>
<span class="gi">+    logger = logging.getLogger(&#39;sphinx.themes&#39;)</span>
<span class="gi">+    logger.warning(message, *args, **kwargs)</span>
<span class="gi">+    return &#39;&#39;  # return empty string not to output any values</span>


<span class="w"> </span>class SphinxFileSystemLoader(FileSystemLoader):
<span class="gu">@@ -53,8 +116,124 @@ class SphinxFileSystemLoader(FileSystemLoader):</span>
<span class="w"> </span>    template names.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def get_source(</span>
<span class="gi">+        self, environment: Environment, template: str</span>
<span class="gi">+    ) -&gt; tuple[str, str, Callable]:</span>
<span class="gi">+        for searchpath in self.searchpath:</span>
<span class="gi">+            filename = path.join(searchpath, template)</span>
<span class="gi">+            f = open_if_exists(filename)</span>
<span class="gi">+            if f is not None:</span>
<span class="gi">+                break</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TemplateNotFound(template)</span>
<span class="gi">+</span>
<span class="gi">+        with f:</span>
<span class="gi">+            contents = f.read().decode(self.encoding)</span>
<span class="gi">+</span>
<span class="gi">+        mtime = _last_modified_time(filename)</span>
<span class="gi">+</span>
<span class="gi">+        def uptodate() -&gt; bool:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return _last_modified_time(filename) == mtime</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+        return contents, filename, uptodate</span>
<span class="gi">+</span>

<span class="w"> </span>class BuiltinTemplateLoader(TemplateBridge, BaseLoader):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Interfaces the rendering environment of jinja2 for use in Sphinx.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    # TemplateBridge interface</span>
<span class="gi">+</span>
<span class="gi">+    def init(</span>
<span class="gi">+        self,</span>
<span class="gi">+        builder: Builder,</span>
<span class="gi">+        theme: Theme | None = None,</span>
<span class="gi">+        dirs: list[str] | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        # create a chain of paths to search</span>
<span class="gi">+        if theme:</span>
<span class="gi">+            # the theme&#39;s own dir and its bases&#39; dirs</span>
<span class="gi">+            pathchain = theme.get_theme_dirs()</span>
<span class="gi">+            # the loader dirs: pathchain + the parent directories for all themes</span>
<span class="gi">+            loaderchain = pathchain + [path.join(p, &#39;..&#39;) for p in pathchain]</span>
<span class="gi">+        elif dirs:</span>
<span class="gi">+            pathchain = list(dirs)</span>
<span class="gi">+            loaderchain = list(dirs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            pathchain = []</span>
<span class="gi">+            loaderchain = []</span>
<span class="gi">+</span>
<span class="gi">+        # prepend explicit template paths</span>
<span class="gi">+        self.templatepathlen = len(builder.config.templates_path)</span>
<span class="gi">+        if builder.config.templates_path:</span>
<span class="gi">+            cfg_templates_path = [</span>
<span class="gi">+                path.join(builder.confdir, tp) for tp in builder.config.templates_path</span>
<span class="gi">+            ]</span>
<span class="gi">+            pathchain[0:0] = cfg_templates_path</span>
<span class="gi">+            loaderchain[0:0] = cfg_templates_path</span>
<span class="gi">+</span>
<span class="gi">+        # store it for use in newest_template_mtime</span>
<span class="gi">+        self.pathchain = pathchain</span>
<span class="gi">+</span>
<span class="gi">+        # make the paths into loaders</span>
<span class="gi">+        self.loaders = [SphinxFileSystemLoader(x) for x in loaderchain]</span>
<span class="gi">+</span>
<span class="gi">+        use_i18n = builder.app.translator is not None</span>
<span class="gi">+        extensions = [&#39;jinja2.ext.i18n&#39;] if use_i18n else []</span>
<span class="gi">+        self.environment = SandboxedEnvironment(loader=self, extensions=extensions)</span>
<span class="gi">+        self.environment.filters[&#39;tobool&#39;] = _tobool</span>
<span class="gi">+        self.environment.filters[&#39;toint&#39;] = _toint</span>
<span class="gi">+        self.environment.filters[&#39;todim&#39;] = _todim</span>
<span class="gi">+        self.environment.filters[&#39;slice_index&#39;] = _slice_index</span>
<span class="gi">+        self.environment.globals[&#39;debug&#39;] = pass_context(pformat)</span>
<span class="gi">+        self.environment.globals[&#39;warning&#39;] = warning</span>
<span class="gi">+        self.environment.globals[&#39;accesskey&#39;] = pass_context(accesskey)</span>
<span class="gi">+        self.environment.globals[&#39;idgen&#39;] = idgen</span>
<span class="gi">+        if use_i18n:</span>
<span class="gi">+            # ``install_gettext_translations`` is injected by the ``jinja2.ext.i18n`` extension</span>
<span class="gi">+            self.environment.install_gettext_translations(  # type: ignore[attr-defined]</span>
<span class="gi">+                builder.app.translator</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def render(self, template: str, context: dict) -&gt; str:  # type: ignore[override]</span>
<span class="gi">+        return self.environment.get_template(template).render(context)</span>
<span class="gi">+</span>
<span class="gi">+    def render_string(self, source: str, context: dict) -&gt; str:</span>
<span class="gi">+        return self.environment.from_string(source).render(context)</span>
<span class="gi">+</span>
<span class="gi">+    def newest_template_mtime(self) -&gt; float:</span>
<span class="gi">+        return self._newest_template_mtime_name()[0]</span>
<span class="gi">+</span>
<span class="gi">+    def newest_template_name(self) -&gt; str:</span>
<span class="gi">+        return self._newest_template_mtime_name()[1]</span>
<span class="gi">+</span>
<span class="gi">+    def _newest_template_mtime_name(self) -&gt; tuple[float, str]:</span>
<span class="gi">+        return max(</span>
<span class="gi">+            (os.stat(os.path.join(root, sfile)).st_mtime_ns / 10**9, sfile)</span>
<span class="gi">+            for dirname in self.pathchain</span>
<span class="gi">+            for root, _dirs, files in os.walk(dirname)</span>
<span class="gi">+            for sfile in files</span>
<span class="gi">+            if sfile.endswith(&#39;.html&#39;)</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    # Loader interface</span>
<span class="gi">+</span>
<span class="gi">+    def get_source(</span>
<span class="gi">+        self, environment: Environment, template: str</span>
<span class="gi">+    ) -&gt; tuple[str, str, Callable]:</span>
<span class="gi">+        loaders = self.loaders</span>
<span class="gi">+        # exclamation mark starts search from theme</span>
<span class="gi">+        if template.startswith(&#39;!&#39;):</span>
<span class="gi">+            loaders = loaders[self.templatepathlen :]</span>
<span class="gi">+            template = template[1:]</span>
<span class="gi">+        for loader in loaders:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return loader.get_source(environment, template)</span>
<span class="gi">+            except TemplateNotFound:</span>
<span class="gi">+                pass</span>
<span class="gi">+        msg = f&#39;{template!r} not found in {self.environment.loader.pathchain}&#39;  # type: ignore[union-attr]</span>
<span class="gi">+        raise TemplateNotFound(msg)</span>
<span class="gh">diff --git a/sphinx/parsers.py b/sphinx/parsers.py</span>
<span class="gh">index a9686d339..cc10ce184 100644</span>
<span class="gd">--- a/sphinx/parsers.py</span>
<span class="gi">+++ b/sphinx/parsers.py</span>
<span class="gu">@@ -1,15 +1,21 @@</span>
<span class="w"> </span>&quot;&quot;&quot;A Base class for additional parsers.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>import docutils.parsers
<span class="w"> </span>import docutils.parsers.rst
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.parsers.rst import states
<span class="w"> </span>from docutils.statemachine import StringList
<span class="w"> </span>from docutils.transforms.universal import SmartQuotes
<span class="gi">+</span>
<span class="w"> </span>from sphinx.util.rst import append_epilog, prepend_prolog
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.transforms import Transform
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.config import Config
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="gu">@@ -24,33 +30,72 @@ class Parser(docutils.parsers.Parser):</span>

<span class="w"> </span>    The subclasses can access sphinx core runtime objects (app, config and env).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    #: The config object</span>
<span class="w"> </span>    config: Config
<span class="gi">+</span>
<span class="gi">+    #: The environment object</span>
<span class="w"> </span>    env: BuildEnvironment

<span class="gd">-    def set_application(self, app: Sphinx) -&gt;None:</span>
<span class="gi">+    def set_application(self, app: Sphinx) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;set_application will be called from Sphinx to set app and other instance variables

<span class="w"> </span>        :param sphinx.application.Sphinx app: Sphinx application object
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._app = app</span>
<span class="gi">+        self.config = app.config</span>
<span class="gi">+        self.env = app.env</span>


<span class="w"> </span>class RSTParser(docutils.parsers.rst.Parser, Parser):
<span class="w"> </span>    &quot;&quot;&quot;A reST parser for Sphinx.&quot;&quot;&quot;

<span class="gd">-    def get_transforms(self) -&gt;list[type[Transform]]:</span>
<span class="gi">+    def get_transforms(self) -&gt; list[type[Transform]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Sphinx&#39;s reST parser replaces a transform class for smart-quotes by its own

<span class="w"> </span>        refs: sphinx.io.SphinxStandaloneReader
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        transforms = super().get_transforms()</span>
<span class="gi">+        transforms.remove(SmartQuotes)</span>
<span class="gi">+        return transforms</span>

<span class="gd">-    def parse(self, inputstring: (str | StringList), document: nodes.document</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def parse(self, inputstring: str | StringList, document: nodes.document) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse text and generate a document tree.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.setup_parse(inputstring, document)  # type: ignore[arg-type]</span>
<span class="gi">+        self.statemachine = states.RSTStateMachine(</span>
<span class="gi">+            state_classes=self.state_classes,</span>
<span class="gi">+            initial_state=self.initial_state,</span>
<span class="gi">+            debug=document.reporter.debug_flag,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # preprocess inputstring</span>
<span class="gi">+        if isinstance(inputstring, str):</span>
<span class="gi">+            lines = docutils.statemachine.string2lines(</span>
<span class="gi">+                inputstring,</span>
<span class="gi">+                tab_width=document.settings.tab_width,</span>
<span class="gi">+                convert_whitespace=True,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            inputlines = StringList(lines, document.current_source)</span>
<span class="gi">+        else:</span>
<span class="gi">+            inputlines = inputstring</span>
<span class="gi">+</span>
<span class="gi">+        self.decorate(inputlines)</span>
<span class="gi">+        self.statemachine.run(inputlines, document, inliner=self.inliner)</span>
<span class="gi">+        self.finish_parse()</span>

<span class="gd">-    def decorate(self, content: StringList) -&gt;None:</span>
<span class="gi">+    def decorate(self, content: StringList) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Preprocess reST content before parsing.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        prepend_prolog(content, self.config.rst_prolog)</span>
<span class="gi">+        append_epilog(content, self.config.rst_epilog)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_source_parser(RSTParser)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/project.py b/sphinx/project.py</span>
<span class="gh">index 7075b88a1..016429993 100644</span>
<span class="gd">--- a/sphinx/project.py</span>
<span class="gi">+++ b/sphinx/project.py</span>
<span class="gu">@@ -1,16 +1,21 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Utility function and classes for Sphinx projects.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import contextlib
<span class="w"> </span>import os
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util._pathlib import _StrPath
<span class="w"> </span>from sphinx.util.matching import get_matching_files
<span class="w"> </span>from sphinx.util.osutil import path_stabilize
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Iterable
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="w"> </span>EXCLUDE_PATHS = [&#39;**/_sources&#39;, &#39;.#*&#39;, &#39;**/.#*&#39;, &#39;*.lproj/**&#39;]

<span class="gu">@@ -18,37 +23,106 @@ EXCLUDE_PATHS = [&#39;**/_sources&#39;, &#39;.#*&#39;, &#39;**/.#*&#39;, &#39;*.lproj/**&#39;]</span>
<span class="w"> </span>class Project:
<span class="w"> </span>    &quot;&quot;&quot;A project is the source code set of the Sphinx document(s).&quot;&quot;&quot;

<span class="gd">-    def __init__(self, srcdir: (str | os.PathLike[str]), source_suffix:</span>
<span class="gd">-        Iterable[str]) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, srcdir: str | os.PathLike[str], source_suffix: Iterable[str]</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        #: Source directory.</span>
<span class="w"> </span>        self.srcdir = _StrPath(srcdir)
<span class="gi">+</span>
<span class="gi">+        #: source_suffix. Same as :confval:`source_suffix`.</span>
<span class="w"> </span>        self.source_suffix = tuple(source_suffix)
<span class="w"> </span>        self._first_source_suffix = next(iter(self.source_suffix), &#39;&#39;)
<span class="gi">+</span>
<span class="gi">+        #: The name of documents belonging to this project.</span>
<span class="w"> </span>        self.docnames: set[str] = set()
<span class="gi">+</span>
<span class="gi">+        # Bijective mapping between docnames and (srcdir relative) paths.</span>
<span class="w"> </span>        self._path_to_docname: dict[Path, str] = {}
<span class="w"> </span>        self._docname_to_path: dict[str, Path] = {}

<span class="gd">-    def restore(self, other: Project) -&gt;None:</span>
<span class="gi">+    def restore(self, other: Project) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Take over a result of last build.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.docnames = other.docnames</span>
<span class="gi">+        self._path_to_docname = other._path_to_docname</span>
<span class="gi">+        self._docname_to_path = other._docname_to_path</span>

<span class="gd">-    def discover(self, exclude_paths: Iterable[str]=(), include_paths:</span>
<span class="gd">-        Iterable[str]=(&#39;**&#39;,)) -&gt;set[str]:</span>
<span class="gi">+    def discover(</span>
<span class="gi">+        self, exclude_paths: Iterable[str] = (), include_paths: Iterable[str] = (&#39;**&#39;,)</span>
<span class="gi">+    ) -&gt; set[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Find all document files in the source directory and put them in
<span class="w"> </span>        :attr:`docnames`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.docnames.clear()</span>
<span class="gi">+        self._path_to_docname.clear()</span>
<span class="gi">+        self._docname_to_path.clear()</span>
<span class="gi">+</span>
<span class="gi">+        for filename in get_matching_files(</span>
<span class="gi">+            self.srcdir,</span>
<span class="gi">+            include_paths,</span>
<span class="gi">+            [*exclude_paths, *EXCLUDE_PATHS],</span>
<span class="gi">+        ):</span>
<span class="gi">+            if docname := self.path2doc(filename):</span>
<span class="gi">+                if docname in self.docnames:</span>
<span class="gi">+                    files = [</span>
<span class="gi">+                        str(f.relative_to(self.srcdir))</span>
<span class="gi">+                        for f in self.srcdir.glob(f&#39;{docname}.*&#39;)</span>
<span class="gi">+                    ]</span>
<span class="gi">+                    logger.warning(</span>
<span class="gi">+                        __(</span>
<span class="gi">+                            &#39;multiple files found for the document &quot;%s&quot;: %s\n&#39;</span>
<span class="gi">+                            &#39;Use %r for the build.&#39;</span>
<span class="gi">+                        ),</span>
<span class="gi">+                        docname,</span>
<span class="gi">+                        &#39;, &#39;.join(files),</span>
<span class="gi">+                        self.doc2path(docname, absolute=True),</span>
<span class="gi">+                        once=True,</span>
<span class="gi">+                    )</span>
<span class="gi">+                elif os.access(self.srcdir / filename, os.R_OK):</span>
<span class="gi">+                    self.docnames.add(docname)</span>
<span class="gi">+                    path = Path(filename)</span>
<span class="gi">+                    self._path_to_docname[path] = docname</span>
<span class="gi">+                    self._docname_to_path[docname] = path</span>
<span class="gi">+                else:</span>
<span class="gi">+                    logger.warning(</span>
<span class="gi">+                        __(&#39;Ignored unreadable document %r.&#39;),</span>
<span class="gi">+                        filename,</span>
<span class="gi">+                        location=docname,</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+        return self.docnames</span>

<span class="gd">-    def path2doc(self, filename: (str | os.PathLike[str])) -&gt;(str | None):</span>
<span class="gi">+    def path2doc(self, filename: str | os.PathLike[str]) -&gt; str | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the docname for the filename if the file is a document.

<span class="w"> </span>        *filename* should be absolute or relative to the source directory.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._path_to_docname[filename]  # type: ignore[index]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            path = Path(filename)</span>
<span class="gi">+            if path.is_absolute():</span>
<span class="gi">+                with contextlib.suppress(ValueError):</span>
<span class="gi">+                    path = path.relative_to(self.srcdir)</span>

<span class="gd">-    def doc2path(self, docname: str, absolute: bool) -&gt;_StrPath:</span>
<span class="gi">+            for suffix in self.source_suffix:</span>
<span class="gi">+                if path.name.endswith(suffix):</span>
<span class="gi">+                    return path_stabilize(path).removesuffix(suffix)</span>
<span class="gi">+</span>
<span class="gi">+            # the file does not have a docname</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    def doc2path(self, docname: str, absolute: bool) -&gt; _StrPath:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the filename for the document name.

<span class="w"> </span>        If *absolute* is True, return as an absolute path.
<span class="w"> </span>        Else, return as a relative path to the source directory.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            filename = self._docname_to_path[docname]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            # Backwards compatibility: the document does not exist</span>
<span class="gi">+            filename = Path(docname + self._first_source_suffix)</span>
<span class="gi">+</span>
<span class="gi">+        if absolute:</span>
<span class="gi">+            return _StrPath(self.srcdir / filename)</span>
<span class="gi">+        return _StrPath(filename)</span>
<span class="gh">diff --git a/sphinx/pycode/ast.py b/sphinx/pycode/ast.py</span>
<span class="gh">index f7da51a16..7ed107f4a 100644</span>
<span class="gd">--- a/sphinx/pycode/ast.py</span>
<span class="gi">+++ b/sphinx/pycode/ast.py</span>
<span class="gu">@@ -1,27 +1,203 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Helpers for AST (Abstract Syntax Tree).&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import ast
<span class="w"> </span>from typing import NoReturn, overload
<span class="gd">-OPERATORS: dict[type[ast.AST], str] = {ast.Add: &#39;+&#39;, ast.And: &#39;and&#39;, ast.</span>
<span class="gd">-    BitAnd: &#39;&amp;&#39;, ast.BitOr: &#39;|&#39;, ast.BitXor: &#39;^&#39;, ast.Div: &#39;/&#39;, ast.</span>
<span class="gd">-    FloorDiv: &#39;//&#39;, ast.Invert: &#39;~&#39;, ast.LShift: &#39;&lt;&lt;&#39;, ast.MatMult: &#39;@&#39;,</span>
<span class="gd">-    ast.Mult: &#39;*&#39;, ast.Mod: &#39;%&#39;, ast.Not: &#39;not&#39;, ast.Pow: &#39;**&#39;, ast.Or:</span>
<span class="gd">-    &#39;or&#39;, ast.RShift: &#39;&gt;&gt;&#39;, ast.Sub: &#39;-&#39;, ast.UAdd: &#39;+&#39;, ast.USub: &#39;-&#39;}</span>
<span class="gi">+</span>
<span class="gi">+OPERATORS: dict[type[ast.AST], str] = {</span>
<span class="gi">+    ast.Add: &quot;+&quot;,</span>
<span class="gi">+    ast.And: &quot;and&quot;,</span>
<span class="gi">+    ast.BitAnd: &quot;&amp;&quot;,</span>
<span class="gi">+    ast.BitOr: &quot;|&quot;,</span>
<span class="gi">+    ast.BitXor: &quot;^&quot;,</span>
<span class="gi">+    ast.Div: &quot;/&quot;,</span>
<span class="gi">+    ast.FloorDiv: &quot;//&quot;,</span>
<span class="gi">+    ast.Invert: &quot;~&quot;,</span>
<span class="gi">+    ast.LShift: &quot;&lt;&lt;&quot;,</span>
<span class="gi">+    ast.MatMult: &quot;@&quot;,</span>
<span class="gi">+    ast.Mult: &quot;*&quot;,</span>
<span class="gi">+    ast.Mod: &quot;%&quot;,</span>
<span class="gi">+    ast.Not: &quot;not&quot;,</span>
<span class="gi">+    ast.Pow: &quot;**&quot;,</span>
<span class="gi">+    ast.Or: &quot;or&quot;,</span>
<span class="gi">+    ast.RShift: &quot;&gt;&gt;&quot;,</span>
<span class="gi">+    ast.Sub: &quot;-&quot;,</span>
<span class="gi">+    ast.UAdd: &quot;+&quot;,</span>
<span class="gi">+    ast.USub: &quot;-&quot;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def unparse(node: None, code: str = &#39;&#39;) -&gt; None:</span>
<span class="gi">+    ...</span>


<span class="gd">-def unparse(node: (ast.AST | None), code: str=&#39;&#39;) -&gt;(str | None):</span>
<span class="gi">+@overload</span>
<span class="gi">+def unparse(node: ast.AST, code: str = &#39;&#39;) -&gt; str:</span>
<span class="gi">+    ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def unparse(node: ast.AST | None, code: str = &#39;&#39;) -&gt; str | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Unparse an AST to string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if node is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    elif isinstance(node, str):</span>
<span class="gi">+        return node</span>
<span class="gi">+    return _UnparseVisitor(code).visit(node)</span>


<span class="gi">+# a greatly cut-down version of `ast._Unparser`</span>
<span class="w"> </span>class _UnparseVisitor(ast.NodeVisitor):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, code: str=&#39;&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, code: str = &#39;&#39;) -&gt; None:</span>
<span class="w"> </span>        self.code = code
<span class="gi">+</span>
<span class="gi">+    def _visit_op(self, node: ast.AST) -&gt; str:</span>
<span class="gi">+        return OPERATORS[node.__class__]</span>
<span class="w"> </span>    for _op in OPERATORS:
<span class="w"> </span>        locals()[f&#39;visit_{_op.__name__}&#39;] = _visit_op

<span class="gd">-    def _visit_arg_with_default(self, arg: ast.arg, default: (ast.AST | None)</span>
<span class="gd">-        ) -&gt;str:</span>
<span class="gi">+    def visit_arg(self, node: ast.arg) -&gt; str:</span>
<span class="gi">+        if node.annotation:</span>
<span class="gi">+            return f&quot;{node.arg}: {self.visit(node.annotation)}&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return node.arg</span>
<span class="gi">+</span>
<span class="gi">+    def _visit_arg_with_default(self, arg: ast.arg, default: ast.AST | None) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Unparse a single argument to a string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        name = self.visit(arg)</span>
<span class="gi">+        if default:</span>
<span class="gi">+            if arg.annotation:</span>
<span class="gi">+                name += &quot; = %s&quot; % self.visit(default)</span>
<span class="gi">+            else:</span>
<span class="gi">+                name += &quot;=%s&quot; % self.visit(default)</span>
<span class="gi">+        return name</span>
<span class="gi">+</span>
<span class="gi">+    def visit_arguments(self, node: ast.arguments) -&gt; str:</span>
<span class="gi">+        defaults: list[ast.expr | None] = list(node.defaults)</span>
<span class="gi">+        positionals = len(node.args)</span>
<span class="gi">+        posonlyargs = len(node.posonlyargs)</span>
<span class="gi">+        positionals += posonlyargs</span>
<span class="gi">+        for _ in range(len(defaults), positionals):</span>
<span class="gi">+            defaults.insert(0, None)</span>
<span class="gi">+</span>
<span class="gi">+        kw_defaults: list[ast.expr | None] = list(node.kw_defaults)</span>
<span class="gi">+        for _ in range(len(kw_defaults), len(node.kwonlyargs)):</span>
<span class="gi">+            kw_defaults.insert(0, None)</span>
<span class="gi">+</span>
<span class="gi">+        args: list[str] = [self._visit_arg_with_default(arg, defaults[i])</span>
<span class="gi">+                           for i, arg in enumerate(node.posonlyargs)]</span>
<span class="gi">+</span>
<span class="gi">+        if node.posonlyargs:</span>
<span class="gi">+            args.append(&#39;/&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        for i, arg in enumerate(node.args):</span>
<span class="gi">+            args.append(self._visit_arg_with_default(arg, defaults[i + posonlyargs]))</span>
<span class="gi">+</span>
<span class="gi">+        if node.vararg:</span>
<span class="gi">+            args.append(&quot;*&quot; + self.visit(node.vararg))</span>
<span class="gi">+</span>
<span class="gi">+        if node.kwonlyargs and not node.vararg:</span>
<span class="gi">+            args.append(&#39;*&#39;)</span>
<span class="gi">+        for i, arg in enumerate(node.kwonlyargs):</span>
<span class="gi">+            args.append(self._visit_arg_with_default(arg, kw_defaults[i]))</span>
<span class="gi">+</span>
<span class="gi">+        if node.kwarg:</span>
<span class="gi">+            args.append(&quot;**&quot; + self.visit(node.kwarg))</span>
<span class="gi">+</span>
<span class="gi">+        return &quot;, &quot;.join(args)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Attribute(self, node: ast.Attribute) -&gt; str:</span>
<span class="gi">+        return f&quot;{self.visit(node.value)}.{node.attr}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def visit_BinOp(self, node: ast.BinOp) -&gt; str:</span>
<span class="gi">+        # Special case ``**`` to not have surrounding spaces.</span>
<span class="gi">+        if isinstance(node.op, ast.Pow):</span>
<span class="gi">+            return &quot;&quot;.join(map(self.visit, (node.left, node.op, node.right)))</span>
<span class="gi">+        return &quot; &quot;.join(map(self.visit, (node.left, node.op, node.right)))</span>
<span class="gi">+</span>
<span class="gi">+    def visit_BoolOp(self, node: ast.BoolOp) -&gt; str:</span>
<span class="gi">+        op = &quot; %s &quot; % self.visit(node.op)</span>
<span class="gi">+        return op.join(self.visit(e) for e in node.values)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Call(self, node: ast.Call) -&gt; str:</span>
<span class="gi">+        args = &#39;, &#39;.join(</span>
<span class="gi">+            [self.visit(e) for e in node.args]</span>
<span class="gi">+            + [f&quot;{k.arg}={self.visit(k.value)}&quot; for k in node.keywords],</span>
<span class="gi">+        )</span>
<span class="gi">+        return f&quot;{self.visit(node.func)}({args})&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Constant(self, node: ast.Constant) -&gt; str:</span>
<span class="gi">+        if node.value is Ellipsis:</span>
<span class="gi">+            return &quot;...&quot;</span>
<span class="gi">+        elif isinstance(node.value, int | float | complex):</span>
<span class="gi">+            if self.code:</span>
<span class="gi">+                return ast.get_source_segment(self.code, node) or repr(node.value)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return repr(node.value)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return repr(node.value)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Dict(self, node: ast.Dict) -&gt; str:</span>
<span class="gi">+        keys = (self.visit(k) for k in node.keys if k is not None)</span>
<span class="gi">+        values = (self.visit(v) for v in node.values)</span>
<span class="gi">+        items = (k + &quot;: &quot; + v for k, v in zip(keys, values, strict=True))</span>
<span class="gi">+        return &quot;{&quot; + &quot;, &quot;.join(items) + &quot;}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Lambda(self, node: ast.Lambda) -&gt; str:</span>
<span class="gi">+        return &quot;lambda %s: ...&quot; % self.visit(node.args)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_List(self, node: ast.List) -&gt; str:</span>
<span class="gi">+        return &quot;[&quot; + &quot;, &quot;.join(self.visit(e) for e in node.elts) + &quot;]&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Name(self, node: ast.Name) -&gt; str:</span>
<span class="gi">+        return node.id</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Set(self, node: ast.Set) -&gt; str:</span>
<span class="gi">+        return &quot;{&quot; + &quot;, &quot;.join(self.visit(e) for e in node.elts) + &quot;}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Slice(self, node: ast.Slice) -&gt; str:</span>
<span class="gi">+        if not node.lower and not node.upper and not node.step:</span>
<span class="gi">+            # Empty slice with default values -&gt; [:]</span>
<span class="gi">+            return &quot;:&quot;</span>
<span class="gi">+</span>
<span class="gi">+        start = self.visit(node.lower) if node.lower else &quot;&quot;</span>
<span class="gi">+        stop = self.visit(node.upper) if node.upper else &quot;&quot;</span>
<span class="gi">+        if not node.step:</span>
<span class="gi">+            # Default step size -&gt; [start:stop]</span>
<span class="gi">+            return f&quot;{start}:{stop}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        step = self.visit(node.step) if node.step else &quot;&quot;</span>
<span class="gi">+        return f&quot;{start}:{stop}:{step}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Subscript(self, node: ast.Subscript) -&gt; str:</span>
<span class="gi">+        def is_simple_tuple(value: ast.expr) -&gt; bool:</span>
<span class="gi">+            return (</span>
<span class="gi">+                isinstance(value, ast.Tuple)</span>
<span class="gi">+                and bool(value.elts)</span>
<span class="gi">+                and not any(isinstance(elt, ast.Starred) for elt in value.elts)</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if is_simple_tuple(node.slice):</span>
<span class="gi">+            elts = &quot;, &quot;.join(self.visit(e)</span>
<span class="gi">+                             for e in node.slice.elts)  # type: ignore[attr-defined]</span>
<span class="gi">+            return f&quot;{self.visit(node.value)}[{elts}]&quot;</span>
<span class="gi">+        return f&quot;{self.visit(node.value)}[{self.visit(node.slice)}]&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def visit_UnaryOp(self, node: ast.UnaryOp) -&gt; str:</span>
<span class="gi">+        # UnaryOp is one of {UAdd, USub, Invert, Not}, which refer to ``+x``,</span>
<span class="gi">+        # ``-x``, ``~x``, and ``not x``. Only Not needs a space.</span>
<span class="gi">+        if isinstance(node.op, ast.Not):</span>
<span class="gi">+            return f&quot;{self.visit(node.op)} {self.visit(node.operand)}&quot;</span>
<span class="gi">+        return f&quot;{self.visit(node.op)}{self.visit(node.operand)}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Tuple(self, node: ast.Tuple) -&gt; str:</span>
<span class="gi">+        if len(node.elts) == 0:</span>
<span class="gi">+            return &quot;()&quot;</span>
<span class="gi">+        elif len(node.elts) == 1:</span>
<span class="gi">+            return &quot;(%s,)&quot; % self.visit(node.elts[0])</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &quot;(&quot; + &quot;, &quot;.join(self.visit(e) for e in node.elts) + &quot;)&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def generic_visit(self, node: ast.AST) -&gt; NoReturn:</span>
<span class="gi">+        raise NotImplementedError(&#39;Unable to parse %s object&#39; % type(node).__name__)</span>
<span class="gh">diff --git a/sphinx/pycode/parser.py b/sphinx/pycode/parser.py</span>
<span class="gh">index 54e6b77c5..18bb99305 100644</span>
<span class="gd">--- a/sphinx/pycode/parser.py</span>
<span class="gi">+++ b/sphinx/pycode/parser.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Utilities parsing and analyzing Python code.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import ast
<span class="w"> </span>import contextlib
<span class="w"> </span>import functools
<span class="gu">@@ -12,18 +14,27 @@ from inspect import Signature</span>
<span class="w"> </span>from token import DEDENT, INDENT, NAME, NEWLINE, NUMBER, OP, STRING
<span class="w"> </span>from tokenize import COMMENT, NL
<span class="w"> </span>from typing import Any
<span class="gi">+</span>
<span class="w"> </span>from sphinx.pycode.ast import unparse as ast_unparse
<span class="gi">+</span>
<span class="w"> </span>comment_re = re.compile(&#39;^\\s*#: ?(.*)\r?\n?$&#39;)
<span class="w"> </span>indent_re = re.compile(&#39;^\\s*$&#39;)
<span class="w"> </span>emptyline_re = re.compile(&#39;^\\s*(#.*)?$&#39;)


<span class="gd">-def get_assign_targets(node: ast.AST) -&gt;list[ast.expr]:</span>
<span class="gi">+def filter_whitespace(code: str) -&gt; str:</span>
<span class="gi">+    return code.replace(&#39;\f&#39;, &#39; &#39;)  # replace FF (form feed) with whitespace</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_assign_targets(node: ast.AST) -&gt; list[ast.expr]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get list of targets from Assign and AnnAssign node.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(node, ast.Assign):</span>
<span class="gi">+        return node.targets</span>
<span class="gi">+    else:</span>
<span class="gi">+        return [node.target]  # type: ignore[attr-defined]</span>


<span class="gd">-def get_lvar_names(node: ast.AST, self: (ast.arg | None)=None) -&gt;list[str]:</span>
<span class="gi">+def get_lvar_names(node: ast.AST, self: ast.arg | None = None) -&gt; list[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert assignment-AST to variable names.

<span class="w"> </span>    This raises `TypeError` if the assignment does not create new variable::
<span class="gu">@@ -32,26 +43,67 @@ def get_lvar_names(node: ast.AST, self: (ast.arg | None)=None) -&gt;list[str]:</span>
<span class="w"> </span>        dic[&quot;bar&quot;] = &#39;baz&#39;
<span class="w"> </span>        # =&gt; TypeError
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if self:</span>
<span class="gi">+        self_id = self.arg</span>
<span class="gi">+</span>
<span class="gi">+    node_name = node.__class__.__name__</span>
<span class="gi">+    if node_name in (&#39;Constant&#39;, &#39;Index&#39;, &#39;Slice&#39;, &#39;Subscript&#39;):</span>
<span class="gi">+        raise TypeError(&#39;%r does not create new variable&#39; % node)</span>
<span class="gi">+    if node_name == &#39;Name&#39;:</span>
<span class="gi">+        if self is None or node.id == self_id:  # type: ignore[attr-defined]</span>
<span class="gi">+            return [node.id]  # type: ignore[attr-defined]</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(&#39;The assignment %r is not instance variable&#39; % node)</span>
<span class="gi">+    elif node_name in (&#39;Tuple&#39;, &#39;List&#39;):</span>
<span class="gi">+        members = []</span>
<span class="gi">+        for elt in node.elts:  # type: ignore[attr-defined]</span>
<span class="gi">+            with contextlib.suppress(TypeError):</span>
<span class="gi">+                members.extend(get_lvar_names(elt, self))</span>
<span class="gi">+</span>
<span class="gi">+        return members</span>
<span class="gi">+    elif node_name == &#39;Attribute&#39;:</span>
<span class="gi">+        if (</span>
<span class="gi">+            node.value.__class__.__name__ == &#39;Name&#39; and  # type: ignore[attr-defined]</span>
<span class="gi">+            self and node.value.id == self_id  # type: ignore[attr-defined]</span>
<span class="gi">+        ):</span>
<span class="gi">+            # instance variable</span>
<span class="gi">+            return [&quot;%s&quot; % get_lvar_names(node.attr, self)[0]]  # type: ignore[attr-defined]</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(&#39;The assignment %r is not instance variable&#39; % node)</span>
<span class="gi">+    elif node_name == &#39;str&#39;:</span>
<span class="gi">+        return [node]  # type: ignore[list-item]</span>
<span class="gi">+    elif node_name == &#39;Starred&#39;:</span>
<span class="gi">+        return get_lvar_names(node.value, self)  # type: ignore[attr-defined]</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise NotImplementedError(&#39;Unexpected node name %r&#39; % node_name)</span>


<span class="gd">-def dedent_docstring(s: str) -&gt;str:</span>
<span class="gi">+def dedent_docstring(s: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Remove common leading indentation from docstring.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def dummy() -&gt; None:</span>
<span class="gi">+        # dummy function to mock `inspect.getdoc`.</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    dummy.__doc__ = s</span>
<span class="gi">+    docstring = inspect.getdoc(dummy)</span>
<span class="gi">+    if docstring:</span>
<span class="gi">+        return docstring.lstrip(&quot;\r\n&quot;).rstrip(&quot;\r\n&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return &quot;&quot;</span>


<span class="w"> </span>class Token:
<span class="w"> </span>    &quot;&quot;&quot;Better token wrapper for tokenize module.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, kind: int, value: Any, start: tuple[int, int], end:</span>
<span class="gd">-        tuple[int, int], source: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, kind: int, value: Any, start: tuple[int, int], end: tuple[int, int],</span>
<span class="gi">+                 source: str) -&gt; None:</span>
<span class="w"> </span>        self.kind = kind
<span class="w"> </span>        self.value = value
<span class="w"> </span>        self.start = start
<span class="w"> </span>        self.end = end
<span class="w"> </span>        self.source = source

<span class="gd">-    def __eq__(self, other: Any) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: Any) -&gt; bool:</span>
<span class="w"> </span>        if isinstance(other, int):
<span class="w"> </span>            return self.kind == other
<span class="w"> </span>        elif isinstance(other, str):
<span class="gu">@@ -63,38 +115,56 @@ class Token:</span>
<span class="w"> </span>        else:
<span class="w"> </span>            raise ValueError(&#39;Unknown value: %r&#39; % other)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;&lt;Token kind={tokenize.tok_name[self.kind]!r} value={self.value.strip()!r}&gt;&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+    def match(self, *conditions: Any) -&gt; bool:</span>
<span class="gi">+        return any(self == candidate for candidate in conditions)</span>

<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&#39;&lt;Token kind={tokenize.tok_name[self.kind]!r} value={self.value.strip()!r}&gt;&#39;</span>

<span class="gd">-class TokenProcessor:</span>

<span class="gd">-    def __init__(self, buffers: list[str]) -&gt;None:</span>
<span class="gi">+class TokenProcessor:</span>
<span class="gi">+    def __init__(self, buffers: list[str]) -&gt; None:</span>
<span class="w"> </span>        lines = iter(buffers)
<span class="w"> </span>        self.buffers = buffers
<span class="gd">-        self.tokens = tokenize.generate_tokens(lambda : next(lines))</span>
<span class="gi">+        self.tokens = tokenize.generate_tokens(lambda: next(lines))</span>
<span class="w"> </span>        self.current: Token | None = None
<span class="w"> </span>        self.previous: Token | None = None

<span class="gd">-    def get_line(self, lineno: int) -&gt;str:</span>
<span class="gi">+    def get_line(self, lineno: int) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns specified line.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.buffers[lineno - 1]</span>

<span class="gd">-    def fetch_token(self) -&gt;(Token | None):</span>
<span class="gi">+    def fetch_token(self) -&gt; Token | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Fetch the next token from source code.

<span class="w"> </span>        Returns ``None`` if sequence finished.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.previous = self.current</span>
<span class="gi">+            self.current = Token(*next(self.tokens))</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            self.current = None</span>
<span class="gi">+</span>
<span class="gi">+        return self.current</span>

<span class="gd">-    def fetch_until(self, condition: Any) -&gt;list[Token]:</span>
<span class="gi">+    def fetch_until(self, condition: Any) -&gt; list[Token]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Fetch tokens until specified token appeared.

<span class="w"> </span>        .. note:: This also handles parenthesis well.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        tokens = []</span>
<span class="gi">+        while current := self.fetch_token():</span>
<span class="gi">+            tokens.append(current)</span>
<span class="gi">+            if current == condition:</span>
<span class="gi">+                break</span>
<span class="gi">+            if current == [OP, &#39;(&#39;]:</span>
<span class="gi">+                tokens += self.fetch_until([OP, &#39;)&#39;])</span>
<span class="gi">+            elif current == [OP, &#39;{&#39;]:</span>
<span class="gi">+                tokens += self.fetch_until([OP, &#39;}&#39;])</span>
<span class="gi">+            elif current == [OP, &#39;[&#39;]:</span>
<span class="gi">+                tokens += self.fetch_until([OP, &#39;]&#39;])</span>
<span class="gi">+</span>
<span class="gi">+        return tokens</span>


<span class="w"> </span>class AfterCommentParser(TokenProcessor):
<span class="gu">@@ -104,23 +174,51 @@ class AfterCommentParser(TokenProcessor):</span>
<span class="w"> </span>    and returns the comment for the variable if one exists.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, lines: list[str]) -&gt;None:</span>
<span class="gi">+    def __init__(self, lines: list[str]) -&gt; None:</span>
<span class="w"> </span>        super().__init__(lines)
<span class="w"> </span>        self.comment: str | None = None

<span class="gd">-    def fetch_rvalue(self) -&gt;list[Token]:</span>
<span class="gi">+    def fetch_rvalue(self) -&gt; list[Token]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Fetch right-hand value of assignment.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def parse(self) -&gt;None:</span>
<span class="gi">+        tokens = []</span>
<span class="gi">+        while current := self.fetch_token():</span>
<span class="gi">+            tokens.append(current)</span>
<span class="gi">+            if current == [OP, &#39;(&#39;]:</span>
<span class="gi">+                tokens += self.fetch_until([OP, &#39;)&#39;])</span>
<span class="gi">+            elif current == [OP, &#39;{&#39;]:</span>
<span class="gi">+                tokens += self.fetch_until([OP, &#39;}&#39;])</span>
<span class="gi">+            elif current == [OP, &#39;[&#39;]:</span>
<span class="gi">+                tokens += self.fetch_until([OP, &#39;]&#39;])</span>
<span class="gi">+            elif current == INDENT:</span>
<span class="gi">+                tokens += self.fetch_until(DEDENT)</span>
<span class="gi">+            elif current == [OP, &#39;;&#39;]:  # NoQA: SIM114</span>
<span class="gi">+                break</span>
<span class="gi">+            elif current and current.kind not in {OP, NAME, NUMBER, STRING}:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        return tokens</span>
<span class="gi">+</span>
<span class="gi">+    def parse(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse the code and obtain comment after assignment.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # skip lvalue (or whole of AnnAssign)</span>
<span class="gi">+        while (tok := self.fetch_token()) and not tok.match([OP, &#39;=&#39;], NEWLINE, COMMENT):</span>
<span class="gi">+            assert tok</span>
<span class="gi">+        assert tok is not None</span>
<span class="gi">+</span>
<span class="gi">+        # skip rvalue (if exists)</span>
<span class="gi">+        if tok == [OP, &#39;=&#39;]:</span>
<span class="gi">+            self.fetch_rvalue()</span>
<span class="gi">+            tok = self.current</span>
<span class="gi">+            assert tok is not None</span>
<span class="gi">+</span>
<span class="gi">+        if tok == COMMENT:</span>
<span class="gi">+            self.comment = tok.value</span>


<span class="w"> </span>class VariableCommentPicker(ast.NodeVisitor):
<span class="w"> </span>    &quot;&quot;&quot;Python source code parser to pick up variable comments.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, buffers: list[str], encoding: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, buffers: list[str], encoding: str) -&gt; None:</span>
<span class="w"> </span>        self.counter = itertools.count()
<span class="w"> </span>        self.buffers = buffers
<span class="w"> </span>        self.encoding = encoding
<span class="gu">@@ -138,60 +236,231 @@ class VariableCommentPicker(ast.NodeVisitor):</span>
<span class="w"> </span>        self.typing_overload: str | None = None
<span class="w"> </span>        super().__init__()

<span class="gd">-    def get_qualname_for(self, name: str) -&gt;(list[str] | None):</span>
<span class="gi">+    def get_qualname_for(self, name: str) -&gt; list[str] | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get qualified name for given object as a list of string(s).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def get_self(self) -&gt;(ast.arg | None):</span>
<span class="gi">+        if self.current_function:</span>
<span class="gi">+            if self.current_classes and self.context[-1] == &quot;__init__&quot;:</span>
<span class="gi">+                # store variable comments inside __init__ method of classes</span>
<span class="gi">+                return self.context[:-1] + [name]</span>
<span class="gi">+            else:</span>
<span class="gi">+                return None</span>
<span class="gi">+        else:</span>
<span class="gi">+            return [*self.context, name]</span>
<span class="gi">+</span>
<span class="gi">+    def add_entry(self, name: str) -&gt; None:</span>
<span class="gi">+        qualname = self.get_qualname_for(name)</span>
<span class="gi">+        if qualname:</span>
<span class="gi">+            self.deforders[&quot;.&quot;.join(qualname)] = next(self.counter)</span>
<span class="gi">+</span>
<span class="gi">+    def add_final_entry(self, name: str) -&gt; None:</span>
<span class="gi">+        qualname = self.get_qualname_for(name)</span>
<span class="gi">+        if qualname:</span>
<span class="gi">+            self.finals.append(&quot;.&quot;.join(qualname))</span>
<span class="gi">+</span>
<span class="gi">+    def add_overload_entry(self, func: ast.FunctionDef) -&gt; None:</span>
<span class="gi">+        # avoid circular import problem</span>
<span class="gi">+        from sphinx.util.inspect import signature_from_ast</span>
<span class="gi">+        qualname = self.get_qualname_for(func.name)</span>
<span class="gi">+        if qualname:</span>
<span class="gi">+            overloads = self.overloads.setdefault(&quot;.&quot;.join(qualname), [])</span>
<span class="gi">+            overloads.append(signature_from_ast(func))</span>
<span class="gi">+</span>
<span class="gi">+    def add_variable_comment(self, name: str, comment: str) -&gt; None:</span>
<span class="gi">+        qualname = self.get_qualname_for(name)</span>
<span class="gi">+        if qualname:</span>
<span class="gi">+            basename = &quot;.&quot;.join(qualname[:-1])</span>
<span class="gi">+            self.comments[(basename, name)] = comment</span>
<span class="gi">+</span>
<span class="gi">+    def add_variable_annotation(self, name: str, annotation: ast.AST) -&gt; None:</span>
<span class="gi">+        qualname = self.get_qualname_for(name)</span>
<span class="gi">+        if qualname:</span>
<span class="gi">+            basename = &quot;.&quot;.join(qualname[:-1])</span>
<span class="gi">+            self.annotations[(basename, name)] = ast_unparse(annotation)</span>
<span class="gi">+</span>
<span class="gi">+    def is_final(self, decorators: list[ast.expr]) -&gt; bool:</span>
<span class="gi">+        final = []</span>
<span class="gi">+        if self.typing:</span>
<span class="gi">+            final.append(&#39;%s.final&#39; % self.typing)</span>
<span class="gi">+        if self.typing_final:</span>
<span class="gi">+            final.append(self.typing_final)</span>
<span class="gi">+</span>
<span class="gi">+        for decorator in decorators:</span>
<span class="gi">+            try:</span>
<span class="gi">+                if ast_unparse(decorator) in final:</span>
<span class="gi">+                    return True</span>
<span class="gi">+            except NotImplementedError:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def is_overload(self, decorators: list[ast.expr]) -&gt; bool:</span>
<span class="gi">+        overload = []</span>
<span class="gi">+        if self.typing:</span>
<span class="gi">+            overload.append(&#39;%s.overload&#39; % self.typing)</span>
<span class="gi">+        if self.typing_overload:</span>
<span class="gi">+            overload.append(self.typing_overload)</span>
<span class="gi">+</span>
<span class="gi">+        for decorator in decorators:</span>
<span class="gi">+            try:</span>
<span class="gi">+                if ast_unparse(decorator) in overload:</span>
<span class="gi">+                    return True</span>
<span class="gi">+            except NotImplementedError:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def get_self(self) -&gt; ast.arg | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the name of the first argument if in a function.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.current_function and self.current_function.args.args:</span>
<span class="gi">+            return self.current_function.args.args[0]</span>
<span class="gi">+        if self.current_function and self.current_function.args.posonlyargs:</span>
<span class="gi">+            return self.current_function.args.posonlyargs[0]</span>
<span class="gi">+        return None</span>

<span class="gd">-    def get_line(self, lineno: int) -&gt;str:</span>
<span class="gi">+    def get_line(self, lineno: int) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns specified line.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.buffers[lineno - 1]</span>

<span class="gd">-    def visit(self, node: ast.AST) -&gt;None:</span>
<span class="gi">+    def visit(self, node: ast.AST) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Updates self.previous to the given node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        super().visit(node)</span>
<span class="gi">+        self.previous = node</span>

<span class="gd">-    def visit_Import(self, node: ast.Import) -&gt;None:</span>
<span class="gi">+    def visit_Import(self, node: ast.Import) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handles Import node and record the order of definitions.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for name in node.names:</span>
<span class="gi">+            self.add_entry(name.asname or name.name)</span>

<span class="gd">-    def visit_ImportFrom(self, node: ast.ImportFrom) -&gt;None:</span>
<span class="gi">+            if name.name == &#39;typing&#39;:</span>
<span class="gi">+                self.typing = name.asname or name.name</span>
<span class="gi">+            elif name.name == &#39;typing.final&#39;:</span>
<span class="gi">+                self.typing_final = name.asname or name.name</span>
<span class="gi">+            elif name.name == &#39;typing.overload&#39;:</span>
<span class="gi">+                self.typing_overload = name.asname or name.name</span>
<span class="gi">+</span>
<span class="gi">+    def visit_ImportFrom(self, node: ast.ImportFrom) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handles Import node and record the order of definitions.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for name in node.names:</span>
<span class="gi">+            self.add_entry(name.asname or name.name)</span>

<span class="gd">-    def visit_Assign(self, node: ast.Assign) -&gt;None:</span>
<span class="gd">-        &quot;&quot;&quot;Handles Assign node and pick up a variable comment.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+            if node.module == &#39;typing&#39; and name.name == &#39;final&#39;:</span>
<span class="gi">+                self.typing_final = name.asname or name.name</span>
<span class="gi">+            elif node.module == &#39;typing&#39; and name.name == &#39;overload&#39;:</span>
<span class="gi">+                self.typing_overload = name.asname or name.name</span>

<span class="gd">-    def visit_AnnAssign(self, node: ast.AnnAssign) -&gt;None:</span>
<span class="gi">+    def visit_Assign(self, node: ast.Assign) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Handles Assign node and pick up a variable comment.&quot;&quot;&quot;</span>
<span class="gi">+        try:</span>
<span class="gi">+            targets = get_assign_targets(node)</span>
<span class="gi">+            varnames: list[str] = functools.reduce(</span>
<span class="gi">+                operator.iadd, [get_lvar_names(t, self=self.get_self()) for t in targets], [])</span>
<span class="gi">+            current_line = self.get_line(node.lineno)</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            return  # this assignment is not new definition!</span>
<span class="gi">+</span>
<span class="gi">+        # record annotation</span>
<span class="gi">+        if hasattr(node, &#39;annotation&#39;) and node.annotation:</span>
<span class="gi">+            for varname in varnames:</span>
<span class="gi">+                self.add_variable_annotation(varname, node.annotation)</span>
<span class="gi">+        elif hasattr(node, &#39;type_comment&#39;) and node.type_comment:</span>
<span class="gi">+            for varname in varnames:</span>
<span class="gi">+                self.add_variable_annotation(</span>
<span class="gi">+                    varname, node.type_comment)  # type: ignore[arg-type]</span>
<span class="gi">+</span>
<span class="gi">+        # check comments after assignment</span>
<span class="gi">+        parser = AfterCommentParser([current_line[node.col_offset:]] +</span>
<span class="gi">+                                    self.buffers[node.lineno:])</span>
<span class="gi">+        parser.parse()</span>
<span class="gi">+        if parser.comment and comment_re.match(parser.comment):</span>
<span class="gi">+            for varname in varnames:</span>
<span class="gi">+                self.add_variable_comment(varname, comment_re.sub(&#39;\\1&#39;, parser.comment))</span>
<span class="gi">+                self.add_entry(varname)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # check comments before assignment</span>
<span class="gi">+        if indent_re.match(current_line[:node.col_offset]):</span>
<span class="gi">+            comment_lines = []</span>
<span class="gi">+            for i in range(node.lineno - 1):</span>
<span class="gi">+                before_line = self.get_line(node.lineno - 1 - i)</span>
<span class="gi">+                if comment_re.match(before_line):</span>
<span class="gi">+                    comment_lines.append(comment_re.sub(&#39;\\1&#39;, before_line))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+            if comment_lines:</span>
<span class="gi">+                comment = dedent_docstring(&#39;\n&#39;.join(reversed(comment_lines)))</span>
<span class="gi">+                for varname in varnames:</span>
<span class="gi">+                    self.add_variable_comment(varname, comment)</span>
<span class="gi">+                    self.add_entry(varname)</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        # not commented (record deforders only)</span>
<span class="gi">+        for varname in varnames:</span>
<span class="gi">+            self.add_entry(varname)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_AnnAssign(self, node: ast.AnnAssign) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handles AnnAssign node and pick up a variable comment.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.visit_Assign(node)  # type: ignore[arg-type]</span>

<span class="gd">-    def visit_Expr(self, node: ast.Expr) -&gt;None:</span>
<span class="gi">+    def visit_Expr(self, node: ast.Expr) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handles Expr node and pick up a comment if string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def visit_Try(self, node: ast.Try) -&gt;None:</span>
<span class="gi">+        if (isinstance(self.previous, ast.Assign | ast.AnnAssign) and</span>
<span class="gi">+                isinstance(node.value, ast.Constant) and isinstance(node.value.value, str)):</span>
<span class="gi">+            try:</span>
<span class="gi">+                targets = get_assign_targets(self.previous)</span>
<span class="gi">+                varnames = get_lvar_names(targets[0], self.get_self())</span>
<span class="gi">+                for varname in varnames:</span>
<span class="gi">+                    if isinstance(node.value.value, str):</span>
<span class="gi">+                        docstring = node.value.value</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        docstring = node.value.value.decode(self.encoding or &#39;utf-8&#39;)</span>
<span class="gi">+</span>
<span class="gi">+                    self.add_variable_comment(varname, dedent_docstring(docstring))</span>
<span class="gi">+                    self.add_entry(varname)</span>
<span class="gi">+            except TypeError:</span>
<span class="gi">+                pass  # this assignment is not new definition!</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Try(self, node: ast.Try) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handles Try node and processes body and else-clause.

<span class="w"> </span>        .. note:: pycode parser ignores objects definition in except-clause.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for subnode in node.body:</span>
<span class="gi">+            self.visit(subnode)</span>
<span class="gi">+        for subnode in node.orelse:</span>
<span class="gi">+            self.visit(subnode)</span>

<span class="gd">-    def visit_ClassDef(self, node: ast.ClassDef) -&gt;None:</span>
<span class="gi">+    def visit_ClassDef(self, node: ast.ClassDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handles ClassDef node and set context.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def visit_FunctionDef(self, node: ast.FunctionDef) -&gt;None:</span>
<span class="gi">+        self.current_classes.append(node.name)</span>
<span class="gi">+        self.add_entry(node.name)</span>
<span class="gi">+        if self.is_final(node.decorator_list):</span>
<span class="gi">+            self.add_final_entry(node.name)</span>
<span class="gi">+        self.context.append(node.name)</span>
<span class="gi">+        self.previous = node</span>
<span class="gi">+        for child in node.body:</span>
<span class="gi">+            self.visit(child)</span>
<span class="gi">+        self.context.pop()</span>
<span class="gi">+        self.current_classes.pop()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_FunctionDef(self, node: ast.FunctionDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handles FunctionDef node and set context.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef) -&gt;None:</span>
<span class="gi">+        if self.current_function is None:</span>
<span class="gi">+            self.add_entry(node.name)  # should be called before setting self.current_function</span>
<span class="gi">+            if self.is_final(node.decorator_list):</span>
<span class="gi">+                self.add_final_entry(node.name)</span>
<span class="gi">+            if self.is_overload(node.decorator_list):</span>
<span class="gi">+                self.add_overload_entry(node)</span>
<span class="gi">+            self.context.append(node.name)</span>
<span class="gi">+            self.current_function = node</span>
<span class="gi">+            for child in node.body:</span>
<span class="gi">+                self.visit(child)</span>
<span class="gi">+            self.context.pop()</span>
<span class="gi">+            self.current_function = None</span>
<span class="gi">+</span>
<span class="gi">+    def visit_AsyncFunctionDef(self, node: ast.AsyncFunctionDef) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Handles AsyncFunctionDef node and set context.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.visit_FunctionDef(node)  # type: ignore[arg-type]</span>


<span class="w"> </span>class DefinitionFinder(TokenProcessor):
<span class="gu">@@ -199,28 +468,75 @@ class DefinitionFinder(TokenProcessor):</span>
<span class="w"> </span>    classes and methods.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, lines: list[str]) -&gt;None:</span>
<span class="gi">+    def __init__(self, lines: list[str]) -&gt; None:</span>
<span class="w"> </span>        super().__init__(lines)
<span class="w"> </span>        self.decorator: Token | None = None
<span class="w"> </span>        self.context: list[str] = []
<span class="w"> </span>        self.indents: list[tuple[str, str | None, int | None]] = []
<span class="w"> </span>        self.definitions: dict[str, tuple[str, int, int]] = {}

<span class="gd">-    def add_definition(self, name: str, entry: tuple[str, int, int]) -&gt;None:</span>
<span class="gi">+    def add_definition(self, name: str, entry: tuple[str, int, int]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a location of definition.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.indents and self.indents[-1][0] == entry[0] == &#39;def&#39;:</span>
<span class="gi">+            # ignore definition of inner function</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.definitions[name] = entry</span>

<span class="gd">-    def parse(self) -&gt;None:</span>
<span class="gi">+    def parse(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse the code to obtain location of definitions.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def parse_definition(self, typ: str) -&gt;None:</span>
<span class="gi">+        while True:</span>
<span class="gi">+            token = self.fetch_token()</span>
<span class="gi">+            if token is None:</span>
<span class="gi">+                break</span>
<span class="gi">+            if token == COMMENT:</span>
<span class="gi">+                pass</span>
<span class="gi">+            elif token == [OP, &#39;@&#39;] and (self.previous is None or</span>
<span class="gi">+                                         self.previous.match(NEWLINE, NL, INDENT, DEDENT)):</span>
<span class="gi">+                if self.decorator is None:</span>
<span class="gi">+                    self.decorator = token</span>
<span class="gi">+            elif token.match([NAME, &#39;class&#39;]):</span>
<span class="gi">+                self.parse_definition(&#39;class&#39;)</span>
<span class="gi">+            elif token.match([NAME, &#39;def&#39;]):</span>
<span class="gi">+                self.parse_definition(&#39;def&#39;)</span>
<span class="gi">+            elif token == INDENT:</span>
<span class="gi">+                self.indents.append((&#39;other&#39;, None, None))</span>
<span class="gi">+            elif token == DEDENT:</span>
<span class="gi">+                self.finalize_block()</span>
<span class="gi">+</span>
<span class="gi">+    def parse_definition(self, typ: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse AST of definition.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        name = self.fetch_token()</span>
<span class="gi">+        self.context.append(name.value)  # type: ignore[union-attr]</span>
<span class="gi">+        funcname = &#39;.&#39;.join(self.context)</span>
<span class="gi">+</span>
<span class="gi">+        if self.decorator:</span>
<span class="gi">+            start_pos = self.decorator.start[0]</span>
<span class="gi">+            self.decorator = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            start_pos = name.start[0]  # type: ignore[union-attr]</span>
<span class="gi">+</span>
<span class="gi">+        self.fetch_until([OP, &#39;:&#39;])</span>
<span class="gi">+        if self.fetch_token().match(COMMENT, NEWLINE):  # type: ignore[union-attr]</span>
<span class="gi">+            self.fetch_until(INDENT)</span>
<span class="gi">+            self.indents.append((typ, funcname, start_pos))</span>
<span class="gi">+        else:</span>
<span class="gi">+            # one-liner</span>
<span class="gi">+            self.add_definition(funcname,</span>
<span class="gi">+                                (typ, start_pos, name.end[0]))  # type: ignore[union-attr]</span>
<span class="gi">+            self.context.pop()</span>

<span class="gd">-    def finalize_block(self) -&gt;None:</span>
<span class="gi">+    def finalize_block(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Finalize definition block.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        definition = self.indents.pop()</span>
<span class="gi">+        if definition[0] != &#39;other&#39;:</span>
<span class="gi">+            typ, funcname, start_pos = definition</span>
<span class="gi">+            end_pos = self.current.end[0] - 1  # type: ignore[union-attr]</span>
<span class="gi">+            while emptyline_re.match(self.get_line(end_pos)):</span>
<span class="gi">+                end_pos -= 1</span>
<span class="gi">+</span>
<span class="gi">+            self.add_definition(funcname, (typ, start_pos, end_pos))  # type: ignore[arg-type]</span>
<span class="gi">+            self.context.pop()</span>


<span class="w"> </span>class Parser:
<span class="gu">@@ -229,7 +545,7 @@ class Parser:</span>
<span class="w"> </span>    This is a better wrapper for ``VariableCommentPicker``.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, code: str, encoding: str=&#39;utf-8&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, code: str, encoding: str = &#39;utf-8&#39;) -&gt; None:</span>
<span class="w"> </span>        self.code = filter_whitespace(code)
<span class="w"> </span>        self.encoding = encoding
<span class="w"> </span>        self.annotations: dict[tuple[str, str], str] = {}
<span class="gu">@@ -239,14 +555,24 @@ class Parser:</span>
<span class="w"> </span>        self.finals: list[str] = []
<span class="w"> </span>        self.overloads: dict[str, list[Signature]] = {}

<span class="gd">-    def parse(self) -&gt;None:</span>
<span class="gi">+    def parse(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse the source code.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.parse_comments()</span>
<span class="gi">+        self.parse_definition()</span>

<span class="gd">-    def parse_comments(self) -&gt;None:</span>
<span class="gi">+    def parse_comments(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse the code and pick up comments.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def parse_definition(self) -&gt;None:</span>
<span class="gi">+        tree = ast.parse(self.code, type_comments=True)</span>
<span class="gi">+        picker = VariableCommentPicker(self.code.splitlines(True), self.encoding)</span>
<span class="gi">+        picker.visit(tree)</span>
<span class="gi">+        self.annotations = picker.annotations</span>
<span class="gi">+        self.comments = picker.comments</span>
<span class="gi">+        self.deforders = picker.deforders</span>
<span class="gi">+        self.finals = picker.finals</span>
<span class="gi">+        self.overloads = picker.overloads</span>
<span class="gi">+</span>
<span class="gi">+    def parse_definition(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse the location of definitions from the code.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parser = DefinitionFinder(self.code.splitlines(True))</span>
<span class="gi">+        parser.parse()</span>
<span class="gi">+        self.definitions = parser.definitions</span>
<span class="gh">diff --git a/sphinx/pygments_styles.py b/sphinx/pygments_styles.py</span>
<span class="gh">index 48959e758..d2266421c 100644</span>
<span class="gd">--- a/sphinx/pygments_styles.py</span>
<span class="gi">+++ b/sphinx/pygments_styles.py</span>
<span class="gu">@@ -1,7 +1,18 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Sphinx theme specific highlighting styles.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from pygments.style import Style
<span class="w"> </span>from pygments.styles.friendly import FriendlyStyle
<span class="gd">-from pygments.token import Comment, Error, Generic, Keyword, Name, Number, Operator, String, Whitespace</span>
<span class="gi">+from pygments.token import (</span>
<span class="gi">+    Comment,</span>
<span class="gi">+    Error,</span>
<span class="gi">+    Generic,</span>
<span class="gi">+    Keyword,</span>
<span class="gi">+    Name,</span>
<span class="gi">+    Number,</span>
<span class="gi">+    Operator,</span>
<span class="gi">+    String,</span>
<span class="gi">+    Whitespace,</span>
<span class="gi">+)</span>


<span class="w"> </span>class NoneStyle(Style):
<span class="gu">@@ -13,33 +24,73 @@ class SphinxStyle(Style):</span>
<span class="w"> </span>    Like friendly, but a bit darker to enhance contrast on the green
<span class="w"> </span>    background.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    background_color = &#39;#eeffcc&#39;
<span class="w"> </span>    default_style = &#39;&#39;
<span class="gd">-    styles = {**FriendlyStyle.styles, Generic.Output: &#39;#333&#39;, Comment:</span>
<span class="gd">-        &#39;italic #408090&#39;, Number: &#39;#208050&#39;}</span>
<span class="gi">+</span>
<span class="gi">+    styles = {</span>
<span class="gi">+        **FriendlyStyle.styles,</span>
<span class="gi">+        Generic.Output: &#39;#333&#39;,</span>
<span class="gi">+        Comment: &#39;italic #408090&#39;,</span>
<span class="gi">+        Number: &#39;#208050&#39;,</span>
<span class="gi">+    }</span>


<span class="w"> </span>class PyramidStyle(Style):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Pylons/pyramid pygments style based on friendly style, by Blaise Laflamme.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    background_color = &#39;#f8f8f8&#39;</span>
<span class="gd">-    default_style = &#39;&#39;</span>
<span class="gd">-    styles = {Whitespace: &#39;#bbbbbb&#39;, Comment: &#39;italic #60a0b0&#39;, Comment.</span>
<span class="gd">-        Preproc: &#39;noitalic #007020&#39;, Comment.Special: &#39;noitalic bg:#fff0f0&#39;,</span>
<span class="gd">-        Keyword: &#39;bold #007020&#39;, Keyword.Pseudo: &#39;nobold&#39;, Keyword.Type:</span>
<span class="gd">-        &#39;nobold #902000&#39;, Operator: &#39;#666666&#39;, Operator.Word:</span>
<span class="gd">-        &#39;bold #007020&#39;, Name.Builtin: &#39;#007020&#39;, Name.Function: &#39;#06287e&#39;,</span>
<span class="gd">-        Name.Class: &#39;bold #0e84b5&#39;, Name.Namespace: &#39;bold #0e84b5&#39;, Name.</span>
<span class="gd">-        Exception: &#39;#007020&#39;, Name.Variable: &#39;#bb60d5&#39;, Name.Constant:</span>
<span class="gd">-        &#39;#60add5&#39;, Name.Label: &#39;bold #002070&#39;, Name.Entity: &#39;bold #d55537&#39;,</span>
<span class="gd">-        Name.Attribute: &#39;#0e84b5&#39;, Name.Tag: &#39;bold #062873&#39;, Name.Decorator:</span>
<span class="gd">-        &#39;bold #555555&#39;, String: &#39;#4070a0&#39;, String.Doc: &#39;italic&#39;, String.</span>
<span class="gd">-        Interpol: &#39;italic #70a0d0&#39;, String.Escape: &#39;bold #4070a0&#39;, String.</span>
<span class="gd">-        Regex: &#39;#235388&#39;, String.Symbol: &#39;#517918&#39;, String.Other: &#39;#c65d09&#39;,</span>
<span class="gd">-        Number: &#39;#40a070&#39;, Generic.Heading: &#39;bold #000080&#39;, Generic.</span>
<span class="gd">-        Subheading: &#39;bold #800080&#39;, Generic.Deleted: &#39;#A00000&#39;, Generic.</span>
<span class="gd">-        Inserted: &#39;#00A000&#39;, Generic.Error: &#39;#FF0000&#39;, Generic.Emph:</span>
<span class="gd">-        &#39;italic&#39;, Generic.Strong: &#39;bold&#39;, Generic.Prompt: &#39;bold #c65d09&#39;,</span>
<span class="gd">-        Generic.Output: &#39;#888&#39;, Generic.Traceback: &#39;#04D&#39;, Error:</span>
<span class="gd">-        &#39;#a40000 bg:#fbe3e4&#39;}</span>
<span class="gi">+</span>
<span class="gi">+    # work in progress...</span>
<span class="gi">+</span>
<span class="gi">+    background_color = &quot;#f8f8f8&quot;</span>
<span class="gi">+    default_style = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    styles = {</span>
<span class="gi">+        Whitespace:                &quot;#bbbbbb&quot;,</span>
<span class="gi">+        Comment:                   &quot;italic #60a0b0&quot;,</span>
<span class="gi">+        Comment.Preproc:           &quot;noitalic #007020&quot;,</span>
<span class="gi">+        Comment.Special:           &quot;noitalic bg:#fff0f0&quot;,</span>
<span class="gi">+</span>
<span class="gi">+        Keyword:                   &quot;bold #007020&quot;,</span>
<span class="gi">+        Keyword.Pseudo:            &quot;nobold&quot;,</span>
<span class="gi">+        Keyword.Type:              &quot;nobold #902000&quot;,</span>
<span class="gi">+</span>
<span class="gi">+        Operator:                  &quot;#666666&quot;,</span>
<span class="gi">+        Operator.Word:             &quot;bold #007020&quot;,</span>
<span class="gi">+</span>
<span class="gi">+        Name.Builtin:              &quot;#007020&quot;,</span>
<span class="gi">+        Name.Function:             &quot;#06287e&quot;,</span>
<span class="gi">+        Name.Class:                &quot;bold #0e84b5&quot;,</span>
<span class="gi">+        Name.Namespace:            &quot;bold #0e84b5&quot;,</span>
<span class="gi">+        Name.Exception:            &quot;#007020&quot;,</span>
<span class="gi">+        Name.Variable:             &quot;#bb60d5&quot;,</span>
<span class="gi">+        Name.Constant:             &quot;#60add5&quot;,</span>
<span class="gi">+        Name.Label:                &quot;bold #002070&quot;,</span>
<span class="gi">+        Name.Entity:               &quot;bold #d55537&quot;,</span>
<span class="gi">+        Name.Attribute:            &quot;#0e84b5&quot;,</span>
<span class="gi">+        Name.Tag:                  &quot;bold #062873&quot;,</span>
<span class="gi">+        Name.Decorator:            &quot;bold #555555&quot;,</span>
<span class="gi">+</span>
<span class="gi">+        String:                    &quot;#4070a0&quot;,</span>
<span class="gi">+        String.Doc:                &quot;italic&quot;,</span>
<span class="gi">+        String.Interpol:           &quot;italic #70a0d0&quot;,</span>
<span class="gi">+        String.Escape:             &quot;bold #4070a0&quot;,</span>
<span class="gi">+        String.Regex:              &quot;#235388&quot;,</span>
<span class="gi">+        String.Symbol:             &quot;#517918&quot;,</span>
<span class="gi">+        String.Other:              &quot;#c65d09&quot;,</span>
<span class="gi">+        Number:                    &quot;#40a070&quot;,</span>
<span class="gi">+</span>
<span class="gi">+        Generic.Heading:           &quot;bold #000080&quot;,</span>
<span class="gi">+        Generic.Subheading:        &quot;bold #800080&quot;,</span>
<span class="gi">+        Generic.Deleted:           &quot;#A00000&quot;,</span>
<span class="gi">+        Generic.Inserted:          &quot;#00A000&quot;,</span>
<span class="gi">+        Generic.Error:             &quot;#FF0000&quot;,</span>
<span class="gi">+        Generic.Emph:              &quot;italic&quot;,</span>
<span class="gi">+        Generic.Strong:            &quot;bold&quot;,</span>
<span class="gi">+        Generic.Prompt:            &quot;bold #c65d09&quot;,</span>
<span class="gi">+        Generic.Output:            &quot;#888&quot;,</span>
<span class="gi">+        Generic.Traceback:         &quot;#04D&quot;,</span>
<span class="gi">+</span>
<span class="gi">+        Error:                     &quot;#a40000 bg:#fbe3e4&quot;,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/registry.py b/sphinx/registry.py</span>
<span class="gh">index dac389ea8..caa8c2daf 100644</span>
<span class="gd">--- a/sphinx/registry.py</span>
<span class="gi">+++ b/sphinx/registry.py</span>
<span class="gu">@@ -1,10 +1,13 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Sphinx component registry.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import traceback
<span class="w"> </span>from importlib import import_module
<span class="w"> </span>from importlib.metadata import entry_points
<span class="w"> </span>from types import MethodType
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from sphinx.domains import Domain, Index, ObjType
<span class="w"> </span>from sphinx.domains.std import GenericObject, Target
<span class="w"> </span>from sphinx.errors import ExtensionError, SphinxError, VersionRequirementError
<span class="gu">@@ -15,63 +18,506 @@ from sphinx.parsers import Parser as SphinxParser</span>
<span class="w"> </span>from sphinx.roles import XRefRole
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.logging import prefixed_warnings
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Callable, Iterator, Sequence
<span class="gi">+</span>
<span class="w"> </span>    from docutils import nodes
<span class="w"> </span>    from docutils.core import Publisher
<span class="w"> </span>    from docutils.nodes import Element, Node, TextElement
<span class="w"> </span>    from docutils.parsers import Parser
<span class="w"> </span>    from docutils.parsers.rst import Directive
<span class="w"> </span>    from docutils.transforms import Transform
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.builders import Builder
<span class="w"> </span>    from sphinx.config import Config
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="w"> </span>    from sphinx.ext.autodoc import Documenter
<span class="gd">-    from sphinx.util.typing import ExtensionMetadata, RoleFunction, TitleGetter, _ExtensionSetupFunc</span>
<span class="gi">+    from sphinx.util.typing import (</span>
<span class="gi">+        ExtensionMetadata,</span>
<span class="gi">+        RoleFunction,</span>
<span class="gi">+        TitleGetter,</span>
<span class="gi">+        _ExtensionSetupFunc,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gd">-EXTENSION_BLACKLIST = {&#39;sphinxjp.themecore&#39;: &#39;1.2&#39;,</span>
<span class="gd">-    &#39;sphinxcontrib-napoleon&#39;: &#39;1.3&#39;, &#39;sphinxprettysearchresults&#39;: &#39;2.0.0&#39;}</span>
<span class="gi">+</span>
<span class="gi">+# list of deprecated extensions. Keys are extension name.</span>
<span class="gi">+# Values are Sphinx version that merge the extension.</span>
<span class="gi">+EXTENSION_BLACKLIST = {</span>
<span class="gi">+    &quot;sphinxjp.themecore&quot;: &quot;1.2&quot;,</span>
<span class="gi">+    &#39;sphinxcontrib-napoleon&#39;: &#39;1.3&#39;,</span>
<span class="gi">+    &quot;sphinxprettysearchresults&quot;: &quot;2.0.0&quot;,</span>
<span class="gi">+}</span>


<span class="w"> </span>class SphinxComponentRegistry:
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="gi">+        #: special attrgetter for autodoc; class object -&gt; attrgetter</span>
<span class="gi">+        self.autodoc_attrgettrs: dict[type, Callable[[Any, str, Any], Any]] = {}</span>

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gd">-        self.autodoc_attrgettrs: dict[type, Callable[[Any, str, Any], Any]] = {</span>
<span class="gd">-            }</span>
<span class="gi">+        #: builders; a dict of builder name -&gt; builder class</span>
<span class="w"> </span>        self.builders: dict[str, type[Builder]] = {}
<span class="gi">+</span>
<span class="gi">+        #: autodoc documenters; a dict of documenter name -&gt; documenter class</span>
<span class="w"> </span>        self.documenters: dict[str, type[Documenter]] = {}
<span class="gi">+</span>
<span class="gi">+        #: css_files; a list of tuple of filename and attributes</span>
<span class="w"> </span>        self.css_files: list[tuple[str, dict[str, Any]]] = []
<span class="gi">+</span>
<span class="gi">+        #: domains; a dict of domain name -&gt; domain class</span>
<span class="w"> </span>        self.domains: dict[str, type[Domain]] = {}
<span class="gi">+</span>
<span class="gi">+        #: additional directives for domains</span>
<span class="gi">+        #: a dict of domain name -&gt; dict of directive name -&gt; directive</span>
<span class="w"> </span>        self.domain_directives: dict[str, dict[str, type[Directive]]] = {}
<span class="gi">+</span>
<span class="gi">+        #: additional indices for domains</span>
<span class="gi">+        #: a dict of domain name -&gt; list of index class</span>
<span class="w"> </span>        self.domain_indices: dict[str, list[type[Index]]] = {}
<span class="gi">+</span>
<span class="gi">+        #: additional object types for domains</span>
<span class="gi">+        #: a dict of domain name -&gt; dict of objtype name -&gt; objtype</span>
<span class="w"> </span>        self.domain_object_types: dict[str, dict[str, ObjType]] = {}
<span class="gi">+</span>
<span class="gi">+        #: additional roles for domains</span>
<span class="gi">+        #: a dict of domain name -&gt; dict of role name -&gt; role impl.</span>
<span class="w"> </span>        self.domain_roles: dict[str, dict[str, RoleFunction | XRefRole]] = {}
<span class="gd">-        self.enumerable_nodes: dict[type[Node], tuple[str, TitleGetter | None]</span>
<span class="gd">-            ] = {}</span>
<span class="gd">-        self.html_inline_math_renderers: dict[str, tuple[Callable, Callable |</span>
<span class="gd">-            None]] = {}</span>
<span class="gd">-        self.html_block_math_renderers: dict[str, tuple[Callable, Callable |</span>
<span class="gd">-            None]] = {}</span>
<span class="gi">+</span>
<span class="gi">+        #: additional enumerable nodes</span>
<span class="gi">+        #: a dict of node class -&gt; tuple of figtype and title_getter function</span>
<span class="gi">+        self.enumerable_nodes: dict[type[Node], tuple[str, TitleGetter | None]] = {}</span>
<span class="gi">+</span>
<span class="gi">+        #: HTML inline and block math renderers</span>
<span class="gi">+        #: a dict of name -&gt; tuple of visit function and depart function</span>
<span class="gi">+        self.html_inline_math_renderers: dict[str,</span>
<span class="gi">+                                              tuple[Callable, Callable | None]] = {}</span>
<span class="gi">+        self.html_block_math_renderers: dict[str,</span>
<span class="gi">+                                             tuple[Callable, Callable | None]] = {}</span>
<span class="gi">+</span>
<span class="gi">+        #: HTML assets</span>
<span class="w"> </span>        self.html_assets_policy: str = &#39;per_page&#39;
<span class="gi">+</span>
<span class="gi">+        #: HTML themes</span>
<span class="w"> </span>        self.html_themes: dict[str, str] = {}
<span class="gi">+</span>
<span class="gi">+        #: js_files; list of JS paths or URLs</span>
<span class="w"> </span>        self.js_files: list[tuple[str | None, dict[str, Any]]] = []
<span class="gi">+</span>
<span class="gi">+        #: LaTeX packages; list of package names and its options</span>
<span class="w"> </span>        self.latex_packages: list[tuple[str, str | None]] = []
<span class="gi">+</span>
<span class="w"> </span>        self.latex_packages_after_hyperref: list[tuple[str, str | None]] = []
<span class="gi">+</span>
<span class="gi">+        #: post transforms; list of transforms</span>
<span class="w"> </span>        self.post_transforms: list[type[Transform]] = []
<span class="gi">+</span>
<span class="gi">+        #: source paresrs; file type -&gt; parser class</span>
<span class="w"> </span>        self.source_parsers: dict[str, type[Parser]] = {}
<span class="gi">+</span>
<span class="gi">+        #: source suffix: suffix -&gt; file type</span>
<span class="w"> </span>        self.source_suffix: dict[str, str] = {}
<span class="gi">+</span>
<span class="gi">+        #: custom translators; builder name -&gt; translator class</span>
<span class="w"> </span>        self.translators: dict[str, type[nodes.NodeVisitor]] = {}
<span class="gd">-        self.translation_handlers: dict[str, dict[str, tuple[Callable, </span>
<span class="gd">-            Callable | None]]] = {}</span>
<span class="gi">+</span>
<span class="gi">+        #: custom handlers for translators</span>
<span class="gi">+        #: a dict of builder name -&gt; dict of node name -&gt; visitor and departure functions</span>
<span class="gi">+        self.translation_handlers: dict[str, dict[str, tuple[Callable, Callable | None]]] = {}</span>
<span class="gi">+</span>
<span class="gi">+        #: additional transforms; list of transforms</span>
<span class="w"> </span>        self.transforms: list[type[Transform]] = []
<span class="gi">+</span>
<span class="gi">+        # private cache of Docutils Publishers (file type -&gt; publisher object)</span>
<span class="w"> </span>        self.publishers: dict[str, Publisher] = {}

<span class="gd">-    def load_extension(self, app: Sphinx, extname: str) -&gt;None:</span>
<span class="gi">+    def add_builder(self, builder: type[Builder], override: bool = False) -&gt; None:</span>
<span class="gi">+        logger.debug(&#39;[app] adding builder: %r&#39;, builder)</span>
<span class="gi">+        if not hasattr(builder, &#39;name&#39;):</span>
<span class="gi">+            raise ExtensionError(__(&#39;Builder class %s has no &quot;name&quot; attribute&#39;) % builder)</span>
<span class="gi">+        if builder.name in self.builders and not override:</span>
<span class="gi">+            raise ExtensionError(__(&#39;Builder %r already exists (in module %s)&#39;) %</span>
<span class="gi">+                                 (builder.name, self.builders[builder.name].__module__))</span>
<span class="gi">+        self.builders[builder.name] = builder</span>
<span class="gi">+</span>
<span class="gi">+    def preload_builder(self, app: Sphinx, name: str) -&gt; None:</span>
<span class="gi">+        if name is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if name not in self.builders:</span>
<span class="gi">+            builder_entry_points = entry_points(group=&#39;sphinx.builders&#39;)</span>
<span class="gi">+            try:</span>
<span class="gi">+                entry_point = builder_entry_points[name]</span>
<span class="gi">+            except KeyError as exc:</span>
<span class="gi">+                raise SphinxError(__(&#39;Builder name %s not registered or available&#39;</span>
<span class="gi">+                                     &#39; through entry point&#39;) % name) from exc</span>
<span class="gi">+</span>
<span class="gi">+            self.load_extension(app, entry_point.module)</span>
<span class="gi">+</span>
<span class="gi">+    def create_builder(self, app: Sphinx, name: str, env: BuildEnvironment) -&gt; Builder:</span>
<span class="gi">+        if name not in self.builders:</span>
<span class="gi">+            raise SphinxError(__(&#39;Builder name %s not registered&#39;) % name)</span>
<span class="gi">+</span>
<span class="gi">+        return self.builders[name](app, env)</span>
<span class="gi">+</span>
<span class="gi">+    def add_domain(self, domain: type[Domain], override: bool = False) -&gt; None:</span>
<span class="gi">+        logger.debug(&#39;[app] adding domain: %r&#39;, domain)</span>
<span class="gi">+        if domain.name in self.domains and not override:</span>
<span class="gi">+            raise ExtensionError(__(&#39;domain %s already registered&#39;) % domain.name)</span>
<span class="gi">+        self.domains[domain.name] = domain</span>
<span class="gi">+</span>
<span class="gi">+    def has_domain(self, domain: str) -&gt; bool:</span>
<span class="gi">+        return domain in self.domains</span>
<span class="gi">+</span>
<span class="gi">+    def create_domains(self, env: BuildEnvironment) -&gt; Iterator[Domain]:</span>
<span class="gi">+        for DomainClass in self.domains.values():</span>
<span class="gi">+            domain = DomainClass(env)</span>
<span class="gi">+</span>
<span class="gi">+            # transplant components added by extensions</span>
<span class="gi">+            domain.directives.update(self.domain_directives.get(domain.name, {}))</span>
<span class="gi">+            domain.roles.update(self.domain_roles.get(domain.name, {}))</span>
<span class="gi">+            domain.indices.extend(self.domain_indices.get(domain.name, []))</span>
<span class="gi">+            for name, objtype in self.domain_object_types.get(domain.name, {}).items():</span>
<span class="gi">+                domain.add_object_type(name, objtype)</span>
<span class="gi">+</span>
<span class="gi">+            yield domain</span>
<span class="gi">+</span>
<span class="gi">+    def add_directive_to_domain(self, domain: str, name: str,</span>
<span class="gi">+                                cls: type[Directive], override: bool = False) -&gt; None:</span>
<span class="gi">+        logger.debug(&#39;[app] adding directive to domain: %r&#39;, (domain, name, cls))</span>
<span class="gi">+        if domain not in self.domains:</span>
<span class="gi">+            raise ExtensionError(__(&#39;domain %s not yet registered&#39;) % domain)</span>
<span class="gi">+</span>
<span class="gi">+        directives: dict[str, type[Directive]] = self.domain_directives.setdefault(domain, {})</span>
<span class="gi">+        if name in directives and not override:</span>
<span class="gi">+            raise ExtensionError(__(&#39;The %r directive is already registered to domain %s&#39;) %</span>
<span class="gi">+                                 (name, domain))</span>
<span class="gi">+        directives[name] = cls</span>
<span class="gi">+</span>
<span class="gi">+    def add_role_to_domain(self, domain: str, name: str,</span>
<span class="gi">+                           role: RoleFunction | XRefRole, override: bool = False,</span>
<span class="gi">+                           ) -&gt; None:</span>
<span class="gi">+        logger.debug(&#39;[app] adding role to domain: %r&#39;, (domain, name, role))</span>
<span class="gi">+        if domain not in self.domains:</span>
<span class="gi">+            raise ExtensionError(__(&#39;domain %s not yet registered&#39;) % domain)</span>
<span class="gi">+        roles = self.domain_roles.setdefault(domain, {})</span>
<span class="gi">+        if name in roles and not override:</span>
<span class="gi">+            raise ExtensionError(__(&#39;The %r role is already registered to domain %s&#39;) %</span>
<span class="gi">+                                 (name, domain))</span>
<span class="gi">+        roles[name] = role</span>
<span class="gi">+</span>
<span class="gi">+    def add_index_to_domain(self, domain: str, index: type[Index],</span>
<span class="gi">+                            override: bool = False) -&gt; None:</span>
<span class="gi">+        logger.debug(&#39;[app] adding index to domain: %r&#39;, (domain, index))</span>
<span class="gi">+        if domain not in self.domains:</span>
<span class="gi">+            raise ExtensionError(__(&#39;domain %s not yet registered&#39;) % domain)</span>
<span class="gi">+        indices = self.domain_indices.setdefault(domain, [])</span>
<span class="gi">+        if index in indices and not override:</span>
<span class="gi">+            raise ExtensionError(__(&#39;The %r index is already registered to domain %s&#39;) %</span>
<span class="gi">+                                 (index.name, domain))</span>
<span class="gi">+        indices.append(index)</span>
<span class="gi">+</span>
<span class="gi">+    def add_object_type(</span>
<span class="gi">+        self,</span>
<span class="gi">+        directivename: str,</span>
<span class="gi">+        rolename: str,</span>
<span class="gi">+        indextemplate: str = &#39;&#39;,</span>
<span class="gi">+        parse_node: Callable | None = None,</span>
<span class="gi">+        ref_nodeclass: type[TextElement] | None = None,</span>
<span class="gi">+        objname: str = &#39;&#39;,</span>
<span class="gi">+        doc_field_types: Sequence = (),</span>
<span class="gi">+        override: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        logger.debug(&#39;[app] adding object type: %r&#39;,</span>
<span class="gi">+                     (directivename, rolename, indextemplate, parse_node,</span>
<span class="gi">+                      ref_nodeclass, objname, doc_field_types))</span>
<span class="gi">+</span>
<span class="gi">+        # create a subclass of GenericObject as the new directive</span>
<span class="gi">+        directive = type(directivename,</span>
<span class="gi">+                         (GenericObject, object),</span>
<span class="gi">+                         {&#39;indextemplate&#39;: indextemplate,</span>
<span class="gi">+                          &#39;parse_node&#39;: parse_node and staticmethod(parse_node),</span>
<span class="gi">+                          &#39;doc_field_types&#39;: doc_field_types})</span>
<span class="gi">+</span>
<span class="gi">+        self.add_directive_to_domain(&#39;std&#39;, directivename, directive)</span>
<span class="gi">+        self.add_role_to_domain(&#39;std&#39;, rolename, XRefRole(innernodeclass=ref_nodeclass))</span>
<span class="gi">+</span>
<span class="gi">+        object_types = self.domain_object_types.setdefault(&#39;std&#39;, {})</span>
<span class="gi">+        if directivename in object_types and not override:</span>
<span class="gi">+            raise ExtensionError(__(&#39;The %r object_type is already registered&#39;) %</span>
<span class="gi">+                                 directivename)</span>
<span class="gi">+        object_types[directivename] = ObjType(objname or directivename, rolename)</span>
<span class="gi">+</span>
<span class="gi">+    def add_crossref_type(</span>
<span class="gi">+        self,</span>
<span class="gi">+        directivename: str,</span>
<span class="gi">+        rolename: str,</span>
<span class="gi">+        indextemplate: str = &#39;&#39;,</span>
<span class="gi">+        ref_nodeclass: type[TextElement] | None = None,</span>
<span class="gi">+        objname: str = &#39;&#39;,</span>
<span class="gi">+        override: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        logger.debug(&#39;[app] adding crossref type: %r&#39;,</span>
<span class="gi">+                     (directivename, rolename, indextemplate, ref_nodeclass, objname))</span>
<span class="gi">+</span>
<span class="gi">+        # create a subclass of Target as the new directive</span>
<span class="gi">+        directive = type(directivename,</span>
<span class="gi">+                         (Target, object),</span>
<span class="gi">+                         {&#39;indextemplate&#39;: indextemplate})</span>
<span class="gi">+</span>
<span class="gi">+        self.add_directive_to_domain(&#39;std&#39;, directivename, directive)</span>
<span class="gi">+        self.add_role_to_domain(&#39;std&#39;, rolename, XRefRole(innernodeclass=ref_nodeclass))</span>
<span class="gi">+</span>
<span class="gi">+        object_types = self.domain_object_types.setdefault(&#39;std&#39;, {})</span>
<span class="gi">+        if directivename in object_types and not override:</span>
<span class="gi">+            raise ExtensionError(__(&#39;The %r crossref_type is already registered&#39;) %</span>
<span class="gi">+                                 directivename)</span>
<span class="gi">+        object_types[directivename] = ObjType(objname or directivename, rolename)</span>
<span class="gi">+</span>
<span class="gi">+    def add_source_suffix(self, suffix: str, filetype: str, override: bool = False) -&gt; None:</span>
<span class="gi">+        logger.debug(&#39;[app] adding source_suffix: %r, %r&#39;, suffix, filetype)</span>
<span class="gi">+        if suffix in self.source_suffix and not override:</span>
<span class="gi">+            raise ExtensionError(__(&#39;source_suffix %r is already registered&#39;) % suffix)</span>
<span class="gi">+        self.source_suffix[suffix] = filetype</span>
<span class="gi">+</span>
<span class="gi">+    def add_source_parser(self, parser: type[Parser], override: bool = False) -&gt; None:</span>
<span class="gi">+        logger.debug(&#39;[app] adding search source_parser: %r&#39;, parser)</span>
<span class="gi">+</span>
<span class="gi">+        # create a map from filetype to parser</span>
<span class="gi">+        for filetype in parser.supported:</span>
<span class="gi">+            if filetype in self.source_parsers and not override:</span>
<span class="gi">+                raise ExtensionError(__(&#39;source_parser for %r is already registered&#39;) %</span>
<span class="gi">+                                     filetype)</span>
<span class="gi">+            self.source_parsers[filetype] = parser</span>
<span class="gi">+</span>
<span class="gi">+    def get_source_parser(self, filetype: str) -&gt; type[Parser]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.source_parsers[filetype]</span>
<span class="gi">+        except KeyError as exc:</span>
<span class="gi">+            raise SphinxError(__(&#39;Source parser for %s not registered&#39;) % filetype) from exc</span>
<span class="gi">+</span>
<span class="gi">+    def get_source_parsers(self) -&gt; dict[str, type[Parser]]:</span>
<span class="gi">+        return self.source_parsers</span>
<span class="gi">+</span>
<span class="gi">+    def create_source_parser(self, app: Sphinx, filename: str) -&gt; Parser:</span>
<span class="gi">+        parser_class = self.get_source_parser(filename)</span>
<span class="gi">+        parser = parser_class()</span>
<span class="gi">+        if isinstance(parser, SphinxParser):</span>
<span class="gi">+            parser.set_application(app)</span>
<span class="gi">+        return parser</span>
<span class="gi">+</span>
<span class="gi">+    def add_translator(self, name: str, translator: type[nodes.NodeVisitor],</span>
<span class="gi">+                       override: bool = False) -&gt; None:</span>
<span class="gi">+        logger.debug(&#39;[app] Change of translator for the %s builder.&#39;, name)</span>
<span class="gi">+        if name in self.translators and not override:</span>
<span class="gi">+            raise ExtensionError(__(&#39;Translator for %r already exists&#39;) % name)</span>
<span class="gi">+        self.translators[name] = translator</span>
<span class="gi">+</span>
<span class="gi">+    def add_translation_handlers(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: type[Element],</span>
<span class="gi">+        **kwargs: tuple[Callable, Callable | None],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        logger.debug(&#39;[app] adding translation_handlers: %r, %r&#39;, node, kwargs)</span>
<span class="gi">+        for builder_name, handlers in kwargs.items():</span>
<span class="gi">+            translation_handlers = self.translation_handlers.setdefault(builder_name, {})</span>
<span class="gi">+            try:</span>
<span class="gi">+                visit, depart = handlers  # unpack once for assertion</span>
<span class="gi">+                translation_handlers[node.__name__] = (visit, depart)</span>
<span class="gi">+            except ValueError as exc:</span>
<span class="gi">+                raise ExtensionError(</span>
<span class="gi">+                    __(&#39;kwargs for add_node() must be a (visit, depart) &#39;</span>
<span class="gi">+                       &#39;function tuple: %r=%r&#39;) % (builder_name, handlers),</span>
<span class="gi">+                ) from exc</span>
<span class="gi">+</span>
<span class="gi">+    def get_translator_class(self, builder: Builder) -&gt; type[nodes.NodeVisitor]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.translators[builder.name]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return builder.default_translator_class</span>
<span class="gi">+            except AttributeError as err:</span>
<span class="gi">+                msg = f&#39;translator not found for {builder.name}&#39;</span>
<span class="gi">+                raise AttributeError(msg) from err</span>
<span class="gi">+</span>
<span class="gi">+    def create_translator(self, builder: Builder, *args: Any) -&gt; nodes.NodeVisitor:</span>
<span class="gi">+        translator_class = self.get_translator_class(builder)</span>
<span class="gi">+        translator = translator_class(*args)</span>
<span class="gi">+</span>
<span class="gi">+        # transplant handlers for custom nodes to translator instance</span>
<span class="gi">+        handlers = self.translation_handlers.get(builder.name, None)</span>
<span class="gi">+        if handlers is None:</span>
<span class="gi">+            # retry with builder.format</span>
<span class="gi">+            handlers = self.translation_handlers.get(builder.format, {})</span>
<span class="gi">+</span>
<span class="gi">+        for name, (visit, depart) in handlers.items():</span>
<span class="gi">+            setattr(translator, &#39;visit_&#39; + name, MethodType(visit, translator))</span>
<span class="gi">+            if depart:</span>
<span class="gi">+                setattr(translator, &#39;depart_&#39; + name, MethodType(depart, translator))</span>
<span class="gi">+</span>
<span class="gi">+        return translator</span>
<span class="gi">+</span>
<span class="gi">+    def add_transform(self, transform: type[Transform]) -&gt; None:</span>
<span class="gi">+        logger.debug(&#39;[app] adding transform: %r&#39;, transform)</span>
<span class="gi">+        self.transforms.append(transform)</span>
<span class="gi">+</span>
<span class="gi">+    def get_transforms(self) -&gt; list[type[Transform]]:</span>
<span class="gi">+        return self.transforms</span>
<span class="gi">+</span>
<span class="gi">+    def add_post_transform(self, transform: type[Transform]) -&gt; None:</span>
<span class="gi">+        logger.debug(&#39;[app] adding post transform: %r&#39;, transform)</span>
<span class="gi">+        self.post_transforms.append(transform)</span>
<span class="gi">+</span>
<span class="gi">+    def get_post_transforms(self) -&gt; list[type[Transform]]:</span>
<span class="gi">+        return self.post_transforms</span>
<span class="gi">+</span>
<span class="gi">+    def add_documenter(self, objtype: str, documenter: type[Documenter]) -&gt; None:</span>
<span class="gi">+        self.documenters[objtype] = documenter</span>
<span class="gi">+</span>
<span class="gi">+    def add_autodoc_attrgetter(self, typ: type,</span>
<span class="gi">+                               attrgetter: Callable[[Any, str, Any], Any]) -&gt; None:</span>
<span class="gi">+        self.autodoc_attrgettrs[typ] = attrgetter</span>
<span class="gi">+</span>
<span class="gi">+    def add_css_files(self, filename: str, **attributes: Any) -&gt; None:</span>
<span class="gi">+        self.css_files.append((filename, attributes))</span>
<span class="gi">+</span>
<span class="gi">+    def add_js_file(self, filename: str | None, **attributes: Any) -&gt; None:</span>
<span class="gi">+        logger.debug(&#39;[app] adding js_file: %r, %r&#39;, filename, attributes)</span>
<span class="gi">+        self.js_files.append((filename, attributes))</span>
<span class="gi">+</span>
<span class="gi">+    def has_latex_package(self, name: str) -&gt; bool:</span>
<span class="gi">+        packages = self.latex_packages + self.latex_packages_after_hyperref</span>
<span class="gi">+        return bool([x for x in packages if x[0] == name])</span>
<span class="gi">+</span>
<span class="gi">+    def add_latex_package(</span>
<span class="gi">+        self, name: str, options: str | None, after_hyperref: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if self.has_latex_package(name):</span>
<span class="gi">+            logger.warning(&quot;latex package &#39;%s&#39; already included&quot;, name)</span>
<span class="gi">+</span>
<span class="gi">+        logger.debug(&#39;[app] adding latex package: %r&#39;, name)</span>
<span class="gi">+        if after_hyperref:</span>
<span class="gi">+            self.latex_packages_after_hyperref.append((name, options))</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.latex_packages.append((name, options))</span>
<span class="gi">+</span>
<span class="gi">+    def add_enumerable_node(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: type[Node],</span>
<span class="gi">+        figtype: str,</span>
<span class="gi">+        title_getter: TitleGetter | None = None, override: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        logger.debug(&#39;[app] adding enumerable node: (%r, %r, %r)&#39;, node, figtype, title_getter)</span>
<span class="gi">+        if node in self.enumerable_nodes and not override:</span>
<span class="gi">+            raise ExtensionError(__(&#39;enumerable_node %r already registered&#39;) % node)</span>
<span class="gi">+        self.enumerable_nodes[node] = (figtype, title_getter)</span>
<span class="gi">+</span>
<span class="gi">+    def add_html_math_renderer(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        inline_renderers: tuple[Callable, Callable | None] | None,</span>
<span class="gi">+        block_renderers: tuple[Callable, Callable | None] | None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        logger.debug(&#39;[app] adding html_math_renderer: %s, %r, %r&#39;,</span>
<span class="gi">+                     name, inline_renderers, block_renderers)</span>
<span class="gi">+        if name in self.html_inline_math_renderers:</span>
<span class="gi">+            raise ExtensionError(__(&#39;math renderer %s is already registered&#39;) % name)</span>
<span class="gi">+</span>
<span class="gi">+        if inline_renderers is not None:</span>
<span class="gi">+            self.html_inline_math_renderers[name] = inline_renderers</span>
<span class="gi">+        if block_renderers is not None:</span>
<span class="gi">+            self.html_block_math_renderers[name] = block_renderers</span>
<span class="gi">+</span>
<span class="gi">+    def add_html_theme(self, name: str, theme_path: str) -&gt; None:</span>
<span class="gi">+        self.html_themes[name] = theme_path</span>
<span class="gi">+</span>
<span class="gi">+    def load_extension(self, app: Sphinx, extname: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Load a Sphinx extension.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if extname in app.extensions:  # already loaded</span>
<span class="gi">+            return</span>
<span class="gi">+        if extname in EXTENSION_BLACKLIST:</span>
<span class="gi">+            logger.warning(__(&#39;the extension %r was already merged with Sphinx since &#39;</span>
<span class="gi">+                              &#39;version %s; this extension is ignored.&#39;),</span>
<span class="gi">+                           extname, EXTENSION_BLACKLIST[extname])</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # update loading context</span>
<span class="gi">+        prefix = __(&#39;while setting up extension %s:&#39;) % extname</span>
<span class="gi">+        with prefixed_warnings(prefix):</span>
<span class="gi">+            try:</span>
<span class="gi">+                mod = import_module(extname)</span>
<span class="gi">+            except ImportError as err:</span>
<span class="gi">+                logger.verbose(__(&#39;Original exception:\n&#39;) + traceback.format_exc())</span>
<span class="gi">+                raise ExtensionError(__(&#39;Could not import extension %s&#39;) % extname,</span>
<span class="gi">+                                     err) from err</span>
<span class="gi">+</span>
<span class="gi">+            setup: _ExtensionSetupFunc | None = getattr(mod, &#39;setup&#39;, None)</span>
<span class="gi">+            if setup is None:</span>
<span class="gi">+                logger.warning(__(&#39;extension %r has no setup() function; is it really &#39;</span>
<span class="gi">+                                  &#39;a Sphinx extension module?&#39;), extname)</span>
<span class="gi">+                metadata: ExtensionMetadata = {}</span>
<span class="gi">+            else:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    metadata = setup(app)</span>
<span class="gi">+                except VersionRequirementError as err:</span>
<span class="gi">+                    # add the extension name to the version required</span>
<span class="gi">+                    raise VersionRequirementError(</span>
<span class="gi">+                        __(&#39;The %s extension used by this project needs at least &#39;</span>
<span class="gi">+                           &#39;Sphinx v%s; it therefore cannot be built with this &#39;</span>
<span class="gi">+                           &#39;version.&#39;) % (extname, err),</span>
<span class="gi">+                    ) from err</span>
<span class="gi">+</span>
<span class="gi">+            if metadata is None:</span>
<span class="gi">+                metadata = {}</span>
<span class="gi">+            elif not isinstance(metadata, dict):</span>
<span class="gi">+                logger.warning(__(&#39;extension %r returned an unsupported object from &#39;</span>
<span class="gi">+                                  &#39;its setup() function; it should return None or a &#39;</span>
<span class="gi">+                                  &#39;metadata dictionary&#39;), extname)</span>
<span class="gi">+                metadata = {}</span>
<span class="gi">+</span>
<span class="gi">+            app.extensions[extname] = Extension(extname, mod, **metadata)</span>
<span class="gi">+</span>
<span class="gi">+    def get_envversion(self, app: Sphinx) -&gt; dict[str, int]:</span>
<span class="gi">+        from sphinx.environment import ENV_VERSION</span>
<span class="gi">+        envversion = {ext.name: ext.metadata[&#39;env_version&#39;] for ext in app.extensions.values()</span>
<span class="gi">+                      if ext.metadata.get(&#39;env_version&#39;)}</span>
<span class="gi">+        envversion[&#39;sphinx&#39;] = ENV_VERSION</span>
<span class="gi">+        return envversion</span>

<span class="gi">+    def get_publisher(self, app: Sphinx, filetype: str) -&gt; Publisher:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.publishers[filetype]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        publisher = create_publisher(app, filetype)</span>
<span class="gi">+        self.publishers[filetype] = publisher</span>
<span class="gi">+        return publisher</span>

<span class="gd">-def merge_source_suffix(app: Sphinx, config: Config) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+def merge_source_suffix(app: Sphinx, config: Config) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Merge any user-specified source_suffix with any added by extensions.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for suffix, filetype in app.registry.source_suffix.items():</span>
<span class="gi">+        if suffix not in app.config.source_suffix:  # NoQA: SIM114</span>
<span class="gi">+            app.config.source_suffix[suffix] = filetype</span>
<span class="gi">+        elif app.config.source_suffix[suffix] == &#39;restructuredtext&#39;:</span>
<span class="gi">+            # The filetype is not specified (default filetype).</span>
<span class="gi">+            # So it overrides default filetype by extensions setting.</span>
<span class="gi">+            app.config.source_suffix[suffix] = filetype</span>
<span class="gi">+        elif app.config.source_suffix[suffix] is None:</span>
<span class="gi">+            msg = __(&#39;`None` is not a valid filetype for %r.&#39;) % suffix</span>
<span class="gi">+            logger.warning(msg)</span>
<span class="gi">+            app.config.source_suffix[suffix] = filetype</span>
<span class="gi">+</span>
<span class="gi">+    # copy config.source_suffix to registry</span>
<span class="gi">+    app.registry.source_suffix = app.config.source_suffix</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.connect(&#39;config-inited&#39;, merge_source_suffix, priority=800)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/roles.py b/sphinx/roles.py</span>
<span class="gh">index 8173b137a..182e2c0da 100644</span>
<span class="gd">--- a/sphinx/roles.py</span>
<span class="gi">+++ b/sphinx/roles.py</span>
<span class="gu">@@ -1,26 +1,44 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Handlers for additional ReST roles.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>import docutils.parsers.rst.directives
<span class="w"> </span>import docutils.parsers.rst.roles
<span class="w"> </span>import docutils.parsers.rst.states
<span class="w"> </span>from docutils import nodes, utils
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.locale import _, __
<span class="w"> </span>from sphinx.util import ws_re
<span class="w"> </span>from sphinx.util.docutils import ReferenceRole, SphinxRole
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Sequence
<span class="gi">+</span>
<span class="w"> </span>    from docutils.nodes import Element, Node, TextElement, system_message
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata, RoleFunction
<span class="gd">-generic_docroles = {&#39;command&#39;: addnodes.literal_strong, &#39;dfn&#39;: nodes.</span>
<span class="gd">-    emphasis, &#39;kbd&#39;: nodes.literal, &#39;mailheader&#39;: addnodes.literal_emphasis,</span>
<span class="gd">-    &#39;makevar&#39;: addnodes.literal_strong, &#39;mimetype&#39;: addnodes.</span>
<span class="gd">-    literal_emphasis, &#39;newsgroup&#39;: addnodes.literal_emphasis, &#39;program&#39;:</span>
<span class="gd">-    addnodes.literal_strong, &#39;regexp&#39;: nodes.literal}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+generic_docroles = {</span>
<span class="gi">+    &#39;command&#39;: addnodes.literal_strong,</span>
<span class="gi">+    &#39;dfn&#39;: nodes.emphasis,</span>
<span class="gi">+    &#39;kbd&#39;: nodes.literal,</span>
<span class="gi">+    &#39;mailheader&#39;: addnodes.literal_emphasis,</span>
<span class="gi">+    &#39;makevar&#39;: addnodes.literal_strong,</span>
<span class="gi">+    &#39;mimetype&#39;: addnodes.literal_emphasis,</span>
<span class="gi">+    &#39;newsgroup&#39;: addnodes.literal_emphasis,</span>
<span class="gi">+    &#39;program&#39;: addnodes.literal_strong,  # XXX should be an x-ref</span>
<span class="gi">+    &#39;regexp&#39;: nodes.literal,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# -- generic cross-reference role ----------------------------------------------</span>


<span class="w"> </span>class XRefRole(ReferenceRole):
<span class="gu">@@ -46,12 +64,18 @@ class XRefRole(ReferenceRole):</span>

<span class="w"> </span>    * Subclassing and overwriting `process_link()` and/or `result_nodes()`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    nodeclass: type[Element] = addnodes.pending_xref
<span class="w"> </span>    innernodeclass: type[TextElement] = nodes.literal

<span class="gd">-    def __init__(self, fix_parens: bool=False, lowercase: bool=False,</span>
<span class="gd">-        nodeclass: (type[Element] | None)=None, innernodeclass: (type[</span>
<span class="gd">-        TextElement] | None)=None, warn_dangling: bool=False) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        fix_parens: bool = False,</span>
<span class="gi">+        lowercase: bool = False,</span>
<span class="gi">+        nodeclass: type[Element] | None = None,</span>
<span class="gi">+        innernodeclass: type[TextElement] | None = None,</span>
<span class="gi">+        warn_dangling: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.fix_parens = fix_parens
<span class="w"> </span>        self.lowercase = lowercase
<span class="w"> </span>        self.warn_dangling = warn_dangling
<span class="gu">@@ -59,64 +83,405 @@ class XRefRole(ReferenceRole):</span>
<span class="w"> </span>            self.nodeclass = nodeclass
<span class="w"> </span>        if innernodeclass is not None:
<span class="w"> </span>            self.innernodeclass = innernodeclass
<span class="gi">+</span>
<span class="w"> </span>        super().__init__()

<span class="gd">-    def process_link(self, env: BuildEnvironment, refnode: Element,</span>
<span class="gd">-        has_explicit_title: bool, title: str, target: str) -&gt;tuple[str, str]:</span>
<span class="gi">+    def update_title_and_target(self, title: str, target: str) -&gt; tuple[str, str]:</span>
<span class="gi">+        if not self.has_explicit_title:</span>
<span class="gi">+            if title.endswith(&#39;()&#39;):</span>
<span class="gi">+                # remove parentheses</span>
<span class="gi">+                title = title[:-2]</span>
<span class="gi">+            if self.config.add_function_parentheses:</span>
<span class="gi">+                # add them back to all occurrences if configured</span>
<span class="gi">+                title += &#39;()&#39;</span>
<span class="gi">+        # remove parentheses from the target too</span>
<span class="gi">+        if target.endswith(&#39;()&#39;):</span>
<span class="gi">+            target = target[:-2]</span>
<span class="gi">+        return title, target</span>
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+        if &#39;:&#39; not in self.name:</span>
<span class="gi">+            self.refdomain, self.reftype = &#39;&#39;, self.name</span>
<span class="gi">+            self.classes = [&#39;xref&#39;, self.reftype]</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.refdomain, self.reftype = self.name.split(&#39;:&#39;, 1)</span>
<span class="gi">+            self.classes = [&#39;xref&#39;, self.refdomain, f&#39;{self.refdomain}-{self.reftype}&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        if self.disabled:</span>
<span class="gi">+            return self.create_non_xref_node()</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.create_xref_node()</span>
<span class="gi">+</span>
<span class="gi">+    def create_non_xref_node(self) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+        text = utils.unescape(self.text[1:])</span>
<span class="gi">+        if self.fix_parens:</span>
<span class="gi">+            self.has_explicit_title = False  # treat as implicit</span>
<span class="gi">+            text, target = self.update_title_and_target(text, &#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        node = self.innernodeclass(self.rawtext, text, classes=self.classes)</span>
<span class="gi">+        return self.result_nodes(self.inliner.document, self.env, node, is_ref=False)</span>
<span class="gi">+</span>
<span class="gi">+    def create_xref_node(self) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+        target = self.target</span>
<span class="gi">+        title = self.title</span>
<span class="gi">+        if self.lowercase:</span>
<span class="gi">+            target = target.lower()</span>
<span class="gi">+        if self.fix_parens:</span>
<span class="gi">+            title, target = self.update_title_and_target(title, target)</span>
<span class="gi">+</span>
<span class="gi">+        # create the reference node</span>
<span class="gi">+        options = {</span>
<span class="gi">+            &#39;refdoc&#39;: self.env.docname,</span>
<span class="gi">+            &#39;refdomain&#39;: self.refdomain,</span>
<span class="gi">+            &#39;reftype&#39;: self.reftype,</span>
<span class="gi">+            &#39;refexplicit&#39;: self.has_explicit_title,</span>
<span class="gi">+            &#39;refwarn&#39;: self.warn_dangling,</span>
<span class="gi">+        }</span>
<span class="gi">+        refnode = self.nodeclass(self.rawtext, **options)</span>
<span class="gi">+        self.set_source_info(refnode)</span>
<span class="gi">+</span>
<span class="gi">+        # determine the target and title for the class</span>
<span class="gi">+        title, target = self.process_link(</span>
<span class="gi">+            self.env, refnode, self.has_explicit_title, title, target</span>
<span class="gi">+        )</span>
<span class="gi">+        refnode[&#39;reftarget&#39;] = target</span>
<span class="gi">+        refnode += self.innernodeclass(self.rawtext, title, classes=self.classes)</span>
<span class="gi">+</span>
<span class="gi">+        return self.result_nodes(self.inliner.document, self.env, refnode, is_ref=True)</span>
<span class="gi">+</span>
<span class="gi">+    # methods that can be overwritten</span>
<span class="gi">+</span>
<span class="gi">+    def process_link(</span>
<span class="gi">+        self,</span>
<span class="gi">+        env: BuildEnvironment,</span>
<span class="gi">+        refnode: Element,</span>
<span class="gi">+        has_explicit_title: bool,</span>
<span class="gi">+        title: str,</span>
<span class="gi">+        target: str,</span>
<span class="gi">+    ) -&gt; tuple[str, str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called after parsing title and target text, and creating the
<span class="w"> </span>        reference node (given in *refnode*).  This method can alter the
<span class="w"> </span>        reference node and must return a new (or the same) ``(title, target)``
<span class="w"> </span>        tuple.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return title, ws_re.sub(&#39; &#39;, target)</span>

<span class="gd">-    def result_nodes(self, document: nodes.document, env: BuildEnvironment,</span>
<span class="gd">-        node: Element, is_ref: bool) -&gt;tuple[list[Node], list[system_message]]:</span>
<span class="gi">+    def result_nodes(</span>
<span class="gi">+        self,</span>
<span class="gi">+        document: nodes.document,</span>
<span class="gi">+        env: BuildEnvironment,</span>
<span class="gi">+        node: Element,</span>
<span class="gi">+        is_ref: bool,</span>
<span class="gi">+    ) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Called before returning the finished nodes.  *node* is the reference
<span class="w"> </span>        node if one was created (*is_ref* is then true), else the content node.
<span class="w"> </span>        This method can add other nodes and must return a ``(nodes, messages)``
<span class="w"> </span>        tuple (the usual return value of a role function).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [node], []</span>


<span class="w"> </span>class AnyXRefRole(XRefRole):
<span class="gd">-    pass</span>
<span class="gi">+    def process_link(</span>
<span class="gi">+        self,</span>
<span class="gi">+        env: BuildEnvironment,</span>
<span class="gi">+        refnode: Element,</span>
<span class="gi">+        has_explicit_title: bool,</span>
<span class="gi">+        title: str,</span>
<span class="gi">+        target: str,</span>
<span class="gi">+    ) -&gt; tuple[str, str]:</span>
<span class="gi">+        result = super().process_link(env, refnode, has_explicit_title, title, target)</span>
<span class="gi">+        # add all possible context info (i.e. std:program, py:module etc.)</span>
<span class="gi">+        refnode.attributes.update(env.ref_context)</span>
<span class="gi">+        return result</span>


<span class="w"> </span>class PEP(ReferenceRole):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+        target_id = &#39;index-%s&#39; % self.env.new_serialno(&#39;index&#39;)</span>
<span class="gi">+        entries = [</span>
<span class="gi">+            (</span>
<span class="gi">+                &#39;single&#39;,</span>
<span class="gi">+                _(&#39;Python Enhancement Proposals; PEP %s&#39;) % self.target,</span>
<span class="gi">+                target_id,</span>
<span class="gi">+                &#39;&#39;,</span>
<span class="gi">+                None,</span>
<span class="gi">+            )</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+        index = addnodes.index(entries=entries)</span>
<span class="gi">+        target = nodes.target(&#39;&#39;, &#39;&#39;, ids=[target_id])</span>
<span class="gi">+        self.inliner.document.note_explicit_target(target)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            refuri = self.build_uri()</span>
<span class="gi">+            reference = nodes.reference(</span>
<span class="gi">+                &#39;&#39;, &#39;&#39;, internal=False, refuri=refuri, classes=[&#39;pep&#39;]</span>
<span class="gi">+            )</span>
<span class="gi">+            if self.has_explicit_title:</span>
<span class="gi">+                reference += nodes.strong(self.title, self.title)</span>
<span class="gi">+            else:</span>
<span class="gi">+                title = &#39;PEP &#39; + self.title</span>
<span class="gi">+                reference += nodes.strong(title, title)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            msg = self.inliner.reporter.error(</span>
<span class="gi">+                __(&#39;invalid PEP number %s&#39;) % self.target, line=self.lineno</span>
<span class="gi">+            )</span>
<span class="gi">+            prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)</span>
<span class="gi">+            return [prb], [msg]</span>
<span class="gi">+</span>
<span class="gi">+        return [index, target, reference], []</span>
<span class="gi">+</span>
<span class="gi">+    def build_uri(self) -&gt; str:</span>
<span class="gi">+        base_url = self.inliner.document.settings.pep_base_url</span>
<span class="gi">+        ret = self.target.split(&#39;#&#39;, 1)</span>
<span class="gi">+        if len(ret) == 2:</span>
<span class="gi">+            return base_url + &#39;pep-%04d/#%s&#39; % (int(ret[0]), ret[1])</span>
<span class="gi">+        else:</span>
<span class="gi">+            return base_url + &#39;pep-%04d/&#39; % int(ret[0])</span>


<span class="w"> </span>class RFC(ReferenceRole):
<span class="gd">-    pass</span>
<span class="gi">+    def run(self) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+        target_id = &#39;index-%s&#39; % self.env.new_serialno(&#39;index&#39;)</span>
<span class="gi">+        entries = [(&#39;single&#39;, &#39;RFC; RFC %s&#39; % self.target, target_id, &#39;&#39;, None)]</span>
<span class="gi">+</span>
<span class="gi">+        index = addnodes.index(entries=entries)</span>
<span class="gi">+        target = nodes.target(&#39;&#39;, &#39;&#39;, ids=[target_id])</span>
<span class="gi">+        self.inliner.document.note_explicit_target(target)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            refuri = self.build_uri()</span>
<span class="gi">+            reference = nodes.reference(</span>
<span class="gi">+                &#39;&#39;, &#39;&#39;, internal=False, refuri=refuri, classes=[&#39;rfc&#39;]</span>
<span class="gi">+            )</span>
<span class="gi">+            if self.has_explicit_title:</span>
<span class="gi">+                reference += nodes.strong(self.title, self.title)</span>
<span class="gi">+            else:</span>
<span class="gi">+                title = &#39;RFC &#39; + self.title</span>
<span class="gi">+                reference += nodes.strong(title, title)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            msg = self.inliner.reporter.error(</span>
<span class="gi">+                __(&#39;invalid RFC number %s&#39;) % self.target, line=self.lineno</span>
<span class="gi">+            )</span>
<span class="gi">+            prb = self.inliner.problematic(self.rawtext, self.rawtext, msg)</span>
<span class="gi">+            return [prb], [msg]</span>
<span class="gi">+</span>
<span class="gi">+        return [index, target, reference], []</span>
<span class="gi">+</span>
<span class="gi">+    def build_uri(self) -&gt; str:</span>
<span class="gi">+        base_url = self.inliner.document.settings.rfc_base_url</span>
<span class="gi">+        ret = self.target.split(&#39;#&#39;, 1)</span>
<span class="gi">+        if len(ret) == 2:</span>
<span class="gi">+            return base_url + self.inliner.rfc_url % int(ret[0]) + &#39;#&#39; + ret[1]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return base_url + self.inliner.rfc_url % int(ret[0])</span>


<span class="w"> </span>class GUILabel(SphinxRole):
<span class="gd">-    amp_re = re.compile(&#39;(?&lt;!&amp;)&amp;(?![&amp;\\s])&#39;)</span>
<span class="gi">+    amp_re = re.compile(r&#39;(?&lt;!&amp;)&amp;(?![&amp;\s])&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+        node = nodes.inline(rawtext=self.rawtext, classes=[self.name])</span>
<span class="gi">+        spans = self.amp_re.split(self.text)</span>
<span class="gi">+        node += nodes.Text(spans.pop(0))</span>
<span class="gi">+        for span in spans:</span>
<span class="gi">+            span = span.replace(&#39;&amp;&amp;&#39;, &#39;&amp;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            letter = nodes.Text(span[0])</span>
<span class="gi">+            accelerator = nodes.inline(&#39;&#39;, &#39;&#39;, letter, classes=[&#39;accelerator&#39;])</span>
<span class="gi">+            node += accelerator</span>
<span class="gi">+            node += nodes.Text(span[1:])</span>
<span class="gi">+</span>
<span class="gi">+        return [node], []</span>


<span class="w"> </span>class MenuSelection(GUILabel):
<span class="gd">-    BULLET_CHARACTER = &#39;&#39;</span>
<span class="gi">+    BULLET_CHARACTER = &#39;\N{TRIANGULAR BULLET}&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+        self.text = self.text.replace(&#39;--&gt;&#39;, self.BULLET_CHARACTER)</span>
<span class="gi">+        return super().run()</span>


<span class="w"> </span>class EmphasizedLiteral(SphinxRole):
<span class="gd">-    parens_re = re.compile(&#39;(\\\\\\\\|\\\\{|\\\\}|{|})&#39;)</span>
<span class="gi">+    parens_re = re.compile(r&#39;(\\\\|\\{|\\}|{|})&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+        children = self.parse(self.text)</span>
<span class="gi">+        node = nodes.literal(</span>
<span class="gi">+            self.rawtext, &#39;&#39;, *children, role=self.name.lower(), classes=[self.name]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        return [node], []</span>
<span class="gi">+</span>
<span class="gi">+    def parse(self, text: str) -&gt; list[Node]:</span>
<span class="gi">+        result: list[Node] = []</span>
<span class="gi">+</span>
<span class="gi">+        stack = [&#39;&#39;]</span>
<span class="gi">+        for part in self.parens_re.split(text):</span>
<span class="gi">+            if part == &#39;\\\\&#39;:  # escaped backslash</span>
<span class="gi">+                stack[-1] += &#39;\\&#39;</span>
<span class="gi">+            elif part == &#39;{&#39;:</span>
<span class="gi">+                if len(stack) &gt;= 2 and stack[-2] == &#39;{&#39;:  # nested</span>
<span class="gi">+                    stack[-1] += &#39;{&#39;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # start emphasis</span>
<span class="gi">+                    stack.extend((&#39;{&#39;, &#39;&#39;))</span>
<span class="gi">+            elif part == &#39;}&#39;:</span>
<span class="gi">+                if len(stack) == 3 and stack[1] == &#39;{&#39; and len(stack[2]) &gt; 0:</span>
<span class="gi">+                    # emphasized word found</span>
<span class="gi">+                    if stack[0]:</span>
<span class="gi">+                        result.append(nodes.Text(stack[0]))</span>
<span class="gi">+                    result.append(nodes.emphasis(stack[2], stack[2]))</span>
<span class="gi">+                    stack = [&#39;&#39;]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # emphasized word not found; the rparen is not a special symbol</span>
<span class="gi">+                    stack.append(&#39;}&#39;)</span>
<span class="gi">+                    stack = [&#39;&#39;.join(stack)]</span>
<span class="gi">+            elif part == &#39;\\{&#39;:  # escaped left-brace</span>
<span class="gi">+                stack[-1] += &#39;{&#39;</span>
<span class="gi">+            elif part == &#39;\\}&#39;:  # escaped right-brace</span>
<span class="gi">+                stack[-1] += &#39;}&#39;</span>
<span class="gi">+            else:  # others (containing escaped braces)</span>
<span class="gi">+                stack[-1] += part</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;&#39;.join(stack):</span>
<span class="gi">+            # remaining is treated as Text</span>
<span class="gi">+            text = &#39;&#39;.join(stack)</span>
<span class="gi">+            result.append(nodes.Text(text))</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>


<span class="w"> </span>class Abbreviation(SphinxRole):
<span class="gd">-    abbr_re = re.compile(&#39;\\((.*)\\)$&#39;, re.DOTALL)</span>
<span class="gi">+    abbr_re = re.compile(r&#39;\((.*)\)$&#39;, re.DOTALL)</span>
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+        options = self.options.copy()</span>
<span class="gi">+        matched = self.abbr_re.search(self.text)</span>
<span class="gi">+        if matched:</span>
<span class="gi">+            text = self.text[: matched.start()].strip()</span>
<span class="gi">+            options[&#39;explanation&#39;] = matched.group(1)</span>
<span class="gi">+        else:</span>
<span class="gi">+            text = self.text</span>
<span class="gi">+</span>
<span class="gi">+        return [nodes.abbreviation(self.rawtext, text, **options)], []</span>


<span class="w"> </span>class Manpage(ReferenceRole):
<span class="gd">-    _manpage_re = re.compile(</span>
<span class="gd">-        &#39;^(?P&lt;path&gt;(?P&lt;page&gt;.+)[(.](?P&lt;section&gt;[1-9]\\w*)?\\)?)$&#39;)</span>
<span class="gi">+    _manpage_re = re.compile(r&#39;^(?P&lt;path&gt;(?P&lt;page&gt;.+)[(.](?P&lt;section&gt;[1-9]\w*)?\)?)$&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def run(self) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+        manpage = ws_re.sub(&#39; &#39;, self.target)</span>
<span class="gi">+        if m := self._manpage_re.match(manpage):</span>
<span class="gi">+            info = m.groupdict()</span>
<span class="gi">+        else:</span>
<span class="gi">+            info = {&#39;path&#39;: manpage, &#39;page&#39;: manpage, &#39;section&#39;: &#39;&#39;}</span>
<span class="gi">+</span>
<span class="gi">+        inner: nodes.Node</span>
<span class="gi">+        text = self.title[1:] if self.disabled else self.title</span>
<span class="gi">+        if not self.disabled and self.config.manpages_url:</span>
<span class="gi">+            uri = self.config.manpages_url.format_map(info)</span>
<span class="gi">+            inner = nodes.reference(&#39;&#39;, text, classes=[self.name], refuri=uri)</span>
<span class="gi">+        else:</span>
<span class="gi">+            inner = nodes.Text(text)</span>
<span class="gi">+        node = addnodes.manpage(self.rawtext, &#39;&#39;, inner, classes=[self.name], **info)</span>
<span class="gi">+</span>
<span class="gi">+        return [node], []</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Sphinx provides the `code-block` directive for highlighting code blocks.</span>
<span class="gi">+# Docutils provides the `code` role which in theory can be used similarly by</span>
<span class="gi">+# defining a custom role for a given programming language:</span>
<span class="gi">+#</span>
<span class="gi">+#     .. .. role:: python(code)</span>
<span class="gi">+#          :language: python</span>
<span class="gi">+#          :class: highlight</span>
<span class="gi">+#</span>
<span class="gi">+# In practice this does not produce correct highlighting because it uses a</span>
<span class="gi">+# separate highlighting mechanism that results in the &quot;long&quot; pygments class</span>
<span class="gi">+# names rather than &quot;short&quot; pygments class names produced by the Sphinx</span>
<span class="gi">+# `code-block` directive and for which this extension contains CSS rules.</span>
<span class="gi">+#</span>
<span class="gi">+# In addition, even if that issue is fixed, because the highlighting</span>
<span class="gi">+# implementation in docutils, despite being based on pygments, differs from that</span>
<span class="gi">+# used by Sphinx, the output does not exactly match that produced by the Sphinx</span>
<span class="gi">+# `code-block` directive.</span>
<span class="gi">+#</span>
<span class="gi">+# This issue is noted here: //github.com/sphinx-doc/sphinx/issues/5157</span>
<span class="gi">+#</span>
<span class="gi">+# This overrides the docutils `code` role to perform highlighting in the same</span>
<span class="gi">+# way as the Sphinx `code-block` directive.</span>
<span class="gi">+#</span>
<span class="gi">+# TODO: Change to use `SphinxRole` once SphinxRole is fixed to support options.</span>
<span class="gi">+def code_role(</span>
<span class="gi">+    name: str,</span>
<span class="gi">+    rawtext: str,</span>
<span class="gi">+    text: str,</span>
<span class="gi">+    lineno: int,</span>
<span class="gi">+    inliner: docutils.parsers.rst.states.Inliner,</span>
<span class="gi">+    options: dict[str, Any] | None = None,</span>
<span class="gi">+    content: Sequence[str] = (),</span>
<span class="gi">+) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+    if options is None:</span>
<span class="gi">+        options = {}</span>
<span class="gi">+    options = options.copy()</span>
<span class="gi">+    docutils.parsers.rst.roles.set_classes(options)</span>
<span class="gi">+    language = options.get(&#39;language&#39;, &#39;&#39;)</span>
<span class="gi">+    classes = [&#39;code&#39;]</span>
<span class="gi">+    if language:</span>
<span class="gi">+        classes.append(&#39;highlight&#39;)</span>
<span class="gi">+    if &#39;classes&#39; in options:</span>
<span class="gi">+        classes.extend(options[&#39;classes&#39;])</span>
<span class="gi">+</span>
<span class="gi">+    if language and language not in classes:</span>
<span class="gi">+        classes.append(language)</span>
<span class="gi">+</span>
<span class="gi">+    node = nodes.literal(rawtext, text, classes=classes, language=language)</span>
<span class="gi">+</span>
<span class="gi">+    return [node], []</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+code_role.options = {  # type: ignore[attr-defined]</span>
<span class="gi">+    &#39;class&#39;: docutils.parsers.rst.directives.class_option,</span>
<span class="gi">+    &#39;language&#39;: docutils.parsers.rst.directives.unchanged,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+specific_docroles: dict[str, RoleFunction] = {</span>
<span class="gi">+    # links to download references</span>
<span class="gi">+    &#39;download&#39;: XRefRole(nodeclass=addnodes.download_reference),</span>
<span class="gi">+    # links to anything</span>
<span class="gi">+    &#39;any&#39;: AnyXRefRole(warn_dangling=True),</span>
<span class="gi">+    &#39;pep&#39;: PEP(),</span>
<span class="gi">+    &#39;rfc&#39;: RFC(),</span>
<span class="gi">+    &#39;guilabel&#39;: GUILabel(),</span>
<span class="gi">+    &#39;menuselection&#39;: MenuSelection(),</span>
<span class="gi">+    &#39;file&#39;: EmphasizedLiteral(),</span>
<span class="gi">+    &#39;samp&#39;: EmphasizedLiteral(),</span>
<span class="gi">+    &#39;abbr&#39;: Abbreviation(),</span>
<span class="gi">+    &#39;manpage&#39;: Manpage(),</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    from docutils.parsers.rst import roles</span>
<span class="gi">+</span>
<span class="gi">+    for rolename, nodeclass in generic_docroles.items():</span>
<span class="gi">+        generic = roles.GenericRole(rolename, nodeclass)</span>
<span class="gi">+        role = roles.CustomRole(rolename, generic, {&#39;classes&#39;: [rolename]})  # type: ignore[arg-type]</span>
<span class="gi">+        roles.register_local_role(rolename, role)  # type: ignore[arg-type]</span>
<span class="gi">+</span>
<span class="gi">+    for rolename, func in specific_docroles.items():</span>
<span class="gi">+        roles.register_local_role(rolename, func)  # type: ignore[arg-type]</span>

<span class="gi">+    # Since docutils registers it as a canonical role, override it as a</span>
<span class="gi">+    # canonical role as well.</span>
<span class="gi">+    roles.register_canonical_role(&#39;code&#39;, code_role)  # type: ignore[arg-type]</span>

<span class="gd">-code_role.options = {&#39;class&#39;: docutils.parsers.rst.directives.class_option,</span>
<span class="gd">-    &#39;language&#39;: docutils.parsers.rst.directives.unchanged}</span>
<span class="gd">-specific_docroles: dict[str, RoleFunction] = {&#39;download&#39;: XRefRole(</span>
<span class="gd">-    nodeclass=addnodes.download_reference), &#39;any&#39;: AnyXRefRole(</span>
<span class="gd">-    warn_dangling=True), &#39;pep&#39;: PEP(), &#39;rfc&#39;: RFC(), &#39;guilabel&#39;: GUILabel(),</span>
<span class="gd">-    &#39;menuselection&#39;: MenuSelection(), &#39;file&#39;: EmphasizedLiteral(), &#39;samp&#39;:</span>
<span class="gd">-    EmphasizedLiteral(), &#39;abbr&#39;: Abbreviation(), &#39;manpage&#39;: Manpage()}</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/search/da.py b/sphinx/search/da.py</span>
<span class="gh">index 2474be663..47c574485 100644</span>
<span class="gd">--- a/sphinx/search/da.py</span>
<span class="gi">+++ b/sphinx/search/da.py</span>
<span class="gu">@@ -1,10 +1,14 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Danish search language: includes the JS Danish stemmer.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Dict
<span class="gi">+</span>
<span class="w"> </span>import snowballstemmer
<span class="gi">+</span>
<span class="w"> </span>from sphinx.search import SearchLanguage, parse_stop_word
<span class="gd">-danish_stopwords = parse_stop_word(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+danish_stopwords = parse_stop_word(&#39;&#39;&#39;</span>
<span class="w"> </span>| source: https://snowball.tartarus.org/algorithms/danish/stop.txt
<span class="w"> </span>og           | and
<span class="w"> </span>i            | in
<span class="gu">@@ -100,8 +104,7 @@ vret        | be</span>
<span class="w"> </span>thi          | for (conj)
<span class="w"> </span>jer          | you
<span class="w"> </span>sdan        | such, like this/like that
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    )</span>
<span class="gi">+&#39;&#39;&#39;)</span>


<span class="w"> </span>class SearchDanish(SearchLanguage):
<span class="gu">@@ -109,3 +112,9 @@ class SearchDanish(SearchLanguage):</span>
<span class="w"> </span>    language_name = &#39;Danish&#39;
<span class="w"> </span>    js_stemmer_rawcode = &#39;danish-stemmer.js&#39;
<span class="w"> </span>    stopwords = danish_stopwords
<span class="gi">+</span>
<span class="gi">+    def init(self, options: dict[str, str]) -&gt; None:</span>
<span class="gi">+        self.stemmer = snowballstemmer.stemmer(&#39;danish&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def stem(self, word: str) -&gt; str:</span>
<span class="gi">+        return self.stemmer.stemWord(word.lower())</span>
<span class="gh">diff --git a/sphinx/search/de.py b/sphinx/search/de.py</span>
<span class="gh">index 861369d3e..dae52c9f8 100644</span>
<span class="gd">--- a/sphinx/search/de.py</span>
<span class="gi">+++ b/sphinx/search/de.py</span>
<span class="gu">@@ -1,10 +1,14 @@</span>
<span class="w"> </span>&quot;&quot;&quot;German search language: includes the JS German stemmer.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Dict
<span class="gi">+</span>
<span class="w"> </span>import snowballstemmer
<span class="gi">+</span>
<span class="w"> </span>from sphinx.search import SearchLanguage, parse_stop_word
<span class="gd">-german_stopwords = parse_stop_word(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+german_stopwords = parse_stop_word(&#39;&#39;&#39;</span>
<span class="w"> </span>|source: https://snowball.tartarus.org/algorithms/german/stop.txt
<span class="w"> </span>aber           |  but

<span class="gu">@@ -283,8 +287,7 @@ zum            |  zu + dem</span>
<span class="w"> </span>zur            |  zu + der
<span class="w"> </span>zwar           |  indeed
<span class="w"> </span>zwischen       |  between
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    )</span>
<span class="gi">+&#39;&#39;&#39;)</span>


<span class="w"> </span>class SearchGerman(SearchLanguage):
<span class="gu">@@ -292,3 +295,9 @@ class SearchGerman(SearchLanguage):</span>
<span class="w"> </span>    language_name = &#39;German&#39;
<span class="w"> </span>    js_stemmer_rawcode = &#39;german-stemmer.js&#39;
<span class="w"> </span>    stopwords = german_stopwords
<span class="gi">+</span>
<span class="gi">+    def init(self, options: dict[str, str]) -&gt; None:</span>
<span class="gi">+        self.stemmer = snowballstemmer.stemmer(&#39;german&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def stem(self, word: str) -&gt; str:</span>
<span class="gi">+        return self.stemmer.stemWord(word.lower())</span>
<span class="gh">diff --git a/sphinx/search/en.py b/sphinx/search/en.py</span>
<span class="gh">index c943768d8..a1f06bd3f 100644</span>
<span class="gd">--- a/sphinx/search/en.py</span>
<span class="gi">+++ b/sphinx/search/en.py</span>
<span class="gu">@@ -1,10 +1,14 @@</span>
<span class="w"> </span>&quot;&quot;&quot;English search language: includes the JS porter stemmer.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Dict
<span class="gi">+</span>
<span class="w"> </span>import snowballstemmer
<span class="gi">+</span>
<span class="w"> </span>from sphinx.search import SearchLanguage
<span class="gd">-english_stopwords = set(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+english_stopwords = set(&quot;&quot;&quot;</span>
<span class="w"> </span>a  and  are  as  at
<span class="w"> </span>be  but  by
<span class="w"> </span>for
<span class="gu">@@ -14,8 +18,8 @@ of  on  or</span>
<span class="w"> </span>such
<span class="w"> </span>that  the  their  then  there  these  they  this  to
<span class="w"> </span>was  will  with
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    .split())</span>
<span class="gi">+&quot;&quot;&quot;.split())</span>
<span class="gi">+</span>
<span class="w"> </span>js_porter_stemmer = &quot;&quot;&quot;
<span class="w"> </span>/**
<span class="w"> </span> * Porter Stemmer
<span class="gu">@@ -135,7 +139,8 @@ var Stemmer = function() {</span>
<span class="w"> </span>    }

<span class="w"> </span>    // Step 2
<span class="gd">-    re = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;</span>
<span class="gi">+    re = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|\</span>
<span class="gi">+ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;</span>
<span class="w"> </span>    if (re.test(w)) {
<span class="w"> </span>      var fp = re.exec(w);
<span class="w"> </span>      stem = fp[1];
<span class="gu">@@ -157,7 +162,8 @@ var Stemmer = function() {</span>
<span class="w"> </span>    }

<span class="w"> </span>    // Step 4
<span class="gd">-    re = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;</span>
<span class="gi">+    re = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|\</span>
<span class="gi">+iti|ous|ive|ize)$/;</span>
<span class="w"> </span>    re2 = /^(.+?)(s|t)(ion)$/;
<span class="w"> </span>    if (re.test(w)) {
<span class="w"> </span>      var fp = re.exec(w);
<span class="gu">@@ -206,3 +212,9 @@ class SearchEnglish(SearchLanguage):</span>
<span class="w"> </span>    language_name = &#39;English&#39;
<span class="w"> </span>    js_stemmer_code = js_porter_stemmer
<span class="w"> </span>    stopwords = english_stopwords
<span class="gi">+</span>
<span class="gi">+    def init(self, options: dict[str, str]) -&gt; None:</span>
<span class="gi">+        self.stemmer = snowballstemmer.stemmer(&#39;porter&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def stem(self, word: str) -&gt; str:</span>
<span class="gi">+        return self.stemmer.stemWord(word.lower())</span>
<span class="gh">diff --git a/sphinx/search/es.py b/sphinx/search/es.py</span>
<span class="gh">index 9205836e5..247095b45 100644</span>
<span class="gd">--- a/sphinx/search/es.py</span>
<span class="gi">+++ b/sphinx/search/es.py</span>
<span class="gu">@@ -1,10 +1,14 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Spanish search language: includes the JS Spanish stemmer.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Dict
<span class="gi">+</span>
<span class="w"> </span>import snowballstemmer
<span class="gi">+</span>
<span class="w"> </span>from sphinx.search import SearchLanguage, parse_stop_word
<span class="gd">-spanish_stopwords = parse_stop_word(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+spanish_stopwords = parse_stop_word(&#39;&#39;&#39;</span>
<span class="w"> </span>|source: https://snowball.tartarus.org/algorithms/spanish/stop.txt
<span class="w"> </span>de             |  from, of
<span class="w"> </span>la             |  the, her
<span class="gu">@@ -343,8 +347,7 @@ tenida</span>
<span class="w"> </span>tenidos
<span class="w"> </span>tenidas
<span class="w"> </span>tened
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    )</span>
<span class="gi">+&#39;&#39;&#39;)</span>


<span class="w"> </span>class SearchSpanish(SearchLanguage):
<span class="gu">@@ -352,3 +355,9 @@ class SearchSpanish(SearchLanguage):</span>
<span class="w"> </span>    language_name = &#39;Spanish&#39;
<span class="w"> </span>    js_stemmer_rawcode = &#39;spanish-stemmer.js&#39;
<span class="w"> </span>    stopwords = spanish_stopwords
<span class="gi">+</span>
<span class="gi">+    def init(self, options: dict[str, str]) -&gt; None:</span>
<span class="gi">+        self.stemmer = snowballstemmer.stemmer(&#39;spanish&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def stem(self, word: str) -&gt; str:</span>
<span class="gi">+        return self.stemmer.stemWord(word.lower())</span>
<span class="gh">diff --git a/sphinx/search/fi.py b/sphinx/search/fi.py</span>
<span class="gh">index a5f713684..5eca6e384 100644</span>
<span class="gd">--- a/sphinx/search/fi.py</span>
<span class="gi">+++ b/sphinx/search/fi.py</span>
<span class="gu">@@ -1,10 +1,14 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Finnish search language: includes the JS Finnish stemmer.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Dict
<span class="gi">+</span>
<span class="w"> </span>import snowballstemmer
<span class="gi">+</span>
<span class="w"> </span>from sphinx.search import SearchLanguage, parse_stop_word
<span class="gd">-finnish_stopwords = parse_stop_word(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+finnish_stopwords = parse_stop_word(&#39;&#39;&#39;</span>
<span class="w"> </span>| source: https://snowball.tartarus.org/algorithms/finnish/stop.txt
<span class="w"> </span>| forms of BE

<span class="gu">@@ -93,8 +97,7 @@ kun    | when</span>
<span class="w"> </span>niin   | so
<span class="w"> </span>nyt    | now
<span class="w"> </span>itse   | self
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    )</span>
<span class="gi">+&#39;&#39;&#39;)</span>


<span class="w"> </span>class SearchFinnish(SearchLanguage):
<span class="gu">@@ -102,3 +105,9 @@ class SearchFinnish(SearchLanguage):</span>
<span class="w"> </span>    language_name = &#39;Finnish&#39;
<span class="w"> </span>    js_stemmer_rawcode = &#39;finnish-stemmer.js&#39;
<span class="w"> </span>    stopwords = finnish_stopwords
<span class="gi">+</span>
<span class="gi">+    def init(self, options: dict[str, str]) -&gt; None:</span>
<span class="gi">+        self.stemmer = snowballstemmer.stemmer(&#39;finnish&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def stem(self, word: str) -&gt; str:</span>
<span class="gi">+        return self.stemmer.stemWord(word.lower())</span>
<span class="gh">diff --git a/sphinx/search/fr.py b/sphinx/search/fr.py</span>
<span class="gh">index 8e0f75484..4d41cf442 100644</span>
<span class="gd">--- a/sphinx/search/fr.py</span>
<span class="gi">+++ b/sphinx/search/fr.py</span>
<span class="gu">@@ -1,10 +1,14 @@</span>
<span class="w"> </span>&quot;&quot;&quot;French search language: includes the JS French stemmer.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Dict
<span class="gi">+</span>
<span class="w"> </span>import snowballstemmer
<span class="gi">+</span>
<span class="w"> </span>from sphinx.search import SearchLanguage, parse_stop_word
<span class="gd">-french_stopwords = parse_stop_word(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+french_stopwords = parse_stop_word(&#39;&#39;&#39;</span>
<span class="w"> </span>| source: https://snowball.tartarus.org/algorithms/french/stop.txt
<span class="w"> </span>au             |  a + le
<span class="w"> </span>aux            |  a + les
<span class="gu">@@ -179,8 +183,7 @@ quelle         |  which</span>
<span class="w"> </span>quelles        |  which
<span class="w"> </span>sans           |  without
<span class="w"> </span>soi            |  oneself
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    )</span>
<span class="gi">+&#39;&#39;&#39;)</span>


<span class="w"> </span>class SearchFrench(SearchLanguage):
<span class="gu">@@ -188,3 +191,9 @@ class SearchFrench(SearchLanguage):</span>
<span class="w"> </span>    language_name = &#39;French&#39;
<span class="w"> </span>    js_stemmer_rawcode = &#39;french-stemmer.js&#39;
<span class="w"> </span>    stopwords = french_stopwords
<span class="gi">+</span>
<span class="gi">+    def init(self, options: dict[str, str]) -&gt; None:</span>
<span class="gi">+        self.stemmer = snowballstemmer.stemmer(&#39;french&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def stem(self, word: str) -&gt; str:</span>
<span class="gi">+        return self.stemmer.stemWord(word.lower())</span>
<span class="gh">diff --git a/sphinx/search/hu.py b/sphinx/search/hu.py</span>
<span class="gh">index 0f9193750..ccd6ebec3 100644</span>
<span class="gd">--- a/sphinx/search/hu.py</span>
<span class="gi">+++ b/sphinx/search/hu.py</span>
<span class="gu">@@ -1,10 +1,14 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Hungarian search language: includes the JS Hungarian stemmer.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Dict
<span class="gi">+</span>
<span class="w"> </span>import snowballstemmer
<span class="gi">+</span>
<span class="w"> </span>from sphinx.search import SearchLanguage, parse_stop_word
<span class="gd">-hungarian_stopwords = parse_stop_word(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+hungarian_stopwords = parse_stop_word(&#39;&#39;&#39;</span>
<span class="w"> </span>| source: https://snowball.tartarus.org/algorithms/hungarian/stop.txt
<span class="w"> </span>| prepared by Anna Tordai
<span class="w"> </span>a
<span class="gu">@@ -206,8 +210,7 @@ vissza</span>
<span class="w"> </span>vele
<span class="w"> </span>viszont
<span class="w"> </span>volna
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    )</span>
<span class="gi">+&#39;&#39;&#39;)</span>


<span class="w"> </span>class SearchHungarian(SearchLanguage):
<span class="gu">@@ -215,3 +218,9 @@ class SearchHungarian(SearchLanguage):</span>
<span class="w"> </span>    language_name = &#39;Hungarian&#39;
<span class="w"> </span>    js_stemmer_rawcode = &#39;hungarian-stemmer.js&#39;
<span class="w"> </span>    stopwords = hungarian_stopwords
<span class="gi">+</span>
<span class="gi">+    def init(self, options: dict[str, str]) -&gt; None:</span>
<span class="gi">+        self.stemmer = snowballstemmer.stemmer(&#39;hungarian&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def stem(self, word: str) -&gt; str:</span>
<span class="gi">+        return self.stemmer.stemWord(word.lower())</span>
<span class="gh">diff --git a/sphinx/search/it.py b/sphinx/search/it.py</span>
<span class="gh">index a3e7c45ce..8436dfa5b 100644</span>
<span class="gd">--- a/sphinx/search/it.py</span>
<span class="gi">+++ b/sphinx/search/it.py</span>
<span class="gu">@@ -1,10 +1,14 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Italian search language: includes the JS Italian stemmer.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Dict
<span class="gi">+</span>
<span class="w"> </span>import snowballstemmer
<span class="gi">+</span>
<span class="w"> </span>from sphinx.search import SearchLanguage, parse_stop_word
<span class="gd">-italian_stopwords = parse_stop_word(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+italian_stopwords = parse_stop_word(&#39;&#39;&#39;</span>
<span class="w"> </span>| source: https://snowball.tartarus.org/algorithms/italian/stop.txt
<span class="w"> </span>ad             |  a (to) before vowel
<span class="w"> </span>al             |  a + il
<span class="gu">@@ -296,8 +300,7 @@ stessi</span>
<span class="w"> </span>stesse
<span class="w"> </span>stessimo
<span class="w"> </span>stessero
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    )</span>
<span class="gi">+&#39;&#39;&#39;)</span>


<span class="w"> </span>class SearchItalian(SearchLanguage):
<span class="gu">@@ -305,3 +308,9 @@ class SearchItalian(SearchLanguage):</span>
<span class="w"> </span>    language_name = &#39;Italian&#39;
<span class="w"> </span>    js_stemmer_rawcode = &#39;italian-stemmer.js&#39;
<span class="w"> </span>    stopwords = italian_stopwords
<span class="gi">+</span>
<span class="gi">+    def init(self, options: dict[str, str]) -&gt; None:</span>
<span class="gi">+        self.stemmer = snowballstemmer.stemmer(&#39;italian&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def stem(self, word: str) -&gt; str:</span>
<span class="gi">+        return self.stemmer.stemWord(word.lower())</span>
<span class="gh">diff --git a/sphinx/search/ja.py b/sphinx/search/ja.py</span>
<span class="gh">index 703d7260b..7ff663292 100644</span>
<span class="gd">--- a/sphinx/search/ja.py</span>
<span class="gi">+++ b/sphinx/search/ja.py</span>
<span class="gu">@@ -1,41 +1,52 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Japanese search language: includes routine to split words.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+# Python Version of TinySegmenter</span>
<span class="gi">+# (https://chasen.org/~taku/software/TinySegmenter/)</span>
<span class="gi">+# TinySegmenter is super compact Japanese tokenizer.</span>
<span class="gi">+#</span>
<span class="gi">+# TinySegmenter was originally developed by Taku Kudo &lt;taku(at)chasen.org&gt;.</span>
<span class="gi">+# Python Version was developed by xnights &lt;programming.magic(at)gmail.com&gt;.</span>
<span class="gi">+# For details, see https://programming-magic.com/?id=170</span>
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import re
<span class="w"> </span>import sys
<span class="w"> </span>from typing import Any
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="gd">-    import MeCab</span>
<span class="gi">+    import MeCab  # type: ignore[import-not-found]</span>
<span class="w"> </span>    native_module = True
<span class="w"> </span>except ImportError:
<span class="w"> </span>    native_module = False
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="gd">-    import janome.tokenizer</span>
<span class="gi">+    import janome.tokenizer  # type: ignore[import-not-found]</span>
<span class="w"> </span>    janome_module = True
<span class="w"> </span>except ImportError:
<span class="w"> </span>    janome_module = False
<span class="gi">+</span>
<span class="w"> </span>from sphinx.errors import ExtensionError, SphinxError
<span class="w"> </span>from sphinx.search import SearchLanguage
<span class="w"> </span>from sphinx.util._importer import import_object


<span class="w"> </span>class BaseSplitter:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, options: dict[str, str]) -&gt;None:</span>
<span class="gi">+    def __init__(self, options: dict[str, str]) -&gt; None:</span>
<span class="w"> </span>        self.options = options

<span class="gd">-    def split(self, input: str) -&gt;list[str]:</span>
<span class="gi">+    def split(self, input: str) -&gt; list[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :param str input:
<span class="w"> </span>        :return:
<span class="w"> </span>        :rtype: list[str]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>


<span class="w"> </span>class MecabSplitter(BaseSplitter):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, options: dict[str, str]) -&gt;None:</span>
<span class="gi">+    def __init__(self, options: dict[str, str]) -&gt; None:</span>
<span class="w"> </span>        super().__init__(options)
<span class="w"> </span>        self.ctypes_libmecab: Any = None
<span class="w"> </span>        self.ctypes_mecab: Any = None
<span class="gu">@@ -45,282 +56,444 @@ class MecabSplitter(BaseSplitter):</span>
<span class="w"> </span>            self.init_native(options)
<span class="w"> </span>        self.dict_encode = options.get(&#39;dic_enc&#39;, &#39;utf-8&#39;)

<span class="gd">-    def __del__(self) -&gt;None:</span>
<span class="gi">+    def split(self, input: str) -&gt; list[str]:</span>
<span class="gi">+        if native_module:</span>
<span class="gi">+            result = self.native.parse(input)</span>
<span class="gi">+        else:</span>
<span class="gi">+            result = self.ctypes_libmecab.mecab_sparse_tostr(</span>
<span class="gi">+                self.ctypes_mecab, input.encode(self.dict_encode))</span>
<span class="gi">+        return result.split(&#39; &#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def init_native(self, options: dict[str, str]) -&gt; None:</span>
<span class="gi">+        param = &#39;-Owakati&#39;</span>
<span class="gi">+        dict = options.get(&#39;dict&#39;)</span>
<span class="gi">+        if dict:</span>
<span class="gi">+            param += &#39; -d %s&#39; % dict</span>
<span class="gi">+        self.native = MeCab.Tagger(param)</span>
<span class="gi">+</span>
<span class="gi">+    def init_ctypes(self, options: dict[str, str]) -&gt; None:</span>
<span class="gi">+        import ctypes.util</span>
<span class="gi">+</span>
<span class="gi">+        lib = options.get(&#39;lib&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if lib is None:</span>
<span class="gi">+            if sys.platform.startswith(&#39;win&#39;):</span>
<span class="gi">+                libname = &#39;libmecab.dll&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                libname = &#39;mecab&#39;</span>
<span class="gi">+            libpath = ctypes.util.find_library(libname)</span>
<span class="gi">+        elif os.path.basename(lib) == lib:</span>
<span class="gi">+            libpath = ctypes.util.find_library(lib)</span>
<span class="gi">+        else:</span>
<span class="gi">+            libpath = None</span>
<span class="gi">+            if os.path.exists(lib):</span>
<span class="gi">+                libpath = lib</span>
<span class="gi">+        if libpath is None:</span>
<span class="gi">+            raise RuntimeError(&#39;MeCab dynamic library is not available&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        param = &#39;mecab -Owakati&#39;</span>
<span class="gi">+        dict = options.get(&#39;dict&#39;)</span>
<span class="gi">+        if dict:</span>
<span class="gi">+            param += &#39; -d %s&#39; % dict</span>
<span class="gi">+</span>
<span class="gi">+        fs_enc = sys.getfilesystemencoding() or sys.getdefaultencoding()</span>
<span class="gi">+</span>
<span class="gi">+        self.ctypes_libmecab = ctypes.CDLL(libpath)</span>
<span class="gi">+        self.ctypes_libmecab.mecab_new2.argtypes = (ctypes.c_char_p,)</span>
<span class="gi">+        self.ctypes_libmecab.mecab_new2.restype = ctypes.c_void_p</span>
<span class="gi">+        self.ctypes_libmecab.mecab_sparse_tostr.argtypes = (ctypes.c_void_p, ctypes.c_char_p)</span>
<span class="gi">+        self.ctypes_libmecab.mecab_sparse_tostr.restype = ctypes.c_char_p</span>
<span class="gi">+        self.ctypes_mecab = self.ctypes_libmecab.mecab_new2(param.encode(fs_enc))</span>
<span class="gi">+        if self.ctypes_mecab is None:</span>
<span class="gi">+            raise SphinxError(&#39;mecab initialization failed&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def __del__(self) -&gt; None:</span>
<span class="w"> </span>        if self.ctypes_libmecab:
<span class="w"> </span>            self.ctypes_libmecab.mecab_destroy(self.ctypes_mecab)


<span class="w"> </span>class JanomeSplitter(BaseSplitter):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, options: dict[str, str]) -&gt;None:</span>
<span class="gi">+    def __init__(self, options: dict[str, str]) -&gt; None:</span>
<span class="w"> </span>        super().__init__(options)
<span class="w"> </span>        self.user_dict = options.get(&#39;user_dic&#39;)
<span class="w"> </span>        self.user_dict_enc = options.get(&#39;user_dic_enc&#39;, &#39;utf8&#39;)
<span class="w"> </span>        self.init_tokenizer()

<span class="gi">+    def init_tokenizer(self) -&gt; None:</span>
<span class="gi">+        if not janome_module:</span>
<span class="gi">+            raise RuntimeError(&#39;Janome is not available&#39;)</span>
<span class="gi">+        self.tokenizer = janome.tokenizer.Tokenizer(udic=self.user_dict, udic_enc=self.user_dict_enc)</span>
<span class="gi">+</span>
<span class="gi">+    def split(self, input: str) -&gt; list[str]:</span>
<span class="gi">+        result = &#39; &#39;.join(token.surface for token in self.tokenizer.tokenize(input))</span>
<span class="gi">+        return result.split(&#39; &#39;)</span>
<span class="gi">+</span>

<span class="w"> </span>class DefaultSplitter(BaseSplitter):
<span class="w"> </span>    patterns_ = {re.compile(pattern): value for pattern, value in {
<span class="gd">-        &#39;[]&#39;: &#39;M&#39;, &#39;[-]&#39;: &#39;H&#39;, &#39;[-]&#39;: &#39;I&#39;,</span>
<span class="gd">-        &#39;[--]&#39;: &#39;K&#39;, &#39;[a-zA-Z--]&#39;: &#39;A&#39;, &#39;[0-9-]&#39;: &#39;N&#39;}.items()}</span>
<span class="gi">+        &#39;[]&#39;: &#39;M&#39;,</span>
<span class="gi">+        &#39;[-]&#39;: &#39;H&#39;,</span>
<span class="gi">+        &#39;[-]&#39;: &#39;I&#39;,</span>
<span class="gi">+        &#39;[--]&#39;: &#39;K&#39;,</span>
<span class="gi">+        &#39;[a-zA-Z--]&#39;: &#39;A&#39;,</span>
<span class="gi">+        &#39;[0-9-]&#39;: &#39;N&#39;,</span>
<span class="gi">+    }.items()}</span>
<span class="w"> </span>    BIAS__ = -332
<span class="w"> </span>    BC1__ = {&#39;HH&#39;: 6, &#39;II&#39;: 2461, &#39;KH&#39;: 406, &#39;OH&#39;: -1378}
<span class="w"> </span>    BC2__ = {&#39;AA&#39;: -3267, &#39;AI&#39;: 2744, &#39;AN&#39;: -878, &#39;HH&#39;: -4070, &#39;HM&#39;: -1711,
<span class="gd">-        &#39;HN&#39;: 4012, &#39;HO&#39;: 3761, &#39;IA&#39;: 1327, &#39;IH&#39;: -1184, &#39;II&#39;: -1332, &#39;IK&#39;:</span>
<span class="gd">-        1721, &#39;IO&#39;: 5492, &#39;KI&#39;: 3831, &#39;KK&#39;: -8741, &#39;MH&#39;: -3132, &#39;MK&#39;: 3334,</span>
<span class="gd">-        &#39;OO&#39;: -2920}</span>
<span class="gd">-    BC3__ = {&#39;HH&#39;: 996, &#39;HI&#39;: 626, &#39;HK&#39;: -721, &#39;HN&#39;: -1307, &#39;HO&#39;: -836,</span>
<span class="gd">-        &#39;IH&#39;: -301, &#39;KK&#39;: 2762, &#39;MK&#39;: 1079, &#39;MM&#39;: 4034, &#39;OA&#39;: -1652, &#39;OH&#39;: 266}</span>
<span class="gi">+             &#39;HN&#39;: 4012, &#39;HO&#39;: 3761, &#39;IA&#39;: 1327, &#39;IH&#39;: -1184, &#39;II&#39;: -1332,</span>
<span class="gi">+             &#39;IK&#39;: 1721, &#39;IO&#39;: 5492, &#39;KI&#39;: 3831, &#39;KK&#39;: -8741, &#39;MH&#39;: -3132,</span>
<span class="gi">+             &#39;MK&#39;: 3334, &#39;OO&#39;: -2920}</span>
<span class="gi">+    BC3__ = {&#39;HH&#39;: 996, &#39;HI&#39;: 626, &#39;HK&#39;: -721, &#39;HN&#39;: -1307, &#39;HO&#39;: -836, &#39;IH&#39;: -301,</span>
<span class="gi">+             &#39;KK&#39;: 2762, &#39;MK&#39;: 1079, &#39;MM&#39;: 4034, &#39;OA&#39;: -1652, &#39;OH&#39;: 266}</span>
<span class="w"> </span>    BP1__ = {&#39;BB&#39;: 295, &#39;OB&#39;: 304, &#39;OO&#39;: -125, &#39;UB&#39;: 352}
<span class="w"> </span>    BP2__ = {&#39;BO&#39;: 60, &#39;OO&#39;: -1762}
<span class="gd">-    BQ1__ = {&#39;BHH&#39;: 1150, &#39;BHM&#39;: 1521, &#39;BII&#39;: -1158, &#39;BIM&#39;: 886, &#39;BMH&#39;: </span>
<span class="gd">-        1208, &#39;BNH&#39;: 449, &#39;BOH&#39;: -91, &#39;BOO&#39;: -2597, &#39;OHI&#39;: 451, &#39;OIH&#39;: -296,</span>
<span class="gd">-        &#39;OKA&#39;: 1851, &#39;OKH&#39;: -1020, &#39;OKK&#39;: 904, &#39;OOO&#39;: 2965}</span>
<span class="gd">-    BQ2__ = {&#39;BHH&#39;: 118, &#39;BHI&#39;: -1159, &#39;BHM&#39;: 466, &#39;BIH&#39;: -919, &#39;BKK&#39;: -</span>
<span class="gd">-        1720, &#39;BKO&#39;: 864, &#39;OHH&#39;: -1139, &#39;OHM&#39;: -181, &#39;OIH&#39;: 153, &#39;UHI&#39;: -1146}</span>
<span class="gi">+    BQ1__ = {&#39;BHH&#39;: 1150, &#39;BHM&#39;: 1521, &#39;BII&#39;: -1158, &#39;BIM&#39;: 886, &#39;BMH&#39;: 1208,</span>
<span class="gi">+             &#39;BNH&#39;: 449, &#39;BOH&#39;: -91, &#39;BOO&#39;: -2597, &#39;OHI&#39;: 451, &#39;OIH&#39;: -296,</span>
<span class="gi">+             &#39;OKA&#39;: 1851, &#39;OKH&#39;: -1020, &#39;OKK&#39;: 904, &#39;OOO&#39;: 2965}</span>
<span class="gi">+    BQ2__ = {&#39;BHH&#39;: 118, &#39;BHI&#39;: -1159, &#39;BHM&#39;: 466, &#39;BIH&#39;: -919, &#39;BKK&#39;: -1720,</span>
<span class="gi">+             &#39;BKO&#39;: 864, &#39;OHH&#39;: -1139, &#39;OHM&#39;: -181, &#39;OIH&#39;: 153, &#39;UHI&#39;: -1146}</span>
<span class="w"> </span>    BQ3__ = {&#39;BHH&#39;: -792, &#39;BHI&#39;: 2664, &#39;BII&#39;: -299, &#39;BKI&#39;: 419, &#39;BMH&#39;: 937,
<span class="gd">-        &#39;BMM&#39;: 8335, &#39;BNN&#39;: 998, &#39;BOH&#39;: 775, &#39;OHH&#39;: 2174, &#39;OHM&#39;: 439, &#39;OII&#39;:</span>
<span class="gd">-        280, &#39;OKH&#39;: 1798, &#39;OKI&#39;: -793, &#39;OKO&#39;: -2242, &#39;OMH&#39;: -2402, &#39;OOO&#39;: 11699</span>
<span class="gd">-        }</span>
<span class="gd">-    BQ4__ = {&#39;BHH&#39;: -3895, &#39;BIH&#39;: 3761, &#39;BII&#39;: -4654, &#39;BIK&#39;: 1348, &#39;BKK&#39;: -</span>
<span class="gd">-        1806, &#39;BMI&#39;: -3385, &#39;BOO&#39;: -12396, &#39;OAH&#39;: 926, &#39;OHH&#39;: 266, &#39;OHK&#39;: -</span>
<span class="gd">-        2036, &#39;ONN&#39;: -973}</span>
<span class="gd">-    BW1__ = {&#39;,&#39;: 660, &#39;,&#39;: 727, &#39;B1&#39;: 1404, &#39;B1&#39;: 542, &#39;&#39;: 660, &#39;&#39;:</span>
<span class="gd">-        727, &#39;&#39;: 1682, &#39;&#39;: 1505, &#39;&#39;: 1743, &#39;&#39;: -2055, &#39;&#39;: 672,</span>
<span class="gd">-        &#39;&#39;: -4817, &#39;&#39;: 665, &#39;&#39;: 3472, &#39;&#39;: 600, &#39;&#39;: -790, &#39;&#39;: </span>
<span class="gd">-        2083, &#39;&#39;: -1262, &#39;&#39;: -4143, &#39;&#39;: 4573, &#39;&#39;: 2641, &#39;&#39;: 1104,</span>
<span class="gd">-        &#39;&#39;: -3399, &#39;&#39;: 1977, &#39;&#39;: -871, &#39;&#39;: 1122, &#39;&#39;: 601, &#39;&#39;: </span>
<span class="gd">-        3463, &#39;&#39;: -802, &#39;&#39;: 805, &#39;&#39;: 1249, &#39;&#39;: 1127, &#39;&#39;: 3445,</span>
<span class="gd">-        &#39;&#39;: 844, &#39;&#39;: -4915, &#39;&#39;: 1922, &#39;&#39;: 3887, &#39;&#39;: 5713, &#39;&#39;: </span>
<span class="gd">-        3015, &#39;&#39;: 7379, &#39;&#39;: -1113, &#39;&#39;: 2468, &#39;&#39;: 1498, &#39;&#39;: 1671,</span>
<span class="gd">-        &#39;&#39;: -912, &#39;&#39;: -501, &#39;&#39;: 741, &#39;&#39;: 2448, &#39;&#39;: 1711, &#39;&#39;: </span>
<span class="gd">-        2600, &#39;&#39;: -2155, &#39;&#39;: -1947, &#39;&#39;: -2565, &#39;&#39;: 2369, &#39;&#39;: -913,</span>
<span class="gd">-        &#39;&#39;: 1860, &#39;&#39;: 731, &#39;&#39;: -1886, &#39;&#39;: 2558, &#39;&#39;: -2784, &#39;&#39;: </span>
<span class="gd">-        -2604, &#39;&#39;: 1497, &#39;&#39;: -2314, &#39;&#39;: -1336, &#39;&#39;: -195, &#39;&#39;: -</span>
<span class="gd">-        2423, &#39;&#39;: -2113, &#39;&#39;: -724, &#39;&#39;: 1404, &#39;&#39;: 542, &#39;&#39;: 1682}</span>
<span class="gd">-    BW2__ = {&#39;..&#39;: -11822, &#39;11&#39;: -669, &#39;&#39;: -5730, &#39;&#39;: -13175, &#39;&#39;: -</span>
<span class="gd">-        1609, &#39;&#39;: 2490, &#39;&#39;: -1350, &#39;&#39;: -602, &#39;&#39;: -7194, &#39;&#39;: 4612,</span>
<span class="gd">-        &#39;&#39;: 853, &#39;&#39;: -3198, &#39;&#39;: 1941, &#39;&#39;: -1597, &#39;&#39;: -8392, &#39;&#39;:</span>
<span class="gd">-        -4193, &#39;&#39;: 4533, &#39;&#39;: 13168, &#39;&#39;: -3977, &#39;&#39;: -1819, &#39;&#39;: -</span>
<span class="gd">-        545, &#39;&#39;: 5078, &#39;&#39;: 972, &#39;&#39;: 939, &#39;&#39;: -3744, &#39;&#39;: -1253,</span>
<span class="gd">-        &#39;&#39;: -662, &#39;&#39;: -3857, &#39;&#39;: -786, &#39;&#39;: 1224, &#39;&#39;: -939, &#39;&#39;: </span>
<span class="gd">-        4589, &#39;&#39;: 1647, &#39;&#39;: -2094, &#39;&#39;: 6144, &#39;&#39;: 3640, &#39;&#39;: 2551,</span>
<span class="gd">-        &#39;&#39;: -3110, &#39;&#39;: -3065, &#39;&#39;: 2666, &#39;&#39;: -1528, &#39;&#39;: -3828,</span>
<span class="gd">-        &#39;&#39;: -4761, &#39;&#39;: -4203, &#39;&#39;: 1890, &#39;&#39;: -1746, &#39;&#39;: -2279,</span>
<span class="gd">-        &#39;&#39;: 720, &#39;&#39;: 5168, &#39;&#39;: -3941, &#39;&#39;: -2488, &#39;&#39;: -1313, &#39;&#39;:</span>
<span class="gd">-        -6509, &#39;&#39;: 2614, &#39;&#39;: 3099, &#39;&#39;: -1615, &#39;&#39;: 2748, &#39;&#39;: 2454,</span>
<span class="gd">-        &#39;&#39;: -7236, &#39;&#39;: -14943, &#39;&#39;: -4688, &#39;&#39;: -11388, &#39;&#39;: 2093,</span>
<span class="gd">-        &#39;&#39;: -7059, &#39;&#39;: -6041, &#39;&#39;: -6125, &#39;&#39;: 1073, &#39;&#39;: -1033,</span>
<span class="gd">-        &#39;&#39;: -2532, &#39;&#39;: 1813, &#39;&#39;: -1316, &#39;&#39;: -6621, &#39;&#39;: 5409, &#39;&#39;:</span>
<span class="gd">-        -3153, &#39;&#39;: 2230, &#39;&#39;: -10713, &#39;&#39;: -944, &#39;&#39;: -1611, &#39;&#39;: -</span>
<span class="gd">-        1897, &#39;&#39;: 651, &#39;&#39;: 1620, &#39;&#39;: 4270, &#39;&#39;: 849, &#39;&#39;: 4114,</span>
<span class="gd">-        &#39;&#39;: 6067, &#39;&#39;: 7901, &#39;&#39;: -11877, &#39;&#39;: 728, &#39;&#39;: -4115, &#39;&#39;:</span>
<span class="gd">-        602, &#39;&#39;: -1375, &#39;&#39;: 970, &#39;&#39;: -1051, &#39;&#39;: -4479, &#39;&#39;: -1116,</span>
<span class="gd">-        &#39;&#39;: 2163, &#39;&#39;: -7758, &#39;&#39;: 970, &#39;&#39;: -913, &#39;&#39;: -2471, &#39;&#39;: </span>
<span class="gd">-        -1250, &#39;&#39;: -1050, &#39;&#39;: -8669, &#39;&#39;: -1626, &#39;&#39;: -2363, &#39;&#39;: -</span>
<span class="gd">-        1982, &#39;&#39;: -4066, &#39;&#39;: -722, &#39;&#39;: -7068, &#39;&#39;: 3372, &#39;&#39;: -601,</span>
<span class="gd">-        &#39;&#39;: -2355, &#39;&#39;: -2697, &#39;&#39;: -1543, &#39;&#39;: -1384, &#39;&#39;: -1276,</span>
<span class="gd">-        &#39;&#39;: -990, &#39;&#39;: -1612, &#39;&#39;: -4268, &#39;&#39;: -669}</span>
<span class="gi">+             &#39;BMM&#39;: 8335, &#39;BNN&#39;: 998, &#39;BOH&#39;: 775, &#39;OHH&#39;: 2174, &#39;OHM&#39;: 439, &#39;OII&#39;: 280,</span>
<span class="gi">+             &#39;OKH&#39;: 1798, &#39;OKI&#39;: -793, &#39;OKO&#39;: -2242, &#39;OMH&#39;: -2402, &#39;OOO&#39;: 11699}</span>
<span class="gi">+    BQ4__ = {&#39;BHH&#39;: -3895, &#39;BIH&#39;: 3761, &#39;BII&#39;: -4654, &#39;BIK&#39;: 1348, &#39;BKK&#39;: -1806,</span>
<span class="gi">+             &#39;BMI&#39;: -3385, &#39;BOO&#39;: -12396, &#39;OAH&#39;: 926, &#39;OHH&#39;: 266, &#39;OHK&#39;: -2036,</span>
<span class="gi">+             &#39;ONN&#39;: -973}</span>
<span class="gi">+    BW1__ = {&#39;,&#39;: 660, &#39;,&#39;: 727, &#39;B1&#39;: 1404, &#39;B1&#39;: 542, &#39;&#39;: 660,</span>
<span class="gi">+             &#39;&#39;: 727, &#39;&#39;: 1682, &#39;&#39;: 1505, &#39;&#39;: 1743, &#39;&#39;: -2055,</span>
<span class="gi">+             &#39;&#39;: 672, &#39;&#39;: -4817, &#39;&#39;: 665, &#39;&#39;: 3472, &#39;&#39;: 600,</span>
<span class="gi">+             &#39;&#39;: -790, &#39;&#39;: 2083, &#39;&#39;: -1262, &#39;&#39;: -4143, &#39;&#39;: 4573,</span>
<span class="gi">+             &#39;&#39;: 2641, &#39;&#39;: 1104, &#39;&#39;: -3399, &#39;&#39;: 1977, &#39;&#39;: -871,</span>
<span class="gi">+             &#39;&#39;: 1122, &#39;&#39;: 601, &#39;&#39;: 3463, &#39;&#39;: -802, &#39;&#39;: 805,</span>
<span class="gi">+             &#39;&#39;: 1249, &#39;&#39;: 1127, &#39;&#39;: 3445, &#39;&#39;: 844, &#39;&#39;: -4915,</span>
<span class="gi">+             &#39;&#39;: 1922, &#39;&#39;: 3887, &#39;&#39;: 5713, &#39;&#39;: 3015, &#39;&#39;: 7379,</span>
<span class="gi">+             &#39;&#39;: -1113, &#39;&#39;: 2468, &#39;&#39;: 1498, &#39;&#39;: 1671, &#39;&#39;: -912,</span>
<span class="gi">+             &#39;&#39;: -501, &#39;&#39;: 741, &#39;&#39;: 2448, &#39;&#39;: 1711, &#39;&#39;: 2600,</span>
<span class="gi">+             &#39;&#39;: -2155, &#39;&#39;: -1947, &#39;&#39;: -2565, &#39;&#39;: 2369, &#39;&#39;: -913,</span>
<span class="gi">+             &#39;&#39;: 1860, &#39;&#39;: 731, &#39;&#39;: -1886, &#39;&#39;: 2558, &#39;&#39;: -2784,</span>
<span class="gi">+             &#39;&#39;: -2604, &#39;&#39;: 1497, &#39;&#39;: -2314, &#39;&#39;: -1336, &#39;&#39;: -195,</span>
<span class="gi">+             &#39;&#39;: -2423, &#39;&#39;: -2113, &#39;&#39;: -724, &#39;&#39;: 1404, &#39;&#39;: 542,</span>
<span class="gi">+             &#39;&#39;: 1682}</span>
<span class="gi">+    BW2__ = {&#39;..&#39;: -11822, &#39;11&#39;: -669, &#39;&#39;: -5730, &#39;&#39;: -13175, &#39;&#39;: -1609,</span>
<span class="gi">+             &#39;&#39;: 2490, &#39;&#39;: -1350, &#39;&#39;: -602, &#39;&#39;: -7194, &#39;&#39;: 4612,</span>
<span class="gi">+             &#39;&#39;: 853, &#39;&#39;: -3198, &#39;&#39;: 1941, &#39;&#39;: -1597, &#39;&#39;: -8392,</span>
<span class="gi">+             &#39;&#39;: -4193, &#39;&#39;: 4533, &#39;&#39;: 13168, &#39;&#39;: -3977, &#39;&#39;: -1819,</span>
<span class="gi">+             &#39;&#39;: -545, &#39;&#39;: 5078, &#39;&#39;: 972, &#39;&#39;: 939, &#39;&#39;: -3744,</span>
<span class="gi">+             &#39;&#39;: -1253, &#39;&#39;: -662, &#39;&#39;: -3857, &#39;&#39;: -786, &#39;&#39;: 1224,</span>
<span class="gi">+             &#39;&#39;: -939, &#39;&#39;: 4589, &#39;&#39;: 1647, &#39;&#39;: -2094, &#39;&#39;: 6144,</span>
<span class="gi">+             &#39;&#39;: 3640, &#39;&#39;: 2551, &#39;&#39;: -3110, &#39;&#39;: -3065, &#39;&#39;: 2666,</span>
<span class="gi">+             &#39;&#39;: -1528, &#39;&#39;: -3828, &#39;&#39;: -4761, &#39;&#39;: -4203, &#39;&#39;: 1890,</span>
<span class="gi">+             &#39;&#39;: -1746, &#39;&#39;: -2279, &#39;&#39;: 720, &#39;&#39;: 5168, &#39;&#39;: -3941,</span>
<span class="gi">+             &#39;&#39;: -2488, &#39;&#39;: -1313, &#39;&#39;: -6509, &#39;&#39;: 2614, &#39;&#39;: 3099,</span>
<span class="gi">+             &#39;&#39;: -1615, &#39;&#39;: 2748, &#39;&#39;: 2454, &#39;&#39;: -7236, &#39;&#39;: -14943,</span>
<span class="gi">+             &#39;&#39;: -4688, &#39;&#39;: -11388, &#39;&#39;: 2093, &#39;&#39;: -7059, &#39;&#39;: -6041,</span>
<span class="gi">+             &#39;&#39;: -6125, &#39;&#39;: 1073, &#39;&#39;: -1033, &#39;&#39;: -2532, &#39;&#39;: 1813,</span>
<span class="gi">+             &#39;&#39;: -1316, &#39;&#39;: -6621, &#39;&#39;: 5409, &#39;&#39;: -3153, &#39;&#39;: 2230,</span>
<span class="gi">+             &#39;&#39;: -10713, &#39;&#39;: -944, &#39;&#39;: -1611, &#39;&#39;: -1897, &#39;&#39;: 651,</span>
<span class="gi">+             &#39;&#39;: 1620, &#39;&#39;: 4270, &#39;&#39;: 849, &#39;&#39;: 4114, &#39;&#39;: 6067,</span>
<span class="gi">+             &#39;&#39;: 7901, &#39;&#39;: -11877, &#39;&#39;: 728, &#39;&#39;: -4115, &#39;&#39;: 602,</span>
<span class="gi">+             &#39;&#39;: -1375, &#39;&#39;: 970, &#39;&#39;: -1051, &#39;&#39;: -4479, &#39;&#39;: -1116,</span>
<span class="gi">+             &#39;&#39;: 2163, &#39;&#39;: -7758, &#39;&#39;: 970, &#39;&#39;: -913, &#39;&#39;: -2471,</span>
<span class="gi">+             &#39;&#39;: -1250, &#39;&#39;: -1050, &#39;&#39;: -8669, &#39;&#39;: -1626, &#39;&#39;: -2363,</span>
<span class="gi">+             &#39;&#39;: -1982, &#39;&#39;: -4066, &#39;&#39;: -722, &#39;&#39;: -7068, &#39;&#39;: 3372,</span>
<span class="gi">+             &#39;&#39;: -601, &#39;&#39;: -2355, &#39;&#39;: -2697, &#39;&#39;: -1543, &#39;&#39;: -1384,</span>
<span class="gi">+             &#39;&#39;: -1276, &#39;&#39;: -990, &#39;&#39;: -1612, &#39;&#39;: -4268, &#39;&#39;: -669}</span>
<span class="w"> </span>    BW3__ = {&#39;&#39;: -2194, &#39;&#39;: 719, &#39;&#39;: 3846, &#39;.&#39;: -1185, &#39;&#39;: -1185,
<span class="gd">-        &#39;&#39;: 5308, &#39;&#39;: 2079, &#39;&#39;: 3029, &#39;&#39;: 2056, &#39;&#39;: 1883, &#39;&#39;: </span>
<span class="gd">-        5600, &#39;&#39;: 1527, &#39;&#39;: 1117, &#39;&#39;: 4798, &#39;&#39;: 1454, &#39;.&#39;: 2857,</span>
<span class="gd">-        &#39;&#39;: 2857, &#39;&#39;: -743, &#39;&#39;: -4098, &#39;&#39;: -669, &#39;&#39;: 6520, &#39;&#39;: </span>
<span class="gd">-        -2670, &#39;,&#39;: 1816, &#39;&#39;: 1816, &#39;&#39;: -4855, &#39;&#39;: -1127, &#39;&#39;: -913,</span>
<span class="gd">-        &#39;&#39;: -4977, &#39;&#39;: -2064, &#39;&#39;: 1645, &#39;&#39;: 1374, &#39;&#39;: 7397, &#39;&#39;:</span>
<span class="gd">-        1542, &#39;&#39;: -2757, &#39;&#39;: -714, &#39;&#39;: 976, &#39;,&#39;: 1557, &#39;&#39;: 1557,</span>
<span class="gd">-        &#39;&#39;: -3714, &#39;&#39;: 3562, &#39;&#39;: 1449, &#39;&#39;: 2608, &#39;&#39;: 1200, &#39;.&#39;: </span>
<span class="gd">-        -1310, &#39;&#39;: -1310, &#39;&#39;: 6521, &#39;,&#39;: 3426, &#39;&#39;: 3426, &#39;&#39;: 841,</span>
<span class="gd">-        &#39;&#39;: 428, &#39;.&#39;: 8875, &#39;&#39;: 8875, &#39;&#39;: -594, &#39;&#39;: 812, &#39;&#39;: -</span>
<span class="gd">-        1183, &#39;&#39;: -853, &#39;.&#39;: 4098, &#39;&#39;: 4098, &#39;&#39;: 1004, &#39;&#39;: -4748,</span>
<span class="gd">-        &#39;&#39;: 300, &#39;&#39;: 6240, &#39;&#39;: 855, &#39;&#39;: 302, &#39;&#39;: 1437, &#39;&#39;: -</span>
<span class="gd">-        1482, &#39;&#39;: 2295, &#39;&#39;: -1387, &#39;&#39;: 2266, &#39;&#39;: 541, &#39;&#39;: -3543,</span>
<span class="gd">-        &#39;&#39;: 4664, &#39;&#39;: 1796, &#39;&#39;: -903, &#39;&#39;: 2135, &#39;,&#39;: -1021, &#39;&#39;: </span>
<span class="gd">-        -1021, &#39;&#39;: 1771, &#39;&#39;: 1906, &#39;&#39;: 2644, &#39;,&#39;: -724, &#39;&#39;: -724,</span>
<span class="gd">-        &#39;&#39;: -1000, &#39;,&#39;: 1337, &#39;&#39;: 1337, &#39;&#39;: 2181, &#39;&#39;: 1113, &#39;&#39;: </span>
<span class="gd">-        6943, &#39;&#39;: -1549, &#39;&#39;: 6154, &#39;&#39;: -793, &#39;&#39;: 1479, &#39;&#39;: 6820,</span>
<span class="gd">-        &#39;&#39;: 3818, &#39;,&#39;: 854, &#39;&#39;: 854, &#39;&#39;: 1850, &#39;&#39;: 1375, &#39;&#39;: -</span>
<span class="gd">-        3246, &#39;&#39;: 1091, &#39;&#39;: -605, &#39;&#39;: 606, &#39;&#39;: 798, &#39;&#39;: 990, &#39;&#39;:</span>
<span class="gd">-        860, &#39;&#39;: 1232, &#39;&#39;: 2217, &#39;&#39;: 1681, &#39;&#39;: 965, &#39;&#39;: -5055,</span>
<span class="gd">-        &#39;,&#39;: 974, &#39;&#39;: 974, &#39;&#39;: 2024, &#39;&#39;: 990}</span>
<span class="gi">+             &#39;&#39;: 5308, &#39;&#39;: 2079, &#39;&#39;: 3029, &#39;&#39;: 2056, &#39;&#39;: 1883,</span>
<span class="gi">+             &#39;&#39;: 5600, &#39;&#39;: 1527, &#39;&#39;: 1117, &#39;&#39;: 4798, &#39;&#39;: 1454,</span>
<span class="gi">+             &#39;.&#39;: 2857, &#39;&#39;: 2857, &#39;&#39;: -743, &#39;&#39;: -4098, &#39;&#39;: -669,</span>
<span class="gi">+             &#39;&#39;: 6520, &#39;&#39;: -2670, &#39;,&#39;: 1816, &#39;&#39;: 1816, &#39;&#39;: -4855,</span>
<span class="gi">+             &#39;&#39;: -1127, &#39;&#39;: -913, &#39;&#39;: -4977, &#39;&#39;: -2064, &#39;&#39;: 1645,</span>
<span class="gi">+             &#39;&#39;: 1374, &#39;&#39;: 7397, &#39;&#39;: 1542, &#39;&#39;: -2757, &#39;&#39;: -714,</span>
<span class="gi">+             &#39;&#39;: 976, &#39;,&#39;: 1557, &#39;&#39;: 1557, &#39;&#39;: -3714, &#39;&#39;: 3562,</span>
<span class="gi">+             &#39;&#39;: 1449, &#39;&#39;: 2608, &#39;&#39;: 1200, &#39;.&#39;: -1310, &#39;&#39;: -1310,</span>
<span class="gi">+             &#39;&#39;: 6521, &#39;,&#39;: 3426, &#39;&#39;: 3426, &#39;&#39;: 841, &#39;&#39;: 428,</span>
<span class="gi">+             &#39;.&#39;: 8875, &#39;&#39;: 8875, &#39;&#39;: -594, &#39;&#39;: 812, &#39;&#39;: -1183,</span>
<span class="gi">+             &#39;&#39;: -853, &#39;.&#39;: 4098, &#39;&#39;: 4098, &#39;&#39;: 1004, &#39;&#39;: -4748,</span>
<span class="gi">+             &#39;&#39;: 300, &#39;&#39;: 6240, &#39;&#39;: 855, &#39;&#39;: 302, &#39;&#39;: 1437,</span>
<span class="gi">+             &#39;&#39;: -1482, &#39;&#39;: 2295, &#39;&#39;: -1387, &#39;&#39;: 2266, &#39;&#39;: 541,</span>
<span class="gi">+             &#39;&#39;: -3543, &#39;&#39;: 4664, &#39;&#39;: 1796, &#39;&#39;: -903, &#39;&#39;: 2135,</span>
<span class="gi">+             &#39;,&#39;: -1021, &#39;&#39;: -1021, &#39;&#39;: 1771, &#39;&#39;: 1906, &#39;&#39;: 2644,</span>
<span class="gi">+             &#39;,&#39;: -724, &#39;&#39;: -724, &#39;&#39;: -1000, &#39;,&#39;: 1337, &#39;&#39;: 1337,</span>
<span class="gi">+             &#39;&#39;: 2181, &#39;&#39;: 1113, &#39;&#39;: 6943, &#39;&#39;: -1549, &#39;&#39;: 6154,</span>
<span class="gi">+             &#39;&#39;: -793, &#39;&#39;: 1479, &#39;&#39;: 6820, &#39;&#39;: 3818, &#39;,&#39;: 854,</span>
<span class="gi">+             &#39;&#39;: 854, &#39;&#39;: 1850, &#39;&#39;: 1375, &#39;&#39;: -3246, &#39;&#39;: 1091,</span>
<span class="gi">+             &#39;&#39;: -605, &#39;&#39;: 606, &#39;&#39;: 798, &#39;&#39;: 990, &#39;&#39;: 860,</span>
<span class="gi">+             &#39;&#39;: 1232, &#39;&#39;: 2217, &#39;&#39;: 1681, &#39;&#39;: 965, &#39;&#39;: -5055,</span>
<span class="gi">+             &#39;,&#39;: 974, &#39;&#39;: 974, &#39;&#39;: 2024, &#39;&#39;: 990}</span>
<span class="w"> </span>    TC1__ = {&#39;AAA&#39;: 1093, &#39;HHH&#39;: 1029, &#39;HHM&#39;: 580, &#39;HII&#39;: 998, &#39;HOH&#39;: -390,
<span class="gd">-        &#39;HOM&#39;: -331, &#39;IHI&#39;: 1169, &#39;IOH&#39;: -142, &#39;IOI&#39;: -1015, &#39;IOM&#39;: 467,</span>
<span class="gd">-        &#39;MMH&#39;: 187, &#39;OOI&#39;: -1832}</span>
<span class="gd">-    TC2__ = {&#39;HHO&#39;: 2088, &#39;HII&#39;: -1023, &#39;HMM&#39;: -1154, &#39;IHI&#39;: -1965, &#39;KKH&#39;: </span>
<span class="gd">-        703, &#39;OII&#39;: -2649}</span>
<span class="gi">+             &#39;HOM&#39;: -331, &#39;IHI&#39;: 1169, &#39;IOH&#39;: -142, &#39;IOI&#39;: -1015, &#39;IOM&#39;: 467,</span>
<span class="gi">+             &#39;MMH&#39;: 187, &#39;OOI&#39;: -1832}</span>
<span class="gi">+    TC2__ = {&#39;HHO&#39;: 2088, &#39;HII&#39;: -1023, &#39;HMM&#39;: -1154, &#39;IHI&#39;: -1965,</span>
<span class="gi">+             &#39;KKH&#39;: 703, &#39;OII&#39;: -2649}</span>
<span class="w"> </span>    TC3__ = {&#39;AAA&#39;: -294, &#39;HHH&#39;: 346, &#39;HHI&#39;: -341, &#39;HII&#39;: -1088, &#39;HIK&#39;: 731,
<span class="gd">-        &#39;HOH&#39;: -1486, &#39;IHH&#39;: 128, &#39;IHI&#39;: -3041, &#39;IHO&#39;: -1935, &#39;IIH&#39;: -825,</span>
<span class="gd">-        &#39;IIM&#39;: -1035, &#39;IOI&#39;: -542, &#39;KHH&#39;: -1216, &#39;KKA&#39;: 491, &#39;KKH&#39;: -1217,</span>
<span class="gd">-        &#39;KOK&#39;: -1009, &#39;MHH&#39;: -2694, &#39;MHM&#39;: -457, &#39;MHO&#39;: 123, &#39;MMH&#39;: -471,</span>
<span class="gd">-        &#39;NNH&#39;: -1689, &#39;NNO&#39;: 662, &#39;OHO&#39;: -3393}</span>
<span class="gi">+             &#39;HOH&#39;: -1486, &#39;IHH&#39;: 128, &#39;IHI&#39;: -3041, &#39;IHO&#39;: -1935, &#39;IIH&#39;: -825,</span>
<span class="gi">+             &#39;IIM&#39;: -1035, &#39;IOI&#39;: -542, &#39;KHH&#39;: -1216, &#39;KKA&#39;: 491, &#39;KKH&#39;: -1217,</span>
<span class="gi">+             &#39;KOK&#39;: -1009, &#39;MHH&#39;: -2694, &#39;MHM&#39;: -457, &#39;MHO&#39;: 123, &#39;MMH&#39;: -471,</span>
<span class="gi">+             &#39;NNH&#39;: -1689, &#39;NNO&#39;: 662, &#39;OHO&#39;: -3393}</span>
<span class="w"> </span>    TC4__ = {&#39;HHH&#39;: -203, &#39;HHI&#39;: 1344, &#39;HHK&#39;: 365, &#39;HHM&#39;: -122, &#39;HHN&#39;: 182,
<span class="gd">-        &#39;HHO&#39;: 669, &#39;HIH&#39;: 804, &#39;HII&#39;: 679, &#39;HOH&#39;: 446, &#39;IHH&#39;: 695, &#39;IHO&#39;: </span>
<span class="gd">-        -2324, &#39;IIH&#39;: 321, &#39;III&#39;: 1497, &#39;IIO&#39;: 656, &#39;IOO&#39;: 54, &#39;KAK&#39;: 4845,</span>
<span class="gd">-        &#39;KKA&#39;: 3386, &#39;KKK&#39;: 3065, &#39;MHH&#39;: -405, &#39;MHI&#39;: 201, &#39;MMH&#39;: -241,</span>
<span class="gd">-        &#39;MMM&#39;: 661, &#39;MOM&#39;: 841}</span>
<span class="gd">-    TQ1__ = {&#39;BHHH&#39;: -227, &#39;BHHI&#39;: 316, &#39;BHIH&#39;: -132, &#39;BIHH&#39;: 60, &#39;BIII&#39;: </span>
<span class="gd">-        1595, &#39;BNHH&#39;: -744, &#39;BOHH&#39;: 225, &#39;BOOO&#39;: -908, &#39;OAKK&#39;: 482, &#39;OHHH&#39;:</span>
<span class="gd">-        281, &#39;OHIH&#39;: 249, &#39;OIHI&#39;: 200, &#39;OIIH&#39;: -68}</span>
<span class="gi">+             &#39;HHO&#39;: 669, &#39;HIH&#39;: 804, &#39;HII&#39;: 679, &#39;HOH&#39;: 446, &#39;IHH&#39;: 695,</span>
<span class="gi">+             &#39;IHO&#39;: -2324, &#39;IIH&#39;: 321, &#39;III&#39;: 1497, &#39;IIO&#39;: 656, &#39;IOO&#39;: 54,</span>
<span class="gi">+             &#39;KAK&#39;: 4845, &#39;KKA&#39;: 3386, &#39;KKK&#39;: 3065, &#39;MHH&#39;: -405, &#39;MHI&#39;: 201,</span>
<span class="gi">+             &#39;MMH&#39;: -241, &#39;MMM&#39;: 661, &#39;MOM&#39;: 841}</span>
<span class="gi">+    TQ1__ = {&#39;BHHH&#39;: -227, &#39;BHHI&#39;: 316, &#39;BHIH&#39;: -132, &#39;BIHH&#39;: 60, &#39;BIII&#39;: 1595,</span>
<span class="gi">+             &#39;BNHH&#39;: -744, &#39;BOHH&#39;: 225, &#39;BOOO&#39;: -908, &#39;OAKK&#39;: 482, &#39;OHHH&#39;: 281,</span>
<span class="gi">+             &#39;OHIH&#39;: 249, &#39;OIHI&#39;: 200, &#39;OIIH&#39;: -68}</span>
<span class="w"> </span>    TQ2__ = {&#39;BIHH&#39;: -1401, &#39;BIII&#39;: -1033, &#39;BKAK&#39;: -543, &#39;BOOO&#39;: -5591}
<span class="gd">-    TQ3__ = {&#39;BHHH&#39;: 478, &#39;BHHM&#39;: -1073, &#39;BHIH&#39;: 222, &#39;BHII&#39;: -504, &#39;BIIH&#39;:</span>
<span class="gd">-        -116, &#39;BIII&#39;: -105, &#39;BMHI&#39;: -863, &#39;BMHM&#39;: -464, &#39;BOMH&#39;: 620, &#39;OHHH&#39;:</span>
<span class="gd">-        346, &#39;OHHI&#39;: 1729, &#39;OHII&#39;: 997, &#39;OHMH&#39;: 481, &#39;OIHH&#39;: 623, &#39;OIIH&#39;: </span>
<span class="gd">-        1344, &#39;OKAK&#39;: 2792, &#39;OKHH&#39;: 587, &#39;OKKA&#39;: 679, &#39;OOHH&#39;: 110, &#39;OOII&#39;: -685</span>
<span class="gd">-        }</span>
<span class="gd">-    TQ4__ = {&#39;BHHH&#39;: -721, &#39;BHHM&#39;: -3604, &#39;BHII&#39;: -966, &#39;BIIH&#39;: -607,</span>
<span class="gd">-        &#39;BIII&#39;: -2181, &#39;OAAA&#39;: -2763, &#39;OAKK&#39;: 180, &#39;OHHH&#39;: -294, &#39;OHHI&#39;: </span>
<span class="gd">-        2446, &#39;OHHO&#39;: 480, &#39;OHIH&#39;: -1573, &#39;OIHH&#39;: 1935, &#39;OIHI&#39;: -493,</span>
<span class="gd">-        &#39;OIIH&#39;: 626, &#39;OIII&#39;: -4007, &#39;OKAK&#39;: -8156}</span>
<span class="gi">+    TQ3__ = {&#39;BHHH&#39;: 478, &#39;BHHM&#39;: -1073, &#39;BHIH&#39;: 222, &#39;BHII&#39;: -504, &#39;BIIH&#39;: -116,</span>
<span class="gi">+             &#39;BIII&#39;: -105, &#39;BMHI&#39;: -863, &#39;BMHM&#39;: -464, &#39;BOMH&#39;: 620, &#39;OHHH&#39;: 346,</span>
<span class="gi">+             &#39;OHHI&#39;: 1729, &#39;OHII&#39;: 997, &#39;OHMH&#39;: 481, &#39;OIHH&#39;: 623, &#39;OIIH&#39;: 1344,</span>
<span class="gi">+             &#39;OKAK&#39;: 2792, &#39;OKHH&#39;: 587, &#39;OKKA&#39;: 679, &#39;OOHH&#39;: 110, &#39;OOII&#39;: -685}</span>
<span class="gi">+    TQ4__ = {&#39;BHHH&#39;: -721, &#39;BHHM&#39;: -3604, &#39;BHII&#39;: -966, &#39;BIIH&#39;: -607, &#39;BIII&#39;: -2181,</span>
<span class="gi">+             &#39;OAAA&#39;: -2763, &#39;OAKK&#39;: 180, &#39;OHHH&#39;: -294, &#39;OHHI&#39;: 2446, &#39;OHHO&#39;: 480,</span>
<span class="gi">+             &#39;OHIH&#39;: -1573, &#39;OIHH&#39;: 1935, &#39;OIHI&#39;: -493, &#39;OIIH&#39;: 626, &#39;OIII&#39;: -4007,</span>
<span class="gi">+             &#39;OKAK&#39;: -8156}</span>
<span class="w"> </span>    TW1__ = {&#39;&#39;: -4681, &#39;&#39;: 2026}
<span class="gd">-    TW2__ = {&#39;&#39;: -2049, &#39;&#39;: -1256, &#39;&#39;: -2434, &#39;&#39;: 3873, &#39;&#39;: </span>
<span class="gd">-        -4430, &#39;&#39;: -1049, &#39;&#39;: 1833, &#39;&#39;: -4657, &#39;&#39;: -4517, &#39;&#39;:</span>
<span class="gd">-        1882, &#39;&#39;: -792, &#39;&#39;: -1512, &#39;&#39;: -8097, &#39;&#39;: -1255, &#39;&#39;:</span>
<span class="gd">-        -2721, &#39;&#39;: -3216}</span>
<span class="gd">-    TW3__ = {&#39;&#39;: -1734, &#39;&#39;: 1314, &#39;&#39;: -4314, &#39;&#39;: -5483, &#39;&#39;: </span>
<span class="gd">-        -5989, &#39;&#39;: -6247, &#39;,&#39;: -727, &#39;&#39;: -727, &#39;&#39;: -600, &#39;&#39;: </span>
<span class="gd">-        -3752, &#39;&#39;: -2287}</span>
<span class="gd">-    TW4__ = {&#39;.&#39;: 8576, &#39;&#39;: 8576, &#39;&#39;: -2348, &#39;&#39;: 2958, &#39;,&#39;: </span>
<span class="gd">-        1516, &#39;&#39;: 1516, &#39;&#39;: 1538, &#39;&#39;: 1349, &#39;&#39;: 5543, &#39;&#39;: </span>
<span class="gd">-        1097, &#39;&#39;: -4258, &#39;&#39;: 5865}</span>
<span class="gi">+    TW2__ = {&#39;&#39;: -2049, &#39;&#39;: -1256, &#39;&#39;: -2434, &#39;&#39;: 3873,</span>
<span class="gi">+             &#39;&#39;: -4430, &#39;&#39;: -1049, &#39;&#39;: 1833, &#39;&#39;: -4657,</span>
<span class="gi">+             &#39;&#39;: -4517, &#39;&#39;: 1882, &#39;&#39;: -792, &#39;&#39;: -1512,</span>
<span class="gi">+             &#39;&#39;: -8097, &#39;&#39;: -1255, &#39;&#39;: -2721, &#39;&#39;: -3216}</span>
<span class="gi">+    TW3__ = {&#39;&#39;: -1734, &#39;&#39;: 1314, &#39;&#39;: -4314, &#39;&#39;: -5483,</span>
<span class="gi">+             &#39;&#39;: -5989, &#39;&#39;: -6247, &#39;,&#39;: -727, &#39;&#39;: -727,</span>
<span class="gi">+             &#39;&#39;: -600, &#39;&#39;: -3752, &#39;&#39;: -2287}</span>
<span class="gi">+    TW4__ = {&#39;.&#39;: 8576, &#39;&#39;: 8576, &#39;&#39;: -2348, &#39;&#39;: 2958,</span>
<span class="gi">+             &#39;,&#39;: 1516, &#39;&#39;: 1516, &#39;&#39;: 1538, &#39;&#39;: 1349,</span>
<span class="gi">+             &#39;&#39;: 5543, &#39;&#39;: 1097, &#39;&#39;: -4258, &#39;&#39;: 5865}</span>
<span class="w"> </span>    UC1__ = {&#39;A&#39;: 484, &#39;K&#39;: 93, &#39;M&#39;: 645, &#39;O&#39;: -505}
<span class="w"> </span>    UC2__ = {&#39;A&#39;: 819, &#39;H&#39;: 1059, &#39;I&#39;: 409, &#39;M&#39;: 3987, &#39;N&#39;: 5775, &#39;O&#39;: 646}
<span class="w"> </span>    UC3__ = {&#39;A&#39;: -1370, &#39;I&#39;: 2311}
<span class="gd">-    UC4__ = {&#39;A&#39;: -2643, &#39;H&#39;: 1809, &#39;I&#39;: -1032, &#39;K&#39;: -3450, &#39;M&#39;: 3565, &#39;N&#39;:</span>
<span class="gd">-        3876, &#39;O&#39;: 6646}</span>
<span class="gi">+    UC4__ = {&#39;A&#39;: -2643, &#39;H&#39;: 1809, &#39;I&#39;: -1032, &#39;K&#39;: -3450, &#39;M&#39;: 3565,</span>
<span class="gi">+             &#39;N&#39;: 3876, &#39;O&#39;: 6646}</span>
<span class="w"> </span>    UC5__ = {&#39;H&#39;: 313, &#39;I&#39;: -1238, &#39;K&#39;: -799, &#39;M&#39;: 539, &#39;O&#39;: -831}
<span class="w"> </span>    UC6__ = {&#39;H&#39;: -506, &#39;I&#39;: -253, &#39;K&#39;: 87, &#39;M&#39;: 247, &#39;O&#39;: -387}
<span class="w"> </span>    UP1__ = {&#39;O&#39;: -214}
<span class="w"> </span>    UP2__ = {&#39;B&#39;: 69, &#39;O&#39;: 935}
<span class="w"> </span>    UP3__ = {&#39;B&#39;: 189}
<span class="gd">-    UQ1__ = {&#39;BH&#39;: 21, &#39;BI&#39;: -12, &#39;BK&#39;: -99, &#39;BN&#39;: 142, &#39;BO&#39;: -56, &#39;OH&#39;: -</span>
<span class="gd">-        95, &#39;OI&#39;: 477, &#39;OK&#39;: 410, &#39;OO&#39;: -2422}</span>
<span class="gi">+    UQ1__ = {&#39;BH&#39;: 21, &#39;BI&#39;: -12, &#39;BK&#39;: -99, &#39;BN&#39;: 142, &#39;BO&#39;: -56, &#39;OH&#39;: -95,</span>
<span class="gi">+             &#39;OI&#39;: 477, &#39;OK&#39;: 410, &#39;OO&#39;: -2422}</span>
<span class="w"> </span>    UQ2__ = {&#39;BH&#39;: 216, &#39;BI&#39;: 113, &#39;OK&#39;: 1759}
<span class="w"> </span>    UQ3__ = {&#39;BA&#39;: -479, &#39;BH&#39;: 42, &#39;BI&#39;: 1913, &#39;BK&#39;: -7198, &#39;BM&#39;: 3160,
<span class="gd">-        &#39;BN&#39;: 6427, &#39;BO&#39;: 14761, &#39;OI&#39;: -827, &#39;ON&#39;: -3212}</span>
<span class="gi">+             &#39;BN&#39;: 6427, &#39;BO&#39;: 14761, &#39;OI&#39;: -827, &#39;ON&#39;: -3212}</span>
<span class="w"> </span>    UW1__ = {&#39;,&#39;: 156, &#39;&#39;: 156, &#39;&#39;: -463, &#39;&#39;: -941, &#39;&#39;: -127, &#39;&#39;: -553,
<span class="gd">-        &#39;&#39;: 121, &#39;&#39;: 505, &#39;&#39;: -201, &#39;&#39;: -547, &#39;&#39;: -123, &#39;&#39;: -789, &#39;&#39;:</span>
<span class="gd">-        -185, &#39;&#39;: -847, &#39;&#39;: -466, &#39;&#39;: -470, &#39;&#39;: 182, &#39;&#39;: -292, &#39;&#39;: </span>
<span class="gd">-        208, &#39;&#39;: 169, &#39;&#39;: -446, &#39;&#39;: -137, &#39;&#39;: -135, &#39;&#39;: -402, &#39;&#39;: -</span>
<span class="gd">-        268, &#39;&#39;: -912, &#39;&#39;: 871, &#39;&#39;: -460, &#39;&#39;: 561, &#39;&#39;: 729, &#39;&#39;: -411,</span>
<span class="gd">-        &#39;&#39;: -141, &#39;&#39;: 361, &#39;&#39;: -408, &#39;&#39;: -386, &#39;&#39;: -718, &#39;&#39;: -463,</span>
<span class="gd">-        &#39;&#39;: -135}</span>
<span class="gd">-    UW2__ = {&#39;,&#39;: -829, &#39;&#39;: -829, &#39;&#39;: 892, &#39;&#39;: -645, &#39;&#39;: 3145, &#39;&#39;: -</span>
<span class="gd">-        538, &#39;&#39;: 505, &#39;&#39;: 134, &#39;&#39;: -502, &#39;&#39;: 1454, &#39;&#39;: -856, &#39;&#39;: -412,</span>
<span class="gd">-        &#39;&#39;: 1141, &#39;&#39;: 878, &#39;&#39;: 540, &#39;&#39;: 1529, &#39;&#39;: -675, &#39;&#39;: 300, &#39;&#39;:</span>
<span class="gd">-        -1011, &#39;&#39;: 188, &#39;&#39;: 1837, &#39;&#39;: -949, &#39;&#39;: -291, &#39;&#39;: -268, &#39;&#39;: -</span>
<span class="gd">-        981, &#39;&#39;: 1273, &#39;&#39;: 1063, &#39;&#39;: -1764, &#39;&#39;: 130, &#39;&#39;: -409, &#39;&#39;: -</span>
<span class="gd">-        1273, &#39;&#39;: 1261, &#39;&#39;: 600, &#39;&#39;: -1263, &#39;&#39;: -402, &#39;&#39;: 1639, &#39;&#39;: -</span>
<span class="gd">-        579, &#39;&#39;: -694, &#39;&#39;: 571, &#39;&#39;: -2516, &#39;&#39;: 2095, &#39;&#39;: -587, &#39;&#39;: </span>
<span class="gd">-        306, &#39;&#39;: 568, &#39;&#39;: 831, &#39;&#39;: -758, &#39;&#39;: -2150, &#39;&#39;: -302, &#39;&#39;: -</span>
<span class="gd">-        968, &#39;&#39;: -861, &#39;&#39;: 492, &#39;&#39;: -123, &#39;&#39;: 978, &#39;&#39;: 362, &#39;&#39;: 548,</span>
<span class="gd">-        &#39;&#39;: -3025, &#39;&#39;: -1566, &#39;&#39;: -3414, &#39;&#39;: -422, &#39;&#39;: -1769, &#39;&#39;: -</span>
<span class="gd">-        865, &#39;&#39;: -483, &#39;&#39;: -1519, &#39;&#39;: 760, &#39;&#39;: 1023, &#39;&#39;: -2009, &#39;&#39;: -</span>
<span class="gd">-        813, &#39;&#39;: -1060, &#39;&#39;: 1067, &#39;&#39;: -1519, &#39;&#39;: -1033, &#39;&#39;: 1522, &#39;&#39;:</span>
<span class="gd">-        -1355, &#39;&#39;: -1682, &#39;&#39;: -1815, &#39;&#39;: -1462, &#39;&#39;: -630, &#39;&#39;: -1843,</span>
<span class="gd">-        &#39;&#39;: -1650, &#39;&#39;: -931, &#39;&#39;: -665, &#39;&#39;: -2378, &#39;&#39;: -180, &#39;&#39;: -1740,</span>
<span class="gd">-        &#39;&#39;: 752, &#39;&#39;: 529, &#39;&#39;: -1584, &#39;&#39;: -242, &#39;&#39;: -1165, &#39;&#39;: -763,</span>
<span class="gd">-        &#39;&#39;: 810, &#39;&#39;: 509, &#39;&#39;: -1353, &#39;&#39;: 838, &#39;&#39;: -744, &#39;&#39;: -3874,</span>
<span class="gd">-        &#39;&#39;: 1010, &#39;&#39;: 1198, &#39;&#39;: 3041, &#39;&#39;: 1758, &#39;&#39;: -1257, &#39;&#39;: -645,</span>
<span class="gd">-        &#39;&#39;: 3145, &#39;&#39;: 831, &#39;&#39;: -587, &#39;&#39;: 306, &#39;&#39;: 568}</span>
<span class="gd">-    UW3__ = {&#39;,&#39;: 4889, &#39;1&#39;: -800, &#39;&#39;: -1723, &#39;&#39;: 4889, &#39;&#39;: -2311, &#39;&#39;: </span>
<span class="gd">-        5827, &#39;&#39;: 2670, &#39;&#39;: -3573, &#39;&#39;: -2696, &#39;&#39;: 1006, &#39;&#39;: 2342, &#39;&#39;:</span>
<span class="gd">-        1983, &#39;&#39;: -4864, &#39;&#39;: -1163, &#39;&#39;: 3271, &#39;&#39;: 1004, &#39;&#39;: 388, &#39;&#39;: </span>
<span class="gd">-        401, &#39;&#39;: -3552, &#39;&#39;: -3116, &#39;&#39;: -1058, &#39;&#39;: -395, &#39;&#39;: 584, &#39;&#39;: </span>
<span class="gd">-        3685, &#39;&#39;: -5228, &#39;&#39;: 842, &#39;&#39;: -521, &#39;&#39;: -1444, &#39;&#39;: -1081, &#39;&#39;:</span>
<span class="gd">-        6167, &#39;&#39;: 2318, &#39;&#39;: 1691, &#39;&#39;: -899, &#39;&#39;: -2788, &#39;&#39;: 2745, &#39;&#39;: </span>
<span class="gd">-        4056, &#39;&#39;: 4555, &#39;&#39;: -2171, &#39;&#39;: -1798, &#39;&#39;: 1199, &#39;&#39;: -5516, &#39;&#39;:</span>
<span class="gd">-        -4384, &#39;&#39;: -120, &#39;&#39;: 1205, &#39;&#39;: 2323, &#39;&#39;: -788, &#39;&#39;: -202, &#39;&#39;: </span>
<span class="gd">-        727, &#39;&#39;: 649, &#39;&#39;: 5905, &#39;&#39;: 2773, &#39;&#39;: -1207, &#39;&#39;: 6620, &#39;&#39;: -</span>
<span class="gd">-        518, &#39;&#39;: 551, &#39;&#39;: 1319, &#39;&#39;: 874, &#39;&#39;: -1350, &#39;&#39;: 521, &#39;&#39;: 1109,</span>
<span class="gd">-        &#39;&#39;: 1591, &#39;&#39;: 2201, &#39;&#39;: 278, &#39;&#39;: -3794, &#39;&#39;: -1619, &#39;&#39;: -1759,</span>
<span class="gd">-        &#39;&#39;: -2087, &#39;&#39;: 3815, &#39;&#39;: 653, &#39;&#39;: -758, &#39;&#39;: -1193, &#39;&#39;: 974,</span>
<span class="gd">-        &#39;&#39;: 2742, &#39;&#39;: 792, &#39;&#39;: 1889, &#39;&#39;: -1368, &#39;&#39;: 811, &#39;&#39;: 4265,</span>
<span class="gd">-        &#39;&#39;: -361, &#39;&#39;: -2439, &#39;&#39;: 4858, &#39;&#39;: 3593, &#39;&#39;: 1574, &#39;&#39;: -3030,</span>
<span class="gd">-        &#39;&#39;: 755, &#39;&#39;: -1880, &#39;&#39;: 5807, &#39;&#39;: 3095, &#39;&#39;: 457, &#39;&#39;: 2475,</span>
<span class="gd">-        &#39;&#39;: 1129, &#39;&#39;: 2286, &#39;&#39;: 4437, &#39;&#39;: 365, &#39;&#39;: -949, &#39;&#39;: -1872,</span>
<span class="gd">-        &#39;&#39;: 1327, &#39;&#39;: -1038, &#39;&#39;: 4646, &#39;&#39;: -2309, &#39;&#39;: -783, &#39;&#39;: -1006,</span>
<span class="gd">-        &#39;&#39;: 483, &#39;&#39;: 1233, &#39;&#39;: 3588, &#39;&#39;: -241, &#39;&#39;: 3906, &#39;&#39;: -837,</span>
<span class="gd">-        &#39;&#39;: 4513, &#39;&#39;: 642, &#39;&#39;: 1389, &#39;&#39;: 1219, &#39;&#39;: -241, &#39;&#39;: 2016,</span>
<span class="gd">-        &#39;&#39;: -1356, &#39;&#39;: -423, &#39;&#39;: -1008, &#39;&#39;: 1078, &#39;&#39;: -513, &#39;&#39;: -3102,</span>
<span class="gd">-        &#39;&#39;: 1155, &#39;&#39;: 3197, &#39;&#39;: -1804, &#39;&#39;: 2416, &#39;&#39;: -1030, &#39;&#39;: 1605,</span>
<span class="gd">-        &#39;&#39;: 1452, &#39;&#39;: -2352, &#39;&#39;: -3885, &#39;&#39;: 1905, &#39;&#39;: -1291, &#39;&#39;: 1822,</span>
<span class="gd">-        &#39;&#39;: -488, &#39;&#39;: -3973, &#39;&#39;: -2013, &#39;&#39;: -1479, &#39;&#39;: 3222, &#39;&#39;: -</span>
<span class="gd">-        1489, &#39;&#39;: 1764, &#39;&#39;: 2099, &#39;&#39;: 5792, &#39;&#39;: -661, &#39;&#39;: -1248, &#39;&#39;: </span>
<span class="gd">-        -951, &#39;&#39;: -937, &#39;&#39;: 4125, &#39;&#39;: 360, &#39;&#39;: 3094, &#39;&#39;: 364, &#39;&#39;: -</span>
<span class="gd">-        805, &#39;&#39;: 5156, &#39;&#39;: 2438, &#39;&#39;: 484, &#39;&#39;: 2613, &#39;&#39;: -1694, &#39;&#39;: -</span>
<span class="gd">-        1073, &#39;&#39;: 1868, &#39;&#39;: -495, &#39;&#39;: 979, &#39;&#39;: 461, &#39;&#39;: -3850, &#39;&#39;: -</span>
<span class="gd">-        273, &#39;&#39;: 914, &#39;&#39;: 1215, &#39;&#39;: 7313, &#39;&#39;: -1835, &#39;&#39;: 792, &#39;&#39;: </span>
<span class="gd">-        6293, &#39;&#39;: -1528, &#39;&#39;: 4231, &#39;&#39;: 401, &#39;&#39;: -960, &#39;&#39;: 1201, &#39;&#39;: </span>
<span class="gd">-        7767, &#39;&#39;: 3066, &#39;&#39;: 3663, &#39;&#39;: 1384, &#39;&#39;: -4229, &#39;&#39;: 1163, &#39;&#39;: </span>
<span class="gd">-        1255, &#39;&#39;: 6457, &#39;&#39;: 725, &#39;&#39;: -2869, &#39;&#39;: 785, &#39;&#39;: 1044, &#39;&#39;: -</span>
<span class="gd">-        562, &#39;&#39;: -733, &#39;&#39;: 1777, &#39;&#39;: 1835, &#39;&#39;: 1375, &#39;&#39;: -1504, &#39;&#39;: -</span>
<span class="gd">-        1136, &#39;&#39;: -681, &#39;&#39;: 1026, &#39;&#39;: 4404, &#39;&#39;: 1200, &#39;&#39;: 2163, &#39;&#39;: </span>
<span class="gd">-        421, &#39;&#39;: -1432, &#39;&#39;: 1302, &#39;&#39;: -1282, &#39;&#39;: 2009, &#39;&#39;: -1045, &#39;&#39;:</span>
<span class="gd">-        2066, &#39;&#39;: 1620, &#39;&#39;: -800, &#39;&#39;: 2670, &#39;&#39;: -3794, &#39;&#39;: -1350, &#39;&#39;:</span>
<span class="gd">-        551, &#39;&#39;: 1319, &#39;&#39;: 874, &#39;&#39;: 521, &#39;&#39;: 1109, &#39;&#39;: 1591, &#39;&#39;: </span>
<span class="gd">-        2201, &#39;&#39;: 278}</span>
<span class="gd">-    UW4__ = {&#39;,&#39;: 3930, &#39;.&#39;: 3508, &#39;&#39;: -4841, &#39;&#39;: 3930, &#39;&#39;: 3508, &#39;&#39;: </span>
<span class="gd">-        4999, &#39;&#39;: 1895, &#39;&#39;: 3798, &#39;&#39;: -5156, &#39;&#39;: 4752, &#39;&#39;: -3435, &#39;&#39;:</span>
<span class="gd">-        -640, &#39;&#39;: -2514, &#39;&#39;: 2405, &#39;&#39;: 530, &#39;&#39;: 6006, &#39;&#39;: -4482, &#39;&#39;: </span>
<span class="gd">-        -3821, &#39;&#39;: -3788, &#39;&#39;: -4376, &#39;&#39;: -4734, &#39;&#39;: 2255, &#39;&#39;: 1979,</span>
<span class="gd">-        &#39;&#39;: 2864, &#39;&#39;: -843, &#39;&#39;: -2506, &#39;&#39;: -731, &#39;&#39;: 1251, &#39;&#39;: 181,</span>
<span class="gd">-        &#39;&#39;: 4091, &#39;&#39;: 5034, &#39;&#39;: 5408, &#39;&#39;: -3654, &#39;&#39;: -5882, &#39;&#39;: -1659,</span>
<span class="gd">-        &#39;&#39;: 3994, &#39;&#39;: 7410, &#39;&#39;: 4547, &#39;&#39;: 5433, &#39;&#39;: 6499, &#39;&#39;: 1853,</span>
<span class="gd">-        &#39;&#39;: 1413, &#39;&#39;: 7396, &#39;&#39;: 8578, &#39;&#39;: 1940, &#39;&#39;: 4249, &#39;&#39;: -4134,</span>
<span class="gd">-        &#39;&#39;: 1345, &#39;&#39;: 6665, &#39;&#39;: -744, &#39;&#39;: 1464, &#39;&#39;: 1051, &#39;&#39;: -2082,</span>
<span class="gd">-        &#39;&#39;: -882, &#39;&#39;: -5046, &#39;&#39;: 4169, &#39;&#39;: -2666, &#39;&#39;: 2795, &#39;&#39;: -1544,</span>
<span class="gd">-        &#39;&#39;: 3351, &#39;&#39;: -2922, &#39;&#39;: -9726, &#39;&#39;: -14896, &#39;&#39;: -2613, &#39;&#39;: -</span>
<span class="gd">-        4570, &#39;&#39;: -1783, &#39;&#39;: 13150, &#39;&#39;: -2352, &#39;&#39;: 2145, &#39;&#39;: 1789, &#39;&#39;:</span>
<span class="gd">-        1287, &#39;&#39;: -724, &#39;&#39;: -403, &#39;&#39;: -1635, &#39;&#39;: -881, &#39;&#39;: -541, &#39;&#39;: </span>
<span class="gd">-        -856, &#39;&#39;: -3637, &#39;&#39;: -4371, &#39;&#39;: -11870, &#39;&#39;: -2069, &#39;&#39;: 2210,</span>
<span class="gd">-        &#39;&#39;: 782, &#39;&#39;: -190, &#39;&#39;: -1768, &#39;&#39;: 1036, &#39;&#39;: 544, &#39;&#39;: 950, &#39;&#39;:</span>
<span class="gd">-        -1286, &#39;&#39;: 530, &#39;&#39;: 4292, &#39;&#39;: 601, &#39;&#39;: -2006, &#39;&#39;: -1212, &#39;&#39;: </span>
<span class="gd">-        584, &#39;&#39;: 788, &#39;&#39;: 1347, &#39;&#39;: 1623, &#39;&#39;: 3879, &#39;&#39;: -302, &#39;&#39;: -</span>
<span class="gd">-        740, &#39;&#39;: -2715, &#39;&#39;: 776, &#39;&#39;: 4517, &#39;&#39;: 1013, &#39;&#39;: 1555, &#39;&#39;: -</span>
<span class="gd">-        1834, &#39;&#39;: -681, &#39;&#39;: -910, &#39;&#39;: -851, &#39;&#39;: 1500, &#39;&#39;: -619, &#39;&#39;: -</span>
<span class="gd">-        1200, &#39;&#39;: 866, &#39;&#39;: -1410, &#39;&#39;: -2094, &#39;&#39;: -1413, &#39;&#39;: 1067, &#39;&#39;:</span>
<span class="gd">-        571, &#39;&#39;: -4802, &#39;&#39;: -1397, &#39;&#39;: -1057, &#39;&#39;: -809, &#39;&#39;: 1910, &#39;&#39;:</span>
<span class="gd">-        -1328, &#39;&#39;: -1500, &#39;&#39;: -2056, &#39;&#39;: -2667, &#39;&#39;: 2771, &#39;&#39;: 374, &#39;&#39;:</span>
<span class="gd">-        -4556, &#39;&#39;: 456, &#39;&#39;: 553, &#39;&#39;: 916, &#39;&#39;: -1566, &#39;&#39;: 856, &#39;&#39;: 787,</span>
<span class="gd">-        &#39;&#39;: 2182, &#39;&#39;: 704, &#39;&#39;: 522, &#39;&#39;: -856, &#39;&#39;: 1798, &#39;&#39;: 1829, &#39;&#39;:</span>
<span class="gd">-        845, &#39;&#39;: -9066, &#39;&#39;: -485, &#39;&#39;: -442, &#39;&#39;: -360, &#39;&#39;: -1043, &#39;&#39;: </span>
<span class="gd">-        5388, &#39;&#39;: -2716, &#39;&#39;: -910, &#39;&#39;: -939, &#39;&#39;: -543, &#39;&#39;: -735, &#39;&#39;: </span>
<span class="gd">-        672, &#39;&#39;: -1267, &#39;&#39;: -1286, &#39;&#39;: -1101, &#39;&#39;: -2900, &#39;&#39;: 1826, &#39;&#39;:</span>
<span class="gd">-        2586, &#39;&#39;: 922, &#39;&#39;: -3485, &#39;&#39;: 2997, &#39;&#39;: -867, &#39;&#39;: -2112, &#39;&#39;: </span>
<span class="gd">-        788, &#39;&#39;: 2937, &#39;&#39;: 786, &#39;&#39;: 2171, &#39;&#39;: 1146, &#39;&#39;: -1169, &#39;&#39;: </span>
<span class="gd">-        940, &#39;&#39;: -994, &#39;&#39;: 749, &#39;&#39;: 2145, &#39;&#39;: -730, &#39;&#39;: -852, &#39;&#39;: -</span>
<span class="gd">-        792, &#39;&#39;: 792, &#39;&#39;: -1184, &#39;&#39;: -244, &#39;&#39;: -1000, &#39;&#39;: 730, &#39;&#39;: -</span>
<span class="gd">-        1481, &#39;&#39;: 1158, &#39;&#39;: -1433, &#39;&#39;: -3370, &#39;&#39;: 929, &#39;&#39;: -1291, &#39;&#39;:</span>
<span class="gd">-        2596, &#39;&#39;: -4866, &#39;&#39;: 1192, &#39;&#39;: -1100, &#39;&#39;: -2213, &#39;&#39;: 357, &#39;&#39;:</span>
<span class="gd">-        -2344, &#39;&#39;: -2297, &#39;&#39;: -2604, &#39;&#39;: -878, &#39;&#39;: -1659, &#39;&#39;: -792,</span>
<span class="gd">-        &#39;&#39;: -1984, &#39;&#39;: 1749, &#39;&#39;: 2120, &#39;&#39;: 1895, &#39;&#39;: 3798, &#39;&#39;: -4371,</span>
<span class="gd">-        &#39;&#39;: -724, &#39;&#39;: -11870, &#39;&#39;: 2145, &#39;&#39;: 1789, &#39;&#39;: 1287, &#39;&#39;: -403,</span>
<span class="gd">-        &#39;&#39;: -1635, &#39;&#39;: -881, &#39;&#39;: -541, &#39;&#39;: -856, &#39;&#39;: -3637}</span>
<span class="gd">-    UW5__ = {&#39;,&#39;: 465, &#39;.&#39;: -299, &#39;1&#39;: -514, &#39;E2&#39;: -32768, &#39;]&#39;: -2762, &#39;&#39;:</span>
<span class="gd">-        465, &#39;&#39;: -299, &#39;&#39;: 363, &#39;&#39;: 1655, &#39;&#39;: 331, &#39;&#39;: -503, &#39;&#39;: 1199,</span>
<span class="gd">-        &#39;&#39;: 527, &#39;&#39;: 647, &#39;&#39;: -421, &#39;&#39;: 1624, &#39;&#39;: 1971, &#39;&#39;: 312, &#39;&#39;:</span>
<span class="gd">-        -983, &#39;&#39;: -1537, &#39;&#39;: -1371, &#39;&#39;: -852, &#39;&#39;: -1186, &#39;&#39;: 1093, &#39;&#39;:</span>
<span class="gd">-        52, &#39;&#39;: 921, &#39;&#39;: -18, &#39;&#39;: -850, &#39;&#39;: -127, &#39;&#39;: 1682, &#39;&#39;: -787,</span>
<span class="gd">-        &#39;&#39;: -1224, &#39;&#39;: -635, &#39;&#39;: -578, &#39;&#39;: 1001, &#39;&#39;: 502, &#39;&#39;: 865,</span>
<span class="gd">-        &#39;&#39;: 3350, &#39;&#39;: 854, &#39;&#39;: -208, &#39;&#39;: 429, &#39;&#39;: 504, &#39;&#39;: 419, &#39;&#39;: </span>
<span class="gd">-        -1264, &#39;&#39;: 327, &#39;&#39;: 241, &#39;&#39;: 451, &#39;&#39;: -343, &#39;&#39;: -871, &#39;&#39;: 722,</span>
<span class="gd">-        &#39;&#39;: -1153, &#39;&#39;: -654, &#39;&#39;: 3519, &#39;&#39;: -901, &#39;&#39;: 848, &#39;&#39;: 2104,</span>
<span class="gd">-        &#39;&#39;: -1296, &#39;&#39;: -548, &#39;&#39;: 1785, &#39;&#39;: -1304, &#39;&#39;: -2991, &#39;&#39;: 921,</span>
<span class="gd">-        &#39;&#39;: 1763, &#39;&#39;: 872, &#39;&#39;: -814, &#39;&#39;: 1618, &#39;&#39;: -1682, &#39;&#39;: 218,</span>
<span class="gd">-        &#39;&#39;: -4353, &#39;&#39;: 932, &#39;&#39;: 1356, &#39;&#39;: -1508, &#39;&#39;: -1347, &#39;&#39;: 240,</span>
<span class="gd">-        &#39;&#39;: -3912, &#39;&#39;: -3149, &#39;&#39;: 1319, &#39;&#39;: -1052, &#39;&#39;: -4003, &#39;&#39;: -</span>
<span class="gd">-        997, &#39;&#39;: -278, &#39;&#39;: -813, &#39;&#39;: 1955, &#39;&#39;: -2233, &#39;&#39;: 663, &#39;&#39;: -</span>
<span class="gd">-        1073, &#39;&#39;: 1219, &#39;&#39;: -1018, &#39;&#39;: -368, &#39;&#39;: 786, &#39;&#39;: 1191, &#39;&#39;: </span>
<span class="gd">-        2368, &#39;&#39;: -689, &#39;&#39;: -514, &#39;&#39;: -32768, &#39;&#39;: 363, &#39;&#39;: 241, &#39;&#39;: </span>
<span class="gd">-        451, &#39;&#39;: -343}</span>
<span class="gi">+             &#39;&#39;: 121, &#39;&#39;: 505, &#39;&#39;: -201, &#39;&#39;: -547, &#39;&#39;: -123, &#39;&#39;: -789,</span>
<span class="gi">+             &#39;&#39;: -185, &#39;&#39;: -847, &#39;&#39;: -466, &#39;&#39;: -470, &#39;&#39;: 182, &#39;&#39;: -292,</span>
<span class="gi">+             &#39;&#39;: 208, &#39;&#39;: 169, &#39;&#39;: -446, &#39;&#39;: -137, &#39;&#39;: -135, &#39;&#39;: -402,</span>
<span class="gi">+             &#39;&#39;: -268, &#39;&#39;: -912, &#39;&#39;: 871, &#39;&#39;: -460, &#39;&#39;: 561, &#39;&#39;: 729,</span>
<span class="gi">+             &#39;&#39;: -411, &#39;&#39;: -141, &#39;&#39;: 361, &#39;&#39;: -408, &#39;&#39;: -386, &#39;&#39;: -718,</span>
<span class="gi">+             &#39;&#39;: -463, &#39;&#39;: -135}</span>
<span class="gi">+    UW2__ = {&#39;,&#39;: -829, &#39;&#39;: -829, &#39;&#39;: 892, &#39;&#39;: -645, &#39;&#39;: 3145, &#39;&#39;: -538,</span>
<span class="gi">+             &#39;&#39;: 505, &#39;&#39;: 134, &#39;&#39;: -502, &#39;&#39;: 1454, &#39;&#39;: -856, &#39;&#39;: -412,</span>
<span class="gi">+             &#39;&#39;: 1141, &#39;&#39;: 878, &#39;&#39;: 540, &#39;&#39;: 1529, &#39;&#39;: -675, &#39;&#39;: 300,</span>
<span class="gi">+             &#39;&#39;: -1011, &#39;&#39;: 188, &#39;&#39;: 1837, &#39;&#39;: -949, &#39;&#39;: -291, &#39;&#39;: -268,</span>
<span class="gi">+             &#39;&#39;: -981, &#39;&#39;: 1273, &#39;&#39;: 1063, &#39;&#39;: -1764, &#39;&#39;: 130, &#39;&#39;: -409,</span>
<span class="gi">+             &#39;&#39;: -1273, &#39;&#39;: 1261, &#39;&#39;: 600, &#39;&#39;: -1263, &#39;&#39;: -402, &#39;&#39;: 1639,</span>
<span class="gi">+             &#39;&#39;: -579, &#39;&#39;: -694, &#39;&#39;: 571, &#39;&#39;: -2516, &#39;&#39;: 2095, &#39;&#39;: -587,</span>
<span class="gi">+             &#39;&#39;: 306, &#39;&#39;: 568, &#39;&#39;: 831, &#39;&#39;: -758, &#39;&#39;: -2150, &#39;&#39;: -302,</span>
<span class="gi">+             &#39;&#39;: -968, &#39;&#39;: -861, &#39;&#39;: 492, &#39;&#39;: -123, &#39;&#39;: 978, &#39;&#39;: 362,</span>
<span class="gi">+             &#39;&#39;: 548, &#39;&#39;: -3025, &#39;&#39;: -1566, &#39;&#39;: -3414, &#39;&#39;: -422, &#39;&#39;: -1769,</span>
<span class="gi">+             &#39;&#39;: -865, &#39;&#39;: -483, &#39;&#39;: -1519, &#39;&#39;: 760, &#39;&#39;: 1023, &#39;&#39;: -2009,</span>
<span class="gi">+             &#39;&#39;: -813, &#39;&#39;: -1060, &#39;&#39;: 1067, &#39;&#39;: -1519, &#39;&#39;: -1033, &#39;&#39;: 1522,</span>
<span class="gi">+             &#39;&#39;: -1355, &#39;&#39;: -1682, &#39;&#39;: -1815, &#39;&#39;: -1462, &#39;&#39;: -630, &#39;&#39;: -1843,</span>
<span class="gi">+             &#39;&#39;: -1650, &#39;&#39;: -931, &#39;&#39;: -665, &#39;&#39;: -2378, &#39;&#39;: -180, &#39;&#39;: -1740,</span>
<span class="gi">+             &#39;&#39;: 752, &#39;&#39;: 529, &#39;&#39;: -1584, &#39;&#39;: -242, &#39;&#39;: -1165, &#39;&#39;: -763,</span>
<span class="gi">+             &#39;&#39;: 810, &#39;&#39;: 509, &#39;&#39;: -1353, &#39;&#39;: 838, &#39;&#39;: -744, &#39;&#39;: -3874,</span>
<span class="gi">+             &#39;&#39;: 1010, &#39;&#39;: 1198, &#39;&#39;: 3041, &#39;&#39;: 1758, &#39;&#39;: -1257, &#39;&#39;: -645,</span>
<span class="gi">+             &#39;&#39;: 3145, &#39;&#39;: 831, &#39;&#39;: -587, &#39;&#39;: 306, &#39;&#39;: 568}</span>
<span class="gi">+    UW3__ = {&#39;,&#39;: 4889, &#39;1&#39;: -800, &#39;&#39;: -1723, &#39;&#39;: 4889, &#39;&#39;: -2311, &#39;&#39;: 5827,</span>
<span class="gi">+             &#39;&#39;: 2670, &#39;&#39;: -3573, &#39;&#39;: -2696, &#39;&#39;: 1006, &#39;&#39;: 2342, &#39;&#39;: 1983,</span>
<span class="gi">+             &#39;&#39;: -4864, &#39;&#39;: -1163, &#39;&#39;: 3271, &#39;&#39;: 1004, &#39;&#39;: 388, &#39;&#39;: 401,</span>
<span class="gi">+             &#39;&#39;: -3552, &#39;&#39;: -3116, &#39;&#39;: -1058, &#39;&#39;: -395, &#39;&#39;: 584, &#39;&#39;: 3685,</span>
<span class="gi">+             &#39;&#39;: -5228, &#39;&#39;: 842, &#39;&#39;: -521, &#39;&#39;: -1444, &#39;&#39;: -1081, &#39;&#39;: 6167,</span>
<span class="gi">+             &#39;&#39;: 2318, &#39;&#39;: 1691, &#39;&#39;: -899, &#39;&#39;: -2788, &#39;&#39;: 2745, &#39;&#39;: 4056,</span>
<span class="gi">+             &#39;&#39;: 4555, &#39;&#39;: -2171, &#39;&#39;: -1798, &#39;&#39;: 1199, &#39;&#39;: -5516, &#39;&#39;: -4384,</span>
<span class="gi">+             &#39;&#39;: -120, &#39;&#39;: 1205, &#39;&#39;: 2323, &#39;&#39;: -788, &#39;&#39;: -202, &#39;&#39;: 727,</span>
<span class="gi">+             &#39;&#39;: 649, &#39;&#39;: 5905, &#39;&#39;: 2773, &#39;&#39;: -1207, &#39;&#39;: 6620, &#39;&#39;: -518,</span>
<span class="gi">+             &#39;&#39;: 551, &#39;&#39;: 1319, &#39;&#39;: 874, &#39;&#39;: -1350, &#39;&#39;: 521, &#39;&#39;: 1109,</span>
<span class="gi">+             &#39;&#39;: 1591, &#39;&#39;: 2201, &#39;&#39;: 278, &#39;&#39;: -3794, &#39;&#39;: -1619, &#39;&#39;: -1759,</span>
<span class="gi">+             &#39;&#39;: -2087, &#39;&#39;: 3815, &#39;&#39;: 653, &#39;&#39;: -758, &#39;&#39;: -1193, &#39;&#39;: 974,</span>
<span class="gi">+             &#39;&#39;: 2742, &#39;&#39;: 792, &#39;&#39;: 1889, &#39;&#39;: -1368, &#39;&#39;: 811, &#39;&#39;: 4265,</span>
<span class="gi">+             &#39;&#39;: -361, &#39;&#39;: -2439, &#39;&#39;: 4858, &#39;&#39;: 3593, &#39;&#39;: 1574, &#39;&#39;: -3030,</span>
<span class="gi">+             &#39;&#39;: 755, &#39;&#39;: -1880, &#39;&#39;: 5807, &#39;&#39;: 3095, &#39;&#39;: 457, &#39;&#39;: 2475,</span>
<span class="gi">+             &#39;&#39;: 1129, &#39;&#39;: 2286, &#39;&#39;: 4437, &#39;&#39;: 365, &#39;&#39;: -949, &#39;&#39;: -1872,</span>
<span class="gi">+             &#39;&#39;: 1327, &#39;&#39;: -1038, &#39;&#39;: 4646, &#39;&#39;: -2309, &#39;&#39;: -783, &#39;&#39;: -1006,</span>
<span class="gi">+             &#39;&#39;: 483, &#39;&#39;: 1233, &#39;&#39;: 3588, &#39;&#39;: -241, &#39;&#39;: 3906, &#39;&#39;: -837,</span>
<span class="gi">+             &#39;&#39;: 4513, &#39;&#39;: 642, &#39;&#39;: 1389, &#39;&#39;: 1219, &#39;&#39;: -241, &#39;&#39;: 2016,</span>
<span class="gi">+             &#39;&#39;: -1356, &#39;&#39;: -423, &#39;&#39;: -1008, &#39;&#39;: 1078, &#39;&#39;: -513, &#39;&#39;: -3102,</span>
<span class="gi">+             &#39;&#39;: 1155, &#39;&#39;: 3197, &#39;&#39;: -1804, &#39;&#39;: 2416, &#39;&#39;: -1030, &#39;&#39;: 1605,</span>
<span class="gi">+             &#39;&#39;: 1452, &#39;&#39;: -2352, &#39;&#39;: -3885, &#39;&#39;: 1905, &#39;&#39;: -1291, &#39;&#39;: 1822,</span>
<span class="gi">+             &#39;&#39;: -488, &#39;&#39;: -3973, &#39;&#39;: -2013, &#39;&#39;: -1479, &#39;&#39;: 3222, &#39;&#39;: -1489,</span>
<span class="gi">+             &#39;&#39;: 1764, &#39;&#39;: 2099, &#39;&#39;: 5792, &#39;&#39;: -661, &#39;&#39;: -1248, &#39;&#39;: -951,</span>
<span class="gi">+             &#39;&#39;: -937, &#39;&#39;: 4125, &#39;&#39;: 360, &#39;&#39;: 3094, &#39;&#39;: 364, &#39;&#39;: -805,</span>
<span class="gi">+             &#39;&#39;: 5156, &#39;&#39;: 2438, &#39;&#39;: 484, &#39;&#39;: 2613, &#39;&#39;: -1694, &#39;&#39;: -1073,</span>
<span class="gi">+             &#39;&#39;: 1868, &#39;&#39;: -495, &#39;&#39;: 979, &#39;&#39;: 461, &#39;&#39;: -3850, &#39;&#39;: -273,</span>
<span class="gi">+             &#39;&#39;: 914, &#39;&#39;: 1215, &#39;&#39;: 7313, &#39;&#39;: -1835, &#39;&#39;: 792, &#39;&#39;: 6293,</span>
<span class="gi">+             &#39;&#39;: -1528, &#39;&#39;: 4231, &#39;&#39;: 401, &#39;&#39;: -960, &#39;&#39;: 1201, &#39;&#39;: 7767,</span>
<span class="gi">+             &#39;&#39;: 3066, &#39;&#39;: 3663, &#39;&#39;: 1384, &#39;&#39;: -4229, &#39;&#39;: 1163, &#39;&#39;: 1255,</span>
<span class="gi">+             &#39;&#39;: 6457, &#39;&#39;: 725, &#39;&#39;: -2869, &#39;&#39;: 785, &#39;&#39;: 1044, &#39;&#39;: -562,</span>
<span class="gi">+             &#39;&#39;: -733, &#39;&#39;: 1777, &#39;&#39;: 1835, &#39;&#39;: 1375, &#39;&#39;: -1504, &#39;&#39;: -1136,</span>
<span class="gi">+             &#39;&#39;: -681, &#39;&#39;: 1026, &#39;&#39;: 4404, &#39;&#39;: 1200, &#39;&#39;: 2163, &#39;&#39;: 421,</span>
<span class="gi">+             &#39;&#39;: -1432, &#39;&#39;: 1302, &#39;&#39;: -1282, &#39;&#39;: 2009, &#39;&#39;: -1045, &#39;&#39;: 2066,</span>
<span class="gi">+             &#39;&#39;: 1620, &#39;&#39;: -800, &#39;&#39;: 2670, &#39;&#39;: -3794, &#39;&#39;: -1350, &#39;&#39;: 551,</span>
<span class="gi">+             &#39;&#39;: 1319, &#39;&#39;: 874, &#39;&#39;: 521, &#39;&#39;: 1109, &#39;&#39;: 1591, &#39;&#39;: 2201, &#39;&#39;: 278}</span>
<span class="gi">+    UW4__ = {&#39;,&#39;: 3930, &#39;.&#39;: 3508, &#39;&#39;: -4841, &#39;&#39;: 3930, &#39;&#39;: 3508, &#39;&#39;: 4999,</span>
<span class="gi">+             &#39;&#39;: 1895, &#39;&#39;: 3798, &#39;&#39;: -5156, &#39;&#39;: 4752, &#39;&#39;: -3435, &#39;&#39;: -640,</span>
<span class="gi">+             &#39;&#39;: -2514, &#39;&#39;: 2405, &#39;&#39;: 530, &#39;&#39;: 6006, &#39;&#39;: -4482, &#39;&#39;: -3821,</span>
<span class="gi">+             &#39;&#39;: -3788, &#39;&#39;: -4376, &#39;&#39;: -4734, &#39;&#39;: 2255, &#39;&#39;: 1979, &#39;&#39;: 2864,</span>
<span class="gi">+             &#39;&#39;: -843, &#39;&#39;: -2506, &#39;&#39;: -731, &#39;&#39;: 1251, &#39;&#39;: 181, &#39;&#39;: 4091,</span>
<span class="gi">+             &#39;&#39;: 5034, &#39;&#39;: 5408, &#39;&#39;: -3654, &#39;&#39;: -5882, &#39;&#39;: -1659, &#39;&#39;: 3994,</span>
<span class="gi">+             &#39;&#39;: 7410, &#39;&#39;: 4547, &#39;&#39;: 5433, &#39;&#39;: 6499, &#39;&#39;: 1853, &#39;&#39;: 1413,</span>
<span class="gi">+             &#39;&#39;: 7396, &#39;&#39;: 8578, &#39;&#39;: 1940, &#39;&#39;: 4249, &#39;&#39;: -4134, &#39;&#39;: 1345,</span>
<span class="gi">+             &#39;&#39;: 6665, &#39;&#39;: -744, &#39;&#39;: 1464, &#39;&#39;: 1051, &#39;&#39;: -2082, &#39;&#39;: -882,</span>
<span class="gi">+             &#39;&#39;: -5046, &#39;&#39;: 4169, &#39;&#39;: -2666, &#39;&#39;: 2795, &#39;&#39;: -1544, &#39;&#39;: 3351,</span>
<span class="gi">+             &#39;&#39;: -2922, &#39;&#39;: -9726, &#39;&#39;: -14896, &#39;&#39;: -2613, &#39;&#39;: -4570,</span>
<span class="gi">+             &#39;&#39;: -1783, &#39;&#39;: 13150, &#39;&#39;: -2352, &#39;&#39;: 2145, &#39;&#39;: 1789, &#39;&#39;: 1287,</span>
<span class="gi">+             &#39;&#39;: -724, &#39;&#39;: -403, &#39;&#39;: -1635, &#39;&#39;: -881, &#39;&#39;: -541, &#39;&#39;: -856,</span>
<span class="gi">+             &#39;&#39;: -3637, &#39;&#39;: -4371, &#39;&#39;: -11870, &#39;&#39;: -2069, &#39;&#39;: 2210, &#39;&#39;: 782,</span>
<span class="gi">+             &#39;&#39;: -190, &#39;&#39;: -1768, &#39;&#39;: 1036, &#39;&#39;: 544, &#39;&#39;: 950, &#39;&#39;: -1286,</span>
<span class="gi">+             &#39;&#39;: 530, &#39;&#39;: 4292, &#39;&#39;: 601, &#39;&#39;: -2006, &#39;&#39;: -1212, &#39;&#39;: 584,</span>
<span class="gi">+             &#39;&#39;: 788, &#39;&#39;: 1347, &#39;&#39;: 1623, &#39;&#39;: 3879, &#39;&#39;: -302, &#39;&#39;: -740,</span>
<span class="gi">+             &#39;&#39;: -2715, &#39;&#39;: 776, &#39;&#39;: 4517, &#39;&#39;: 1013, &#39;&#39;: 1555, &#39;&#39;: -1834,</span>
<span class="gi">+             &#39;&#39;: -681, &#39;&#39;: -910, &#39;&#39;: -851, &#39;&#39;: 1500, &#39;&#39;: -619, &#39;&#39;: -1200,</span>
<span class="gi">+             &#39;&#39;: 866, &#39;&#39;: -1410, &#39;&#39;: -2094, &#39;&#39;: -1413, &#39;&#39;: 1067, &#39;&#39;: 571,</span>
<span class="gi">+             &#39;&#39;: -4802, &#39;&#39;: -1397, &#39;&#39;: -1057, &#39;&#39;: -809, &#39;&#39;: 1910, &#39;&#39;: -1328,</span>
<span class="gi">+             &#39;&#39;: -1500, &#39;&#39;: -2056, &#39;&#39;: -2667, &#39;&#39;: 2771, &#39;&#39;: 374, &#39;&#39;: -4556,</span>
<span class="gi">+             &#39;&#39;: 456, &#39;&#39;: 553, &#39;&#39;: 916, &#39;&#39;: -1566, &#39;&#39;: 856, &#39;&#39;: 787,</span>
<span class="gi">+             &#39;&#39;: 2182, &#39;&#39;: 704, &#39;&#39;: 522, &#39;&#39;: -856, &#39;&#39;: 1798, &#39;&#39;: 1829,</span>
<span class="gi">+             &#39;&#39;: 845, &#39;&#39;: -9066, &#39;&#39;: -485, &#39;&#39;: -442, &#39;&#39;: -360, &#39;&#39;: -1043,</span>
<span class="gi">+             &#39;&#39;: 5388, &#39;&#39;: -2716, &#39;&#39;: -910, &#39;&#39;: -939, &#39;&#39;: -543, &#39;&#39;: -735,</span>
<span class="gi">+             &#39;&#39;: 672, &#39;&#39;: -1267, &#39;&#39;: -1286, &#39;&#39;: -1101, &#39;&#39;: -2900, &#39;&#39;: 1826,</span>
<span class="gi">+             &#39;&#39;: 2586, &#39;&#39;: 922, &#39;&#39;: -3485, &#39;&#39;: 2997, &#39;&#39;: -867, &#39;&#39;: -2112,</span>
<span class="gi">+             &#39;&#39;: 788, &#39;&#39;: 2937, &#39;&#39;: 786, &#39;&#39;: 2171, &#39;&#39;: 1146, &#39;&#39;: -1169,</span>
<span class="gi">+             &#39;&#39;: 940, &#39;&#39;: -994, &#39;&#39;: 749, &#39;&#39;: 2145, &#39;&#39;: -730, &#39;&#39;: -852,</span>
<span class="gi">+             &#39;&#39;: -792, &#39;&#39;: 792, &#39;&#39;: -1184, &#39;&#39;: -244, &#39;&#39;: -1000, &#39;&#39;: 730,</span>
<span class="gi">+             &#39;&#39;: -1481, &#39;&#39;: 1158, &#39;&#39;: -1433, &#39;&#39;: -3370, &#39;&#39;: 929, &#39;&#39;: -1291,</span>
<span class="gi">+             &#39;&#39;: 2596, &#39;&#39;: -4866, &#39;&#39;: 1192, &#39;&#39;: -1100, &#39;&#39;: -2213, &#39;&#39;: 357,</span>
<span class="gi">+             &#39;&#39;: -2344, &#39;&#39;: -2297, &#39;&#39;: -2604, &#39;&#39;: -878, &#39;&#39;: -1659, &#39;&#39;: -792,</span>
<span class="gi">+             &#39;&#39;: -1984, &#39;&#39;: 1749, &#39;&#39;: 2120, &#39;&#39;: 1895, &#39;&#39;: 3798, &#39;&#39;: -4371,</span>
<span class="gi">+             &#39;&#39;: -724, &#39;&#39;: -11870, &#39;&#39;: 2145, &#39;&#39;: 1789, &#39;&#39;: 1287, &#39;&#39;: -403,</span>
<span class="gi">+             &#39;&#39;: -1635, &#39;&#39;: -881, &#39;&#39;: -541, &#39;&#39;: -856, &#39;&#39;: -3637}</span>
<span class="gi">+    UW5__ = {&#39;,&#39;: 465, &#39;.&#39;: -299, &#39;1&#39;: -514, &#39;E2&#39;: -32768, &#39;]&#39;: -2762, &#39;&#39;: 465,</span>
<span class="gi">+             &#39;&#39;: -299, &#39;&#39;: 363, &#39;&#39;: 1655, &#39;&#39;: 331, &#39;&#39;: -503, &#39;&#39;: 1199,</span>
<span class="gi">+             &#39;&#39;: 527, &#39;&#39;: 647, &#39;&#39;: -421, &#39;&#39;: 1624, &#39;&#39;: 1971, &#39;&#39;: 312,</span>
<span class="gi">+             &#39;&#39;: -983, &#39;&#39;: -1537, &#39;&#39;: -1371, &#39;&#39;: -852, &#39;&#39;: -1186, &#39;&#39;: 1093,</span>
<span class="gi">+             &#39;&#39;: 52, &#39;&#39;: 921, &#39;&#39;: -18, &#39;&#39;: -850, &#39;&#39;: -127, &#39;&#39;: 1682,</span>
<span class="gi">+             &#39;&#39;: -787, &#39;&#39;: -1224, &#39;&#39;: -635, &#39;&#39;: -578, &#39;&#39;: 1001, &#39;&#39;: 502,</span>
<span class="gi">+             &#39;&#39;: 865, &#39;&#39;: 3350, &#39;&#39;: 854, &#39;&#39;: -208, &#39;&#39;: 429, &#39;&#39;: 504,</span>
<span class="gi">+             &#39;&#39;: 419, &#39;&#39;: -1264, &#39;&#39;: 327, &#39;&#39;: 241, &#39;&#39;: 451, &#39;&#39;: -343,</span>
<span class="gi">+             &#39;&#39;: -871, &#39;&#39;: 722, &#39;&#39;: -1153, &#39;&#39;: -654, &#39;&#39;: 3519, &#39;&#39;: -901,</span>
<span class="gi">+             &#39;&#39;: 848, &#39;&#39;: 2104, &#39;&#39;: -1296, &#39;&#39;: -548, &#39;&#39;: 1785, &#39;&#39;: -1304,</span>
<span class="gi">+             &#39;&#39;: -2991, &#39;&#39;: 921, &#39;&#39;: 1763, &#39;&#39;: 872, &#39;&#39;: -814, &#39;&#39;: 1618,</span>
<span class="gi">+             &#39;&#39;: -1682, &#39;&#39;: 218, &#39;&#39;: -4353, &#39;&#39;: 932, &#39;&#39;: 1356, &#39;&#39;: -1508,</span>
<span class="gi">+             &#39;&#39;: -1347, &#39;&#39;: 240, &#39;&#39;: -3912, &#39;&#39;: -3149, &#39;&#39;: 1319, &#39;&#39;: -1052,</span>
<span class="gi">+             &#39;&#39;: -4003, &#39;&#39;: -997, &#39;&#39;: -278, &#39;&#39;: -813, &#39;&#39;: 1955, &#39;&#39;: -2233,</span>
<span class="gi">+             &#39;&#39;: 663, &#39;&#39;: -1073, &#39;&#39;: 1219, &#39;&#39;: -1018, &#39;&#39;: -368, &#39;&#39;: 786,</span>
<span class="gi">+             &#39;&#39;: 1191, &#39;&#39;: 2368, &#39;&#39;: -689, &#39;&#39;: -514, &#39;&#39;: -32768, &#39;&#39;: 363,</span>
<span class="gi">+             &#39;&#39;: 241, &#39;&#39;: 451, &#39;&#39;: -343}</span>
<span class="w"> </span>    UW6__ = {&#39;,&#39;: 227, &#39;.&#39;: 808, &#39;1&#39;: -270, &#39;E1&#39;: 306, &#39;&#39;: 227, &#39;&#39;: 808,
<span class="gd">-        &#39;&#39;: -307, &#39;&#39;: 189, &#39;&#39;: 241, &#39;&#39;: -73, &#39;&#39;: -121, &#39;&#39;: -200, &#39;&#39;:</span>
<span class="gd">-        1782, &#39;&#39;: 383, &#39;&#39;: -428, &#39;&#39;: 573, &#39;&#39;: -1014, &#39;&#39;: 101, &#39;&#39;: -</span>
<span class="gd">-        105, &#39;&#39;: -253, &#39;&#39;: -149, &#39;&#39;: -417, &#39;&#39;: -236, &#39;&#39;: -206, &#39;&#39;: </span>
<span class="gd">-        187, &#39;&#39;: -135, &#39;&#39;: 195, &#39;&#39;: -673, &#39;&#39;: -496, &#39;&#39;: -277, &#39;&#39;: 201,</span>
<span class="gd">-        &#39;&#39;: -800, &#39;&#39;: 624, &#39;&#39;: 302, &#39;&#39;: 1792, &#39;&#39;: -1212, &#39;&#39;: 798, &#39;&#39;:</span>
<span class="gd">-        -960, &#39;&#39;: 887, &#39;&#39;: -695, &#39;&#39;: 535, &#39;&#39;: -697, &#39;&#39;: 753, &#39;&#39;: -507,</span>
<span class="gd">-        &#39;&#39;: 974, &#39;&#39;: -822, &#39;&#39;: 1811, &#39;&#39;: 463, &#39;&#39;: 1082, &#39;&#39;: -270,</span>
<span class="gd">-        &#39;&#39;: 306, &#39;&#39;: -673, &#39;&#39;: -496}</span>
<span class="gi">+             &#39;&#39;: -307, &#39;&#39;: 189, &#39;&#39;: 241, &#39;&#39;: -73, &#39;&#39;: -121, &#39;&#39;: -200,</span>
<span class="gi">+             &#39;&#39;: 1782, &#39;&#39;: 383, &#39;&#39;: -428, &#39;&#39;: 573, &#39;&#39;: -1014, &#39;&#39;: 101,</span>
<span class="gi">+             &#39;&#39;: -105, &#39;&#39;: -253, &#39;&#39;: -149, &#39;&#39;: -417, &#39;&#39;: -236, &#39;&#39;: -206,</span>
<span class="gi">+             &#39;&#39;: 187, &#39;&#39;: -135, &#39;&#39;: 195, &#39;&#39;: -673, &#39;&#39;: -496, &#39;&#39;: -277,</span>
<span class="gi">+             &#39;&#39;: 201, &#39;&#39;: -800, &#39;&#39;: 624, &#39;&#39;: 302, &#39;&#39;: 1792, &#39;&#39;: -1212,</span>
<span class="gi">+             &#39;&#39;: 798, &#39;&#39;: -960, &#39;&#39;: 887, &#39;&#39;: -695, &#39;&#39;: 535, &#39;&#39;: -697,</span>
<span class="gi">+             &#39;&#39;: 753, &#39;&#39;: -507, &#39;&#39;: 974, &#39;&#39;: -822, &#39;&#39;: 1811, &#39;&#39;: 463,</span>
<span class="gi">+             &#39;&#39;: 1082, &#39;&#39;: -270, &#39;&#39;: 306, &#39;&#39;: -673, &#39;&#39;: -496}</span>
<span class="gi">+</span>
<span class="gi">+    # ctype_</span>
<span class="gi">+    def ctype_(self, char: str) -&gt; str:</span>
<span class="gi">+        for pattern, value in self.patterns_.items():</span>
<span class="gi">+            if pattern.match(char):</span>
<span class="gi">+                return value</span>
<span class="gi">+        return &#39;O&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # ts_</span>
<span class="gi">+    def ts_(self, dict: dict[str, int], key: str) -&gt; int:</span>
<span class="gi">+        if key in dict:</span>
<span class="gi">+            return dict[key]</span>
<span class="gi">+        return 0</span>
<span class="gi">+</span>
<span class="gi">+    # segment</span>
<span class="gi">+    def split(self, input: str) -&gt; list[str]:</span>
<span class="gi">+        if not input:</span>
<span class="gi">+            return []</span>
<span class="gi">+</span>
<span class="gi">+        result = []</span>
<span class="gi">+        seg = [&#39;B3&#39;, &#39;B2&#39;, &#39;B1&#39;, *input, &#39;E1&#39;, &#39;E2&#39;, &#39;E3&#39;]</span>
<span class="gi">+        ctype = [&#39;O&#39;, &#39;O&#39;, &#39;O&#39;, *map(self.ctype_, input), &#39;O&#39;, &#39;O&#39;, &#39;O&#39;]</span>
<span class="gi">+        word = seg[3]</span>
<span class="gi">+        p1 = &#39;U&#39;</span>
<span class="gi">+        p2 = &#39;U&#39;</span>
<span class="gi">+        p3 = &#39;U&#39;</span>
<span class="gi">+</span>
<span class="gi">+        for i in range(4, len(seg) - 3):</span>
<span class="gi">+            score = self.BIAS__</span>
<span class="gi">+            w1 = seg[i-3]</span>
<span class="gi">+            w2 = seg[i-2]</span>
<span class="gi">+            w3 = seg[i-1]</span>
<span class="gi">+            w4 = seg[i]</span>
<span class="gi">+            w5 = seg[i+1]</span>
<span class="gi">+            w6 = seg[i+2]</span>
<span class="gi">+            c1 = ctype[i-3]</span>
<span class="gi">+            c2 = ctype[i-2]</span>
<span class="gi">+            c3 = ctype[i-1]</span>
<span class="gi">+            c4 = ctype[i]</span>
<span class="gi">+            c5 = ctype[i+1]</span>
<span class="gi">+            c6 = ctype[i+2]</span>
<span class="gi">+            score += self.ts_(self.UP1__, p1)</span>
<span class="gi">+            score += self.ts_(self.UP2__, p2)</span>
<span class="gi">+            score += self.ts_(self.UP3__, p3)</span>
<span class="gi">+            score += self.ts_(self.BP1__, p1 + p2)</span>
<span class="gi">+            score += self.ts_(self.BP2__, p2 + p3)</span>
<span class="gi">+            score += self.ts_(self.UW1__, w1)</span>
<span class="gi">+            score += self.ts_(self.UW2__, w2)</span>
<span class="gi">+            score += self.ts_(self.UW3__, w3)</span>
<span class="gi">+            score += self.ts_(self.UW4__, w4)</span>
<span class="gi">+            score += self.ts_(self.UW5__, w5)</span>
<span class="gi">+            score += self.ts_(self.UW6__, w6)</span>
<span class="gi">+            score += self.ts_(self.BW1__, w2 + w3)</span>
<span class="gi">+            score += self.ts_(self.BW2__, w3 + w4)</span>
<span class="gi">+            score += self.ts_(self.BW3__, w4 + w5)</span>
<span class="gi">+            score += self.ts_(self.TW1__, w1 + w2 + w3)</span>
<span class="gi">+            score += self.ts_(self.TW2__, w2 + w3 + w4)</span>
<span class="gi">+            score += self.ts_(self.TW3__, w3 + w4 + w5)</span>
<span class="gi">+            score += self.ts_(self.TW4__, w4 + w5 + w6)</span>
<span class="gi">+            score += self.ts_(self.UC1__, c1)</span>
<span class="gi">+            score += self.ts_(self.UC2__, c2)</span>
<span class="gi">+            score += self.ts_(self.UC3__, c3)</span>
<span class="gi">+            score += self.ts_(self.UC4__, c4)</span>
<span class="gi">+            score += self.ts_(self.UC5__, c5)</span>
<span class="gi">+            score += self.ts_(self.UC6__, c6)</span>
<span class="gi">+            score += self.ts_(self.BC1__, c2 + c3)</span>
<span class="gi">+            score += self.ts_(self.BC2__, c3 + c4)</span>
<span class="gi">+            score += self.ts_(self.BC3__, c4 + c5)</span>
<span class="gi">+            score += self.ts_(self.TC1__, c1 + c2 + c3)</span>
<span class="gi">+            score += self.ts_(self.TC2__, c2 + c3 + c4)</span>
<span class="gi">+            score += self.ts_(self.TC3__, c3 + c4 + c5)</span>
<span class="gi">+            score += self.ts_(self.TC4__, c4 + c5 + c6)</span>
<span class="gi">+#           score += self.ts_(self.TC5__, c4 + c5 + c6)</span>
<span class="gi">+            score += self.ts_(self.UQ1__, p1 + c1)</span>
<span class="gi">+            score += self.ts_(self.UQ2__, p2 + c2)</span>
<span class="gi">+            score += self.ts_(self.UQ1__, p3 + c3)</span>
<span class="gi">+            score += self.ts_(self.BQ1__, p2 + c2 + c3)</span>
<span class="gi">+            score += self.ts_(self.BQ2__, p2 + c3 + c4)</span>
<span class="gi">+            score += self.ts_(self.BQ3__, p3 + c2 + c3)</span>
<span class="gi">+            score += self.ts_(self.BQ4__, p3 + c3 + c4)</span>
<span class="gi">+            score += self.ts_(self.TQ1__, p2 + c1 + c2 + c3)</span>
<span class="gi">+            score += self.ts_(self.TQ2__, p2 + c2 + c3 + c4)</span>
<span class="gi">+            score += self.ts_(self.TQ3__, p3 + c1 + c2 + c3)</span>
<span class="gi">+            score += self.ts_(self.TQ4__, p3 + c2 + c3 + c4)</span>
<span class="gi">+            p = &#39;O&#39;</span>
<span class="gi">+            if score &gt; 0:</span>
<span class="gi">+                result.append(word.strip())</span>
<span class="gi">+                word = &#39;&#39;</span>
<span class="gi">+                p = &#39;B&#39;</span>
<span class="gi">+            p1 = p2</span>
<span class="gi">+            p2 = p3</span>
<span class="gi">+            p3 = p</span>
<span class="gi">+            word += seg[i]</span>
<span class="gi">+</span>
<span class="gi">+        result.append(word.strip())</span>
<span class="gi">+        return result</span>


<span class="w"> </span>class SearchJapanese(SearchLanguage):
<span class="gu">@@ -330,3 +503,26 @@ class SearchJapanese(SearchLanguage):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    lang = &#39;ja&#39;
<span class="w"> </span>    language_name = &#39;Japanese&#39;
<span class="gi">+</span>
<span class="gi">+    def init(self, options: dict[str, str]) -&gt; None:</span>
<span class="gi">+        dotted_path = options.get(&#39;type&#39;)</span>
<span class="gi">+        if dotted_path is None:</span>
<span class="gi">+            self.splitter = DefaultSplitter(options)</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                splitter_cls = import_object(</span>
<span class="gi">+                    dotted_path, &quot;html_search_options[&#39;type&#39;] setting&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+                self.splitter = splitter_cls(options)</span>
<span class="gi">+            except ExtensionError as exc:</span>
<span class="gi">+                msg = f&quot;Splitter module {dotted_path!r} can&#39;t be imported&quot;</span>
<span class="gi">+                raise ExtensionError(msg) from exc</span>
<span class="gi">+</span>
<span class="gi">+    def split(self, input: str) -&gt; list[str]:</span>
<span class="gi">+        return self.splitter.split(input)</span>
<span class="gi">+</span>
<span class="gi">+    def word_filter(self, stemmed_word: str) -&gt; bool:</span>
<span class="gi">+        return len(stemmed_word) &gt; 1</span>
<span class="gi">+</span>
<span class="gi">+    def stem(self, word: str) -&gt; str:</span>
<span class="gi">+        return word</span>
<span class="gh">diff --git a/sphinx/search/nl.py b/sphinx/search/nl.py</span>
<span class="gh">index 08808edf6..cb5e8c4f9 100644</span>
<span class="gd">--- a/sphinx/search/nl.py</span>
<span class="gi">+++ b/sphinx/search/nl.py</span>
<span class="gu">@@ -1,10 +1,14 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Dutch search language: includes the JS porter stemmer.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Dict
<span class="gi">+</span>
<span class="w"> </span>import snowballstemmer
<span class="gi">+</span>
<span class="w"> </span>from sphinx.search import SearchLanguage, parse_stop_word
<span class="gd">-dutch_stopwords = parse_stop_word(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+dutch_stopwords = parse_stop_word(&#39;&#39;&#39;</span>
<span class="w"> </span>| source: https://snowball.tartarus.org/algorithms/dutch/stop.txt
<span class="w"> </span>de             |  the
<span class="w"> </span>en             |  and
<span class="gu">@@ -107,8 +111,7 @@ uw             |  your</span>
<span class="w"> </span>iemand         |  somebody
<span class="w"> </span>geweest        |  been; past participle of &#39;be&#39;
<span class="w"> </span>andere         |  other
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    )</span>
<span class="gi">+&#39;&#39;&#39;)</span>


<span class="w"> </span>class SearchDutch(SearchLanguage):
<span class="gu">@@ -116,3 +119,9 @@ class SearchDutch(SearchLanguage):</span>
<span class="w"> </span>    language_name = &#39;Dutch&#39;
<span class="w"> </span>    js_stemmer_rawcode = &#39;dutch-stemmer.js&#39;
<span class="w"> </span>    stopwords = dutch_stopwords
<span class="gi">+</span>
<span class="gi">+    def init(self, options: dict[str, str]) -&gt; None:</span>
<span class="gi">+        self.stemmer = snowballstemmer.stemmer(&#39;dutch&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def stem(self, word: str) -&gt; str:</span>
<span class="gi">+        return self.stemmer.stemWord(word.lower())</span>
<span class="gh">diff --git a/sphinx/search/no.py b/sphinx/search/no.py</span>
<span class="gh">index eb6e4e26d..aa7c1043b 100644</span>
<span class="gd">--- a/sphinx/search/no.py</span>
<span class="gi">+++ b/sphinx/search/no.py</span>
<span class="gu">@@ -1,10 +1,14 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Norwegian search language: includes the JS Norwegian stemmer.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Dict
<span class="gi">+</span>
<span class="w"> </span>import snowballstemmer
<span class="gi">+</span>
<span class="w"> </span>from sphinx.search import SearchLanguage, parse_stop_word
<span class="gd">-norwegian_stopwords = parse_stop_word(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+norwegian_stopwords = parse_stop_word(&#39;&#39;&#39;</span>
<span class="w"> </span>| source: https://snowball.tartarus.org/algorithms/norwegian/stop.txt
<span class="w"> </span>og             | and
<span class="w"> </span>i              | in
<span class="gu">@@ -182,8 +186,7 @@ verte          | become *</span>
<span class="w"> </span>vort           | become *
<span class="w"> </span>varte          | became *
<span class="w"> </span>vart           | became *
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    )</span>
<span class="gi">+&#39;&#39;&#39;)</span>


<span class="w"> </span>class SearchNorwegian(SearchLanguage):
<span class="gu">@@ -191,3 +194,9 @@ class SearchNorwegian(SearchLanguage):</span>
<span class="w"> </span>    language_name = &#39;Norwegian&#39;
<span class="w"> </span>    js_stemmer_rawcode = &#39;norwegian-stemmer.js&#39;
<span class="w"> </span>    stopwords = norwegian_stopwords
<span class="gi">+</span>
<span class="gi">+    def init(self, options: dict[str, str]) -&gt; None:</span>
<span class="gi">+        self.stemmer = snowballstemmer.stemmer(&#39;norwegian&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def stem(self, word: str) -&gt; str:</span>
<span class="gi">+        return self.stemmer.stemWord(word.lower())</span>
<span class="gh">diff --git a/sphinx/search/pt.py b/sphinx/search/pt.py</span>
<span class="gh">index 634958238..0cf96109a 100644</span>
<span class="gd">--- a/sphinx/search/pt.py</span>
<span class="gi">+++ b/sphinx/search/pt.py</span>
<span class="gu">@@ -1,10 +1,14 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Portuguese search language: includes the JS Portuguese stemmer.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Dict
<span class="gi">+</span>
<span class="w"> </span>import snowballstemmer
<span class="gi">+</span>
<span class="w"> </span>from sphinx.search import SearchLanguage, parse_stop_word
<span class="gd">-portuguese_stopwords = parse_stop_word(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+portuguese_stopwords = parse_stop_word(&#39;&#39;&#39;</span>
<span class="w"> </span>| source: https://snowball.tartarus.org/algorithms/portuguese/stop.txt
<span class="w"> </span>de             |  of, from
<span class="w"> </span>a              |  the; to, at; her
<span class="gu">@@ -241,8 +245,7 @@ tero</span>
<span class="w"> </span>teria
<span class="w"> </span>teramos
<span class="w"> </span>teriam
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    )</span>
<span class="gi">+&#39;&#39;&#39;)</span>


<span class="w"> </span>class SearchPortuguese(SearchLanguage):
<span class="gu">@@ -250,3 +253,9 @@ class SearchPortuguese(SearchLanguage):</span>
<span class="w"> </span>    language_name = &#39;Portuguese&#39;
<span class="w"> </span>    js_stemmer_rawcode = &#39;portuguese-stemmer.js&#39;
<span class="w"> </span>    stopwords = portuguese_stopwords
<span class="gi">+</span>
<span class="gi">+    def init(self, options: dict[str, str]) -&gt; None:</span>
<span class="gi">+        self.stemmer = snowballstemmer.stemmer(&#39;portuguese&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def stem(self, word: str) -&gt; str:</span>
<span class="gi">+        return self.stemmer.stemWord(word.lower())</span>
<span class="gh">diff --git a/sphinx/search/ro.py b/sphinx/search/ro.py</span>
<span class="gh">index 85243751a..f15b7a6bb 100644</span>
<span class="gd">--- a/sphinx/search/ro.py</span>
<span class="gi">+++ b/sphinx/search/ro.py</span>
<span class="gu">@@ -1,7 +1,11 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Romanian search language: includes the JS Romanian stemmer.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Dict, Set
<span class="gi">+</span>
<span class="w"> </span>import snowballstemmer
<span class="gi">+</span>
<span class="w"> </span>from sphinx.search import SearchLanguage


<span class="gu">@@ -10,3 +14,9 @@ class SearchRomanian(SearchLanguage):</span>
<span class="w"> </span>    language_name = &#39;Romanian&#39;
<span class="w"> </span>    js_stemmer_rawcode = &#39;romanian-stemmer.js&#39;
<span class="w"> </span>    stopwords: set[str] = set()
<span class="gi">+</span>
<span class="gi">+    def init(self, options: dict[str, str]) -&gt; None:</span>
<span class="gi">+        self.stemmer = snowballstemmer.stemmer(&#39;romanian&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def stem(self, word: str) -&gt; str:</span>
<span class="gi">+        return self.stemmer.stemWord(word.lower())</span>
<span class="gh">diff --git a/sphinx/search/ru.py b/sphinx/search/ru.py</span>
<span class="gh">index a2a8a8712..d6b817ebe 100644</span>
<span class="gd">--- a/sphinx/search/ru.py</span>
<span class="gi">+++ b/sphinx/search/ru.py</span>
<span class="gu">@@ -1,10 +1,14 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Russian search language: includes the JS Russian stemmer.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Dict
<span class="gi">+</span>
<span class="w"> </span>import snowballstemmer
<span class="gi">+</span>
<span class="w"> </span>from sphinx.search import SearchLanguage, parse_stop_word
<span class="gd">-russian_stopwords = parse_stop_word(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+russian_stopwords = parse_stop_word(&#39;&#39;&#39;</span>
<span class="w"> </span>| source: https://snowball.tartarus.org/algorithms/russian/stop.txt
<span class="w"> </span>              | and
<span class="w"> </span>              | in/into
<span class="gu">@@ -231,8 +235,7 @@ russian_stopwords = parse_stop_word(</span>
<span class="w"> </span>  | 
<span class="w"> </span>  | 
<span class="w"> </span>  | 
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    )</span>
<span class="gi">+&#39;&#39;&#39;)</span>


<span class="w"> </span>class SearchRussian(SearchLanguage):
<span class="gu">@@ -240,3 +243,9 @@ class SearchRussian(SearchLanguage):</span>
<span class="w"> </span>    language_name = &#39;Russian&#39;
<span class="w"> </span>    js_stemmer_rawcode = &#39;russian-stemmer.js&#39;
<span class="w"> </span>    stopwords = russian_stopwords
<span class="gi">+</span>
<span class="gi">+    def init(self, options: dict[str, str]) -&gt; None:</span>
<span class="gi">+        self.stemmer = snowballstemmer.stemmer(&#39;russian&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def stem(self, word: str) -&gt; str:</span>
<span class="gi">+        return self.stemmer.stemWord(word.lower())</span>
<span class="gh">diff --git a/sphinx/search/sv.py b/sphinx/search/sv.py</span>
<span class="gh">index 3276ce85a..b90e22764 100644</span>
<span class="gd">--- a/sphinx/search/sv.py</span>
<span class="gi">+++ b/sphinx/search/sv.py</span>
<span class="gu">@@ -1,10 +1,14 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Swedish search language: includes the JS Swedish stemmer.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Dict
<span class="gi">+</span>
<span class="w"> </span>import snowballstemmer
<span class="gi">+</span>
<span class="w"> </span>from sphinx.search import SearchLanguage, parse_stop_word
<span class="gd">-swedish_stopwords = parse_stop_word(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+swedish_stopwords = parse_stop_word(&#39;&#39;&#39;</span>
<span class="w"> </span>| source: https://snowball.tartarus.org/algorithms/swedish/stop.txt
<span class="w"> </span>och            | and
<span class="w"> </span>det            | it, this/that
<span class="gu">@@ -120,8 +124,7 @@ vra           | our</span>
<span class="w"> </span>ert            | your
<span class="w"> </span>era            | your
<span class="w"> </span>vilkas         | whose
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    )</span>
<span class="gi">+&#39;&#39;&#39;)</span>


<span class="w"> </span>class SearchSwedish(SearchLanguage):
<span class="gu">@@ -129,3 +132,9 @@ class SearchSwedish(SearchLanguage):</span>
<span class="w"> </span>    language_name = &#39;Swedish&#39;
<span class="w"> </span>    js_stemmer_rawcode = &#39;swedish-stemmer.js&#39;
<span class="w"> </span>    stopwords = swedish_stopwords
<span class="gi">+</span>
<span class="gi">+    def init(self, options: dict[str, str]) -&gt; None:</span>
<span class="gi">+        self.stemmer = snowballstemmer.stemmer(&#39;swedish&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def stem(self, word: str) -&gt; str:</span>
<span class="gi">+        return self.stemmer.stemWord(word.lower())</span>
<span class="gh">diff --git a/sphinx/search/tr.py b/sphinx/search/tr.py</span>
<span class="gh">index 582d9271b..fdfc18a22 100644</span>
<span class="gd">--- a/sphinx/search/tr.py</span>
<span class="gi">+++ b/sphinx/search/tr.py</span>
<span class="gu">@@ -1,7 +1,11 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Turkish search language: includes the JS Turkish stemmer.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Dict, Set
<span class="gi">+</span>
<span class="w"> </span>import snowballstemmer
<span class="gi">+</span>
<span class="w"> </span>from sphinx.search import SearchLanguage


<span class="gu">@@ -10,3 +14,9 @@ class SearchTurkish(SearchLanguage):</span>
<span class="w"> </span>    language_name = &#39;Turkish&#39;
<span class="w"> </span>    js_stemmer_rawcode = &#39;turkish-stemmer.js&#39;
<span class="w"> </span>    stopwords: set[str] = set()
<span class="gi">+</span>
<span class="gi">+    def init(self, options: dict[str, str]) -&gt; None:</span>
<span class="gi">+        self.stemmer = snowballstemmer.stemmer(&#39;turkish&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def stem(self, word: str) -&gt; str:</span>
<span class="gi">+        return self.stemmer.stemWord(word.lower())</span>
<span class="gh">diff --git a/sphinx/search/zh.py b/sphinx/search/zh.py</span>
<span class="gh">index c10d2f820..e40c9a9fe 100644</span>
<span class="gd">--- a/sphinx/search/zh.py</span>
<span class="gi">+++ b/sphinx/search/zh.py</span>
<span class="gu">@@ -1,16 +1,21 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Chinese search language: includes routine to split words.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import re
<span class="gi">+</span>
<span class="w"> </span>import snowballstemmer
<span class="gi">+</span>
<span class="w"> </span>from sphinx.search import SearchLanguage
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="gd">-    import jieba</span>
<span class="gi">+    import jieba  # type: ignore[import-not-found]</span>
<span class="w"> </span>    JIEBA = True
<span class="w"> </span>except ImportError:
<span class="w"> </span>    JIEBA = False
<span class="gd">-english_stopwords = set(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+english_stopwords = set(&quot;&quot;&quot;</span>
<span class="w"> </span>a  and  are  as  at
<span class="w"> </span>be  but  by
<span class="w"> </span>for
<span class="gu">@@ -20,8 +25,8 @@ of  on  or</span>
<span class="w"> </span>such
<span class="w"> </span>that  the  their  then  there  these  they  this  to
<span class="w"> </span>was  will  with
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    .split())</span>
<span class="gi">+&quot;&quot;&quot;.split())</span>
<span class="gi">+</span>
<span class="w"> </span>js_porter_stemmer = &quot;&quot;&quot;
<span class="w"> </span>/**
<span class="w"> </span> * Porter Stemmer
<span class="gu">@@ -141,7 +146,8 @@ var Stemmer = function() {</span>
<span class="w"> </span>    }

<span class="w"> </span>    // Step 2
<span class="gd">-    re = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;</span>
<span class="gi">+    re = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|\</span>
<span class="gi">+ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;</span>
<span class="w"> </span>    if (re.test(w)) {
<span class="w"> </span>      var fp = re.exec(w);
<span class="w"> </span>      stem = fp[1];
<span class="gu">@@ -163,7 +169,8 @@ var Stemmer = function() {</span>
<span class="w"> </span>    }

<span class="w"> </span>    // Step 4
<span class="gd">-    re = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;</span>
<span class="gi">+    re = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|\</span>
<span class="gi">+iti|ous|ive|ize)$/;</span>
<span class="w"> </span>    re2 = /^(.+?)(s|t)(ion)$/;
<span class="w"> </span>    if (re.test(w)) {
<span class="w"> </span>      var fp = re.exec(w);
<span class="gu">@@ -211,9 +218,44 @@ class SearchChinese(SearchLanguage):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Chinese search implementation
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    lang = &#39;zh&#39;
<span class="w"> </span>    language_name = &#39;Chinese&#39;
<span class="w"> </span>    js_stemmer_code = js_porter_stemmer
<span class="w"> </span>    stopwords = english_stopwords
<span class="gd">-    latin1_letters = re.compile(&#39;[a-zA-Z0-9_]+&#39;)</span>
<span class="gi">+    latin1_letters = re.compile(r&#39;[a-zA-Z0-9_]+&#39;)</span>
<span class="w"> </span>    latin_terms: list[str] = []
<span class="gi">+</span>
<span class="gi">+    def init(self, options: dict[str, str]) -&gt; None:</span>
<span class="gi">+        if JIEBA:</span>
<span class="gi">+            dict_path = options.get(&#39;dict&#39;)</span>
<span class="gi">+            if dict_path and os.path.isfile(dict_path):</span>
<span class="gi">+                jieba.load_userdict(dict_path)</span>
<span class="gi">+</span>
<span class="gi">+        self.stemmer = snowballstemmer.stemmer(&#39;english&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def split(self, input: str) -&gt; list[str]:</span>
<span class="gi">+        chinese: list[str] = []</span>
<span class="gi">+        if JIEBA:</span>
<span class="gi">+            chinese = list(jieba.cut_for_search(input))</span>
<span class="gi">+</span>
<span class="gi">+        latin1 = \</span>
<span class="gi">+            [term.strip() for term in self.latin1_letters.findall(input)]</span>
<span class="gi">+        self.latin_terms.extend(latin1)</span>
<span class="gi">+        return chinese + latin1</span>
<span class="gi">+</span>
<span class="gi">+    def word_filter(self, stemmed_word: str) -&gt; bool:</span>
<span class="gi">+        return len(stemmed_word) &gt; 1</span>
<span class="gi">+</span>
<span class="gi">+    def stem(self, word: str) -&gt; str:</span>
<span class="gi">+        # Don&#39;t stem Latin words that are long enough to be relevant for search</span>
<span class="gi">+        # if not stemmed, but would be too short after being stemmed</span>
<span class="gi">+        # avoids some issues with acronyms</span>
<span class="gi">+        should_not_be_stemmed = (</span>
<span class="gi">+            word in self.latin_terms and</span>
<span class="gi">+            len(word) &gt;= 3 and</span>
<span class="gi">+            len(self.stemmer.stemWord(word.lower())) &lt; 3</span>
<span class="gi">+        )</span>
<span class="gi">+        if should_not_be_stemmed:</span>
<span class="gi">+            return word.lower()</span>
<span class="gi">+        return self.stemmer.stemWord(word.lower())</span>
<span class="gh">diff --git a/sphinx/testing/fixtures.py b/sphinx/testing/fixtures.py</span>
<span class="gh">index 354a465af..03e38e85e 100644</span>
<span class="gd">--- a/sphinx/testing/fixtures.py</span>
<span class="gi">+++ b/sphinx/testing/fixtures.py</span>
<span class="gu">@@ -1,46 +1,124 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Sphinx test fixtures for pytest&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import shutil
<span class="w"> </span>import subprocess
<span class="w"> </span>import sys
<span class="w"> </span>from collections import namedtuple
<span class="w"> </span>from io import StringIO
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>import pytest
<span class="gi">+</span>
<span class="w"> </span>from sphinx.testing.util import SphinxTestApp, SphinxTestAppWrapperForSkipBuilding
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Callable, Iterator
<span class="w"> </span>    from pathlib import Path
<span class="w"> </span>    from typing import Any
<span class="gi">+</span>
<span class="w"> </span>DEFAULT_ENABLED_MARKERS = [
<span class="gd">-    &#39;sphinx(buildername=&quot;html&quot;, *, testroot=&quot;root&quot;, srcdir=None, confoverrides=None, freshenv=False, warningiserror=False, tags=None, verbosity=0, parallel=0, builddir=None, docutils_conf=None): arguments to initialize the sphinx test application.&#39;</span>
<span class="gd">-    , &#39;test_params(shared_result=...): test parameters.&#39;]</span>
<span class="gi">+    # The marker signature differs from the constructor signature</span>
<span class="gi">+    # since the way it is processed assumes keyword arguments for</span>
<span class="gi">+    # the &#39;testroot&#39; and &#39;srcdir&#39;.</span>
<span class="gi">+    (</span>
<span class="gi">+        &#39;sphinx(&#39;</span>
<span class="gi">+        &#39;buildername=&quot;html&quot;, *, &#39;</span>
<span class="gi">+        &#39;testroot=&quot;root&quot;, srcdir=None, &#39;</span>
<span class="gi">+        &#39;confoverrides=None, freshenv=False, &#39;</span>
<span class="gi">+        &#39;warningiserror=False, tags=None, verbosity=0, parallel=0, &#39;</span>
<span class="gi">+        &#39;builddir=None, docutils_conf=None&#39;</span>
<span class="gi">+        &#39;): arguments to initialize the sphinx test application.&#39;</span>
<span class="gi">+    ),</span>
<span class="gi">+    &#39;test_params(shared_result=...): test parameters.&#39;,</span>
<span class="gi">+]</span>


<span class="gd">-def pytest_configure(config: pytest.Config) -&gt;None:</span>
<span class="gi">+def pytest_configure(config: pytest.Config) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Register custom markers&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for marker in DEFAULT_ENABLED_MARKERS:</span>
<span class="gi">+        config.addinivalue_line(&#39;markers&#39;, marker)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@pytest.fixture(scope=&#39;session&#39;)</span>
<span class="gi">+def rootdir() -&gt; Path | None:</span>
<span class="gi">+    return None</span>


<span class="w"> </span>class SharedResult:
<span class="w"> </span>    cache: dict[str, dict[str, str]] = {}

<span class="gi">+    def store(self, key: str, app_: SphinxTestApp) -&gt; Any:</span>
<span class="gi">+        if key in self.cache:</span>
<span class="gi">+            return</span>
<span class="gi">+        data = {</span>
<span class="gi">+            &#39;status&#39;: app_.status.getvalue(),</span>
<span class="gi">+            &#39;warning&#39;: app_.warning.getvalue(),</span>
<span class="gi">+        }</span>
<span class="gi">+        self.cache[key] = data</span>
<span class="gi">+</span>
<span class="gi">+    def restore(self, key: str) -&gt; dict[str, StringIO]:</span>
<span class="gi">+        if key not in self.cache:</span>
<span class="gi">+            return {}</span>
<span class="gi">+        data = self.cache[key]</span>
<span class="gi">+        return {</span>
<span class="gi">+            &#39;status&#39;: StringIO(data[&#39;status&#39;]),</span>
<span class="gi">+            &#39;warning&#39;: StringIO(data[&#39;warning&#39;]),</span>
<span class="gi">+        }</span>
<span class="gi">+</span>

<span class="w"> </span>@pytest.fixture
<span class="gd">-def app_params(request: Any, test_params: dict[str, Any], shared_result:</span>
<span class="gd">-    SharedResult, sphinx_test_tempdir: str, rootdir: Path) -&gt;_app_params:</span>
<span class="gi">+def app_params(</span>
<span class="gi">+    request: Any,</span>
<span class="gi">+    test_params: dict[str, Any],</span>
<span class="gi">+    shared_result: SharedResult,</span>
<span class="gi">+    sphinx_test_tempdir: str,</span>
<span class="gi">+    rootdir: Path,</span>
<span class="gi">+) -&gt; _app_params:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Parameters that are specified by &#39;pytest.mark.sphinx&#39; for
<span class="w"> </span>    sphinx.application.Sphinx initialization
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # ##### process pytest.mark.sphinx</span>
<span class="gi">+</span>
<span class="gi">+    pargs: dict[int, Any] = {}</span>
<span class="gi">+    kwargs: dict[str, Any] = {}</span>
<span class="gi">+</span>
<span class="gi">+    # to avoid stacking positional args</span>
<span class="gi">+    for info in reversed(list(request.node.iter_markers(&quot;sphinx&quot;))):</span>
<span class="gi">+        pargs |= dict(enumerate(info.args))</span>
<span class="gi">+        kwargs.update(info.kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    args = [pargs[i] for i in sorted(pargs.keys())]</span>
<span class="gi">+</span>
<span class="gi">+    # ##### process pytest.mark.test_params</span>
<span class="gi">+    if test_params[&#39;shared_result&#39;]:</span>
<span class="gi">+        if &#39;srcdir&#39; in kwargs:</span>
<span class="gi">+            msg = &#39;You can not specify shared_result and srcdir in same time.&#39;</span>
<span class="gi">+            pytest.fail(msg)</span>
<span class="gi">+        kwargs[&#39;srcdir&#39;] = test_params[&#39;shared_result&#39;]</span>
<span class="gi">+        restore = shared_result.restore(test_params[&#39;shared_result&#39;])</span>
<span class="gi">+        kwargs.update(restore)</span>
<span class="gi">+</span>
<span class="gi">+    # ##### prepare Application params</span>
<span class="gi">+</span>
<span class="gi">+    testroot = kwargs.pop(&#39;testroot&#39;, &#39;root&#39;)</span>
<span class="gi">+    kwargs[&#39;srcdir&#39;] = srcdir = sphinx_test_tempdir / kwargs.get(&#39;srcdir&#39;, testroot)</span>
<span class="gi">+</span>
<span class="gi">+    # special support for sphinx/tests</span>
<span class="gi">+    if rootdir and not srcdir.exists():</span>
<span class="gi">+        testroot_path = rootdir / (&#39;test-&#39; + testroot)</span>
<span class="gi">+        shutil.copytree(testroot_path, srcdir)</span>
<span class="gi">+</span>
<span class="gi">+    return _app_params(args, kwargs)</span>


<span class="w"> </span>_app_params = namedtuple(&#39;_app_params&#39;, &#39;args,kwargs&#39;)


<span class="w"> </span>@pytest.fixture
<span class="gd">-def test_params(request: Any) -&gt;dict[str, Any]:</span>
<span class="gi">+def test_params(request: Any) -&gt; dict[str, Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Test parameters that are specified by &#39;pytest.mark.test_params&#39;

<span class="gu">@@ -50,63 +128,124 @@ def test_params(request: Any) -&gt;dict[str, Any]:</span>
<span class="w"> </span>       have same &#39;shared_result&#39; value.
<span class="w"> </span>       **NOTE**: You can not specify both shared_result and srcdir.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    env = request.node.get_closest_marker(&#39;test_params&#39;)</span>
<span class="gi">+    kwargs = env.kwargs if env else {}</span>
<span class="gi">+    result = {</span>
<span class="gi">+        &#39;shared_result&#39;: None,</span>
<span class="gi">+    }</span>
<span class="gi">+    result.update(kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    if result[&#39;shared_result&#39;] and not isinstance(result[&#39;shared_result&#39;], str):</span>
<span class="gi">+        msg = &#39;You can only provide a string type of value for &quot;shared_result&quot;&#39;</span>
<span class="gi">+        raise pytest.Exception(msg)</span>
<span class="gi">+    return result</span>


<span class="w"> </span>@pytest.fixture
<span class="gd">-def app(test_params: dict[str, Any], app_params: _app_params, make_app:</span>
<span class="gd">-    Callable[[], SphinxTestApp], shared_result: SharedResult) -&gt;Iterator[</span>
<span class="gd">-    SphinxTestApp]:</span>
<span class="gi">+def app(</span>
<span class="gi">+    test_params: dict[str, Any],</span>
<span class="gi">+    app_params: _app_params,</span>
<span class="gi">+    make_app: Callable[[], SphinxTestApp],</span>
<span class="gi">+    shared_result: SharedResult,</span>
<span class="gi">+) -&gt; Iterator[SphinxTestApp]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Provides the &#39;sphinx.application.Sphinx&#39; object
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    args, kwargs = app_params</span>
<span class="gi">+    app_ = make_app(*args, **kwargs)</span>
<span class="gi">+    yield app_</span>
<span class="gi">+</span>
<span class="gi">+    print(&#39;# testroot:&#39;, kwargs.get(&#39;testroot&#39;, &#39;root&#39;))</span>
<span class="gi">+    print(&#39;# builder:&#39;, app_.builder.name)</span>
<span class="gi">+    print(&#39;# srcdir:&#39;, app_.srcdir)</span>
<span class="gi">+    print(&#39;# outdir:&#39;, app_.outdir)</span>
<span class="gi">+    print(&#39;# status:&#39;, &#39;\n&#39; + app_.status.getvalue())</span>
<span class="gi">+    print(&#39;# warning:&#39;, &#39;\n&#39; + app_.warning.getvalue())</span>
<span class="gi">+</span>
<span class="gi">+    if test_params[&#39;shared_result&#39;]:</span>
<span class="gi">+        shared_result.store(test_params[&#39;shared_result&#39;], app_)</span>


<span class="w"> </span>@pytest.fixture
<span class="gd">-def status(app: SphinxTestApp) -&gt;StringIO:</span>
<span class="gi">+def status(app: SphinxTestApp) -&gt; StringIO:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Back-compatibility for testing with previous @with_app decorator
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return app.status</span>


<span class="w"> </span>@pytest.fixture
<span class="gd">-def warning(app: SphinxTestApp) -&gt;StringIO:</span>
<span class="gi">+def warning(app: SphinxTestApp) -&gt; StringIO:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Back-compatibility for testing with previous @with_app decorator
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return app.warning</span>


<span class="w"> </span>@pytest.fixture
<span class="gd">-def make_app(test_params: dict[str, Any]) -&gt;Iterator[Callable[[],</span>
<span class="gd">-    SphinxTestApp]]:</span>
<span class="gi">+def make_app(test_params: dict[str, Any]) -&gt; Iterator[Callable[[], SphinxTestApp]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Provides make_app function to initialize SphinxTestApp instance.
<span class="w"> </span>    if you want to initialize &#39;app&#39; in your test function. please use this
<span class="w"> </span>    instead of using SphinxTestApp class directory.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    apps = []</span>
<span class="gi">+    syspath = sys.path.copy()</span>
<span class="gi">+</span>
<span class="gi">+    def make(*args: Any, **kwargs: Any) -&gt; SphinxTestApp:</span>
<span class="gi">+        status, warning = StringIO(), StringIO()</span>
<span class="gi">+        kwargs.setdefault(&#39;status&#39;, status)</span>
<span class="gi">+        kwargs.setdefault(&#39;warning&#39;, warning)</span>
<span class="gi">+        app_: SphinxTestApp</span>
<span class="gi">+        if test_params[&#39;shared_result&#39;]:</span>
<span class="gi">+            app_ = SphinxTestAppWrapperForSkipBuilding(*args, **kwargs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            app_ = SphinxTestApp(*args, **kwargs)</span>
<span class="gi">+        apps.append(app_)</span>
<span class="gi">+        return app_</span>
<span class="gi">+    yield make</span>
<span class="gi">+</span>
<span class="gi">+    sys.path[:] = syspath</span>
<span class="gi">+    for app_ in reversed(apps):  # clean up applications from the new ones</span>
<span class="gi">+        app_.cleanup()</span>


<span class="w"> </span>@pytest.fixture
<span class="gd">-def if_graphviz_found(app: SphinxTestApp) -&gt;None:</span>
<span class="gi">+def shared_result() -&gt; SharedResult:</span>
<span class="gi">+    return SharedResult()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@pytest.fixture(scope=&#39;module&#39;, autouse=True)</span>
<span class="gi">+def _shared_result_cache() -&gt; None:</span>
<span class="gi">+    SharedResult.cache.clear()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@pytest.fixture</span>
<span class="gi">+def if_graphviz_found(app: SphinxTestApp) -&gt; None:  # NoQA: PT004</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    The test will be skipped when using &#39;if_graphviz_found&#39; fixture and graphviz
<span class="w"> </span>    dot command is not found.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    graphviz_dot = getattr(app.config, &#39;graphviz_dot&#39;, &#39;&#39;)</span>
<span class="gi">+    try:</span>
<span class="gi">+        if graphviz_dot:</span>
<span class="gi">+            # print the graphviz_dot version, to check that the binary is available</span>
<span class="gi">+            subprocess.run([graphviz_dot, &#39;-V&#39;], capture_output=True, check=False)</span>
<span class="gi">+            return</span>
<span class="gi">+    except OSError:  # No such file or directory</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    pytest.skip(&#39;graphviz &quot;dot&quot; is not available&#39;)</span>


<span class="w"> </span>@pytest.fixture(scope=&#39;session&#39;)
<span class="gd">-def sphinx_test_tempdir(tmp_path_factory: pytest.TempPathFactory) -&gt;Path:</span>
<span class="gi">+def sphinx_test_tempdir(tmp_path_factory: pytest.TempPathFactory) -&gt; Path:</span>
<span class="w"> </span>    &quot;&quot;&quot;Temporary directory.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return tmp_path_factory.getbasetemp()</span>


<span class="w"> </span>@pytest.fixture
<span class="gd">-def rollback_sysmodules() -&gt;Iterator[None]:</span>
<span class="gi">+def rollback_sysmodules() -&gt; Iterator[None]:  # NoQA: PT004</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Rollback sys.modules to its value before testing to unload modules
<span class="w"> </span>    during tests.
<span class="gu">@@ -114,4 +253,10 @@ def rollback_sysmodules() -&gt;Iterator[None]:</span>
<span class="w"> </span>    For example, used in test_ext_autosummary.py to permit unloading the
<span class="w"> </span>    target module to clear its cache.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sysmodules = list(sys.modules)</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        for modname in list(sys.modules):</span>
<span class="gi">+            if modname not in sysmodules:</span>
<span class="gi">+                sys.modules.pop(modname)</span>
<span class="gh">diff --git a/sphinx/testing/path.py b/sphinx/testing/path.py</span>
<span class="gh">index 6aa6b7bf7..49f0ffa60 100644</span>
<span class="gd">--- a/sphinx/testing/path.py</span>
<span class="gi">+++ b/sphinx/testing/path.py</span>
<span class="gu">@@ -1,22 +1,30 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import shutil
<span class="w"> </span>import sys
<span class="w"> </span>import warnings
<span class="w"> </span>from typing import IO, TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from sphinx.deprecation import RemovedInSphinx90Warning
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    import builtins
<span class="w"> </span>    from collections.abc import Callable
<span class="gd">-warnings.warn(</span>
<span class="gd">-    &quot;&#39;sphinx.testing.path&#39; is deprecated. Use &#39;os.path&#39; or &#39;pathlib&#39; instead.&quot;,</span>
<span class="gd">-    RemovedInSphinx90Warning, stacklevel=2)</span>
<span class="gi">+</span>
<span class="gi">+warnings.warn(&quot;&#39;sphinx.testing.path&#39; is deprecated. &quot;</span>
<span class="gi">+              &quot;Use &#39;os.path&#39; or &#39;pathlib&#39; instead.&quot;,</span>
<span class="gi">+              RemovedInSphinx90Warning, stacklevel=2)</span>
<span class="gi">+</span>
<span class="w"> </span>FILESYSTEMENCODING = sys.getfilesystemencoding() or sys.getdefaultencoding()


<span class="gd">-def getumask() -&gt;int:</span>
<span class="gi">+def getumask() -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get current umask value&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    umask = os.umask(0)  # Note: Change umask value temporarily to obtain it</span>
<span class="gi">+    os.umask(umask)</span>
<span class="gi">+</span>
<span class="gi">+    return umask</span>


<span class="w"> </span>UMASK = getumask()
<span class="gu">@@ -26,53 +34,60 @@ class path(str):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Represents a path which behaves like a string.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    __slots__ = ()

<span class="w"> </span>    @property
<span class="gd">-    def parent(self) -&gt;path:</span>
<span class="gi">+    def parent(self) -&gt; path:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        The name of the directory the file or directory is in.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.__class__(os.path.dirname(self))</span>

<span class="gd">-    def abspath(self) -&gt;path:</span>
<span class="gi">+    def basename(self) -&gt; str:</span>
<span class="gi">+        return os.path.basename(self)</span>
<span class="gi">+</span>
<span class="gi">+    def abspath(self) -&gt; path:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns the absolute path.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.__class__(os.path.abspath(self))</span>

<span class="gd">-    def isabs(self) -&gt;bool:</span>
<span class="gi">+    def isabs(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns ``True`` if the path is absolute.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return os.path.isabs(self)</span>

<span class="gd">-    def isdir(self) -&gt;bool:</span>
<span class="gi">+    def isdir(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns ``True`` if the path is a directory.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return os.path.isdir(self)</span>

<span class="gd">-    def isfile(self) -&gt;bool:</span>
<span class="gi">+    def isfile(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns ``True`` if the path is a file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return os.path.isfile(self)</span>

<span class="gd">-    def islink(self) -&gt;bool:</span>
<span class="gi">+    def islink(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns ``True`` if the path is a symbolic link.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return os.path.islink(self)</span>

<span class="gd">-    def ismount(self) -&gt;bool:</span>
<span class="gi">+    def ismount(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns ``True`` if the path is a mount point.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return os.path.ismount(self)</span>

<span class="gd">-    def rmtree(self, ignore_errors: bool=False, onerror: (Callable[[</span>
<span class="gd">-        Callable[..., Any], str, Any], object] | None)=None) -&gt;None:</span>
<span class="gi">+    def rmtree(</span>
<span class="gi">+        self,</span>
<span class="gi">+        ignore_errors: bool = False,</span>
<span class="gi">+        onerror:  Callable[[Callable[..., Any], str, Any], object] | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Removes the file or directory and any files or directories it may
<span class="w"> </span>        contain.
<span class="gu">@@ -88,9 +103,9 @@ class path(str):</span>
<span class="w"> </span>            caused it to fail and `exc_info` is a tuple as returned by
<span class="w"> </span>            :func:`sys.exc_info`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        shutil.rmtree(self, ignore_errors=ignore_errors, onerror=onerror)</span>

<span class="gd">-    def copytree(self, destination: str, symlinks: bool=False) -&gt;None:</span>
<span class="gi">+    def copytree(self, destination: str, symlinks: bool = False) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Recursively copy a directory to the given `destination`. If the given
<span class="w"> </span>        `destination` does not exist it will be created.
<span class="gu">@@ -100,9 +115,19 @@ class path(str):</span>
<span class="w"> </span>            links in the destination tree otherwise the contents of the files
<span class="w"> </span>            pointed to by the symbolic links are copied.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        shutil.copytree(self, destination, symlinks=symlinks)</span>
<span class="gi">+        if os.environ.get(&#39;SPHINX_READONLY_TESTDIR&#39;):</span>
<span class="gi">+            # If source tree is marked read-only (e.g. because it is on a read-only</span>
<span class="gi">+            # filesystem), `shutil.copytree` will mark the destination as read-only</span>
<span class="gi">+            # as well.  To avoid failures when adding additional files/directories</span>
<span class="gi">+            # to the destination tree, ensure destination directories are not marked</span>
<span class="gi">+            # read-only.</span>
<span class="gi">+            for root, _dirs, files in os.walk(destination):</span>
<span class="gi">+                os.chmod(root, 0o755 &amp; ~UMASK)</span>
<span class="gi">+                for name in files:</span>
<span class="gi">+                    os.chmod(os.path.join(root, name), 0o644 &amp; ~UMASK)</span>

<span class="gd">-    def movetree(self, destination: str) -&gt;None:</span>
<span class="gi">+    def movetree(self, destination: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Recursively move the file or directory to the given `destination`
<span class="w"> </span>        similar to the  Unix &quot;mv&quot; command.
<span class="gu">@@ -110,74 +135,92 @@ class path(str):</span>
<span class="w"> </span>        If the `destination` is a file it may be overwritten depending on the
<span class="w"> </span>        :func:`os.rename` semantics.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        shutil.move(self, destination)</span>
<span class="gi">+</span>
<span class="w"> </span>    move = movetree

<span class="gd">-    def unlink(self) -&gt;None:</span>
<span class="gi">+    def unlink(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Removes a file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        os.unlink(self)</span>

<span class="gd">-    def stat(self) -&gt;Any:</span>
<span class="gi">+    def stat(self) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns a stat of the file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return os.stat(self)</span>
<span class="gi">+</span>
<span class="gi">+    def utime(self, arg: Any) -&gt; None:</span>
<span class="gi">+        os.utime(self, arg)</span>

<span class="gd">-    def write_text(self, text: str, encoding: str=&#39;utf-8&#39;, **kwargs: Any</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def open(self, mode: str = &#39;r&#39;, **kwargs: Any) -&gt; IO[str]:</span>
<span class="gi">+        return open(self, mode, **kwargs)  # NoQA: SIM115</span>
<span class="gi">+</span>
<span class="gi">+    def write_text(self, text: str, encoding: str = &#39;utf-8&#39;, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Writes the given `text` to the file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with open(self, &#39;w&#39;, encoding=encoding, **kwargs) as f:</span>
<span class="gi">+            f.write(text)</span>

<span class="gd">-    def read_text(self, encoding: str=&#39;utf-8&#39;, **kwargs: Any) -&gt;str:</span>
<span class="gi">+    def read_text(self, encoding: str = &#39;utf-8&#39;, **kwargs: Any) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns the text in the file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with open(self, encoding=encoding, **kwargs) as f:</span>
<span class="gi">+            return f.read()</span>

<span class="gd">-    def read_bytes(self) -&gt;builtins.bytes:</span>
<span class="gi">+    def read_bytes(self) -&gt; builtins.bytes:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns the bytes in the file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with open(self, mode=&#39;rb&#39;) as f:</span>
<span class="gi">+            return f.read()</span>

<span class="gd">-    def write_bytes(self, bytes: bytes, append: bool=False) -&gt;None:</span>
<span class="gi">+    def write_bytes(self, bytes: bytes, append: bool = False) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Writes the given `bytes` to the file.

<span class="w"> </span>        :param append:
<span class="w"> </span>            If ``True`` given `bytes` are added at the end of the file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if append:</span>
<span class="gi">+            mode = &#39;ab&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            mode = &#39;wb&#39;</span>
<span class="gi">+        with open(self, mode=mode) as f:</span>
<span class="gi">+            f.write(bytes)</span>

<span class="gd">-    def exists(self) -&gt;bool:</span>
<span class="gi">+    def exists(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns ``True`` if the path exist.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return os.path.exists(self)</span>

<span class="gd">-    def lexists(self) -&gt;bool:</span>
<span class="gi">+    def lexists(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns ``True`` if the path exists unless it is a broken symbolic
<span class="w"> </span>        link.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return os.path.lexists(self)</span>

<span class="gd">-    def makedirs(self, mode: int=511, exist_ok: bool=False) -&gt;None:</span>
<span class="gi">+    def makedirs(self, mode: int = 0o777, exist_ok: bool = False) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Recursively create directories.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        os.makedirs(self, mode, exist_ok=exist_ok)</span>

<span class="gd">-    def joinpath(self, *args: Any) -&gt;path:</span>
<span class="gi">+    def joinpath(self, *args: Any) -&gt; path:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Joins the path with the argument given and returns the result.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.__class__(os.path.join(self, *map(self.__class__, args)))</span>
<span class="gi">+</span>
<span class="gi">+    def listdir(self) -&gt; list[str]:</span>
<span class="gi">+        return os.listdir(self)</span>
<span class="gi">+</span>
<span class="w"> </span>    __div__ = __truediv__ = joinpath

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return f&#39;{self.__class__.__name__}({super().__repr__()})&#39;
<span class="gh">diff --git a/sphinx/testing/restructuredtext.py b/sphinx/testing/restructuredtext.py</span>
<span class="gh">index f8e53bc18..1f89336db 100644</span>
<span class="gd">--- a/sphinx/testing/restructuredtext.py</span>
<span class="gi">+++ b/sphinx/testing/restructuredtext.py</span>
<span class="gu">@@ -1,12 +1,35 @@</span>
<span class="w"> </span>from os import path
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.core import publish_doctree
<span class="gi">+</span>
<span class="w"> </span>from sphinx.application import Sphinx
<span class="w"> </span>from sphinx.io import SphinxStandaloneReader
<span class="w"> </span>from sphinx.parsers import RSTParser
<span class="w"> </span>from sphinx.util.docutils import sphinx_domains


<span class="gd">-def parse(app: Sphinx, text: str, docname: str=&#39;index&#39;) -&gt;nodes.document:</span>
<span class="gi">+def parse(app: Sphinx, text: str, docname: str = &#39;index&#39;) -&gt; nodes.document:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a string as reStructuredText with Sphinx application.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        app.env.temp_data[&#39;docname&#39;] = docname</span>
<span class="gi">+        reader = SphinxStandaloneReader()</span>
<span class="gi">+        reader.setup(app)</span>
<span class="gi">+        parser = RSTParser()</span>
<span class="gi">+        parser.set_application(app)</span>
<span class="gi">+        with sphinx_domains(app.env):</span>
<span class="gi">+            return publish_doctree(</span>
<span class="gi">+                text,</span>
<span class="gi">+                path.join(app.srcdir, docname + &#39;.rst&#39;),</span>
<span class="gi">+                reader=reader,</span>
<span class="gi">+                parser=parser,</span>
<span class="gi">+                settings_overrides={</span>
<span class="gi">+                    &#39;env&#39;: app.env,</span>
<span class="gi">+                    &#39;gettext_compact&#39;: True,</span>
<span class="gi">+                    &#39;input_encoding&#39;: &#39;utf-8&#39;,</span>
<span class="gi">+                    &#39;output_encoding&#39;: &#39;unicode&#39;,</span>
<span class="gi">+                    &#39;traceback&#39;: True,</span>
<span class="gi">+                },</span>
<span class="gi">+            )</span>
<span class="gi">+    finally:</span>
<span class="gi">+        app.env.temp_data.pop(&#39;docname&#39;, None)</span>
<span class="gh">diff --git a/sphinx/testing/util.py b/sphinx/testing/util.py</span>
<span class="gh">index 6b9e7daa2..9cf77d304 100644</span>
<span class="gd">--- a/sphinx/testing/util.py</span>
<span class="gi">+++ b/sphinx/testing/util.py</span>
<span class="gu">@@ -1,30 +1,80 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Sphinx test suite utilities&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gd">-__all__ = &#39;SphinxTestApp&#39;, &#39;SphinxTestAppWrapperForSkipBuilding&#39;</span>
<span class="gi">+</span>
<span class="gi">+__all__ = (&#39;SphinxTestApp&#39;, &#39;SphinxTestAppWrapperForSkipBuilding&#39;)</span>
<span class="gi">+</span>
<span class="w"> </span>import contextlib
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="w"> </span>from io import StringIO
<span class="w"> </span>from types import MappingProxyType
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.parsers.rst import directives, roles
<span class="gi">+</span>
<span class="w"> </span>import sphinx.application
<span class="w"> </span>import sphinx.locale
<span class="w"> </span>import sphinx.pycode
<span class="w"> </span>from sphinx.util.console import strip_colors
<span class="w"> </span>from sphinx.util.docutils import additional_nodes
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Mapping, Sequence
<span class="w"> </span>    from pathlib import Path
<span class="w"> </span>    from typing import Any
<span class="w"> </span>    from xml.etree.ElementTree import ElementTree
<span class="gi">+</span>
<span class="w"> </span>    from docutils.nodes import Node


<span class="gd">-def etree_parse(path: (str | os.PathLike[str])) -&gt;ElementTree:</span>
<span class="gi">+def assert_node(node: Node, cls: Any = None, xpath: str = &quot;&quot;, **kwargs: Any) -&gt; None:</span>
<span class="gi">+    if cls:</span>
<span class="gi">+        if isinstance(cls, list):</span>
<span class="gi">+            assert_node(node, cls[0], xpath=xpath, **kwargs)</span>
<span class="gi">+            if cls[1:]:</span>
<span class="gi">+                if isinstance(cls[1], tuple):</span>
<span class="gi">+                    assert_node(node, cls[1], xpath=xpath, **kwargs)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    assert isinstance(node, nodes.Element), \</span>
<span class="gi">+                        &#39;The node%s does not have any children&#39; % xpath</span>
<span class="gi">+                    assert len(node) == 1, \</span>
<span class="gi">+                        &#39;The node%s has %d child nodes, not one&#39; % (xpath, len(node))</span>
<span class="gi">+                    assert_node(node[0], cls[1:], xpath=xpath + &quot;[0]&quot;, **kwargs)</span>
<span class="gi">+        elif isinstance(cls, tuple):</span>
<span class="gi">+            assert isinstance(node, list | nodes.Element), \</span>
<span class="gi">+                &#39;The node%s does not have any items&#39; % xpath</span>
<span class="gi">+            assert len(node) == len(cls), \</span>
<span class="gi">+                &#39;The node%s has %d child nodes, not %r&#39; % (xpath, len(node), len(cls))</span>
<span class="gi">+            for i, nodecls in enumerate(cls):</span>
<span class="gi">+                path = xpath + &quot;[%d]&quot; % i</span>
<span class="gi">+                assert_node(node[i], nodecls, xpath=path, **kwargs)</span>
<span class="gi">+        elif isinstance(cls, str):</span>
<span class="gi">+            assert node == cls, f&#39;The node {xpath!r} is not {cls!r}: {node!r}&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert isinstance(node, cls), \</span>
<span class="gi">+                f&#39;The node{xpath} is not subclass of {cls!r}: {node!r}&#39;</span>
<span class="gi">+</span>
<span class="gi">+    if kwargs:</span>
<span class="gi">+        assert isinstance(node, nodes.Element), \</span>
<span class="gi">+            &#39;The node%s does not have any attributes&#39; % xpath</span>
<span class="gi">+</span>
<span class="gi">+        for key, value in kwargs.items():</span>
<span class="gi">+            if key not in node:</span>
<span class="gi">+                if (key := key.replace(&#39;_&#39;, &#39;-&#39;)) not in node:</span>
<span class="gi">+                    msg = f&#39;The node{xpath} does not have {key!r} attribute: {node!r}&#39;</span>
<span class="gi">+                    raise AssertionError(msg)</span>
<span class="gi">+            assert node[key] == value, \</span>
<span class="gi">+                f&#39;The node{xpath}[{key}] is not {value!r}: {node[key]!r}&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# keep this to restrict the API usage and to have a correct return type</span>
<span class="gi">+def etree_parse(path: str | os.PathLike[str]) -&gt; ElementTree:</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse a file into a (safe) XML element tree.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from defusedxml.ElementTree import parse as xml_parse</span>
<span class="gi">+</span>
<span class="gi">+    return xml_parse(path)</span>


<span class="w"> </span>class SphinxTestApp(sphinx.application.Sphinx):
<span class="gu">@@ -49,36 +99,61 @@ class SphinxTestApp(sphinx.application.Sphinx):</span>
<span class="w"> </span>    directory, whereas in the latter, the user must provide it themselves.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, /, buildername: str=&#39;html&#39;, srcdir: (Path | None)=</span>
<span class="gd">-        None, builddir: (Path | None)=None, freshenv: bool=False,</span>
<span class="gd">-        confoverrides: (dict[str, Any] | None)=None, status: (StringIO |</span>
<span class="gd">-        None)=None, warning: (StringIO | None)=None, tags: Sequence[str]=(),</span>
<span class="gd">-        docutils_conf: (str | None)=None, parallel: int=0, verbosity: int=0,</span>
<span class="gd">-        warningiserror: bool=False, pdb: bool=False, exception_on_warning:</span>
<span class="gd">-        bool=False, **extras: Any) -&gt;None:</span>
<span class="gi">+    # see https://github.com/sphinx-doc/sphinx/pull/12089 for the</span>
<span class="gi">+    # discussion on how the signature of this class should be used</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        /,  # to allow &#39;self&#39; as an extras</span>
<span class="gi">+        buildername: str = &#39;html&#39;,</span>
<span class="gi">+        srcdir: Path | None = None,</span>
<span class="gi">+        builddir: Path | None = None,  # extra constructor argument</span>
<span class="gi">+        freshenv: bool = False,  # argument is not in the same order as in the superclass</span>
<span class="gi">+        confoverrides: dict[str, Any] | None = None,</span>
<span class="gi">+        status: StringIO | None = None,</span>
<span class="gi">+        warning: StringIO | None = None,</span>
<span class="gi">+        tags: Sequence[str] = (),</span>
<span class="gi">+        docutils_conf: str | None = None,  # extra constructor argument</span>
<span class="gi">+        parallel: int = 0,</span>
<span class="gi">+        # additional arguments at the end to keep the signature</span>
<span class="gi">+        verbosity: int = 0,  # argument is not in the same order as in the superclass</span>
<span class="gi">+        warningiserror: bool = False,  # argument is not in the same order as in the superclass</span>
<span class="gi">+        pdb: bool = False,</span>
<span class="gi">+        exception_on_warning: bool = False,</span>
<span class="gi">+        # unknown keyword arguments</span>
<span class="gi">+        **extras: Any,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        assert srcdir is not None
<span class="gi">+</span>
<span class="w"> </span>        if verbosity == -1:
<span class="w"> </span>            quiet = True
<span class="w"> </span>            verbosity = 0
<span class="w"> </span>        else:
<span class="w"> </span>            quiet = False
<span class="gi">+</span>
<span class="w"> </span>        if status is None:
<span class="gi">+            # ensure that :attr:`status` is a StringIO and not sys.stdout</span>
<span class="gi">+            # but allow the stream to be /dev/null by passing verbosity=-1</span>
<span class="w"> </span>            status = None if quiet else StringIO()
<span class="w"> </span>        elif not isinstance(status, StringIO):
<span class="gd">-            err = &#39;%r must be an io.StringIO object, got: %s&#39; % (&#39;status&#39;,</span>
<span class="gd">-                type(status))</span>
<span class="gi">+            err = &quot;%r must be an io.StringIO object, got: %s&quot; % (&#39;status&#39;, type(status))</span>
<span class="w"> </span>            raise TypeError(err)
<span class="gi">+</span>
<span class="w"> </span>        if warning is None:
<span class="gi">+            # ensure that :attr:`warning` is a StringIO and not sys.stderr</span>
<span class="gi">+            # but allow the stream to be /dev/null by passing verbosity=-1</span>
<span class="w"> </span>            warning = None if quiet else StringIO()
<span class="w"> </span>        elif not isinstance(warning, StringIO):
<span class="gd">-            err = &#39;%r must be an io.StringIO object, got: %s&#39; % (&#39;warning&#39;,</span>
<span class="gd">-                type(warning))</span>
<span class="gi">+            err = &#39;%r must be an io.StringIO object, got: %s&#39; % (&#39;warning&#39;, type(warning))</span>
<span class="w"> </span>            raise TypeError(err)
<span class="gi">+</span>
<span class="w"> </span>        self.docutils_conf_path = srcdir / &#39;docutils.conf&#39;
<span class="w"> </span>        if docutils_conf is not None:
<span class="w"> </span>            self.docutils_conf_path.write_text(docutils_conf, encoding=&#39;utf8&#39;)
<span class="gi">+</span>
<span class="w"> </span>        if builddir is None:
<span class="w"> </span>            builddir = srcdir / &#39;_build&#39;
<span class="gi">+</span>
<span class="w"> </span>        confdir = srcdir
<span class="w"> </span>        outdir = builddir.joinpath(buildername)
<span class="w"> </span>        outdir.mkdir(parents=True, exist_ok=True)
<span class="gu">@@ -86,32 +161,60 @@ class SphinxTestApp(sphinx.application.Sphinx):</span>
<span class="w"> </span>        doctreedir.mkdir(parents=True, exist_ok=True)
<span class="w"> </span>        if confoverrides is None:
<span class="w"> </span>            confoverrides = {}
<span class="gi">+</span>
<span class="w"> </span>        self._saved_path = sys.path.copy()
<span class="w"> </span>        self.extras: Mapping[str, Any] = MappingProxyType(extras)
<span class="w"> </span>        &quot;&quot;&quot;Extras keyword arguments.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>        try:
<span class="gd">-            super().__init__(srcdir, confdir, outdir, doctreedir,</span>
<span class="gd">-                buildername, confoverrides=confoverrides, status=status,</span>
<span class="gd">-                warning=warning, freshenv=freshenv, warningiserror=</span>
<span class="gd">-                warningiserror, tags=tags, verbosity=verbosity, parallel=</span>
<span class="gd">-                parallel, pdb=pdb, exception_on_warning=exception_on_warning)</span>
<span class="gi">+            super().__init__(</span>
<span class="gi">+                srcdir, confdir, outdir, doctreedir, buildername,</span>
<span class="gi">+                confoverrides=confoverrides, status=status, warning=warning,</span>
<span class="gi">+                freshenv=freshenv, warningiserror=warningiserror, tags=tags,</span>
<span class="gi">+                verbosity=verbosity, parallel=parallel,</span>
<span class="gi">+                pdb=pdb, exception_on_warning=exception_on_warning,</span>
<span class="gi">+            )</span>
<span class="w"> </span>        except Exception:
<span class="w"> </span>            self.cleanup()
<span class="w"> </span>            raise

<span class="gi">+    def _init_builder(self) -&gt; None:</span>
<span class="gi">+        # override the default theme to &#39;basic&#39; rather than &#39;alabaster&#39;</span>
<span class="gi">+        # for test independence</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;html_theme&#39; in self.config._overrides:</span>
<span class="gi">+            pass  # respect overrides</span>
<span class="gi">+        elif &#39;html_theme&#39; in self.config and self.config.html_theme == &#39;alabaster&#39;:</span>
<span class="gi">+            self.config.html_theme = self.config._overrides.get(&#39;html_theme&#39;, &#39;basic&#39;)</span>
<span class="gi">+        super()._init_builder()</span>
<span class="gi">+</span>
<span class="w"> </span>    @property
<span class="gd">-    def status(self) -&gt;StringIO:</span>
<span class="gi">+    def status(self) -&gt; StringIO:</span>
<span class="w"> </span>        &quot;&quot;&quot;The in-memory text I/O for the application status messages.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # sphinx.application.Sphinx uses StringIO for a quiet stream</span>
<span class="gi">+        assert isinstance(self._status, StringIO)</span>
<span class="gi">+        return self._status</span>

<span class="w"> </span>    @property
<span class="gd">-    def warning(self) -&gt;StringIO:</span>
<span class="gi">+    def warning(self) -&gt; StringIO:</span>
<span class="w"> </span>        &quot;&quot;&quot;The in-memory text I/O for the application warning messages.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # sphinx.application.Sphinx uses StringIO for a quiet stream</span>
<span class="gi">+        assert isinstance(self._warning, StringIO)</span>
<span class="gi">+        return self._warning</span>
<span class="gi">+</span>
<span class="gi">+    def cleanup(self, doctrees: bool = False) -&gt; None:</span>
<span class="gi">+        sys.path[:] = self._saved_path</span>
<span class="gi">+        _clean_up_global_state()</span>
<span class="gi">+        with contextlib.suppress(FileNotFoundError):</span>
<span class="gi">+            os.remove(self.docutils_conf_path)</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return f&#39;&lt;{self.__class__.__name__} buildername={self.builder.name!r}&gt;&#39;

<span class="gi">+    def build(self, force_all: bool = False, filenames: list[str] | None = None) -&gt; None:</span>
<span class="gi">+        self.env._pickled_doctree_cache.clear()</span>
<span class="gi">+        super().build(force_all, filenames)</span>
<span class="gi">+</span>

<span class="w"> </span>class SphinxTestAppWrapperForSkipBuilding(SphinxTestApp):
<span class="w"> </span>    &quot;&quot;&quot;A wrapper for SphinxTestApp.
<span class="gu">@@ -120,16 +223,44 @@ class SphinxTestAppWrapperForSkipBuilding(SphinxTestApp):</span>
<span class="w"> </span>    if it has already been built and there are any output files.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gi">+    def build(self, force_all: bool = False, filenames: list[str] | None = None) -&gt; None:</span>
<span class="gi">+        if not os.listdir(self.outdir):</span>
<span class="gi">+            # if listdir is empty, do build.</span>
<span class="gi">+            super().build(force_all, filenames)</span>
<span class="gi">+            # otherwise, we can use built cache</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _clean_up_global_state() -&gt; None:</span>
<span class="gi">+    # clean up Docutils global state</span>
<span class="gi">+    directives._directives.clear()  # type: ignore[attr-defined]</span>
<span class="gi">+    roles._roles.clear()  # type: ignore[attr-defined]</span>
<span class="gi">+    for node in additional_nodes:</span>
<span class="gi">+        delattr(nodes.GenericNodeVisitor, f&#39;visit_{node.__name__}&#39;)</span>
<span class="gi">+        delattr(nodes.GenericNodeVisitor, f&#39;depart_{node.__name__}&#39;)</span>
<span class="gi">+        delattr(nodes.SparseNodeVisitor, f&#39;visit_{node.__name__}&#39;)</span>
<span class="gi">+        delattr(nodes.SparseNodeVisitor, f&#39;depart_{node.__name__}&#39;)</span>
<span class="gi">+    additional_nodes.clear()</span>
<span class="gi">+</span>
<span class="gi">+    # clean up Sphinx global state</span>
<span class="gi">+    sphinx.locale.translators.clear()</span>

<span class="gi">+    # clean up autodoc global state</span>
<span class="gi">+    sphinx.pycode.ModuleAnalyzer.cache.clear()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# deprecated name -&gt; (object to return, canonical path or &#39;&#39;, removal version)</span>
<span class="w"> </span>_DEPRECATED_OBJECTS: dict[str, tuple[Any, str, tuple[int, int]]] = {
<span class="gd">-    &#39;strip_escseq&#39;: (strip_colors, &#39;sphinx.util.console.strip_colors&#39;, (9, 0))}</span>
<span class="gi">+    &#39;strip_escseq&#39;: (strip_colors, &#39;sphinx.util.console.strip_colors&#39;, (9, 0)),</span>
<span class="gi">+}</span>


<span class="gd">-def __getattr__(name: str) -&gt;Any:</span>
<span class="gi">+def __getattr__(name: str) -&gt; Any:</span>
<span class="w"> </span>    if name not in _DEPRECATED_OBJECTS:
<span class="w"> </span>        msg = f&#39;module {__name__!r} has no attribute {name!r}&#39;
<span class="w"> </span>        raise AttributeError(msg)
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.deprecation import _deprecation_warning
<span class="gi">+</span>
<span class="w"> </span>    deprecated_object, canonical_name, remove = _DEPRECATED_OBJECTS[name]
<span class="w"> </span>    _deprecation_warning(__name__, name, canonical_name, remove=remove)
<span class="w"> </span>    return deprecated_object
<span class="gh">diff --git a/sphinx/theming.py b/sphinx/theming.py</span>
<span class="gh">index 43bb6bd9b..6d9986ba3 100644</span>
<span class="gd">--- a/sphinx/theming.py</span>
<span class="gi">+++ b/sphinx/theming.py</span>
<span class="gu">@@ -1,6 +1,9 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Theming support for HTML builders.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gd">-__all__ = &#39;Theme&#39;, &#39;HTMLThemeFactory&#39;</span>
<span class="gi">+</span>
<span class="gi">+__all__ = (&#39;Theme&#39;, &#39;HTMLThemeFactory&#39;)</span>
<span class="gi">+</span>
<span class="w"> </span>import configparser
<span class="w"> </span>import contextlib
<span class="w"> </span>import os
<span class="gu">@@ -11,39 +14,45 @@ from importlib.metadata import entry_points</span>
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="w"> </span>from zipfile import ZipFile
<span class="gi">+</span>
<span class="w"> </span>from sphinx import package_dir
<span class="w"> </span>from sphinx.config import check_confval_types as _config_post_init
<span class="w"> </span>from sphinx.errors import ThemeError
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.osutil import ensuredir
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &gt;= (3, 11):
<span class="w"> </span>    import tomllib
<span class="w"> </span>else:
<span class="w"> </span>    import tomli as tomllib
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Callable
<span class="w"> </span>    from typing import TypedDict
<span class="gi">+</span>
<span class="w"> </span>    from typing_extensions import Required
<span class="gd">-    from sphinx.application import Sphinx</span>

<span class="gi">+    from sphinx.application import Sphinx</span>

<span class="gd">-    class _ThemeToml(TypedDict, total=(False)):</span>
<span class="gi">+    class _ThemeToml(TypedDict, total=False):</span>
<span class="w"> </span>        theme: Required[_ThemeTomlTheme]
<span class="w"> </span>        options: dict[str, str]

<span class="gd">-</span>
<span class="gd">-    class _ThemeTomlTheme(TypedDict, total=(False)):</span>
<span class="gi">+    class _ThemeTomlTheme(TypedDict, total=False):</span>
<span class="w"> </span>        inherit: Required[str]
<span class="w"> </span>        stylesheets: list[str]
<span class="w"> </span>        sidebars: list[str]
<span class="w"> </span>        pygments_style: _ThemeTomlThemePygments

<span class="gd">-</span>
<span class="gd">-    class _ThemeTomlThemePygments(TypedDict, total=(False)):</span>
<span class="gi">+    class _ThemeTomlThemePygments(TypedDict, total=False):</span>
<span class="w"> </span>        default: str
<span class="w"> </span>        dark: str
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gi">+</span>
<span class="w"> </span>_NO_DEFAULT = object()
<span class="w"> </span>_THEME_TOML = &#39;theme.toml&#39;
<span class="w"> </span>_THEME_CONF = &#39;theme.conf&#39;
<span class="gu">@@ -55,11 +64,18 @@ class Theme:</span>
<span class="w"> </span>    This class supports both theme directory and theme archive (zipped theme).
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, name: str, *, configs: dict[str, _ConfigFile], paths:</span>
<span class="gd">-        list[str], tmp_dirs: list[str]) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        *,</span>
<span class="gi">+        configs: dict[str, _ConfigFile],</span>
<span class="gi">+        paths: list[str],</span>
<span class="gi">+        tmp_dirs: list[str],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self._dirs = tuple(paths)
<span class="w"> </span>        self._tmp_dirs = tmp_dirs
<span class="gi">+</span>
<span class="w"> </span>        options: dict[str, Any] = {}
<span class="w"> </span>        self.stylesheets: tuple[str, ...] = ()
<span class="w"> </span>        self.sidebar_templates: tuple[str, ...] = ()
<span class="gu">@@ -75,35 +91,71 @@ class Theme:</span>
<span class="w"> </span>                self.pygments_style_default = config.pygments_style_default
<span class="w"> </span>            if config.pygments_style_dark is not None:
<span class="w"> </span>                self.pygments_style_dark = config.pygments_style_dark
<span class="gi">+</span>
<span class="w"> </span>        self._options = options

<span class="gd">-    def get_theme_dirs(self) -&gt;list[str]:</span>
<span class="gi">+    def get_theme_dirs(self) -&gt; list[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a list of theme directories, beginning with this theme&#39;s,
<span class="w"> </span>        then the base theme&#39;s, then that one&#39;s base theme&#39;s, etc.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return list(self._dirs)</span>

<span class="gd">-    def get_config(self, section: str, name: str, default: Any=_NO_DEFAULT</span>
<span class="gd">-        ) -&gt;Any:</span>
<span class="gi">+    def get_config(self, section: str, name: str, default: Any = _NO_DEFAULT) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the value for a theme configuration setting, searching the
<span class="w"> </span>        base theme chain.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if section == &#39;theme&#39;:</span>
<span class="gi">+            if name == &#39;stylesheet&#39;:</span>
<span class="gi">+                value = &#39;, &#39;.join(self.stylesheets) or default</span>
<span class="gi">+            elif name == &#39;sidebars&#39;:</span>
<span class="gi">+                value = &#39;, &#39;.join(self.sidebar_templates) or default</span>
<span class="gi">+            elif name == &#39;pygments_style&#39;:</span>
<span class="gi">+                value = self.pygments_style_default or default</span>
<span class="gi">+            elif name == &#39;pygments_dark_style&#39;:</span>
<span class="gi">+                value = self.pygments_style_dark or default</span>
<span class="gi">+            else:</span>
<span class="gi">+                value = default</span>
<span class="gi">+        elif section == &#39;options&#39;:</span>
<span class="gi">+            value = self._options.get(name, default)</span>
<span class="gi">+        else:</span>
<span class="gi">+            msg = __(</span>
<span class="gi">+                &#39;Theme configuration sections other than [theme] and [options] &#39;</span>
<span class="gi">+                &#39;are not supported (tried to get a value from %r).&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+            raise ThemeError(msg)</span>
<span class="gi">+        if value is _NO_DEFAULT:</span>
<span class="gi">+            msg = __(&#39;setting %s.%s occurs in none of the searched theme configs&#39;) % (</span>
<span class="gi">+                section,</span>
<span class="gi">+                name,</span>
<span class="gi">+            )</span>
<span class="gi">+            raise ThemeError(msg)</span>
<span class="gi">+        return value</span>

<span class="gd">-    def get_options(self, overrides: (dict[str, Any] | None)=None) -&gt;dict[</span>
<span class="gd">-        str, Any]:</span>
<span class="gi">+    def get_options(self, overrides: dict[str, Any] | None = None) -&gt; dict[str, Any]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a dictionary of theme options and their values.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if overrides is None:</span>
<span class="gi">+            overrides = {}</span>
<span class="gi">+</span>
<span class="gi">+        options = self._options.copy()</span>
<span class="gi">+        for option, value in overrides.items():</span>
<span class="gi">+            if option not in options:</span>
<span class="gi">+                logger.warning(__(&#39;unsupported theme option %r given&#39;), option)</span>
<span class="gi">+            else:</span>
<span class="gi">+                options[option] = value</span>

<span class="gd">-    def _cleanup(self) -&gt;None:</span>
<span class="gi">+        return options</span>
<span class="gi">+</span>
<span class="gi">+    def _cleanup(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Remove temporary directories.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for tmp_dir in self._tmp_dirs:</span>
<span class="gi">+            with contextlib.suppress(Exception):</span>
<span class="gi">+                shutil.rmtree(tmp_dir)</span>


<span class="w"> </span>class HTMLThemeFactory:
<span class="w"> </span>    &quot;&quot;&quot;A factory class for HTML Themes.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, app: Sphinx) -&gt;None:</span>
<span class="gi">+    def __init__(self, app: Sphinx) -&gt; None:</span>
<span class="w"> </span>        self._app = app
<span class="w"> </span>        self._themes = app.registry.html_themes
<span class="w"> </span>        self._entry_point_themes: dict[str, Callable[[], None]] = {}
<span class="gu">@@ -112,73 +164,397 @@ class HTMLThemeFactory:</span>
<span class="w"> </span>            self._load_additional_themes(app.config.html_theme_path)
<span class="w"> </span>        self._load_entry_point_themes()

<span class="gd">-    def _load_builtin_themes(self) -&gt;None:</span>
<span class="gi">+    def _load_builtin_themes(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Load built-in themes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        themes = self._find_themes(path.join(package_dir, &#39;themes&#39;))</span>
<span class="gi">+        for name, theme in themes.items():</span>
<span class="gi">+            self._themes[name] = theme</span>

<span class="gd">-    def _load_additional_themes(self, theme_paths: list[str]) -&gt;None:</span>
<span class="gi">+    def _load_additional_themes(self, theme_paths: list[str]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Load additional themes placed at specified directories.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for theme_path in theme_paths:</span>
<span class="gi">+            abs_theme_path = path.abspath(path.join(self._app.confdir, theme_path))</span>
<span class="gi">+            themes = self._find_themes(abs_theme_path)</span>
<span class="gi">+            for name, theme in themes.items():</span>
<span class="gi">+                self._themes[name] = theme</span>

<span class="gd">-    def _load_entry_point_themes(self) -&gt;None:</span>
<span class="gi">+    def _load_entry_point_themes(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Try to load a theme with the specified name.

<span class="w"> </span>        This uses the ``sphinx.html_themes`` entry point from package metadata.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for entry_point in entry_points(group=&#39;sphinx.html_themes&#39;):</span>
<span class="gi">+            if entry_point.name in self._themes:</span>
<span class="gi">+                continue  # don&#39;t overwrite loaded themes</span>
<span class="gi">+</span>
<span class="gi">+            def _load_theme_closure(</span>
<span class="gi">+                # bind variables in the function definition</span>
<span class="gi">+                app: Sphinx = self._app,</span>
<span class="gi">+                theme_module: str = entry_point.module,</span>
<span class="gi">+            ) -&gt; None:</span>
<span class="gi">+                app.setup_extension(theme_module)</span>
<span class="gi">+                _config_post_init(app, app.config)</span>
<span class="gi">+</span>
<span class="gi">+            self._entry_point_themes[entry_point.name] = _load_theme_closure</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def _find_themes(theme_path: str) -&gt;dict[str, str]:</span>
<span class="gi">+    def _find_themes(theme_path: str) -&gt; dict[str, str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Search themes from specified directory.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def create(self, name: str) -&gt;Theme:</span>
<span class="gi">+        themes: dict[str, str] = {}</span>
<span class="gi">+        if not path.isdir(theme_path):</span>
<span class="gi">+            return themes</span>
<span class="gi">+</span>
<span class="gi">+        for entry in os.listdir(theme_path):</span>
<span class="gi">+            pathname = path.join(theme_path, entry)</span>
<span class="gi">+            if path.isfile(pathname) and entry.lower().endswith(&#39;.zip&#39;):</span>
<span class="gi">+                if _is_archived_theme(pathname):</span>
<span class="gi">+                    name = entry[:-4]</span>
<span class="gi">+                    themes[name] = pathname</span>
<span class="gi">+                else:</span>
<span class="gi">+                    logger.warning(</span>
<span class="gi">+                        __(</span>
<span class="gi">+                            &#39;file %r on theme path is not a valid &#39;</span>
<span class="gi">+                            &#39;zipfile or contains no theme&#39;</span>
<span class="gi">+                        ),</span>
<span class="gi">+                        entry,</span>
<span class="gi">+                    )</span>
<span class="gi">+            else:</span>
<span class="gi">+                toml_path = path.join(pathname, _THEME_TOML)</span>
<span class="gi">+                conf_path = path.join(pathname, _THEME_CONF)</span>
<span class="gi">+                if path.isfile(toml_path) or path.isfile(conf_path):</span>
<span class="gi">+                    themes[entry] = pathname</span>
<span class="gi">+</span>
<span class="gi">+        return themes</span>
<span class="gi">+</span>
<span class="gi">+    def create(self, name: str) -&gt; Theme:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create an instance of theme.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _is_archived_theme(filename: str, /) -&gt;bool:</span>
<span class="gi">+        if name in self._entry_point_themes:</span>
<span class="gi">+            # Load a deferred theme from an entry point</span>
<span class="gi">+            entry_point_loader = self._entry_point_themes[name]</span>
<span class="gi">+            entry_point_loader()</span>
<span class="gi">+        if name not in self._themes:</span>
<span class="gi">+            raise ThemeError(__(&#39;no theme named %r found (missing theme.toml?)&#39;) % name)</span>
<span class="gi">+</span>
<span class="gi">+        themes, theme_dirs, tmp_dirs = _load_theme_with_ancestors(</span>
<span class="gi">+            name,</span>
<span class="gi">+            self._themes,</span>
<span class="gi">+            self._entry_point_themes,</span>
<span class="gi">+        )</span>
<span class="gi">+        return Theme(name, configs=themes, paths=theme_dirs, tmp_dirs=tmp_dirs)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _is_archived_theme(filename: str, /) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check whether the specified file is an archived theme file or not.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _extract_zip(filename: str, target_dir: str, /) -&gt;None:</span>
<span class="gi">+    try:</span>
<span class="gi">+        with ZipFile(filename) as f:</span>
<span class="gi">+            namelist = frozenset(f.namelist())</span>
<span class="gi">+            return _THEME_TOML in namelist or _THEME_CONF in namelist</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _load_theme_with_ancestors(</span>
<span class="gi">+    name: str,</span>
<span class="gi">+    theme_paths: dict[str, str],</span>
<span class="gi">+    entry_point_themes: dict[str, Callable[[], None]],</span>
<span class="gi">+    /,</span>
<span class="gi">+) -&gt; tuple[dict[str, _ConfigFile], list[str], list[str]]:</span>
<span class="gi">+    themes: dict[str, _ConfigFile] = {}</span>
<span class="gi">+    theme_dirs: list[str] = []</span>
<span class="gi">+    tmp_dirs: list[str] = []</span>
<span class="gi">+</span>
<span class="gi">+    # having 10+ theme ancestors is ludicrous</span>
<span class="gi">+    for _ in range(10):</span>
<span class="gi">+        inherit, theme_dir, tmp_dir, config = _load_theme(name, theme_paths[name])</span>
<span class="gi">+        theme_dirs.append(theme_dir)</span>
<span class="gi">+        if tmp_dir is not None:</span>
<span class="gi">+            tmp_dirs.append(tmp_dir)</span>
<span class="gi">+        themes[name] = config</span>
<span class="gi">+        if inherit == &#39;none&#39;:</span>
<span class="gi">+            break</span>
<span class="gi">+        if inherit in themes:</span>
<span class="gi">+            msg = __(&#39;The %r theme has circular inheritance&#39;) % name</span>
<span class="gi">+            raise ThemeError(msg)</span>
<span class="gi">+        if inherit in entry_point_themes and inherit not in theme_paths:</span>
<span class="gi">+            # Load a deferred theme from an entry point</span>
<span class="gi">+            entry_point_loader = entry_point_themes[inherit]</span>
<span class="gi">+            entry_point_loader()</span>
<span class="gi">+        if inherit not in theme_paths:</span>
<span class="gi">+            msg = __(</span>
<span class="gi">+                &#39;The %r theme inherits from %r, which is not a loaded theme. &#39;</span>
<span class="gi">+                &#39;Loaded themes are: %s&#39;</span>
<span class="gi">+            ) % (name, inherit, &#39;, &#39;.join(sorted(theme_paths)))</span>
<span class="gi">+            raise ThemeError(msg)</span>
<span class="gi">+        name = inherit</span>
<span class="gi">+    else:</span>
<span class="gi">+        msg = __(&#39;The %r theme has too many ancestors&#39;) % name</span>
<span class="gi">+        raise ThemeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    return themes, theme_dirs, tmp_dirs</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _load_theme(</span>
<span class="gi">+    name: str, theme_path: str, /</span>
<span class="gi">+) -&gt; tuple[str, str, str | None, _ConfigFile]:</span>
<span class="gi">+    if path.isdir(theme_path):</span>
<span class="gi">+        # already a directory, do nothing</span>
<span class="gi">+        tmp_dir = None</span>
<span class="gi">+        theme_dir = theme_path</span>
<span class="gi">+    else:</span>
<span class="gi">+        # extract the theme to a temp directory</span>
<span class="gi">+        tmp_dir = tempfile.mkdtemp(&#39;sxt&#39;)</span>
<span class="gi">+        theme_dir = path.join(tmp_dir, name)</span>
<span class="gi">+        _extract_zip(theme_path, theme_dir)</span>
<span class="gi">+</span>
<span class="gi">+    if path.isfile(toml_path := path.join(theme_dir, _THEME_TOML)):</span>
<span class="gi">+        _cfg_table = _load_theme_toml(toml_path)</span>
<span class="gi">+        inherit = _validate_theme_toml(_cfg_table, name)</span>
<span class="gi">+        config = _convert_theme_toml(_cfg_table)</span>
<span class="gi">+    elif path.isfile(conf_path := path.join(theme_dir, _THEME_CONF)):</span>
<span class="gi">+        _cfg_parser = _load_theme_conf(conf_path)</span>
<span class="gi">+        inherit = _validate_theme_conf(_cfg_parser, name)</span>
<span class="gi">+        config = _convert_theme_conf(_cfg_parser)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ThemeError(__(&#39;no theme configuration file found in %r&#39;) % theme_dir)</span>
<span class="gi">+</span>
<span class="gi">+    return inherit, theme_dir, tmp_dir, config</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _extract_zip(filename: str, target_dir: str, /) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Extract zip file to target directory.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ensuredir(target_dir)</span>
<span class="gi">+</span>
<span class="gi">+    with ZipFile(filename) as archive:</span>
<span class="gi">+        for name in archive.namelist():</span>
<span class="gi">+            if name.endswith(&#39;/&#39;):</span>
<span class="gi">+                continue</span>
<span class="gi">+            entry = path.join(target_dir, name)</span>
<span class="gi">+            ensuredir(path.dirname(entry))</span>
<span class="gi">+            with open(path.join(entry), &#39;wb&#39;) as fp:</span>
<span class="gi">+                fp.write(archive.read(name))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _load_theme_toml(config_file_path: str, /) -&gt; _ThemeToml:</span>
<span class="gi">+    with open(config_file_path, encoding=&#39;utf-8&#39;) as f:</span>
<span class="gi">+        config_text = f.read()</span>
<span class="gi">+    c = tomllib.loads(config_text)</span>
<span class="gi">+    return {s: c[s] for s in (&#39;theme&#39;, &#39;options&#39;) if s in c}  # type: ignore[return-value]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _validate_theme_toml(cfg: _ThemeToml, name: str) -&gt; str:</span>
<span class="gi">+    if &#39;theme&#39; not in cfg:</span>
<span class="gi">+        msg = __(&#39;theme %r doesn\&#39;t have the &quot;theme&quot; table&#39;) % name</span>
<span class="gi">+        raise ThemeError(msg)</span>
<span class="gi">+    theme = cfg[&#39;theme&#39;]</span>
<span class="gi">+    if not isinstance(theme, dict):</span>
<span class="gi">+        msg = __(&#39;The %r theme &quot;[theme]&quot; table is not a table&#39;) % name</span>
<span class="gi">+        raise ThemeError(msg)</span>
<span class="gi">+    inherit = theme.get(&#39;inherit&#39;, &#39;&#39;)</span>
<span class="gi">+    if not inherit:</span>
<span class="gi">+        msg = __(&#39;The %r theme must define the &quot;theme.inherit&quot; setting&#39;) % name</span>
<span class="gi">+        raise ThemeError(msg)</span>
<span class="gi">+    if &#39;options&#39; in cfg:</span>
<span class="gi">+        if not isinstance(cfg[&#39;options&#39;], dict):</span>
<span class="gi">+            msg = __(&#39;The %r theme &quot;[options]&quot; table is not a table&#39;) % name</span>
<span class="gi">+            raise ThemeError(msg)</span>
<span class="gi">+    return inherit</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _convert_theme_toml(cfg: _ThemeToml, /) -&gt; _ConfigFile:</span>
<span class="gi">+    theme = cfg[&#39;theme&#39;]</span>
<span class="gi">+    if &#39;stylesheets&#39; in theme:</span>
<span class="gi">+        stylesheets: tuple[str, ...] | None = tuple(theme[&#39;stylesheets&#39;])</span>
<span class="gi">+    else:</span>
<span class="gi">+        stylesheets = None</span>
<span class="gi">+    if &#39;sidebars&#39; in theme:</span>
<span class="gi">+        sidebar_templates: tuple[str, ...] | None = tuple(theme[&#39;sidebars&#39;])</span>
<span class="gi">+    else:</span>
<span class="gi">+        sidebar_templates = None</span>
<span class="gi">+    pygments_table = theme.get(&#39;pygments_style&#39;, {})</span>
<span class="gi">+    if isinstance(pygments_table, str):</span>
<span class="gi">+        hint = f&#39;pygments_style = {{ default = &quot;{pygments_table}&quot; }}&#39;</span>
<span class="gi">+        msg = (</span>
<span class="gi">+            __(&#39;The &quot;theme.pygments_style&quot; setting must be a table. Hint: &quot;%s&quot;&#39;) % hint</span>
<span class="gi">+        )</span>
<span class="gi">+        raise ThemeError(msg)</span>
<span class="gi">+    pygments_style_default: str | None = pygments_table.get(&#39;default&#39;)</span>
<span class="gi">+    pygments_style_dark: str | None = pygments_table.get(&#39;dark&#39;)</span>
<span class="gi">+    return _ConfigFile(</span>
<span class="gi">+        stylesheets=stylesheets,</span>
<span class="gi">+        sidebar_templates=sidebar_templates,</span>
<span class="gi">+        pygments_style_default=pygments_style_default,</span>
<span class="gi">+        pygments_style_dark=pygments_style_dark,</span>
<span class="gi">+        options=cfg.get(&#39;options&#39;, {}),</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _load_theme_conf(config_file_path: str, /) -&gt; configparser.RawConfigParser:</span>
<span class="gi">+    c = configparser.RawConfigParser()</span>
<span class="gi">+    c.read(config_file_path, encoding=&#39;utf-8&#39;)</span>
<span class="gi">+    return c</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _validate_theme_conf(cfg: configparser.RawConfigParser, name: str) -&gt; str:</span>
<span class="gi">+    if not cfg.has_section(&#39;theme&#39;):</span>
<span class="gi">+        raise ThemeError(__(&#39;theme %r doesn\&#39;t have the &quot;theme&quot; table&#39;) % name)</span>
<span class="gi">+    if inherit := cfg.get(&#39;theme&#39;, &#39;inherit&#39;, fallback=None):</span>
<span class="gi">+        return inherit</span>
<span class="gi">+    msg = __(&#39;The %r theme must define the &quot;theme.inherit&quot; setting&#39;) % name</span>
<span class="gi">+    raise ThemeError(msg)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _convert_theme_conf(cfg: configparser.RawConfigParser, /) -&gt; _ConfigFile:</span>
<span class="gi">+    if stylesheet := cfg.get(&#39;theme&#39;, &#39;stylesheet&#39;, fallback=&#39;&#39;):</span>
<span class="gi">+        stylesheets: tuple[str, ...] | None = tuple(</span>
<span class="gi">+            map(str.strip, stylesheet.split(&#39;,&#39;))</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        stylesheets = None</span>
<span class="gi">+    if sidebar := cfg.get(&#39;theme&#39;, &#39;sidebars&#39;, fallback=&#39;&#39;):</span>
<span class="gi">+        sidebar_templates: tuple[str, ...] | None = tuple(</span>
<span class="gi">+            map(str.strip, sidebar.split(&#39;,&#39;))</span>
<span class="gi">+        )</span>
<span class="gi">+    else:</span>
<span class="gi">+        sidebar_templates = None</span>
<span class="gi">+    pygments_style_default: str | None = cfg.get(</span>
<span class="gi">+        &#39;theme&#39;, &#39;pygments_style&#39;, fallback=None</span>
<span class="gi">+    )</span>
<span class="gi">+    pygments_style_dark: str | None = cfg.get(</span>
<span class="gi">+        &#39;theme&#39;, &#39;pygments_dark_style&#39;, fallback=None</span>
<span class="gi">+    )</span>
<span class="gi">+    options = dict(cfg.items(&#39;options&#39;)) if cfg.has_section(&#39;options&#39;) else {}</span>
<span class="gi">+    return _ConfigFile(</span>
<span class="gi">+        stylesheets=stylesheets,</span>
<span class="gi">+        sidebar_templates=sidebar_templates,</span>
<span class="gi">+        pygments_style_default=pygments_style_default,</span>
<span class="gi">+        pygments_style_dark=pygments_style_dark,</span>
<span class="gi">+        options=options,</span>
<span class="gi">+    )</span>


<span class="w"> </span>class _ConfigFile:
<span class="gd">-    __slots__ = (&#39;stylesheets&#39;, &#39;sidebar_templates&#39;,</span>
<span class="gd">-        &#39;pygments_style_default&#39;, &#39;pygments_style_dark&#39;, &#39;options&#39;)</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, stylesheets: (tuple[str, ...] | None),</span>
<span class="gd">-        sidebar_templates: (tuple[str, ...] | None), pygments_style_default:</span>
<span class="gd">-        (str | None), pygments_style_dark: (str | None), options: dict[str,</span>
<span class="gd">-        str]) -&gt;None:</span>
<span class="gi">+    __slots__ = (</span>
<span class="gi">+        &#39;stylesheets&#39;,</span>
<span class="gi">+        &#39;sidebar_templates&#39;,</span>
<span class="gi">+        &#39;pygments_style_default&#39;,</span>
<span class="gi">+        &#39;pygments_style_dark&#39;,</span>
<span class="gi">+        &#39;options&#39;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        stylesheets: tuple[str, ...] | None,</span>
<span class="gi">+        sidebar_templates: tuple[str, ...] | None,</span>
<span class="gi">+        pygments_style_default: str | None,</span>
<span class="gi">+        pygments_style_dark: str | None,</span>
<span class="gi">+        options: dict[str, str],</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.stylesheets: tuple[str, ...] | None = stylesheets
<span class="w"> </span>        self.sidebar_templates: tuple[str, ...] | None = sidebar_templates
<span class="w"> </span>        self.pygments_style_default: str | None = pygments_style_default
<span class="w"> </span>        self.pygments_style_dark: str | None = pygments_style_dark
<span class="w"> </span>        self.options: dict[str, str] = options.copy()

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return (
<span class="gd">-            f&#39;{self.__class__.__qualname__}(stylesheets={self.stylesheets!r}, sidebar_templates={self.sidebar_templates!r}, pygments_style_default={self.pygments_style_default!r}, pygments_style_dark={self.pygments_style_dark!r}, options={self.options!r})&#39;</span>
<span class="gd">-            )</span>
<span class="gd">-</span>
<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+            f&#39;{self.__class__.__qualname__}(&#39;</span>
<span class="gi">+            f&#39;stylesheets={self.stylesheets!r}, &#39;</span>
<span class="gi">+            f&#39;sidebar_templates={self.sidebar_templates!r}, &#39;</span>
<span class="gi">+            f&#39;pygments_style_default={self.pygments_style_default!r}, &#39;</span>
<span class="gi">+            f&#39;pygments_style_dark={self.pygments_style_dark!r}, &#39;</span>
<span class="gi">+            f&#39;options={self.options!r})&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if isinstance(other, _ConfigFile):
<span class="gd">-            return (self.stylesheets == other.stylesheets and self.</span>
<span class="gd">-                sidebar_templates == other.sidebar_templates and self.</span>
<span class="gd">-                pygments_style_default == other.pygments_style_default and </span>
<span class="gd">-                self.pygments_style_dark == other.pygments_style_dark and </span>
<span class="gd">-                self.options == other.options)</span>
<span class="gi">+            return (</span>
<span class="gi">+                self.stylesheets == other.stylesheets</span>
<span class="gi">+                and self.sidebar_templates == other.sidebar_templates</span>
<span class="gi">+                and self.pygments_style_default == other.pygments_style_default</span>
<span class="gi">+                and self.pygments_style_dark == other.pygments_style_dark</span>
<span class="gi">+                and self.options == other.options</span>
<span class="gi">+            )</span>
<span class="w"> </span>        return NotImplemented

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gd">-        return hash((self.__class__.__qualname__, self.stylesheets, self.</span>
<span class="gd">-            sidebar_templates, self.pygments_style_default, self.</span>
<span class="gd">-            pygments_style_dark, self.options))</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="gi">+        return hash((</span>
<span class="gi">+            self.__class__.__qualname__,</span>
<span class="gi">+            self.stylesheets,</span>
<span class="gi">+            self.sidebar_templates,</span>
<span class="gi">+            self.pygments_style_default,</span>
<span class="gi">+            self.pygments_style_dark,</span>
<span class="gi">+            self.options,</span>
<span class="gi">+        ))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _migrate_conf_to_toml(argv: list[str]) -&gt; int:</span>
<span class="gi">+    if argv[:1] != [&#39;conf_to_toml&#39;]:</span>
<span class="gi">+        raise SystemExit(0)</span>
<span class="gi">+    argv = argv[1:]</span>
<span class="gi">+    if len(argv) != 1:</span>
<span class="gi">+        print(&#39;Usage: python -m sphinx.theming conf_to_toml &lt;theme path&gt;&#39;)  # NoQA: T201</span>
<span class="gi">+        raise SystemExit(1)</span>
<span class="gi">+    theme_dir = path.realpath(argv[0])</span>
<span class="gi">+    conf_path = path.join(theme_dir, _THEME_CONF)</span>
<span class="gi">+    if not path.isdir(theme_dir) or not path.isfile(conf_path):</span>
<span class="gi">+        print(  # NoQA: T201</span>
<span class="gi">+            f&#39;{theme_dir!r} must be a path to a theme directory containing a &quot;theme.conf&quot; file&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+        return 1</span>
<span class="gi">+    _cfg_parser = _load_theme_conf(conf_path)</span>
<span class="gi">+    if not _cfg_parser.has_section(&#39;theme&#39;):</span>
<span class="gi">+        print(&#39;The &quot;theme&quot; table is missing.&#39;)  # NoQA: T201</span>
<span class="gi">+        return 1</span>
<span class="gi">+    inherit = _cfg_parser.get(&#39;theme&#39;, &#39;inherit&#39;, fallback=None)</span>
<span class="gi">+    if not inherit:</span>
<span class="gi">+        print(&#39;The &quot;theme.inherit&quot; setting is missing.&#39;)  # NoQA: T201</span>
<span class="gi">+        return 1</span>
<span class="gi">+</span>
<span class="gi">+    toml_lines = [</span>
<span class="gi">+        &#39;[theme]&#39;,</span>
<span class="gi">+        f&#39;inherit = &quot;{inherit}&quot;&#39;,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    stylesheet = _cfg_parser.get(&#39;theme&#39;, &#39;stylesheet&#39;, fallback=...)</span>
<span class="gi">+    if stylesheet == &#39;&#39;:</span>
<span class="gi">+        toml_lines.append(&#39;stylesheets = []&#39;)</span>
<span class="gi">+    elif stylesheet is not ...:</span>
<span class="gi">+        toml_lines.append(&#39;stylesheets = [&#39;)</span>
<span class="gi">+        toml_lines.extend(f&#39;    &quot;{s}&quot;,&#39; for s in map(str.strip, stylesheet.split(&#39;,&#39;)))</span>
<span class="gi">+        toml_lines.append(&#39;]&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    sidebar = _cfg_parser.get(&#39;theme&#39;, &#39;sidebars&#39;, fallback=...)</span>
<span class="gi">+    if sidebar == &#39;&#39;:</span>
<span class="gi">+        toml_lines.append(&#39;sidebars = []&#39;)</span>
<span class="gi">+    elif sidebar is not ...:</span>
<span class="gi">+        toml_lines.append(&#39;sidebars = [&#39;)</span>
<span class="gi">+        toml_lines += [f&#39;    &quot;{s}&quot;,&#39; for s in map(str.strip, sidebar.split(&#39;,&#39;))]</span>
<span class="gi">+        toml_lines.append(&#39;]&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    styles = []</span>
<span class="gi">+    default = _cfg_parser.get(&#39;theme&#39;, &#39;pygments_style&#39;, fallback=...)</span>
<span class="gi">+    if default is not ...:</span>
<span class="gi">+        styles.append(f&#39;default = &quot;{default}&quot;&#39;)</span>
<span class="gi">+    dark = _cfg_parser.get(&#39;theme&#39;, &#39;pygments_dark_style&#39;, fallback=...)</span>
<span class="gi">+    if dark is not ...:</span>
<span class="gi">+        styles.append(f&#39;dark = &quot;{dark}&quot;&#39;)</span>
<span class="gi">+    if styles:</span>
<span class="gi">+        toml_lines.append(&#39;pygments_style = { &#39; + &#39;, &#39;.join(styles) + &#39; }&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if _cfg_parser.has_section(&#39;options&#39;):</span>
<span class="gi">+        toml_lines.append(&#39;&#39;)</span>
<span class="gi">+        toml_lines.append(&#39;[options]&#39;)</span>
<span class="gi">+        toml_lines += [</span>
<span class="gi">+            f&#39;{key} = &quot;{d}&quot;&#39;</span>
<span class="gi">+            for key, default in _cfg_parser.items(&#39;options&#39;)</span>
<span class="gi">+            if (d := default.replace(&#39;&quot;&#39;, r&#39;\&quot;&#39;)) or True</span>
<span class="gi">+        ]</span>
<span class="gi">+</span>
<span class="gi">+    toml_path = path.join(theme_dir, _THEME_TOML)</span>
<span class="gi">+    with open(toml_path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:</span>
<span class="gi">+        f.write(&#39;\n&#39;.join(toml_lines) + &#39;\n&#39;)</span>
<span class="gi">+    print(f&#39;Written converted settings to {toml_path!r}&#39;)  # NoQA: T201</span>
<span class="gi">+    return 0</span>


<span class="w"> </span>if __name__ == &#39;__main__&#39;:
<span class="gh">diff --git a/sphinx/transforms/compact_bullet_list.py b/sphinx/transforms/compact_bullet_list.py</span>
<span class="gh">index 54ebc5311..acd863478 100644</span>
<span class="gd">--- a/sphinx/transforms/compact_bullet_list.py</span>
<span class="gi">+++ b/sphinx/transforms/compact_bullet_list.py</span>
<span class="gu">@@ -1,11 +1,17 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Docutils transforms used by Sphinx when reading documents.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.transforms import SphinxTransform
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.nodes import Node
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata

<span class="gu">@@ -17,7 +23,27 @@ class RefOnlyListChecker(nodes.GenericNodeVisitor):</span>
<span class="w"> </span>    single reference in it.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def invisible_visit(self, node: Node) -&gt;None:</span>
<span class="gi">+    def default_visit(self, node: Node) -&gt; None:</span>
<span class="gi">+        raise nodes.NodeFound</span>
<span class="gi">+</span>
<span class="gi">+    def visit_bullet_list(self, node: nodes.bullet_list) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_list_item(self, node: nodes.list_item) -&gt; None:</span>
<span class="gi">+        children: list[Node] = [child for child in node.children</span>
<span class="gi">+                                if not isinstance(child, nodes.Invisible)]</span>
<span class="gi">+        if len(children) != 1:</span>
<span class="gi">+            raise nodes.NodeFound</span>
<span class="gi">+        if not isinstance(children[0], nodes.paragraph):</span>
<span class="gi">+            raise nodes.NodeFound</span>
<span class="gi">+        para = children[0]</span>
<span class="gi">+        if len(para) != 1:</span>
<span class="gi">+            raise nodes.NodeFound</span>
<span class="gi">+        if not isinstance(para[0], addnodes.pending_xref):</span>
<span class="gi">+            raise nodes.NodeFound</span>
<span class="gi">+        raise nodes.SkipChildren</span>
<span class="gi">+</span>
<span class="gi">+    def invisible_visit(self, node: Node) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Invisible nodes should be ignored.&quot;&quot;&quot;
<span class="w"> </span>        pass

<span class="gu">@@ -28,4 +54,38 @@ class RefOnlyBulletListTransform(SphinxTransform):</span>
<span class="w"> </span>    Specifically implemented for &#39;Indices and Tables&#39; section, which looks
<span class="w"> </span>    odd when html_compact_lists is false.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    default_priority = 100
<span class="gi">+</span>
<span class="gi">+    def apply(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        if self.config.html_compact_lists:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        def check_refonly_list(node: Node) -&gt; bool:</span>
<span class="gi">+            &quot;&quot;&quot;Check for list with only references in it.&quot;&quot;&quot;</span>
<span class="gi">+            visitor = RefOnlyListChecker(self.document)</span>
<span class="gi">+            try:</span>
<span class="gi">+                node.walk(visitor)</span>
<span class="gi">+            except nodes.NodeFound:</span>
<span class="gi">+                return False</span>
<span class="gi">+            else:</span>
<span class="gi">+                return True</span>
<span class="gi">+</span>
<span class="gi">+        for node in self.document.findall(nodes.bullet_list):</span>
<span class="gi">+            if check_refonly_list(node):</span>
<span class="gi">+                for item in node.findall(nodes.list_item):</span>
<span class="gi">+                    para = cast(nodes.paragraph, item[0])</span>
<span class="gi">+                    ref = cast(nodes.reference, para[0])</span>
<span class="gi">+                    compact_para = addnodes.compact_paragraph()</span>
<span class="gi">+                    compact_para += ref</span>
<span class="gi">+                    item.replace(para, compact_para)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_transform(RefOnlyBulletListTransform)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/transforms/i18n.py b/sphinx/transforms/i18n.py</span>
<span class="gh">index 7d4cc25e7..8b6783676 100644</span>
<span class="gd">--- a/sphinx/transforms/i18n.py</span>
<span class="gi">+++ b/sphinx/transforms/i18n.py</span>
<span class="gu">@@ -1,12 +1,16 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Docutils transforms used by Sphinx when reading documents.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import contextlib
<span class="w"> </span>from os import path
<span class="w"> </span>from re import DOTALL, match
<span class="w"> </span>from textwrap import indent
<span class="w"> </span>from typing import TYPE_CHECKING, Any, TypeVar
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.io import StringInput
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.domains.std import make_glossary_term, split_term_classifiers
<span class="w"> </span>from sphinx.errors import ConfigError
<span class="gu">@@ -16,19 +20,36 @@ from sphinx.transforms import SphinxTransform</span>
<span class="w"> </span>from sphinx.util import get_filetype, logging
<span class="w"> </span>from sphinx.util.i18n import docname_to_domain
<span class="w"> </span>from sphinx.util.index_entries import split_index_msg
<span class="gd">-from sphinx.util.nodes import IMAGE_TYPE_NODES, LITERAL_TYPE_NODES, NodeMatcher, extract_messages, traverse_translatable_index</span>
<span class="gi">+from sphinx.util.nodes import (</span>
<span class="gi">+    IMAGE_TYPE_NODES,</span>
<span class="gi">+    LITERAL_TYPE_NODES,</span>
<span class="gi">+    NodeMatcher,</span>
<span class="gi">+    extract_messages,</span>
<span class="gi">+    traverse_translatable_index,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Sequence
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.config import Config
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gd">-EXCLUDED_PENDING_XREF_ATTRIBUTES = &#39;refexplicit&#39;,</span>
<span class="gi">+</span>
<span class="gi">+# The attributes not copied to the translated node</span>
<span class="gi">+#</span>
<span class="gi">+# * refexplict: For allow to give (or not to give) an explicit title</span>
<span class="gi">+#               to the pending_xref on translation</span>
<span class="gi">+EXCLUDED_PENDING_XREF_ATTRIBUTES = (&#39;refexplicit&#39;,)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>N = TypeVar(&#39;N&#39;, bound=nodes.Node)


<span class="gd">-def publish_msgstr(app: Sphinx, source: str, source_path: str, source_line:</span>
<span class="gd">-    int, config: Config, settings: Any) -&gt;nodes.Element:</span>
<span class="gi">+def publish_msgstr(app: Sphinx, source: str, source_path: str, source_line: int,</span>
<span class="gi">+                   config: Config, settings: Any) -&gt; nodes.Element:</span>
<span class="w"> </span>    &quot;&quot;&quot;Publish msgstr (single line) into docutils document

<span class="w"> </span>    :param sphinx.application.Sphinx app: sphinx application
<span class="gu">@@ -40,55 +61,567 @@ def publish_msgstr(app: Sphinx, source: str, source_path: str, source_line:</span>
<span class="w"> </span>    :return: document
<span class="w"> </span>    :rtype: docutils.nodes.document
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        # clear rst_prolog temporarily</span>
<span class="gi">+        rst_prolog = config.rst_prolog</span>
<span class="gi">+        config.rst_prolog = None</span>
<span class="gi">+</span>
<span class="gi">+        from sphinx.io import SphinxI18nReader</span>
<span class="gi">+        reader = SphinxI18nReader()</span>
<span class="gi">+        reader.setup(app)</span>
<span class="gi">+        filetype = get_filetype(config.source_suffix, source_path)</span>
<span class="gi">+        parser = app.registry.create_source_parser(app, filetype)</span>
<span class="gi">+        doc = reader.read(</span>
<span class="gi">+            source=StringInput(source=source,</span>
<span class="gi">+                               source_path=f&quot;{source_path}:{source_line}:&lt;translated&gt;&quot;),</span>
<span class="gi">+            parser=parser,</span>
<span class="gi">+            settings=settings,</span>
<span class="gi">+        )</span>
<span class="gi">+        with contextlib.suppress(IndexError):  # empty node</span>
<span class="gi">+            return doc[0]</span>
<span class="gi">+        return doc</span>
<span class="gi">+    finally:</span>
<span class="gi">+        config.rst_prolog = rst_prolog</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_noqa(source: str) -&gt; tuple[str, bool]:</span>
<span class="gi">+    m = match(r&quot;(.*)(?&lt;!\\)#\s*noqa\s*$&quot;, source, DOTALL)</span>
<span class="gi">+    if m:</span>
<span class="gi">+        return m.group(1), True</span>
<span class="gi">+    else:</span>
<span class="gi">+        return source, False</span>


<span class="w"> </span>class PreserveTranslatableMessages(SphinxTransform):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Preserve original translatable messages before translation
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_priority = 10</span>
<span class="gi">+</span>
<span class="gi">+    default_priority = 10  # this MUST be invoked before Locale transform</span>
<span class="gi">+</span>
<span class="gi">+    def apply(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        for node in self.document.findall(addnodes.translatable):</span>
<span class="gi">+            node.preserve_original_messages()</span>


<span class="w"> </span>class _NodeUpdater:
<span class="w"> </span>    &quot;&quot;&quot;Contains logic for updating one node with the translated content.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, node: nodes.Element, patch: nodes.Element, document:</span>
<span class="gd">-        nodes.document, noqa: bool) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self, node: nodes.Element, patch: nodes.Element, document: nodes.document, noqa: bool,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.node: nodes.Element = node
<span class="w"> </span>        self.patch: nodes.Element = patch
<span class="w"> </span>        self.document: nodes.document = document
<span class="w"> </span>        self.noqa: bool = noqa

<span class="w"> </span>    def compare_references(self, old_refs: Sequence[nodes.Element],
<span class="gd">-        new_refs: Sequence[nodes.Element], warning_msg: str) -&gt;None:</span>
<span class="gi">+                           new_refs: Sequence[nodes.Element],</span>
<span class="gi">+                           warning_msg: str) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Warn about mismatches between references in original and translated content.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # FIXME: could use a smarter strategy than len(old_refs) == len(new_refs)</span>
<span class="gi">+        if not self.noqa and len(old_refs) != len(new_refs):</span>
<span class="gi">+            old_ref_rawsources = [ref.rawsource for ref in old_refs]</span>
<span class="gi">+            new_ref_rawsources = [ref.rawsource for ref in new_refs]</span>
<span class="gi">+            logger.warning(warning_msg.format(old_ref_rawsources, new_ref_rawsources),</span>
<span class="gi">+                           location=self.node, type=&#39;i18n&#39;, subtype=&#39;inconsistent_references&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def update_title_mapping(self) -&gt; bool:</span>
<span class="gi">+        processed = False  # skip flag</span>
<span class="gi">+</span>
<span class="gi">+        # update title(section) target name-id mapping</span>
<span class="gi">+        if isinstance(self.node, nodes.title) and isinstance(self.node.parent, nodes.section):</span>
<span class="gi">+            section_node = self.node.parent</span>
<span class="gi">+            new_name = nodes.fully_normalize_name(self.patch.astext())</span>
<span class="gi">+            old_name = nodes.fully_normalize_name(self.node.astext())</span>
<span class="gi">+</span>
<span class="gi">+            if old_name != new_name:</span>
<span class="gi">+                # if name would be changed, replace node names and</span>
<span class="gi">+                # document nameids mapping with new name.</span>
<span class="gi">+                names: list[str] = section_node.setdefault(&#39;names&#39;, [])</span>
<span class="gi">+                names.append(new_name)</span>
<span class="gi">+                # Original section name (reference target name) should be kept to refer</span>
<span class="gi">+                # from other nodes which is still not translated or uses explicit target</span>
<span class="gi">+                # name like &quot;`text to display &lt;explicit target name_&gt;`_&quot;..</span>
<span class="gi">+                # So, `old_name` is still exist in `names`.</span>
<span class="gi">+</span>
<span class="gi">+                _id = self.document.nameids.get(old_name, None)</span>
<span class="gi">+                explicit = self.document.nametypes.get(old_name, None)</span>
<span class="gi">+</span>
<span class="gi">+                # * if explicit: _id is label. title node need another id.</span>
<span class="gi">+                # * if not explicit:</span>
<span class="gi">+                #</span>
<span class="gi">+                #   * if _id is None:</span>
<span class="gi">+                #</span>
<span class="gi">+                #     _id is None means:</span>
<span class="gi">+                #</span>
<span class="gi">+                #     1. _id was not provided yet.</span>
<span class="gi">+                #</span>
<span class="gi">+                #     2. _id was duplicated.</span>
<span class="gi">+                #</span>
<span class="gi">+                #        old_name entry still exists in nameids and</span>
<span class="gi">+                #        nametypes for another duplicated entry.</span>
<span class="gi">+                #</span>
<span class="gi">+                #   * if _id is provided: below process</span>
<span class="gi">+                if _id:</span>
<span class="gi">+                    if not explicit:</span>
<span class="gi">+                        # _id was not duplicated.</span>
<span class="gi">+                        # remove old_name entry from document ids database</span>
<span class="gi">+                        # to reuse original _id.</span>
<span class="gi">+                        self.document.nameids.pop(old_name, None)</span>
<span class="gi">+                        self.document.nametypes.pop(old_name, None)</span>
<span class="gi">+                        self.document.ids.pop(_id, None)</span>
<span class="gi">+</span>
<span class="gi">+                    # re-entry with new named section node.</span>
<span class="gi">+                    #</span>
<span class="gi">+                    # Note: msgnode that is a second parameter of the</span>
<span class="gi">+                    # `note_implicit_target` is not necessary here because</span>
<span class="gi">+                    # section_node has been noted previously on rst parsing by</span>
<span class="gi">+                    # `docutils.parsers.rst.states.RSTState.new_subsection()`</span>
<span class="gi">+                    # and already has `system_message` if needed.</span>
<span class="gi">+                    self.document.note_implicit_target(section_node)</span>
<span class="gi">+</span>
<span class="gi">+                # replace target&#39;s refname to new target name</span>
<span class="gi">+                matcher = NodeMatcher(nodes.target, refname=old_name)</span>
<span class="gi">+                for old_target in matcher.findall(self.document):</span>
<span class="gi">+                    old_target[&#39;refname&#39;] = new_name</span>
<span class="gi">+</span>
<span class="gi">+                processed = True</span>
<span class="gi">+</span>
<span class="gi">+        return processed</span>
<span class="gi">+</span>
<span class="gi">+    def update_autofootnote_references(self) -&gt; None:</span>
<span class="gi">+        # auto-numbered foot note reference should use original &#39;ids&#39;.</span>
<span class="gi">+        def list_replace_or_append(lst: list[N], old: N, new: N) -&gt; None:</span>
<span class="gi">+            if old in lst:</span>
<span class="gi">+                lst[lst.index(old)] = new</span>
<span class="gi">+            else:</span>
<span class="gi">+                lst.append(new)</span>
<span class="gi">+</span>
<span class="gi">+        is_autofootnote_ref = NodeMatcher(nodes.footnote_reference, auto=Any)</span>
<span class="gi">+        old_foot_refs = list(is_autofootnote_ref.findall(self.node))</span>
<span class="gi">+        new_foot_refs = list(is_autofootnote_ref.findall(self.patch))</span>
<span class="gi">+        self.compare_references(old_foot_refs, new_foot_refs,</span>
<span class="gi">+                                __(&#39;inconsistent footnote references in translated message.&#39;</span>
<span class="gi">+                                   &#39; original: {0}, translated: {1}&#39;))</span>
<span class="gi">+        old_foot_namerefs: dict[str, list[nodes.footnote_reference]] = {}</span>
<span class="gi">+        for r in old_foot_refs:</span>
<span class="gi">+            old_foot_namerefs.setdefault(r.get(&#39;refname&#39;), []).append(r)</span>
<span class="gi">+        for newf in new_foot_refs:</span>
<span class="gi">+            refname = newf.get(&#39;refname&#39;)</span>
<span class="gi">+            refs = old_foot_namerefs.get(refname, [])</span>
<span class="gi">+            if not refs:</span>
<span class="gi">+                newf.parent.remove(newf)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            oldf = refs.pop(0)</span>
<span class="gi">+            newf[&#39;ids&#39;] = oldf[&#39;ids&#39;]</span>
<span class="gi">+            for id in newf[&#39;ids&#39;]:</span>
<span class="gi">+                self.document.ids[id] = newf</span>
<span class="gi">+</span>
<span class="gi">+            if newf[&#39;auto&#39;] == 1:</span>
<span class="gi">+                # autofootnote_refs</span>
<span class="gi">+                list_replace_or_append(self.document.autofootnote_refs, oldf, newf)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # symbol_footnote_refs</span>
<span class="gi">+                list_replace_or_append(self.document.symbol_footnote_refs, oldf, newf)</span>
<span class="gi">+</span>
<span class="gi">+            if refname:</span>
<span class="gi">+                footnote_refs = self.document.footnote_refs.setdefault(refname, [])</span>
<span class="gi">+                list_replace_or_append(footnote_refs, oldf, newf)</span>
<span class="gi">+</span>
<span class="gi">+                refnames = self.document.refnames.setdefault(refname, [])</span>
<span class="gi">+                list_replace_or_append(refnames, oldf, newf)</span>
<span class="gi">+</span>
<span class="gi">+    def update_refnamed_references(self) -&gt; None:</span>
<span class="gi">+        # reference should use new (translated) &#39;refname&#39;.</span>
<span class="gi">+        # * reference target &quot;.. _Python: ...&quot; is not translatable.</span>
<span class="gi">+        # * use translated refname for section refname.</span>
<span class="gi">+        # * inline reference &quot;`Python &lt;...&gt;`_&quot; has no &#39;refname&#39;.</span>
<span class="gi">+        is_refnamed_ref = NodeMatcher(nodes.reference, refname=Any)</span>
<span class="gi">+        old_refs = list(is_refnamed_ref.findall(self.node))</span>
<span class="gi">+        new_refs = list(is_refnamed_ref.findall(self.patch))</span>
<span class="gi">+        self.compare_references(old_refs, new_refs,</span>
<span class="gi">+                                __(&#39;inconsistent references in translated message.&#39;</span>
<span class="gi">+                                   &#39; original: {0}, translated: {1}&#39;))</span>
<span class="gi">+        old_ref_names = [r[&#39;refname&#39;] for r in old_refs]</span>
<span class="gi">+        new_ref_names = [r[&#39;refname&#39;] for r in new_refs]</span>
<span class="gi">+        orphans = [*({*old_ref_names} - {*new_ref_names})]</span>
<span class="gi">+        for newr in new_refs:</span>
<span class="gi">+            if not self.document.has_name(newr[&#39;refname&#39;]):</span>
<span class="gi">+                # Maybe refname is translated but target is not translated.</span>
<span class="gi">+                # Note: multiple translated refnames break link ordering.</span>
<span class="gi">+                if orphans:</span>
<span class="gi">+                    newr[&#39;refname&#39;] = orphans.pop(0)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # orphan refnames is already empty!</span>
<span class="gi">+                    # reference number is same in new_refs and old_refs.</span>
<span class="gi">+                    pass</span>
<span class="gi">+</span>
<span class="gi">+            self.document.note_refname(newr)</span>
<span class="gi">+</span>
<span class="gi">+    def update_refnamed_footnote_references(self) -&gt; None:</span>
<span class="gi">+        # refnamed footnote should use original &#39;ids&#39;.</span>
<span class="gi">+        is_refnamed_footnote_ref = NodeMatcher(nodes.footnote_reference, refname=Any)</span>
<span class="gi">+        old_foot_refs = list(is_refnamed_footnote_ref.findall(self.node))</span>
<span class="gi">+        new_foot_refs = list(is_refnamed_footnote_ref.findall(self.patch))</span>
<span class="gi">+        refname_ids_map: dict[str, list[str]] = {}</span>
<span class="gi">+        self.compare_references(old_foot_refs, new_foot_refs,</span>
<span class="gi">+                                __(&#39;inconsistent footnote references in translated message.&#39;</span>
<span class="gi">+                                   &#39; original: {0}, translated: {1}&#39;))</span>
<span class="gi">+        for oldf in old_foot_refs:</span>
<span class="gi">+            refname_ids_map.setdefault(oldf[&quot;refname&quot;], []).append(oldf[&quot;ids&quot;])</span>
<span class="gi">+        for newf in new_foot_refs:</span>
<span class="gi">+            refname = newf[&quot;refname&quot;]</span>
<span class="gi">+            if refname_ids_map.get(refname):</span>
<span class="gi">+                newf[&quot;ids&quot;] = refname_ids_map[refname].pop(0)</span>
<span class="gi">+</span>
<span class="gi">+    def update_citation_references(self) -&gt; None:</span>
<span class="gi">+        # citation should use original &#39;ids&#39;.</span>
<span class="gi">+        is_citation_ref = NodeMatcher(nodes.citation_reference, refname=Any)</span>
<span class="gi">+        old_cite_refs = list(is_citation_ref.findall(self.node))</span>
<span class="gi">+        new_cite_refs = list(is_citation_ref.findall(self.patch))</span>
<span class="gi">+        self.compare_references(old_cite_refs, new_cite_refs,</span>
<span class="gi">+                                __(&#39;inconsistent citation references in translated message.&#39;</span>
<span class="gi">+                                   &#39; original: {0}, translated: {1}&#39;))</span>
<span class="gi">+        refname_ids_map: dict[str, list[str]] = {}</span>
<span class="gi">+        for oldc in old_cite_refs:</span>
<span class="gi">+            refname_ids_map.setdefault(oldc[&quot;refname&quot;], []).append(oldc[&quot;ids&quot;])</span>
<span class="gi">+        for newc in new_cite_refs:</span>
<span class="gi">+            refname = newc[&quot;refname&quot;]</span>
<span class="gi">+            if refname_ids_map.get(refname):</span>
<span class="gi">+                newc[&quot;ids&quot;] = refname_ids_map[refname].pop()</span>
<span class="gi">+</span>
<span class="gi">+    def update_pending_xrefs(self) -&gt; None:</span>
<span class="gi">+        # Original pending_xref[&#39;reftarget&#39;] contain not-translated</span>
<span class="gi">+        # target name, new pending_xref must use original one.</span>
<span class="gi">+        # This code restricts to change ref-targets in the translation.</span>
<span class="gi">+        old_xrefs = [*self.node.findall(addnodes.pending_xref)]</span>
<span class="gi">+        new_xrefs = [*self.patch.findall(addnodes.pending_xref)]</span>
<span class="gi">+        self.compare_references(old_xrefs, new_xrefs,</span>
<span class="gi">+                                __(&#39;inconsistent term references in translated message.&#39;</span>
<span class="gi">+                                   &#39; original: {0}, translated: {1}&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        xref_reftarget_map: dict[tuple[str, str, str] | None, dict[str, Any]] = {}</span>
<span class="gi">+</span>
<span class="gi">+        def get_ref_key(node: addnodes.pending_xref) -&gt; tuple[str, str, str] | None:</span>
<span class="gi">+            case = node[&quot;refdomain&quot;], node[&quot;reftype&quot;]</span>
<span class="gi">+            if case == (&#39;std&#39;, &#39;term&#39;):</span>
<span class="gi">+                return None</span>
<span class="gi">+            else:</span>
<span class="gi">+                return (</span>
<span class="gi">+                    node[&quot;refdomain&quot;],</span>
<span class="gi">+                    node[&quot;reftype&quot;],</span>
<span class="gi">+                    node[&#39;reftarget&#39;],</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        for old in old_xrefs:</span>
<span class="gi">+            key = get_ref_key(old)</span>
<span class="gi">+            if key:</span>
<span class="gi">+                xref_reftarget_map[key] = old.attributes</span>
<span class="gi">+        for new in new_xrefs:</span>
<span class="gi">+            key = get_ref_key(new)</span>
<span class="gi">+            # Copy attributes to keep original node behavior. Especially</span>
<span class="gi">+            # copying &#39;reftarget&#39;, &#39;py:module&#39;, &#39;py:class&#39; are needed.</span>
<span class="gi">+            for k, v in xref_reftarget_map.get(key, {}).items():</span>
<span class="gi">+                if k not in EXCLUDED_PENDING_XREF_ATTRIBUTES:</span>
<span class="gi">+                    new[k] = v</span>
<span class="gi">+</span>
<span class="gi">+    def update_leaves(self) -&gt; None:</span>
<span class="gi">+        for child in self.patch.children:</span>
<span class="gi">+            child.parent = self.node</span>
<span class="gi">+        self.node.children = self.patch.children</span>


<span class="w"> </span>class Locale(SphinxTransform):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Replace translatable nodes with their translated doctree.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    default_priority = 20

<span class="gi">+    def apply(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        settings, source = self.document.settings, self.document[&#39;source&#39;]</span>
<span class="gi">+        msgstr = &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        textdomain = docname_to_domain(self.env.docname, self.config.gettext_compact)</span>
<span class="gi">+</span>
<span class="gi">+        # fetch translations</span>
<span class="gi">+        dirs = [path.join(self.env.srcdir, directory)</span>
<span class="gi">+                for directory in self.config.locale_dirs]</span>
<span class="gi">+        catalog, has_catalog = init_locale(dirs, self.config.language, textdomain)</span>
<span class="gi">+        if not has_catalog:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        catalogues = [getattr(catalog, &#39;_catalog&#39;, None)]</span>
<span class="gi">+        while (catalog := catalog._fallback) is not None:  # type: ignore[attr-defined]</span>
<span class="gi">+            catalogues.append(getattr(catalog, &#39;_catalog&#39;, None))</span>
<span class="gi">+        merged: dict[str, str] = {}</span>
<span class="gi">+        for catalogue in filter(None, reversed(catalogues)):  # type: dict[str, str]</span>
<span class="gi">+            merged |= catalogue</span>
<span class="gi">+</span>
<span class="gi">+        # phase1: replace reference ids with translated names</span>
<span class="gi">+        for node, msg in extract_messages(self.document):</span>
<span class="gi">+            msgstr = merged.get(msg, &#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            # There is no point in having noqa on literal blocks because</span>
<span class="gi">+            # they cannot contain references.  Recognizing it would just</span>
<span class="gi">+            # completely prevent escaping the noqa.  Outside of literal</span>
<span class="gi">+            # blocks, one can always write \#noqa.</span>
<span class="gi">+            if not isinstance(node, LITERAL_TYPE_NODES):</span>
<span class="gi">+                msgstr, _ = parse_noqa(msgstr)</span>
<span class="gi">+</span>
<span class="gi">+            if msgstr.strip() == &#39;&#39;:</span>
<span class="gi">+                # as-of-yet untranslated</span>
<span class="gi">+                node[&#39;translated&#39;] = False</span>
<span class="gi">+                continue</span>
<span class="gi">+            if msgstr == msg:</span>
<span class="gi">+                # identical source and translated messages</span>
<span class="gi">+                node[&#39;translated&#39;] = True</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Avoid &quot;Literal block expected; none found.&quot; warnings.</span>
<span class="gi">+            # If msgstr ends with &#39;::&#39; then it cause warning message at</span>
<span class="gi">+            # parser.parse() processing.</span>
<span class="gi">+            # literal-block-warning is only appear in avobe case.</span>
<span class="gi">+            if msgstr.strip().endswith(&#39;::&#39;):</span>
<span class="gi">+                msgstr += &#39;\n\n   dummy literal&#39;</span>
<span class="gi">+                # dummy literal node will discard by &#39;patch = patch[0]&#39;</span>
<span class="gi">+</span>
<span class="gi">+            # literalblock need literal block notation to avoid it become</span>
<span class="gi">+            # paragraph.</span>
<span class="gi">+            if isinstance(node, LITERAL_TYPE_NODES):</span>
<span class="gi">+                msgstr = &#39;::\n\n&#39; + indent(msgstr, &#39; &#39; * 3)</span>
<span class="gi">+</span>
<span class="gi">+            patch = publish_msgstr(self.app, msgstr, source,</span>
<span class="gi">+                                   node.line, self.config, settings)  # type: ignore[arg-type]</span>
<span class="gi">+            # FIXME: no warnings about inconsistent references in this part</span>
<span class="gi">+            # XXX doctest and other block markup</span>
<span class="gi">+            if not isinstance(patch, nodes.paragraph):</span>
<span class="gi">+                continue  # skip for now</span>
<span class="gi">+</span>
<span class="gi">+            updater = _NodeUpdater(node, patch, self.document, noqa=False)</span>
<span class="gi">+            processed = updater.update_title_mapping()</span>
<span class="gi">+</span>
<span class="gi">+            # glossary terms update refid</span>
<span class="gi">+            if isinstance(node, nodes.term):</span>
<span class="gi">+                for _id in node[&#39;ids&#39;]:</span>
<span class="gi">+                    term, first_classifier = split_term_classifiers(msgstr)</span>
<span class="gi">+                    patch = publish_msgstr(</span>
<span class="gi">+                        self.app, term or &#39;&#39;, source, node.line, self.config, settings,  # type: ignore[arg-type]</span>
<span class="gi">+                    )</span>
<span class="gi">+                    updater.patch = make_glossary_term(</span>
<span class="gi">+                        self.env, patch, first_classifier,</span>
<span class="gi">+                        source, node.line, _id, self.document,  # type: ignore[arg-type]</span>
<span class="gi">+                    )</span>
<span class="gi">+                    processed = True</span>
<span class="gi">+</span>
<span class="gi">+            # update leaves with processed nodes</span>
<span class="gi">+            if processed:</span>
<span class="gi">+                updater.update_leaves()</span>
<span class="gi">+                node[&#39;translated&#39;] = True  # to avoid double translation</span>
<span class="gi">+            else:</span>
<span class="gi">+                node[&#39;translated&#39;] = False</span>
<span class="gi">+</span>
<span class="gi">+        # phase2: translation</span>
<span class="gi">+        for node, msg in extract_messages(self.document):</span>
<span class="gi">+            if node.setdefault(&#39;translated&#39;, False):  # to avoid double translation</span>
<span class="gi">+                continue  # skip if the node is already translated by phase1</span>
<span class="gi">+</span>
<span class="gi">+            msgstr = merged.get(msg, &#39;&#39;)</span>
<span class="gi">+            noqa = False</span>
<span class="gi">+</span>
<span class="gi">+            # See above.</span>
<span class="gi">+            if not isinstance(node, LITERAL_TYPE_NODES):</span>
<span class="gi">+                msgstr, noqa = parse_noqa(msgstr)</span>
<span class="gi">+</span>
<span class="gi">+            if not msgstr or msgstr == msg:  # as-of-yet untranslated</span>
<span class="gi">+                node[&#39;translated&#39;] = False</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # update translatable nodes</span>
<span class="gi">+            if isinstance(node, addnodes.translatable):</span>
<span class="gi">+                node.apply_translated_message(msg, msgstr)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # update meta nodes</span>
<span class="gi">+            if isinstance(node, nodes.meta):</span>
<span class="gi">+                node[&#39;content&#39;] = msgstr</span>
<span class="gi">+                node[&#39;translated&#39;] = True</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(node, nodes.image) and node.get(&#39;alt&#39;) == msg:</span>
<span class="gi">+                node[&#39;alt&#39;] = msgstr</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # Avoid &quot;Literal block expected; none found.&quot; warnings.</span>
<span class="gi">+            # If msgstr ends with &#39;::&#39; then it cause warning message at</span>
<span class="gi">+            # parser.parse() processing.</span>
<span class="gi">+            # literal-block-warning is only appear in avobe case.</span>
<span class="gi">+            if msgstr.strip().endswith(&#39;::&#39;):</span>
<span class="gi">+                msgstr += &#39;\n\n   dummy literal&#39;</span>
<span class="gi">+                # dummy literal node will discard by &#39;patch = patch[0]&#39;</span>
<span class="gi">+</span>
<span class="gi">+            # literalblock need literal block notation to avoid it become</span>
<span class="gi">+            # paragraph.</span>
<span class="gi">+            if isinstance(node, LITERAL_TYPE_NODES):</span>
<span class="gi">+                msgstr = &#39;::\n\n&#39; + indent(msgstr, &#39; &#39; * 3)</span>
<span class="gi">+</span>
<span class="gi">+            # Structural Subelements phase1</span>
<span class="gi">+            # There is a possibility that only the title node is created.</span>
<span class="gi">+            # see: https://docutils.sourceforge.io/docs/ref/doctree.html#structural-subelements</span>
<span class="gi">+            if isinstance(node, nodes.title):</span>
<span class="gi">+                # This generates: &lt;section ...&gt;&lt;title&gt;msgstr&lt;/title&gt;&lt;/section&gt;</span>
<span class="gi">+                msgstr = msgstr + &#39;\n&#39; + &#39;=&#39; * len(msgstr) * 2</span>
<span class="gi">+</span>
<span class="gi">+            patch = publish_msgstr(self.app, msgstr, source,</span>
<span class="gi">+                                   node.line, self.config, settings)  # type: ignore[arg-type]</span>
<span class="gi">+            # Structural Subelements phase2</span>
<span class="gi">+            if isinstance(node, nodes.title):</span>
<span class="gi">+                # get &lt;title&gt; node that placed as a first child</span>
<span class="gi">+                patch = patch.next_node()  # type: ignore[assignment]</span>
<span class="gi">+</span>
<span class="gi">+            # ignore unexpected markups in translation message</span>
<span class="gi">+            unexpected: tuple[type[nodes.Element], ...] = (</span>
<span class="gi">+                nodes.paragraph,    # expected form of translation</span>
<span class="gi">+                nodes.title,        # generated by above &quot;Subelements phase2&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            # following types are expected if</span>
<span class="gi">+            # config.gettext_additional_targets is configured</span>
<span class="gi">+            unexpected += LITERAL_TYPE_NODES</span>
<span class="gi">+            unexpected += IMAGE_TYPE_NODES</span>
<span class="gi">+</span>
<span class="gi">+            if not isinstance(patch, unexpected):</span>
<span class="gi">+                continue  # skip</span>
<span class="gi">+</span>
<span class="gi">+            updater = _NodeUpdater(node, patch, self.document, noqa)</span>
<span class="gi">+            updater.update_autofootnote_references()</span>
<span class="gi">+            updater.update_refnamed_references()</span>
<span class="gi">+            updater.update_refnamed_footnote_references()</span>
<span class="gi">+            updater.update_citation_references()</span>
<span class="gi">+            updater.update_pending_xrefs()</span>
<span class="gi">+            updater.update_leaves()</span>
<span class="gi">+</span>
<span class="gi">+            # for highlighting that expects .rawsource and .astext() are same.</span>
<span class="gi">+            if isinstance(node, LITERAL_TYPE_NODES):</span>
<span class="gi">+                node.rawsource = node.astext()</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(node, nodes.image) and node.get(&#39;alt&#39;) != msg:</span>
<span class="gi">+                node[&#39;uri&#39;] = patch[&#39;uri&#39;]</span>
<span class="gi">+                node[&#39;translated&#39;] = False</span>
<span class="gi">+                continue  # do not mark translated</span>
<span class="gi">+</span>
<span class="gi">+            node[&#39;translated&#39;] = True  # to avoid double translation</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;index&#39; in self.config.gettext_additional_targets:</span>
<span class="gi">+            # Extract and translate messages for index entries.</span>
<span class="gi">+            for node, entries in traverse_translatable_index(self.document):</span>
<span class="gi">+                new_entries: list[tuple[str, str, str, str, str | None]] = []</span>
<span class="gi">+                for entry_type, value, target_id, main, _category_key in entries:</span>
<span class="gi">+                    msg_parts = split_index_msg(entry_type, value)</span>
<span class="gi">+                    msgstr_parts = []</span>
<span class="gi">+                    for part in msg_parts:</span>
<span class="gi">+                        msgstr = merged.get(part, &#39;&#39;)</span>
<span class="gi">+                        if not msgstr:</span>
<span class="gi">+                            msgstr = part</span>
<span class="gi">+                        msgstr_parts.append(msgstr)</span>
<span class="gi">+</span>
<span class="gi">+                    new_entry = entry_type, &#39;;&#39;.join(msgstr_parts), target_id, main, None</span>
<span class="gi">+                    new_entries.append(new_entry)</span>
<span class="gi">+</span>
<span class="gi">+                node[&#39;raw_entries&#39;] = entries</span>
<span class="gi">+                node[&#39;entries&#39;] = new_entries</span>
<span class="gi">+</span>

<span class="w"> </span>class TranslationProgressTotaliser(SphinxTransform):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Calculate the number of translated and untranslated nodes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    default_priority = 25</span>
<span class="gi">+</span>
<span class="gi">+    default_priority = 25  # MUST happen after Locale</span>
<span class="gi">+</span>
<span class="gi">+    def apply(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        from sphinx.builders.gettext import MessageCatalogBuilder</span>
<span class="gi">+        if isinstance(self.app.builder, MessageCatalogBuilder):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        total = translated = 0</span>
<span class="gi">+        for node in NodeMatcher(nodes.Element, translated=Any).findall(self.document):</span>
<span class="gi">+            total += 1</span>
<span class="gi">+            if node[&#39;translated&#39;]:</span>
<span class="gi">+                translated += 1</span>
<span class="gi">+</span>
<span class="gi">+        self.document[&#39;translation_progress&#39;] = {</span>
<span class="gi">+            &#39;total&#39;: total,</span>
<span class="gi">+            &#39;translated&#39;: translated,</span>
<span class="gi">+        }</span>


<span class="w"> </span>class AddTranslationClasses(SphinxTransform):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Add ``translated`` or ``untranslated`` classes to indicate translation status.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    default_priority = 950

<span class="gi">+    def apply(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        from sphinx.builders.gettext import MessageCatalogBuilder</span>
<span class="gi">+        if isinstance(self.app.builder, MessageCatalogBuilder):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if not self.config.translation_progress_classes:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if self.config.translation_progress_classes is True:</span>
<span class="gi">+            add_translated = add_untranslated = True</span>
<span class="gi">+        elif self.config.translation_progress_classes == &#39;translated&#39;:</span>
<span class="gi">+            add_translated = True</span>
<span class="gi">+            add_untranslated = False</span>
<span class="gi">+        elif self.config.translation_progress_classes == &#39;untranslated&#39;:</span>
<span class="gi">+            add_translated = False</span>
<span class="gi">+            add_untranslated = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            msg = (&#39;translation_progress_classes must be &#39;</span>
<span class="gi">+                   &#39;True, False, &quot;translated&quot; or &quot;untranslated&quot;&#39;)</span>
<span class="gi">+            raise ConfigError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        for node in NodeMatcher(nodes.Element, translated=Any).findall(self.document):</span>
<span class="gi">+            if node[&#39;translated&#39;]:</span>
<span class="gi">+                if add_translated:</span>
<span class="gi">+                    node.setdefault(&#39;classes&#39;, []).append(&#39;translated&#39;)  # type: ignore[arg-type]</span>
<span class="gi">+            else:</span>
<span class="gi">+                if add_untranslated:</span>
<span class="gi">+                    node.setdefault(&#39;classes&#39;, []).append(&#39;untranslated&#39;)  # type: ignore[arg-type]</span>
<span class="gi">+</span>

<span class="w"> </span>class RemoveTranslatableInline(SphinxTransform):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Remove inline nodes used for translation as placeholders.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    default_priority = 999
<span class="gi">+</span>
<span class="gi">+    def apply(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        from sphinx.builders.gettext import MessageCatalogBuilder</span>
<span class="gi">+        if isinstance(self.app.builder, MessageCatalogBuilder):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        matcher = NodeMatcher(nodes.inline, translatable=Any)</span>
<span class="gi">+        for inline in matcher.findall(self.document):</span>
<span class="gi">+            inline.parent.remove(inline)</span>
<span class="gi">+            inline.parent += inline.children</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_transform(PreserveTranslatableMessages)</span>
<span class="gi">+    app.add_transform(Locale)</span>
<span class="gi">+    app.add_transform(TranslationProgressTotaliser)</span>
<span class="gi">+    app.add_transform(AddTranslationClasses)</span>
<span class="gi">+    app.add_transform(RemoveTranslatableInline)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/transforms/post_transforms/code.py b/sphinx/transforms/post_transforms/code.py</span>
<span class="gh">index b9d48014f..4375b4d89 100644</span>
<span class="gd">--- a/sphinx/transforms/post_transforms/code.py</span>
<span class="gi">+++ b/sphinx/transforms/post_transforms/code.py</span>
<span class="gu">@@ -1,14 +1,20 @@</span>
<span class="w"> </span>&quot;&quot;&quot;transforms for code-blocks.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>from typing import TYPE_CHECKING, Any, NamedTuple
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from pygments.lexers import PythonConsoleLexer, guess_lexer
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.ext import doctest
<span class="w"> </span>from sphinx.transforms import SphinxTransform
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.nodes import Node, TextElement
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata

<span class="gu">@@ -27,17 +33,56 @@ class HighlightLanguageTransform(SphinxTransform):</span>
<span class="w"> </span>    :rst:dir:`highlight` directive.  After processing, this transform
<span class="w"> </span>    removes ``highlightlang`` node from doctree.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    default_priority = 400

<span class="gi">+    def apply(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        visitor = HighlightLanguageVisitor(self.document,</span>
<span class="gi">+                                           self.config.highlight_language)</span>
<span class="gi">+        self.document.walkabout(visitor)</span>

<span class="gd">-class HighlightLanguageVisitor(nodes.NodeVisitor):</span>
<span class="gi">+        for node in list(self.document.findall(addnodes.highlightlang)):</span>
<span class="gi">+            node.parent.remove(node)</span>

<span class="gd">-    def __init__(self, document: nodes.document, default_language: str) -&gt;None:</span>
<span class="gd">-        self.default_setting = HighlightSetting(default_language, False,</span>
<span class="gd">-            sys.maxsize)</span>
<span class="gi">+</span>
<span class="gi">+class HighlightLanguageVisitor(nodes.NodeVisitor):</span>
<span class="gi">+    def __init__(self, document: nodes.document, default_language: str) -&gt; None:</span>
<span class="gi">+        self.default_setting = HighlightSetting(default_language, False, sys.maxsize)</span>
<span class="w"> </span>        self.settings: list[HighlightSetting] = []
<span class="w"> </span>        super().__init__(document)

<span class="gi">+    def unknown_visit(self, node: Node) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def unknown_departure(self, node: Node) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_document(self, node: Node) -&gt; None:</span>
<span class="gi">+        self.settings.append(self.default_setting)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_document(self, node: Node) -&gt; None:</span>
<span class="gi">+        self.settings.pop()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_start_of_file(self, node: Node) -&gt; None:</span>
<span class="gi">+        self.settings.append(self.default_setting)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_start_of_file(self, node: Node) -&gt; None:</span>
<span class="gi">+        self.settings.pop()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_highlightlang(self, node: addnodes.highlightlang) -&gt; None:</span>
<span class="gi">+        self.settings[-1] = HighlightSetting(node[&#39;lang&#39;],</span>
<span class="gi">+                                             node[&#39;force&#39;],</span>
<span class="gi">+                                             node[&#39;linenothreshold&#39;])</span>
<span class="gi">+</span>
<span class="gi">+    def visit_literal_block(self, node: nodes.literal_block) -&gt; None:</span>
<span class="gi">+        setting = self.settings[-1]</span>
<span class="gi">+        if &#39;language&#39; not in node:</span>
<span class="gi">+            node[&#39;language&#39;] = setting.language</span>
<span class="gi">+            node[&#39;force&#39;] = setting.force</span>
<span class="gi">+        if &#39;linenos&#39; not in node:</span>
<span class="gi">+            lines = node.astext().count(&#39;\n&#39;)</span>
<span class="gi">+            node[&#39;linenos&#39;] = (lines &gt;= setting.lineno_threshold - 1)</span>
<span class="gi">+</span>

<span class="w"> </span>class TrimDoctestFlagsTransform(SphinxTransform):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -45,4 +90,53 @@ class TrimDoctestFlagsTransform(SphinxTransform):</span>

<span class="w"> </span>    see :confval:`trim_doctest_flags` for more information.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    default_priority = HighlightLanguageTransform.default_priority + 1
<span class="gi">+</span>
<span class="gi">+    def apply(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        for lbnode in self.document.findall(nodes.literal_block):</span>
<span class="gi">+            if self.is_pyconsole(lbnode):</span>
<span class="gi">+                self.strip_doctest_flags(lbnode)</span>
<span class="gi">+</span>
<span class="gi">+        for dbnode in self.document.findall(nodes.doctest_block):</span>
<span class="gi">+            self.strip_doctest_flags(dbnode)</span>
<span class="gi">+</span>
<span class="gi">+    def strip_doctest_flags(self, node: TextElement) -&gt; None:</span>
<span class="gi">+        if not node.get(&#39;trim_flags&#39;, self.config.trim_doctest_flags):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        source = node.rawsource</span>
<span class="gi">+        source = doctest.blankline_re.sub(&#39;&#39;, source)</span>
<span class="gi">+        source = doctest.doctestopt_re.sub(&#39;&#39;, source)</span>
<span class="gi">+        node.rawsource = source</span>
<span class="gi">+        node[:] = [nodes.Text(source)]</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def is_pyconsole(node: nodes.literal_block) -&gt; bool:</span>
<span class="gi">+        if node.rawsource != node.astext():</span>
<span class="gi">+            return False  # skip parsed-literal node</span>
<span class="gi">+</span>
<span class="gi">+        language = node.get(&#39;language&#39;)</span>
<span class="gi">+        if language in {&#39;pycon&#39;, &#39;pycon3&#39;}:</span>
<span class="gi">+            return True</span>
<span class="gi">+        elif language in {&#39;py&#39;, &#39;python&#39;, &#39;py3&#39;, &#39;python3&#39;, &#39;default&#39;}:</span>
<span class="gi">+            return node.rawsource.startswith(&#39;&gt;&gt;&gt;&#39;)</span>
<span class="gi">+        elif language == &#39;guess&#39;:</span>
<span class="gi">+            try:</span>
<span class="gi">+                lexer = guess_lexer(node.rawsource)</span>
<span class="gi">+                return isinstance(lexer, PythonConsoleLexer)</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_post_transform(HighlightLanguageTransform)</span>
<span class="gi">+    app.add_post_transform(TrimDoctestFlagsTransform)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/transforms/post_transforms/images.py b/sphinx/transforms/post_transforms/images.py</span>
<span class="gh">index 76d5727d2..05b07dd22 100644</span>
<span class="gd">--- a/sphinx/transforms/post_transforms/images.py</span>
<span class="gi">+++ b/sphinx/transforms/post_transforms/images.py</span>
<span class="gu">@@ -1,12 +1,16 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Docutils transforms used by Sphinx.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import re
<span class="w"> </span>from hashlib import sha1
<span class="w"> </span>from math import ceil
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.transforms import SphinxTransform
<span class="w"> </span>from sphinx.util import logging, requests
<span class="gu">@@ -14,25 +18,146 @@ from sphinx.util._pathlib import _StrPath</span>
<span class="w"> </span>from sphinx.util.http_date import epoch_to_rfc1123, rfc1123_to_epoch
<span class="w"> </span>from sphinx.util.images import get_image_extension, guess_mimetype, parse_data_uri
<span class="w"> </span>from sphinx.util.osutil import ensuredir
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gi">+</span>
<span class="w"> </span>MAX_FILENAME_LEN = 32
<span class="w"> </span>CRITICAL_PATH_CHAR_RE = re.compile(&#39;[:;&lt;&gt;|*&quot; ]&#39;)


<span class="w"> </span>class BaseImageConverter(SphinxTransform):
<span class="gd">-    pass</span>
<span class="gi">+    def apply(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        for node in self.document.findall(nodes.image):</span>
<span class="gi">+            if self.match(node):</span>
<span class="gi">+                self.handle(node)</span>
<span class="gi">+</span>
<span class="gi">+    def match(self, node: nodes.image) -&gt; bool:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def handle(self, node: nodes.image) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def imagedir(self) -&gt; str:</span>
<span class="gi">+        return os.path.join(self.app.doctreedir, &#39;images&#39;)</span>


<span class="w"> </span>class ImageDownloader(BaseImageConverter):
<span class="w"> </span>    default_priority = 100

<span class="gi">+    def match(self, node: nodes.image) -&gt; bool:</span>
<span class="gi">+        if not self.app.builder.supported_image_types:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if self.app.builder.supported_remote_images:</span>
<span class="gi">+            return False</span>
<span class="gi">+        return &#39;://&#39; in node[&#39;uri&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    def handle(self, node: nodes.image) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            basename = os.path.basename(node[&#39;uri&#39;])</span>
<span class="gi">+            if &#39;?&#39; in basename:</span>
<span class="gi">+                basename = basename.split(&#39;?&#39;)[0]</span>
<span class="gi">+            if basename == &#39;&#39; or len(basename) &gt; MAX_FILENAME_LEN:</span>
<span class="gi">+                filename, ext = os.path.splitext(node[&#39;uri&#39;])</span>
<span class="gi">+                basename = sha1(filename.encode(), usedforsecurity=False).hexdigest() + ext</span>
<span class="gi">+            basename = CRITICAL_PATH_CHAR_RE.sub(&quot;_&quot;, basename)</span>
<span class="gi">+</span>
<span class="gi">+            uri_hash = sha1(node[&#39;uri&#39;].encode(), usedforsecurity=False).hexdigest()</span>
<span class="gi">+            path = Path(self.imagedir, uri_hash, basename)</span>
<span class="gi">+            path.parent.mkdir(parents=True, exist_ok=True)</span>
<span class="gi">+            self._download_image(node, path)</span>
<span class="gi">+</span>
<span class="gi">+        except Exception as exc:</span>
<span class="gi">+            msg = __(&#39;Could not fetch remote image: %s [%s]&#39;)</span>
<span class="gi">+            logger.warning(msg, node[&#39;uri&#39;], exc)</span>
<span class="gi">+</span>
<span class="gi">+    def _download_image(self, node: nodes.image, path: Path) -&gt; None:</span>
<span class="gi">+        headers = {}</span>
<span class="gi">+        if path.exists():</span>
<span class="gi">+            timestamp: float = ceil(path.stat().st_mtime)</span>
<span class="gi">+            headers[&#39;If-Modified-Since&#39;] = epoch_to_rfc1123(timestamp)</span>
<span class="gi">+</span>
<span class="gi">+        config = self.app.config</span>
<span class="gi">+        r = requests.get(</span>
<span class="gi">+            node[&#39;uri&#39;], headers=headers,</span>
<span class="gi">+            _user_agent=config.user_agent,</span>
<span class="gi">+            _tls_info=(config.tls_verify, config.tls_cacerts),</span>
<span class="gi">+        )</span>
<span class="gi">+        if r.status_code &gt;= 400:</span>
<span class="gi">+            msg = __(&#39;Could not fetch remote image: %s [%d]&#39;)</span>
<span class="gi">+            logger.warning(msg, node[&#39;uri&#39;], r.status_code)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.app.env.original_image_uri[_StrPath(path)] = node[&#39;uri&#39;]</span>
<span class="gi">+</span>
<span class="gi">+            if r.status_code == 200:</span>
<span class="gi">+                path.write_bytes(r.content)</span>
<span class="gi">+            if last_modified := r.headers.get(&#39;Last-Modified&#39;):</span>
<span class="gi">+                timestamp = rfc1123_to_epoch(last_modified)</span>
<span class="gi">+                os.utime(path, (timestamp, timestamp))</span>
<span class="gi">+</span>
<span class="gi">+            self._process_image(node, path)</span>
<span class="gi">+</span>
<span class="gi">+    def _process_image(self, node: nodes.image, path: Path) -&gt; None:</span>
<span class="gi">+        str_path = _StrPath(path)</span>
<span class="gi">+        self.app.env.original_image_uri[str_path] = node[&#39;uri&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        mimetype = guess_mimetype(path, default=&#39;*&#39;)</span>
<span class="gi">+        if mimetype != &#39;*&#39; and path.suffix == &#39;&#39;:</span>
<span class="gi">+            # append a suffix if URI does not contain suffix</span>
<span class="gi">+            ext = get_image_extension(mimetype) or &#39;&#39;</span>
<span class="gi">+            with_ext = path.with_name(path.name + ext)</span>
<span class="gi">+            os.replace(path, with_ext)</span>
<span class="gi">+            self.app.env.original_image_uri.pop(str_path)</span>
<span class="gi">+            self.app.env.original_image_uri[_StrPath(with_ext)] = node[&#39;uri&#39;]</span>
<span class="gi">+            path = with_ext</span>
<span class="gi">+        path_str = str(path)</span>
<span class="gi">+        node[&#39;candidates&#39;].pop(&#39;?&#39;)</span>
<span class="gi">+        node[&#39;candidates&#39;][mimetype] = path_str</span>
<span class="gi">+        node[&#39;uri&#39;] = path_str</span>
<span class="gi">+        self.app.env.images.add_file(self.env.docname, path_str)</span>
<span class="gi">+</span>

<span class="w"> </span>class DataURIExtractor(BaseImageConverter):
<span class="w"> </span>    default_priority = 150

<span class="gi">+    def match(self, node: nodes.image) -&gt; bool:</span>
<span class="gi">+        if self.app.builder.supported_data_uri_images is True:</span>
<span class="gi">+            return False  # do not transform the image; data URIs are valid in the build output</span>
<span class="gi">+        return node[&#39;uri&#39;].startswith(&#39;data:&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def handle(self, node: nodes.image) -&gt; None:</span>
<span class="gi">+        image = parse_data_uri(node[&#39;uri&#39;])</span>
<span class="gi">+        assert image is not None</span>
<span class="gi">+        ext = get_image_extension(image.mimetype)</span>
<span class="gi">+        if ext is None:</span>
<span class="gi">+            logger.warning(__(&#39;Unknown image format: %s...&#39;), node[&#39;uri&#39;][:32],</span>
<span class="gi">+                           location=node)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        ensuredir(os.path.join(self.imagedir, &#39;embeded&#39;))</span>
<span class="gi">+        digest = sha1(image.data, usedforsecurity=False).hexdigest()</span>
<span class="gi">+        path = _StrPath(self.imagedir, &#39;embeded&#39;, digest + ext)</span>
<span class="gi">+        self.app.env.original_image_uri[path] = node[&#39;uri&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        with open(path, &#39;wb&#39;) as f:</span>
<span class="gi">+            f.write(image.data)</span>
<span class="gi">+</span>
<span class="gi">+        path_str = str(path)</span>
<span class="gi">+        node[&#39;candidates&#39;].pop(&#39;?&#39;)</span>
<span class="gi">+        node[&#39;candidates&#39;][image.mimetype] = path_str</span>
<span class="gi">+        node[&#39;uri&#39;] = path_str</span>
<span class="gi">+        self.app.env.images.add_file(self.env.docname, path_str)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_filename_for(filename: str, mimetype: str) -&gt; str:</span>
<span class="gi">+    basename = os.path.basename(filename)</span>
<span class="gi">+    basename = CRITICAL_PATH_CHAR_RE.sub(&quot;_&quot;, basename)</span>
<span class="gi">+    return os.path.splitext(basename)[0] + (get_image_extension(mimetype) or &#39;&#39;)</span>
<span class="gi">+</span>

<span class="w"> </span>class ImageConverter(BaseImageConverter):
<span class="w"> </span>    &quot;&quot;&quot;A base class for image converters.
<span class="gu">@@ -55,18 +180,113 @@ class ImageConverter(BaseImageConverter):</span>
<span class="w"> </span>    3. Register your image converter to Sphinx using
<span class="w"> </span>       :py:meth:`.Sphinx.add_post_transform`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    default_priority = 200
<span class="gi">+</span>
<span class="gi">+    #: The converter is available or not.  Will be filled at the first call of</span>
<span class="gi">+    #: the build.  The result is shared in the same process.</span>
<span class="gi">+    #:</span>
<span class="gi">+    #: .. todo:: This should be refactored not to store the state without class</span>
<span class="gi">+    #:           variable.</span>
<span class="w"> </span>    available: bool | None = None
<span class="gi">+</span>
<span class="gi">+    #: A conversion rules the image converter supports.</span>
<span class="gi">+    #: It is represented as a list of pair of source image format (mimetype) and</span>
<span class="gi">+    #: destination one::</span>
<span class="gi">+    #:</span>
<span class="gi">+    #:     conversion_rules = [</span>
<span class="gi">+    #:         (&#39;image/svg+xml&#39;, &#39;image/png&#39;),</span>
<span class="gi">+    #:         (&#39;image/gif&#39;, &#39;image/png&#39;),</span>
<span class="gi">+    #:         (&#39;application/pdf&#39;, &#39;image/png&#39;),</span>
<span class="gi">+    #:     ]</span>
<span class="w"> </span>    conversion_rules: list[tuple[str, str]] = []

<span class="gd">-    def is_available(self) -&gt;bool:</span>
<span class="gi">+    def match(self, node: nodes.image) -&gt; bool:</span>
<span class="gi">+        if not self.app.builder.supported_image_types:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if &#39;?&#39; in node[&#39;candidates&#39;]:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if set(self.guess_mimetypes(node)) &amp; set(self.app.builder.supported_image_types):</span>
<span class="gi">+            # builder supports the image; no need to convert</span>
<span class="gi">+            return False</span>
<span class="gi">+        if self.available is None:</span>
<span class="gi">+            # store the value to the class variable to share it during the build</span>
<span class="gi">+            self.__class__.available = self.is_available()</span>
<span class="gi">+</span>
<span class="gi">+        if not self.available:</span>
<span class="gi">+            return False</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                self.get_conversion_rule(node)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                return False</span>
<span class="gi">+            else:</span>
<span class="gi">+                return True</span>
<span class="gi">+</span>
<span class="gi">+    def get_conversion_rule(self, node: nodes.image) -&gt; tuple[str, str]:</span>
<span class="gi">+        for candidate in self.guess_mimetypes(node):</span>
<span class="gi">+            for supported in self.app.builder.supported_image_types:</span>
<span class="gi">+                rule = (candidate, supported)</span>
<span class="gi">+                if rule in self.conversion_rules:</span>
<span class="gi">+                    return rule</span>
<span class="gi">+</span>
<span class="gi">+        msg = &#39;No conversion rule found&#39;</span>
<span class="gi">+        raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    def is_available(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return the image converter is available or not.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def guess_mimetypes(self, node: nodes.image) -&gt; list[str]:</span>
<span class="gi">+        # The special key ? is set for nonlocal URIs.</span>
<span class="gi">+        if &#39;?&#39; in node[&#39;candidates&#39;]:</span>
<span class="gi">+            return []</span>
<span class="gi">+        elif &#39;*&#39; in node[&#39;candidates&#39;]:</span>
<span class="gi">+            path = os.path.join(self.app.srcdir, node[&#39;uri&#39;])</span>
<span class="gi">+            guessed = guess_mimetype(path)</span>
<span class="gi">+            return [guessed] if guessed is not None else []</span>
<span class="gi">+        else:</span>
<span class="gi">+            return node[&#39;candidates&#39;].keys()</span>
<span class="gi">+</span>
<span class="gi">+    def handle(self, node: nodes.image) -&gt; None:</span>
<span class="gi">+        _from, _to = self.get_conversion_rule(node)</span>
<span class="gi">+</span>
<span class="gi">+        if _from in node[&#39;candidates&#39;]:</span>
<span class="gi">+            srcpath = node[&#39;candidates&#39;][_from]</span>
<span class="gi">+        else:</span>
<span class="gi">+            srcpath = node[&#39;candidates&#39;][&#39;*&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        filename = self.env.images[srcpath][1]</span>
<span class="gi">+        filename = get_filename_for(filename, _to)</span>
<span class="gi">+        ensuredir(self.imagedir)</span>
<span class="gi">+        destpath = os.path.join(self.imagedir, filename)</span>
<span class="gi">+</span>
<span class="gi">+        abs_srcpath = os.path.join(self.app.srcdir, srcpath)</span>
<span class="gi">+        if self.convert(abs_srcpath, destpath):</span>
<span class="gi">+            if &#39;*&#39; in node[&#39;candidates&#39;]:</span>
<span class="gi">+                node[&#39;candidates&#39;][&#39;*&#39;] = destpath</span>
<span class="gi">+            else:</span>
<span class="gi">+                node[&#39;candidates&#39;][_to] = destpath</span>
<span class="gi">+            node[&#39;uri&#39;] = destpath</span>

<span class="gd">-    def convert(self, _from: str, _to: str) -&gt;bool:</span>
<span class="gi">+            self.env.original_image_uri[_StrPath(destpath)] = srcpath</span>
<span class="gi">+            self.env.images.add_file(self.env.docname, destpath)</span>
<span class="gi">+</span>
<span class="gi">+    def convert(self, _from: str, _to: str) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Convert an image file to the expected format.

<span class="w"> </span>        *_from* is a path of the source image file, and *_to* is a path
<span class="w"> </span>        of the destination file.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_post_transform(ImageDownloader)</span>
<span class="gi">+    app.add_post_transform(DataURIExtractor)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/transforms/references.py b/sphinx/transforms/references.py</span>
<span class="gh">index f9e9f641a..6f935aa2a 100644</span>
<span class="gd">--- a/sphinx/transforms/references.py</span>
<span class="gi">+++ b/sphinx/transforms/references.py</span>
<span class="gu">@@ -1,8 +1,13 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Docutils transforms used by Sphinx.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from docutils.transforms.references import DanglingReferences
<span class="gi">+</span>
<span class="w"> </span>from sphinx.transforms import SphinxTransform
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gu">@@ -11,7 +16,34 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>class SphinxDanglingReferences(DanglingReferences):
<span class="w"> </span>    &quot;&quot;&quot;DanglingReferences transform which does not output info messages.&quot;&quot;&quot;

<span class="gi">+    def apply(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            reporter = self.document.reporter</span>
<span class="gi">+            report_level = reporter.report_level</span>
<span class="gi">+</span>
<span class="gi">+            # suppress INFO level messages for a while</span>
<span class="gi">+            reporter.report_level = max(reporter.WARNING_LEVEL, reporter.report_level)</span>
<span class="gi">+            super().apply()  # type: ignore[no-untyped-call]</span>
<span class="gi">+        finally:</span>
<span class="gi">+            reporter.report_level = report_level</span>
<span class="gi">+</span>

<span class="w"> </span>class SphinxDomains(SphinxTransform):
<span class="w"> </span>    &quot;&quot;&quot;Collect objects to Sphinx domains for cross references.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    default_priority = 850
<span class="gi">+</span>
<span class="gi">+    def apply(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        for domain in self.env.domains.values():</span>
<span class="gi">+            domain.process_doc(self.env, self.env.docname, self.document)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_transform(SphinxDanglingReferences)</span>
<span class="gi">+    app.add_transform(SphinxDomains)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/util/_files.py b/sphinx/util/_files.py</span>
<span class="gh">index 9f83a18a5..925200241 100644</span>
<span class="gd">--- a/sphinx/util/_files.py</span>
<span class="gi">+++ b/sphinx/util/_files.py</span>
<span class="gu">@@ -1,4 +1,5 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import hashlib
<span class="w"> </span>import os.path
<span class="w"> </span>from typing import Any
<span class="gu">@@ -11,13 +12,39 @@ class FilenameUniqDict(dict[str, tuple[set[str], str]]):</span>
<span class="w"> </span>    appear in.  Used for images and downloadable files in the environment.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self._existing: set[str] = set()

<span class="gd">-    def __getstate__(self) -&gt;set[str]:</span>
<span class="gi">+    def add_file(self, docname: str, newfile: str) -&gt; str:</span>
<span class="gi">+        if newfile in self:</span>
<span class="gi">+            self[newfile][0].add(docname)</span>
<span class="gi">+            return self[newfile][1]</span>
<span class="gi">+        uniquename = os.path.basename(newfile)</span>
<span class="gi">+        base, ext = os.path.splitext(uniquename)</span>
<span class="gi">+        i = 0</span>
<span class="gi">+        while uniquename in self._existing:</span>
<span class="gi">+            i += 1</span>
<span class="gi">+            uniquename = f&#39;{base}{i}{ext}&#39;</span>
<span class="gi">+        self[newfile] = ({docname}, uniquename)</span>
<span class="gi">+        self._existing.add(uniquename)</span>
<span class="gi">+        return uniquename</span>
<span class="gi">+</span>
<span class="gi">+    def purge_doc(self, docname: str) -&gt; None:</span>
<span class="gi">+        for filename, (docs, unique) in list(self.items()):</span>
<span class="gi">+            docs.discard(docname)</span>
<span class="gi">+            if not docs:</span>
<span class="gi">+                del self[filename]</span>
<span class="gi">+                self._existing.discard(unique)</span>
<span class="gi">+</span>
<span class="gi">+    def merge_other(self, docnames: set[str], other: dict[str, tuple[set[str], Any]]) -&gt; None:</span>
<span class="gi">+        for filename, (docs, _unique) in other.items():</span>
<span class="gi">+            for doc in docs &amp; set(docnames):</span>
<span class="gi">+                self.add_file(doc, filename)</span>
<span class="gi">+</span>
<span class="gi">+    def __getstate__(self) -&gt; set[str]:</span>
<span class="w"> </span>        return self._existing

<span class="gd">-    def __setstate__(self, state: set[str]) -&gt;None:</span>
<span class="gi">+    def __setstate__(self, state: set[str]) -&gt; None:</span>
<span class="w"> </span>        self._existing = state


<span class="gu">@@ -27,3 +54,23 @@ class DownloadFiles(dict[str, tuple[set[str], str]]):</span>
<span class="w"> </span>    .. important:: This class would be refactored in nearly future.
<span class="w"> </span>                   Hence don&#39;t hack this directly.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    def add_file(self, docname: str, filename: str) -&gt; str:</span>
<span class="gi">+        if filename not in self:</span>
<span class="gi">+            digest = hashlib.md5(filename.encode(), usedforsecurity=False).hexdigest()</span>
<span class="gi">+            dest = f&#39;{digest}/{os.path.basename(filename)}&#39;</span>
<span class="gi">+            self[filename] = (set(), dest)</span>
<span class="gi">+</span>
<span class="gi">+        self[filename][0].add(docname)</span>
<span class="gi">+        return self[filename][1]</span>
<span class="gi">+</span>
<span class="gi">+    def purge_doc(self, docname: str) -&gt; None:</span>
<span class="gi">+        for filename, (docs, _dest) in list(self.items()):</span>
<span class="gi">+            docs.discard(docname)</span>
<span class="gi">+            if not docs:</span>
<span class="gi">+                del self[filename]</span>
<span class="gi">+</span>
<span class="gi">+    def merge_other(self, docnames: set[str], other: dict[str, tuple[set[str], Any]]) -&gt; None:</span>
<span class="gi">+        for filename, (docs, _dest) in other.items():</span>
<span class="gi">+            for docname in docs &amp; set(docnames):</span>
<span class="gi">+                self.add_file(docname, filename)</span>
<span class="gh">diff --git a/sphinx/util/_importer.py b/sphinx/util/_importer.py</span>
<span class="gh">index 6f88b541b..915750d2d 100644</span>
<span class="gd">--- a/sphinx/util/_importer.py</span>
<span class="gi">+++ b/sphinx/util/_importer.py</span>
<span class="gu">@@ -1,9 +1,27 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from importlib import import_module
<span class="w"> </span>from typing import Any
<span class="gi">+</span>
<span class="w"> </span>from sphinx.errors import ExtensionError


<span class="gd">-def import_object(object_name: str, /, source: str=&#39;&#39;) -&gt;Any:</span>
<span class="gi">+def import_object(object_name: str, /, source: str = &#39;&#39;) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Import python object by qualname.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    obj_path = object_name.split(&#39;.&#39;)</span>
<span class="gi">+    module_name = obj_path.pop(0)</span>
<span class="gi">+    try:</span>
<span class="gi">+        obj = import_module(module_name)</span>
<span class="gi">+        for name in obj_path:</span>
<span class="gi">+            module_name += &#39;.&#39; + name</span>
<span class="gi">+            try:</span>
<span class="gi">+                obj = getattr(obj, name)</span>
<span class="gi">+            except AttributeError:</span>
<span class="gi">+                obj = import_module(module_name)</span>
<span class="gi">+    except (AttributeError, ImportError) as exc:</span>
<span class="gi">+        if source:</span>
<span class="gi">+            msg = f&#39;Could not import {object_name} (needed for {source})&#39;</span>
<span class="gi">+            raise ExtensionError(msg, exc) from exc</span>
<span class="gi">+        msg = f&#39;Could not import {object_name}&#39;</span>
<span class="gi">+        raise ExtensionError(msg, exc) from exc</span>
<span class="gi">+    return obj</span>
<span class="gh">diff --git a/sphinx/util/_io.py b/sphinx/util/_io.py</span>
<span class="gh">index 47a4e10e9..3689d9e45 100644</span>
<span class="gd">--- a/sphinx/util/_io.py</span>
<span class="gi">+++ b/sphinx/util/_io.py</span>
<span class="gu">@@ -1,18 +1,34 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from sphinx.util.console import strip_escape_sequences
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing import Protocol

<span class="gd">-</span>
<span class="w"> </span>    class SupportsWrite(Protocol):
<span class="gd">-        pass</span>
<span class="gi">+        def write(self, text: str, /) -&gt; int | None:</span>
<span class="gi">+            ...</span>


<span class="w"> </span>class TeeStripANSI:
<span class="w"> </span>    &quot;&quot;&quot;File-like object writing to two streams.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, stream_term: SupportsWrite, stream_file: SupportsWrite</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        stream_term: SupportsWrite,</span>
<span class="gi">+        stream_file: SupportsWrite,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.stream_term = stream_term
<span class="w"> </span>        self.stream_file = stream_file
<span class="gi">+</span>
<span class="gi">+    def write(self, text: str, /) -&gt; None:</span>
<span class="gi">+        self.stream_term.write(text)</span>
<span class="gi">+        self.stream_file.write(strip_escape_sequences(text))</span>
<span class="gi">+</span>
<span class="gi">+    def flush(self) -&gt; None:</span>
<span class="gi">+        if hasattr(self.stream_term, &#39;flush&#39;):</span>
<span class="gi">+            self.stream_term.flush()</span>
<span class="gi">+        if hasattr(self.stream_file, &#39;flush&#39;):</span>
<span class="gi">+            self.stream_file.flush()</span>
<span class="gh">diff --git a/sphinx/util/_pathlib.py b/sphinx/util/_pathlib.py</span>
<span class="gh">index 12641986f..ebbb30607 100644</span>
<span class="gd">--- a/sphinx/util/_pathlib.py</span>
<span class="gi">+++ b/sphinx/util/_pathlib.py</span>
<span class="gu">@@ -11,44 +11,59 @@ or explicit string coercion.</span>
<span class="w"> </span>In Sphinx 9, ``Path`` objects will be expected and returned in all instances
<span class="w"> </span>that ``_StrPath`` is currently used.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>import warnings
<span class="w"> </span>from pathlib import Path, PosixPath, PurePath, WindowsPath
<span class="w"> </span>from typing import Any
<span class="gi">+</span>
<span class="w"> </span>from sphinx.deprecation import RemovedInSphinx90Warning
<span class="gi">+</span>
<span class="w"> </span>_STR_METHODS = frozenset(str.__dict__)
<span class="w"> </span>_PATH_NAME = Path().__class__.__name__
<span class="gi">+</span>
<span class="w"> </span>_MSG = (
<span class="gd">-    &#39;Sphinx 9 will drop support for representing paths as strings. Use &quot;pathlib.Path&quot; or &quot;os.fspath&quot; instead.&#39;</span>
<span class="gd">-    )</span>
<span class="gd">-if sys.platform == &#39;win32&#39;:</span>
<span class="gi">+    &#39;Sphinx 9 will drop support for representing paths as strings. &#39;</span>
<span class="gi">+    &#39;Use &quot;pathlib.Path&quot; or &quot;os.fspath&quot; instead.&#39;</span>
<span class="gi">+)</span>

<span class="gi">+# https://docs.python.org/3/library/stdtypes.html#typesseq-common</span>
<span class="gi">+# https://docs.python.org/3/library/stdtypes.html#string-methods</span>

<span class="gi">+if sys.platform == &#39;win32&#39;:</span>
<span class="w"> </span>    class _StrPath(WindowsPath):
<span class="gi">+        def replace(  # type: ignore[override]</span>
<span class="gi">+            self, old: str, new: str, count: int = -1, /,</span>
<span class="gi">+        ) -&gt; str:</span>
<span class="gi">+            # replace exists in both Path and str;</span>
<span class="gi">+            # in Path it makes filesystem changes, so we use the safer str version</span>
<span class="gi">+            warnings.warn(_MSG, RemovedInSphinx90Warning, stacklevel=2)</span>
<span class="gi">+            return self.__str__().replace(old, new, count)  # NoQA:  PLC2801</span>

<span class="gd">-        def __getattr__(self, item: str) -&gt;Any:</span>
<span class="gi">+        def __getattr__(self, item: str) -&gt; Any:</span>
<span class="w"> </span>            if item in _STR_METHODS:
<span class="w"> </span>                warnings.warn(_MSG, RemovedInSphinx90Warning, stacklevel=2)
<span class="w"> </span>                return getattr(self.__str__(), item)
<span class="w"> </span>            msg = f&#39;{_PATH_NAME!r} has no attribute {item!r}&#39;
<span class="w"> </span>            raise AttributeError(msg)

<span class="gd">-        def __add__(self, other: str) -&gt;str:</span>
<span class="gi">+        def __add__(self, other: str) -&gt; str:</span>
<span class="w"> </span>            warnings.warn(_MSG, RemovedInSphinx90Warning, stacklevel=2)
<span class="w"> </span>            return self.__str__() + other

<span class="gd">-        def __bool__(self) -&gt;bool:</span>
<span class="gi">+        def __bool__(self) -&gt; bool:</span>
<span class="w"> </span>            if not self.__str__():
<span class="w"> </span>                warnings.warn(_MSG, RemovedInSphinx90Warning, stacklevel=2)
<span class="w"> </span>                return False
<span class="w"> </span>            return True

<span class="gd">-        def __contains__(self, item: str) -&gt;bool:</span>
<span class="gi">+        def __contains__(self, item: str) -&gt; bool:</span>
<span class="w"> </span>            warnings.warn(_MSG, RemovedInSphinx90Warning, stacklevel=2)
<span class="w"> </span>            return item in self.__str__()

<span class="gd">-        def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+        def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>            if isinstance(other, PurePath):
<span class="w"> </span>                return super().__eq__(other)
<span class="w"> </span>            if isinstance(other, str):
<span class="gu">@@ -56,43 +71,48 @@ if sys.platform == &#39;win32&#39;:</span>
<span class="w"> </span>                return self.__str__() == other
<span class="w"> </span>            return NotImplemented

<span class="gd">-        def __hash__(self) -&gt;int:</span>
<span class="gi">+        def __hash__(self) -&gt; int:</span>
<span class="w"> </span>            return super().__hash__()

<span class="gd">-        def __getitem__(self, item: (int | slice)) -&gt;str:</span>
<span class="gi">+        def __getitem__(self, item: int | slice) -&gt; str:</span>
<span class="w"> </span>            warnings.warn(_MSG, RemovedInSphinx90Warning, stacklevel=2)
<span class="w"> </span>            return self.__str__()[item]

<span class="gd">-        def __len__(self) -&gt;int:</span>
<span class="gi">+        def __len__(self) -&gt; int:</span>
<span class="w"> </span>            warnings.warn(_MSG, RemovedInSphinx90Warning, stacklevel=2)
<span class="w"> </span>            return len(self.__str__())
<span class="w"> </span>else:
<span class="gd">-</span>
<span class="gd">-</span>
<span class="w"> </span>    class _StrPath(PosixPath):
<span class="gi">+        def replace(  # type: ignore[override]</span>
<span class="gi">+            self, old: str, new: str, count: int = -1, /,</span>
<span class="gi">+        ) -&gt; str:</span>
<span class="gi">+            # replace exists in both Path and str;</span>
<span class="gi">+            # in Path it makes filesystem changes, so we use the safer str version</span>
<span class="gi">+            warnings.warn(_MSG, RemovedInSphinx90Warning, stacklevel=2)</span>
<span class="gi">+            return self.__str__().replace(old, new, count)  # NoQA:  PLC2801</span>

<span class="gd">-        def __getattr__(self, item: str) -&gt;Any:</span>
<span class="gi">+        def __getattr__(self, item: str) -&gt; Any:</span>
<span class="w"> </span>            if item in _STR_METHODS:
<span class="w"> </span>                warnings.warn(_MSG, RemovedInSphinx90Warning, stacklevel=2)
<span class="w"> </span>                return getattr(self.__str__(), item)
<span class="w"> </span>            msg = f&#39;{_PATH_NAME!r} has no attribute {item!r}&#39;
<span class="w"> </span>            raise AttributeError(msg)

<span class="gd">-        def __add__(self, other: str) -&gt;str:</span>
<span class="gi">+        def __add__(self, other: str) -&gt; str:</span>
<span class="w"> </span>            warnings.warn(_MSG, RemovedInSphinx90Warning, stacklevel=2)
<span class="w"> </span>            return self.__str__() + other

<span class="gd">-        def __bool__(self) -&gt;bool:</span>
<span class="gi">+        def __bool__(self) -&gt; bool:</span>
<span class="w"> </span>            if not self.__str__():
<span class="w"> </span>                warnings.warn(_MSG, RemovedInSphinx90Warning, stacklevel=2)
<span class="w"> </span>                return False
<span class="w"> </span>            return True

<span class="gd">-        def __contains__(self, item: str) -&gt;bool:</span>
<span class="gi">+        def __contains__(self, item: str) -&gt; bool:</span>
<span class="w"> </span>            warnings.warn(_MSG, RemovedInSphinx90Warning, stacklevel=2)
<span class="w"> </span>            return item in self.__str__()

<span class="gd">-        def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+        def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>            if isinstance(other, PurePath):
<span class="w"> </span>                return super().__eq__(other)
<span class="w"> </span>            if isinstance(other, str):
<span class="gu">@@ -100,13 +120,13 @@ else:</span>
<span class="w"> </span>                return self.__str__() == other
<span class="w"> </span>            return NotImplemented

<span class="gd">-        def __hash__(self) -&gt;int:</span>
<span class="gi">+        def __hash__(self) -&gt; int:</span>
<span class="w"> </span>            return super().__hash__()

<span class="gd">-        def __getitem__(self, item: (int | slice)) -&gt;str:</span>
<span class="gi">+        def __getitem__(self, item: int | slice) -&gt; str:</span>
<span class="w"> </span>            warnings.warn(_MSG, RemovedInSphinx90Warning, stacklevel=2)
<span class="w"> </span>            return self.__str__()[item]

<span class="gd">-        def __len__(self) -&gt;int:</span>
<span class="gi">+        def __len__(self) -&gt; int:</span>
<span class="w"> </span>            warnings.warn(_MSG, RemovedInSphinx90Warning, stacklevel=2)
<span class="w"> </span>            return len(self.__str__())
<span class="gh">diff --git a/sphinx/util/_timestamps.py b/sphinx/util/_timestamps.py</span>
<span class="gh">index 9804211d8..32aca5232 100644</span>
<span class="gd">--- a/sphinx/util/_timestamps.py</span>
<span class="gi">+++ b/sphinx/util/_timestamps.py</span>
<span class="gu">@@ -1,10 +1,12 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import time


<span class="gd">-def _format_rfc3339_microseconds(timestamp: int, /) -&gt;str:</span>
<span class="gi">+def _format_rfc3339_microseconds(timestamp: int, /) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return an RFC 3339 formatted string representing the given timestamp.

<span class="w"> </span>    :param timestamp: The timestamp to format, in microseconds.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    seconds, fraction = divmod(timestamp, 10**6)</span>
<span class="gi">+    return time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;, time.gmtime(seconds)) + f&#39;.{fraction // 1_000}&#39;</span>
<span class="gh">diff --git a/sphinx/util/build_phase.py b/sphinx/util/build_phase.py</span>
<span class="gh">index 4148d592b..76e94a9b0 100644</span>
<span class="gd">--- a/sphinx/util/build_phase.py</span>
<span class="gi">+++ b/sphinx/util/build_phase.py</span>
<span class="gu">@@ -1,9 +1,11 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Build phase of Sphinx application.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from enum import IntEnum


<span class="w"> </span>class BuildPhase(IntEnum):
<span class="w"> </span>    &quot;&quot;&quot;Build phase of Sphinx application.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    INITIALIZATION = 1
<span class="w"> </span>    READING = 2
<span class="w"> </span>    CONSISTENCY_CHECK = 3
<span class="gh">diff --git a/sphinx/util/cfamily.py b/sphinx/util/cfamily.py</span>
<span class="gh">index 93e955260..6c85f8aad 100644</span>
<span class="gd">--- a/sphinx/util/cfamily.py</span>
<span class="gi">+++ b/sphinx/util/cfamily.py</span>
<span class="gu">@@ -1,86 +1,94 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Utility functions common to the C and C++ domains.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from copy import deepcopy
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.util import logging
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Callable, Sequence
<span class="w"> </span>    from typing import Any, TypeAlias
<span class="gi">+</span>
<span class="w"> </span>    from docutils.nodes import TextElement
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.config import Config
<span class="gi">+</span>
<span class="w"> </span>    StringifyTransform: TypeAlias = Callable[[Any], str]
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gd">-_whitespace_re = re.compile(&#39;\\s+&#39;)</span>
<span class="gd">-anon_identifier_re = re.compile(&#39;(@[a-zA-Z0-9_])[a-zA-Z0-9_]*\\b&#39;)</span>
<span class="gd">-identifier_re = re.compile(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+_whitespace_re = re.compile(r&#39;\s+&#39;)</span>
<span class="gi">+anon_identifier_re = re.compile(r&#39;(@[a-zA-Z0-9_])[a-zA-Z0-9_]*\b&#39;)</span>
<span class="gi">+identifier_re = re.compile(r&#39;&#39;&#39;</span>
<span class="w"> </span>    (   # This &#39;extends&#39; _anon_identifier_re with the ordinary identifiers,
<span class="w"> </span>        # make sure they are in sync.
<span class="gd">-        (~?\\b[a-zA-Z_])  # ordinary identifiers</span>
<span class="gi">+        (~?\b[a-zA-Z_])  # ordinary identifiers</span>
<span class="w"> </span>    |   (@[a-zA-Z0-9_])  # our extension for names of anonymous entities
<span class="w"> </span>    )
<span class="gd">-    [a-zA-Z0-9_]*\\b</span>
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    , flags=re.VERBOSE)</span>
<span class="gd">-integer_literal_re = re.compile(&quot;[1-9][0-9]*(\\&#39;[0-9]+)*&quot;)</span>
<span class="gd">-octal_literal_re = re.compile(&quot;0[0-7]*(\\&#39;[0-7]+)*&quot;)</span>
<span class="gd">-hex_literal_re = re.compile(&quot;0[xX][0-9a-fA-F]+(\\&#39;[0-9a-fA-F]+)*&quot;)</span>
<span class="gd">-binary_literal_re = re.compile(&quot;0[bB][01]+(\\&#39;[01]+)*&quot;)</span>
<span class="gd">-integers_literal_suffix_re = re.compile(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    [a-zA-Z0-9_]*\b</span>
<span class="gi">+&#39;&#39;&#39;, flags=re.VERBOSE)</span>
<span class="gi">+integer_literal_re = re.compile(r&#39;[1-9][0-9]*(\&#39;[0-9]+)*&#39;)</span>
<span class="gi">+octal_literal_re = re.compile(r&#39;0[0-7]*(\&#39;[0-7]+)*&#39;)</span>
<span class="gi">+hex_literal_re = re.compile(r&#39;0[xX][0-9a-fA-F]+(\&#39;[0-9a-fA-F]+)*&#39;)</span>
<span class="gi">+binary_literal_re = re.compile(r&#39;0[bB][01]+(\&#39;[01]+)*&#39;)</span>
<span class="gi">+integers_literal_suffix_re = re.compile(r&#39;&#39;&#39;</span>
<span class="w"> </span>    # unsigned and/or (long) long, in any order, but at least one of them
<span class="w"> </span>    (
<span class="w"> </span>        ([uU]    ([lL]  |  (ll)  |  (LL))?)
<span class="w"> </span>        |
<span class="w"> </span>        (([lL]  |  (ll)  |  (LL))    [uU]?)
<span class="gd">-    )\\b</span>
<span class="gi">+    )\b</span>
<span class="w"> </span>    # the ending word boundary is important for distinguishing
<span class="w"> </span>    # between suffixes and UDLs in C++
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    , flags=re.VERBOSE)</span>
<span class="gd">-float_literal_re = re.compile(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+&#39;&#39;&#39;, flags=re.VERBOSE)</span>
<span class="gi">+float_literal_re = re.compile(r&#39;&#39;&#39;</span>
<span class="w"> </span>    [+-]?(
<span class="w"> </span>    # decimal
<span class="gd">-      ([0-9]+(\\&#39;[0-9]+)*[eE][+-]?[0-9]+(\\&#39;[0-9]+)*)</span>
<span class="gd">-    | (([0-9]+(\\&#39;[0-9]+)*)?\\.[0-9]+(\\&#39;[0-9]+)*([eE][+-]?[0-9]+(\\&#39;[0-9]+)*)?)</span>
<span class="gd">-    | ([0-9]+(\\&#39;[0-9]+)*\\.([eE][+-]?[0-9]+(\\&#39;[0-9]+)*)?)</span>
<span class="gi">+      ([0-9]+(\&#39;[0-9]+)*[eE][+-]?[0-9]+(\&#39;[0-9]+)*)</span>
<span class="gi">+    | (([0-9]+(\&#39;[0-9]+)*)?\.[0-9]+(\&#39;[0-9]+)*([eE][+-]?[0-9]+(\&#39;[0-9]+)*)?)</span>
<span class="gi">+    | ([0-9]+(\&#39;[0-9]+)*\.([eE][+-]?[0-9]+(\&#39;[0-9]+)*)?)</span>
<span class="w"> </span>    # hex
<span class="gd">-    | (0[xX][0-9a-fA-F]+(\\&#39;[0-9a-fA-F]+)*[pP][+-]?[0-9a-fA-F]+(\\&#39;[0-9a-fA-F]+)*)</span>
<span class="gd">-    | (0[xX]([0-9a-fA-F]+(\\&#39;[0-9a-fA-F]+)*)?\\.</span>
<span class="gd">-        [0-9a-fA-F]+(\\&#39;[0-9a-fA-F]+)*([pP][+-]?[0-9a-fA-F]+(\\&#39;[0-9a-fA-F]+)*)?)</span>
<span class="gd">-    | (0[xX][0-9a-fA-F]+(\\&#39;[0-9a-fA-F]+)*\\.([pP][+-]?[0-9a-fA-F]+(\\&#39;[0-9a-fA-F]+)*)?)</span>
<span class="gi">+    | (0[xX][0-9a-fA-F]+(\&#39;[0-9a-fA-F]+)*[pP][+-]?[0-9a-fA-F]+(\&#39;[0-9a-fA-F]+)*)</span>
<span class="gi">+    | (0[xX]([0-9a-fA-F]+(\&#39;[0-9a-fA-F]+)*)?\.</span>
<span class="gi">+        [0-9a-fA-F]+(\&#39;[0-9a-fA-F]+)*([pP][+-]?[0-9a-fA-F]+(\&#39;[0-9a-fA-F]+)*)?)</span>
<span class="gi">+    | (0[xX][0-9a-fA-F]+(\&#39;[0-9a-fA-F]+)*\.([pP][+-]?[0-9a-fA-F]+(\&#39;[0-9a-fA-F]+)*)?)</span>
<span class="w"> </span>    )
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    , flags=re.VERBOSE)</span>
<span class="gd">-float_literal_suffix_re = re.compile(&#39;[fFlL]\\b&#39;)</span>
<span class="gd">-char_literal_re = re.compile(</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+&#39;&#39;&#39;, flags=re.VERBOSE)</span>
<span class="gi">+float_literal_suffix_re = re.compile(r&#39;[fFlL]\b&#39;)</span>
<span class="gi">+# the ending word boundary is important for distinguishing between suffixes and UDLs in C++</span>
<span class="gi">+char_literal_re = re.compile(r&#39;&#39;&#39;</span>
<span class="w"> </span>    ((?:u8)|u|U|L)?
<span class="w"> </span>    &#39;(
<span class="gd">-      (?:[^\\\\&#39;])</span>
<span class="gd">-    | (\\\\(</span>
<span class="gd">-        (?:[&#39;&quot;?\\\\abfnrtv])</span>
<span class="gi">+      (?:[^\\&#39;])</span>
<span class="gi">+    | (\\(</span>
<span class="gi">+        (?:[&#39;&quot;?\\abfnrtv])</span>
<span class="w"> </span>      | (?:[0-7]{1,3})
<span class="w"> </span>      | (?:x[0-9a-fA-F]{2})
<span class="w"> </span>      | (?:u[0-9a-fA-F]{4})
<span class="w"> </span>      | (?:U[0-9a-fA-F]{8})
<span class="w"> </span>      ))
<span class="w"> </span>    )&#39;
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gd">-    , flags=re.VERBOSE)</span>
<span class="gi">+&#39;&#39;&#39;, flags=re.VERBOSE)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def verify_description_mode(mode: str) -&gt; None:</span>
<span class="gi">+    if mode not in (&#39;lastIsName&#39;, &#39;noneIsName&#39;, &#39;markType&#39;, &#39;markName&#39;, &#39;param&#39;, &#39;udl&#39;):</span>
<span class="gi">+        raise Exception(&quot;Description mode &#39;%s&#39; is invalid.&quot; % mode)</span>


<span class="w"> </span>class NoOldIdError(Exception):
<span class="gi">+    # Used to avoid implementing unneeded id generation for old id schemes.</span>
<span class="w"> </span>    pass


<span class="w"> </span>class ASTBaseBase:
<span class="gd">-</span>
<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if type(self) is not type(other):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        try:
<span class="gu">@@ -88,115 +96,174 @@ class ASTBaseBase:</span>
<span class="w"> </span>        except AttributeError:
<span class="w"> </span>            return False

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def clone(self) -&gt; Any:</span>
<span class="gi">+        return deepcopy(self)</span>
<span class="gi">+</span>
<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>
<span class="gi">+</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        return self._stringify(str)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def get_display_string(self) -&gt; str:</span>
<span class="gi">+        return self._stringify(lambda ast: ast.get_display_string())</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return f&#39;&lt;{self.__class__.__name__}: {self._stringify(repr)}&gt;&#39;


<span class="gi">+################################################################################</span>
<span class="gi">+# Attributes</span>
<span class="gi">+################################################################################</span>
<span class="gi">+</span>
<span class="w"> </span>class ASTAttribute(ASTBaseBase):
<span class="gd">-    pass</span>
<span class="gi">+    def describe_signature(self, signode: TextElement) -&gt; None:</span>
<span class="gi">+        raise NotImplementedError(repr(self))</span>


<span class="w"> </span>class ASTCPPAttribute(ASTAttribute):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, arg: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, arg: str) -&gt; None:</span>
<span class="w"> </span>        self.arg = arg

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTCPPAttribute):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.arg == other.arg

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.arg)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return f&quot;[[{self.arg}]]&quot;</span>

<span class="gd">-class ASTGnuAttribute(ASTBaseBase):</span>
<span class="gi">+    def describe_signature(self, signode: TextElement) -&gt; None:</span>
<span class="gi">+        signode.append(addnodes.desc_sig_punctuation(&#39;[[&#39;, &#39;[[&#39;))</span>
<span class="gi">+        signode.append(nodes.Text(self.arg))</span>
<span class="gi">+        signode.append(addnodes.desc_sig_punctuation(&#39;]]&#39;, &#39;]]&#39;))</span>

<span class="gd">-    def __init__(self, name: str, args: (ASTBaseParenExprList | None)) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+class ASTGnuAttribute(ASTBaseBase):</span>
<span class="gi">+    def __init__(self, name: str, args: ASTBaseParenExprList | None) -&gt; None:</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.args = args

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTGnuAttribute):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.name == other.name and self.args == other.args

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.name, self.args))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        if self.args:</span>
<span class="gi">+            return self.name + transform(self.args)</span>
<span class="gi">+        return self.name</span>

<span class="gd">-class ASTGnuAttributeList(ASTAttribute):</span>

<span class="gd">-    def __init__(self, attrs: list[ASTGnuAttribute]) -&gt;None:</span>
<span class="gi">+class ASTGnuAttributeList(ASTAttribute):</span>
<span class="gi">+    def __init__(self, attrs: list[ASTGnuAttribute]) -&gt; None:</span>
<span class="w"> </span>        self.attrs = attrs

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTGnuAttributeList):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.attrs == other.attrs

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.attrs)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        attrs = &#39;, &#39;.join(map(transform, self.attrs))</span>
<span class="gi">+        return f&#39;__attribute__(({attrs}))&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement) -&gt; None:</span>
<span class="gi">+        signode.append(nodes.Text(str(self)))</span>
<span class="gi">+</span>

<span class="w"> </span>class ASTIdAttribute(ASTAttribute):
<span class="w"> </span>    &quot;&quot;&quot;For simple attributes defined by the user.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, id: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, id: str) -&gt; None:</span>
<span class="w"> </span>        self.id = id

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTIdAttribute):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.id == other.id

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.id)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return self.id</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement) -&gt; None:</span>
<span class="gi">+        signode.append(nodes.Text(self.id))</span>
<span class="gi">+</span>

<span class="w"> </span>class ASTParenAttribute(ASTAttribute):
<span class="w"> </span>    &quot;&quot;&quot;For paren attributes defined by the user.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, id: str, arg: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, id: str, arg: str) -&gt; None:</span>
<span class="w"> </span>        self.id = id
<span class="w"> </span>        self.arg = arg

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTParenAttribute):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.id == other.id and self.arg == other.arg

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.id, self.arg))

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return f&#39;{self.id}({self.arg})&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement) -&gt; None:</span>
<span class="gi">+        signode.append(nodes.Text(str(self)))</span>

<span class="gd">-class ASTAttributeList(ASTBaseBase):</span>

<span class="gd">-    def __init__(self, attrs: list[ASTAttribute]) -&gt;None:</span>
<span class="gi">+class ASTAttributeList(ASTBaseBase):</span>
<span class="gi">+    def __init__(self, attrs: list[ASTAttribute]) -&gt; None:</span>
<span class="w"> </span>        self.attrs = attrs

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        if not isinstance(other, ASTAttributeList):
<span class="w"> </span>            return NotImplemented
<span class="w"> </span>        return self.attrs == other.attrs

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.attrs)

<span class="gd">-    def __len__(self) -&gt;int:</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="w"> </span>        return len(self.attrs)

<span class="gd">-    def __add__(self, other: ASTAttributeList) -&gt;ASTAttributeList:</span>
<span class="gi">+    def __add__(self, other: ASTAttributeList) -&gt; ASTAttributeList:</span>
<span class="w"> </span>        return ASTAttributeList(self.attrs + other.attrs)

<span class="gi">+    def _stringify(self, transform: StringifyTransform) -&gt; str:</span>
<span class="gi">+        return &#39; &#39;.join(map(transform, self.attrs))</span>
<span class="gi">+</span>
<span class="gi">+    def describe_signature(self, signode: TextElement) -&gt; None:</span>
<span class="gi">+        if len(self.attrs) == 0:</span>
<span class="gi">+            return</span>
<span class="gi">+        self.attrs[0].describe_signature(signode)</span>
<span class="gi">+        if len(self.attrs) == 1:</span>
<span class="gi">+            return</span>
<span class="gi">+        for attr in self.attrs[1:]:</span>
<span class="gi">+            signode.append(addnodes.desc_sig_space())</span>
<span class="gi">+            attr.describe_signature(signode)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+################################################################################</span>

<span class="w"> </span>class ASTBaseParenExprList(ASTBaseBase):
<span class="w"> </span>    pass


<span class="gi">+################################################################################</span>
<span class="gi">+</span>
<span class="w"> </span>class UnsupportedMultiCharacterCharLiteral(Exception):
<span class="w"> </span>    pass

<span class="gu">@@ -206,15 +273,222 @@ class DefinitionError(Exception):</span>


<span class="w"> </span>class BaseParser:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, definition: str, *, location: (nodes.Node | tuple[</span>
<span class="gd">-        str, int] | str), config: Config) -&gt;None:</span>
<span class="gi">+    def __init__(self, definition: str, *,</span>
<span class="gi">+                 location: nodes.Node | tuple[str, int] | str,</span>
<span class="gi">+                 config: Config) -&gt; None:</span>
<span class="w"> </span>        self.definition = definition.strip()
<span class="gd">-        self.location = location</span>
<span class="gi">+        self.location = location  # for warnings</span>
<span class="w"> </span>        self.config = config
<span class="gi">+</span>
<span class="w"> </span>        self.pos = 0
<span class="w"> </span>        self.end = len(self.definition)
<span class="w"> </span>        self.last_match: re.Match[str] | None = None
<span class="w"> </span>        self._previous_state: tuple[int, re.Match[str] | None] = (0, None)
<span class="w"> </span>        self.otherErrors: list[DefinitionError] = []
<span class="gi">+</span>
<span class="gi">+        # in our tests the following is set to False to capture bad parsing</span>
<span class="w"> </span>        self.allowFallbackExpressionParsing = True
<span class="gi">+</span>
<span class="gi">+    def _make_multi_error(self, errors: list[Any], header: str) -&gt; DefinitionError:</span>
<span class="gi">+        if len(errors) == 1:</span>
<span class="gi">+            if len(header) &gt; 0:</span>
<span class="gi">+                return DefinitionError(header + &#39;\n&#39; + str(errors[0][0]))</span>
<span class="gi">+            else:</span>
<span class="gi">+                return DefinitionError(str(errors[0][0]))</span>
<span class="gi">+        result = [header, &#39;\n&#39;]</span>
<span class="gi">+        for e in errors:</span>
<span class="gi">+            if len(e[1]) &gt; 0:</span>
<span class="gi">+                indent = &#39;  &#39;</span>
<span class="gi">+                result.extend((e[1], &#39;:\n&#39;))</span>
<span class="gi">+                for line in str(e[0]).split(&#39;\n&#39;):</span>
<span class="gi">+                    if len(line) == 0:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    result.extend((indent, line, &#39;\n&#39;))</span>
<span class="gi">+            else:</span>
<span class="gi">+                result.append(str(e[0]))</span>
<span class="gi">+        return DefinitionError(&#39;&#39;.join(result))</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def language(self) -&gt; str:</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def status(self, msg: str) -&gt; None:</span>
<span class="gi">+        # for debugging</span>
<span class="gi">+        indicator = &#39;-&#39; * self.pos + &#39;^&#39;</span>
<span class="gi">+        logger.debug(f&quot;{msg}\n{self.definition}\n{indicator}&quot;)  # NoQA: G004</span>
<span class="gi">+</span>
<span class="gi">+    def fail(self, msg: str) -&gt; None:</span>
<span class="gi">+        errors = []</span>
<span class="gi">+        indicator = &#39;-&#39; * self.pos + &#39;^&#39;</span>
<span class="gi">+        exMain = DefinitionError(</span>
<span class="gi">+            &#39;Invalid %s declaration: %s [error at %d]\n  %s\n  %s&#39; %</span>
<span class="gi">+            (self.language, msg, self.pos, self.definition, indicator))</span>
<span class="gi">+        errors.append((exMain, &quot;Main error&quot;))</span>
<span class="gi">+        errors.extend((err, &quot;Potential other error&quot;) for err in self.otherErrors)</span>
<span class="gi">+        self.otherErrors = []</span>
<span class="gi">+        raise self._make_multi_error(errors, &#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def warn(self, msg: str) -&gt; None:</span>
<span class="gi">+        logger.warning(msg, location=self.location)</span>
<span class="gi">+</span>
<span class="gi">+    def match(self, regex: re.Pattern[str]) -&gt; bool:</span>
<span class="gi">+        match = regex.match(self.definition, self.pos)</span>
<span class="gi">+        if match is not None:</span>
<span class="gi">+            self._previous_state = (self.pos, self.last_match)</span>
<span class="gi">+            self.pos = match.end()</span>
<span class="gi">+            self.last_match = match</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def skip_string(self, string: str) -&gt; bool:</span>
<span class="gi">+        strlen = len(string)</span>
<span class="gi">+        if self.definition[self.pos:self.pos + strlen] == string:</span>
<span class="gi">+            self.pos += strlen</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def skip_word(self, word: str) -&gt; bool:</span>
<span class="gi">+        return self.match(re.compile(r&#39;\b%s\b&#39; % re.escape(word)))</span>
<span class="gi">+</span>
<span class="gi">+    def skip_ws(self) -&gt; bool:</span>
<span class="gi">+        return self.match(_whitespace_re)</span>
<span class="gi">+</span>
<span class="gi">+    def skip_word_and_ws(self, word: str) -&gt; bool:</span>
<span class="gi">+        if self.skip_word(word):</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def skip_string_and_ws(self, string: str) -&gt; bool:</span>
<span class="gi">+        if self.skip_string(string):</span>
<span class="gi">+            self.skip_ws()</span>
<span class="gi">+            return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def eof(self) -&gt; bool:</span>
<span class="gi">+        return self.pos &gt;= self.end</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def current_char(self) -&gt; str:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.definition[self.pos]</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            return &#39;EOF&#39;</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def matched_text(self) -&gt; str:</span>
<span class="gi">+        if self.last_match is not None:</span>
<span class="gi">+            return self.last_match.group()</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def read_rest(self) -&gt; str:</span>
<span class="gi">+        rv = self.definition[self.pos:]</span>
<span class="gi">+        self.pos = self.end</span>
<span class="gi">+        return rv</span>
<span class="gi">+</span>
<span class="gi">+    def assert_end(self, *, allowSemicolon: bool = False) -&gt; None:</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        if allowSemicolon:</span>
<span class="gi">+            if not self.eof and self.definition[self.pos:] != &#39;;&#39;:</span>
<span class="gi">+                self.fail(&#39;Expected end of definition or ;.&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if not self.eof:</span>
<span class="gi">+                self.fail(&#39;Expected end of definition.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    ################################################################################</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def id_attributes(self) -&gt; Sequence[str]:</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def paren_attributes(self) -&gt; Sequence[str]:</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_balanced_token_seq(self, end: list[str]) -&gt; str:</span>
<span class="gi">+        # TODO: add handling of string literals and similar</span>
<span class="gi">+        brackets = {&#39;(&#39;: &#39;)&#39;, &#39;[&#39;: &#39;]&#39;, &#39;{&#39;: &#39;}&#39;}</span>
<span class="gi">+        startPos = self.pos</span>
<span class="gi">+        symbols: list[str] = []</span>
<span class="gi">+        while not self.eof:</span>
<span class="gi">+            if len(symbols) == 0 and self.current_char in end:</span>
<span class="gi">+                break</span>
<span class="gi">+            if self.current_char in brackets:</span>
<span class="gi">+                symbols.append(brackets[self.current_char])</span>
<span class="gi">+            elif len(symbols) &gt; 0 and self.current_char == symbols[-1]:</span>
<span class="gi">+                symbols.pop()</span>
<span class="gi">+            elif self.current_char in &quot;)]}&quot;:</span>
<span class="gi">+                self.fail(&quot;Unexpected &#39;%s&#39; in balanced-token-seq.&quot; % self.current_char)</span>
<span class="gi">+            self.pos += 1</span>
<span class="gi">+        if self.eof:</span>
<span class="gi">+            self.fail(&quot;Could not find end of balanced-token-seq starting at %d.&quot;</span>
<span class="gi">+                      % startPos)</span>
<span class="gi">+        return self.definition[startPos:self.pos]</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_attribute(self) -&gt; ASTAttribute | None:</span>
<span class="gi">+        self.skip_ws()</span>
<span class="gi">+        # try C++11 style</span>
<span class="gi">+        startPos = self.pos</span>
<span class="gi">+        if self.skip_string_and_ws(&#39;[&#39;):</span>
<span class="gi">+            if not self.skip_string(&#39;[&#39;):</span>
<span class="gi">+                self.pos = startPos</span>
<span class="gi">+            else:</span>
<span class="gi">+                # TODO: actually implement the correct grammar</span>
<span class="gi">+                arg = self._parse_balanced_token_seq(end=[&#39;]&#39;])</span>
<span class="gi">+                if not self.skip_string_and_ws(&#39;]&#39;):</span>
<span class="gi">+                    self.fail(&quot;Expected &#39;]&#39; in end of attribute.&quot;)</span>
<span class="gi">+                if not self.skip_string_and_ws(&#39;]&#39;):</span>
<span class="gi">+                    self.fail(&quot;Expected &#39;]&#39; in end of attribute after [[...]&quot;)</span>
<span class="gi">+                return ASTCPPAttribute(arg)</span>
<span class="gi">+</span>
<span class="gi">+        # try GNU style</span>
<span class="gi">+        if self.skip_word_and_ws(&#39;__attribute__&#39;):</span>
<span class="gi">+            if not self.skip_string_and_ws(&#39;(&#39;):</span>
<span class="gi">+                self.fail(&quot;Expected &#39;(&#39; after &#39;__attribute__&#39;.&quot;)</span>
<span class="gi">+            if not self.skip_string_and_ws(&#39;(&#39;):</span>
<span class="gi">+                self.fail(&quot;Expected &#39;(&#39; after &#39;__attribute__(&#39;.&quot;)</span>
<span class="gi">+            attrs = []</span>
<span class="gi">+            while 1:</span>
<span class="gi">+                if self.match(identifier_re):</span>
<span class="gi">+                    name = self.matched_text</span>
<span class="gi">+                    exprs = self._parse_paren_expression_list()</span>
<span class="gi">+                    attrs.append(ASTGnuAttribute(name, exprs))</span>
<span class="gi">+                if self.skip_string_and_ws(&#39;,&#39;):</span>
<span class="gi">+                    continue</span>
<span class="gi">+                if self.skip_string_and_ws(&#39;)&#39;):</span>
<span class="gi">+                    break</span>
<span class="gi">+                self.fail(&quot;Expected identifier, &#39;)&#39;, or &#39;,&#39; in __attribute__.&quot;)</span>
<span class="gi">+            if not self.skip_string_and_ws(&#39;)&#39;):</span>
<span class="gi">+                self.fail(&quot;Expected &#39;)&#39; after &#39;__attribute__((...)&#39;&quot;)</span>
<span class="gi">+            return ASTGnuAttributeList(attrs)</span>
<span class="gi">+</span>
<span class="gi">+        # try the simple id attributes defined by the user</span>
<span class="gi">+        for id in self.id_attributes:</span>
<span class="gi">+            if self.skip_word_and_ws(id):</span>
<span class="gi">+                return ASTIdAttribute(id)</span>
<span class="gi">+</span>
<span class="gi">+        # try the paren attributes defined by the user</span>
<span class="gi">+        for id in self.paren_attributes:</span>
<span class="gi">+            if not self.skip_string_and_ws(id):</span>
<span class="gi">+                continue</span>
<span class="gi">+            if not self.skip_string(&#39;(&#39;):</span>
<span class="gi">+                self.fail(&quot;Expected &#39;(&#39; after user-defined paren-attribute.&quot;)</span>
<span class="gi">+            arg = self._parse_balanced_token_seq(end=[&#39;)&#39;])</span>
<span class="gi">+            if not self.skip_string(&#39;)&#39;):</span>
<span class="gi">+                self.fail(&quot;Expected &#39;)&#39; to end user-defined paren-attribute.&quot;)</span>
<span class="gi">+            return ASTParenAttribute(id, arg)</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_attribute_list(self) -&gt; ASTAttributeList:</span>
<span class="gi">+        res = []</span>
<span class="gi">+        while True:</span>
<span class="gi">+            attr = self._parse_attribute()</span>
<span class="gi">+            if attr is None:</span>
<span class="gi">+                break</span>
<span class="gi">+            res.append(attr)</span>
<span class="gi">+        return ASTAttributeList(res)</span>
<span class="gi">+</span>
<span class="gi">+    def _parse_paren_expression_list(self) -&gt; ASTBaseParenExprList | None:</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gh">diff --git a/sphinx/util/console.py b/sphinx/util/console.py</span>
<span class="gh">index 1da057880..2b24715ca 100644</span>
<span class="gd">--- a/sphinx/util/console.py</span>
<span class="gi">+++ b/sphinx/util/console.py</span>
<span class="gu">@@ -1,49 +1,140 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Format colored console output.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import re
<span class="w"> </span>import shutil
<span class="w"> </span>import sys
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from typing import Final
<span class="gi">+</span>
<span class="gi">+    # fmt: off</span>
<span class="gi">+    def reset(text: str) -&gt; str: ...  # NoQA: E704</span>
<span class="gi">+    def bold(text: str) -&gt; str: ...  # NoQA: E704</span>
<span class="gi">+    def faint(text: str) -&gt; str: ...  # NoQA: E704</span>
<span class="gi">+    def standout(text: str) -&gt; str: ...  # NoQA: E704</span>
<span class="gi">+    def underline(text: str) -&gt; str: ...  # NoQA: E704</span>
<span class="gi">+    def blink(text: str) -&gt; str: ...  # NoQA: E704</span>
<span class="gi">+</span>
<span class="gi">+    def black(text: str) -&gt; str: ...  # NoQA: E704</span>
<span class="gi">+    def white(text: str) -&gt; str: ...  # NoQA: E704</span>
<span class="gi">+    def red(text: str) -&gt; str: ...  # NoQA: E704</span>
<span class="gi">+    def green(text: str) -&gt; str: ...  # NoQA: E704</span>
<span class="gi">+    def yellow(text: str) -&gt; str: ...  # NoQA: E704</span>
<span class="gi">+    def blue(text: str) -&gt; str: ...  # NoQA: E704</span>
<span class="gi">+    def fuchsia(text: str) -&gt; str: ...  # NoQA: E704</span>
<span class="gi">+    def teal(text: str) -&gt; str: ...  # NoQA: E704</span>
<span class="gi">+</span>
<span class="gi">+    def darkgray(text: str) -&gt; str: ...  # NoQA: E704</span>
<span class="gi">+    def lightgray(text: str) -&gt; str: ...  # NoQA: E704</span>
<span class="gi">+    def darkred(text: str) -&gt; str: ...  # NoQA: E704</span>
<span class="gi">+    def darkgreen(text: str) -&gt; str: ...  # NoQA: E704</span>
<span class="gi">+    def brown(text: str) -&gt; str: ...  # NoQA: E704</span>
<span class="gi">+    def darkblue(text: str) -&gt; str: ...  # NoQA: E704</span>
<span class="gi">+    def purple(text: str) -&gt; str: ...  # NoQA: E704</span>
<span class="gi">+    def turquoise(text: str) -&gt; str: ...  # NoQA: E704</span>
<span class="gi">+    # fmt: on</span>
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="gi">+    # check if colorama is installed to support color on Windows</span>
<span class="w"> </span>    import colorama
<span class="w"> </span>    COLORAMA_AVAILABLE = True
<span class="w"> </span>except ImportError:
<span class="w"> </span>    COLORAMA_AVAILABLE = False
<span class="gd">-_CSI: Final[str] = re.escape(&#39;\x1b[&#39;)</span>
<span class="gd">-_ansi_color_re: Final[re.Pattern[str]] = re.compile(</span>
<span class="gd">-    &#39;\\x1b\\[(?:\\d+;){0,2}\\d*m&#39;)</span>
<span class="gd">-_ansi_re: Final[re.Pattern[str]] = re.compile(_CSI +</span>
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+_CSI: Final[str] = re.escape(&#39;\x1b[&#39;)  # &#39;ESC [&#39;: Control Sequence Introducer</span>
<span class="gi">+</span>
<span class="gi">+# Pattern matching ANSI control sequences containing colors.</span>
<span class="gi">+_ansi_color_re: Final[re.Pattern[str]] = re.compile(r&#39;\x1b\[(?:\d+;){0,2}\d*m&#39;)</span>
<span class="gi">+</span>
<span class="gi">+_ansi_re: Final[re.Pattern[str]] = re.compile(</span>
<span class="gi">+    _CSI</span>
<span class="gi">+    + r&quot;&quot;&quot;</span>
<span class="w"> </span>    (?:
<span class="gd">-      (?:\\d+;){0,2}\\d*m     # ANSI color code    (&#39;m&#39; is equivalent to &#39;0m&#39;)</span>
<span class="gi">+      (?:\d+;){0,2}\d*m     # ANSI color code    (&#39;m&#39; is equivalent to &#39;0m&#39;)</span>
<span class="w"> </span>    |
<span class="w"> </span>      [012]?K               # ANSI Erase in Line (&#39;K&#39; is equivalent to &#39;0K&#39;)
<span class="gd">-    )&quot;&quot;&quot;</span>
<span class="gd">-    , re.VERBOSE | re.ASCII)</span>
<span class="gi">+    )&quot;&quot;&quot;,</span>
<span class="gi">+    re.VERBOSE | re.ASCII,</span>
<span class="gi">+)</span>
<span class="w"> </span>&quot;&quot;&quot;Pattern matching ANSI CSI colors (SGR) and erase line (EL) sequences.

<span class="w"> </span>See :func:`strip_escape_sequences` for details.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>codes: dict[str, str] = {}


<span class="gd">-def terminal_safe(s: str) -&gt;str:</span>
<span class="gi">+def terminal_safe(s: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Safely encode a string for printing to the terminal.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return s.encode(&#39;ascii&#39;, &#39;backslashreplace&#39;).decode(&#39;ascii&#39;)</span>


<span class="gd">-def get_terminal_width() -&gt;int:</span>
<span class="gi">+def get_terminal_width() -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the width of the terminal in columns.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return shutil.get_terminal_size().columns - 1</span>


<span class="w"> </span>_tw: int = get_terminal_width()


<span class="gd">-def strip_colors(s: str) -&gt;str:</span>
<span class="gi">+def term_width_line(text: str) -&gt; str:</span>
<span class="gi">+    if not codes:</span>
<span class="gi">+        # if no coloring, don&#39;t output fancy backspaces</span>
<span class="gi">+        return text + &#39;\n&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        # codes are not displayed, this must be taken into account</span>
<span class="gi">+        return text.ljust(_tw + len(text) - len(strip_escape_sequences(text))) + &#39;\r&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def color_terminal() -&gt; bool:</span>
<span class="gi">+    if &#39;NO_COLOR&#39; in os.environ:</span>
<span class="gi">+        return False</span>
<span class="gi">+    if sys.platform == &#39;win32&#39; and COLORAMA_AVAILABLE:</span>
<span class="gi">+        colorama.just_fix_windows_console()</span>
<span class="gi">+        return True</span>
<span class="gi">+    if &#39;FORCE_COLOR&#39; in os.environ:</span>
<span class="gi">+        return True</span>
<span class="gi">+    if not hasattr(sys.stdout, &#39;isatty&#39;):</span>
<span class="gi">+        return False</span>
<span class="gi">+    if not sys.stdout.isatty():</span>
<span class="gi">+        return False</span>
<span class="gi">+    if &#39;COLORTERM&#39; in os.environ:</span>
<span class="gi">+        return True</span>
<span class="gi">+    term = os.environ.get(&#39;TERM&#39;, &#39;dumb&#39;).lower()</span>
<span class="gi">+    return term in (&#39;xterm&#39;, &#39;linux&#39;) or &#39;color&#39; in term</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def nocolor() -&gt; None:</span>
<span class="gi">+    if sys.platform == &#39;win32&#39; and COLORAMA_AVAILABLE:</span>
<span class="gi">+        colorama.deinit()</span>
<span class="gi">+    codes.clear()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def coloron() -&gt; None:</span>
<span class="gi">+    codes.update(_orig_codes)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def colorize(name: str, text: str, input_mode: bool = False) -&gt; str:</span>
<span class="gi">+    def escseq(name: str) -&gt; str:</span>
<span class="gi">+        # Wrap escape sequence with ``\1`` and ``\2`` to let readline know</span>
<span class="gi">+        # it is non-printable characters</span>
<span class="gi">+        # ref: https://tiswww.case.edu/php/chet/readline/readline.html</span>
<span class="gi">+        #</span>
<span class="gi">+        # Note: This hack does not work well in Windows (see #5059)</span>
<span class="gi">+        escape = codes.get(name, &#39;&#39;)</span>
<span class="gi">+        if input_mode and escape and sys.platform != &#39;win32&#39;:</span>
<span class="gi">+            return &#39;\1&#39; + escape + &#39;\2&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return escape</span>
<span class="gi">+</span>
<span class="gi">+    return escseq(name) + text + escseq(&#39;reset&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def strip_colors(s: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Remove the ANSI color codes in a string *s*.

<span class="w"> </span>    .. caution::
<span class="gu">@@ -53,15 +144,15 @@ def strip_colors(s: str) -&gt;str:</span>

<span class="w"> </span>    .. seealso:: :func:`strip_escape_sequences`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _ansi_color_re.sub(&#39;&#39;, s)</span>


<span class="gd">-def strip_escape_sequences(text: str, /) -&gt;str:</span>
<span class="gd">-    &quot;&quot;&quot;Remove the ANSI CSI colors and &quot;erase in line&quot; sequences.</span>
<span class="gi">+def strip_escape_sequences(text: str, /) -&gt; str:</span>
<span class="gi">+    r&quot;&quot;&quot;Remove the ANSI CSI colors and &quot;erase in line&quot; sequences.</span>

<span class="w"> </span>    Other `escape sequences `__ (e.g., VT100-specific functions) are not
<span class="w"> </span>    supported and only control sequences *natively* known to Sphinx (i.e.,
<span class="gd">-    colors declared in this module and &quot;erase entire line&quot; (``&#39;\\x1b[2K&#39;``))</span>
<span class="gi">+    colors declared in this module and &quot;erase entire line&quot; (``&#39;\x1b[2K&#39;``))</span>
<span class="w"> </span>    are eliminated by this function.

<span class="w"> </span>    .. caution::
<span class="gu">@@ -76,19 +167,44 @@ def strip_escape_sequences(text: str, /) -&gt;str:</span>

<span class="w"> </span>    __ https://en.wikipedia.org/wiki/ANSI_escape_code
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _ansi_re.sub(&#39;&#39;, text)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def create_color_func(name: str) -&gt; None:</span>
<span class="gi">+    def inner(text: str) -&gt; str:</span>
<span class="gi">+        return colorize(name, text)</span>
<span class="gi">+</span>
<span class="gi">+    globals()[name] = inner</span>
<span class="gi">+</span>

<span class="gi">+_attrs = {</span>
<span class="gi">+    &#39;reset&#39;: &#39;39;49;00m&#39;,</span>
<span class="gi">+    &#39;bold&#39;: &#39;01m&#39;,</span>
<span class="gi">+    &#39;faint&#39;: &#39;02m&#39;,</span>
<span class="gi">+    &#39;standout&#39;: &#39;03m&#39;,</span>
<span class="gi">+    &#39;underline&#39;: &#39;04m&#39;,</span>
<span class="gi">+    &#39;blink&#39;: &#39;05m&#39;,</span>
<span class="gi">+}</span>

<span class="gd">-_attrs = {&#39;reset&#39;: &#39;39;49;00m&#39;, &#39;bold&#39;: &#39;01m&#39;, &#39;faint&#39;: &#39;02m&#39;, &#39;standout&#39;:</span>
<span class="gd">-    &#39;03m&#39;, &#39;underline&#39;: &#39;04m&#39;, &#39;blink&#39;: &#39;05m&#39;}</span>
<span class="w"> </span>for __name, __value in _attrs.items():
<span class="w"> </span>    codes[__name] = &#39;\x1b[&#39; + __value
<span class="gd">-_colors = [(&#39;black&#39;, &#39;darkgray&#39;), (&#39;darkred&#39;, &#39;red&#39;), (&#39;darkgreen&#39;, &#39;green&#39;</span>
<span class="gd">-    ), (&#39;brown&#39;, &#39;yellow&#39;), (&#39;darkblue&#39;, &#39;blue&#39;), (&#39;purple&#39;, &#39;fuchsia&#39;), (</span>
<span class="gd">-    &#39;turquoise&#39;, &#39;teal&#39;), (&#39;lightgray&#39;, &#39;white&#39;)]</span>
<span class="gi">+</span>
<span class="gi">+_colors = [</span>
<span class="gi">+    (&#39;black&#39;, &#39;darkgray&#39;),</span>
<span class="gi">+    (&#39;darkred&#39;, &#39;red&#39;),</span>
<span class="gi">+    (&#39;darkgreen&#39;, &#39;green&#39;),</span>
<span class="gi">+    (&#39;brown&#39;, &#39;yellow&#39;),</span>
<span class="gi">+    (&#39;darkblue&#39;, &#39;blue&#39;),</span>
<span class="gi">+    (&#39;purple&#39;, &#39;fuchsia&#39;),</span>
<span class="gi">+    (&#39;turquoise&#39;, &#39;teal&#39;),</span>
<span class="gi">+    (&#39;lightgray&#39;, &#39;white&#39;),</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>for __i, (__dark, __light) in enumerate(_colors, 30):
<span class="w"> </span>    codes[__dark] = &#39;\x1b[%im&#39; % __i
<span class="w"> </span>    codes[__light] = &#39;\x1b[%im&#39; % (__i + 60)
<span class="gi">+</span>
<span class="w"> </span>_orig_codes = codes.copy()
<span class="gi">+</span>
<span class="w"> </span>for _name in codes:
<span class="w"> </span>    create_color_func(_name)
<span class="gh">diff --git a/sphinx/util/display.py b/sphinx/util/display.py</span>
<span class="gh">index cdbaa5a8c..f3aea633e 100644</span>
<span class="gd">--- a/sphinx/util/display.py</span>
<span class="gi">+++ b/sphinx/util/display.py</span>
<span class="gu">@@ -1,35 +1,84 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import functools
<span class="gi">+</span>
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.console import bold, color_terminal
<span class="gi">+</span>
<span class="w"> </span>if False:
<span class="w"> </span>    from collections.abc import Callable, Iterable, Iterator
<span class="w"> </span>    from types import TracebackType
<span class="w"> </span>    from typing import Any, TypeVar
<span class="gi">+</span>
<span class="w"> </span>    from typing_extensions import ParamSpec
<span class="gi">+</span>
<span class="w"> </span>    T = TypeVar(&#39;T&#39;)
<span class="w"> </span>    P = ParamSpec(&#39;P&#39;)
<span class="w"> </span>    R = TypeVar(&#39;R&#39;)
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="gi">+def display_chunk(chunk: Any) -&gt; str:</span>
<span class="gi">+    if isinstance(chunk, list | tuple):</span>
<span class="gi">+        if len(chunk) == 1:</span>
<span class="gi">+            return str(chunk[0])</span>
<span class="gi">+        return f&#39;{chunk[0]} .. {chunk[-1]}&#39;</span>
<span class="gi">+    return str(chunk)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def status_iterator(</span>
<span class="gi">+    iterable: Iterable[T],</span>
<span class="gi">+    summary: str,</span>
<span class="gi">+    color: str = &#39;darkgreen&#39;,</span>
<span class="gi">+    length: int = 0,</span>
<span class="gi">+    verbosity: int = 0,</span>
<span class="gi">+    stringify_func: Callable[[Any], str] = display_chunk,</span>
<span class="gi">+) -&gt; Iterator[T]:</span>
<span class="gi">+    # printing on a single line requires ANSI control sequences</span>
<span class="gi">+    single_line = verbosity &lt; 1 and color_terminal()</span>
<span class="gi">+    bold_summary = bold(summary)</span>
<span class="gi">+    if length == 0:</span>
<span class="gi">+        logger.info(bold_summary, nonl=True)</span>
<span class="gi">+        for item in iterable:</span>
<span class="gi">+            logger.info(stringify_func(item) + &#39; &#39;, nonl=True, color=color)</span>
<span class="gi">+            yield item</span>
<span class="gi">+    else:</span>
<span class="gi">+        for i, item in enumerate(iterable, start=1):</span>
<span class="gi">+            if single_line:</span>
<span class="gi">+                # clear the entire line (&#39;Erase in Line&#39;)</span>
<span class="gi">+                logger.info(&#39;\x1b[2K&#39;, nonl=True)</span>
<span class="gi">+            logger.info(f&#39;{bold_summary}[{i / length: &gt;4.0%}] &#39;, nonl=True)  # NoQA: G004</span>
<span class="gi">+            # Emit the string representation of ``item``</span>
<span class="gi">+            logger.info(stringify_func(item), nonl=True, color=color)</span>
<span class="gi">+            # If in single-line mode, emit a carriage return to move the cursor</span>
<span class="gi">+            # to the start of the line.</span>
<span class="gi">+            # If not, emit a newline to move the cursor to the next line.</span>
<span class="gi">+            logger.info(&#39;\r&#39; * single_line, nonl=single_line)</span>
<span class="gi">+            yield item</span>
<span class="gi">+    logger.info(&#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class SkipProgressMessage(Exception):
<span class="w"> </span>    pass


<span class="w"> </span>class progress_message:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, message: str, *, nonl: bool=True) -&gt;None:</span>
<span class="gi">+    def __init__(self, message: str, *, nonl: bool = True) -&gt; None:</span>
<span class="w"> </span>        self.message = message
<span class="w"> </span>        self.nonl = nonl

<span class="gd">-    def __enter__(self) -&gt;None:</span>
<span class="gi">+    def __enter__(self) -&gt; None:</span>
<span class="w"> </span>        logger.info(bold(self.message + &#39;... &#39;), nonl=self.nonl)

<span class="gd">-    def __exit__(self, typ: (type[BaseException] | None), val: (</span>
<span class="gd">-        BaseException | None), tb: (TracebackType | None)) -&gt;bool:</span>
<span class="gd">-        prefix = &#39;&#39; if self.nonl else bold(self.message + &#39;: &#39;)</span>
<span class="gi">+    def __exit__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        typ: type[BaseException] | None,</span>
<span class="gi">+        val: BaseException | None,</span>
<span class="gi">+        tb: TracebackType | None,</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="gi">+        prefix = &quot;&quot; if self.nonl else bold(self.message + &#39;: &#39;)</span>
<span class="w"> </span>        if isinstance(val, SkipProgressMessage):
<span class="w"> </span>            logger.info(prefix + __(&#39;skipped&#39;))
<span class="w"> </span>            if val.args:
<span class="gu">@@ -39,12 +88,13 @@ class progress_message:</span>
<span class="w"> </span>            logger.info(prefix + __(&#39;failed&#39;))
<span class="w"> </span>        else:
<span class="w"> </span>            logger.info(prefix + __(&#39;done&#39;))
<span class="gd">-        return False</span>

<span class="gd">-    def __call__(self, f: Callable[P, R]) -&gt;Callable[P, R]:</span>
<span class="gi">+        return False</span>

<span class="gi">+    def __call__(self, f: Callable[P, R]) -&gt; Callable[P, R]:</span>
<span class="w"> </span>        @functools.wraps(f)
<span class="gd">-        def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt;R:</span>
<span class="gi">+        def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:  # type: ignore[return]</span>
<span class="w"> </span>            with self:
<span class="w"> </span>                return f(*args, **kwargs)
<span class="gi">+</span>
<span class="w"> </span>        return wrapper
<span class="gh">diff --git a/sphinx/util/docfields.py b/sphinx/util/docfields.py</span>
<span class="gh">index 71ce35c34..0ef44d2fd 100644</span>
<span class="gd">--- a/sphinx/util/docfields.py</span>
<span class="gi">+++ b/sphinx/util/docfields.py</span>
<span class="gu">@@ -4,25 +4,37 @@</span>
<span class="w"> </span>be domain-specifically transformed to a more appealing presentation.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import contextlib
<span class="w"> </span>from typing import TYPE_CHECKING, Any, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.nodes import Element, Node
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.nodes import get_node_line
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.parsers.rst.states import Inliner
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.directives import ObjectDescription
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="w"> </span>    from sphinx.util.typing import TextlikeNode
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="gd">-def _is_single_paragraph(node: nodes.field_body) -&gt;bool:</span>
<span class="gi">+def _is_single_paragraph(node: nodes.field_body) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;True if the node only contains one paragraph (and system messages).&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(node) == 0:</span>
<span class="gi">+        return False</span>
<span class="gi">+    elif len(node) &gt; 1:</span>
<span class="gi">+        for subnode in node[1:]:  # type: Node</span>
<span class="gi">+            if not isinstance(subnode, nodes.system_message):</span>
<span class="gi">+                return False</span>
<span class="gi">+    return isinstance(node[0], nodes.paragraph)</span>


<span class="w"> </span>class Field:
<span class="gu">@@ -38,11 +50,19 @@ class Field:</span>
<span class="w"> </span>       :returns: description of the return value
<span class="w"> </span>       :rtype: description of the return type
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    is_grouped = False
<span class="w"> </span>    is_typed = False

<span class="gd">-    def __init__(self, name: str, names: tuple[str, ...]=(), label: str=&#39;&#39;,</span>
<span class="gd">-        has_arg: bool=True, rolename: str=&#39;&#39;, bodyrolename: str=&#39;&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        names: tuple[str, ...] = (),</span>
<span class="gi">+        label: str = &#39;&#39;,</span>
<span class="gi">+        has_arg: bool = True,</span>
<span class="gi">+        rolename: str = &#39;&#39;,</span>
<span class="gi">+        bodyrolename: str = &#39;&#39;,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.names = names
<span class="w"> </span>        self.label = label
<span class="gu">@@ -50,6 +70,73 @@ class Field:</span>
<span class="w"> </span>        self.rolename = rolename
<span class="w"> </span>        self.bodyrolename = bodyrolename

<span class="gi">+    def make_xref(self, rolename: str, domain: str, target: str,</span>
<span class="gi">+                  innernode: type[TextlikeNode] = addnodes.literal_emphasis,</span>
<span class="gi">+                  contnode: Node | None = None, env: BuildEnvironment | None = None,</span>
<span class="gi">+                  inliner: Inliner | None = None, location: Element | None = None) -&gt; Node:</span>
<span class="gi">+        # note: for backwards compatibility env is last, but not optional</span>
<span class="gi">+        assert env is not None</span>
<span class="gi">+        assert (inliner is None) == (location is None), (inliner, location)</span>
<span class="gi">+        if not rolename:</span>
<span class="gi">+            return contnode or innernode(target, target)  # type: ignore[call-arg]</span>
<span class="gi">+        # The domain is passed from DocFieldTransformer. So it surely exists.</span>
<span class="gi">+        # So we don&#39;t need to take care the env.get_domain() raises an exception.</span>
<span class="gi">+        role = env.get_domain(domain).role(rolename)</span>
<span class="gi">+        if role is None or inliner is None:</span>
<span class="gi">+            if role is None and inliner is not None:</span>
<span class="gi">+                msg = __(&quot;Problem in %s domain: field is supposed &quot;</span>
<span class="gi">+                         &quot;to use role &#39;%s&#39;, but that role is not in the domain.&quot;)</span>
<span class="gi">+                logger.warning(__(msg), domain, rolename, location=location)</span>
<span class="gi">+            refnode = addnodes.pending_xref(&#39;&#39;, refdomain=domain, refexplicit=False,</span>
<span class="gi">+                                            reftype=rolename, reftarget=target)</span>
<span class="gi">+            refnode += contnode or innernode(target, target)  # type: ignore[call-arg]</span>
<span class="gi">+            env.get_domain(domain).process_field_xref(refnode)</span>
<span class="gi">+            return refnode</span>
<span class="gi">+        lineno = -1</span>
<span class="gi">+        if location is not None:</span>
<span class="gi">+            with contextlib.suppress(ValueError):</span>
<span class="gi">+                lineno = get_node_line(location)</span>
<span class="gi">+        ns, messages = role(rolename, target, target, lineno, inliner, {}, [])</span>
<span class="gi">+        return nodes.inline(target, &#39;&#39;, *ns)</span>
<span class="gi">+</span>
<span class="gi">+    def make_xrefs(self, rolename: str, domain: str, target: str,</span>
<span class="gi">+                   innernode: type[TextlikeNode] = addnodes.literal_emphasis,</span>
<span class="gi">+                   contnode: Node | None = None, env: BuildEnvironment | None = None,</span>
<span class="gi">+                   inliner: Inliner | None = None, location: Element | None = None,</span>
<span class="gi">+                   ) -&gt; list[Node]:</span>
<span class="gi">+        return [self.make_xref(rolename, domain, target, innernode, contnode,</span>
<span class="gi">+                               env, inliner, location)]</span>
<span class="gi">+</span>
<span class="gi">+    def make_entry(self, fieldarg: str, content: list[Node]) -&gt; tuple[str, list[Node]]:</span>
<span class="gi">+        return (fieldarg, content)</span>
<span class="gi">+</span>
<span class="gi">+    def make_field(</span>
<span class="gi">+        self,</span>
<span class="gi">+        types: dict[str, list[Node]],</span>
<span class="gi">+        domain: str,</span>
<span class="gi">+        item: tuple,</span>
<span class="gi">+        env: BuildEnvironment | None = None,</span>
<span class="gi">+        inliner: Inliner | None = None,</span>
<span class="gi">+        location: Element | None = None,</span>
<span class="gi">+    ) -&gt; nodes.field:</span>
<span class="gi">+        fieldarg, content = item</span>
<span class="gi">+        fieldname = nodes.field_name(&#39;&#39;, self.label)</span>
<span class="gi">+        if fieldarg:</span>
<span class="gi">+            fieldname += nodes.Text(&#39; &#39;)</span>
<span class="gi">+            fieldname.extend(self.make_xrefs(self.rolename, domain,</span>
<span class="gi">+                                             fieldarg, nodes.Text,</span>
<span class="gi">+                                             env=env, inliner=inliner, location=location))</span>
<span class="gi">+</span>
<span class="gi">+        if len(content) == 1 and (</span>
<span class="gi">+                isinstance(content[0], nodes.Text) or</span>
<span class="gi">+                (isinstance(content[0], nodes.inline) and len(content[0]) == 1 and</span>
<span class="gi">+                 isinstance(content[0][0], nodes.Text))):</span>
<span class="gi">+            content = self.make_xrefs(self.bodyrolename, domain,</span>
<span class="gi">+                                      content[0].astext(), contnode=content[0],</span>
<span class="gi">+                                      env=env, inliner=inliner, location=location)</span>
<span class="gi">+        fieldbody = nodes.field_body(&#39;&#39;, nodes.paragraph(&#39;&#39;, &#39;&#39;, *content))</span>
<span class="gi">+        return nodes.field(&#39;&#39;, fieldname, fieldbody)</span>
<span class="gi">+</span>

<span class="w"> </span>class GroupedField(Field):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -64,14 +151,43 @@ class GroupedField(Field):</span>

<span class="w"> </span>       :raises ErrorClass: description when it is raised
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    is_grouped = True
<span class="w"> </span>    list_type = nodes.bullet_list

<span class="gd">-    def __init__(self, name: str, names: tuple[str, ...]=(), label: str=&#39;&#39;,</span>
<span class="gd">-        rolename: str=&#39;&#39;, can_collapse: bool=False) -&gt;None:</span>
<span class="gi">+    def __init__(self, name: str, names: tuple[str, ...] = (), label: str = &#39;&#39;,</span>
<span class="gi">+                 rolename: str = &#39;&#39;, can_collapse: bool = False) -&gt; None:</span>
<span class="w"> </span>        super().__init__(name, names, label, True, rolename)
<span class="w"> </span>        self.can_collapse = can_collapse

<span class="gi">+    def make_field(</span>
<span class="gi">+        self,</span>
<span class="gi">+        types: dict[str, list[Node]],</span>
<span class="gi">+        domain: str,</span>
<span class="gi">+        items: tuple,</span>
<span class="gi">+        env: BuildEnvironment | None = None,</span>
<span class="gi">+        inliner: Inliner | None = None,</span>
<span class="gi">+        location: Element | None = None,</span>
<span class="gi">+    ) -&gt; nodes.field:</span>
<span class="gi">+        fieldname = nodes.field_name(&#39;&#39;, self.label)</span>
<span class="gi">+        listnode = self.list_type()</span>
<span class="gi">+        for fieldarg, content in items:</span>
<span class="gi">+            par = nodes.paragraph()</span>
<span class="gi">+            par.extend(self.make_xrefs(self.rolename, domain, fieldarg,</span>
<span class="gi">+                                       addnodes.literal_strong,</span>
<span class="gi">+                                       env=env, inliner=inliner, location=location))</span>
<span class="gi">+            par += nodes.Text(&#39; -- &#39;)</span>
<span class="gi">+            par += content</span>
<span class="gi">+            listnode += nodes.list_item(&#39;&#39;, par)</span>
<span class="gi">+</span>
<span class="gi">+        if len(items) == 1 and self.can_collapse:</span>
<span class="gi">+            list_item = cast(nodes.list_item, listnode[0])</span>
<span class="gi">+            fieldbody = nodes.field_body(&#39;&#39;, list_item[0])</span>
<span class="gi">+            return nodes.field(&#39;&#39;, fieldname, fieldbody)</span>
<span class="gi">+</span>
<span class="gi">+        fieldbody = nodes.field_body(&#39;&#39;, listnode)</span>
<span class="gi">+        return nodes.field(&#39;&#39;, fieldname, fieldbody)</span>
<span class="gi">+</span>

<span class="w"> </span>class TypedField(GroupedField):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -92,31 +208,205 @@ class TypedField(GroupedField):</span>

<span class="w"> </span>       :param SomeClass foo: description of parameter foo
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    is_typed = True

<span class="gd">-    def __init__(self, name: str, names: tuple[str, ...]=(), typenames:</span>
<span class="gd">-        tuple[str, ...]=(), label: str=&#39;&#39;, rolename: str=&#39;&#39;, typerolename:</span>
<span class="gd">-        str=&#39;&#39;, can_collapse: bool=False) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        name: str,</span>
<span class="gi">+        names: tuple[str, ...] = (),</span>
<span class="gi">+        typenames: tuple[str, ...] = (),</span>
<span class="gi">+        label: str = &#39;&#39;,</span>
<span class="gi">+        rolename: str = &#39;&#39;,</span>
<span class="gi">+        typerolename: str = &#39;&#39;,</span>
<span class="gi">+        can_collapse: bool = False,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        super().__init__(name, names, label, rolename, can_collapse)
<span class="w"> </span>        self.typenames = typenames
<span class="w"> </span>        self.typerolename = typerolename

<span class="gi">+    def make_field(</span>
<span class="gi">+        self,</span>
<span class="gi">+        types: dict[str, list[Node]],</span>
<span class="gi">+        domain: str,</span>
<span class="gi">+        items: tuple,</span>
<span class="gi">+        env: BuildEnvironment | None = None,</span>
<span class="gi">+        inliner: Inliner | None = None,</span>
<span class="gi">+        location: Element | None = None,</span>
<span class="gi">+    ) -&gt; nodes.field:</span>
<span class="gi">+        def handle_item(fieldarg: str, content: list[Node]) -&gt; nodes.paragraph:</span>
<span class="gi">+            par = nodes.paragraph()</span>
<span class="gi">+            par.extend(self.make_xrefs(self.rolename, domain, fieldarg,</span>
<span class="gi">+                                       addnodes.literal_strong, env=env))</span>
<span class="gi">+            if fieldarg in types:</span>
<span class="gi">+                par += nodes.Text(&#39; (&#39;)</span>
<span class="gi">+                # NOTE: using .pop() here to prevent a single type node to be</span>
<span class="gi">+                # inserted twice into the doctree, which leads to</span>
<span class="gi">+                # inconsistencies later when references are resolved</span>
<span class="gi">+                fieldtype = types.pop(fieldarg)</span>
<span class="gi">+                if len(fieldtype) == 1 and isinstance(fieldtype[0], nodes.Text):</span>
<span class="gi">+                    typename = fieldtype[0].astext()</span>
<span class="gi">+                    par.extend(self.make_xrefs(self.typerolename, domain, typename,</span>
<span class="gi">+                                               addnodes.literal_emphasis, env=env,</span>
<span class="gi">+                                               inliner=inliner, location=location))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    par += fieldtype</span>
<span class="gi">+                par += nodes.Text(&#39;)&#39;)</span>
<span class="gi">+            has_content = any(c.astext().strip() for c in content)</span>
<span class="gi">+            if has_content:</span>
<span class="gi">+                par += nodes.Text(&#39; -- &#39;)</span>
<span class="gi">+                par += content</span>
<span class="gi">+            return par</span>
<span class="gi">+</span>
<span class="gi">+        fieldname = nodes.field_name(&#39;&#39;, self.label)</span>
<span class="gi">+        if len(items) == 1 and self.can_collapse:</span>
<span class="gi">+            fieldarg, content = items[0]</span>
<span class="gi">+            bodynode: Node = handle_item(fieldarg, content)</span>
<span class="gi">+        else:</span>
<span class="gi">+            bodynode = self.list_type()</span>
<span class="gi">+            for fieldarg, content in items:</span>
<span class="gi">+                bodynode += nodes.list_item(&#39;&#39;, handle_item(fieldarg, content))</span>
<span class="gi">+        fieldbody = nodes.field_body(&#39;&#39;, bodynode)</span>
<span class="gi">+        return nodes.field(&#39;&#39;, fieldname, fieldbody)</span>
<span class="gi">+</span>

<span class="w"> </span>class DocFieldTransformer:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Transforms field lists in &quot;doc field&quot; syntax into better-looking
<span class="w"> </span>    equivalents, using the field type definitions given on a domain.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    typemap: dict[str, tuple[Field, bool]]

<span class="gd">-    def __init__(self, directive: ObjectDescription) -&gt;None:</span>
<span class="gi">+    def __init__(self, directive: ObjectDescription) -&gt; None:</span>
<span class="w"> </span>        self.directive = directive
<span class="gi">+</span>
<span class="w"> </span>        self.typemap = directive.get_field_type_map()

<span class="gd">-    def transform_all(self, node: addnodes.desc_content) -&gt;None:</span>
<span class="gi">+    def transform_all(self, node: addnodes.desc_content) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Transform all field list children of a node.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # don&#39;t traverse, only handle field lists that are immediate children</span>
<span class="gi">+        for child in node:</span>
<span class="gi">+            if isinstance(child, nodes.field_list):</span>
<span class="gi">+                self.transform(child)</span>

<span class="gd">-    def transform(self, node: nodes.field_list) -&gt;None:</span>
<span class="gi">+    def transform(self, node: nodes.field_list) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Transform a single field list *node*.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        typemap = self.typemap</span>
<span class="gi">+</span>
<span class="gi">+        entries: list[nodes.field | tuple[Field, Any, Element]] = []</span>
<span class="gi">+        groupindices: dict[str, int] = {}</span>
<span class="gi">+        types: dict[str, dict] = {}</span>
<span class="gi">+</span>
<span class="gi">+        # step 1: traverse all fields and collect field types and content</span>
<span class="gi">+        for field in cast(list[nodes.field], node):</span>
<span class="gi">+            assert len(field) == 2</span>
<span class="gi">+            field_name = cast(nodes.field_name, field[0])</span>
<span class="gi">+            field_body = cast(nodes.field_body, field[1])</span>
<span class="gi">+            try:</span>
<span class="gi">+                # split into field type and argument</span>
<span class="gi">+                fieldtype_name, fieldarg = field_name.astext().split(None, 1)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                # maybe an argument-less field type?</span>
<span class="gi">+                fieldtype_name, fieldarg = field_name.astext(), &#39;&#39;</span>
<span class="gi">+            typedesc, is_typefield = typemap.get(fieldtype_name, (None, None))</span>
<span class="gi">+</span>
<span class="gi">+            # collect the content, trying not to keep unnecessary paragraphs</span>
<span class="gi">+            if _is_single_paragraph(field_body):</span>
<span class="gi">+                paragraph = cast(nodes.paragraph, field_body[0])</span>
<span class="gi">+                content = paragraph.children</span>
<span class="gi">+            else:</span>
<span class="gi">+                content = field_body.children</span>
<span class="gi">+</span>
<span class="gi">+            # sort out unknown fields</span>
<span class="gi">+            if typedesc is None or typedesc.has_arg != bool(fieldarg):</span>
<span class="gi">+                # either the field name is unknown, or the argument doesn&#39;t</span>
<span class="gi">+                # match the spec; capitalize field name and be done with it</span>
<span class="gi">+                new_fieldname = fieldtype_name[0:1].upper() + fieldtype_name[1:]</span>
<span class="gi">+                if fieldarg:</span>
<span class="gi">+                    new_fieldname += &#39; &#39; + fieldarg</span>
<span class="gi">+                field_name[0] = nodes.Text(new_fieldname)</span>
<span class="gi">+                entries.append(field)</span>
<span class="gi">+</span>
<span class="gi">+                # but if this has a type then we can at least link it</span>
<span class="gi">+                if (typedesc and is_typefield and content and</span>
<span class="gi">+                        len(content) == 1 and isinstance(content[0], nodes.Text)):</span>
<span class="gi">+                    typed_field = cast(TypedField, typedesc)</span>
<span class="gi">+                    target = content[0].astext()</span>
<span class="gi">+                    xrefs = typed_field.make_xrefs(</span>
<span class="gi">+                        typed_field.typerolename,</span>
<span class="gi">+                        self.directive.domain or &#39;&#39;,</span>
<span class="gi">+                        target,</span>
<span class="gi">+                        contnode=content[0],</span>
<span class="gi">+                        env=self.directive.state.document.settings.env,</span>
<span class="gi">+                    )</span>
<span class="gi">+                    if _is_single_paragraph(field_body):</span>
<span class="gi">+                        paragraph = cast(nodes.paragraph, field_body[0])</span>
<span class="gi">+                        paragraph.clear()</span>
<span class="gi">+                        paragraph.extend(xrefs)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        field_body.clear()</span>
<span class="gi">+                        field_body += nodes.paragraph(&#39;&#39;, &#39;&#39;, *xrefs)</span>
<span class="gi">+</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            typename = typedesc.name</span>
<span class="gi">+</span>
<span class="gi">+            # if the field specifies a type, put it in the types collection</span>
<span class="gi">+            if is_typefield:</span>
<span class="gi">+                # filter out only inline nodes; others will result in invalid</span>
<span class="gi">+                # markup being written out</span>
<span class="gi">+                content = [n for n in content if isinstance(n, nodes.Inline | nodes.Text)]</span>
<span class="gi">+                if content:</span>
<span class="gi">+                    types.setdefault(typename, {})[fieldarg] = content</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            # also support syntax like ``:param type name:``</span>
<span class="gi">+            if typedesc.is_typed:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    argtype, argname = fieldarg.rsplit(None, 1)</span>
<span class="gi">+                except ValueError:</span>
<span class="gi">+                    pass</span>
<span class="gi">+                else:</span>
<span class="gi">+                    types.setdefault(typename, {})[argname] = \</span>
<span class="gi">+                        [nodes.Text(argtype)]</span>
<span class="gi">+                    fieldarg = argname</span>
<span class="gi">+</span>
<span class="gi">+            translatable_content = nodes.inline(field_body.rawsource,</span>
<span class="gi">+                                                translatable=True)</span>
<span class="gi">+            translatable_content.document = field_body.parent.document</span>
<span class="gi">+            translatable_content.source = field_body.parent.source</span>
<span class="gi">+            translatable_content.line = field_body.parent.line</span>
<span class="gi">+            translatable_content += content</span>
<span class="gi">+</span>
<span class="gi">+            # grouped entries need to be collected in one entry, while others</span>
<span class="gi">+            # get one entry per field</span>
<span class="gi">+            if typedesc.is_grouped:</span>
<span class="gi">+                if typename in groupindices:</span>
<span class="gi">+                    group = cast(tuple[Field, list, Node], entries[groupindices[typename]])</span>
<span class="gi">+                else:</span>
<span class="gi">+                    groupindices[typename] = len(entries)</span>
<span class="gi">+                    group = (typedesc, [], field)</span>
<span class="gi">+                    entries.append(group)</span>
<span class="gi">+                new_entry = typedesc.make_entry(fieldarg, [translatable_content])</span>
<span class="gi">+                group[1].append(new_entry)</span>
<span class="gi">+            else:</span>
<span class="gi">+                new_entry = typedesc.make_entry(fieldarg, [translatable_content])</span>
<span class="gi">+                entries.append((typedesc, new_entry, field))</span>
<span class="gi">+</span>
<span class="gi">+        # step 2: all entries are collected, construct the new field list</span>
<span class="gi">+        new_list = nodes.field_list()</span>
<span class="gi">+        for entry in entries:</span>
<span class="gi">+            if isinstance(entry, nodes.field):</span>
<span class="gi">+                # pass-through old field</span>
<span class="gi">+                new_list += entry</span>
<span class="gi">+            else:</span>
<span class="gi">+                fieldtype, items, location = entry</span>
<span class="gi">+                fieldtypes = types.get(fieldtype.name, {})</span>
<span class="gi">+                env = self.directive.state.document.settings.env</span>
<span class="gi">+                inliner = self.directive.state.inliner</span>
<span class="gi">+                domain = self.directive.domain or &#39;&#39;</span>
<span class="gi">+                new_list += fieldtype.make_field(fieldtypes, domain, items,</span>
<span class="gi">+                                                 env=env, inliner=inliner, location=location)</span>
<span class="gi">+</span>
<span class="gi">+        node.replace_self(new_list)</span>
<span class="gh">diff --git a/sphinx/util/docstrings.py b/sphinx/util/docstrings.py</span>
<span class="gh">index 8e3c68d14..6ccc5389b 100644</span>
<span class="gd">--- a/sphinx/util/docstrings.py</span>
<span class="gi">+++ b/sphinx/util/docstrings.py</span>
<span class="gu">@@ -1,17 +1,45 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Utilities for docstring processing.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="w"> </span>from docutils.parsers.rst.states import Body
<span class="gi">+</span>
<span class="w"> </span>field_list_item_re = re.compile(Body.patterns[&#39;field_marker&#39;])


<span class="gd">-def separate_metadata(s: (str | None)) -&gt;tuple[str | None, dict[str, str]]:</span>
<span class="gi">+def separate_metadata(s: str | None) -&gt; tuple[str | None, dict[str, str]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Separate docstring into metadata and others.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    in_other_element = False</span>
<span class="gi">+    metadata: dict[str, str] = {}</span>
<span class="gi">+    lines = []</span>
<span class="gi">+</span>
<span class="gi">+    if not s:</span>
<span class="gi">+        return s, metadata</span>
<span class="gi">+</span>
<span class="gi">+    for line in prepare_docstring(s):</span>
<span class="gi">+        if line.strip() == &#39;&#39;:</span>
<span class="gi">+            in_other_element = False</span>
<span class="gi">+            lines.append(line)</span>
<span class="gi">+        else:</span>
<span class="gi">+            matched = field_list_item_re.match(line)</span>
<span class="gi">+            if matched and not in_other_element:</span>
<span class="gi">+                field_name = matched.group()[1:].split(&#39;:&#39;, 1)[0]</span>
<span class="gi">+                if field_name.startswith(&#39;meta &#39;):</span>
<span class="gi">+                    name = field_name[5:].strip()</span>
<span class="gi">+                    metadata[name] = line[matched.end():].strip()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    lines.append(line)</span>
<span class="gi">+            else:</span>
<span class="gi">+                in_other_element = True</span>
<span class="gi">+                lines.append(line)</span>
<span class="gi">+</span>
<span class="gi">+    return &#39;\n&#39;.join(lines), metadata</span>


<span class="gd">-def prepare_docstring(s: str, tabsize: int=8) -&gt;list[str]:</span>
<span class="gi">+def prepare_docstring(s: str, tabsize: int = 8) -&gt; list[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a docstring into lines of parseable reST.  Remove common leading
<span class="w"> </span>    indentation, where the indentation of the first line is ignored.

<span class="gu">@@ -19,11 +47,42 @@ def prepare_docstring(s: str, tabsize: int=8) -&gt;list[str]:</span>
<span class="w"> </span>    ViewList (used as argument of nested_parse().)  An empty line is added to
<span class="w"> </span>    act as a separator between this docstring and following content.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    lines = s.expandtabs(tabsize).splitlines()</span>
<span class="gi">+    # Find minimum indentation of any non-blank lines after ignored lines.</span>
<span class="gi">+    margin = sys.maxsize</span>
<span class="gi">+    for line in lines[1:]:</span>
<span class="gi">+        content = len(line.lstrip())</span>
<span class="gi">+        if content:</span>
<span class="gi">+            indent = len(line) - content</span>
<span class="gi">+            margin = min(margin, indent)</span>
<span class="gi">+    # Remove indentation from the first line.</span>
<span class="gi">+    if len(lines):</span>
<span class="gi">+        lines[0] = lines[0].lstrip()</span>
<span class="gi">+    if margin &lt; sys.maxsize:</span>
<span class="gi">+        for i in range(1, len(lines)):</span>
<span class="gi">+            lines[i] = lines[i][margin:]</span>
<span class="gi">+    # Remove any leading blank lines.</span>
<span class="gi">+    while lines and not lines[0]:</span>
<span class="gi">+        lines.pop(0)</span>
<span class="gi">+    # make sure there is an empty line at the end</span>
<span class="gi">+    if lines and lines[-1]:</span>
<span class="gi">+        lines.append(&#39;&#39;)</span>
<span class="gi">+    return lines</span>


<span class="gd">-def prepare_commentdoc(s: str) -&gt;list[str]:</span>
<span class="gi">+def prepare_commentdoc(s: str) -&gt; list[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Extract documentation comment lines (starting with #:) and return them
<span class="w"> </span>    as a list of lines.  Returns an empty list if there is no documentation.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = []</span>
<span class="gi">+    lines = [line.strip() for line in s.expandtabs().splitlines()]</span>
<span class="gi">+    for line in lines:</span>
<span class="gi">+        if line.startswith(&#39;#:&#39;):</span>
<span class="gi">+            line = line[2:]</span>
<span class="gi">+            # the first space after the comment is ignored</span>
<span class="gi">+            if line and line[0] == &#39; &#39;:</span>
<span class="gi">+                line = line[1:]</span>
<span class="gi">+            result.append(line)</span>
<span class="gi">+    if result and result[-1]:</span>
<span class="gi">+        result.append(&#39;&#39;)</span>
<span class="gi">+    return result</span>
<span class="gh">diff --git a/sphinx/util/docutils.py b/sphinx/util/docutils.py</span>
<span class="gh">index d4889e254..269f3794a 100644</span>
<span class="gd">--- a/sphinx/util/docutils.py</span>
<span class="gi">+++ b/sphinx/util/docutils.py</span>
<span class="gu">@@ -1,111 +1,147 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Utility functions for docutils.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import re
<span class="gd">-from collections.abc import Sequence</span>
<span class="gi">+from collections.abc import Sequence  # NoQA: TCH003</span>
<span class="w"> </span>from contextlib import contextmanager
<span class="w"> </span>from copy import copy
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import IO, TYPE_CHECKING, Any, cast
<span class="gi">+</span>
<span class="w"> </span>import docutils
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.io import FileOutput
<span class="w"> </span>from docutils.parsers.rst import Directive, directives, roles
<span class="gd">-from docutils.parsers.rst.states import Inliner</span>
<span class="gi">+from docutils.parsers.rst.states import Inliner  # NoQA: TCH002</span>
<span class="w"> </span>from docutils.statemachine import State, StateMachine, StringList
<span class="w"> </span>from docutils.utils import Reporter, unescape
<span class="gi">+</span>
<span class="w"> </span>from sphinx.errors import SphinxError
<span class="w"> </span>from sphinx.locale import _, __
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.parsing import nested_parse_to_nodes
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gd">-report_re = re.compile(</span>
<span class="gd">-    &#39;^(.+?:(?:\\d+)?): \\((DEBUG|INFO|WARNING|ERROR|SEVERE)/(\\d+)?\\) &#39;)</span>
<span class="gi">+report_re = re.compile(&#39;^(.+?:(?:\\d+)?): \\((DEBUG|INFO|WARNING|ERROR|SEVERE)/(\\d+)?\\) &#39;)</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="gd">-    from collections.abc import Callable, Iterator</span>
<span class="gi">+    from collections.abc import Callable, Iterator  # NoQA: TCH003</span>
<span class="w"> </span>    from types import ModuleType
<span class="gi">+</span>
<span class="w"> </span>    from docutils.frontend import Values
<span class="w"> </span>    from docutils.nodes import Element, Node, system_message
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.builders import Builder
<span class="w"> </span>    from sphinx.config import Config
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="w"> </span>    from sphinx.util.typing import RoleFunction
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>additional_nodes: set[type[Element]] = set()


<span class="w"> </span>@contextmanager
<span class="gd">-def docutils_namespace() -&gt;Iterator[None]:</span>
<span class="gi">+def docutils_namespace() -&gt; Iterator[None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create namespace for reST parsers.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        _directives = copy(directives._directives)  # type: ignore[attr-defined]</span>
<span class="gi">+        _roles = copy(roles._roles)  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        directives._directives = _directives  # type: ignore[attr-defined]</span>
<span class="gi">+        roles._roles = _roles  # type: ignore[attr-defined]</span>

<span class="gi">+        for node in list(additional_nodes):</span>
<span class="gi">+            unregister_node(node)</span>
<span class="gi">+            additional_nodes.discard(node)</span>

<span class="gd">-def is_directive_registered(name: str) -&gt;bool:</span>
<span class="gi">+</span>
<span class="gi">+def is_directive_registered(name: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check the *name* directive is already registered.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return name in directives._directives  # type: ignore[attr-defined]</span>


<span class="gd">-def register_directive(name: str, directive: type[Directive]) -&gt;None:</span>
<span class="gi">+def register_directive(name: str, directive: type[Directive]) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Register a directive to docutils.

<span class="w"> </span>    This modifies global state of docutils.  So it is better to use this
<span class="w"> </span>    inside ``docutils_namespace()`` to prevent side-effects.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    directives.register_directive(name, directive)</span>


<span class="gd">-def is_role_registered(name: str) -&gt;bool:</span>
<span class="gi">+def is_role_registered(name: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check the *name* role is already registered.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return name in roles._roles  # type: ignore[attr-defined]</span>


<span class="gd">-def register_role(name: str, role: RoleFunction) -&gt;None:</span>
<span class="gi">+def register_role(name: str, role: RoleFunction) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Register a role to docutils.

<span class="w"> </span>    This modifies global state of docutils.  So it is better to use this
<span class="w"> </span>    inside ``docutils_namespace()`` to prevent side-effects.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    roles.register_local_role(name, role)  # type: ignore[arg-type]</span>


<span class="gd">-def unregister_role(name: str) -&gt;None:</span>
<span class="gi">+def unregister_role(name: str) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Unregister a role from docutils.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    roles._roles.pop(name, None)  # type: ignore[attr-defined]</span>


<span class="gd">-def is_node_registered(node: type[Element]) -&gt;bool:</span>
<span class="gi">+def is_node_registered(node: type[Element]) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check the *node* is already registered.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return hasattr(nodes.GenericNodeVisitor, &#39;visit_&#39; + node.__name__)</span>


<span class="gd">-def register_node(node: type[Element]) -&gt;None:</span>
<span class="gi">+def register_node(node: type[Element]) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Register a node to docutils.

<span class="w"> </span>    This modifies global state of some visitors.  So it is better to use this
<span class="w"> </span>    inside ``docutils_namespace()`` to prevent side-effects.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not hasattr(nodes.GenericNodeVisitor, &#39;visit_&#39; + node.__name__):</span>
<span class="gi">+        nodes._add_node_class_names([node.__name__])  # type: ignore[attr-defined]</span>
<span class="gi">+        additional_nodes.add(node)</span>


<span class="gd">-def unregister_node(node: type[Element]) -&gt;None:</span>
<span class="gi">+def unregister_node(node: type[Element]) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Unregister a node from docutils.

<span class="w"> </span>    This is inverse of ``nodes._add_nodes_class_names()``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if hasattr(nodes.GenericNodeVisitor, &#39;visit_&#39; + node.__name__):</span>
<span class="gi">+        delattr(nodes.GenericNodeVisitor, &quot;visit_&quot; + node.__name__)</span>
<span class="gi">+        delattr(nodes.GenericNodeVisitor, &quot;depart_&quot; + node.__name__)</span>
<span class="gi">+        delattr(nodes.SparseNodeVisitor, &#39;visit_&#39; + node.__name__)</span>
<span class="gi">+        delattr(nodes.SparseNodeVisitor, &#39;depart_&#39; + node.__name__)</span>


<span class="w"> </span>@contextmanager
<span class="gd">-def patched_get_language() -&gt;Iterator[None]:</span>
<span class="gi">+def patched_get_language() -&gt; Iterator[None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Patch docutils.languages.get_language() temporarily.

<span class="w"> </span>    This ignores the second argument ``reporter`` to suppress warnings.
<span class="w"> </span>    refs: https://github.com/sphinx-doc/sphinx/issues/3788
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from docutils.languages import get_language</span>
<span class="gi">+</span>
<span class="gi">+    def patched_get_language(language_code: str, reporter: Reporter | None = None) -&gt; Any:</span>
<span class="gi">+        return get_language(language_code)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        docutils.languages.get_language = patched_get_language  # type: ignore[assignment]</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        # restore original implementations</span>
<span class="gi">+        docutils.languages.get_language = get_language</span>


<span class="w"> </span>@contextmanager
<span class="gd">-def patched_rst_get_language() -&gt;Iterator[None]:</span>
<span class="gi">+def patched_rst_get_language() -&gt; Iterator[None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Patch docutils.parsers.rst.languages.get_language().
<span class="w"> </span>    Starting from docutils 0.17, get_language() in ``rst.languages``
<span class="w"> </span>    also has a reporter, which needs to be disabled temporarily.
<span class="gu">@@ -115,19 +151,42 @@ def patched_rst_get_language() -&gt;Iterator[None]:</span>

<span class="w"> </span>    refs: https://github.com/sphinx-doc/sphinx/issues/10179
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from docutils.parsers.rst.languages import get_language</span>
<span class="gi">+</span>
<span class="gi">+    def patched_get_language(language_code: str, reporter: Reporter | None = None) -&gt; Any:</span>
<span class="gi">+        return get_language(language_code)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        docutils.parsers.rst.languages.get_language = patched_get_language  # type: ignore[assignment]</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        # restore original implementations</span>
<span class="gi">+        docutils.parsers.rst.languages.get_language = get_language</span>


<span class="w"> </span>@contextmanager
<span class="gd">-def using_user_docutils_conf(confdir: (str | None)) -&gt;Iterator[None]:</span>
<span class="gi">+def using_user_docutils_conf(confdir: str | None) -&gt; Iterator[None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Let docutils know the location of ``docutils.conf`` for Sphinx.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        docutilsconfig = os.environ.get(&#39;DOCUTILSCONFIG&#39;, None)</span>
<span class="gi">+        if confdir:</span>
<span class="gi">+            os.environ[&#39;DOCUTILSCONFIG&#39;] = path.join(path.abspath(confdir), &#39;docutils.conf&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        if docutilsconfig is None:</span>
<span class="gi">+            os.environ.pop(&#39;DOCUTILSCONFIG&#39;, None)</span>
<span class="gi">+        else:</span>
<span class="gi">+            os.environ[&#39;DOCUTILSCONFIG&#39;] = docutilsconfig</span>


<span class="w"> </span>@contextmanager
<span class="gd">-def patch_docutils(confdir: (str | None)=None) -&gt;Iterator[None]:</span>
<span class="gi">+def patch_docutils(confdir: str | None = None) -&gt; Iterator[None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Patch to docutils temporarily.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with patched_get_language(), \</span>
<span class="gi">+         patched_rst_get_language(), \</span>
<span class="gi">+         using_user_docutils_conf(confdir):</span>
<span class="gi">+        yield</span>


<span class="w"> </span>class CustomReSTDispatcher:
<span class="gu">@@ -137,17 +196,40 @@ class CustomReSTDispatcher:</span>
<span class="w"> </span>    by original one temporarily.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self.directive_func: Callable = lambda *args: (None, [])
<span class="w"> </span>        self.roles_func: Callable = lambda *args: (None, [])

<span class="gd">-    def __enter__(self) -&gt;None:</span>
<span class="gi">+    def __enter__(self) -&gt; None:</span>
<span class="w"> </span>        self.enable()

<span class="gd">-    def __exit__(self, exc_type: type[Exception], exc_value: Exception,</span>
<span class="gd">-        traceback: Any) -&gt;None:</span>
<span class="gi">+    def __exit__(</span>
<span class="gi">+        self, exc_type: type[Exception], exc_value: Exception, traceback: Any,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.disable()

<span class="gi">+    def enable(self) -&gt; None:</span>
<span class="gi">+        self.directive_func = directives.directive</span>
<span class="gi">+        self.role_func = roles.role</span>
<span class="gi">+</span>
<span class="gi">+        directives.directive = self.directive  # type: ignore[assignment]</span>
<span class="gi">+        roles.role = self.role  # type: ignore[assignment]</span>
<span class="gi">+</span>
<span class="gi">+    def disable(self) -&gt; None:</span>
<span class="gi">+        directives.directive = self.directive_func</span>
<span class="gi">+        roles.role = self.role_func</span>
<span class="gi">+</span>
<span class="gi">+    def directive(self,</span>
<span class="gi">+                  directive_name: str, language_module: ModuleType, document: nodes.document,</span>
<span class="gi">+                  ) -&gt; tuple[type[Directive] | None, list[system_message]]:</span>
<span class="gi">+        return self.directive_func(directive_name, language_module, document)</span>
<span class="gi">+</span>
<span class="gi">+    def role(</span>
<span class="gi">+        self, role_name: str, language_module: ModuleType, lineno: int, reporter: Reporter,</span>
<span class="gi">+    ) -&gt; tuple[RoleFunction, list[system_message]]:</span>
<span class="gi">+        return self.role_func(role_name, language_module,  # type: ignore[return-value]</span>
<span class="gi">+                              lineno, reporter)</span>
<span class="gi">+</span>

<span class="w"> </span>class ElementLookupError(Exception):
<span class="w"> </span>    pass
<span class="gu">@@ -158,58 +240,126 @@ class sphinx_domains(CustomReSTDispatcher):</span>
<span class="w"> </span>    markup takes precedence.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, env: BuildEnvironment) -&gt;None:</span>
<span class="gi">+    def __init__(self, env: BuildEnvironment) -&gt; None:</span>
<span class="w"> </span>        self.env = env
<span class="w"> </span>        super().__init__()

<span class="gd">-    def lookup_domain_element(self, type: str, name: str) -&gt;Any:</span>
<span class="gi">+    def lookup_domain_element(self, type: str, name: str) -&gt; Any:</span>
<span class="w"> </span>        &quot;&quot;&quot;Lookup a markup element (directive or role), given its name which can
<span class="w"> </span>        be a full name (with domain).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        name = name.lower()</span>
<span class="gi">+        # explicit domain given?</span>
<span class="gi">+        if &#39;:&#39; in name:</span>
<span class="gi">+            domain_name, name = name.split(&#39;:&#39;, 1)</span>
<span class="gi">+            if domain_name in self.env.domains:</span>
<span class="gi">+                domain = self.env.get_domain(domain_name)</span>
<span class="gi">+                element = getattr(domain, type)(name)</span>
<span class="gi">+                if element is not None:</span>
<span class="gi">+                    return element, []</span>
<span class="gi">+            else:</span>
<span class="gi">+                logger.warning(_(&#39;unknown directive or role name: %s:%s&#39;), domain_name, name)</span>
<span class="gi">+        # else look in the default domain</span>
<span class="gi">+        else:</span>
<span class="gi">+            def_domain = self.env.temp_data.get(&#39;default_domain&#39;)</span>
<span class="gi">+            if def_domain is not None:</span>
<span class="gi">+                element = getattr(def_domain, type)(name)</span>
<span class="gi">+                if element is not None:</span>
<span class="gi">+                    return element, []</span>
<span class="gi">+</span>
<span class="gi">+        # always look in the std domain</span>
<span class="gi">+        element = getattr(self.env.get_domain(&#39;std&#39;), type)(name)</span>
<span class="gi">+        if element is not None:</span>
<span class="gi">+            return element, []</span>
<span class="gi">+</span>
<span class="gi">+        raise ElementLookupError</span>
<span class="gi">+</span>
<span class="gi">+    def directive(self,</span>
<span class="gi">+                  directive_name: str, language_module: ModuleType, document: nodes.document,</span>
<span class="gi">+                  ) -&gt; tuple[type[Directive] | None, list[system_message]]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.lookup_domain_element(&#39;directive&#39;, directive_name)</span>
<span class="gi">+        except ElementLookupError:</span>
<span class="gi">+            return super().directive(directive_name, language_module, document)</span>
<span class="gi">+</span>
<span class="gi">+    def role(</span>
<span class="gi">+        self, role_name: str, language_module: ModuleType, lineno: int, reporter: Reporter,</span>
<span class="gi">+    ) -&gt; tuple[RoleFunction, list[system_message]]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.lookup_domain_element(&#39;role&#39;, role_name)</span>
<span class="gi">+        except ElementLookupError:</span>
<span class="gi">+            return super().role(role_name, language_module, lineno, reporter)</span>


<span class="w"> </span>class WarningStream:
<span class="gd">-    pass</span>
<span class="gi">+    def write(self, text: str) -&gt; None:</span>
<span class="gi">+        matched = report_re.search(text)</span>
<span class="gi">+        if not matched:</span>
<span class="gi">+            logger.warning(text.rstrip(&quot;\r\n&quot;), type=&quot;docutils&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            location, type, level = matched.groups()</span>
<span class="gi">+            message = report_re.sub(&#39;&#39;, text).rstrip()</span>
<span class="gi">+            logger.log(type, message, location=location, type=&quot;docutils&quot;)</span>


<span class="w"> </span>class LoggingReporter(Reporter):
<span class="gd">-</span>
<span class="w"> </span>    @classmethod
<span class="gd">-    def from_reporter(cls: type[LoggingReporter], reporter: Reporter</span>
<span class="gd">-        ) -&gt;LoggingReporter:</span>
<span class="gi">+    def from_reporter(cls: type[LoggingReporter], reporter: Reporter) -&gt; LoggingReporter:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create an instance of LoggingReporter from other reporter object.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return cls(reporter.source, reporter.report_level, reporter.halt_level,</span>
<span class="gi">+                   reporter.debug_flag, reporter.error_handler)</span>

<span class="gd">-    def __init__(self, source: str, report_level: int=Reporter.</span>
<span class="gd">-        WARNING_LEVEL, halt_level: int=Reporter.SEVERE_LEVEL, debug: bool=</span>
<span class="gd">-        False, error_handler: str=&#39;backslashreplace&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, source: str, report_level: int = Reporter.WARNING_LEVEL,</span>
<span class="gi">+                 halt_level: int = Reporter.SEVERE_LEVEL, debug: bool = False,</span>
<span class="gi">+                 error_handler: str = &#39;backslashreplace&#39;) -&gt; None:</span>
<span class="w"> </span>        stream = cast(IO, WarningStream())
<span class="gd">-        super().__init__(source, report_level, halt_level, stream, debug,</span>
<span class="gd">-            error_handler=error_handler)</span>
<span class="gi">+        super().__init__(source, report_level, halt_level,</span>
<span class="gi">+                         stream, debug, error_handler=error_handler)</span>


<span class="w"> </span>class NullReporter(Reporter):
<span class="w"> </span>    &quot;&quot;&quot;A dummy reporter; write nothing.&quot;&quot;&quot;

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        super().__init__(&#39;&#39;, 999, 4)


<span class="w"> </span>@contextmanager
<span class="gd">-def switch_source_input(state: State, content: StringList) -&gt;Iterator[None]:</span>
<span class="gi">+def switch_source_input(state: State, content: StringList) -&gt; Iterator[None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Switch current source input of state temporarily.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        # remember the original ``get_source_and_line()`` method</span>
<span class="gi">+        gsal = state.memo.reporter.get_source_and_line  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="gi">+        # replace it by new one</span>
<span class="gi">+        state_machine: StateMachine[None] = StateMachine([], None)  # type: ignore[arg-type]</span>
<span class="gi">+        state_machine.input_lines = content</span>
<span class="gi">+        state.memo.reporter.get_source_and_line = state_machine.get_source_and_line  # type: ignore[attr-defined]  # NoQA: E501</span>
<span class="gi">+</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        # restore the method</span>
<span class="gi">+        state.memo.reporter.get_source_and_line = gsal  # type: ignore[attr-defined]</span>


<span class="w"> </span>class SphinxFileOutput(FileOutput):
<span class="w"> </span>    &quot;&quot;&quot;Better FileOutput class for Sphinx.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, **kwargs: Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, **kwargs: Any) -&gt; None:</span>
<span class="w"> </span>        self.overwrite_if_changed = kwargs.pop(&#39;overwrite_if_changed&#39;, False)
<span class="w"> </span>        kwargs.setdefault(&#39;encoding&#39;, &#39;utf-8&#39;)
<span class="w"> </span>        super().__init__(**kwargs)

<span class="gi">+    def write(self, data: str) -&gt; str:</span>
<span class="gi">+        if (self.destination_path and self.autoclose and &#39;b&#39; not in self.mode and</span>
<span class="gi">+                self.overwrite_if_changed and os.path.exists(self.destination_path)):</span>
<span class="gi">+            with open(self.destination_path, encoding=self.encoding) as f:</span>
<span class="gi">+                # skip writing: content not changed</span>
<span class="gi">+                if f.read() == data:</span>
<span class="gi">+                    return data</span>
<span class="gi">+</span>
<span class="gi">+        return super().write(data)</span>
<span class="gi">+</span>

<span class="w"> </span>class SphinxDirective(Directive):
<span class="w"> </span>    &quot;&quot;&quot;A base class for Sphinx directives.
<span class="gu">@@ -223,44 +373,50 @@ class SphinxDirective(Directive):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    @property
<span class="gd">-    def env(self) -&gt;BuildEnvironment:</span>
<span class="gi">+    def env(self) -&gt; BuildEnvironment:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reference to the :class:`.BuildEnvironment` object.

<span class="w"> </span>        .. versionadded:: 1.8
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.state.document.settings.env</span>

<span class="w"> </span>    @property
<span class="gd">-    def config(self) -&gt;Config:</span>
<span class="gi">+    def config(self) -&gt; Config:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reference to the :class:`.Config` object.

<span class="w"> </span>        .. versionadded:: 1.8
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.env.config</span>

<span class="gd">-    def get_source_info(self) -&gt;tuple[str, int]:</span>
<span class="gi">+    def get_source_info(self) -&gt; tuple[str, int]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get source and line number.

<span class="w"> </span>        .. versionadded:: 3.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.state_machine.get_source_and_line(self.lineno)</span>

<span class="gd">-    def set_source_info(self, node: Node) -&gt;None:</span>
<span class="gi">+    def set_source_info(self, node: Node) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Set source and line number to the node.

<span class="w"> </span>        .. versionadded:: 2.1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        node.source, node.line = self.get_source_info()</span>

<span class="gd">-    def get_location(self) -&gt;str:</span>
<span class="gi">+    def get_location(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get current location info for logging.

<span class="w"> </span>        .. versionadded:: 4.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def parse_content_to_nodes(self, allow_section_headings: bool=False</span>
<span class="gd">-        ) -&gt;list[Node]:</span>
<span class="gi">+        source, line = self.get_source_info()</span>
<span class="gi">+        if source and line:</span>
<span class="gi">+            return f&#39;{source}:{line}&#39;</span>
<span class="gi">+        if source:</span>
<span class="gi">+            return f&#39;{source}:&#39;</span>
<span class="gi">+        if line:</span>
<span class="gi">+            return f&#39;&lt;unknown&gt;:{line}&#39;</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def parse_content_to_nodes(self, allow_section_headings: bool = False) -&gt; list[Node]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse the directive&#39;s content into nodes.

<span class="w"> </span>        :param allow_section_headings:
<span class="gu">@@ -273,10 +429,16 @@ class SphinxDirective(Directive):</span>

<span class="w"> </span>        .. versionadded:: 7.4
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def parse_text_to_nodes(self, text: str=&#39;&#39;, /, *, offset: int=-1,</span>
<span class="gd">-        allow_section_headings: bool=False) -&gt;list[Node]:</span>
<span class="gi">+        return nested_parse_to_nodes(</span>
<span class="gi">+            self.state,</span>
<span class="gi">+            self.content,</span>
<span class="gi">+            offset=self.content_offset,</span>
<span class="gi">+            allow_section_headings=allow_section_headings,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def parse_text_to_nodes(</span>
<span class="gi">+        self, text: str = &#39;&#39;, /, *, offset: int = -1, allow_section_headings: bool = False,</span>
<span class="gi">+    ) -&gt; list[Node]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse *text* into nodes.

<span class="w"> </span>        :param text:
<span class="gu">@@ -293,10 +455,18 @@ class SphinxDirective(Directive):</span>

<span class="w"> </span>        .. versionadded:: 7.4
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def parse_inline(self, text: str, *, lineno: int=-1) -&gt;tuple[list[Node],</span>
<span class="gd">-        list[system_message]]:</span>
<span class="gi">+        if offset == -1:</span>
<span class="gi">+            offset = self.content_offset</span>
<span class="gi">+        return nested_parse_to_nodes(</span>
<span class="gi">+            self.state,</span>
<span class="gi">+            text,</span>
<span class="gi">+            offset=offset,</span>
<span class="gi">+            allow_section_headings=allow_section_headings,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def parse_inline(</span>
<span class="gi">+        self, text: str, *, lineno: int = -1,</span>
<span class="gi">+    ) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse *text* as inline elements.

<span class="w"> </span>        :param text:
<span class="gu">@@ -310,7 +480,9 @@ class SphinxDirective(Directive):</span>

<span class="w"> </span>        .. versionadded:: 7.4
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if lineno == -1:</span>
<span class="gi">+            lineno = self.lineno</span>
<span class="gi">+        return self.state.inline_text(text, lineno)</span>


<span class="w"> </span>class SphinxRole:
<span class="gu">@@ -323,23 +495,30 @@ class SphinxRole:</span>
<span class="w"> </span>    .. note:: The subclasses of this class might not work with docutils.
<span class="w"> </span>              This class is strongly coupled with Sphinx.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    name: str</span>
<span class="gd">-    rawtext: str</span>
<span class="gd">-    text: str</span>
<span class="gd">-    lineno: int</span>
<span class="gd">-    inliner: Inliner</span>
<span class="gi">+</span>
<span class="gi">+    name: str         #: The role name actually used in the document.</span>
<span class="gi">+    rawtext: str      #: A string containing the entire interpreted text input.</span>
<span class="gi">+    text: str         #: The interpreted text content.</span>
<span class="gi">+    lineno: int       #: The line number where the interpreted text begins.</span>
<span class="gi">+    inliner: Inliner  #: The ``docutils.parsers.rst.states.Inliner`` object.</span>
<span class="gi">+    #: A dictionary of directive options for customisation</span>
<span class="gi">+    #: (from the &quot;role&quot; directive).</span>
<span class="w"> </span>    options: dict[str, Any]
<span class="gi">+    #: A list of strings, the directive content for customisation</span>
<span class="gi">+    #: (from the &quot;role&quot; directive).</span>
<span class="w"> </span>    content: Sequence[str]

<span class="w"> </span>    def __call__(self, name: str, rawtext: str, text: str, lineno: int,
<span class="gd">-        inliner: Inliner, options: (dict | None)=None, content: Sequence[</span>
<span class="gd">-        str]=()) -&gt;tuple[list[Node], list[system_message]]:</span>
<span class="gi">+                 inliner: Inliner, options: dict | None = None, content: Sequence[str] = (),</span>
<span class="gi">+                 ) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="w"> </span>        self.rawtext = rawtext
<span class="w"> </span>        self.text = unescape(text)
<span class="w"> </span>        self.lineno = lineno
<span class="w"> </span>        self.inliner = inliner
<span class="w"> </span>        self.options = options if options is not None else {}
<span class="w"> </span>        self.content = content
<span class="gi">+</span>
<span class="gi">+        # guess role type</span>
<span class="w"> </span>        if name:
<span class="w"> </span>            self.name = name.lower()
<span class="w"> </span>        else:
<span class="gu">@@ -349,30 +528,51 @@ class SphinxRole:</span>
<span class="w"> </span>            if not self.name:
<span class="w"> </span>                msg = &#39;cannot determine default role!&#39;
<span class="w"> </span>                raise SphinxError(msg)
<span class="gi">+</span>
<span class="w"> </span>        return self.run()

<span class="gi">+    def run(self) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="w"> </span>    @property
<span class="gd">-    def env(self) -&gt;BuildEnvironment:</span>
<span class="gi">+    def env(self) -&gt; BuildEnvironment:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reference to the :class:`.BuildEnvironment` object.

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.inliner.document.settings.env</span>

<span class="w"> </span>    @property
<span class="gd">-    def config(self) -&gt;Config:</span>
<span class="gi">+    def config(self) -&gt; Config:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reference to the :class:`.Config` object.

<span class="w"> </span>        .. versionadded:: 2.0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.env.config</span>

<span class="gd">-    def get_location(self) -&gt;str:</span>
<span class="gi">+    def get_source_info(self, lineno: int | None = None) -&gt; tuple[str, int]:</span>
<span class="gi">+        # .. versionadded:: 3.0</span>
<span class="gi">+        if lineno is None:</span>
<span class="gi">+            lineno = self.lineno</span>
<span class="gi">+        return self.inliner.reporter.get_source_and_line(lineno)  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="gi">+    def set_source_info(self, node: Node, lineno: int | None = None) -&gt; None:</span>
<span class="gi">+        # .. versionadded:: 2.0</span>
<span class="gi">+        node.source, node.line = self.get_source_info(lineno)</span>
<span class="gi">+</span>
<span class="gi">+    def get_location(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get current location info for logging.

<span class="w"> </span>        .. versionadded:: 4.2
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        source, line = self.get_source_info()</span>
<span class="gi">+        if source and line:</span>
<span class="gi">+            return f&#39;{source}:{line}&#39;</span>
<span class="gi">+        if source:</span>
<span class="gi">+            return f&#39;{source}:&#39;</span>
<span class="gi">+        if line:</span>
<span class="gi">+            return f&#39;&lt;unknown&gt;:{line}&#39;</span>
<span class="gi">+        return &#39;&#39;</span>


<span class="w"> </span>class ReferenceRole(SphinxRole):
<span class="gu">@@ -384,18 +584,24 @@ class ReferenceRole(SphinxRole):</span>

<span class="w"> </span>    .. versionadded:: 2.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    has_explicit_title: bool</span>
<span class="gd">-    disabled: bool</span>
<span class="gd">-    title: str</span>
<span class="gd">-    target: str</span>
<span class="gd">-    explicit_title_re = re.compile(&#39;^(.+?)\\s*(?&lt;!\\x00)&lt;(.*?)&gt;$&#39;, re.DOTALL)</span>
<span class="gi">+</span>
<span class="gi">+    has_explicit_title: bool    #: A boolean indicates the role has explicit title or not.</span>
<span class="gi">+    disabled: bool              #: A boolean indicates the reference is disabled.</span>
<span class="gi">+    title: str                  #: The link title for the interpreted text.</span>
<span class="gi">+    target: str                 #: The link target for the interpreted text.</span>
<span class="gi">+</span>
<span class="gi">+    # \x00 means the &quot;&lt;&quot; was backslash-escaped</span>
<span class="gi">+    explicit_title_re = re.compile(r&#39;^(.+?)\s*(?&lt;!\x00)&lt;(.*?)&gt;$&#39;, re.DOTALL)</span>

<span class="w"> </span>    def __call__(self, name: str, rawtext: str, text: str, lineno: int,
<span class="gd">-        inliner: Inliner, options: (dict | None)=None, content: Sequence[</span>
<span class="gd">-        str]=()) -&gt;tuple[list[Node], list[system_message]]:</span>
<span class="gi">+                 inliner: Inliner, options: dict | None = None, content: Sequence[str] = (),</span>
<span class="gi">+                 ) -&gt; tuple[list[Node], list[system_message]]:</span>
<span class="w"> </span>        if options is None:
<span class="w"> </span>            options = {}
<span class="gi">+</span>
<span class="gi">+        # if the first character is a bang, don&#39;t cross-reference at all</span>
<span class="w"> </span>        self.disabled = text.startswith(&#39;!&#39;)
<span class="gi">+</span>
<span class="w"> </span>        matched = self.explicit_title_re.match(text)
<span class="w"> </span>        if matched:
<span class="w"> </span>            self.has_explicit_title = True
<span class="gu">@@ -405,8 +611,8 @@ class ReferenceRole(SphinxRole):</span>
<span class="w"> </span>            self.has_explicit_title = False
<span class="w"> </span>            self.title = unescape(text)
<span class="w"> </span>            self.target = unescape(text)
<span class="gd">-        return super().__call__(name, rawtext, text, lineno, inliner,</span>
<span class="gd">-            options, content)</span>
<span class="gi">+</span>
<span class="gi">+        return super().__call__(name, rawtext, text, lineno, inliner, options, content)</span>


<span class="w"> </span>class SphinxTranslator(nodes.NodeVisitor):
<span class="gu">@@ -423,13 +629,13 @@ class SphinxTranslator(nodes.NodeVisitor):</span>
<span class="w"> </span>              This class is strongly coupled with Sphinx.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, document: nodes.document, builder: Builder) -&gt;None:</span>
<span class="gi">+    def __init__(self, document: nodes.document, builder: Builder) -&gt; None:</span>
<span class="w"> </span>        super().__init__(document)
<span class="w"> </span>        self.builder = builder
<span class="w"> </span>        self.config = builder.config
<span class="w"> </span>        self.settings = document.settings

<span class="gd">-    def dispatch_visit(self, node: Node) -&gt;None:</span>
<span class="gi">+    def dispatch_visit(self, node: Node) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Dispatch node to appropriate visitor method.
<span class="w"> </span>        The priority of visitor method is:
<span class="gu">@@ -438,9 +644,15 @@ class SphinxTranslator(nodes.NodeVisitor):</span>
<span class="w"> </span>        2. ``self.visit_{super_node_class}()``
<span class="w"> </span>        3. ``self.unknown_visit()``
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for node_class in node.__class__.__mro__:</span>
<span class="gi">+            method = getattr(self, &#39;visit_%s&#39; % (node_class.__name__), None)</span>
<span class="gi">+            if method:</span>
<span class="gi">+                method(node)</span>
<span class="gi">+                break</span>
<span class="gi">+        else:</span>
<span class="gi">+            super().dispatch_visit(node)</span>

<span class="gd">-    def dispatch_departure(self, node: Node) -&gt;None:</span>
<span class="gi">+    def dispatch_departure(self, node: Node) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Dispatch node to appropriate departure method.
<span class="w"> </span>        The priority of departure method is:
<span class="gu">@@ -449,17 +661,43 @@ class SphinxTranslator(nodes.NodeVisitor):</span>
<span class="w"> </span>        2. ``self.depart_{super_node_class}()``
<span class="w"> </span>        3. ``self.unknown_departure()``
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for node_class in node.__class__.__mro__:</span>
<span class="gi">+            method = getattr(self, &#39;depart_%s&#39; % (node_class.__name__), None)</span>
<span class="gi">+            if method:</span>
<span class="gi">+                method(node)</span>
<span class="gi">+                break</span>
<span class="gi">+        else:</span>
<span class="gi">+            super().dispatch_departure(node)</span>
<span class="gi">+</span>
<span class="gi">+    def unknown_visit(self, node: Node) -&gt; None:</span>
<span class="gi">+        logger.warning(__(&#39;unknown node type: %r&#39;), node, location=node)</span>


<span class="gi">+# cache a vanilla instance of nodes.document</span>
<span class="gi">+# Used in new_document() function</span>
<span class="w"> </span>__document_cache__: tuple[Values, Reporter]


<span class="gd">-def new_document(source_path: str, settings: Any=None) -&gt;nodes.document:</span>
<span class="gi">+def new_document(source_path: str, settings: Any = None) -&gt; nodes.document:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a new empty document object.  This is an alternative of docutils&#39;.

<span class="w"> </span>    This is a simple wrapper for ``docutils.utils.new_document()``.  It
<span class="w"> </span>    caches the result of docutils&#39; and use it on second call for instantiation.
<span class="w"> </span>    This makes an instantiation of document nodes much faster.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global __document_cache__</span>
<span class="gi">+    try:</span>
<span class="gi">+        cached_settings, reporter = __document_cache__</span>
<span class="gi">+    except NameError:</span>
<span class="gi">+        doc = docutils.utils.new_document(source_path)</span>
<span class="gi">+        __document_cache__ = cached_settings, reporter = doc.settings, doc.reporter</span>
<span class="gi">+</span>
<span class="gi">+    if settings is None:</span>
<span class="gi">+        # Make a copy of the cached settings to accelerate instantiation</span>
<span class="gi">+        settings = copy(cached_settings)</span>
<span class="gi">+</span>
<span class="gi">+    # Create a new instance of nodes.document using cached reporter</span>
<span class="gi">+    from sphinx import addnodes</span>
<span class="gi">+    document = addnodes.document(settings, reporter, source=source_path)</span>
<span class="gi">+    document.note_source(source_path, -1)</span>
<span class="gi">+    return document</span>
<span class="gh">diff --git a/sphinx/util/exceptions.py b/sphinx/util/exceptions.py</span>
<span class="gh">index 53e2b545f..577ec734e 100644</span>
<span class="gd">--- a/sphinx/util/exceptions.py</span>
<span class="gi">+++ b/sphinx/util/exceptions.py</span>
<span class="gu">@@ -1,19 +1,68 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import sys
<span class="w"> </span>import traceback
<span class="w"> </span>from tempfile import NamedTemporaryFile
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from sphinx.errors import SphinxParallelError
<span class="w"> </span>from sphinx.util.console import strip_escape_sequences
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from sphinx.application import Sphinx


<span class="gd">-def save_traceback(app: (Sphinx | None), exc: BaseException) -&gt;str:</span>
<span class="gi">+def save_traceback(app: Sphinx | None, exc: BaseException) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Save the given exception&#39;s traceback in a temporary file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import platform</span>
<span class="gi">+</span>
<span class="gi">+    import docutils</span>
<span class="gi">+    import jinja2</span>
<span class="gi">+    import pygments</span>
<span class="gi">+</span>
<span class="gi">+    import sphinx</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(exc, SphinxParallelError):</span>
<span class="gi">+        exc_format = &#39;(Error in parallel process)\n&#39; + exc.traceback</span>
<span class="gi">+    else:</span>
<span class="gi">+        exc_format = traceback.format_exc()</span>
<span class="gi">+</span>
<span class="gi">+    if app is None:</span>
<span class="gi">+        last_msgs = exts_list = &#39;&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        extensions = app.extensions.values()</span>
<span class="gi">+        last_msgs = &#39;\n&#39;.join(f&#39;#   {strip_escape_sequences(s).strip()}&#39;</span>
<span class="gi">+                              for s in app.messagelog)</span>
<span class="gi">+        exts_list = &#39;\n&#39;.join(f&#39;#   {ext.name} ({ext.version})&#39; for ext in extensions</span>
<span class="gi">+                              if ext.version != &#39;builtin&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    with NamedTemporaryFile(&#39;w&#39;, suffix=&#39;.log&#39;, prefix=&#39;sphinx-err-&#39;, delete=False) as f:</span>
<span class="gi">+        f.write(f&quot;&quot;&quot;\</span>
<span class="gi">+# Platform:         {sys.platform}; ({platform.platform()})</span>
<span class="gi">+# Sphinx version:   {sphinx.__display_version__}</span>
<span class="gi">+# Python version:   {platform.python_version()} ({platform.python_implementation()})</span>
<span class="gi">+# Docutils version: {docutils.__version__}</span>
<span class="gi">+# Jinja2 version:   {jinja2.__version__}</span>
<span class="gi">+# Pygments version: {pygments.__version__}</span>
<span class="gi">+</span>
<span class="gi">+# Last messages:</span>
<span class="gi">+{last_msgs}</span>
<span class="gi">+</span>
<span class="gi">+# Loaded extensions:</span>
<span class="gi">+{exts_list}</span>
<span class="gi">+</span>
<span class="gi">+# Traceback:</span>
<span class="gi">+{exc_format}</span>
<span class="gi">+&quot;&quot;&quot;)</span>
<span class="gi">+    return f.name</span>


<span class="gd">-def format_exception_cut_frames(x: int=1) -&gt;str:</span>
<span class="gi">+def format_exception_cut_frames(x: int = 1) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Format an exception with traceback, but only the last x frames.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    typ, val, tb = sys.exc_info()</span>
<span class="gi">+    # res = [&#39;Traceback (most recent call last):\n&#39;]</span>
<span class="gi">+    res: list[str] = []</span>
<span class="gi">+    tbres = traceback.format_tb(tb)</span>
<span class="gi">+    res += tbres[-x:]</span>
<span class="gi">+    res += traceback.format_exception_only(typ, val)</span>
<span class="gi">+    return &#39;&#39;.join(res)</span>
<span class="gh">diff --git a/sphinx/util/fileutil.py b/sphinx/util/fileutil.py</span>
<span class="gh">index fa4bab77f..259a2af19 100644</span>
<span class="gd">--- a/sphinx/util/fileutil.py</span>
<span class="gi">+++ b/sphinx/util/fileutil.py</span>
<span class="gu">@@ -1,30 +1,44 @@</span>
<span class="w"> </span>&quot;&quot;&quot;File utility functions for Sphinx.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import posixpath
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from docutils.utils import relative_path
<span class="gi">+</span>
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.osutil import copyfile, ensuredir
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Callable
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.util.template import BaseRenderer
<span class="w"> </span>    from sphinx.util.typing import PathMatcher
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="gd">-def _template_basename(filename: (str | os.PathLike[str])) -&gt;(str | None):</span>
<span class="gi">+def _template_basename(filename: str | os.PathLike[str]) -&gt; str | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Given an input filename:
<span class="w"> </span>    If the input looks like a template, then return the filename output should
<span class="w"> </span>    be written to.  Otherwise, return no result (None).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    basename = os.path.basename(filename)</span>
<span class="gi">+    if basename.lower().endswith(&#39;_t&#39;):</span>
<span class="gi">+        return str(filename)[:-2]</span>
<span class="gi">+    elif basename.lower().endswith(&#39;.jinja&#39;):</span>
<span class="gi">+        return str(filename)[:-6]</span>
<span class="gi">+    return None</span>


<span class="gd">-def copy_asset_file(source: (str | os.PathLike[str]), destination: (str |</span>
<span class="gd">-    os.PathLike[str]), context: (dict[str, Any] | None)=None, renderer: (</span>
<span class="gd">-    BaseRenderer | None)=None, *, force: bool=False) -&gt;None:</span>
<span class="gi">+def copy_asset_file(source: str | os.PathLike[str], destination: str | os.PathLike[str],</span>
<span class="gi">+                    context: dict[str, Any] | None = None,</span>
<span class="gi">+                    renderer: BaseRenderer | None = None,</span>
<span class="gi">+                    *,</span>
<span class="gi">+                    force: bool = False) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Copy an asset file to destination.

<span class="w"> </span>    On copying, it expands the template variables if context argument is given and
<span class="gu">@@ -36,14 +50,50 @@ def copy_asset_file(source: (str | os.PathLike[str]), destination: (str |</span>
<span class="w"> </span>    :param renderer: The template engine.  If not given, SphinxRenderer is used by default
<span class="w"> </span>    :param bool force: Overwrite the destination file even if it exists.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not os.path.exists(source):</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    if os.path.isdir(destination):</span>
<span class="gi">+        # Use source filename if destination points a directory</span>
<span class="gi">+        destination = os.path.join(destination, os.path.basename(source))</span>
<span class="gi">+    else:</span>
<span class="gi">+        destination = str(destination)</span>

<span class="gi">+    if _template_basename(source) and context is not None:</span>
<span class="gi">+        if renderer is None:</span>
<span class="gi">+            from sphinx.util.template import SphinxRenderer</span>
<span class="gi">+            renderer = SphinxRenderer()</span>

<span class="gd">-def copy_asset(source: (str | os.PathLike[str]), destination: (str | os.</span>
<span class="gd">-    PathLike[str]), excluded: PathMatcher=lambda path: False, context: (</span>
<span class="gd">-    dict[str, Any] | None)=None, renderer: (BaseRenderer | None)=None,</span>
<span class="gd">-    onerror: (Callable[[str, Exception], None] | None)=None, *, force: bool</span>
<span class="gd">-    =False) -&gt;None:</span>
<span class="gi">+        with open(source, encoding=&#39;utf-8&#39;) as fsrc:</span>
<span class="gi">+            template_content = fsrc.read()</span>
<span class="gi">+        rendered_template = renderer.render_string(template_content, context)</span>
<span class="gi">+</span>
<span class="gi">+        if (</span>
<span class="gi">+            not force</span>
<span class="gi">+            and os.path.exists(destination)</span>
<span class="gi">+            and template_content != rendered_template</span>
<span class="gi">+        ):</span>
<span class="gi">+            msg = __(&#39;Aborted attempted copy from rendered template %s to %s &#39;</span>
<span class="gi">+                     &#39;(the destination path has existing data).&#39;)</span>
<span class="gi">+            logger.warning(msg, os.fsdecode(source), os.fsdecode(destination),</span>
<span class="gi">+                           type=&#39;misc&#39;, subtype=&#39;copy_overwrite&#39;)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        destination = _template_basename(destination) or destination</span>
<span class="gi">+        with open(destination, &#39;w&#39;, encoding=&#39;utf-8&#39;) as fdst:</span>
<span class="gi">+            msg = __(&#39;Writing evaluated template result to %s&#39;)</span>
<span class="gi">+            logger.info(msg, os.fsdecode(destination), type=&#39;misc&#39;,</span>
<span class="gi">+                        subtype=&#39;template_evaluation&#39;)</span>
<span class="gi">+            fdst.write(rendered_template)</span>
<span class="gi">+    else:</span>
<span class="gi">+        copyfile(source, destination, force=force)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def copy_asset(source: str | os.PathLike[str], destination: str | os.PathLike[str],</span>
<span class="gi">+               excluded: PathMatcher = lambda path: False,</span>
<span class="gi">+               context: dict[str, Any] | None = None, renderer: BaseRenderer | None = None,</span>
<span class="gi">+               onerror: Callable[[str, Exception], None] | None = None,</span>
<span class="gi">+               *, force: bool = False) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Copy asset files to destination recursively.

<span class="w"> </span>    On copying, it expands the template variables if context argument is given and
<span class="gu">@@ -59,4 +109,39 @@ def copy_asset(source: (str | os.PathLike[str]), destination: (str | os.</span>
<span class="w"> </span>    :param onerror: The error handler.
<span class="w"> </span>    :param bool force: Overwrite the destination file even if it exists.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not os.path.exists(source):</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    if renderer is None:</span>
<span class="gi">+        from sphinx.util.template import SphinxRenderer</span>
<span class="gi">+        renderer = SphinxRenderer()</span>
<span class="gi">+</span>
<span class="gi">+    ensuredir(destination)</span>
<span class="gi">+    if os.path.isfile(source):</span>
<span class="gi">+        copy_asset_file(source, destination,</span>
<span class="gi">+                        context=context,</span>
<span class="gi">+                        renderer=renderer,</span>
<span class="gi">+                        force=force)</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    for root, dirs, files in os.walk(source, followlinks=True):</span>
<span class="gi">+        reldir = relative_path(source, root)</span>
<span class="gi">+        for dir in dirs.copy():</span>
<span class="gi">+            if excluded(posixpath.join(reldir, dir)):</span>
<span class="gi">+                dirs.remove(dir)</span>
<span class="gi">+            else:</span>
<span class="gi">+                ensuredir(posixpath.join(destination, reldir, dir))</span>
<span class="gi">+</span>
<span class="gi">+        for filename in files:</span>
<span class="gi">+            if not excluded(posixpath.join(reldir, filename)):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    copy_asset_file(posixpath.join(root, filename),</span>
<span class="gi">+                                    posixpath.join(destination, reldir),</span>
<span class="gi">+                                    context=context,</span>
<span class="gi">+                                    renderer=renderer,</span>
<span class="gi">+                                    force=force)</span>
<span class="gi">+                except Exception as exc:</span>
<span class="gi">+                    if onerror:</span>
<span class="gi">+                        onerror(posixpath.join(root, filename), exc)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        raise</span>
<span class="gh">diff --git a/sphinx/util/http_date.py b/sphinx/util/http_date.py</span>
<span class="gh">index 0a1f2f186..4908101bc 100644</span>
<span class="gd">--- a/sphinx/util/http_date.py</span>
<span class="gi">+++ b/sphinx/util/http_date.py</span>
<span class="gu">@@ -2,21 +2,45 @@</span>

<span class="w"> </span>Reference: https://www.rfc-editor.org/rfc/rfc7231#section-7.1.1.1
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import time
<span class="w"> </span>import warnings
<span class="w"> </span>from email.utils import parsedate_tz
<span class="gi">+</span>
<span class="w"> </span>from sphinx.deprecation import RemovedInSphinx90Warning
<span class="gd">-_WEEKDAY_NAME = &#39;Mon&#39;, &#39;Tue&#39;, &#39;Wed&#39;, &#39;Thu&#39;, &#39;Fri&#39;, &#39;Sat&#39;, &#39;Sun&#39;</span>
<span class="gd">-_MONTH_NAME = (&#39;&#39;, &#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;, &#39;May&#39;, &#39;Jun&#39;, &#39;Jul&#39;, &#39;Aug&#39;,</span>
<span class="gd">-    &#39;Sep&#39;, &#39;Oct&#39;, &#39;Nov&#39;, &#39;Dec&#39;)</span>
<span class="gi">+</span>
<span class="gi">+_WEEKDAY_NAME = (&#39;Mon&#39;, &#39;Tue&#39;, &#39;Wed&#39;, &#39;Thu&#39;, &#39;Fri&#39;, &#39;Sat&#39;, &#39;Sun&#39;)</span>
<span class="gi">+_MONTH_NAME = (&#39;&#39;,  # Placeholder for indexing purposes</span>
<span class="gi">+               &#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;, &#39;May&#39;, &#39;Jun&#39;,</span>
<span class="gi">+               &#39;Jul&#39;, &#39;Aug&#39;, &#39;Sep&#39;, &#39;Oct&#39;, &#39;Nov&#39;, &#39;Dec&#39;)</span>
<span class="w"> </span>_GMT_OFFSET = float(time.localtime().tm_gmtoff)


<span class="gd">-def epoch_to_rfc1123(epoch: float) -&gt;str:</span>
<span class="gi">+def epoch_to_rfc1123(epoch: float) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return HTTP-date string from epoch offset.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    yr, mn, dd, hh, mm, ss, wd, _yd, _tz = time.gmtime(epoch)</span>
<span class="gi">+    weekday_name = _WEEKDAY_NAME[wd]</span>
<span class="gi">+    month = _MONTH_NAME[mn]</span>
<span class="gi">+    return f&#39;{weekday_name}, {dd:02} {month} {yr:04} {hh:02}:{mm:02}:{ss:02} GMT&#39;</span>


<span class="gd">-def rfc1123_to_epoch(rfc1123: str) -&gt;float:</span>
<span class="gi">+def rfc1123_to_epoch(rfc1123: str) -&gt; float:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return epoch offset from HTTP-date string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    t = parsedate_tz(rfc1123)</span>
<span class="gi">+    if t is None:</span>
<span class="gi">+        raise ValueError</span>
<span class="gi">+    if not rfc1123.endswith(&quot; GMT&quot;):</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;HTTP-date string does not meet RFC 7231 requirements &quot;</span>
<span class="gi">+            f&quot;(must end with &#39;GMT&#39;): {rfc1123!r}&quot;,</span>
<span class="gi">+            RemovedInSphinx90Warning, stacklevel=3,</span>
<span class="gi">+        )</span>
<span class="gi">+    epoch_secs = time.mktime(time.struct_time(t[:9])) + _GMT_OFFSET</span>
<span class="gi">+    if (gmt_offset := t[9]) != 0:</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;HTTP-date string does not meet RFC 7231 requirements &quot;</span>
<span class="gi">+            f&quot;(must be GMT time): {rfc1123!r}&quot;,</span>
<span class="gi">+            RemovedInSphinx90Warning, stacklevel=3,</span>
<span class="gi">+        )</span>
<span class="gi">+        return epoch_secs - (gmt_offset or 0)</span>
<span class="gi">+    return epoch_secs</span>
<span class="gh">diff --git a/sphinx/util/i18n.py b/sphinx/util/i18n.py</span>
<span class="gh">index c493eb2cf..2f2d500d9 100644</span>
<span class="gd">--- a/sphinx/util/i18n.py</span>
<span class="gi">+++ b/sphinx/util/i18n.py</span>
<span class="gu">@@ -1,47 +1,64 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Builder superclass for all builders.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import re
<span class="w"> </span>from datetime import datetime, timezone
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING, NamedTuple
<span class="gi">+</span>
<span class="w"> </span>import babel.dates
<span class="w"> </span>from babel.messages.mofile import write_mo
<span class="w"> </span>from babel.messages.pofile import read_po
<span class="gi">+</span>
<span class="w"> </span>from sphinx.errors import SphinxError
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.util import logging
<span class="gd">-from sphinx.util.osutil import SEP, _last_modified_time, canon_path, relpath</span>
<span class="gi">+from sphinx.util.osutil import (</span>
<span class="gi">+    SEP,</span>
<span class="gi">+    _last_modified_time,</span>
<span class="gi">+    canon_path,</span>
<span class="gi">+    relpath,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    import datetime as dt
<span class="w"> </span>    from collections.abc import Iterator
<span class="w"> </span>    from typing import Protocol, TypeAlias
<span class="gi">+</span>
<span class="w"> </span>    from babel.core import Locale
<span class="gd">-    from sphinx.environment import BuildEnvironment</span>

<span class="gi">+    from sphinx.environment import BuildEnvironment</span>

<span class="w"> </span>    class DateFormatter(Protocol):
<span class="gd">-</span>
<span class="gd">-        def __call__(self, date: (dt.date | None)=..., format: str=...,</span>
<span class="gd">-            locale: (str | Locale | None)=...) -&gt;str:</span>
<span class="gd">-            ...</span>
<span class="gd">-</span>
<span class="gi">+        def __call__(  # NoQA: E704</span>
<span class="gi">+            self,</span>
<span class="gi">+            date: dt.date | None = ...,</span>
<span class="gi">+            format: str = ...,</span>
<span class="gi">+            locale: str | Locale | None = ...,</span>
<span class="gi">+        ) -&gt; str: ...</span>

<span class="w"> </span>    class TimeFormatter(Protocol):
<span class="gd">-</span>
<span class="gd">-        def __call__(self, time: (dt.time | dt.datetime | float | None)=...,</span>
<span class="gd">-            format: str=..., tzinfo: (dt.tzinfo | None)=..., locale: (str |</span>
<span class="gd">-            Locale | None)=...) -&gt;str:</span>
<span class="gd">-            ...</span>
<span class="gd">-</span>
<span class="gi">+        def __call__(  # NoQA: E704</span>
<span class="gi">+            self,</span>
<span class="gi">+            time: dt.time | dt.datetime | float | None = ...,</span>
<span class="gi">+            format: str = ...,</span>
<span class="gi">+            tzinfo: dt.tzinfo | None = ...,</span>
<span class="gi">+            locale: str | Locale | None = ...,</span>
<span class="gi">+        ) -&gt; str: ...</span>

<span class="w"> </span>    class DatetimeFormatter(Protocol):
<span class="gi">+        def __call__(  # NoQA: E704</span>
<span class="gi">+            self,</span>
<span class="gi">+            datetime: dt.date | dt.time | float | None = ...,</span>
<span class="gi">+            format: str = ...,</span>
<span class="gi">+            tzinfo: dt.tzinfo | None = ...,</span>
<span class="gi">+            locale: str | Locale | None = ...,</span>
<span class="gi">+        ) -&gt; str: ...</span>

<span class="gd">-        def __call__(self, datetime: (dt.date | dt.time | float | None)=...,</span>
<span class="gd">-            format: str=..., tzinfo: (dt.tzinfo | None)=..., locale: (str |</span>
<span class="gd">-            Locale | None)=...) -&gt;str:</span>
<span class="gd">-            ...</span>
<span class="w"> </span>    Formatter: TypeAlias = DateFormatter | TimeFormatter | DatetimeFormatter
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)


<span class="gu">@@ -52,29 +69,221 @@ class LocaleFileInfoBase(NamedTuple):</span>


<span class="w"> </span>class CatalogInfo(LocaleFileInfoBase):
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def po_file(self) -&gt; str:</span>
<span class="gi">+        return self.domain + &#39;.po&#39;</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def mo_file(self) -&gt; str:</span>
<span class="gi">+        return self.domain + &#39;.mo&#39;</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def po_path(self) -&gt; str:</span>
<span class="gi">+        return path.join(self.base_dir, self.po_file)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def mo_path(self) -&gt; str:</span>
<span class="gi">+        return path.join(self.base_dir, self.mo_file)</span>
<span class="gi">+</span>
<span class="gi">+    def is_outdated(self) -&gt; bool:</span>
<span class="gi">+        return (</span>
<span class="gi">+            not path.exists(self.mo_path) or</span>
<span class="gi">+            _last_modified_time(self.mo_path) &lt; _last_modified_time(self.po_path))</span>
<span class="gi">+</span>
<span class="gi">+    def write_mo(self, locale: str, use_fuzzy: bool = False) -&gt; None:</span>
<span class="gi">+        with open(self.po_path, encoding=self.charset) as file_po:</span>
<span class="gi">+            try:</span>
<span class="gi">+                po = read_po(file_po, locale)</span>
<span class="gi">+            except Exception as exc:</span>
<span class="gi">+                logger.warning(__(&#39;reading error: %s, %s&#39;), self.po_path, exc)</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+        with open(self.mo_path, &#39;wb&#39;) as file_mo:</span>
<span class="gi">+            try:</span>
<span class="gi">+                write_mo(file_mo, po, use_fuzzy)</span>
<span class="gi">+            except Exception as exc:</span>
<span class="gi">+                logger.warning(__(&#39;writing error: %s, %s&#39;), self.mo_path, exc)</span>


<span class="w"> </span>class CatalogRepository:
<span class="w"> </span>    &quot;&quot;&quot;A repository for message catalogs.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, basedir: (str | os.PathLike[str]), locale_dirs: list</span>
<span class="gd">-        [str], language: str, encoding: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, basedir: str | os.PathLike[str], locale_dirs: list[str],</span>
<span class="gi">+                 language: str, encoding: str) -&gt; None:</span>
<span class="w"> </span>        self.basedir = basedir
<span class="w"> </span>        self._locale_dirs = locale_dirs
<span class="w"> </span>        self.language = language
<span class="w"> </span>        self.encoding = encoding

<span class="gi">+    @property</span>
<span class="gi">+    def locale_dirs(self) -&gt; Iterator[str]:</span>
<span class="gi">+        if not self.language:</span>
<span class="gi">+            return</span>

<span class="gd">-def docname_to_domain(docname: str, compaction: (bool | str)) -&gt;str:</span>
<span class="gi">+        for locale_dir in self._locale_dirs:</span>
<span class="gi">+            locale_dir = path.join(self.basedir, locale_dir)</span>
<span class="gi">+            locale_path = path.join(locale_dir, self.language, &#39;LC_MESSAGES&#39;)</span>
<span class="gi">+            if path.exists(locale_path):</span>
<span class="gi">+                yield locale_dir</span>
<span class="gi">+            else:</span>
<span class="gi">+                logger.verbose(__(&#39;locale_dir %s does not exist&#39;), locale_path)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def pofiles(self) -&gt; Iterator[tuple[str, str]]:</span>
<span class="gi">+        for locale_dir in self.locale_dirs:</span>
<span class="gi">+            basedir = path.join(locale_dir, self.language, &#39;LC_MESSAGES&#39;)</span>
<span class="gi">+            for root, dirnames, filenames in os.walk(basedir):</span>
<span class="gi">+                # skip dot-directories</span>
<span class="gi">+                for dirname in [d for d in dirnames if d.startswith(&#39;.&#39;)]:</span>
<span class="gi">+                    dirnames.remove(dirname)</span>
<span class="gi">+</span>
<span class="gi">+                for filename in filenames:</span>
<span class="gi">+                    if filename.endswith(&#39;.po&#39;):</span>
<span class="gi">+                        fullpath = path.join(root, filename)</span>
<span class="gi">+                        yield basedir, relpath(fullpath, basedir)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def catalogs(self) -&gt; Iterator[CatalogInfo]:</span>
<span class="gi">+        for basedir, filename in self.pofiles:</span>
<span class="gi">+            domain = canon_path(path.splitext(filename)[0])</span>
<span class="gi">+            yield CatalogInfo(basedir, domain, self.encoding)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def docname_to_domain(docname: str, compaction: bool | str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert docname to domain for catalogs.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(compaction, str):</span>
<span class="gi">+        return compaction</span>
<span class="gi">+    if compaction:</span>
<span class="gi">+        return docname.split(SEP, 1)[0]</span>
<span class="gi">+    else:</span>
<span class="gi">+        return docname</span>


<span class="gd">-date_format_mappings = {&#39;%a&#39;: &#39;EEE&#39;, &#39;%A&#39;: &#39;EEEE&#39;, &#39;%b&#39;: &#39;MMM&#39;, &#39;%B&#39;:</span>
<span class="gd">-    &#39;MMMM&#39;, &#39;%c&#39;: &#39;medium&#39;, &#39;%-d&#39;: &#39;d&#39;, &#39;%d&#39;: &#39;dd&#39;, &#39;%-H&#39;: &#39;H&#39;, &#39;%H&#39;: &#39;HH&#39;,</span>
<span class="gd">-    &#39;%-I&#39;: &#39;h&#39;, &#39;%I&#39;: &#39;hh&#39;, &#39;%-j&#39;: &#39;D&#39;, &#39;%j&#39;: &#39;DDD&#39;, &#39;%-m&#39;: &#39;M&#39;, &#39;%m&#39;: &#39;MM&#39;,</span>
<span class="gd">-    &#39;%-M&#39;: &#39;m&#39;, &#39;%M&#39;: &#39;mm&#39;, &#39;%p&#39;: &#39;a&#39;, &#39;%-S&#39;: &#39;s&#39;, &#39;%S&#39;: &#39;ss&#39;, &#39;%U&#39;: &#39;WW&#39;,</span>
<span class="gd">-    &#39;%w&#39;: &#39;e&#39;, &#39;%-W&#39;: &#39;W&#39;, &#39;%W&#39;: &#39;WW&#39;, &#39;%x&#39;: &#39;medium&#39;, &#39;%X&#39;: &#39;medium&#39;, &#39;%y&#39;:</span>
<span class="gd">-    &#39;YY&#39;, &#39;%Y&#39;: &#39;yyyy&#39;, &#39;%Z&#39;: &#39;zzz&#39;, &#39;%z&#39;: &#39;ZZZ&#39;, &#39;%%&#39;: &#39;%&#39;}</span>
<span class="gi">+# date_format mappings: ustrftime() to babel.dates.format_datetime()</span>
<span class="gi">+date_format_mappings = {</span>
<span class="gi">+    &#39;%a&#39;:  &#39;EEE&#39;,     # Weekday as locales abbreviated name.</span>
<span class="gi">+    &#39;%A&#39;:  &#39;EEEE&#39;,    # Weekday as locales full name.</span>
<span class="gi">+    &#39;%b&#39;:  &#39;MMM&#39;,     # Month as locales abbreviated name.</span>
<span class="gi">+    &#39;%B&#39;:  &#39;MMMM&#39;,    # Month as locales full name.</span>
<span class="gi">+    &#39;%c&#39;:  &#39;medium&#39;,  # Locales appropriate date and time representation.</span>
<span class="gi">+    &#39;%-d&#39;: &#39;d&#39;,       # Day of the month as a decimal number.</span>
<span class="gi">+    &#39;%d&#39;:  &#39;dd&#39;,      # Day of the month as a zero-padded decimal number.</span>
<span class="gi">+    &#39;%-H&#39;: &#39;H&#39;,       # Hour (24-hour clock) as a decimal number [0,23].</span>
<span class="gi">+    &#39;%H&#39;:  &#39;HH&#39;,      # Hour (24-hour clock) as a zero-padded decimal number [00,23].</span>
<span class="gi">+    &#39;%-I&#39;: &#39;h&#39;,       # Hour (12-hour clock) as a decimal number [1,12].</span>
<span class="gi">+    &#39;%I&#39;:  &#39;hh&#39;,      # Hour (12-hour clock) as a zero-padded decimal number [01,12].</span>
<span class="gi">+    &#39;%-j&#39;: &#39;D&#39;,       # Day of the year as a decimal number.</span>
<span class="gi">+    &#39;%j&#39;:  &#39;DDD&#39;,     # Day of the year as a zero-padded decimal number.</span>
<span class="gi">+    &#39;%-m&#39;: &#39;M&#39;,       # Month as a decimal number.</span>
<span class="gi">+    &#39;%m&#39;:  &#39;MM&#39;,      # Month as a zero-padded decimal number.</span>
<span class="gi">+    &#39;%-M&#39;: &#39;m&#39;,       # Minute as a decimal number [0,59].</span>
<span class="gi">+    &#39;%M&#39;:  &#39;mm&#39;,      # Minute as a zero-padded decimal number [00,59].</span>
<span class="gi">+    &#39;%p&#39;:  &#39;a&#39;,       # Locales equivalent of either AM or PM.</span>
<span class="gi">+    &#39;%-S&#39;: &#39;s&#39;,       # Second as a decimal number.</span>
<span class="gi">+    &#39;%S&#39;:  &#39;ss&#39;,      # Second as a zero-padded decimal number.</span>
<span class="gi">+    &#39;%U&#39;:  &#39;WW&#39;,      # Week number of the year (Sunday as the first day of the week)</span>
<span class="gi">+                      # as a zero padded decimal number. All days in a new year preceding</span>
<span class="gi">+                      # the first Sunday are considered to be in week 0.</span>
<span class="gi">+    &#39;%w&#39;:  &#39;e&#39;,       # Weekday as a decimal number, where 0 is Sunday and 6 is Saturday.</span>
<span class="gi">+    &#39;%-W&#39;: &#39;W&#39;,       # Week number of the year (Monday as the first day of the week)</span>
<span class="gi">+                      # as a decimal number. All days in a new year preceding the first</span>
<span class="gi">+                      # Monday are considered to be in week 0.</span>
<span class="gi">+    &#39;%W&#39;:  &#39;WW&#39;,      # Week number of the year (Monday as the first day of the week)</span>
<span class="gi">+                      # as a zero-padded decimal number.</span>
<span class="gi">+    &#39;%x&#39;:  &#39;medium&#39;,  # Locales appropriate date representation.</span>
<span class="gi">+    &#39;%X&#39;:  &#39;medium&#39;,  # Locales appropriate time representation.</span>
<span class="gi">+    &#39;%y&#39;:  &#39;YY&#39;,      # Year without century as a zero-padded decimal number.</span>
<span class="gi">+    &#39;%Y&#39;:  &#39;yyyy&#39;,    # Year with century as a decimal number.</span>
<span class="gi">+    &#39;%Z&#39;:  &#39;zzz&#39;,     # Time zone name (no characters if no time zone exists).</span>
<span class="gi">+    &#39;%z&#39;:  &#39;ZZZ&#39;,     # UTC offset in the form HHMM[SS[.ffffff]]</span>
<span class="gi">+                      # (empty string if the object is naive).</span>
<span class="gi">+    &#39;%%&#39;:  &#39;%&#39;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="w"> </span>date_format_re = re.compile(&#39;(%s)&#39; % &#39;|&#39;.join(date_format_mappings))
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def babel_format_date(date: datetime, format: str, locale: str,</span>
<span class="gi">+                      formatter: Formatter = babel.dates.format_date) -&gt; str:</span>
<span class="gi">+    # Check if we have the tzinfo attribute. If not we cannot do any time</span>
<span class="gi">+    # related formats.</span>
<span class="gi">+    if not hasattr(date, &#39;tzinfo&#39;):</span>
<span class="gi">+        formatter = babel.dates.format_date</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return formatter(date, format, locale=locale)</span>
<span class="gi">+    except (ValueError, babel.core.UnknownLocaleError):</span>
<span class="gi">+        # fallback to English</span>
<span class="gi">+        return formatter(date, format, locale=&#39;en&#39;)</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        logger.warning(__(&#39;Invalid date format. Quote the string by single quote &#39;</span>
<span class="gi">+                          &#39;if you want to output it directly: %s&#39;), format)</span>
<span class="gi">+        return format</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def format_date(</span>
<span class="gi">+    format: str, *, date: datetime | None = None, language: str,</span>
<span class="gi">+) -&gt; str:</span>
<span class="gi">+    if date is None:</span>
<span class="gi">+        # If time is not specified, try to use $SOURCE_DATE_EPOCH variable</span>
<span class="gi">+        # See https://wiki.debian.org/ReproducibleBuilds/TimestampsProposal</span>
<span class="gi">+        source_date_epoch = os.getenv(&#39;SOURCE_DATE_EPOCH&#39;)</span>
<span class="gi">+        if source_date_epoch is not None:</span>
<span class="gi">+            date = datetime.fromtimestamp(float(source_date_epoch), tz=timezone.utc)</span>
<span class="gi">+        else:</span>
<span class="gi">+            date = datetime.now(tz=timezone.utc).astimezone()</span>
<span class="gi">+</span>
<span class="gi">+    result = []</span>
<span class="gi">+    tokens = date_format_re.split(format)</span>
<span class="gi">+    for token in tokens:</span>
<span class="gi">+        if token in date_format_mappings:</span>
<span class="gi">+            babel_format = date_format_mappings.get(token, &#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            # Check if we have to use a different babel formatter then</span>
<span class="gi">+            # format_datetime, because we only want to format a date</span>
<span class="gi">+            # or a time.</span>
<span class="gi">+            function: Formatter</span>
<span class="gi">+            if token == &#39;%x&#39;:</span>
<span class="gi">+                function = babel.dates.format_date</span>
<span class="gi">+            elif token == &#39;%X&#39;:</span>
<span class="gi">+                function = babel.dates.format_time</span>
<span class="gi">+            else:</span>
<span class="gi">+                function = babel.dates.format_datetime</span>
<span class="gi">+</span>
<span class="gi">+            result.append(babel_format_date(date, babel_format, locale=language,</span>
<span class="gi">+                                            formatter=function))</span>
<span class="gi">+        else:</span>
<span class="gi">+            result.append(token)</span>
<span class="gi">+</span>
<span class="gi">+    return &quot;&quot;.join(result)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_image_filename_for_language(</span>
<span class="gi">+    filename: str | os.PathLike[str],</span>
<span class="gi">+    env: BuildEnvironment,</span>
<span class="gi">+) -&gt; str:</span>
<span class="gi">+    root, ext = path.splitext(filename)</span>
<span class="gi">+    dirname = path.dirname(root)</span>
<span class="gi">+    docpath = path.dirname(env.docname)</span>
<span class="gi">+    try:</span>
<span class="gi">+        return env.config.figure_language_filename.format(</span>
<span class="gi">+            root=root,</span>
<span class="gi">+            ext=ext,</span>
<span class="gi">+            path=dirname and dirname + SEP,</span>
<span class="gi">+            basename=path.basename(root),</span>
<span class="gi">+            docpath=docpath and docpath + SEP,</span>
<span class="gi">+            language=env.config.language,</span>
<span class="gi">+        )</span>
<span class="gi">+    except KeyError as exc:</span>
<span class="gi">+        msg = f&#39;Invalid figure_language_filename: {exc!r}&#39;</span>
<span class="gi">+        raise SphinxError(msg) from exc</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def search_image_for_language(filename: str, env: BuildEnvironment) -&gt; str:</span>
<span class="gi">+    translated = get_image_filename_for_language(filename, env)</span>
<span class="gi">+    _, abspath = env.relfn2path(translated)</span>
<span class="gi">+    if path.exists(abspath):</span>
<span class="gi">+        return translated</span>
<span class="gi">+    else:</span>
<span class="gi">+        return filename</span>
<span class="gh">diff --git a/sphinx/util/images.py b/sphinx/util/images.py</span>
<span class="gh">index 06f78c23a..70735c6cf 100644</span>
<span class="gd">--- a/sphinx/util/images.py</span>
<span class="gi">+++ b/sphinx/util/images.py</span>
<span class="gu">@@ -1,20 +1,32 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Image utility functions for Sphinx.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import base64
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING, NamedTuple, overload
<span class="gi">+</span>
<span class="w"> </span>import imagesize
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from os import PathLike
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    from PIL import Image
<span class="w"> </span>    PILLOW_AVAILABLE = True
<span class="w"> </span>except ImportError:
<span class="w"> </span>    PILLOW_AVAILABLE = False
<span class="gd">-mime_suffixes = {&#39;.gif&#39;: &#39;image/gif&#39;, &#39;.jpg&#39;: &#39;image/jpeg&#39;, &#39;.png&#39;:</span>
<span class="gd">-    &#39;image/png&#39;, &#39;.pdf&#39;: &#39;application/pdf&#39;, &#39;.svg&#39;: &#39;image/svg+xml&#39;,</span>
<span class="gd">-    &#39;.svgz&#39;: &#39;image/svg+xml&#39;, &#39;.ai&#39;: &#39;application/illustrator&#39;, &#39;.webp&#39;:</span>
<span class="gd">-    &#39;image/webp&#39;}</span>
<span class="gi">+</span>
<span class="gi">+mime_suffixes = {</span>
<span class="gi">+    &#39;.gif&#39;: &#39;image/gif&#39;,</span>
<span class="gi">+    &#39;.jpg&#39;: &#39;image/jpeg&#39;,</span>
<span class="gi">+    &#39;.png&#39;: &#39;image/png&#39;,</span>
<span class="gi">+    &#39;.pdf&#39;: &#39;application/pdf&#39;,</span>
<span class="gi">+    &#39;.svg&#39;: &#39;image/svg+xml&#39;,</span>
<span class="gi">+    &#39;.svgz&#39;: &#39;image/svg+xml&#39;,</span>
<span class="gi">+    &#39;.ai&#39;: &#39;application/illustrator&#39;,</span>
<span class="gi">+    &#39;.webp&#39;: &#39;image/webp&#39;,</span>
<span class="gi">+}</span>
<span class="w"> </span>_suffix_from_mime = {v: k for k, v in reversed(mime_suffixes.items())}


<span class="gu">@@ -22,3 +34,115 @@ class DataURI(NamedTuple):</span>
<span class="w"> </span>    mimetype: str
<span class="w"> </span>    charset: str
<span class="w"> </span>    data: bytes
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_image_size(filename: str) -&gt; tuple[int, int] | None:</span>
<span class="gi">+    try:</span>
<span class="gi">+        size = imagesize.get(filename)</span>
<span class="gi">+        if size[0] == -1:</span>
<span class="gi">+            size = None</span>
<span class="gi">+        elif isinstance(size[0], float) or isinstance(size[1], float):</span>
<span class="gi">+            size = (int(size[0]), int(size[1]))</span>
<span class="gi">+</span>
<span class="gi">+        if size is None and PILLOW_AVAILABLE:  # fallback to Pillow</span>
<span class="gi">+            with Image.open(filename) as im:</span>
<span class="gi">+                size = im.size</span>
<span class="gi">+</span>
<span class="gi">+        return size</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def guess_mimetype(filename: PathLike[str] | str, default: str) -&gt; str:</span>
<span class="gi">+    ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@overload</span>
<span class="gi">+def guess_mimetype(filename: PathLike[str] | str, default: None = None) -&gt; str | None:</span>
<span class="gi">+    ...</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def guess_mimetype(</span>
<span class="gi">+    filename: PathLike[str] | str = &#39;&#39;,</span>
<span class="gi">+    default: str | None = None,</span>
<span class="gi">+) -&gt; str | None:</span>
<span class="gi">+    ext = path.splitext(filename)[1].lower()</span>
<span class="gi">+    if ext in mime_suffixes:</span>
<span class="gi">+        return mime_suffixes[ext]</span>
<span class="gi">+    if path.exists(filename):</span>
<span class="gi">+        try:</span>
<span class="gi">+            imgtype = _image_type_from_file(filename)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;image/&#39; + imgtype</span>
<span class="gi">+    return default</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_image_extension(mimetype: str) -&gt; str | None:</span>
<span class="gi">+    return _suffix_from_mime.get(mimetype)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_data_uri(uri: str) -&gt; DataURI | None:</span>
<span class="gi">+    if not uri.startswith(&#39;data:&#39;):</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    # data:[&lt;MIME-type&gt;][;charset=&lt;encoding&gt;][;base64],&lt;data&gt;</span>
<span class="gi">+    mimetype = &#39;text/plain&#39;</span>
<span class="gi">+    charset = &#39;US-ASCII&#39;</span>
<span class="gi">+</span>
<span class="gi">+    properties, data = uri[5:].split(&#39;,&#39;, 1)</span>
<span class="gi">+    for prop in properties.split(&#39;;&#39;):</span>
<span class="gi">+        if prop == &#39;base64&#39;:</span>
<span class="gi">+            pass  # skip</span>
<span class="gi">+        elif prop.startswith(&#39;charset=&#39;):</span>
<span class="gi">+            charset = prop[8:]</span>
<span class="gi">+        elif prop:</span>
<span class="gi">+            mimetype = prop</span>
<span class="gi">+</span>
<span class="gi">+    image_data = base64.b64decode(data)</span>
<span class="gi">+    return DataURI(mimetype, charset, image_data)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _image_type_from_file(filename: PathLike[str] | str) -&gt; str:</span>
<span class="gi">+    with open(filename, &#39;rb&#39;) as f:</span>
<span class="gi">+        header = f.read(32)  # 32 bytes</span>
<span class="gi">+</span>
<span class="gi">+    # Bitmap</span>
<span class="gi">+    # https://en.wikipedia.org/wiki/BMP_file_format#Bitmap_file_header</span>
<span class="gi">+    if header.startswith(b&#39;BM&#39;):</span>
<span class="gi">+        return &#39;bmp&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # GIF</span>
<span class="gi">+    # https://en.wikipedia.org/wiki/GIF#File_format</span>
<span class="gi">+    if header.startswith((b&#39;GIF87a&#39;, b&#39;GIF89a&#39;)):</span>
<span class="gi">+        return &#39;gif&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # JPEG data</span>
<span class="gi">+    # https://en.wikipedia.org/wiki/JPEG_File_Interchange_Format#File_format_structure</span>
<span class="gi">+    if header.startswith(b&#39;\xFF\xD8&#39;):</span>
<span class="gi">+        return &#39;jpeg&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # Portable Network Graphics</span>
<span class="gi">+    # https://en.wikipedia.org/wiki/PNG#File_header</span>
<span class="gi">+    if header.startswith(b&#39;\x89PNG\r\n\x1A\n&#39;):</span>
<span class="gi">+        return &#39;png&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # Scalable Vector Graphics</span>
<span class="gi">+    # https://svgwg.org/svg2-draft/struct.html</span>
<span class="gi">+    if b&#39;&lt;svg&#39; in header.lower():</span>
<span class="gi">+        return &#39;svg+xml&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # TIFF</span>
<span class="gi">+    # https://en.wikipedia.org/wiki/TIFF#Byte_order</span>
<span class="gi">+    if header.startswith((b&#39;MM&#39;, b&#39;II&#39;)):</span>
<span class="gi">+        return &#39;tiff&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # WebP</span>
<span class="gi">+    # https://en.wikipedia.org/wiki/WebP#Technology</span>
<span class="gi">+    if header.startswith(b&#39;RIFF&#39;) and header[8:12] == b&#39;WEBP&#39;:</span>
<span class="gi">+        return &#39;webp&#39;</span>
<span class="gi">+</span>
<span class="gi">+    msg = &#39;Could not detect image type!&#39;</span>
<span class="gi">+    raise ValueError(msg)</span>
<span class="gh">diff --git a/sphinx/util/index_entries.py b/sphinx/util/index_entries.py</span>
<span class="gh">index 56ebb9a85..100468429 100644</span>
<span class="gd">--- a/sphinx/util/index_entries.py</span>
<span class="gi">+++ b/sphinx/util/index_entries.py</span>
<span class="gu">@@ -1,6 +1,27 @@</span>
<span class="w"> </span>from __future__ import annotations


<span class="gd">-def _split_into(n: int, type: str, value: str) -&gt;list[str]:</span>
<span class="gi">+def split_index_msg(entry_type: str, value: str) -&gt; list[str]:</span>
<span class="gi">+    # new entry types must be listed in util/nodes.py!</span>
<span class="gi">+    if entry_type == &#39;single&#39;:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return _split_into(2, &#39;single&#39;, value)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            return _split_into(1, &#39;single&#39;, value)</span>
<span class="gi">+    if entry_type == &#39;pair&#39;:</span>
<span class="gi">+        return _split_into(2, &#39;pair&#39;, value)</span>
<span class="gi">+    if entry_type == &#39;triple&#39;:</span>
<span class="gi">+        return _split_into(3, &#39;triple&#39;, value)</span>
<span class="gi">+    if entry_type in {&#39;see&#39;, &#39;seealso&#39;}:</span>
<span class="gi">+        return _split_into(2, &#39;see&#39;, value)</span>
<span class="gi">+    msg = f&#39;invalid {entry_type} index entry {value!r}&#39;</span>
<span class="gi">+    raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _split_into(n: int, type: str, value: str) -&gt; list[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Split an index entry into a given number of parts at semicolons.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parts = [x.strip() for x in value.split(&#39;;&#39;, n - 1)]</span>
<span class="gi">+    if len(list(filter(None, parts))) &lt; n:</span>
<span class="gi">+        msg = f&#39;invalid {type} index entry {value!r}&#39;</span>
<span class="gi">+        raise ValueError(msg)</span>
<span class="gi">+    return parts</span>
<span class="gh">diff --git a/sphinx/util/inspect.py b/sphinx/util/inspect.py</span>
<span class="gh">index 5e7c1ae78..096da877c 100644</span>
<span class="gd">--- a/sphinx/util/inspect.py</span>
<span class="gi">+++ b/sphinx/util/inspect.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Helpers for inspecting Python modules.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import ast
<span class="w"> </span>import builtins
<span class="w"> </span>import contextlib
<span class="gu">@@ -16,40 +18,51 @@ from inspect import Parameter, Signature</span>
<span class="w"> </span>from io import StringIO
<span class="w"> </span>from types import ClassMethodDescriptorType, MethodDescriptorType, WrapperDescriptorType
<span class="w"> </span>from typing import TYPE_CHECKING, Any, ForwardRef
<span class="gi">+</span>
<span class="w"> </span>from sphinx.pycode.ast import unparse as ast_unparse
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.typing import stringify_annotation
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Callable, Sequence
<span class="w"> </span>    from inspect import _ParameterKind
<span class="w"> </span>    from types import MethodType, ModuleType
<span class="w"> </span>    from typing import Final, Protocol, TypeAlias
<span class="gd">-    from typing_extensions import TypeIs</span>

<span class="gi">+    from typing_extensions import TypeIs</span>

<span class="w"> </span>    class _SupportsGet(Protocol):
<span class="gd">-</span>
<span class="gd">-        def __get__(self, __instance: Any, __owner: (type | None)=...) -&gt;Any:</span>
<span class="gd">-            ...</span>
<span class="gd">-</span>
<span class="gi">+        def __get__(self, __instance: Any, __owner: type | None = ...) -&gt; Any: ...  # NoQA: E704</span>

<span class="w"> </span>    class _SupportsSet(Protocol):
<span class="gd">-</span>
<span class="gd">-        def __set__(self, __instance: Any, __value: Any) -&gt;None:</span>
<span class="gd">-            ...</span>
<span class="gd">-</span>
<span class="gi">+        # instance and value are contravariants but we do not need that precision</span>
<span class="gi">+        def __set__(self, __instance: Any, __value: Any) -&gt; None: ...  # NoQA: E704</span>

<span class="w"> </span>    class _SupportsDelete(Protocol):
<span class="gi">+        # instance is contravariant but we do not need that precision</span>
<span class="gi">+        def __delete__(self, __instance: Any) -&gt; None: ...  # NoQA: E704</span>
<span class="gi">+</span>
<span class="gi">+    _RoutineType: TypeAlias = (</span>
<span class="gi">+        types.FunctionType</span>
<span class="gi">+        | types.LambdaType</span>
<span class="gi">+        | types.MethodType</span>
<span class="gi">+        | types.BuiltinFunctionType</span>
<span class="gi">+        | types.BuiltinMethodType</span>
<span class="gi">+        | types.WrapperDescriptorType</span>
<span class="gi">+        | types.MethodDescriptorType</span>
<span class="gi">+        | types.ClassMethodDescriptorType</span>
<span class="gi">+    )</span>
<span class="gi">+    _SignatureType: TypeAlias = (</span>
<span class="gi">+        Callable[..., Any]</span>
<span class="gi">+        | staticmethod</span>
<span class="gi">+        | classmethod</span>
<span class="gi">+    )</span>

<span class="gd">-        def __delete__(self, __instance: Any) -&gt;None:</span>
<span class="gd">-            ...</span>
<span class="gd">-    _RoutineType: TypeAlias = (types.FunctionType | types.LambdaType |</span>
<span class="gd">-        types.MethodType | types.BuiltinFunctionType | types.</span>
<span class="gd">-        BuiltinMethodType | types.WrapperDescriptorType | types.</span>
<span class="gd">-        MethodDescriptorType | types.ClassMethodDescriptorType)</span>
<span class="gd">-    _SignatureType: TypeAlias = Callable[..., Any] | staticmethod | classmethod</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gd">-memory_address_re = re.compile(&#39; at 0x[0-9a-f]{8,16}(?=&gt;)&#39;, re.IGNORECASE)</span>
<span class="gi">+</span>
<span class="gi">+memory_address_re = re.compile(r&#39; at 0x[0-9a-f]{8,16}(?=&gt;)&#39;, re.IGNORECASE)</span>
<span class="gi">+</span>
<span class="gi">+# re-export as is</span>
<span class="w"> </span>isasyncgenfunction = inspect.isasyncgenfunction
<span class="w"> </span>ismethod = inspect.ismethod
<span class="w"> </span>ismethoddescriptor = inspect.ismethoddescriptor
<span class="gu">@@ -57,15 +70,23 @@ isclass = inspect.isclass</span>
<span class="w"> </span>ismodule = inspect.ismodule


<span class="gd">-def unwrap(obj: Any) -&gt;Any:</span>
<span class="gi">+def unwrap(obj: Any) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get an original object from wrapped object (wrapped functions).

<span class="w"> </span>    Mocked objects are returned as is.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if hasattr(obj, &#39;__sphinx_mock__&#39;):</span>
<span class="gi">+        # Skip unwrapping mock object to avoid RecursionError</span>
<span class="gi">+        return obj</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return inspect.unwrap(obj)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        # might be a mock object</span>
<span class="gi">+        return obj</span>


<span class="gd">-def unwrap_all(obj: Any, *, stop: (Callable[[Any], bool] | None)=None) -&gt;Any:</span>
<span class="gi">+def unwrap_all(obj: Any, *, stop: Callable[[Any], bool] | None = None) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get an original object from wrapped object.

<span class="w"> </span>    Unlike :func:`unwrap`, this unwraps partial functions, wrapped functions,
<span class="gu">@@ -74,194 +95,395 @@ def unwrap_all(obj: Any, *, stop: (Callable[[Any], bool] | None)=None) -&gt;Any:</span>
<span class="w"> </span>    When specified, *stop* is a predicate indicating whether an object should
<span class="w"> </span>    be unwrapped or not.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if callable(stop):</span>
<span class="gi">+        while not stop(obj):</span>
<span class="gi">+            if ispartial(obj):</span>
<span class="gi">+                obj = obj.func</span>
<span class="gi">+            elif inspect.isroutine(obj) and hasattr(obj, &#39;__wrapped__&#39;):</span>
<span class="gi">+                obj = obj.__wrapped__</span>
<span class="gi">+            elif isclassmethod(obj) or isstaticmethod(obj):</span>
<span class="gi">+                obj = obj.__func__</span>
<span class="gi">+            else:</span>
<span class="gi">+                return obj</span>
<span class="gi">+        return obj  # in case the while loop never starts</span>
<span class="gi">+</span>
<span class="gi">+    while True:</span>
<span class="gi">+        if ispartial(obj):</span>
<span class="gi">+            obj = obj.func</span>
<span class="gi">+        elif inspect.isroutine(obj) and hasattr(obj, &#39;__wrapped__&#39;):</span>
<span class="gi">+            obj = obj.__wrapped__</span>
<span class="gi">+        elif isclassmethod(obj) or isstaticmethod(obj):</span>
<span class="gi">+            obj = obj.__func__</span>
<span class="gi">+        else:</span>
<span class="gi">+            return obj</span>


<span class="gd">-def getall(obj: Any) -&gt;(Sequence[str] | None):</span>
<span class="gi">+def getall(obj: Any) -&gt; Sequence[str] | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the ``__all__`` attribute of an object as a sequence.

<span class="w"> </span>    This returns ``None`` if the given ``obj.__all__`` does not exist and
<span class="w"> </span>    raises :exc:`ValueError` if ``obj.__all__`` is not a list or tuple of
<span class="w"> </span>    strings.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    __all__ = safe_getattr(obj, &#39;__all__&#39;, None)</span>
<span class="gi">+    if __all__ is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    if isinstance(__all__, list | tuple) and all(isinstance(e, str) for e in __all__):</span>
<span class="gi">+        return __all__</span>
<span class="gi">+    raise ValueError(__all__)</span>


<span class="gd">-def getannotations(obj: Any) -&gt;Mapping[str, Any]:</span>
<span class="gi">+def getannotations(obj: Any) -&gt; Mapping[str, Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Safely get the ``__annotations__`` attribute of an object.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    __annotations__ = safe_getattr(obj, &#39;__annotations__&#39;, None)</span>
<span class="gi">+    if isinstance(__annotations__, Mapping):</span>
<span class="gi">+        return __annotations__</span>
<span class="gi">+    return {}</span>


<span class="gd">-def getglobals(obj: Any) -&gt;Mapping[str, Any]:</span>
<span class="gi">+def getglobals(obj: Any) -&gt; Mapping[str, Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Safely get :attr:`obj.__globals__ &lt;function.__globals__&gt;`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    __globals__ = safe_getattr(obj, &#39;__globals__&#39;, None)</span>
<span class="gi">+    if isinstance(__globals__, Mapping):</span>
<span class="gi">+        return __globals__</span>
<span class="gi">+    return {}</span>


<span class="gd">-def getmro(obj: Any) -&gt;tuple[type, ...]:</span>
<span class="gi">+def getmro(obj: Any) -&gt; tuple[type, ...]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Safely get :attr:`obj.__mro__ &lt;class.__mro__&gt;`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    __mro__ = safe_getattr(obj, &#39;__mro__&#39;, None)</span>
<span class="gi">+    if isinstance(__mro__, tuple):</span>
<span class="gi">+        return __mro__</span>
<span class="gi">+    return ()</span>


<span class="gd">-def getorigbases(obj: Any) -&gt;(tuple[Any, ...] | None):</span>
<span class="gi">+def getorigbases(obj: Any) -&gt; tuple[Any, ...] | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Safely get ``obj.__orig_bases__``.

<span class="w"> </span>    This returns ``None`` if the object is not a class or if ``__orig_bases__``
<span class="w"> </span>    is not well-defined (e.g., a non-tuple object or an empty sequence).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isclass(obj):</span>
<span class="gi">+        return None</span>

<span class="gi">+    # Get __orig_bases__ from obj.__dict__ to avoid accessing the parent&#39;s __orig_bases__.</span>
<span class="gi">+    # refs: https://github.com/sphinx-doc/sphinx/issues/9607</span>
<span class="gi">+    __dict__ = safe_getattr(obj, &#39;__dict__&#39;, {})</span>
<span class="gi">+    __orig_bases__ = __dict__.get(&#39;__orig_bases__&#39;)</span>
<span class="gi">+    if isinstance(__orig_bases__, tuple) and len(__orig_bases__) &gt; 0:</span>
<span class="gi">+        return __orig_bases__</span>
<span class="gi">+    return None</span>

<span class="gd">-def getslots(obj: Any) -&gt;(dict[str, Any] | dict[str, None] | None):</span>
<span class="gi">+</span>
<span class="gi">+def getslots(obj: Any) -&gt; dict[str, Any] | dict[str, None] | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Safely get :term:`obj.__slots__ &lt;__slots__&gt;` as a dictionary if any.

<span class="w"> </span>    - This returns ``None`` if ``obj.__slots__`` does not exist.
<span class="w"> </span>    - This raises a :exc:`TypeError` if *obj* is not a class.
<span class="w"> </span>    - This raises a :exc:`ValueError` if ``obj.__slots__`` is invalid.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def isenumclass(x: Any) -&gt;TypeIs[type[enum.Enum]]:</span>
<span class="gi">+    if not isclass(obj):</span>
<span class="gi">+        raise TypeError</span>
<span class="gi">+</span>
<span class="gi">+    __slots__ = safe_getattr(obj, &#39;__slots__&#39;, None)</span>
<span class="gi">+    if __slots__ is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    elif isinstance(__slots__, dict):</span>
<span class="gi">+        return __slots__</span>
<span class="gi">+    elif isinstance(__slots__, str):</span>
<span class="gi">+        return {__slots__: None}</span>
<span class="gi">+    elif isinstance(__slots__, list | tuple):</span>
<span class="gi">+        return dict.fromkeys(__slots__)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def isenumclass(x: Any) -&gt; TypeIs[type[enum.Enum]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the object is an :class:`enumeration class &lt;enum.Enum&gt;`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isclass(x) and issubclass(x, enum.Enum)</span>


<span class="gd">-def isenumattribute(x: Any) -&gt;TypeIs[enum.Enum]:</span>
<span class="gi">+def isenumattribute(x: Any) -&gt; TypeIs[enum.Enum]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the object is an enumeration attribute.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(x, enum.Enum)</span>


<span class="gd">-def unpartial(obj: Any) -&gt;Any:</span>
<span class="gi">+def unpartial(obj: Any) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get an original object from a partial-like object.

<span class="w"> </span>    If *obj* is not a partial object, it is returned as is.

<span class="w"> </span>    .. seealso:: :func:`ispartial`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    while ispartial(obj):</span>
<span class="gi">+        obj = obj.func</span>
<span class="gi">+    return obj</span>


<span class="gd">-def ispartial(obj: Any) -&gt;TypeIs[partial | partialmethod]:</span>
<span class="gi">+def ispartial(obj: Any) -&gt; TypeIs[partial | partialmethod]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the object is a partial function or method.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(obj, partial | partialmethod)</span>


<span class="gd">-def isclassmethod(obj: Any, cls: Any=None, name: (str | None)=None) -&gt;TypeIs[</span>
<span class="gd">-    classmethod]:</span>
<span class="gi">+def isclassmethod(</span>
<span class="gi">+    obj: Any,</span>
<span class="gi">+    cls: Any = None,</span>
<span class="gi">+    name: str | None = None,</span>
<span class="gi">+) -&gt; TypeIs[classmethod]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the object is a :class:`classmethod`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def isstaticmethod(obj: Any, cls: Any=None, name: (str | None)=None) -&gt;TypeIs[</span>
<span class="gd">-    staticmethod]:</span>
<span class="gi">+    if isinstance(obj, classmethod):</span>
<span class="gi">+        return True</span>
<span class="gi">+    if ismethod(obj) and obj.__self__ is not None and isclass(obj.__self__):</span>
<span class="gi">+        return True</span>
<span class="gi">+    if cls and name:</span>
<span class="gi">+        # trace __mro__ if the method is defined in parent class</span>
<span class="gi">+        sentinel = object()</span>
<span class="gi">+        for basecls in getmro(cls):</span>
<span class="gi">+            meth = basecls.__dict__.get(name, sentinel)</span>
<span class="gi">+            if meth is not sentinel:</span>
<span class="gi">+                return isclassmethod(meth)</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def isstaticmethod(</span>
<span class="gi">+    obj: Any,</span>
<span class="gi">+    cls: Any = None,</span>
<span class="gi">+    name: str | None = None,</span>
<span class="gi">+) -&gt; TypeIs[staticmethod]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the object is a :class:`staticmethod`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def isdescriptor(x: Any) -&gt;TypeIs[_SupportsGet | _SupportsSet | _SupportsDelete</span>
<span class="gd">-    ]:</span>
<span class="gi">+    if isinstance(obj, staticmethod):</span>
<span class="gi">+        return True</span>
<span class="gi">+    if cls and name:</span>
<span class="gi">+        # trace __mro__ if the method is defined in parent class</span>
<span class="gi">+        sentinel = object()</span>
<span class="gi">+        for basecls in getattr(cls, &#39;__mro__&#39;, [cls]):</span>
<span class="gi">+            meth = basecls.__dict__.get(name, sentinel)</span>
<span class="gi">+            if meth is not sentinel:</span>
<span class="gi">+                return isinstance(meth, staticmethod)</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def isdescriptor(x: Any) -&gt; TypeIs[_SupportsGet | _SupportsSet | _SupportsDelete]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the object is a :external+python:term:`descriptor`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return any(</span>
<span class="gi">+        callable(safe_getattr(x, item, None)) for item in (&#39;__get__&#39;, &#39;__set__&#39;, &#39;__delete__&#39;)</span>
<span class="gi">+    )</span>


<span class="gd">-def isabstractmethod(obj: Any) -&gt;bool:</span>
<span class="gi">+def isabstractmethod(obj: Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the object is an :func:`abstractmethod`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return safe_getattr(obj, &#39;__isabstractmethod__&#39;, False) is True</span>


<span class="gd">-def isboundmethod(method: MethodType) -&gt;bool:</span>
<span class="gi">+def isboundmethod(method: MethodType) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the method is a bound method.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return safe_getattr(method, &#39;__self__&#39;, None) is not None</span>


<span class="gd">-def is_cython_function_or_method(obj: Any) -&gt;bool:</span>
<span class="gi">+def is_cython_function_or_method(obj: Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the object is a function or method in cython.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return obj.__class__.__name__ == &#39;cython_function_or_method&#39;</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        return False</span>


<span class="gd">-_DESCRIPTOR_LIKE: Final[tuple[type, ...]] = (ClassMethodDescriptorType,</span>
<span class="gd">-    MethodDescriptorType, WrapperDescriptorType)</span>
<span class="gi">+_DESCRIPTOR_LIKE: Final[tuple[type, ...]] = (</span>
<span class="gi">+    ClassMethodDescriptorType,</span>
<span class="gi">+    MethodDescriptorType,</span>
<span class="gi">+    WrapperDescriptorType,</span>
<span class="gi">+)</span>


<span class="gd">-def isattributedescriptor(obj: Any) -&gt;bool:</span>
<span class="gi">+def isattributedescriptor(obj: Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the object is an attribute-like descriptor.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def is_singledispatch_function(obj: Any) -&gt;bool:</span>
<span class="gi">+    if inspect.isdatadescriptor(obj):</span>
<span class="gi">+        # data descriptor is kind of attribute</span>
<span class="gi">+        return True</span>
<span class="gi">+    if isdescriptor(obj):</span>
<span class="gi">+        # non data descriptor</span>
<span class="gi">+        unwrapped = unwrap(obj)</span>
<span class="gi">+        if isfunction(unwrapped) or isbuiltin(unwrapped) or ismethod(unwrapped):</span>
<span class="gi">+            # attribute must not be either function, builtin and method</span>
<span class="gi">+            return False</span>
<span class="gi">+        if is_cython_function_or_method(unwrapped):</span>
<span class="gi">+            # attribute must not be either function and method (for cython)</span>
<span class="gi">+            return False</span>
<span class="gi">+        if isclass(unwrapped):</span>
<span class="gi">+            # attribute must not be a class</span>
<span class="gi">+            return False</span>
<span class="gi">+        if isinstance(unwrapped, _DESCRIPTOR_LIKE):</span>
<span class="gi">+            # attribute must not be a method descriptor</span>
<span class="gi">+            return False</span>
<span class="gi">+        # attribute must not be an instancemethod (C-API)</span>
<span class="gi">+        return type(unwrapped).__name__ != &#39;instancemethod&#39;</span>
<span class="gi">+    return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_singledispatch_function(obj: Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the object is a :func:`~functools.singledispatch` function.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (</span>
<span class="gi">+        inspect.isfunction(obj)</span>
<span class="gi">+        and hasattr(obj, &#39;dispatch&#39;)</span>
<span class="gi">+        and hasattr(obj, &#39;register&#39;)</span>
<span class="gi">+        and obj.dispatch.__module__ == &#39;functools&#39;</span>
<span class="gi">+    )</span>


<span class="gd">-def is_singledispatch_method(obj: Any) -&gt;TypeIs[singledispatchmethod]:</span>
<span class="gi">+def is_singledispatch_method(obj: Any) -&gt; TypeIs[singledispatchmethod]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the object is a :class:`~functools.singledispatchmethod`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(obj, singledispatchmethod)</span>


<span class="gd">-def isfunction(obj: Any) -&gt;TypeIs[types.FunctionType]:</span>
<span class="gi">+def isfunction(obj: Any) -&gt; TypeIs[types.FunctionType]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the object is a user-defined function.

<span class="w"> </span>    Partial objects are unwrapped before checking them.

<span class="w"> </span>    .. seealso:: :external+python:func:`inspect.isfunction`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return inspect.isfunction(unpartial(obj))</span>


<span class="gd">-def isbuiltin(obj: Any) -&gt;TypeIs[types.BuiltinFunctionType]:</span>
<span class="gi">+def isbuiltin(obj: Any) -&gt; TypeIs[types.BuiltinFunctionType]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the object is a built-in function or method.

<span class="w"> </span>    Partial objects are unwrapped before checking them.

<span class="w"> </span>    .. seealso:: :external+python:func:`inspect.isbuiltin`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return inspect.isbuiltin(unpartial(obj))</span>


<span class="gd">-def isroutine(obj: Any) -&gt;TypeIs[_RoutineType]:</span>
<span class="gi">+def isroutine(obj: Any) -&gt; TypeIs[_RoutineType]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the object is a kind of function or method.

<span class="w"> </span>    Partial objects are unwrapped before checking them.

<span class="w"> </span>    .. seealso:: :external+python:func:`inspect.isroutine`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return inspect.isroutine(unpartial(obj))</span>


<span class="gd">-def iscoroutinefunction(obj: Any) -&gt;TypeIs[Callable[..., types.CoroutineType]]:</span>
<span class="gi">+def iscoroutinefunction(obj: Any) -&gt; TypeIs[Callable[..., types.CoroutineType]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the object is a :external+python:term:`coroutine` function.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    obj = unwrap_all(obj, stop=_is_wrapped_coroutine)</span>
<span class="gi">+    return inspect.iscoroutinefunction(obj)</span>


<span class="gd">-def _is_wrapped_coroutine(obj: Any) -&gt;bool:</span>
<span class="gi">+def _is_wrapped_coroutine(obj: Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the object is wrapped coroutine-function.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isstaticmethod(obj) or isclassmethod(obj) or ispartial(obj):</span>
<span class="gi">+        # staticmethod, classmethod and partial method are not a wrapped coroutine-function</span>
<span class="gi">+        # Note: Since 3.10, staticmethod and classmethod becomes a kind of wrappers</span>
<span class="gi">+        return False</span>
<span class="gi">+    return hasattr(obj, &#39;__wrapped__&#39;)</span>


<span class="gd">-def isproperty(obj: Any) -&gt;TypeIs[property | cached_property]:</span>
<span class="gi">+def isproperty(obj: Any) -&gt; TypeIs[property | cached_property]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the object is property (possibly cached).&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(obj, property | cached_property)</span>


<span class="gd">-def isgenericalias(obj: Any) -&gt;TypeIs[types.GenericAlias]:</span>
<span class="gi">+def isgenericalias(obj: Any) -&gt; TypeIs[types.GenericAlias]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the object is a generic alias.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(obj, types.GenericAlias | typing._BaseGenericAlias)  # type: ignore[attr-defined]</span>


<span class="gd">-def safe_getattr(obj: Any, name: str, *defargs: Any) -&gt;Any:</span>
<span class="gi">+def safe_getattr(obj: Any, name: str, *defargs: Any) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;A getattr() that turns all exceptions into AttributeErrors.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def object_description(obj: Any, *, _seen: frozenset[int]=frozenset()) -&gt;str:</span>
<span class="gi">+    try:</span>
<span class="gi">+        return getattr(obj, name, *defargs)</span>
<span class="gi">+    except Exception as exc:</span>
<span class="gi">+        # sometimes accessing a property raises an exception (e.g.</span>
<span class="gi">+        # NotImplementedError), so let&#39;s try to read the attribute directly</span>
<span class="gi">+        try:</span>
<span class="gi">+            # In case the object does weird things with attribute access</span>
<span class="gi">+            # such that accessing `obj.__dict__` may raise an exception</span>
<span class="gi">+            return obj.__dict__[name]</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        # this is a catch-all for all the weird things that some modules do</span>
<span class="gi">+        # with attribute access</span>
<span class="gi">+        if defargs:</span>
<span class="gi">+            return defargs[0]</span>
<span class="gi">+</span>
<span class="gi">+        raise AttributeError(name) from exc</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def object_description(obj: Any, *, _seen: frozenset[int] = frozenset()) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;A repr() implementation that returns text safe to use in reST context.

<span class="w"> </span>    Maintains a set of &#39;seen&#39; object IDs to detect and avoid infinite recursion.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def is_builtin_class_method(obj: Any, attr_name: str) -&gt;bool:</span>
<span class="gi">+    seen = _seen</span>
<span class="gi">+    if isinstance(obj, dict):</span>
<span class="gi">+        if id(obj) in seen:</span>
<span class="gi">+            return &#39;dict(...)&#39;</span>
<span class="gi">+        seen |= {id(obj)}</span>
<span class="gi">+        try:</span>
<span class="gi">+            sorted_keys = sorted(obj)</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            # Cannot sort dict keys, fall back to using descriptions as a sort key</span>
<span class="gi">+            sorted_keys = sorted(obj, key=lambda k: object_description(k, _seen=seen))</span>
<span class="gi">+</span>
<span class="gi">+        items = (</span>
<span class="gi">+            (object_description(key, _seen=seen), object_description(obj[key], _seen=seen))</span>
<span class="gi">+            for key in sorted_keys</span>
<span class="gi">+        )</span>
<span class="gi">+        return &#39;{%s}&#39; % &#39;, &#39;.join(f&#39;{key}: {value}&#39; for (key, value) in items)</span>
<span class="gi">+    elif isinstance(obj, set):</span>
<span class="gi">+        if id(obj) in seen:</span>
<span class="gi">+            return &#39;set(...)&#39;</span>
<span class="gi">+        seen |= {id(obj)}</span>
<span class="gi">+        try:</span>
<span class="gi">+            sorted_values = sorted(obj)</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            # Cannot sort set values, fall back to using descriptions as a sort key</span>
<span class="gi">+            sorted_values = sorted(obj, key=lambda x: object_description(x, _seen=seen))</span>
<span class="gi">+        return &#39;{%s}&#39; % &#39;, &#39;.join(object_description(x, _seen=seen) for x in sorted_values)</span>
<span class="gi">+    elif isinstance(obj, frozenset):</span>
<span class="gi">+        if id(obj) in seen:</span>
<span class="gi">+            return &#39;frozenset(...)&#39;</span>
<span class="gi">+        seen |= {id(obj)}</span>
<span class="gi">+        try:</span>
<span class="gi">+            sorted_values = sorted(obj)</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            # Cannot sort frozenset values, fall back to using descriptions as a sort key</span>
<span class="gi">+            sorted_values = sorted(obj, key=lambda x: object_description(x, _seen=seen))</span>
<span class="gi">+        return &#39;frozenset({%s})&#39; % &#39;, &#39;.join(</span>
<span class="gi">+            object_description(x, _seen=seen) for x in sorted_values</span>
<span class="gi">+        )</span>
<span class="gi">+    elif isinstance(obj, enum.Enum):</span>
<span class="gi">+        if obj.__repr__.__func__ is not enum.Enum.__repr__:  # type: ignore[attr-defined]</span>
<span class="gi">+            return repr(obj)</span>
<span class="gi">+        return f&#39;{obj.__class__.__name__}.{obj.name}&#39;</span>
<span class="gi">+    elif isinstance(obj, tuple):</span>
<span class="gi">+        if id(obj) in seen:</span>
<span class="gi">+            return &#39;tuple(...)&#39;</span>
<span class="gi">+        seen |= frozenset([id(obj)])</span>
<span class="gi">+        return &#39;({}{})&#39;.format(</span>
<span class="gi">+            &#39;, &#39;.join(object_description(x, _seen=seen) for x in obj),</span>
<span class="gi">+            &#39;,&#39; * (len(obj) == 1),</span>
<span class="gi">+        )</span>
<span class="gi">+    elif isinstance(obj, list):</span>
<span class="gi">+        if id(obj) in seen:</span>
<span class="gi">+            return &#39;list(...)&#39;</span>
<span class="gi">+        seen |= {id(obj)}</span>
<span class="gi">+        return &#39;[%s]&#39; % &#39;, &#39;.join(object_description(x, _seen=seen) for x in obj)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        s = repr(obj)</span>
<span class="gi">+    except Exception as exc:</span>
<span class="gi">+        raise ValueError from exc</span>
<span class="gi">+    # Strip non-deterministic memory addresses such as</span>
<span class="gi">+    # ``&lt;__main__.A at 0x7f68cb685710&gt;``</span>
<span class="gi">+    s = memory_address_re.sub(&#39;&#39;, s)</span>
<span class="gi">+    return s.replace(&#39;\n&#39;, &#39; &#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_builtin_class_method(obj: Any, attr_name: str) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check whether *attr_name* is implemented on a builtin class.

<span class="w"> </span>        &gt;&gt;&gt; is_builtin_class_method(int, &#39;__init__&#39;)
<span class="gu">@@ -271,19 +493,31 @@ def is_builtin_class_method(obj: Any, attr_name: str) -&gt;bool:</span>
<span class="w"> </span>    This function is needed since CPython implements ``int.__init__`` via
<span class="w"> </span>    descriptors, but PyPy implementation is written in pure Python code.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    mro = getmro(obj)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        cls = next(c for c in mro if attr_name in safe_getattr(c, &#39;__dict__&#39;, {}))</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        name = safe_getattr(cls, &#39;__name__&#39;)</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    return getattr(builtins, name, None) is cls</span>


<span class="w"> </span>class DefaultValue:
<span class="w"> </span>    &quot;&quot;&quot;A simple wrapper for default value of the parameters of overload functions.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, value: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, value: str) -&gt; None:</span>
<span class="w"> </span>        self.value = value

<span class="gd">-    def __eq__(self, other: object) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: object) -&gt; bool:</span>
<span class="w"> </span>        return self.value == other

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return self.value


<span class="gu">@@ -293,46 +527,53 @@ class TypeAliasForwardRef:</span>
<span class="w"> </span>    This avoids the error on evaluating the type inside :func:`typing.get_type_hints()`.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, name: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, name: str) -&gt; None:</span>
<span class="w"> </span>        self.name = name

<span class="gd">-    def __call__(self) -&gt;None:</span>
<span class="gi">+    def __call__(self) -&gt; None:</span>
<span class="gi">+        # Dummy method to imitate special typing classes</span>
<span class="w"> </span>        pass

<span class="gd">-    def __eq__(self, other: Any) -&gt;bool:</span>
<span class="gi">+    def __eq__(self, other: Any) -&gt; bool:</span>
<span class="w"> </span>        return self.name == other

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash(self.name)

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return self.name


<span class="w"> </span>class TypeAliasModule:
<span class="w"> </span>    &quot;&quot;&quot;Pseudo module class for :confval:`autodoc_type_aliases`.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, modname: str, mapping: Mapping[str, str]) -&gt;None:</span>
<span class="gi">+    def __init__(self, modname: str, mapping: Mapping[str, str]) -&gt; None:</span>
<span class="w"> </span>        self.__modname = modname
<span class="w"> </span>        self.__mapping = mapping
<span class="gi">+</span>
<span class="w"> </span>        self.__module: ModuleType | None = None

<span class="gd">-    def __getattr__(self, name: str) -&gt;Any:</span>
<span class="gi">+    def __getattr__(self, name: str) -&gt; Any:</span>
<span class="w"> </span>        fullname = &#39;.&#39;.join(filter(None, [self.__modname, name]))
<span class="w"> </span>        if fullname in self.__mapping:
<span class="gi">+            # exactly matched</span>
<span class="w"> </span>            return TypeAliasForwardRef(self.__mapping[fullname])
<span class="w"> </span>        else:
<span class="w"> </span>            prefix = fullname + &#39;.&#39;
<span class="gd">-            nested = {k: v for k, v in self.__mapping.items() if k.</span>
<span class="gd">-                startswith(prefix)}</span>
<span class="gi">+            nested = {k: v for k, v in self.__mapping.items() if k.startswith(prefix)}</span>
<span class="w"> </span>            if nested:
<span class="gi">+                # sub modules or classes found</span>
<span class="w"> </span>                return TypeAliasModule(fullname, nested)
<span class="w"> </span>            else:
<span class="gi">+                # no sub modules or classes found.</span>
<span class="w"> </span>                try:
<span class="gi">+                    # return the real submodule if exists</span>
<span class="w"> </span>                    return import_module(fullname)
<span class="w"> </span>                except ImportError:
<span class="gi">+                    # return the real class</span>
<span class="w"> </span>                    if self.__module is None:
<span class="w"> </span>                        self.__module = import_module(self.__modname)
<span class="gi">+</span>
<span class="w"> </span>                    return getattr(self.__module, name)


<span class="gu">@@ -342,58 +583,166 @@ class TypeAliasNamespace(dict[str, Any]):</span>
<span class="w"> </span>    Useful for looking up nested objects via ``namespace.foo.bar.Class``.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, mapping: Mapping[str, str]) -&gt;None:</span>
<span class="gi">+    def __init__(self, mapping: Mapping[str, str]) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.__mapping = mapping

<span class="gd">-    def __getitem__(self, key: str) -&gt;Any:</span>
<span class="gi">+    def __getitem__(self, key: str) -&gt; Any:</span>
<span class="w"> </span>        if key in self.__mapping:
<span class="gi">+            # exactly matched</span>
<span class="w"> </span>            return TypeAliasForwardRef(self.__mapping[key])
<span class="w"> </span>        else:
<span class="w"> </span>            prefix = key + &#39;.&#39;
<span class="gd">-            nested = {k: v for k, v in self.__mapping.items() if k.</span>
<span class="gd">-                startswith(prefix)}</span>
<span class="gi">+            nested = {k: v for k, v in self.__mapping.items() if k.startswith(prefix)}</span>
<span class="w"> </span>            if nested:
<span class="gi">+                # sub modules or classes found</span>
<span class="w"> </span>                return TypeAliasModule(key, nested)
<span class="w"> </span>            else:
<span class="w"> </span>                raise KeyError


<span class="gd">-def _should_unwrap(subject: _SignatureType) -&gt;bool:</span>
<span class="gi">+def _should_unwrap(subject: _SignatureType) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check the function should be unwrapped on getting signature.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def signature(subject: _SignatureType, bound_method: bool=False,</span>
<span class="gd">-    type_aliases: (Mapping[str, str] | None)=None) -&gt;Signature:</span>
<span class="gi">+    __globals__ = getglobals(subject)</span>
<span class="gi">+    # contextmanger should be unwrapped</span>
<span class="gi">+    return (</span>
<span class="gi">+        __globals__.get(&#39;__name__&#39;) == &#39;contextlib&#39;</span>
<span class="gi">+        and __globals__.get(&#39;__file__&#39;) == contextlib.__file__</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def signature(</span>
<span class="gi">+    subject: _SignatureType,</span>
<span class="gi">+    bound_method: bool = False,</span>
<span class="gi">+    type_aliases: Mapping[str, str] | None = None,</span>
<span class="gi">+) -&gt; Signature:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a Signature object for the given *subject*.

<span class="w"> </span>    :param bound_method: Specify *subject* is a bound method or not
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if type_aliases is None:</span>
<span class="gi">+        type_aliases = {}</span>

<span class="gi">+    try:</span>
<span class="gi">+        if _should_unwrap(subject):</span>
<span class="gi">+            signature = inspect.signature(subject)  # type: ignore[arg-type]</span>
<span class="gi">+        else:</span>
<span class="gi">+            signature = inspect.signature(subject, follow_wrapped=True)  # type: ignore[arg-type]</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        # follow built-in wrappers up (ex. functools.lru_cache)</span>
<span class="gi">+        signature = inspect.signature(subject)  # type: ignore[arg-type]</span>
<span class="gi">+    parameters = list(signature.parameters.values())</span>
<span class="gi">+    return_annotation = signature.return_annotation</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        # Resolve annotations using ``get_type_hints()`` and type_aliases.</span>
<span class="gi">+        localns = TypeAliasNamespace(type_aliases)</span>
<span class="gi">+        annotations = typing.get_type_hints(subject, None, localns, include_extras=True)</span>
<span class="gi">+        for i, param in enumerate(parameters):</span>
<span class="gi">+            if param.name in annotations:</span>
<span class="gi">+                annotation = annotations[param.name]</span>
<span class="gi">+                if isinstance(annotation, TypeAliasForwardRef):</span>
<span class="gi">+                    annotation = annotation.name</span>
<span class="gi">+                parameters[i] = param.replace(annotation=annotation)</span>
<span class="gi">+        if &#39;return&#39; in annotations:</span>
<span class="gi">+            if isinstance(annotations[&#39;return&#39;], TypeAliasForwardRef):</span>
<span class="gi">+                return_annotation = annotations[&#39;return&#39;].name</span>
<span class="gi">+            else:</span>
<span class="gi">+                return_annotation = annotations[&#39;return&#39;]</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        # ``get_type_hints()`` does not support some kind of objects like partial,</span>
<span class="gi">+        # ForwardRef and so on.</span>
<span class="gi">+        pass</span>

<span class="gd">-def evaluate_signature(sig: Signature, globalns: (dict[str, Any] | None)=</span>
<span class="gd">-    None, localns: (dict[str, Any] | None)=None) -&gt;Signature:</span>
<span class="gi">+    if bound_method:</span>
<span class="gi">+        if inspect.ismethod(subject):</span>
<span class="gi">+            # ``inspect.signature()`` considers the subject is a bound method and removes</span>
<span class="gi">+            # first argument from signature.  Therefore no skips are needed here.</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            if len(parameters) &gt; 0:</span>
<span class="gi">+                parameters.pop(0)</span>
<span class="gi">+</span>
<span class="gi">+    # To allow to create signature object correctly for pure python functions,</span>
<span class="gi">+    # pass an internal parameter __validate_parameters__=False to Signature</span>
<span class="gi">+    #</span>
<span class="gi">+    # For example, this helps a function having a default value `inspect._empty`.</span>
<span class="gi">+    # refs: https://github.com/sphinx-doc/sphinx/issues/7935</span>
<span class="gi">+    return Signature(</span>
<span class="gi">+        parameters, return_annotation=return_annotation, __validate_parameters__=False</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def evaluate_signature(</span>
<span class="gi">+    sig: Signature,</span>
<span class="gi">+    globalns: dict[str, Any] | None = None,</span>
<span class="gi">+    localns: dict[str, Any] | None = None,</span>
<span class="gi">+) -&gt; Signature:</span>
<span class="w"> </span>    &quot;&quot;&quot;Evaluate unresolved type annotations in a signature object.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if globalns is None:</span>
<span class="gi">+        globalns = {}</span>
<span class="gi">+    if localns is None:</span>
<span class="gi">+        localns = globalns</span>

<span class="gi">+    parameters = list(sig.parameters.values())</span>
<span class="gi">+    for i, param in enumerate(parameters):</span>
<span class="gi">+        if param.annotation:</span>
<span class="gi">+            annotation = _evaluate(param.annotation, globalns, localns)</span>
<span class="gi">+            parameters[i] = param.replace(annotation=annotation)</span>

<span class="gd">-def _evaluate_forwardref(ref: ForwardRef, globalns: (dict[str, Any] | None),</span>
<span class="gd">-    localns: (dict[str, Any] | None)) -&gt;Any:</span>
<span class="gd">-    &quot;&quot;&quot;Evaluate a forward reference.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    return_annotation = sig.return_annotation</span>
<span class="gi">+    if return_annotation:</span>
<span class="gi">+        return_annotation = _evaluate(return_annotation, globalns, localns)</span>
<span class="gi">+</span>
<span class="gi">+    return sig.replace(parameters=parameters, return_annotation=return_annotation)</span>


<span class="gd">-def _evaluate(annotation: Any, globalns: dict[str, Any], localns: dict[str,</span>
<span class="gd">-    Any]) -&gt;Any:</span>
<span class="gi">+def _evaluate_forwardref(</span>
<span class="gi">+    ref: ForwardRef,</span>
<span class="gi">+    globalns: dict[str, Any] | None,</span>
<span class="gi">+    localns: dict[str, Any] | None,</span>
<span class="gi">+) -&gt; Any:</span>
<span class="gi">+    &quot;&quot;&quot;Evaluate a forward reference.&quot;&quot;&quot;</span>
<span class="gi">+    if sys.version_info &gt;= (3, 12, 4):</span>
<span class="gi">+        # ``type_params`` were added in 3.13 and the signature of _evaluate()</span>
<span class="gi">+        # is not backward-compatible (it was backported to 3.12.4, so anything</span>
<span class="gi">+        # before 3.12.4 still has the old signature).</span>
<span class="gi">+        #</span>
<span class="gi">+        # See: https://github.com/python/cpython/pull/118104.</span>
<span class="gi">+        return ref._evaluate(globalns, localns, {}, recursive_guard=frozenset())  # type: ignore[arg-type, misc]</span>
<span class="gi">+    return ref._evaluate(globalns, localns, frozenset())</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _evaluate(</span>
<span class="gi">+    annotation: Any,</span>
<span class="gi">+    globalns: dict[str, Any],</span>
<span class="gi">+    localns: dict[str, Any],</span>
<span class="gi">+) -&gt; Any:</span>
<span class="w"> </span>    &quot;&quot;&quot;Evaluate unresolved type annotation.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        if isinstance(annotation, str):</span>
<span class="gi">+            ref = ForwardRef(annotation, True)</span>
<span class="gi">+            annotation = _evaluate_forwardref(ref, globalns, localns)</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(annotation, ForwardRef):</span>
<span class="gi">+                annotation = _evaluate_forwardref(ref, globalns, localns)</span>
<span class="gi">+            elif isinstance(annotation, str):</span>
<span class="gi">+                # might be a ForwardRef&#39;ed annotation in overloaded functions</span>
<span class="gi">+                ref = ForwardRef(annotation, True)</span>
<span class="gi">+                annotation = _evaluate_forwardref(ref, globalns, localns)</span>
<span class="gi">+    except (NameError, TypeError):</span>
<span class="gi">+        # failed to evaluate type. skipped.</span>
<span class="gi">+        pass</span>

<span class="gi">+    return annotation</span>

<span class="gd">-def stringify_signature(sig: Signature, show_annotation: bool=True,</span>
<span class="gd">-    show_return_annotation: bool=True, unqualified_typehints: bool=False</span>
<span class="gd">-    ) -&gt;str:</span>
<span class="gi">+</span>
<span class="gi">+def stringify_signature(</span>
<span class="gi">+    sig: Signature,</span>
<span class="gi">+    show_annotation: bool = True,</span>
<span class="gi">+    show_return_annotation: bool = True,</span>
<span class="gi">+    unqualified_typehints: bool = False,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Stringify a :class:`~inspect.Signature` object.

<span class="w"> </span>    :param show_annotation: If enabled, show annotations on the signature
<span class="gu">@@ -401,21 +750,137 @@ def stringify_signature(sig: Signature, show_annotation: bool=True,</span>
<span class="w"> </span>    :param unqualified_typehints: If enabled, show annotations as unqualified
<span class="w"> </span>                                  (ex. io.StringIO -&gt; StringIO)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if unqualified_typehints:</span>
<span class="gi">+        mode = &#39;smart&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        mode = &#39;fully-qualified&#39;</span>
<span class="gi">+</span>
<span class="gi">+    EMPTY = Parameter.empty</span>
<span class="gi">+</span>
<span class="gi">+    args = []</span>
<span class="gi">+    last_kind = None</span>
<span class="gi">+    for param in sig.parameters.values():</span>
<span class="gi">+        if param.kind != Parameter.POSITIONAL_ONLY and last_kind == Parameter.POSITIONAL_ONLY:</span>
<span class="gi">+            # PEP-570: Separator for Positional Only Parameter: /</span>
<span class="gi">+            args.append(&#39;/&#39;)</span>
<span class="gi">+        if param.kind == Parameter.KEYWORD_ONLY and last_kind in (</span>
<span class="gi">+            Parameter.POSITIONAL_OR_KEYWORD,</span>
<span class="gi">+            Parameter.POSITIONAL_ONLY,</span>
<span class="gi">+            None,</span>
<span class="gi">+        ):</span>
<span class="gi">+            # PEP-3102: Separator for Keyword Only Parameter: *</span>
<span class="gi">+            args.append(&#39;*&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        arg = StringIO()</span>
<span class="gi">+        if param.kind is Parameter.VAR_POSITIONAL:</span>
<span class="gi">+            arg.write(&#39;*&#39; + param.name)</span>
<span class="gi">+        elif param.kind is Parameter.VAR_KEYWORD:</span>
<span class="gi">+            arg.write(&#39;**&#39; + param.name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            arg.write(param.name)</span>
<span class="gi">+</span>
<span class="gi">+        if show_annotation and param.annotation is not EMPTY:</span>
<span class="gi">+            arg.write(&#39;: &#39;)</span>
<span class="gi">+            arg.write(stringify_annotation(param.annotation, mode))  # type: ignore[arg-type]</span>
<span class="gi">+        if param.default is not EMPTY:</span>
<span class="gi">+            if show_annotation and param.annotation is not EMPTY:</span>
<span class="gi">+                arg.write(&#39; = &#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                arg.write(&#39;=&#39;)</span>
<span class="gi">+            arg.write(object_description(param.default))</span>

<span class="gi">+        args.append(arg.getvalue())</span>
<span class="gi">+        last_kind = param.kind</span>

<span class="gd">-def signature_from_str(signature: str) -&gt;Signature:</span>
<span class="gd">-    &quot;&quot;&quot;Create a :class:`~inspect.Signature` object from a string.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    if last_kind is Parameter.POSITIONAL_ONLY:</span>
<span class="gi">+        # PEP-570: Separator for Positional Only Parameter: /</span>
<span class="gi">+        args.append(&#39;/&#39;)</span>

<span class="gi">+    concatenated_args = &#39;, &#39;.join(args)</span>
<span class="gi">+    if sig.return_annotation is EMPTY or not show_annotation or not show_return_annotation:</span>
<span class="gi">+        return f&#39;({concatenated_args})&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        retann = stringify_annotation(sig.return_annotation, mode)  # type: ignore[arg-type]</span>
<span class="gi">+        return f&#39;({concatenated_args}) -&gt; {retann}&#39;</span>

<span class="gd">-def signature_from_ast(node: ast.FunctionDef, code: str=&#39;&#39;) -&gt;Signature:</span>
<span class="gd">-    &quot;&quot;&quot;Create a :class:`~inspect.Signature` object from an AST node.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+def signature_from_str(signature: str) -&gt; Signature:</span>
<span class="gi">+    &quot;&quot;&quot;Create a :class:`~inspect.Signature` object from a string.&quot;&quot;&quot;</span>
<span class="gi">+    code = &#39;def func&#39; + signature + &#39;: pass&#39;</span>
<span class="gi">+    module = ast.parse(code)</span>
<span class="gi">+    function = typing.cast(ast.FunctionDef, module.body[0])</span>
<span class="gi">+</span>
<span class="gi">+    return signature_from_ast(function, code)</span>


<span class="gd">-def getdoc(obj: Any, attrgetter: Callable=safe_getattr, allow_inherited:</span>
<span class="gd">-    bool=False, cls: Any=None, name: (str | None)=None) -&gt;(str | None):</span>
<span class="gi">+def signature_from_ast(node: ast.FunctionDef, code: str = &#39;&#39;) -&gt; Signature:</span>
<span class="gi">+    &quot;&quot;&quot;Create a :class:`~inspect.Signature` object from an AST node.&quot;&quot;&quot;</span>
<span class="gi">+    EMPTY = Parameter.empty</span>
<span class="gi">+</span>
<span class="gi">+    args: ast.arguments = node.args</span>
<span class="gi">+    defaults: tuple[ast.expr | None, ...] = tuple(args.defaults)</span>
<span class="gi">+    pos_only_offset = len(args.posonlyargs)</span>
<span class="gi">+    defaults_offset = pos_only_offset + len(args.args) - len(defaults)</span>
<span class="gi">+    # The sequence ``D = args.defaults`` contains non-None AST expressions,</span>
<span class="gi">+    # so we can use ``None`` as a sentinel value for that to indicate that</span>
<span class="gi">+    # there is no default value for a specific parameter.</span>
<span class="gi">+    #</span>
<span class="gi">+    # Let *p* be the number of positional-only and positional-or-keyword</span>
<span class="gi">+    # arguments. Note that ``0 &lt;= len(D) &lt;= p`` and ``D[0]`` is the default</span>
<span class="gi">+    # value corresponding to a positional-only *or* a positional-or-keyword</span>
<span class="gi">+    # argument. Since a non-default argument cannot follow a default argument,</span>
<span class="gi">+    # the sequence *D* can be completed on the left by adding None sentinels</span>
<span class="gi">+    # so that ``len(D) == p`` and ``D[i]`` is the *i*-th default argument.</span>
<span class="gi">+    defaults = (None,) * defaults_offset + defaults</span>
<span class="gi">+</span>
<span class="gi">+    # construct the parameter list</span>
<span class="gi">+    params: list[Parameter] = []</span>
<span class="gi">+</span>
<span class="gi">+    # positional-only arguments (introduced in Python 3.8)</span>
<span class="gi">+    for arg, defexpr in zip(args.posonlyargs, defaults, strict=False):</span>
<span class="gi">+        params.append(_define(Parameter.POSITIONAL_ONLY, arg, code, defexpr=defexpr))</span>
<span class="gi">+</span>
<span class="gi">+    # normal arguments</span>
<span class="gi">+    for arg, defexpr in zip(args.args, defaults[pos_only_offset:], strict=False):</span>
<span class="gi">+        params.append(_define(Parameter.POSITIONAL_OR_KEYWORD, arg, code, defexpr=defexpr))</span>
<span class="gi">+</span>
<span class="gi">+    # variadic positional argument (no possible default expression)</span>
<span class="gi">+    if args.vararg:</span>
<span class="gi">+        params.append(_define(Parameter.VAR_POSITIONAL, args.vararg, code, defexpr=None))</span>
<span class="gi">+</span>
<span class="gi">+    # keyword-only arguments</span>
<span class="gi">+    for arg, defexpr in zip(args.kwonlyargs, args.kw_defaults, strict=False):</span>
<span class="gi">+        params.append(_define(Parameter.KEYWORD_ONLY, arg, code, defexpr=defexpr))</span>
<span class="gi">+</span>
<span class="gi">+    # variadic keyword argument (no possible default expression)</span>
<span class="gi">+    if args.kwarg:</span>
<span class="gi">+        params.append(_define(Parameter.VAR_KEYWORD, args.kwarg, code, defexpr=None))</span>
<span class="gi">+</span>
<span class="gi">+    return_annotation = ast_unparse(node.returns, code) or EMPTY</span>
<span class="gi">+    return Signature(params, return_annotation=return_annotation)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _define(</span>
<span class="gi">+    kind: _ParameterKind,</span>
<span class="gi">+    arg: ast.arg,</span>
<span class="gi">+    code: str,</span>
<span class="gi">+    *,</span>
<span class="gi">+    defexpr: ast.expr | None,</span>
<span class="gi">+) -&gt; Parameter:</span>
<span class="gi">+    EMPTY = Parameter.empty</span>
<span class="gi">+</span>
<span class="gi">+    default = EMPTY if defexpr is None else DefaultValue(ast_unparse(defexpr, code))</span>
<span class="gi">+    annotation = ast_unparse(arg.annotation, code) or EMPTY</span>
<span class="gi">+    return Parameter(arg.arg, kind, default=default, annotation=annotation)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def getdoc(</span>
<span class="gi">+    obj: Any,</span>
<span class="gi">+    attrgetter: Callable = safe_getattr,</span>
<span class="gi">+    allow_inherited: bool = False,</span>
<span class="gi">+    cls: Any = None,</span>
<span class="gi">+    name: str | None = None,</span>
<span class="gi">+) -&gt; str | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get the docstring for the object.

<span class="w"> </span>    This tries to obtain the docstring for some kind of objects additionally:
<span class="gu">@@ -424,4 +889,46 @@ def getdoc(obj: Any, attrgetter: Callable=safe_getattr, allow_inherited:</span>
<span class="w"> </span>    * inherited docstring
<span class="w"> </span>    * inherited decorated methods
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if cls and name and isclassmethod(obj, cls, name):</span>
<span class="gi">+        for basecls in getmro(cls):</span>
<span class="gi">+            meth = basecls.__dict__.get(name)</span>
<span class="gi">+            if meth and hasattr(meth, &#39;__func__&#39;):</span>
<span class="gi">+                doc: str | None = getdoc(meth.__func__)</span>
<span class="gi">+                if doc is not None or not allow_inherited:</span>
<span class="gi">+                    return doc</span>
<span class="gi">+</span>
<span class="gi">+    doc = _getdoc_internal(obj)</span>
<span class="gi">+    if ispartial(obj) and doc == obj.__class__.__doc__:</span>
<span class="gi">+        return getdoc(obj.func)</span>
<span class="gi">+    elif doc is None and allow_inherited:</span>
<span class="gi">+        if cls and name:</span>
<span class="gi">+            # Check a docstring of the attribute or method from super classes.</span>
<span class="gi">+            for basecls in getmro(cls):</span>
<span class="gi">+                meth = safe_getattr(basecls, name, None)</span>
<span class="gi">+                if meth is not None:</span>
<span class="gi">+                    doc = _getdoc_internal(meth)</span>
<span class="gi">+                    if doc is not None:</span>
<span class="gi">+                        break</span>
<span class="gi">+</span>
<span class="gi">+            if doc is None:</span>
<span class="gi">+                # retry using `inspect.getdoc()`</span>
<span class="gi">+                for basecls in getmro(cls):</span>
<span class="gi">+                    meth = safe_getattr(basecls, name, None)</span>
<span class="gi">+                    if meth is not None:</span>
<span class="gi">+                        doc = inspect.getdoc(meth)</span>
<span class="gi">+                        if doc is not None:</span>
<span class="gi">+                            break</span>
<span class="gi">+</span>
<span class="gi">+        if doc is None:</span>
<span class="gi">+            doc = inspect.getdoc(obj)</span>
<span class="gi">+</span>
<span class="gi">+    return doc</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _getdoc_internal(</span>
<span class="gi">+    obj: Any, attrgetter: Callable[[Any, str, Any], Any] = safe_getattr</span>
<span class="gi">+) -&gt; str | None:</span>
<span class="gi">+    doc = attrgetter(obj, &#39;__doc__&#39;, None)</span>
<span class="gi">+    if isinstance(doc, str):</span>
<span class="gi">+        return doc</span>
<span class="gi">+    return None</span>
<span class="gh">diff --git a/sphinx/util/inventory.py b/sphinx/util/inventory.py</span>
<span class="gh">index 5648e43b1..c48922cfb 100644</span>
<span class="gd">--- a/sphinx/util/inventory.py</span>
<span class="gi">+++ b/sphinx/util/inventory.py</span>
<span class="gu">@@ -1,15 +1,20 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Inventory utility functions for Sphinx.&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import re
<span class="w"> </span>import zlib
<span class="w"> </span>from typing import IO, TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.util import logging
<span class="gi">+</span>
<span class="w"> </span>BUFSIZE = 16 * 1024
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Callable, Iterator
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.builders import Builder
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="w"> </span>    from sphinx.util.typing import Inventory, InventoryItem
<span class="gu">@@ -21,11 +26,186 @@ class InventoryFileReader:</span>
<span class="w"> </span>    This reader supports mixture of texts and compressed texts.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, stream: IO[bytes]) -&gt;None:</span>
<span class="gi">+    def __init__(self, stream: IO[bytes]) -&gt; None:</span>
<span class="w"> </span>        self.stream = stream
<span class="w"> </span>        self.buffer = b&#39;&#39;
<span class="w"> </span>        self.eof = False

<span class="gi">+    def read_buffer(self) -&gt; None:</span>
<span class="gi">+        chunk = self.stream.read(BUFSIZE)</span>
<span class="gi">+        if chunk == b&#39;&#39;:</span>
<span class="gi">+            self.eof = True</span>
<span class="gi">+        self.buffer += chunk</span>
<span class="gi">+</span>
<span class="gi">+    def readline(self) -&gt; str:</span>
<span class="gi">+        pos = self.buffer.find(b&#39;\n&#39;)</span>
<span class="gi">+        if pos != -1:</span>
<span class="gi">+            line = self.buffer[:pos].decode()</span>
<span class="gi">+            self.buffer = self.buffer[pos + 1:]</span>
<span class="gi">+        elif self.eof:</span>
<span class="gi">+            line = self.buffer.decode()</span>
<span class="gi">+            self.buffer = b&#39;&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.read_buffer()</span>
<span class="gi">+            line = self.readline()</span>
<span class="gi">+</span>
<span class="gi">+        return line</span>
<span class="gi">+</span>
<span class="gi">+    def readlines(self) -&gt; Iterator[str]:</span>
<span class="gi">+        while not self.eof:</span>
<span class="gi">+            line = self.readline()</span>
<span class="gi">+            if line:</span>
<span class="gi">+                yield line</span>
<span class="gi">+</span>
<span class="gi">+    def read_compressed_chunks(self) -&gt; Iterator[bytes]:</span>
<span class="gi">+        decompressor = zlib.decompressobj()</span>
<span class="gi">+        while not self.eof:</span>
<span class="gi">+            self.read_buffer()</span>
<span class="gi">+            yield decompressor.decompress(self.buffer)</span>
<span class="gi">+            self.buffer = b&#39;&#39;</span>
<span class="gi">+        yield decompressor.flush()</span>
<span class="gi">+</span>
<span class="gi">+    def read_compressed_lines(self) -&gt; Iterator[str]:</span>
<span class="gi">+        buf = b&#39;&#39;</span>
<span class="gi">+        for chunk in self.read_compressed_chunks():</span>
<span class="gi">+            buf += chunk</span>
<span class="gi">+            pos = buf.find(b&#39;\n&#39;)</span>
<span class="gi">+            while pos != -1:</span>
<span class="gi">+                yield buf[:pos].decode()</span>
<span class="gi">+                buf = buf[pos + 1:]</span>
<span class="gi">+                pos = buf.find(b&#39;\n&#39;)</span>
<span class="gi">+</span>

<span class="w"> </span>class InventoryFile:
<span class="gd">-    pass</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def load(</span>
<span class="gi">+        cls: type[InventoryFile],</span>
<span class="gi">+        stream: IO[bytes],</span>
<span class="gi">+        uri: str,</span>
<span class="gi">+        joinfunc: Callable[[str, str], str],</span>
<span class="gi">+    ) -&gt; Inventory:</span>
<span class="gi">+        reader = InventoryFileReader(stream)</span>
<span class="gi">+        line = reader.readline().rstrip()</span>
<span class="gi">+        if line == &#39;# Sphinx inventory version 1&#39;:</span>
<span class="gi">+            return cls.load_v1(reader, uri, joinfunc)</span>
<span class="gi">+        elif line == &#39;# Sphinx inventory version 2&#39;:</span>
<span class="gi">+            return cls.load_v2(reader, uri, joinfunc)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&#39;invalid inventory header: %s&#39; % line)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def load_v1(</span>
<span class="gi">+        cls: type[InventoryFile],</span>
<span class="gi">+        stream: InventoryFileReader,</span>
<span class="gi">+        uri: str,</span>
<span class="gi">+        join: Callable[[str, str], str],</span>
<span class="gi">+    ) -&gt; Inventory:</span>
<span class="gi">+        invdata: Inventory = {}</span>
<span class="gi">+        projname = stream.readline().rstrip()[11:]</span>
<span class="gi">+        version = stream.readline().rstrip()[11:]</span>
<span class="gi">+        for line in stream.readlines():</span>
<span class="gi">+            name, type, location = line.rstrip().split(None, 2)</span>
<span class="gi">+            location = join(uri, location)</span>
<span class="gi">+            # version 1 did not add anchors to the location</span>
<span class="gi">+            if type == &#39;mod&#39;:</span>
<span class="gi">+                type = &#39;py:module&#39;</span>
<span class="gi">+                location += &#39;#module-&#39; + name</span>
<span class="gi">+            else:</span>
<span class="gi">+                type = &#39;py:&#39; + type</span>
<span class="gi">+                location += &#39;#&#39; + name</span>
<span class="gi">+            invdata.setdefault(type, {})[name] = (projname, version, location, &#39;-&#39;)</span>
<span class="gi">+        return invdata</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def load_v2(</span>
<span class="gi">+        cls: type[InventoryFile],</span>
<span class="gi">+        stream: InventoryFileReader,</span>
<span class="gi">+        uri: str,</span>
<span class="gi">+        join: Callable[[str, str], str],</span>
<span class="gi">+    ) -&gt; Inventory:</span>
<span class="gi">+        invdata: Inventory = {}</span>
<span class="gi">+        projname = stream.readline().rstrip()[11:]</span>
<span class="gi">+        version = stream.readline().rstrip()[11:]</span>
<span class="gi">+        # definition -&gt; priority, location, display name</span>
<span class="gi">+        potential_ambiguities: dict[str, tuple[str, str, str]] = {}</span>
<span class="gi">+        actual_ambiguities = set()</span>
<span class="gi">+        line = stream.readline()</span>
<span class="gi">+        if &#39;zlib&#39; not in line:</span>
<span class="gi">+            raise ValueError(&#39;invalid inventory header (not compressed): %s&#39; % line)</span>
<span class="gi">+</span>
<span class="gi">+        for line in stream.read_compressed_lines():</span>
<span class="gi">+            # be careful to handle names with embedded spaces correctly</span>
<span class="gi">+            m = re.match(r&#39;(.+?)\s+(\S+)\s+(-?\d+)\s+?(\S*)\s+(.*)&#39;,</span>
<span class="gi">+                         line.rstrip(), flags=re.VERBOSE)</span>
<span class="gi">+            if not m:</span>
<span class="gi">+                continue</span>
<span class="gi">+            name, type, prio, location, dispname = m.groups()</span>
<span class="gi">+            if &#39;:&#39; not in type:</span>
<span class="gi">+                # wrong type value. type should be in the form of &quot;{domain}:{objtype}&quot;</span>
<span class="gi">+                #</span>
<span class="gi">+                # Note: To avoid the regex DoS, this is implemented in python (refs: #8175)</span>
<span class="gi">+                continue</span>
<span class="gi">+            if type == &#39;py:module&#39; and type in invdata and name in invdata[type]:</span>
<span class="gi">+                # due to a bug in 1.1 and below,</span>
<span class="gi">+                # two inventory entries are created</span>
<span class="gi">+                # for Python modules, and the first</span>
<span class="gi">+                # one is correct</span>
<span class="gi">+                continue</span>
<span class="gi">+            if type in {&#39;std:label&#39;, &#39;std:term&#39;}:</span>
<span class="gi">+                # Some types require case insensitive matches:</span>
<span class="gi">+                # * &#39;term&#39;: https://github.com/sphinx-doc/sphinx/issues/9291</span>
<span class="gi">+                # * &#39;label&#39;: https://github.com/sphinx-doc/sphinx/issues/12008</span>
<span class="gi">+                definition = f&quot;{type}:{name}&quot;</span>
<span class="gi">+                content = prio, location, dispname</span>
<span class="gi">+                lowercase_definition = definition.lower()</span>
<span class="gi">+                if lowercase_definition in potential_ambiguities:</span>
<span class="gi">+                    if potential_ambiguities[lowercase_definition] != content:</span>
<span class="gi">+                        actual_ambiguities.add(definition)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        logger.debug(__(&quot;inventory &lt;%s&gt; contains duplicate definitions of %s&quot;),</span>
<span class="gi">+                                     uri, definition, type=&#39;intersphinx&#39;,  subtype=&#39;external&#39;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    potential_ambiguities[lowercase_definition] = content</span>
<span class="gi">+            if location.endswith(&#39;$&#39;):</span>
<span class="gi">+                location = location[:-1] + name</span>
<span class="gi">+            location = join(uri, location)</span>
<span class="gi">+            inv_item: InventoryItem = projname, version, location, dispname</span>
<span class="gi">+            invdata.setdefault(type, {})[name] = inv_item</span>
<span class="gi">+        for ambiguity in actual_ambiguities:</span>
<span class="gi">+            logger.info(__(&quot;inventory &lt;%s&gt; contains multiple definitions for %s&quot;),</span>
<span class="gi">+                        uri, ambiguity, type=&#39;intersphinx&#39;,  subtype=&#39;external&#39;)</span>
<span class="gi">+        return invdata</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def dump(</span>
<span class="gi">+        cls: type[InventoryFile], filename: str, env: BuildEnvironment, builder: Builder,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        def escape(string: str) -&gt; str:</span>
<span class="gi">+            return re.sub(&quot;\\s+&quot;, &quot; &quot;, string)</span>
<span class="gi">+</span>
<span class="gi">+        with open(os.path.join(filename), &#39;wb&#39;) as f:</span>
<span class="gi">+            # header</span>
<span class="gi">+            f.write((&#39;# Sphinx inventory version 2\n&#39;</span>
<span class="gi">+                     &#39;# Project: %s\n&#39;</span>
<span class="gi">+                     &#39;# Version: %s\n&#39;</span>
<span class="gi">+                     &#39;# The remainder of this file is compressed using zlib.\n&#39; %</span>
<span class="gi">+                     (escape(env.config.project),</span>
<span class="gi">+                      escape(env.config.version))).encode())</span>
<span class="gi">+</span>
<span class="gi">+            # body</span>
<span class="gi">+            compressor = zlib.compressobj(9)</span>
<span class="gi">+            for domainname, domain in sorted(env.domains.items()):</span>
<span class="gi">+                for name, dispname, typ, docname, anchor, prio in \</span>
<span class="gi">+                        sorted(domain.get_objects()):</span>
<span class="gi">+                    if anchor.endswith(name):</span>
<span class="gi">+                        # this can shorten the inventory by as much as 25%</span>
<span class="gi">+                        anchor = anchor[:-len(name)] + &#39;$&#39;</span>
<span class="gi">+                    uri = builder.get_target_uri(docname)</span>
<span class="gi">+                    if anchor:</span>
<span class="gi">+                        uri += &#39;#&#39; + anchor</span>
<span class="gi">+                    if dispname == name:</span>
<span class="gi">+                        dispname = &#39;-&#39;</span>
<span class="gi">+                    entry = (&#39;%s %s:%s %s %s %s\n&#39; %</span>
<span class="gi">+                             (name, domainname, typ, prio, uri, dispname))</span>
<span class="gi">+                    f.write(compressor.compress(entry.encode()))</span>
<span class="gi">+            f.write(compressor.flush())</span>
<span class="gh">diff --git a/sphinx/util/logging.py b/sphinx/util/logging.py</span>
<span class="gh">index 00c940a4c..804ef62cc 100644</span>
<span class="gd">--- a/sphinx/util/logging.py</span>
<span class="gi">+++ b/sphinx/util/logging.py</span>
<span class="gu">@@ -1,33 +1,56 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Logging utility functions for Sphinx.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import logging
<span class="w"> </span>import logging.handlers
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from contextlib import contextmanager, nullcontext
<span class="w"> </span>from typing import IO, TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.utils import get_source_line
<span class="gi">+</span>
<span class="w"> </span>from sphinx.errors import SphinxWarning
<span class="w"> </span>from sphinx.util.console import colorize
<span class="w"> </span>from sphinx.util.osutil import abspath
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Iterator, Sequence, Set
<span class="w"> </span>    from typing import NoReturn
<span class="gi">+</span>
<span class="w"> </span>    from docutils.nodes import Node
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>NAMESPACE = &#39;sphinx&#39;
<span class="w"> </span>VERBOSE = 15
<span class="gd">-LEVEL_NAMES: defaultdict[str, int] = defaultdict(lambda : logging.WARNING,</span>
<span class="gd">-    {&#39;CRITICAL&#39;: logging.CRITICAL, &#39;SEVERE&#39;: logging.CRITICAL, &#39;ERROR&#39;:</span>
<span class="gd">-    logging.ERROR, &#39;WARNING&#39;: logging.WARNING, &#39;INFO&#39;: logging.INFO,</span>
<span class="gd">-    &#39;VERBOSE&#39;: VERBOSE, &#39;DEBUG&#39;: logging.DEBUG})</span>
<span class="gd">-VERBOSITY_MAP: defaultdict[int, int] = defaultdict(lambda : logging.NOTSET,</span>
<span class="gd">-    {(0): logging.INFO, (1): VERBOSE, (2): logging.DEBUG})</span>
<span class="gd">-COLOR_MAP: defaultdict[int, str] = defaultdict(lambda : &#39;blue&#39;, {logging.</span>
<span class="gd">-    ERROR: &#39;darkred&#39;, logging.WARNING: &#39;red&#39;, logging.DEBUG: &#39;darkgray&#39;})</span>

<span class="gd">-</span>
<span class="gd">-def getLogger(name: str) -&gt;SphinxLoggerAdapter:</span>
<span class="gi">+LEVEL_NAMES: defaultdict[str, int] = defaultdict(lambda: logging.WARNING, {</span>
<span class="gi">+    &#39;CRITICAL&#39;: logging.CRITICAL,</span>
<span class="gi">+    &#39;SEVERE&#39;: logging.CRITICAL,</span>
<span class="gi">+    &#39;ERROR&#39;: logging.ERROR,</span>
<span class="gi">+    &#39;WARNING&#39;: logging.WARNING,</span>
<span class="gi">+    &#39;INFO&#39;: logging.INFO,</span>
<span class="gi">+    &#39;VERBOSE&#39;: VERBOSE,</span>
<span class="gi">+    &#39;DEBUG&#39;: logging.DEBUG,</span>
<span class="gi">+})</span>
<span class="gi">+</span>
<span class="gi">+VERBOSITY_MAP: defaultdict[int, int] = defaultdict(lambda: logging.NOTSET, {</span>
<span class="gi">+    0: logging.INFO,</span>
<span class="gi">+    1: VERBOSE,</span>
<span class="gi">+    2: logging.DEBUG,</span>
<span class="gi">+})</span>
<span class="gi">+</span>
<span class="gi">+COLOR_MAP: defaultdict[int, str] = defaultdict(lambda: &#39;blue&#39;, {</span>
<span class="gi">+    logging.ERROR: &#39;darkred&#39;,</span>
<span class="gi">+    logging.WARNING: &#39;red&#39;,</span>
<span class="gi">+    logging.DEBUG: &#39;darkgray&#39;,</span>
<span class="gi">+})</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def getLogger(name: str) -&gt; SphinxLoggerAdapter:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get logger wrapped by :class:`sphinx.util.logging.SphinxLoggerAdapter`.

<span class="w"> </span>    Sphinx logger always uses ``sphinx.*`` namespace to be independent from
<span class="gu">@@ -41,37 +64,102 @@ def getLogger(name: str) -&gt;SphinxLoggerAdapter:</span>
<span class="w"> </span>        &gt;&gt;&gt; logger.info(&#39;Hello, this is an extension!&#39;)
<span class="w"> </span>        Hello, this is an extension!
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # add sphinx prefix to name forcely</span>
<span class="gi">+    logger = logging.getLogger(NAMESPACE + &#39;.&#39; + name)</span>
<span class="gi">+    # Forcely enable logger</span>
<span class="gi">+    logger.disabled = False</span>
<span class="gi">+    # wrap logger by SphinxLoggerAdapter</span>
<span class="gi">+    return SphinxLoggerAdapter(logger, {})</span>


<span class="gd">-def convert_serializable(records: list[logging.LogRecord]) -&gt;None:</span>
<span class="gi">+def convert_serializable(records: list[logging.LogRecord]) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert LogRecord serializable.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for r in records:</span>
<span class="gi">+        # extract arguments to a message and clear them</span>
<span class="gi">+        r.msg = r.getMessage()</span>
<span class="gi">+        r.args = ()</span>
<span class="gi">+</span>
<span class="gi">+        location = getattr(r, &#39;location&#39;, None)</span>
<span class="gi">+        if isinstance(location, nodes.Node):</span>
<span class="gi">+            r.location = get_node_location(location)</span>


<span class="w"> </span>class SphinxLogRecord(logging.LogRecord):
<span class="w"> </span>    &quot;&quot;&quot;Log record class supporting location&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    prefix = &#39;&#39;
<span class="w"> </span>    location: Any = None

<span class="gi">+    def getMessage(self) -&gt; str:</span>
<span class="gi">+        message = super().getMessage()</span>
<span class="gi">+        location = getattr(self, &#39;location&#39;, None)</span>
<span class="gi">+        if location:</span>
<span class="gi">+            message = f&#39;{location}: {self.prefix}{message}&#39;</span>
<span class="gi">+        elif self.prefix not in message:</span>
<span class="gi">+            message = self.prefix + message</span>
<span class="gi">+</span>
<span class="gi">+        return message</span>
<span class="gi">+</span>

<span class="w"> </span>class SphinxInfoLogRecord(SphinxLogRecord):
<span class="w"> </span>    &quot;&quot;&quot;Info log record class supporting location&quot;&quot;&quot;
<span class="gd">-    prefix = &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    prefix = &#39;&#39;  # do not show any prefix for INFO messages</span>


<span class="w"> </span>class SphinxWarningLogRecord(SphinxLogRecord):
<span class="w"> </span>    &quot;&quot;&quot;Warning log record class supporting location&quot;&quot;&quot;

<span class="gi">+    @property</span>
<span class="gi">+    def prefix(self) -&gt; str:  # type: ignore[override]</span>
<span class="gi">+        if self.levelno &gt;= logging.CRITICAL:</span>
<span class="gi">+            return &#39;CRITICAL: &#39;</span>
<span class="gi">+        elif self.levelno &gt;= logging.ERROR:</span>
<span class="gi">+            return &#39;ERROR: &#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;WARNING: &#39;</span>
<span class="gi">+</span>

<span class="w"> </span>class SphinxLoggerAdapter(logging.LoggerAdapter):
<span class="w"> </span>    &quot;&quot;&quot;LoggerAdapter allowing ``type`` and ``subtype`` keywords.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    KEYWORDS = [&#39;type&#39;, &#39;subtype&#39;, &#39;location&#39;, &#39;nonl&#39;, &#39;color&#39;, &#39;once&#39;]

<span class="gd">-    def warning(self, msg: object, *args: object, type: (None | str)=None,</span>
<span class="gd">-        subtype: (None | str)=None, location: (None | str | tuple[str |</span>
<span class="gd">-        None, int | None] | Node)=None, nonl: bool=True, color: (str | None</span>
<span class="gd">-        )=None, once: bool=False, **kwargs: Any) -&gt;None:</span>
<span class="gi">+    def log(  # type: ignore[override]</span>
<span class="gi">+        self, level: int | str, msg: str, *args: Any, **kwargs: Any,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if isinstance(level, int):</span>
<span class="gi">+            super().log(level, msg, *args, **kwargs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            levelno = LEVEL_NAMES[level]</span>
<span class="gi">+            super().log(levelno, msg, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def verbose(self, msg: str, *args: Any, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        self.log(VERBOSE, msg, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def process(self, msg: str, kwargs: dict) -&gt; tuple[str, dict]:  # type: ignore[override]</span>
<span class="gi">+        extra = kwargs.setdefault(&#39;extra&#39;, {})</span>
<span class="gi">+        for keyword in self.KEYWORDS:</span>
<span class="gi">+            if keyword in kwargs:</span>
<span class="gi">+                extra[keyword] = kwargs.pop(keyword)</span>
<span class="gi">+</span>
<span class="gi">+        return msg, kwargs</span>
<span class="gi">+</span>
<span class="gi">+    def handle(self, record: logging.LogRecord) -&gt; None:</span>
<span class="gi">+        self.logger.handle(record)</span>
<span class="gi">+</span>
<span class="gi">+    def warning(  # type: ignore[override]</span>
<span class="gi">+        self,</span>
<span class="gi">+        msg: object,</span>
<span class="gi">+        *args: object,</span>
<span class="gi">+        type: None | str = None,</span>
<span class="gi">+        subtype: None | str = None,</span>
<span class="gi">+        location: None | str | tuple[str | None, int | None] | Node = None,</span>
<span class="gi">+        nonl: bool = True,</span>
<span class="gi">+        color: str | None = None,</span>
<span class="gi">+        once: bool = False,</span>
<span class="gi">+        **kwargs: Any,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Log a sphinx warning.

<span class="w"> </span>        It is recommended to include a ``type`` and ``subtype`` for warnings as
<span class="gu">@@ -94,37 +182,100 @@ class SphinxLoggerAdapter(logging.LoggerAdapter):</span>
<span class="w"> </span>        :param once: Do not log this warning,
<span class="w"> </span>            if a previous warning already has same ``msg``, ``args`` and ``once=True``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return super().warning(</span>
<span class="gi">+            msg,</span>
<span class="gi">+            *args,</span>
<span class="gi">+            type=type,</span>
<span class="gi">+            subtype=subtype,</span>
<span class="gi">+            location=location,</span>
<span class="gi">+            nonl=nonl,</span>
<span class="gi">+            color=color,</span>
<span class="gi">+            once=once,</span>
<span class="gi">+            **kwargs,</span>
<span class="gi">+        )</span>


<span class="w"> </span>class WarningStreamHandler(logging.StreamHandler):
<span class="w"> </span>    &quot;&quot;&quot;StreamHandler for warnings.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    pass


<span class="w"> </span>class NewLineStreamHandler(logging.StreamHandler):
<span class="w"> </span>    &quot;&quot;&quot;StreamHandler which switches line terminator by record.nonl flag.&quot;&quot;&quot;

<span class="gi">+    def emit(self, record: logging.LogRecord) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.acquire()</span>
<span class="gi">+            if getattr(record, &#39;nonl&#39;, False):</span>
<span class="gi">+                # skip appending terminator when nonl=True</span>
<span class="gi">+                self.terminator = &#39;&#39;</span>
<span class="gi">+            super().emit(record)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.terminator = &#39;\n&#39;</span>
<span class="gi">+            self.release()</span>
<span class="gi">+</span>

<span class="w"> </span>class MemoryHandler(logging.handlers.BufferingHandler):
<span class="w"> </span>    &quot;&quot;&quot;Handler buffering all logs.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    buffer: list[logging.LogRecord]

<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        super().__init__(-1)

<span class="gi">+    def shouldFlush(self, record: logging.LogRecord) -&gt; bool:</span>
<span class="gi">+        return False  # never flush</span>
<span class="gi">+</span>
<span class="gi">+    def flush(self) -&gt; None:</span>
<span class="gi">+        # suppress any flushes triggered by importing packages that flush</span>
<span class="gi">+        # all handlers at initialization time</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def flushTo(self, logger: logging.Logger) -&gt; None:</span>
<span class="gi">+        self.acquire()</span>
<span class="gi">+        try:</span>
<span class="gi">+            for record in self.buffer:</span>
<span class="gi">+                logger.handle(record)</span>
<span class="gi">+            self.buffer = []</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self.release()</span>
<span class="gi">+</span>
<span class="gi">+    def clear(self) -&gt; list[logging.LogRecord]:</span>
<span class="gi">+        buffer, self.buffer = self.buffer, []</span>
<span class="gi">+        return buffer</span>
<span class="gi">+</span>

<span class="w"> </span>@contextmanager
<span class="gd">-def pending_warnings() -&gt;Iterator[logging.Handler]:</span>
<span class="gi">+def pending_warnings() -&gt; Iterator[logging.Handler]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Context manager to postpone logging warnings temporarily.

<span class="w"> </span>    Similar to :func:`pending_logging`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    logger = logging.getLogger(NAMESPACE)</span>
<span class="gi">+    memhandler = MemoryHandler()</span>
<span class="gi">+    memhandler.setLevel(logging.WARNING)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        handlers = []</span>
<span class="gi">+        for handler in logger.handlers[:]:</span>
<span class="gi">+            if isinstance(handler, WarningStreamHandler):</span>
<span class="gi">+                logger.removeHandler(handler)</span>
<span class="gi">+                handlers.append(handler)</span>
<span class="gi">+</span>
<span class="gi">+        logger.addHandler(memhandler)</span>
<span class="gi">+        yield memhandler</span>
<span class="gi">+    finally:</span>
<span class="gi">+        logger.removeHandler(memhandler)</span>
<span class="gi">+</span>
<span class="gi">+        for handler in handlers:</span>
<span class="gi">+            logger.addHandler(handler)</span>
<span class="gi">+</span>
<span class="gi">+        memhandler.flushTo(logger)</span>


<span class="w"> </span>@contextmanager
<span class="gd">-def suppress_logging() -&gt;Iterator[MemoryHandler]:</span>
<span class="gi">+def suppress_logging() -&gt; Iterator[MemoryHandler]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Context manager to suppress logging all logs temporarily.

<span class="w"> </span>    For example::
<span class="gu">@@ -134,11 +285,26 @@ def suppress_logging() -&gt;Iterator[MemoryHandler]:</span>
<span class="w"> </span>        &gt;&gt;&gt;     some_long_process()
<span class="w"> </span>        &gt;&gt;&gt;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    logger = logging.getLogger(NAMESPACE)</span>
<span class="gi">+    memhandler = MemoryHandler()</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        handlers = []</span>
<span class="gi">+        for handler in logger.handlers[:]:</span>
<span class="gi">+            logger.removeHandler(handler)</span>
<span class="gi">+            handlers.append(handler)</span>
<span class="gi">+</span>
<span class="gi">+        logger.addHandler(memhandler)</span>
<span class="gi">+        yield memhandler</span>
<span class="gi">+    finally:</span>
<span class="gi">+        logger.removeHandler(memhandler)</span>
<span class="gi">+</span>
<span class="gi">+        for handler in handlers:</span>
<span class="gi">+            logger.addHandler(handler)</span>


<span class="w"> </span>@contextmanager
<span class="gd">-def pending_logging() -&gt;Iterator[MemoryHandler]:</span>
<span class="gi">+def pending_logging() -&gt; Iterator[MemoryHandler]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Context manager to postpone logging all logs temporarily.

<span class="w"> </span>    For example::
<span class="gu">@@ -149,14 +315,19 @@ def pending_logging() -&gt;Iterator[MemoryHandler]:</span>
<span class="w"> </span>        &gt;&gt;&gt;
<span class="w"> </span>        Warning message!  # the warning is flushed here
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    logger = logging.getLogger(NAMESPACE)</span>
<span class="gi">+    try:</span>
<span class="gi">+        with suppress_logging() as memhandler:</span>
<span class="gi">+            yield memhandler</span>
<span class="gi">+    finally:</span>
<span class="gi">+        memhandler.flushTo(logger)</span>


<span class="gd">-skip_warningiserror = nullcontext</span>
<span class="gi">+skip_warningiserror = nullcontext  # Deprecate in Sphinx 10</span>


<span class="w"> </span>@contextmanager
<span class="gd">-def prefixed_warnings(prefix: str) -&gt;Iterator[None]:</span>
<span class="gi">+def prefixed_warnings(prefix: str) -&gt; Iterator[None]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Context manager to prepend prefix to all warning log records temporarily.

<span class="w"> </span>    For example::
<span class="gu">@@ -166,52 +337,145 @@ def prefixed_warnings(prefix: str) -&gt;Iterator[None]:</span>

<span class="w"> </span>    .. versionadded:: 2.0
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    logger = logging.getLogger(NAMESPACE)</span>
<span class="gi">+    warning_handler = None</span>
<span class="gi">+    for handler in logger.handlers:</span>
<span class="gi">+        if isinstance(handler, WarningStreamHandler):</span>
<span class="gi">+            warning_handler = handler</span>
<span class="gi">+            break</span>
<span class="gi">+    else:</span>
<span class="gi">+        # warning stream not found</span>
<span class="gi">+        yield</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    prefix_filter = None</span>
<span class="gi">+    for _filter in warning_handler.filters:</span>
<span class="gi">+        if isinstance(_filter, MessagePrefixFilter):</span>
<span class="gi">+            prefix_filter = _filter</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+    if prefix_filter:</span>
<span class="gi">+        # already prefixed</span>
<span class="gi">+        try:</span>
<span class="gi">+            previous = prefix_filter.prefix</span>
<span class="gi">+            prefix_filter.prefix = prefix</span>
<span class="gi">+            yield</span>
<span class="gi">+        finally:</span>
<span class="gi">+            prefix_filter.prefix = previous</span>
<span class="gi">+    else:</span>
<span class="gi">+        # not prefixed yet</span>
<span class="gi">+        prefix_filter = MessagePrefixFilter(prefix)</span>
<span class="gi">+        try:</span>
<span class="gi">+            warning_handler.addFilter(prefix_filter)</span>
<span class="gi">+            yield</span>
<span class="gi">+        finally:</span>
<span class="gi">+            warning_handler.removeFilter(prefix_filter)</span>


<span class="w"> </span>class LogCollector:
<span class="gd">-</span>
<span class="gd">-    def __init__(self) -&gt;None:</span>
<span class="gi">+    def __init__(self) -&gt; None:</span>
<span class="w"> </span>        self.logs: list[logging.LogRecord] = []

<span class="gi">+    @contextmanager</span>
<span class="gi">+    def collect(self) -&gt; Iterator[None]:</span>
<span class="gi">+        with pending_logging() as memhandler:</span>
<span class="gi">+            yield</span>
<span class="gi">+</span>
<span class="gi">+            self.logs = memhandler.clear()</span>
<span class="gi">+</span>

<span class="w"> </span>class InfoFilter(logging.Filter):
<span class="w"> </span>    &quot;&quot;&quot;Filter error and warning messages.&quot;&quot;&quot;

<span class="gi">+    def filter(self, record: logging.LogRecord) -&gt; bool:</span>
<span class="gi">+        return record.levelno &lt; logging.WARNING</span>
<span class="gi">+</span>

<span class="w"> </span>class _RaiseOnWarningFilter(logging.Filter):
<span class="w"> </span>    &quot;&quot;&quot;Raise exception if a warning is emitted.&quot;&quot;&quot;

<span class="gd">-</span>
<span class="gd">-def is_suppressed_warning(warning_type: str, sub_type: str,</span>
<span class="gd">-    suppress_warnings: (Set[str] | Sequence[str])) -&gt;bool:</span>
<span class="gi">+    def filter(self, record: logging.LogRecord) -&gt; NoReturn:</span>
<span class="gi">+        try:</span>
<span class="gi">+            message = record.msg % record.args</span>
<span class="gi">+        except (TypeError, ValueError):</span>
<span class="gi">+            message = record.msg  # use record.msg itself</span>
<span class="gi">+        if location := getattr(record, &#39;location&#39;, &#39;&#39;):</span>
<span class="gi">+            message = f&quot;{location}:{message}&quot;</span>
<span class="gi">+        if record.exc_info is not None:</span>
<span class="gi">+            raise SphinxWarning(message) from record.exc_info[1]</span>
<span class="gi">+        raise SphinxWarning(message)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_suppressed_warning(</span>
<span class="gi">+    warning_type: str, sub_type: str, suppress_warnings: Set[str] | Sequence[str],</span>
<span class="gi">+) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check whether the warning is suppressed or not.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if warning_type is None or len(suppress_warnings) == 0:</span>
<span class="gi">+        return False</span>
<span class="gi">+    suppressed_warnings = frozenset(suppress_warnings)</span>
<span class="gi">+    if warning_type in suppressed_warnings:</span>
<span class="gi">+        return True</span>
<span class="gi">+    if f&#39;{warning_type}.*&#39; in suppressed_warnings:</span>
<span class="gi">+        return True</span>
<span class="gi">+    return f&#39;{warning_type}.{sub_type}&#39; in suppressed_warnings</span>


<span class="w"> </span>class WarningSuppressor(logging.Filter):
<span class="w"> </span>    &quot;&quot;&quot;Filter logs by `suppress_warnings`.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, app: Sphinx) -&gt;None:</span>
<span class="gi">+    def __init__(self, app: Sphinx) -&gt; None:</span>
<span class="w"> </span>        self.app = app
<span class="w"> </span>        super().__init__()

<span class="gi">+    def filter(self, record: logging.LogRecord) -&gt; bool:</span>
<span class="gi">+        type = getattr(record, &#39;type&#39;, &#39;&#39;)</span>
<span class="gi">+        subtype = getattr(record, &#39;subtype&#39;, &#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            suppress_warnings = self.app.config.suppress_warnings</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            # config is not initialized yet (ex. in conf.py)</span>
<span class="gi">+            suppress_warnings = ()</span>
<span class="gi">+</span>
<span class="gi">+        if is_suppressed_warning(type, subtype, suppress_warnings):</span>
<span class="gi">+            return False</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.app._warncount += 1</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>

<span class="w"> </span>class MessagePrefixFilter(logging.Filter):
<span class="w"> </span>    &quot;&quot;&quot;Prepend prefix to all log records.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, prefix: str) -&gt;None:</span>
<span class="gi">+    def __init__(self, prefix: str) -&gt; None:</span>
<span class="w"> </span>        self.prefix = prefix
<span class="w"> </span>        super().__init__()

<span class="gi">+    def filter(self, record: logging.LogRecord) -&gt; bool:</span>
<span class="gi">+        if self.prefix:</span>
<span class="gi">+            record.msg = self.prefix + &#39; &#39; + record.msg</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>

<span class="w"> </span>class OnceFilter(logging.Filter):
<span class="w"> </span>    &quot;&quot;&quot;Show the message only once.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, name: str=&#39;&#39;) -&gt;None:</span>
<span class="gi">+    def __init__(self, name: str = &#39;&#39;) -&gt; None:</span>
<span class="w"> </span>        super().__init__(name)
<span class="w"> </span>        self.messages: dict[str, list] = {}

<span class="gi">+    def filter(self, record: logging.LogRecord) -&gt; bool:</span>
<span class="gi">+        once = getattr(record, &#39;once&#39;, &#39;&#39;)</span>
<span class="gi">+        if not once:</span>
<span class="gi">+            return True</span>
<span class="gi">+        else:</span>
<span class="gi">+            params = self.messages.setdefault(record.msg, [])</span>
<span class="gi">+            if record.args in params:</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+            params.append(record.args)</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>

<span class="w"> </span>class SphinxLogRecordTranslator(logging.Filter):
<span class="w"> </span>    &quot;&quot;&quot;Converts a log record to one Sphinx expects
<span class="gu">@@ -220,42 +484,148 @@ class SphinxLogRecordTranslator(logging.Filter):</span>
<span class="w"> </span>    * docname to path if location given
<span class="w"> </span>    * append warning type/subtype to message if :confval:`show_warning_types` is ``True``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    LogRecordClass: type[logging.LogRecord]

<span class="gd">-    def __init__(self, app: Sphinx) -&gt;None:</span>
<span class="gi">+    def __init__(self, app: Sphinx) -&gt; None:</span>
<span class="w"> </span>        self.app = app
<span class="w"> </span>        super().__init__()

<span class="gi">+    def filter(self, record: SphinxWarningLogRecord) -&gt; bool:  # type: ignore[override]</span>
<span class="gi">+        if isinstance(record, logging.LogRecord):</span>
<span class="gi">+            # force subclassing to handle location</span>
<span class="gi">+            record.__class__ = self.LogRecordClass  # type: ignore[assignment]</span>
<span class="gi">+</span>
<span class="gi">+        location = getattr(record, &#39;location&#39;, None)</span>
<span class="gi">+        if isinstance(location, tuple):</span>
<span class="gi">+            docname, lineno = location</span>
<span class="gi">+            if docname:</span>
<span class="gi">+                if lineno:</span>
<span class="gi">+                    record.location = f&#39;{self.app.env.doc2path(docname)}:{lineno}&#39;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    record.location = f&#39;{self.app.env.doc2path(docname)}&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                record.location = None</span>
<span class="gi">+        elif isinstance(location, nodes.Node):</span>
<span class="gi">+            record.location = get_node_location(location)</span>
<span class="gi">+        elif location and &#39;:&#39; not in location:</span>
<span class="gi">+            record.location = f&#39;{self.app.env.doc2path(location)}&#39;</span>
<span class="gi">+</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>

<span class="w"> </span>class InfoLogRecordTranslator(SphinxLogRecordTranslator):
<span class="w"> </span>    &quot;&quot;&quot;LogRecordTranslator for INFO level log records.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    LogRecordClass = SphinxInfoLogRecord


<span class="w"> </span>class WarningLogRecordTranslator(SphinxLogRecordTranslator):
<span class="w"> </span>    &quot;&quot;&quot;LogRecordTranslator for WARNING level log records.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    LogRecordClass = SphinxWarningLogRecord

<span class="gi">+    def filter(self, record: SphinxWarningLogRecord) -&gt; bool:  # type: ignore[override]</span>
<span class="gi">+        ret = super().filter(record)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            show_warning_types = self.app.config.show_warning_types</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            # config is not initialized yet (ex. in conf.py)</span>
<span class="gi">+            show_warning_types = False</span>
<span class="gi">+        if show_warning_types:</span>
<span class="gi">+            if log_type := getattr(record, &#39;type&#39;, &#39;&#39;):</span>
<span class="gi">+                if log_subtype := getattr(record, &#39;subtype&#39;, &#39;&#39;):</span>
<span class="gi">+                    record.msg += f&#39; [{log_type}.{log_subtype}]&#39;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    record.msg += f&#39; [{log_type}]&#39;</span>
<span class="gi">+</span>
<span class="gi">+        return ret</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_node_location(node: Node) -&gt; str | None:</span>
<span class="gi">+    source, line = get_source_line(node)</span>
<span class="gi">+    if source and line:</span>
<span class="gi">+        return f&quot;{abspath(source)}:{line}&quot;</span>
<span class="gi">+    if source:</span>
<span class="gi">+        return f&quot;{abspath(source)}:&quot;</span>
<span class="gi">+    if line:</span>
<span class="gi">+        return f&quot;&lt;unknown&gt;:{line}&quot;</span>
<span class="gi">+    return None</span>
<span class="gi">+</span>

<span class="w"> </span>class ColorizeFormatter(logging.Formatter):
<span class="gd">-    pass</span>
<span class="gi">+    def format(self, record: logging.LogRecord) -&gt; str:</span>
<span class="gi">+        message = super().format(record)</span>
<span class="gi">+        color = getattr(record, &#39;color&#39;, None)</span>
<span class="gi">+        if color is None:</span>
<span class="gi">+            color = COLOR_MAP.get(record.levelno)</span>
<span class="gi">+</span>
<span class="gi">+        if color:</span>
<span class="gi">+            return colorize(color, message)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return message</span>


<span class="w"> </span>class SafeEncodingWriter:
<span class="w"> </span>    &quot;&quot;&quot;Stream writer which ignores UnicodeEncodeError silently&quot;&quot;&quot;

<span class="gd">-    def __init__(self, stream: IO) -&gt;None:</span>
<span class="gi">+    def __init__(self, stream: IO) -&gt; None:</span>
<span class="w"> </span>        self.stream = stream
<span class="w"> </span>        self.encoding = getattr(stream, &#39;encoding&#39;, &#39;ascii&#39;) or &#39;ascii&#39;

<span class="gi">+    def write(self, data: str) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.stream.write(data)</span>
<span class="gi">+        except UnicodeEncodeError:</span>
<span class="gi">+            # stream accept only str, not bytes.  So, we encode and replace</span>
<span class="gi">+            # non-encodable characters, then decode them.</span>
<span class="gi">+            self.stream.write(data.encode(self.encoding, &#39;replace&#39;).decode(self.encoding))</span>
<span class="gi">+</span>
<span class="gi">+    def flush(self) -&gt; None:</span>
<span class="gi">+        if hasattr(self.stream, &#39;flush&#39;):</span>
<span class="gi">+            self.stream.flush()</span>
<span class="gi">+</span>

<span class="w"> </span>class LastMessagesWriter:
<span class="w"> </span>    &quot;&quot;&quot;Stream writer storing last 10 messages in memory to save trackback&quot;&quot;&quot;

<span class="gd">-    def __init__(self, app: Sphinx, stream: IO) -&gt;None:</span>
<span class="gi">+    def __init__(self, app: Sphinx, stream: IO) -&gt; None:</span>
<span class="w"> </span>        self.app = app

<span class="gi">+    def write(self, data: str) -&gt; None:</span>
<span class="gi">+        self.app.messagelog.append(data)</span>

<span class="gd">-def setup(app: Sphinx, status: IO, warning: IO) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx, status: IO, warning: IO) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Setup root logger for Sphinx&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    logger = logging.getLogger(NAMESPACE)</span>
<span class="gi">+    logger.setLevel(logging.DEBUG)</span>
<span class="gi">+    logger.propagate = False</span>
<span class="gi">+</span>
<span class="gi">+    # clear all handlers</span>
<span class="gi">+    for handler in logger.handlers[:]:</span>
<span class="gi">+        logger.removeHandler(handler)</span>
<span class="gi">+</span>
<span class="gi">+    info_handler = NewLineStreamHandler(SafeEncodingWriter(status))</span>
<span class="gi">+    info_handler.addFilter(InfoFilter())</span>
<span class="gi">+    info_handler.addFilter(InfoLogRecordTranslator(app))</span>
<span class="gi">+    info_handler.setLevel(VERBOSITY_MAP[app.verbosity])</span>
<span class="gi">+    info_handler.setFormatter(ColorizeFormatter())</span>
<span class="gi">+</span>
<span class="gi">+    warning_handler = WarningStreamHandler(SafeEncodingWriter(warning))</span>
<span class="gi">+    if app._exception_on_warning:</span>
<span class="gi">+        warning_handler.addFilter(_RaiseOnWarningFilter())</span>
<span class="gi">+    warning_handler.addFilter(WarningSuppressor(app))</span>
<span class="gi">+    warning_handler.addFilter(WarningLogRecordTranslator(app))</span>
<span class="gi">+    warning_handler.addFilter(OnceFilter())</span>
<span class="gi">+    warning_handler.setLevel(logging.WARNING)</span>
<span class="gi">+    warning_handler.setFormatter(ColorizeFormatter())</span>
<span class="gi">+</span>
<span class="gi">+    messagelog_handler = logging.StreamHandler(LastMessagesWriter(app, status))</span>
<span class="gi">+    messagelog_handler.addFilter(InfoFilter())</span>
<span class="gi">+    messagelog_handler.setLevel(VERBOSITY_MAP[app.verbosity])</span>
<span class="gi">+</span>
<span class="gi">+    logger.addHandler(info_handler)</span>
<span class="gi">+    logger.addHandler(warning_handler)</span>
<span class="gi">+    logger.addHandler(messagelog_handler)</span>
<span class="gh">diff --git a/sphinx/util/matching.py b/sphinx/util/matching.py</span>
<span class="gh">index de4967a6a..79c56dd2e 100644</span>
<span class="gd">--- a/sphinx/util/matching.py</span>
<span class="gi">+++ b/sphinx/util/matching.py</span>
<span class="gu">@@ -1,20 +1,67 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Pattern-matching utility functions for Sphinx.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os.path
<span class="w"> </span>import re
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from sphinx.util.osutil import canon_path, path_stabilize
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Callable, Iterable, Iterator


<span class="gd">-def _translate_pattern(pat: str) -&gt;str:</span>
<span class="gi">+def _translate_pattern(pat: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Translate a shell-style glob pattern to a regular expression.

<span class="w"> </span>    Adapted from the fnmatch module, but enhanced so that single stars don&#39;t
<span class="w"> </span>    match slashes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    i, n = 0, len(pat)</span>
<span class="gi">+    res = &#39;&#39;</span>
<span class="gi">+    while i &lt; n:</span>
<span class="gi">+        c = pat[i]</span>
<span class="gi">+        i += 1</span>
<span class="gi">+        if c == &#39;*&#39;:</span>
<span class="gi">+            if i &lt; n and pat[i] == &#39;*&#39;:</span>
<span class="gi">+                # double star matches slashes too</span>
<span class="gi">+                i += 1</span>
<span class="gi">+                res = res + &#39;.*&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                # single star doesn&#39;t match slashes</span>
<span class="gi">+                res = res + &#39;[^/]*&#39;</span>
<span class="gi">+        elif c == &#39;?&#39;:</span>
<span class="gi">+            # question mark doesn&#39;t match slashes too</span>
<span class="gi">+            res = res + &#39;[^/]&#39;</span>
<span class="gi">+        elif c == &#39;[&#39;:</span>
<span class="gi">+            j = i</span>
<span class="gi">+            if j &lt; n and pat[j] == &#39;!&#39;:</span>
<span class="gi">+                j += 1</span>
<span class="gi">+            if j &lt; n and pat[j] == &#39;]&#39;:</span>
<span class="gi">+                j += 1</span>
<span class="gi">+            while j &lt; n and pat[j] != &#39;]&#39;:</span>
<span class="gi">+                j += 1</span>
<span class="gi">+            if j &gt;= n:</span>
<span class="gi">+                res = res + &#39;\\[&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                stuff = pat[i:j].replace(&#39;\\&#39;, &#39;\\\\&#39;)</span>
<span class="gi">+                i = j + 1</span>
<span class="gi">+                if stuff[0] == &#39;!&#39;:</span>
<span class="gi">+                    # negative pattern mustn&#39;t match slashes too</span>
<span class="gi">+                    stuff = &#39;^/&#39; + stuff[1:]</span>
<span class="gi">+                elif stuff[0] == &#39;^&#39;:</span>
<span class="gi">+                    stuff = &#39;\\&#39; + stuff</span>
<span class="gi">+                res = f&#39;{res}[{stuff}]&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            res += re.escape(c)</span>
<span class="gi">+    return res + &#39;$&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def compile_matchers(</span>
<span class="gi">+    patterns: Iterable[str],</span>
<span class="gi">+) -&gt; list[Callable[[str], re.Match[str] | None]]:</span>
<span class="gi">+    return [re.compile(_translate_pattern(pat)).match for pat in patterns]</span>


<span class="w"> </span>class Matcher:
<span class="gu">@@ -24,37 +71,50 @@ class Matcher:</span>
<span class="w"> </span>          For example, &quot;**/index.rst&quot; matches with &quot;index.rst&quot;
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, exclude_patterns: Iterable[str]) -&gt;None:</span>
<span class="gd">-        expanded = [pat[3:] for pat in exclude_patterns if pat.startswith(</span>
<span class="gd">-            &#39;**/&#39;)]</span>
<span class="gi">+    def __init__(self, exclude_patterns: Iterable[str]) -&gt; None:</span>
<span class="gi">+        expanded = [pat[3:] for pat in exclude_patterns if pat.startswith(&#39;**/&#39;)]</span>
<span class="w"> </span>        self.patterns = compile_matchers(list(exclude_patterns) + expanded)

<span class="gd">-    def __call__(self, string: str) -&gt;bool:</span>
<span class="gi">+    def __call__(self, string: str) -&gt; bool:</span>
<span class="w"> </span>        return self.match(string)

<span class="gi">+    def match(self, string: str) -&gt; bool:</span>
<span class="gi">+        string = canon_path(string)</span>
<span class="gi">+        return any(pat(string) for pat in self.patterns)</span>
<span class="gi">+</span>

<span class="w"> </span>DOTFILES = Matcher([&#39;**/.*&#39;])
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>_pat_cache: dict[str, re.Pattern[str]] = {}


<span class="gd">-def patmatch(name: str, pat: str) -&gt;(re.Match[str] | None):</span>
<span class="gi">+def patmatch(name: str, pat: str) -&gt; re.Match[str] | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return if name matches the regular expression (pattern)
<span class="w"> </span>    ``pat```. Adapted from fnmatch module.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if pat not in _pat_cache:</span>
<span class="gi">+        _pat_cache[pat] = re.compile(_translate_pattern(pat))</span>
<span class="gi">+    return _pat_cache[pat].match(name)</span>


<span class="gd">-def patfilter(names: Iterable[str], pat: str) -&gt;list[str]:</span>
<span class="gi">+def patfilter(names: Iterable[str], pat: str) -&gt; list[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the subset of the list ``names`` that match
<span class="w"> </span>    the regular expression (pattern) ``pat``.

<span class="w"> </span>    Adapted from fnmatch module.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if pat not in _pat_cache:</span>
<span class="gi">+        _pat_cache[pat] = re.compile(_translate_pattern(pat))</span>
<span class="gi">+    match = _pat_cache[pat].match</span>
<span class="gi">+    return list(filter(match, names))</span>


<span class="gd">-def get_matching_files(dirname: (str | os.PathLike[str]), include_patterns:</span>
<span class="gd">-    Iterable[str]=(&#39;**&#39;,), exclude_patterns: Iterable[str]=()) -&gt;Iterator[str]:</span>
<span class="gi">+def get_matching_files(</span>
<span class="gi">+    dirname: str | os.PathLike[str],</span>
<span class="gi">+    include_patterns: Iterable[str] = (&quot;**&quot;,),</span>
<span class="gi">+    exclude_patterns: Iterable[str] = (),</span>
<span class="gi">+) -&gt; Iterator[str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get all file names in a directory, recursively.

<span class="w"> </span>    Filter file names by the glob-style include_patterns and exclude_patterns.
<span class="gu">@@ -64,4 +124,47 @@ def get_matching_files(dirname: (str | os.PathLike[str]), include_patterns:</span>
<span class="w"> </span>    exclusions from *exclude_patterns* take priority over inclusions.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # dirname is a normalized absolute path.</span>
<span class="gi">+    dirname = os.path.normpath(os.path.abspath(dirname))</span>
<span class="gi">+</span>
<span class="gi">+    exclude_matchers = compile_matchers(exclude_patterns)</span>
<span class="gi">+    include_matchers = compile_matchers(include_patterns)</span>
<span class="gi">+</span>
<span class="gi">+    for root, dirs, files in os.walk(dirname, followlinks=True):</span>
<span class="gi">+        relative_root = os.path.relpath(root, dirname)</span>
<span class="gi">+        if relative_root == &quot;.&quot;:</span>
<span class="gi">+            relative_root = &quot;&quot;  # suppress dirname for files on the target dir</span>
<span class="gi">+</span>
<span class="gi">+        # Filter files</span>
<span class="gi">+        included_files = []</span>
<span class="gi">+        for entry in sorted(files):</span>
<span class="gi">+            entry = path_stabilize(os.path.join(relative_root, entry))</span>
<span class="gi">+            keep = False</span>
<span class="gi">+            for matcher in include_matchers:</span>
<span class="gi">+                if matcher(entry):</span>
<span class="gi">+                    keep = True</span>
<span class="gi">+                    break  # break the inner loop</span>
<span class="gi">+</span>
<span class="gi">+            for matcher in exclude_matchers:</span>
<span class="gi">+                if matcher(entry):</span>
<span class="gi">+                    keep = False</span>
<span class="gi">+                    break  # break the inner loop</span>
<span class="gi">+</span>
<span class="gi">+            if keep:</span>
<span class="gi">+                included_files.append(entry)</span>
<span class="gi">+</span>
<span class="gi">+        # Filter directories</span>
<span class="gi">+        filtered_dirs = []</span>
<span class="gi">+        for dir_name in sorted(dirs):</span>
<span class="gi">+            normalised = path_stabilize(os.path.join(relative_root, dir_name))</span>
<span class="gi">+            for matcher in exclude_matchers:</span>
<span class="gi">+                if matcher(normalised):</span>
<span class="gi">+                    break  # break the inner loop</span>
<span class="gi">+            else:</span>
<span class="gi">+                # if the loop didn&#39;t break</span>
<span class="gi">+                filtered_dirs.append(dir_name)</span>
<span class="gi">+</span>
<span class="gi">+        dirs[:] = filtered_dirs</span>
<span class="gi">+</span>
<span class="gi">+        # Yield filtered files</span>
<span class="gi">+        yield from included_files</span>
<span class="gh">diff --git a/sphinx/util/math.py b/sphinx/util/math.py</span>
<span class="gh">index 63ddbabd2..576fdcf53 100644</span>
<span class="gd">--- a/sphinx/util/math.py</span>
<span class="gi">+++ b/sphinx/util/math.py</span>
<span class="gu">@@ -1,6 +1,62 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Utility functions for math.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils import nodes
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.writers.html5 import HTML5Translator
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_node_equation_number(writer: HTML5Translator, node: nodes.math_block) -&gt; str:</span>
<span class="gi">+    if writer.builder.config.math_numfig and writer.builder.config.numfig:</span>
<span class="gi">+        figtype = &#39;displaymath&#39;</span>
<span class="gi">+        if writer.builder.name == &#39;singlehtml&#39;:</span>
<span class="gi">+            key = f&quot;{writer.docnames[-1]}/{figtype}&quot;  # type: ignore[has-type]</span>
<span class="gi">+        else:</span>
<span class="gi">+            key = figtype</span>
<span class="gi">+</span>
<span class="gi">+        id = node[&#39;ids&#39;][0]</span>
<span class="gi">+        number = writer.builder.fignumbers.get(key, {}).get(id, ())</span>
<span class="gi">+        eqno = &#39;.&#39;.join(map(str, number))</span>
<span class="gi">+        eqno = writer.builder.config.math_numsep.join(eqno.rsplit(&#39;.&#39;, 1))</span>
<span class="gi">+        return eqno</span>
<span class="gi">+    else:</span>
<span class="gi">+        return node[&#39;number&#39;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def wrap_displaymath(text: str, label: str | None, numbering: bool) -&gt; str:</span>
<span class="gi">+    def is_equation(part: str) -&gt; str:</span>
<span class="gi">+        return part.strip()</span>
<span class="gi">+</span>
<span class="gi">+    if label is None:</span>
<span class="gi">+        labeldef = &#39;&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        labeldef = r&#39;\label{%s}&#39; % label</span>
<span class="gi">+        numbering = True</span>
<span class="gi">+</span>
<span class="gi">+    parts = list(filter(is_equation, text.split(&#39;\n\n&#39;)))</span>
<span class="gi">+    equations = []</span>
<span class="gi">+    if len(parts) == 0:</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+    elif len(parts) == 1:</span>
<span class="gi">+        if numbering:</span>
<span class="gi">+            begin = r&#39;\begin{equation}&#39; + labeldef</span>
<span class="gi">+            end = r&#39;\end{equation}&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            begin = r&#39;\begin{equation*}&#39; + labeldef</span>
<span class="gi">+            end = r&#39;\end{equation*}&#39;</span>
<span class="gi">+        equations.append(&#39;\\begin{split}%s\\end{split}\n&#39; % parts[0])</span>
<span class="gi">+    else:</span>
<span class="gi">+        if numbering:</span>
<span class="gi">+            begin = r&#39;\begin{align}%s\!\begin{aligned}&#39; % labeldef</span>
<span class="gi">+            end = r&#39;\end{aligned}\end{align}&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            begin = r&#39;\begin{align*}%s\!\begin{aligned}&#39; % labeldef</span>
<span class="gi">+            end = r&#39;\end{aligned}\end{align*}&#39;</span>
<span class="gi">+        equations.extend(&#39;%s\\\\\n&#39; % part.strip() for part in parts)</span>
<span class="gi">+</span>
<span class="gi">+    concatenated_equations = &#39;&#39;.join(equations)</span>
<span class="gi">+    return f&#39;{begin}\n{concatenated_equations}{end}&#39;</span>
<span class="gh">diff --git a/sphinx/util/nodes.py b/sphinx/util/nodes.py</span>
<span class="gh">index c491cf3fb..01ce81290 100644</span>
<span class="gd">--- a/sphinx/util/nodes.py</span>
<span class="gi">+++ b/sphinx/util/nodes.py</span>
<span class="gu">@@ -1,28 +1,41 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Docutils node-related utility functions for Sphinx.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import contextlib
<span class="w"> </span>import re
<span class="w"> </span>import unicodedata
<span class="w"> </span>from typing import TYPE_CHECKING, Any, Generic, TypeVar, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.nodes import Node
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.parsing import _fresh_title_style_context
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Callable, Iterable, Iterator
<span class="gi">+</span>
<span class="w"> </span>    from docutils.nodes import Element
<span class="w"> </span>    from docutils.parsers.rst import Directive
<span class="w"> </span>    from docutils.parsers.rst.states import Inliner, RSTState
<span class="w"> </span>    from docutils.statemachine import StringList
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.builders import Builder
<span class="w"> </span>    from sphinx.environment import BuildEnvironment
<span class="w"> </span>    from sphinx.util.tags import Tags
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gd">-explicit_title_re = re.compile(&#39;^(.+?)\\s*(?&lt;!\\x00)&lt;([^&lt;]*?)&gt;$&#39;, re.DOTALL)</span>
<span class="gd">-caption_ref_re = explicit_title_re</span>
<span class="gd">-N = TypeVar(&#39;N&#39;, bound=Node)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# \x00 means the &quot;&lt;&quot; was backslash-escaped</span>
<span class="gi">+explicit_title_re = re.compile(r&#39;^(.+?)\s*(?&lt;!\x00)&lt;([^&lt;]*?)&gt;$&#39;, re.DOTALL)</span>
<span class="gi">+caption_ref_re = explicit_title_re  # b/w compat alias</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+N = TypeVar(&quot;N&quot;, bound=Node)</span>


<span class="w"> </span>class NodeMatcher(Generic[N]):
<span class="gu">@@ -46,33 +59,56 @@ class NodeMatcher(Generic[N]):</span>
<span class="w"> </span>        # =&gt; [&lt;reference ...&gt;, &lt;reference ...&gt;, ...]
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, *node_classes: type[N], **attrs: Any) -&gt;None:</span>
<span class="gi">+    def __init__(self, *node_classes: type[N], **attrs: Any) -&gt; None:</span>
<span class="w"> </span>        self.classes = node_classes
<span class="w"> </span>        self.attrs = attrs

<span class="gd">-    def __call__(self, node: Node) -&gt;bool:</span>
<span class="gi">+    def match(self, node: Node) -&gt; bool:</span>
<span class="gi">+        try:</span>
<span class="gi">+            if self.classes and not isinstance(node, self.classes):</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+            if self.attrs:</span>
<span class="gi">+                if not isinstance(node, nodes.Element):</span>
<span class="gi">+                    return False</span>
<span class="gi">+</span>
<span class="gi">+                for key, value in self.attrs.items():</span>
<span class="gi">+                    if key not in node:</span>
<span class="gi">+                        return False</span>
<span class="gi">+                    elif value is Any:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    elif node.get(key) != value:</span>
<span class="gi">+                        return False</span>
<span class="gi">+</span>
<span class="gi">+            return True</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            # for non-Element nodes</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(self, node: Node) -&gt; bool:</span>
<span class="w"> </span>        return self.match(node)

<span class="gd">-    def findall(self, node: Node) -&gt;Iterator[N]:</span>
<span class="gi">+    def findall(self, node: Node) -&gt; Iterator[N]:</span>
<span class="w"> </span>        &quot;&quot;&quot;An alternative to `Node.findall` with improved type safety.

<span class="w"> </span>        While the `NodeMatcher` object can be used as an argument to `Node.findall`, doing so
<span class="w"> </span>        confounds type checkers&#39; ability to determine the return type of the iterator.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for found in node.findall(self):</span>
<span class="gi">+            yield cast(N, found)</span>


<span class="gd">-def get_full_module_name(node: Node) -&gt;str:</span>
<span class="gi">+def get_full_module_name(node: Node) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return full module dotted path like: &#39;docutils.nodes.paragraph&#39;

<span class="w"> </span>    :param nodes.Node node: target node
<span class="w"> </span>    :return: full module dotted path
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return f&#39;{node.__module__}.{node.__class__.__name__}&#39;</span>


<span class="gd">-def repr_domxml(node: Node, length: int=80) -&gt;str:</span>
<span class="gi">+def repr_domxml(node: Node, length: int = 80) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    return DOM XML representation of the specified node like:
<span class="w"> </span>    &#39;&lt;paragraph translatable=&quot;False&quot;&gt;&lt;inline classes=&quot;versionadded&quot;&gt;Added in version...&#39;
<span class="gu">@@ -83,29 +119,214 @@ def repr_domxml(node: Node, length: int=80) -&gt;str:</span>
<span class="w"> </span>       returns full of DOM XML representation.
<span class="w"> </span>    :return: DOM XML representation
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-IGNORED_NODES = (nodes.Invisible, nodes.literal_block, nodes.doctest_block,</span>
<span class="gd">-    addnodes.versionmodified)</span>
<span class="gd">-LITERAL_TYPE_NODES = (nodes.literal_block, nodes.doctest_block, nodes.</span>
<span class="gd">-    math_block, nodes.raw)</span>
<span class="gd">-IMAGE_TYPE_NODES = nodes.image,</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def extract_messages(doctree: Element) -&gt;Iterable[tuple[Element, str]]:</span>
<span class="gi">+    try:</span>
<span class="gi">+        text = node.asdom().toxml()</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        text = str(node)</span>
<span class="gi">+    if length and len(text) &gt; length:</span>
<span class="gi">+        text = text[:length] + &#39;...&#39;</span>
<span class="gi">+    return text</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def apply_source_workaround(node: Element) -&gt; None:</span>
<span class="gi">+    # workaround: nodes.term have wrong rawsource if classifier is specified.</span>
<span class="gi">+    # The behavior of docutils-0.11, 0.12 is:</span>
<span class="gi">+    # * when ``term text : classifier1 : classifier2`` is specified,</span>
<span class="gi">+    # * rawsource of term node will have: ``term text : classifier1 : classifier2``</span>
<span class="gi">+    # * rawsource of classifier node will be None</span>
<span class="gi">+    if isinstance(node, nodes.classifier) and not node.rawsource:</span>
<span class="gi">+        logger.debug(&#39;[i18n] PATCH: %r to have source, line and rawsource: %s&#39;,</span>
<span class="gi">+                     get_full_module_name(node), repr_domxml(node))</span>
<span class="gi">+        definition_list_item = node.parent</span>
<span class="gi">+        node.source = definition_list_item.source</span>
<span class="gi">+        node.line = definition_list_item.line - 1  # type: ignore[operator]</span>
<span class="gi">+        node.rawsource = node.astext()  # set &#39;classifier1&#39; (or &#39;classifier2&#39;)</span>
<span class="gi">+    elif isinstance(node, nodes.classifier) and not node.source:</span>
<span class="gi">+        # docutils-0.15 fills in rawsource attribute, but not in source.</span>
<span class="gi">+        node.source = node.parent.source</span>
<span class="gi">+    if isinstance(node, nodes.image) and node.source is None:</span>
<span class="gi">+        logger.debug(&#39;[i18n] PATCH: %r to have source, line: %s&#39;,</span>
<span class="gi">+                     get_full_module_name(node), repr_domxml(node))</span>
<span class="gi">+        node.source, node.line = node.parent.source, node.parent.line</span>
<span class="gi">+    if isinstance(node, nodes.title) and node.source is None:</span>
<span class="gi">+        logger.debug(&#39;[i18n] PATCH: %r to have source: %s&#39;,</span>
<span class="gi">+                     get_full_module_name(node), repr_domxml(node))</span>
<span class="gi">+        node.source, node.line = node.parent.source, node.parent.line</span>
<span class="gi">+    if isinstance(node, nodes.term):</span>
<span class="gi">+        logger.debug(&#39;[i18n] PATCH: %r to have rawsource: %s&#39;,</span>
<span class="gi">+                     get_full_module_name(node), repr_domxml(node))</span>
<span class="gi">+        # strip classifier from rawsource of term</span>
<span class="gi">+        for classifier in reversed(list(node.parent.findall(nodes.classifier))):</span>
<span class="gi">+            node.rawsource = re.sub(r&#39;\s*:\s*%s&#39; % re.escape(classifier.astext()),</span>
<span class="gi">+                                    &#39;&#39;, node.rawsource)</span>
<span class="gi">+    if isinstance(node, nodes.topic) and node.source is None:</span>
<span class="gi">+        # docutils-0.18 does not fill the source attribute of topic</span>
<span class="gi">+        logger.debug(&#39;[i18n] PATCH: %r to have source, line: %s&#39;,</span>
<span class="gi">+                     get_full_module_name(node), repr_domxml(node))</span>
<span class="gi">+        node.source, node.line = node.parent.source, node.parent.line</span>
<span class="gi">+</span>
<span class="gi">+    # workaround: literal_block under bullet list (#4913)</span>
<span class="gi">+    if isinstance(node, nodes.literal_block) and node.source is None:</span>
<span class="gi">+        with contextlib.suppress(ValueError):</span>
<span class="gi">+            node.source = get_node_source(node)</span>
<span class="gi">+</span>
<span class="gi">+    # workaround: recommonmark-0.2.0 doesn&#39;t set rawsource attribute</span>
<span class="gi">+    if not node.rawsource:</span>
<span class="gi">+        node.rawsource = node.astext()</span>
<span class="gi">+</span>
<span class="gi">+    if node.source and node.rawsource:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    # workaround: some docutils nodes doesn&#39;t have source, line.</span>
<span class="gi">+    if isinstance(node, (</span>
<span class="gi">+        nodes.rubric  # #1305 rubric directive</span>
<span class="gi">+        | nodes.line  # #1477 line node</span>
<span class="gi">+        | nodes.image  # #3093 image directive in substitution</span>
<span class="gi">+        | nodes.field_name  # #3335 field list syntax</span>
<span class="gi">+    )):</span>
<span class="gi">+        logger.debug(&#39;[i18n] PATCH: %r to have source and line: %s&#39;,</span>
<span class="gi">+                     get_full_module_name(node), repr_domxml(node))</span>
<span class="gi">+        try:</span>
<span class="gi">+            node.source = get_node_source(node)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            node.source = &#39;&#39;</span>
<span class="gi">+        node.line = 0  # need fix docutils to get `node.line`</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+IGNORED_NODES = (</span>
<span class="gi">+    nodes.Invisible,</span>
<span class="gi">+    nodes.literal_block,</span>
<span class="gi">+    nodes.doctest_block,</span>
<span class="gi">+    addnodes.versionmodified,</span>
<span class="gi">+    # XXX there are probably more</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_translatable(node: Node) -&gt; bool:</span>
<span class="gi">+    if isinstance(node, addnodes.translatable):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    # image node marked as translatable or having alt text</span>
<span class="gi">+    if isinstance(node, nodes.image) and (node.get(&#39;translatable&#39;) or node.get(&#39;alt&#39;)):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(node, nodes.Inline) and &#39;translatable&#39; not in node:  # type: ignore[operator]</span>
<span class="gi">+        # inline node must not be translated if &#39;translatable&#39; is not set</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(node, nodes.TextElement):</span>
<span class="gi">+        if not node.source:</span>
<span class="gi">+            logger.debug(&#39;[i18n] SKIP %r because no node.source: %s&#39;,</span>
<span class="gi">+                         get_full_module_name(node), repr_domxml(node))</span>
<span class="gi">+            return False  # built-in message</span>
<span class="gi">+        if isinstance(node, IGNORED_NODES) and &#39;translatable&#39; not in node:</span>
<span class="gi">+            logger.debug(&quot;[i18n] SKIP %r because node is in IGNORED_NODES &quot;</span>
<span class="gi">+                         &quot;and no node[&#39;translatable&#39;]: %s&quot;,</span>
<span class="gi">+                         get_full_module_name(node), repr_domxml(node))</span>
<span class="gi">+            return False</span>
<span class="gi">+        if not node.get(&#39;translatable&#39;, True):</span>
<span class="gi">+            # not(node[&#39;translatable&#39;] == True or node[&#39;translatable&#39;] is None)</span>
<span class="gi">+            logger.debug(&quot;[i18n] SKIP %r because not node[&#39;translatable&#39;]: %s&quot;,</span>
<span class="gi">+                         get_full_module_name(node), repr_domxml(node))</span>
<span class="gi">+            return False</span>
<span class="gi">+        # &lt;field_name&gt;orphan&lt;/field_name&gt;</span>
<span class="gi">+        # XXX ignore all metadata (== docinfo)</span>
<span class="gi">+        if isinstance(node, nodes.field_name) and (node.children[0] == &#39;orphan&#39;):</span>
<span class="gi">+            logger.debug(&#39;[i18n] SKIP %r because orphan node: %s&#39;,</span>
<span class="gi">+                         get_full_module_name(node), repr_domxml(node))</span>
<span class="gi">+            return False</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    return isinstance(node, nodes.meta)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+LITERAL_TYPE_NODES = (</span>
<span class="gi">+    nodes.literal_block,</span>
<span class="gi">+    nodes.doctest_block,</span>
<span class="gi">+    nodes.math_block,</span>
<span class="gi">+    nodes.raw,</span>
<span class="gi">+)</span>
<span class="gi">+IMAGE_TYPE_NODES = (</span>
<span class="gi">+    nodes.image,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def extract_messages(doctree: Element) -&gt; Iterable[tuple[Element, str]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Extract translatable messages from a document tree.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def traverse_translatable_index(doctree: Element) -&gt;Iterable[tuple[Element,</span>
<span class="gd">-    list[tuple[str, str, str, str, str | None]]]]:</span>
<span class="gi">+    for node in doctree.findall(is_translatable):</span>
<span class="gi">+        if isinstance(node, addnodes.translatable):</span>
<span class="gi">+            for msg in node.extract_original_messages():</span>
<span class="gi">+                yield node, msg  # type: ignore[misc]</span>
<span class="gi">+            continue</span>
<span class="gi">+        if isinstance(node, LITERAL_TYPE_NODES):</span>
<span class="gi">+            msg = node.rawsource</span>
<span class="gi">+            if not msg:</span>
<span class="gi">+                msg = node.astext()</span>
<span class="gi">+        elif isinstance(node, nodes.image):</span>
<span class="gi">+            if node.get(&#39;alt&#39;):</span>
<span class="gi">+                yield node, node[&#39;alt&#39;]</span>
<span class="gi">+            if node.get(&#39;translatable&#39;):</span>
<span class="gi">+                image_uri = node.get(&#39;original_uri&#39;, node[&#39;uri&#39;])</span>
<span class="gi">+                msg = f&#39;.. image:: {image_uri}&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                msg = &#39;&#39;</span>
<span class="gi">+        elif isinstance(node, nodes.meta):</span>
<span class="gi">+            msg = node[&quot;content&quot;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            msg = node.rawsource.replace(&#39;\n&#39;, &#39; &#39;).strip()  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="gi">+        # XXX nodes rendering empty are likely a bug in sphinx.addnodes</span>
<span class="gi">+        if msg:</span>
<span class="gi">+            yield node, msg  # type: ignore[misc]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_node_source(node: Element) -&gt; str:</span>
<span class="gi">+    for pnode in traverse_parent(node):</span>
<span class="gi">+        if pnode.source:</span>
<span class="gi">+            return pnode.source</span>
<span class="gi">+    msg = &#39;node source not found&#39;</span>
<span class="gi">+    raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_node_line(node: Element) -&gt; int:</span>
<span class="gi">+    for pnode in traverse_parent(node):</span>
<span class="gi">+        if pnode.line:</span>
<span class="gi">+            return pnode.line</span>
<span class="gi">+    msg = &#39;node line not found&#39;</span>
<span class="gi">+    raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def traverse_parent(node: Element, cls: Any = None) -&gt; Iterable[Element]:</span>
<span class="gi">+    while node:</span>
<span class="gi">+        if cls is None or isinstance(node, cls):</span>
<span class="gi">+            yield node</span>
<span class="gi">+        node = node.parent</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_prev_node(node: Node) -&gt; Node | None:</span>
<span class="gi">+    pos = node.parent.index(node)</span>
<span class="gi">+    if pos &gt; 0:</span>
<span class="gi">+        return node.parent[pos - 1]</span>
<span class="gi">+    else:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def traverse_translatable_index(</span>
<span class="gi">+    doctree: Element,</span>
<span class="gi">+) -&gt; Iterable[tuple[Element, list[tuple[str, str, str, str, str | None]]]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Traverse translatable index node from a document tree.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    matcher = NodeMatcher(addnodes.index, inline=False)</span>
<span class="gi">+    for node in matcher.findall(doctree):</span>
<span class="gi">+        if &#39;raw_entries&#39; in node:</span>
<span class="gi">+            entries = node[&#39;raw_entries&#39;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            entries = node[&#39;entries&#39;]</span>
<span class="gi">+        yield node, entries</span>


<span class="gd">-def nested_parse_with_titles(state: RSTState, content: StringList, node:</span>
<span class="gd">-    Node, content_offset: int=0) -&gt;str:</span>
<span class="gi">+def nested_parse_with_titles(state: RSTState, content: StringList, node: Node,</span>
<span class="gi">+                             content_offset: int = 0) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Version of state.nested_parse() that allows titles and does not require
<span class="w"> </span>    titles to have the same decoration as the calling document.

<span class="gu">@@ -115,33 +336,119 @@ def nested_parse_with_titles(state: RSTState, content: StringList, node:</span>
<span class="w"> </span>    This function is retained for compatibility and will be deprecated in
<span class="w"> </span>    Sphinx 8. Prefer ``nested_parse_to_nodes()``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with _fresh_title_style_context(state):</span>
<span class="gi">+        ret = state.nested_parse(content, content_offset, node, match_titles=True)</span>
<span class="gi">+    return ret</span>


<span class="gd">-def clean_astext(node: Element) -&gt;str:</span>
<span class="gi">+def clean_astext(node: Element) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Like node.astext(), but ignore images.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    node = node.deepcopy()</span>
<span class="gi">+    for img in node.findall(nodes.image):</span>
<span class="gi">+        img[&#39;alt&#39;] = &#39;&#39;</span>
<span class="gi">+    for raw in list(node.findall(nodes.raw)):</span>
<span class="gi">+        raw.parent.remove(raw)</span>
<span class="gi">+    return node.astext()</span>


<span class="gd">-def split_explicit_title(text: str) -&gt;tuple[bool, str, str]:</span>
<span class="gi">+def split_explicit_title(text: str) -&gt; tuple[bool, str, str]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Split role content into title and target, if given.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-indextypes = [&#39;single&#39;, &#39;pair&#39;, &#39;double&#39;, &#39;triple&#39;, &#39;see&#39;, &#39;seealso&#39;]</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def inline_all_toctrees(builder: Builder, docnameset: set[str], docname:</span>
<span class="gd">-    str, tree: nodes.document, colorfunc: Callable[[str], str], traversed:</span>
<span class="gd">-    list[str], indent: str=&#39;&#39;) -&gt;nodes.document:</span>
<span class="gi">+    match = explicit_title_re.match(text)</span>
<span class="gi">+    if match:</span>
<span class="gi">+        return True, match.group(1), match.group(2)</span>
<span class="gi">+    return False, text, text</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+indextypes = [</span>
<span class="gi">+    &#39;single&#39;, &#39;pair&#39;, &#39;double&#39;, &#39;triple&#39;, &#39;see&#39;, &#39;seealso&#39;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def process_index_entry(entry: str, targetid: str,</span>
<span class="gi">+                        ) -&gt; list[tuple[str, str, str, str, str | None]]:</span>
<span class="gi">+    from sphinx.domains.python import pairindextypes</span>
<span class="gi">+</span>
<span class="gi">+    indexentries: list[tuple[str, str, str, str, str | None]] = []</span>
<span class="gi">+    entry = entry.strip()</span>
<span class="gi">+    oentry = entry</span>
<span class="gi">+    main = &#39;&#39;</span>
<span class="gi">+    if entry.startswith(&#39;!&#39;):</span>
<span class="gi">+        main = &#39;main&#39;</span>
<span class="gi">+        entry = entry[1:].lstrip()</span>
<span class="gi">+    for index_type in pairindextypes:</span>
<span class="gi">+        if entry.startswith(f&#39;{index_type}:&#39;):</span>
<span class="gi">+            value = entry[len(index_type) + 1:].strip()</span>
<span class="gi">+            value = f&#39;{pairindextypes[index_type]}; {value}&#39;</span>
<span class="gi">+            # xref RemovedInSphinx90Warning</span>
<span class="gi">+            logger.warning(__(&#39;%r is deprecated for index entries (from entry %r). &#39;</span>
<span class="gi">+                              &quot;Use &#39;pair: %s&#39; instead.&quot;),</span>
<span class="gi">+                           index_type, entry, value, type=&#39;index&#39;)</span>
<span class="gi">+            indexentries.append((&#39;pair&#39;, value, targetid, main, None))</span>
<span class="gi">+            break</span>
<span class="gi">+    else:</span>
<span class="gi">+        for index_type in indextypes:</span>
<span class="gi">+            if entry.startswith(f&#39;{index_type}:&#39;):</span>
<span class="gi">+                value = entry[len(index_type) + 1:].strip()</span>
<span class="gi">+                if index_type == &#39;double&#39;:</span>
<span class="gi">+                    index_type = &#39;pair&#39;</span>
<span class="gi">+                indexentries.append((index_type, value, targetid, main, None))</span>
<span class="gi">+                break</span>
<span class="gi">+        # shorthand notation for single entries</span>
<span class="gi">+        else:</span>
<span class="gi">+            for value in oentry.split(&#39;,&#39;):</span>
<span class="gi">+                value = value.strip()</span>
<span class="gi">+                main = &#39;&#39;</span>
<span class="gi">+                if value.startswith(&#39;!&#39;):</span>
<span class="gi">+                    main = &#39;main&#39;</span>
<span class="gi">+                    value = value[1:].lstrip()</span>
<span class="gi">+                if not value:</span>
<span class="gi">+                    continue</span>
<span class="gi">+                indexentries.append((&#39;single&#39;, value, targetid, main, None))</span>
<span class="gi">+    return indexentries</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def inline_all_toctrees(</span>
<span class="gi">+    builder: Builder,</span>
<span class="gi">+    docnameset: set[str],</span>
<span class="gi">+    docname: str,</span>
<span class="gi">+    tree: nodes.document,</span>
<span class="gi">+    colorfunc: Callable[[str], str],</span>
<span class="gi">+    traversed: list[str],</span>
<span class="gi">+    indent: str = &#39;&#39;,</span>
<span class="gi">+) -&gt; nodes.document:</span>
<span class="w"> </span>    &quot;&quot;&quot;Inline all toctrees in the *tree*.

<span class="w"> </span>    Record all docnames in *docnameset*, and output docnames with *colorfunc*.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def _make_id(string: str) -&gt;str:</span>
<span class="gi">+    tree = tree.deepcopy()</span>
<span class="gi">+    for toctreenode in list(tree.findall(addnodes.toctree)):</span>
<span class="gi">+        newnodes = []</span>
<span class="gi">+        includefiles = map(str, toctreenode[&#39;includefiles&#39;])</span>
<span class="gi">+        indent += &#39; &#39;</span>
<span class="gi">+        for includefile in includefiles:</span>
<span class="gi">+            if includefile not in traversed:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    traversed.append(includefile)</span>
<span class="gi">+                    logger.info(indent + colorfunc(includefile))</span>
<span class="gi">+                    subtree = inline_all_toctrees(builder, docnameset, includefile,</span>
<span class="gi">+                                                  builder.env.get_doctree(includefile),</span>
<span class="gi">+                                                  colorfunc, traversed, indent)</span>
<span class="gi">+                    docnameset.add(includefile)</span>
<span class="gi">+                except Exception:</span>
<span class="gi">+                    logger.warning(__(&#39;toctree contains ref to nonexisting file %r&#39;),</span>
<span class="gi">+                                   includefile, location=docname)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    sof = addnodes.start_of_file(docname=includefile)</span>
<span class="gi">+                    sof.children = subtree.children</span>
<span class="gi">+                    for sectionnode in sof.findall(nodes.section):</span>
<span class="gi">+                        if &#39;docname&#39; not in sectionnode:</span>
<span class="gi">+                            sectionnode[&#39;docname&#39;] = includefile</span>
<span class="gi">+                    newnodes.append(sof)</span>
<span class="gi">+        toctreenode.parent.replace(toctreenode, newnodes)</span>
<span class="gi">+    return tree</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _make_id(string: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert `string` into an identifier and return it.

<span class="w"> </span>    This function is a modified version of ``docutils.nodes.make_id()`` of
<span class="gu">@@ -157,75 +464,218 @@ def _make_id(string: str) -&gt;str:</span>
<span class="w"> </span>    # Maintainer: docutils-develop@lists.sourceforge.net
<span class="w"> </span>    # Copyright: This module has been placed in the public domain.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    id = string.translate(_non_id_translate_digraphs)</span>
<span class="gi">+    id = id.translate(_non_id_translate)</span>
<span class="gi">+    # get rid of non-ascii characters.</span>
<span class="gi">+    # &#39;ascii&#39; lowercase to prevent problems with turkish locale.</span>
<span class="gi">+    id = unicodedata.normalize(&#39;NFKD&#39;, id).encode(&#39;ascii&#39;, &#39;ignore&#39;).decode(&#39;ascii&#39;)</span>
<span class="gi">+    # shrink runs of whitespace and replace by hyphen</span>
<span class="gi">+    id = _non_id_chars.sub(&#39;-&#39;, &#39; &#39;.join(id.split()))</span>
<span class="gi">+    id = _non_id_at_ends.sub(&#39;&#39;, id)</span>
<span class="gi">+    return str(id)</span>


<span class="w"> </span>_non_id_chars = re.compile(&#39;[^a-zA-Z0-9._]+&#39;)
<span class="w"> </span>_non_id_at_ends = re.compile(&#39;^[-0-9._]+|-+$&#39;)
<span class="gd">-_non_id_translate = {(248): &#39;o&#39;, (273): &#39;d&#39;, (295): &#39;h&#39;, (305): &#39;i&#39;, (322):</span>
<span class="gd">-    &#39;l&#39;, (359): &#39;t&#39;, (384): &#39;b&#39;, (387): &#39;b&#39;, (392): &#39;c&#39;, (396): &#39;d&#39;, (402):</span>
<span class="gd">-    &#39;f&#39;, (409): &#39;k&#39;, (410): &#39;l&#39;, (414): &#39;n&#39;, (421): &#39;p&#39;, (427): &#39;t&#39;, (429):</span>
<span class="gd">-    &#39;t&#39;, (436): &#39;y&#39;, (438): &#39;z&#39;, (485): &#39;g&#39;, (549): &#39;z&#39;, (564): &#39;l&#39;, (565):</span>
<span class="gd">-    &#39;n&#39;, (566): &#39;t&#39;, (567): &#39;j&#39;, (572): &#39;c&#39;, (575): &#39;s&#39;, (576): &#39;z&#39;, (583):</span>
<span class="gd">-    &#39;e&#39;, (585): &#39;j&#39;, (587): &#39;q&#39;, (589): &#39;r&#39;, (591): &#39;y&#39;}</span>
<span class="gd">-_non_id_translate_digraphs = {(223): &#39;sz&#39;, (230): &#39;ae&#39;, (339): &#39;oe&#39;, (568):</span>
<span class="gd">-    &#39;db&#39;, (569): &#39;qp&#39;}</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def make_id(env: BuildEnvironment, document: nodes.document, prefix: str=&#39;&#39;,</span>
<span class="gd">-    term: (str | None)=None) -&gt;str:</span>
<span class="gi">+_non_id_translate = {</span>
<span class="gi">+    0x00f8: &#39;o&#39;,       # o with stroke</span>
<span class="gi">+    0x0111: &#39;d&#39;,       # d with stroke</span>
<span class="gi">+    0x0127: &#39;h&#39;,       # h with stroke</span>
<span class="gi">+    0x0131: &#39;i&#39;,       # dotless i</span>
<span class="gi">+    0x0142: &#39;l&#39;,       # l with stroke</span>
<span class="gi">+    0x0167: &#39;t&#39;,       # t with stroke</span>
<span class="gi">+    0x0180: &#39;b&#39;,       # b with stroke</span>
<span class="gi">+    0x0183: &#39;b&#39;,       # b with topbar</span>
<span class="gi">+    0x0188: &#39;c&#39;,       # c with hook</span>
<span class="gi">+    0x018c: &#39;d&#39;,       # d with topbar</span>
<span class="gi">+    0x0192: &#39;f&#39;,       # f with hook</span>
<span class="gi">+    0x0199: &#39;k&#39;,       # k with hook</span>
<span class="gi">+    0x019a: &#39;l&#39;,       # l with bar</span>
<span class="gi">+    0x019e: &#39;n&#39;,       # n with long right leg</span>
<span class="gi">+    0x01a5: &#39;p&#39;,       # p with hook</span>
<span class="gi">+    0x01ab: &#39;t&#39;,       # t with palatal hook</span>
<span class="gi">+    0x01ad: &#39;t&#39;,       # t with hook</span>
<span class="gi">+    0x01b4: &#39;y&#39;,       # y with hook</span>
<span class="gi">+    0x01b6: &#39;z&#39;,       # z with stroke</span>
<span class="gi">+    0x01e5: &#39;g&#39;,       # g with stroke</span>
<span class="gi">+    0x0225: &#39;z&#39;,       # z with hook</span>
<span class="gi">+    0x0234: &#39;l&#39;,       # l with curl</span>
<span class="gi">+    0x0235: &#39;n&#39;,       # n with curl</span>
<span class="gi">+    0x0236: &#39;t&#39;,       # t with curl</span>
<span class="gi">+    0x0237: &#39;j&#39;,       # dotless j</span>
<span class="gi">+    0x023c: &#39;c&#39;,       # c with stroke</span>
<span class="gi">+    0x023f: &#39;s&#39;,       # s with swash tail</span>
<span class="gi">+    0x0240: &#39;z&#39;,       # z with swash tail</span>
<span class="gi">+    0x0247: &#39;e&#39;,       # e with stroke</span>
<span class="gi">+    0x0249: &#39;j&#39;,       # j with stroke</span>
<span class="gi">+    0x024b: &#39;q&#39;,       # q with hook tail</span>
<span class="gi">+    0x024d: &#39;r&#39;,       # r with stroke</span>
<span class="gi">+    0x024f: &#39;y&#39;,       # y with stroke</span>
<span class="gi">+}</span>
<span class="gi">+_non_id_translate_digraphs = {</span>
<span class="gi">+    0x00df: &#39;sz&#39;,      # ligature sz</span>
<span class="gi">+    0x00e6: &#39;ae&#39;,      # ae</span>
<span class="gi">+    0x0153: &#39;oe&#39;,      # ligature oe</span>
<span class="gi">+    0x0238: &#39;db&#39;,      # db digraph</span>
<span class="gi">+    0x0239: &#39;qp&#39;,      # qp digraph</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make_id(env: BuildEnvironment, document: nodes.document,</span>
<span class="gi">+            prefix: str = &#39;&#39;, term: str | None = None) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Generate an appropriate node_id for given *prefix* and *term*.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def find_pending_xref_condition(node: addnodes.pending_xref, condition: str</span>
<span class="gd">-    ) -&gt;(Element | None):</span>
<span class="gi">+    node_id = None</span>
<span class="gi">+    if prefix:</span>
<span class="gi">+        idformat = prefix + &quot;-%s&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        idformat = (document.settings.id_prefix or &quot;id&quot;) + &quot;%s&quot;</span>
<span class="gi">+</span>
<span class="gi">+    # try to generate node_id by *term*</span>
<span class="gi">+    if prefix and term:</span>
<span class="gi">+        node_id = _make_id(idformat % term)</span>
<span class="gi">+        if node_id == prefix:</span>
<span class="gi">+            # *term* is not good to generate a node_id.</span>
<span class="gi">+            node_id = None</span>
<span class="gi">+    elif term:</span>
<span class="gi">+        node_id = _make_id(term)</span>
<span class="gi">+        if node_id == &#39;&#39;:</span>
<span class="gi">+            node_id = None  # fallback to None</span>
<span class="gi">+</span>
<span class="gi">+    while node_id is None or node_id in document.ids:</span>
<span class="gi">+        node_id = idformat % env.new_serialno(prefix)</span>
<span class="gi">+</span>
<span class="gi">+    return node_id</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def find_pending_xref_condition(node: addnodes.pending_xref, condition: str,</span>
<span class="gi">+                                ) -&gt; Element | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Pick matched pending_xref_condition node up from the pending_xref.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for subnode in node:</span>
<span class="gi">+        if (isinstance(subnode, addnodes.pending_xref_condition) and</span>
<span class="gi">+                subnode.get(&#39;condition&#39;) == condition):</span>
<span class="gi">+            return subnode</span>
<span class="gi">+    return None</span>


<span class="gd">-def make_refnode(builder: Builder, fromdocname: str, todocname: str,</span>
<span class="gd">-    targetid: (str | None), child: (Node | list[Node]), title: (str | None)</span>
<span class="gd">-    =None) -&gt;nodes.reference:</span>
<span class="gi">+def make_refnode(builder: Builder, fromdocname: str, todocname: str, targetid: str | None,</span>
<span class="gi">+                 child: Node | list[Node], title: str | None = None,</span>
<span class="gi">+                 ) -&gt; nodes.reference:</span>
<span class="w"> </span>    &quot;&quot;&quot;Shortcut to create a reference node.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    node = nodes.reference(&#39;&#39;, &#39;&#39;, internal=True)</span>
<span class="gi">+    if fromdocname == todocname and targetid:</span>
<span class="gi">+        node[&#39;refid&#39;] = targetid</span>
<span class="gi">+    else:</span>
<span class="gi">+        if targetid:</span>
<span class="gi">+            node[&#39;refuri&#39;] = (builder.get_relative_uri(fromdocname, todocname) +</span>
<span class="gi">+                              &#39;#&#39; + targetid)</span>
<span class="gi">+        else:</span>
<span class="gi">+            node[&#39;refuri&#39;] = builder.get_relative_uri(fromdocname, todocname)</span>
<span class="gi">+    if title:</span>
<span class="gi">+        node[&#39;reftitle&#39;] = title</span>
<span class="gi">+    node += child</span>
<span class="gi">+    return node</span>


<span class="gd">-NON_SMARTQUOTABLE_PARENT_NODES = (nodes.FixedTextElement, nodes.literal,</span>
<span class="gd">-    nodes.math, nodes.image, nodes.raw, nodes.problematic, addnodes.</span>
<span class="gd">-    not_smartquotable)</span>
<span class="gi">+def set_source_info(directive: Directive, node: Node) -&gt; None:</span>
<span class="gi">+    node.source, node.line = \</span>
<span class="gi">+        directive.state_machine.get_source_and_line(directive.lineno)</span>


<span class="gd">-def is_smartquotable(node: Node) -&gt;bool:</span>
<span class="gd">-    &quot;&quot;&quot;Check whether the node is smart-quotable or not.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+def set_role_source_info(inliner: Inliner, lineno: int, node: Node) -&gt; None:</span>
<span class="gi">+    gsal = inliner.reporter.get_source_and_line  # type: ignore[attr-defined]</span>
<span class="gi">+    node.source, node.line = gsal(lineno)</span>


<span class="gd">-def process_only_nodes(document: Node, tags: Tags) -&gt;None:</span>
<span class="gd">-    &quot;&quot;&quot;Filter ``only`` nodes which do not match *tags*.&quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+def copy_source_info(src: Element, dst: Element) -&gt; None:</span>
<span class="gi">+    with contextlib.suppress(ValueError):</span>
<span class="gi">+        dst.source = get_node_source(src)</span>
<span class="gi">+        dst.line = get_node_line(src)</span>


<span class="gd">-def _only_node_keep_children(node: addnodes.only, tags: Tags) -&gt;bool:</span>
<span class="gi">+NON_SMARTQUOTABLE_PARENT_NODES = (</span>
<span class="gi">+    nodes.FixedTextElement,</span>
<span class="gi">+    nodes.literal,</span>
<span class="gi">+    nodes.math,</span>
<span class="gi">+    nodes.image,</span>
<span class="gi">+    nodes.raw,</span>
<span class="gi">+    nodes.problematic,</span>
<span class="gi">+    addnodes.not_smartquotable,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_smartquotable(node: Node) -&gt; bool:</span>
<span class="gi">+    &quot;&quot;&quot;Check whether the node is smart-quotable or not.&quot;&quot;&quot;</span>
<span class="gi">+    for pnode in traverse_parent(node.parent):</span>
<span class="gi">+        if isinstance(pnode, NON_SMARTQUOTABLE_PARENT_NODES):</span>
<span class="gi">+            return False</span>
<span class="gi">+        if pnode.get(&#39;support_smartquotes&#39;, None) is False:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    return getattr(node, &#39;support_smartquotes&#39;, None) is not False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def process_only_nodes(document: Node, tags: Tags) -&gt; None:</span>
<span class="gi">+    &quot;&quot;&quot;Filter ``only`` nodes which do not match *tags*.&quot;&quot;&quot;</span>
<span class="gi">+    for node in document.findall(addnodes.only):</span>
<span class="gi">+        if _only_node_keep_children(node, tags):</span>
<span class="gi">+            node.replace_self(node.children or nodes.comment())</span>
<span class="gi">+        else:</span>
<span class="gi">+            # A comment on the comment() nodes being inserted: replacing by [] would</span>
<span class="gi">+            # result in a &quot;Losing ids&quot; exception if there is a target node before</span>
<span class="gi">+            # the only node, so we make sure docutils can transfer the id to</span>
<span class="gi">+            # something, even if it&#39;s just a comment and will lose the id anyway...</span>
<span class="gi">+            node.replace_self(nodes.comment())</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _only_node_keep_children(node: addnodes.only, tags: Tags) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Keep children if tags match or error.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return tags.eval_condition(node[&#39;expr&#39;])</span>
<span class="gi">+    except Exception as err:</span>
<span class="gi">+        logger.warning(</span>
<span class="gi">+            __(&#39;exception while evaluating only directive expression: %s&#39;),</span>
<span class="gi">+            err,</span>
<span class="gi">+            location=node)</span>
<span class="gi">+        return True</span>


<span class="gd">-def _copy_except__document(el: Element) -&gt;Element:</span>
<span class="gi">+def _copy_except__document(el: Element) -&gt; Element:</span>
<span class="w"> </span>    &quot;&quot;&quot;Monkey-patch ```nodes.Element.copy``` to not copy the ``_document``
<span class="w"> </span>    attribute.

<span class="w"> </span>    xref: https://github.com/sphinx-doc/sphinx/issues/11116#issuecomment-1376767086
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    newnode = object.__new__(el.__class__)</span>
<span class="gi">+    # set in Element.__init__()</span>
<span class="gi">+    newnode.children = []</span>
<span class="gi">+    newnode.rawsource = el.rawsource</span>
<span class="gi">+    newnode.tagname = el.tagname</span>
<span class="gi">+    # copied in Element.copy()</span>
<span class="gi">+    newnode.attributes = {k: (v</span>
<span class="gi">+                              if k not in {&#39;ids&#39;, &#39;classes&#39;, &#39;names&#39;, &#39;dupnames&#39;, &#39;backrefs&#39;}</span>
<span class="gi">+                              else v[:])</span>
<span class="gi">+                          for k, v in el.attributes.items()}</span>
<span class="gi">+    newnode.line = el.line</span>
<span class="gi">+    newnode.source = el.source</span>
<span class="gi">+    return newnode</span>


<span class="gd">-nodes.Element.copy = _copy_except__document</span>
<span class="gi">+nodes.Element.copy = _copy_except__document  # type: ignore[assignment]</span>


<span class="gd">-def _deepcopy(el: Element) -&gt;Element:</span>
<span class="gi">+def _deepcopy(el: Element) -&gt; Element:</span>
<span class="w"> </span>    &quot;&quot;&quot;Monkey-patch ```nodes.Element.deepcopy``` for speed.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-nodes.Element.deepcopy = _deepcopy</span>
<span class="gi">+    newnode = el.copy()</span>
<span class="gi">+    newnode.children = [child.deepcopy() for child in el.children]</span>
<span class="gi">+    for child in newnode.children:</span>
<span class="gi">+        child.parent = newnode</span>
<span class="gi">+        if el.document:</span>
<span class="gi">+            child.document = el.document</span>
<span class="gi">+            if child.source is None:</span>
<span class="gi">+                child.source = el.document.current_source</span>
<span class="gi">+            if child.line is None:</span>
<span class="gi">+                child.line = el.document.current_line</span>
<span class="gi">+    return newnode</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+nodes.Element.deepcopy = _deepcopy  # type: ignore[assignment]</span>
<span class="gh">diff --git a/sphinx/util/osutil.py b/sphinx/util/osutil.py</span>
<span class="gh">index 83ada565b..d5d6ab5bc 100644</span>
<span class="gd">--- a/sphinx/util/osutil.py</span>
<span class="gi">+++ b/sphinx/util/osutil.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Operating system-related utility functions for Sphinx.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import contextlib
<span class="w"> </span>import filecmp
<span class="w"> </span>import os
<span class="gu">@@ -11,34 +13,65 @@ from io import StringIO</span>
<span class="w"> </span>from os import path
<span class="w"> </span>from pathlib import Path
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from sphinx.locale import __
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from types import TracebackType
<span class="w"> </span>    from typing import Any
<span class="gd">-SEP = &#39;/&#39;</span>
<span class="gi">+</span>
<span class="gi">+# SEP separates path elements in the canonical file names</span>
<span class="gi">+#</span>
<span class="gi">+# Define SEP as a manifest constant, not so much because we expect it to change</span>
<span class="gi">+# in the future as to avoid the suspicion that a stray &quot;/&quot; in the code is a</span>
<span class="gi">+# hangover from more *nix-oriented origins.</span>
<span class="gi">+SEP = &quot;/&quot;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def os_path(canonical_path: str, /) -&gt; str:</span>
<span class="gi">+    return canonical_path.replace(SEP, path.sep)</span>


<span class="gd">-def canon_path(native_path: (str | os.PathLike[str]), /) -&gt;str:</span>
<span class="gi">+def canon_path(native_path: str | os.PathLike[str], /) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return path in OS-independent form&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return os.fspath(native_path).replace(path.sep, SEP)</span>


<span class="gd">-def path_stabilize(filepath: (str | os.PathLike[str]), /) -&gt;str:</span>
<span class="gi">+def path_stabilize(filepath: str | os.PathLike[str], /) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Normalize path separator and unicode string&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    new_path = canon_path(filepath)</span>
<span class="gi">+    return unicodedata.normalize(&#39;NFC&#39;, new_path)</span>


<span class="gd">-def relative_uri(base: str, to: str) -&gt;str:</span>
<span class="gi">+def relative_uri(base: str, to: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a relative URL from ``base`` to ``to``.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def ensuredir(file: (str | os.PathLike[str])) -&gt;None:</span>
<span class="gi">+    if to.startswith(SEP):</span>
<span class="gi">+        return to</span>
<span class="gi">+    b2 = base.split(&#39;#&#39;)[0].split(SEP)</span>
<span class="gi">+    t2 = to.split(&#39;#&#39;)[0].split(SEP)</span>
<span class="gi">+    # remove common segments (except the last segment)</span>
<span class="gi">+    for x, y in zip(b2[:-1], t2[:-1], strict=False):</span>
<span class="gi">+        if x != y:</span>
<span class="gi">+            break</span>
<span class="gi">+        b2.pop(0)</span>
<span class="gi">+        t2.pop(0)</span>
<span class="gi">+    if b2 == t2:</span>
<span class="gi">+        # Special case: relative_uri(&#39;f/index.html&#39;,&#39;f/index.html&#39;)</span>
<span class="gi">+        # returns &#39;&#39;, not &#39;index.html&#39;</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+    if len(b2) == 1 and t2 == [&#39;&#39;]:</span>
<span class="gi">+        # Special case: relative_uri(&#39;f/index.html&#39;,&#39;f/&#39;) should</span>
<span class="gi">+        # return &#39;./&#39;, not &#39;&#39;</span>
<span class="gi">+        return &#39;.&#39; + SEP</span>
<span class="gi">+    return (&#39;..&#39; + SEP) * (len(b2) - 1) + SEP.join(t2)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def ensuredir(file: str | os.PathLike[str]) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Ensure that a path exists.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    os.makedirs(file, exist_ok=True)</span>


<span class="gd">-def _last_modified_time(source: (str | os.PathLike[str]), /) -&gt;int:</span>
<span class="gi">+def _last_modified_time(source: str | os.PathLike[str], /) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the last modified time of ``filename``.

<span class="w"> </span>    The time is returned as integer microseconds.
<span class="gu">@@ -48,17 +81,23 @@ def _last_modified_time(source: (str | os.PathLike[str]), /) -&gt;int:</span>
<span class="w"> </span>    We prefer to err on the side of re-rendering a file,
<span class="w"> </span>    so we round up to the nearest microsecond.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    st = source.stat() if isinstance(source, os.DirEntry) else os.stat(source)</span>
<span class="gi">+    # upside-down floor division to get the ceiling</span>
<span class="gi">+    return -(st.st_mtime_ns // -1_000)</span>


<span class="gd">-def _copy_times(source: (str | os.PathLike[str]), dest: (str | os.PathLike[</span>
<span class="gd">-    str])) -&gt;None:</span>
<span class="gi">+def _copy_times(source: str | os.PathLike[str], dest: str | os.PathLike[str]) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Copy a file&#39;s modification times.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    st = source.stat() if isinstance(source, os.DirEntry) else os.stat(source)</span>
<span class="gi">+    os.utime(dest, ns=(st.st_atime_ns, st.st_mtime_ns))</span>


<span class="gd">-def copyfile(source: (str | os.PathLike[str]), dest: (str | os.PathLike[str</span>
<span class="gd">-    ]), *, force: bool=False) -&gt;None:</span>
<span class="gi">+def copyfile(</span>
<span class="gi">+    source: str | os.PathLike[str],</span>
<span class="gi">+    dest: str | os.PathLike[str],</span>
<span class="gi">+    *,</span>
<span class="gi">+    force: bool = False,</span>
<span class="gi">+) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Copy a file and its modification times, if possible.

<span class="w"> </span>    :param source: An existing source to copy.
<span class="gu">@@ -68,41 +107,87 @@ def copyfile(source: (str | os.PathLike[str]), dest: (str | os.PathLike[str</span>

<span class="w"> </span>    .. note:: :func:`copyfile` is a no-op if *source* and *dest* are identical.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # coerce to Path objects</span>
<span class="gi">+    source = Path(source)</span>
<span class="gi">+    dest = Path(dest)</span>
<span class="gi">+    if not source.exists():</span>
<span class="gi">+        msg = f&#39;{source} does not exist&#39;</span>
<span class="gi">+        raise FileNotFoundError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    if (</span>
<span class="gi">+        not (dest_exists := dest.exists()) or</span>
<span class="gi">+        # comparison must be done using shallow=False since</span>
<span class="gi">+        # two different files might have the same size</span>
<span class="gi">+        not filecmp.cmp(source, dest, shallow=False)</span>
<span class="gi">+    ):</span>
<span class="gi">+        if not force and dest_exists:</span>
<span class="gi">+            # sphinx.util.logging imports sphinx.util.osutil,</span>
<span class="gi">+            # so use a local import to avoid circular imports</span>
<span class="gi">+            from sphinx.util import logging</span>
<span class="gi">+            logger = logging.getLogger(__name__)</span>
<span class="gi">+</span>
<span class="gi">+            msg = __(&#39;Aborted attempted copy from %s to %s &#39;</span>
<span class="gi">+                     &#39;(the destination path has existing data).&#39;)</span>
<span class="gi">+            logger.warning(msg, source, dest,</span>
<span class="gi">+                           type=&#39;misc&#39;, subtype=&#39;copy_overwrite&#39;)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        shutil.copyfile(source, dest)</span>
<span class="gi">+        with contextlib.suppress(OSError):</span>
<span class="gi">+            # don&#39;t do full copystat because the source may be read-only</span>
<span class="gi">+            _copy_times(source, dest)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+_no_fn_re = re.compile(r&#39;[^a-zA-Z0-9_-]&#39;)</span>


<span class="gd">-_no_fn_re = re.compile(&#39;[^a-zA-Z0-9_-]&#39;)</span>
<span class="gi">+def make_filename(string: str) -&gt; str:</span>
<span class="gi">+    return _no_fn_re.sub(&#39;&#39;, string) or &#39;sphinx&#39;</span>


<span class="gd">-def relpath(path: (str | os.PathLike[str]), start: (str | os.PathLike[str] |</span>
<span class="gd">-    None)=os.curdir) -&gt;str:</span>
<span class="gi">+def make_filename_from_project(project: str) -&gt; str:</span>
<span class="gi">+    return make_filename(project.removesuffix(&#39; Documentation&#39;)).lower()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def relpath(path: str | os.PathLike[str],</span>
<span class="gi">+            start: str | os.PathLike[str] | None = os.curdir) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a relative filepath to *path* either from the current directory or
<span class="w"> </span>    from an optional *start* directory.

<span class="w"> </span>    This is an alternative of ``os.path.relpath()``.  This returns original path
<span class="w"> </span>    if *path* and *start* are on different drives (for Windows platform).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return os.path.relpath(path, start)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        return str(path)</span>


<span class="gd">-safe_relpath = relpath</span>
<span class="gi">+safe_relpath = relpath  # for compatibility</span>
<span class="w"> </span>fs_encoding = sys.getfilesystemencoding() or sys.getdefaultencoding()
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>abspath = path.abspath


<span class="w"> </span>class _chdir:
<span class="w"> </span>    &quot;&quot;&quot;Remove this fall-back once support for Python 3.10 is removed.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, target_dir: str, /) -&gt;None:</span>
<span class="gi">+    def __init__(self, target_dir: str, /) -&gt; None:</span>
<span class="w"> </span>        self.path = target_dir
<span class="w"> </span>        self._dirs: list[str] = []

<span class="gd">-    def __enter__(self) -&gt;None:</span>
<span class="gi">+    def __enter__(self) -&gt; None:</span>
<span class="w"> </span>        self._dirs.append(os.getcwd())
<span class="w"> </span>        os.chdir(self.path)

<span class="gd">-    def __exit__(self, type: (type[BaseException] | None), value: (</span>
<span class="gd">-        BaseException | None), traceback: (TracebackType | None), /) -&gt;None:</span>
<span class="gi">+    def __exit__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        type: type[BaseException] | None,</span>
<span class="gi">+        value: BaseException | None,</span>
<span class="gi">+        traceback: TracebackType | None,</span>
<span class="gi">+        /,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        os.chdir(self._dirs.pop())


<span class="gu">@@ -123,26 +208,55 @@ class FileAvoidWrite:</span>
<span class="w"> </span>    Objects can be used as context managers.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, path: (str | Path)) -&gt;None:</span>
<span class="gi">+    def __init__(self, path: str | Path) -&gt; None:</span>
<span class="w"> </span>        self._path = path
<span class="w"> </span>        self._io: StringIO | None = None

<span class="gd">-    def close(self) -&gt;None:</span>
<span class="gi">+    def write(self, data: str) -&gt; None:</span>
<span class="gi">+        if not self._io:</span>
<span class="gi">+            self._io = StringIO()</span>
<span class="gi">+        self._io.write(data)</span>
<span class="gi">+</span>
<span class="gi">+    def close(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Stop accepting writes and write file, if needed.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._io:</span>
<span class="gi">+            msg = &#39;FileAvoidWrite does not support empty files.&#39;</span>
<span class="gi">+            raise Exception(msg)</span>
<span class="gi">+</span>
<span class="gi">+        buf = self.getvalue()</span>
<span class="gi">+        self._io.close()</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            with open(self._path, encoding=&#39;utf-8&#39;) as old_f:</span>
<span class="gi">+                old_content = old_f.read()</span>
<span class="gi">+                if old_content == buf:</span>
<span class="gi">+                    return</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        with open(self._path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:</span>
<span class="gi">+            f.write(buf)</span>

<span class="gd">-    def __enter__(self) -&gt;FileAvoidWrite:</span>
<span class="gi">+    def __enter__(self) -&gt; FileAvoidWrite:</span>
<span class="w"> </span>        return self

<span class="gd">-    def __exit__(self, exc_type: type[Exception], exc_value: Exception,</span>
<span class="gd">-        traceback: Any) -&gt;bool:</span>
<span class="gi">+    def __exit__(</span>
<span class="gi">+        self, exc_type: type[Exception], exc_value: Exception, traceback: Any,</span>
<span class="gi">+    ) -&gt; bool:</span>
<span class="w"> </span>        self.close()
<span class="w"> </span>        return True

<span class="gd">-    def __getattr__(self, name: str) -&gt;Any:</span>
<span class="gi">+    def __getattr__(self, name: str) -&gt; Any:</span>
<span class="gi">+        # Proxy to _io instance.</span>
<span class="w"> </span>        if not self._io:
<span class="gd">-            msg = (</span>
<span class="gd">-                &#39;Must write to FileAvoidWrite before other methods can be used&#39;</span>
<span class="gd">-                )</span>
<span class="gi">+            msg = &#39;Must write to FileAvoidWrite before other methods can be used&#39;</span>
<span class="w"> </span>            raise Exception(msg)
<span class="gi">+</span>
<span class="w"> </span>        return getattr(self._io, name)
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def rmtree(path: str) -&gt; None:</span>
<span class="gi">+    if os.path.isdir(path):</span>
<span class="gi">+        shutil.rmtree(path)</span>
<span class="gi">+    else:</span>
<span class="gi">+        os.remove(path)</span>
<span class="gh">diff --git a/sphinx/util/parallel.py b/sphinx/util/parallel.py</span>
<span class="gh">index d4b1bfccb..f17ef7129 100644</span>
<span class="gd">--- a/sphinx/util/parallel.py</span>
<span class="gi">+++ b/sphinx/util/parallel.py</span>
<span class="gu">@@ -1,39 +1,159 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Parallel building utilities.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import time
<span class="w"> </span>import traceback
<span class="w"> </span>from math import sqrt
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    import multiprocessing
<span class="w"> </span>    HAS_MULTIPROCESSING = True
<span class="w"> </span>except ImportError:
<span class="w"> </span>    HAS_MULTIPROCESSING = False
<span class="gi">+</span>
<span class="w"> </span>from sphinx.errors import SphinxParallelError
<span class="w"> </span>from sphinx.util import logging
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Callable, Sequence
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gi">+</span>
<span class="gi">+# our parallel functionality only works for the forking Process</span>
<span class="w"> </span>parallel_available = HAS_MULTIPROCESSING and os.name == &#39;posix&#39;


<span class="w"> </span>class SerialTasks:
<span class="w"> </span>    &quot;&quot;&quot;Has the same interface as ParallelTasks, but executes tasks directly.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, nproc: int=1) -&gt;None:</span>
<span class="gi">+    def __init__(self, nproc: int = 1) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def add_task(</span>
<span class="gi">+        self, task_func: Callable, arg: Any = None, result_func: Callable | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        if arg is not None:</span>
<span class="gi">+            res = task_func(arg)</span>
<span class="gi">+        else:</span>
<span class="gi">+            res = task_func()</span>
<span class="gi">+        if result_func:</span>
<span class="gi">+            result_func(res)</span>
<span class="gi">+</span>
<span class="gi">+    def join(self) -&gt; None:</span>
<span class="w"> </span>        pass


<span class="w"> </span>class ParallelTasks:
<span class="w"> </span>    &quot;&quot;&quot;Executes *nproc* tasks in parallel after forking.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, nproc: int) -&gt;None:</span>
<span class="gi">+    def __init__(self, nproc: int) -&gt; None:</span>
<span class="w"> </span>        self.nproc = nproc
<span class="gi">+        # (optional) function performed by each task on the result of main task</span>
<span class="w"> </span>        self._result_funcs: dict[int, Callable] = {}
<span class="gi">+        # task arguments</span>
<span class="w"> </span>        self._args: dict[int, list[Any] | None] = {}
<span class="gi">+        # list of subprocesses (both started and waiting)</span>
<span class="w"> </span>        self._procs: dict[int, Any] = {}
<span class="gi">+        # list of receiving pipe connections of running subprocesses</span>
<span class="w"> </span>        self._precvs: dict[int, Any] = {}
<span class="gi">+        # list of receiving pipe connections of waiting subprocesses</span>
<span class="w"> </span>        self._precvsWaiting: dict[int, Any] = {}
<span class="gi">+        # number of working subprocesses</span>
<span class="w"> </span>        self._pworking = 0
<span class="gi">+        # task number of each subprocess</span>
<span class="w"> </span>        self._taskid = 0
<span class="gi">+</span>
<span class="gi">+    def _process(self, pipe: Any, func: Callable, arg: Any) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            collector = logging.LogCollector()</span>
<span class="gi">+            with collector.collect():</span>
<span class="gi">+                if arg is None:</span>
<span class="gi">+                    ret = func()</span>
<span class="gi">+                else:</span>
<span class="gi">+                    ret = func(arg)</span>
<span class="gi">+            failed = False</span>
<span class="gi">+        except BaseException as err:</span>
<span class="gi">+            failed = True</span>
<span class="gi">+            errmsg = traceback.format_exception_only(err.__class__, err)[0].strip()</span>
<span class="gi">+            ret = (errmsg, traceback.format_exc())</span>
<span class="gi">+        logging.convert_serializable(collector.logs)</span>
<span class="gi">+        pipe.send((failed, collector.logs, ret))</span>
<span class="gi">+</span>
<span class="gi">+    def add_task(</span>
<span class="gi">+        self, task_func: Callable, arg: Any = None, result_func: Callable | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        tid = self._taskid</span>
<span class="gi">+        self._taskid += 1</span>
<span class="gi">+        self._result_funcs[tid] = result_func or (lambda arg, result: None)</span>
<span class="gi">+        self._args[tid] = arg</span>
<span class="gi">+        precv, psend = multiprocessing.Pipe(False)</span>
<span class="gi">+        context: Any = multiprocessing.get_context(&#39;fork&#39;)</span>
<span class="gi">+        proc = context.Process(target=self._process, args=(psend, task_func, arg))</span>
<span class="gi">+        self._procs[tid] = proc</span>
<span class="gi">+        self._precvsWaiting[tid] = precv</span>
<span class="gi">+        try:</span>
<span class="gi">+            self._join_one()</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            # shutdown other child processes on failure</span>
<span class="gi">+            # (e.g. OSError: Failed to allocate memory)</span>
<span class="gi">+            self.terminate()</span>
<span class="gi">+</span>
<span class="gi">+    def join(self) -&gt; None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            while self._pworking:</span>
<span class="gi">+                if not self._join_one():</span>
<span class="gi">+                    time.sleep(0.02)</span>
<span class="gi">+        finally:</span>
<span class="gi">+            # shutdown other child processes on failure</span>
<span class="gi">+            self.terminate()</span>
<span class="gi">+</span>
<span class="gi">+    def terminate(self) -&gt; None:</span>
<span class="gi">+        for tid in list(self._precvs):</span>
<span class="gi">+            self._procs[tid].terminate()</span>
<span class="gi">+            self._result_funcs.pop(tid)</span>
<span class="gi">+            self._procs.pop(tid)</span>
<span class="gi">+            self._precvs.pop(tid)</span>
<span class="gi">+            self._pworking -= 1</span>
<span class="gi">+</span>
<span class="gi">+    def _join_one(self) -&gt; bool:</span>
<span class="gi">+        joined_any = False</span>
<span class="gi">+        for tid, pipe in self._precvs.items():</span>
<span class="gi">+            if pipe.poll():</span>
<span class="gi">+                exc, logs, result = pipe.recv()</span>
<span class="gi">+                if exc:</span>
<span class="gi">+                    raise SphinxParallelError(*result)</span>
<span class="gi">+                for log in logs:</span>
<span class="gi">+                    logger.handle(log)</span>
<span class="gi">+                self._result_funcs.pop(tid)(self._args.pop(tid), result)</span>
<span class="gi">+                self._procs[tid].join()</span>
<span class="gi">+                self._precvs.pop(tid)</span>
<span class="gi">+                self._pworking -= 1</span>
<span class="gi">+                joined_any = True</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        while self._precvsWaiting and self._pworking &lt; self.nproc:</span>
<span class="gi">+            newtid, newprecv = self._precvsWaiting.popitem()</span>
<span class="gi">+            self._precvs[newtid] = newprecv</span>
<span class="gi">+            self._procs[newtid].start()</span>
<span class="gi">+            self._pworking += 1</span>
<span class="gi">+</span>
<span class="gi">+        return joined_any</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def make_chunks(arguments: Sequence[str], nproc: int, maxbatch: int = 10) -&gt; list[Any]:</span>
<span class="gi">+    # determine how many documents to read in one go</span>
<span class="gi">+    nargs = len(arguments)</span>
<span class="gi">+    chunksize = nargs // nproc</span>
<span class="gi">+    if chunksize &gt;= maxbatch:</span>
<span class="gi">+        # try to improve batch size vs. number of batches</span>
<span class="gi">+        chunksize = int(sqrt(nargs / nproc * maxbatch))</span>
<span class="gi">+    if chunksize == 0:</span>
<span class="gi">+        chunksize = 1</span>
<span class="gi">+    nchunks, rest = divmod(nargs, chunksize)</span>
<span class="gi">+    if rest:</span>
<span class="gi">+        nchunks += 1</span>
<span class="gi">+    # partition documents in &quot;chunks&quot; that will be written by one Process</span>
<span class="gi">+    return [arguments[i * chunksize:(i + 1) * chunksize] for i in range(nchunks)]</span>
<span class="gh">diff --git a/sphinx/util/parsing.py b/sphinx/util/parsing.py</span>
<span class="gh">index cc99e270e..a8f937f8f 100644</span>
<span class="gd">--- a/sphinx/util/parsing.py</span>
<span class="gi">+++ b/sphinx/util/parsing.py</span>
<span class="gu">@@ -1,17 +1,28 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Docutils utility functions for parsing text.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import contextlib
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>from docutils.nodes import Element, Node
<span class="w"> </span>from docutils.statemachine import StringList, string2lines
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Iterator
<span class="gi">+</span>
<span class="w"> </span>    from docutils.parsers.rst.states import RSTState


<span class="gd">-def nested_parse_to_nodes(state: RSTState, text: (str | StringList), *,</span>
<span class="gd">-    source: str=&#39;&lt;generated text&gt;&#39;, offset: int=0, allow_section_headings:</span>
<span class="gd">-    bool=True, keep_title_context: bool=False) -&gt;list[Node]:</span>
<span class="gi">+def nested_parse_to_nodes(</span>
<span class="gi">+    state: RSTState,</span>
<span class="gi">+    text: str | StringList,</span>
<span class="gi">+    *,</span>
<span class="gi">+    source: str = &#39;&lt;generated text&gt;&#39;,</span>
<span class="gi">+    offset: int = 0,</span>
<span class="gi">+    allow_section_headings: bool = True,</span>
<span class="gi">+    keep_title_context: bool = False,</span>
<span class="gi">+) -&gt; list[Node]:  # Element | nodes.Text</span>
<span class="w"> </span>    &quot;&quot;&quot;Parse *text* into nodes.

<span class="w"> </span>    :param state:
<span class="gu">@@ -40,4 +51,43 @@ def nested_parse_to_nodes(state: RSTState, text: (str | StringList), *,</span>

<span class="w"> </span>    .. versionadded:: 7.4
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    document = state.document</span>
<span class="gi">+    content = _text_to_string_list(</span>
<span class="gi">+        text, source=source, tab_width=document.settings.tab_width,</span>
<span class="gi">+    )</span>
<span class="gi">+    node = Element()  # Anonymous container for parsing</span>
<span class="gi">+    node.document = document</span>
<span class="gi">+</span>
<span class="gi">+    if keep_title_context:</span>
<span class="gi">+        state.nested_parse(content, offset, node, match_titles=allow_section_headings)</span>
<span class="gi">+    else:</span>
<span class="gi">+        with _fresh_title_style_context(state):</span>
<span class="gi">+            state.nested_parse(content, offset, node, match_titles=allow_section_headings)</span>
<span class="gi">+    return node.children</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@contextlib.contextmanager</span>
<span class="gi">+def _fresh_title_style_context(state: RSTState) -&gt; Iterator[None]:</span>
<span class="gi">+    # hack around title style bookkeeping</span>
<span class="gi">+    memo = state.memo</span>
<span class="gi">+    surrounding_title_styles: list[str | tuple[str, str]] = memo.title_styles</span>
<span class="gi">+    surrounding_section_level: int = memo.section_level</span>
<span class="gi">+    # clear current title styles</span>
<span class="gi">+    memo.title_styles = []</span>
<span class="gi">+    memo.section_level = 0</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        # reset title styles</span>
<span class="gi">+        memo.title_styles = surrounding_title_styles</span>
<span class="gi">+        memo.section_level = surrounding_section_level</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _text_to_string_list(</span>
<span class="gi">+    text: str | StringList, /, *, source: str, tab_width: int,</span>
<span class="gi">+) -&gt; StringList:</span>
<span class="gi">+    # Doesn&#39;t really belong in this module, but avoids circular imports.</span>
<span class="gi">+    if isinstance(text, StringList):</span>
<span class="gi">+        return text</span>
<span class="gi">+    content = string2lines(text, tab_width, convert_whitespace=True)</span>
<span class="gi">+    return StringList(content, source=source)</span>
<span class="gh">diff --git a/sphinx/util/png.py b/sphinx/util/png.py</span>
<span class="gh">index fb20e2105..6c942194e 100644</span>
<span class="gd">--- a/sphinx/util/png.py</span>
<span class="gi">+++ b/sphinx/util/png.py</span>
<span class="gu">@@ -1,22 +1,43 @@</span>
<span class="w"> </span>&quot;&quot;&quot;PNG image manipulation helpers.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import binascii
<span class="w"> </span>import struct
<span class="gi">+</span>
<span class="w"> </span>LEN_IEND = 12
<span class="w"> </span>LEN_DEPTH = 22
<span class="gi">+</span>
<span class="w"> </span>DEPTH_CHUNK_LEN = struct.pack(&#39;!i&#39;, 10)
<span class="w"> </span>DEPTH_CHUNK_START = b&#39;tEXtDepth\x00&#39;
<span class="gd">-IEND_CHUNK = b&#39;\x00\x00\x00\x00IEND\xaeB`\x82&#39;</span>
<span class="gi">+IEND_CHUNK = b&#39;\x00\x00\x00\x00IEND\xAE\x42\x60\x82&#39;</span>


<span class="gd">-def read_png_depth(filename: str) -&gt;(int | None):</span>
<span class="gi">+def read_png_depth(filename: str) -&gt; int | None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Read the special tEXt chunk indicating the depth from a PNG file.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with open(filename, &#39;rb&#39;) as f:</span>
<span class="gi">+        f.seek(- (LEN_IEND + LEN_DEPTH), 2)</span>
<span class="gi">+        depthchunk = f.read(LEN_DEPTH)</span>
<span class="gi">+        if not depthchunk.startswith(DEPTH_CHUNK_LEN + DEPTH_CHUNK_START):</span>
<span class="gi">+            # either not a PNG file or not containing the depth chunk</span>
<span class="gi">+            return None</span>
<span class="gi">+        else:</span>
<span class="gi">+            return struct.unpack(&#39;!i&#39;, depthchunk[14:18])[0]</span>


<span class="gd">-def write_png_depth(filename: str, depth: int) -&gt;None:</span>
<span class="gi">+def write_png_depth(filename: str, depth: int) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Write the special tEXt chunk indicating the depth to a PNG file.

<span class="w"> </span>    The chunk is placed immediately before the special IEND chunk.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    data = struct.pack(&#39;!i&#39;, depth)</span>
<span class="gi">+    with open(filename, &#39;r+b&#39;) as f:</span>
<span class="gi">+        # seek to the beginning of the IEND chunk</span>
<span class="gi">+        f.seek(-LEN_IEND, 2)</span>
<span class="gi">+        # overwrite it with the depth chunk</span>
<span class="gi">+        f.write(DEPTH_CHUNK_LEN + DEPTH_CHUNK_START + data)</span>
<span class="gi">+        # calculate the checksum over chunk name and data</span>
<span class="gi">+        crc = binascii.crc32(DEPTH_CHUNK_START + data) &amp; 0xffffffff</span>
<span class="gi">+        f.write(struct.pack(&#39;!I&#39;, crc))</span>
<span class="gi">+        # replace the IEND chunk</span>
<span class="gi">+        f.write(IEND_CHUNK)</span>
<span class="gh">diff --git a/sphinx/util/requests.py b/sphinx/util/requests.py</span>
<span class="gh">index c1ee76baa..7c64e940d 100644</span>
<span class="gd">--- a/sphinx/util/requests.py</span>
<span class="gi">+++ b/sphinx/util/requests.py</span>
<span class="gu">@@ -1,45 +1,76 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Simple requests package loader&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import warnings
<span class="w"> </span>from typing import Any
<span class="w"> </span>from urllib.parse import urlsplit
<span class="gi">+</span>
<span class="w"> </span>import requests
<span class="w"> </span>from urllib3.exceptions import InsecureRequestWarning
<span class="gi">+</span>
<span class="w"> </span>import sphinx
<span class="gd">-_USER_AGENT = (</span>
<span class="gd">-    f&#39;Mozilla/5.0 (X11; Linux x86_64; rv:100.0) Gecko/20100101 Firefox/100.0 Sphinx/{sphinx.__version__}&#39;</span>
<span class="gd">-    )</span>
<span class="gi">+</span>
<span class="gi">+_USER_AGENT = (f&#39;Mozilla/5.0 (X11; Linux x86_64; rv:100.0) Gecko/20100101 Firefox/100.0 &#39;</span>
<span class="gi">+               f&#39;Sphinx/{sphinx.__version__}&#39;)</span>


<span class="gd">-def _get_tls_cacert(url: str, certs: (str | dict[str, str] | None)) -&gt;(str |</span>
<span class="gd">-    bool):</span>
<span class="gi">+def _get_tls_cacert(url: str, certs: str | dict[str, str] | None) -&gt; str | bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get additional CA cert for a specific URL.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not certs:</span>
<span class="gi">+        return True</span>
<span class="gi">+    elif isinstance(certs, str | tuple):</span>
<span class="gi">+        return certs</span>
<span class="gi">+    else:</span>
<span class="gi">+        hostname = urlsplit(url).netloc</span>
<span class="gi">+        if &#39;@&#39; in hostname:</span>
<span class="gi">+            _, hostname = hostname.split(&#39;@&#39;, 1)</span>

<span class="gi">+        return certs.get(hostname, True)</span>

<span class="gd">-def get(url: str, **kwargs: Any) -&gt;requests.Response:</span>
<span class="gi">+</span>
<span class="gi">+def get(url: str, **kwargs: Any) -&gt; requests.Response:</span>
<span class="w"> </span>    &quot;&quot;&quot;Sends a GET request like ``requests.get()``.

<span class="w"> </span>    This sets up User-Agent header and TLS verification automatically.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with _Session() as session:</span>
<span class="gi">+        return session.get(url, **kwargs)</span>


<span class="gd">-def head(url: str, **kwargs: Any) -&gt;requests.Response:</span>
<span class="gi">+def head(url: str, **kwargs: Any) -&gt; requests.Response:</span>
<span class="w"> </span>    &quot;&quot;&quot;Sends a HEAD request like ``requests.head()``.

<span class="w"> </span>    This sets up User-Agent header and TLS verification automatically.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    with _Session() as session:</span>
<span class="gi">+        return session.head(url, **kwargs)</span>


<span class="w"> </span>class _Session(requests.Session):
<span class="gd">-</span>
<span class="gd">-    def request(self, method: str, url: str, _user_agent: str=&#39;&#39;, _tls_info:</span>
<span class="gd">-        tuple[bool, str | dict[str, str] | None]=(), **kwargs: Any</span>
<span class="gd">-        ) -&gt;requests.Response:</span>
<span class="gi">+    def request(  # type: ignore[override]</span>
<span class="gi">+        self, method: str, url: str,</span>
<span class="gi">+        _user_agent: str = &#39;&#39;,</span>
<span class="gi">+        _tls_info: tuple[bool, str | dict[str, str] | None] = (),  # type: ignore[assignment]</span>
<span class="gi">+        **kwargs: Any,</span>
<span class="gi">+    ) -&gt; requests.Response:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sends a request with an HTTP verb and url.

<span class="w"> </span>        This sets up User-Agent header and TLS verification automatically.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        headers = kwargs.setdefault(&#39;headers&#39;, {})</span>
<span class="gi">+        headers.setdefault(&#39;User-Agent&#39;, _user_agent or _USER_AGENT)</span>
<span class="gi">+        if _tls_info:</span>
<span class="gi">+            tls_verify, tls_cacerts = _tls_info</span>
<span class="gi">+            verify = bool(kwargs.get(&#39;verify&#39;, tls_verify))</span>
<span class="gi">+            kwargs.setdefault(&#39;verify&#39;, verify and _get_tls_cacert(url, tls_cacerts))</span>
<span class="gi">+        else:</span>
<span class="gi">+            verify = kwargs.get(&#39;verify&#39;, True)</span>
<span class="gi">+</span>
<span class="gi">+        if verify:</span>
<span class="gi">+            return super().request(method, url, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        with warnings.catch_warnings():</span>
<span class="gi">+            # ignore InsecureRequestWarning if verify=False</span>
<span class="gi">+            warnings.filterwarnings(&quot;ignore&quot;, category=InsecureRequestWarning)</span>
<span class="gi">+            return super().request(method, url, **kwargs)</span>
<span class="gh">diff --git a/sphinx/util/rst.py b/sphinx/util/rst.py</span>
<span class="gh">index 21fe03367..4e8fdee2e 100644</span>
<span class="gd">--- a/sphinx/util/rst.py</span>
<span class="gi">+++ b/sphinx/util/rst.py</span>
<span class="gu">@@ -1,44 +1,112 @@</span>
<span class="w"> </span>&quot;&quot;&quot;reST helper functions.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from contextlib import contextmanager
<span class="w"> </span>from typing import TYPE_CHECKING, cast
<span class="w"> </span>from unicodedata import east_asian_width
<span class="gi">+</span>
<span class="w"> </span>from docutils.parsers.rst import roles
<span class="gd">-from docutils.parsers.rst.languages import en as english</span>
<span class="gi">+from docutils.parsers.rst.languages import en as english  # type: ignore[attr-defined]</span>
<span class="w"> </span>from docutils.parsers.rst.states import Body
<span class="w"> </span>from docutils.utils import Reporter
<span class="w"> </span>from jinja2 import Environment, pass_environment
<span class="gi">+</span>
<span class="w"> </span>from sphinx.locale import __
<span class="w"> </span>from sphinx.util import docutils, logging
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Iterator
<span class="gi">+</span>
<span class="w"> </span>    from docutils.statemachine import StringList
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gi">+</span>
<span class="w"> </span>FIELD_NAME_RE = re.compile(Body.patterns[&#39;field_marker&#39;])
<span class="gd">-symbols_re = re.compile(&#39;([!-\\-/:-@\\[-`{-~])&#39;)</span>
<span class="gi">+symbols_re = re.compile(r&#39;([!-\-/:-@\[-`{-~])&#39;)  # symbols without dot(0x2e)</span>
<span class="w"> </span>SECTIONING_CHARS = [&#39;=&#39;, &#39;-&#39;, &#39;~&#39;]
<span class="gd">-WIDECHARS: dict[str, str] = defaultdict(lambda : &#39;WF&#39;)</span>
<span class="gd">-WIDECHARS[&#39;ja&#39;] = &#39;WFA&#39;</span>

<span class="gi">+# width of characters</span>
<span class="gi">+WIDECHARS: dict[str, str] = defaultdict(lambda: &quot;WF&quot;)  # WF: Wide + Full-width</span>
<span class="gi">+WIDECHARS[&quot;ja&quot;] = &quot;WFA&quot;  # In Japanese, Ambiguous characters also have double width</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def escape(text: str) -&gt; str:</span>
<span class="gi">+    text = symbols_re.sub(r&#39;\\\1&#39;, text)</span>
<span class="gi">+    text = re.sub(r&#39;^\.&#39;, r&#39;\.&#39;, text)  # escape a dot at top</span>
<span class="gi">+    return text</span>

<span class="gd">-def textwidth(text: str, widechars: str=&#39;WF&#39;) -&gt;int:</span>
<span class="gi">+</span>
<span class="gi">+def textwidth(text: str, widechars: str = &#39;WF&#39;) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Get width of text.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def charwidth(char: str, widechars: str) -&gt; int:</span>
<span class="gi">+        if east_asian_width(char) in widechars:</span>
<span class="gi">+            return 2</span>
<span class="gi">+        else:</span>
<span class="gi">+            return 1</span>
<span class="gi">+</span>
<span class="gi">+    return sum(charwidth(c, widechars) for c in text)</span>


<span class="w"> </span>@pass_environment
<span class="gd">-def heading(env: Environment, text: str, level: int=1) -&gt;str:</span>
<span class="gi">+def heading(env: Environment, text: str, level: int = 1) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Create a heading for *level*.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert level &lt;= 3</span>
<span class="gi">+    # ``env.language`` is injected by ``sphinx.util.template.ReSTRenderer``</span>
<span class="gi">+    width = textwidth(text, WIDECHARS[env.language])  # type: ignore[attr-defined]</span>
<span class="gi">+    sectioning_char = SECTIONING_CHARS[level - 1]</span>
<span class="gi">+    return f&#39;{text}\n{sectioning_char * width}&#39;</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+@contextmanager</span>
<span class="gi">+def default_role(docname: str, name: str) -&gt; Iterator[None]:</span>
<span class="gi">+    if name:</span>
<span class="gi">+        dummy_reporter = Reporter(&#39;&#39;, 4, 4)</span>
<span class="gi">+        role_fn, _ = roles.role(name, english, 0, dummy_reporter)</span>
<span class="gi">+        if role_fn:</span>
<span class="gi">+            docutils.register_role(&#39;&#39;, role_fn)  # type: ignore[arg-type]</span>
<span class="gi">+        else:</span>
<span class="gi">+            logger.warning(__(&#39;default role %s not found&#39;), name, location=docname)</span>
<span class="gi">+</span>
<span class="gi">+    yield</span>

<span class="gi">+    docutils.unregister_role(&#39;&#39;)</span>

<span class="gd">-def prepend_prolog(content: StringList, prolog: str) -&gt;None:</span>
<span class="gi">+</span>
<span class="gi">+def prepend_prolog(content: StringList, prolog: str) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Prepend a string to content body as prolog.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if prolog:</span>
<span class="gi">+        pos = 0</span>
<span class="gi">+        for line in content:</span>
<span class="gi">+            if FIELD_NAME_RE.match(line):</span>
<span class="gi">+                pos += 1</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        if pos &gt; 0:</span>
<span class="gi">+            # insert a blank line after docinfo</span>
<span class="gi">+            content.insert(pos, &#39;&#39;, &#39;&lt;generated&gt;&#39;, 0)</span>
<span class="gi">+            pos += 1</span>
<span class="gi">+</span>
<span class="gi">+        # insert prolog (after docinfo if exists)</span>
<span class="gi">+        lineno = 0</span>
<span class="gi">+        for lineno, line in enumerate(prolog.splitlines()):</span>
<span class="gi">+            content.insert(pos + lineno, line, &#39;&lt;rst_prolog&gt;&#39;, lineno)</span>
<span class="gi">+</span>
<span class="gi">+        content.insert(pos + lineno + 1, &#39;&#39;, &#39;&lt;generated&gt;&#39;, 0)</span>


<span class="gd">-def append_epilog(content: StringList, epilog: str) -&gt;None:</span>
<span class="gi">+def append_epilog(content: StringList, epilog: str) -&gt; None:</span>
<span class="w"> </span>    &quot;&quot;&quot;Append a string to content body as epilog.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if epilog:</span>
<span class="gi">+        if len(content) &gt; 0:</span>
<span class="gi">+            source, lineno = content.info(-1)</span>
<span class="gi">+            lineno = cast(int, lineno)  # lineno will never be None, since len(content) &gt; 0</span>
<span class="gi">+        else:</span>
<span class="gi">+            source = &#39;&lt;generated&gt;&#39;</span>
<span class="gi">+            lineno = 0</span>
<span class="gi">+        content.append(&#39;&#39;, source, lineno + 1)</span>
<span class="gi">+        for lineno, line in enumerate(epilog.splitlines()):</span>
<span class="gi">+            content.append(line, &#39;&lt;rst_epilog&gt;&#39;, lineno)</span>
<span class="gh">diff --git a/sphinx/util/tags.py b/sphinx/util/tags.py</span>
<span class="gh">index 808df44b6..71492dc9a 100644</span>
<span class="gd">--- a/sphinx/util/tags.py</span>
<span class="gi">+++ b/sphinx/util/tags.py</span>
<span class="gu">@@ -1,43 +1,112 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import warnings
<span class="w"> </span>from typing import TYPE_CHECKING
<span class="gi">+</span>
<span class="w"> </span>import jinja2.environment
<span class="w"> </span>import jinja2.nodes
<span class="w"> </span>import jinja2.parser
<span class="gi">+</span>
<span class="w"> </span>from sphinx.deprecation import RemovedInSphinx90Warning
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Iterator, Sequence
<span class="w"> </span>    from typing import Literal
<span class="gi">+</span>
<span class="w"> </span>_ENV = jinja2.environment.Environment()


<span class="w"> </span>class BooleanParser(jinja2.parser.Parser):
<span class="w"> </span>    &quot;&quot;&quot;Only allow conditional expressions and binary operators.&quot;&quot;&quot;

<span class="gi">+    def parse_compare(self) -&gt; jinja2.nodes.Expr:</span>
<span class="gi">+        node: jinja2.nodes.Expr</span>
<span class="gi">+        token = self.stream.current</span>
<span class="gi">+        if token.type == &#39;name&#39;:</span>
<span class="gi">+            if token.value in {&#39;true&#39;, &#39;True&#39;}:</span>
<span class="gi">+                node = jinja2.nodes.Const(True, lineno=token.lineno)</span>
<span class="gi">+            elif token.value in {&#39;false&#39;, &#39;False&#39;}:</span>
<span class="gi">+                node = jinja2.nodes.Const(False, lineno=token.lineno)</span>
<span class="gi">+            elif token.value in {&#39;none&#39;, &#39;None&#39;}:</span>
<span class="gi">+                node = jinja2.nodes.Const(None, lineno=token.lineno)</span>
<span class="gi">+            else:</span>
<span class="gi">+                node = jinja2.nodes.Name(token.value, &#39;load&#39;, lineno=token.lineno)</span>
<span class="gi">+            next(self.stream)</span>
<span class="gi">+        elif token.type == &#39;lparen&#39;:</span>
<span class="gi">+            next(self.stream)</span>
<span class="gi">+            node = self.parse_expression()</span>
<span class="gi">+            self.stream.expect(&#39;rparen&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.fail(f&quot;unexpected token &#39;{token}&#39;&quot;, token.lineno)</span>
<span class="gi">+        return node</span>

<span class="gd">-class Tags:</span>

<span class="gd">-    def __init__(self, tags: Sequence[str]=()) -&gt;None:</span>
<span class="gi">+class Tags:</span>
<span class="gi">+    def __init__(self, tags: Sequence[str] = ()) -&gt; None:</span>
<span class="w"> </span>        self._tags = set(tags or ())
<span class="w"> </span>        self._condition_cache: dict[str, bool] = {}

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gd">-        return f&quot;{self.__class__.__name__}({&#39;, &#39;.join(sorted(self._tags))})&quot;</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="gi">+        return f&#39;{self.__class__.__name__}({&quot;, &quot;.join(sorted(self._tags))})&#39;</span>

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="w"> </span>        return f&#39;{self.__class__.__name__}({tuple(sorted(self._tags))})&#39;

<span class="gd">-    def __iter__(self) -&gt;Iterator[str]:</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[str]:</span>
<span class="w"> </span>        return iter(self._tags)

<span class="gd">-    def __contains__(self, tag: str) -&gt;bool:</span>
<span class="gi">+    def __contains__(self, tag: str) -&gt; bool:</span>
<span class="w"> </span>        return tag in self._tags

<span class="gd">-    def eval_condition(self, condition: str) -&gt;bool:</span>
<span class="gi">+    def has(self, tag: str) -&gt; bool:</span>
<span class="gi">+        return tag in self._tags</span>
<span class="gi">+</span>
<span class="gi">+    def add(self, tag: str) -&gt; None:</span>
<span class="gi">+        self._tags.add(tag)</span>
<span class="gi">+</span>
<span class="gi">+    def remove(self, tag: str) -&gt; None:</span>
<span class="gi">+        self._tags.discard(tag)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def tags(self) -&gt; dict[str, Literal[True]]:</span>
<span class="gi">+        warnings.warn(&#39;Tags.tags is deprecated, use methods on Tags.&#39;,</span>
<span class="gi">+                      RemovedInSphinx90Warning, stacklevel=2)</span>
<span class="gi">+        return dict.fromkeys(self._tags, True)</span>
<span class="gi">+</span>
<span class="gi">+    def eval_condition(self, condition: str) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Evaluate a boolean condition.

<span class="w"> </span>        Only conditional expressions and binary operators (and, or, not)
<span class="w"> </span>        are permitted, and operate on tag names, where truthy values mean
<span class="w"> </span>        the tag is present and vice versa.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if condition in self._condition_cache:</span>
<span class="gi">+            return self._condition_cache[condition]</span>
<span class="gi">+</span>
<span class="gi">+        # exceptions are handled by the caller</span>
<span class="gi">+        parser = BooleanParser(_ENV, condition, state=&#39;variable&#39;)</span>
<span class="gi">+        expr = parser.parse_expression()</span>
<span class="gi">+        if not parser.stream.eos:</span>
<span class="gi">+            msg = &#39;chunk after expression&#39;</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+        evaluated = self._condition_cache[condition] = self._eval_node(expr)</span>
<span class="gi">+        return evaluated</span>
<span class="gi">+</span>
<span class="gi">+    def _eval_node(self, node: jinja2.nodes.Node | None) -&gt; bool:</span>
<span class="gi">+        if isinstance(node, jinja2.nodes.CondExpr):</span>
<span class="gi">+            if self._eval_node(node.test):</span>
<span class="gi">+                return self._eval_node(node.expr1)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return self._eval_node(node.expr2)</span>
<span class="gi">+        elif isinstance(node, jinja2.nodes.And):</span>
<span class="gi">+            return self._eval_node(node.left) and self._eval_node(node.right)</span>
<span class="gi">+        elif isinstance(node, jinja2.nodes.Or):</span>
<span class="gi">+            return self._eval_node(node.left) or self._eval_node(node.right)</span>
<span class="gi">+        elif isinstance(node, jinja2.nodes.Not):</span>
<span class="gi">+            return not self._eval_node(node.node)</span>
<span class="gi">+        elif isinstance(node, jinja2.nodes.Name):</span>
<span class="gi">+            return node.name in self._tags</span>
<span class="gi">+        else:</span>
<span class="gi">+            msg = &#39;invalid node, check parsing&#39;</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gh">diff --git a/sphinx/util/template.py b/sphinx/util/template.py</span>
<span class="gh">index 5598ce1aa..2b38e3a86 100644</span>
<span class="gd">--- a/sphinx/util/template.py</span>
<span class="gi">+++ b/sphinx/util/template.py</span>
<span class="gu">@@ -1,61 +1,89 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Templates utility functions for Sphinx.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>from functools import partial
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from jinja2 import TemplateNotFound
<span class="w"> </span>from jinja2.loaders import BaseLoader
<span class="w"> </span>from jinja2.sandbox import SandboxedEnvironment
<span class="gi">+</span>
<span class="w"> </span>from sphinx import package_dir
<span class="w"> </span>from sphinx.jinja2glue import SphinxFileSystemLoader
<span class="w"> </span>from sphinx.locale import get_translator
<span class="w"> </span>from sphinx.util import rst, texescape
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Callable, Sequence
<span class="gi">+</span>
<span class="w"> </span>    from jinja2.environment import Environment


<span class="w"> </span>class BaseRenderer:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, loader: (BaseLoader | None)=None) -&gt;None:</span>
<span class="gd">-        self.env = SandboxedEnvironment(loader=loader, extensions=[</span>
<span class="gd">-            &#39;jinja2.ext.i18n&#39;])</span>
<span class="gi">+    def __init__(self, loader: BaseLoader | None = None) -&gt; None:</span>
<span class="gi">+        self.env = SandboxedEnvironment(loader=loader, extensions=[&#39;jinja2.ext.i18n&#39;])</span>
<span class="w"> </span>        self.env.filters[&#39;repr&#39;] = repr
<span class="gd">-        self.env.install_gettext_translations(get_translator())</span>
<span class="gi">+        # ``install_gettext_translations`` is injected by the ``jinja2.ext.i18n`` extension</span>
<span class="gi">+        self.env.install_gettext_translations(get_translator())  # type: ignore[attr-defined]</span>

<span class="gi">+    def render(self, template_name: str, context: dict[str, Any]) -&gt; str:</span>
<span class="gi">+        return self.env.get_template(template_name).render(context)</span>
<span class="gi">+</span>
<span class="gi">+    def render_string(self, source: str, context: dict[str, Any]) -&gt; str:</span>
<span class="gi">+        return self.env.from_string(source).render(context)</span>

<span class="gd">-class FileRenderer(BaseRenderer):</span>

<span class="gd">-    def __init__(self, search_path: Sequence[str | os.PathLike[str]]) -&gt;None:</span>
<span class="gi">+class FileRenderer(BaseRenderer):</span>
<span class="gi">+    def __init__(self, search_path: Sequence[str | os.PathLike[str]]) -&gt; None:</span>
<span class="w"> </span>        if isinstance(search_path, str | os.PathLike):
<span class="w"> </span>            search_path = [search_path]
<span class="w"> </span>        else:
<span class="gi">+            # filter &quot;None&quot; paths</span>
<span class="w"> </span>            search_path = list(filter(None, search_path))
<span class="gi">+</span>
<span class="w"> </span>        loader = SphinxFileSystemLoader(search_path)
<span class="w"> </span>        super().__init__(loader)

<span class="gi">+    @classmethod</span>
<span class="gi">+    def render_from_file(</span>
<span class="gi">+        cls: type[FileRenderer], filename: str, context: dict[str, Any],</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        dirname = os.path.dirname(filename)</span>
<span class="gi">+        basename = os.path.basename(filename)</span>
<span class="gi">+        return cls(dirname).render(basename, context)</span>

<span class="gd">-class SphinxRenderer(FileRenderer):</span>

<span class="gd">-    def __init__(self, template_path: (Sequence[str | os.PathLike[str]] |</span>
<span class="gd">-        None)=None) -&gt;None:</span>
<span class="gi">+class SphinxRenderer(FileRenderer):</span>
<span class="gi">+    def __init__(self, template_path: Sequence[str | os.PathLike[str]] | None = None) -&gt; None:</span>
<span class="w"> </span>        if template_path is None:
<span class="w"> </span>            template_path = os.path.join(package_dir, &#39;templates&#39;)
<span class="w"> </span>        super().__init__(template_path)

<span class="gi">+    @classmethod</span>
<span class="gi">+    def render_from_file(</span>
<span class="gi">+        cls: type[FileRenderer], filename: str, context: dict[str, Any],</span>
<span class="gi">+    ) -&gt; str:</span>
<span class="gi">+        return FileRenderer.render_from_file(filename, context)</span>

<span class="gd">-class LaTeXRenderer(SphinxRenderer):</span>

<span class="gd">-    def __init__(self, template_path: (Sequence[str | os.PathLike[str]] |</span>
<span class="gd">-        None)=None, latex_engine: (str | None)=None) -&gt;None:</span>
<span class="gi">+class LaTeXRenderer(SphinxRenderer):</span>
<span class="gi">+    def __init__(self, template_path: Sequence[str | os.PathLike[str]] | None = None,</span>
<span class="gi">+                 latex_engine: str | None = None) -&gt; None:</span>
<span class="w"> </span>        if template_path is None:
<span class="w"> </span>            template_path = [os.path.join(package_dir, &#39;templates&#39;, &#39;latex&#39;)]
<span class="w"> </span>        super().__init__(template_path)
<span class="gi">+</span>
<span class="gi">+        # use texescape as escape filter</span>
<span class="w"> </span>        escape = partial(texescape.escape, latex_engine=latex_engine)
<span class="w"> </span>        self.env.filters[&#39;e&#39;] = escape
<span class="w"> </span>        self.env.filters[&#39;escape&#39;] = escape
<span class="w"> </span>        self.env.filters[&#39;eabbr&#39;] = texescape.escape_abbr
<span class="gi">+</span>
<span class="gi">+        # use JSP/eRuby like tagging instead because curly bracket; the default</span>
<span class="gi">+        # tagging of jinja2 is not good for LaTeX sources.</span>
<span class="w"> </span>        self.env.variable_start_string = &#39;&lt;%=&#39;
<span class="w"> </span>        self.env.variable_end_string = &#39;%&gt;&#39;
<span class="w"> </span>        self.env.block_start_string = &#39;&lt;%&#39;
<span class="gu">@@ -65,11 +93,14 @@ class LaTeXRenderer(SphinxRenderer):</span>


<span class="w"> </span>class ReSTRenderer(SphinxRenderer):
<span class="gd">-</span>
<span class="gd">-    def __init__(self, template_path: (Sequence[str | os.PathLike[str]] |</span>
<span class="gd">-        None)=None, language: (str | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, template_path: Sequence[str | os.PathLike[str]] | None = None,</span>
<span class="gi">+                 language: str | None = None) -&gt; None:</span>
<span class="w"> </span>        super().__init__(template_path)
<span class="gi">+</span>
<span class="gi">+        # add language to environment</span>
<span class="w"> </span>        self.env.extend(language=language)
<span class="gi">+</span>
<span class="gi">+        # use texescape as escape filter</span>
<span class="w"> </span>        self.env.filters[&#39;e&#39;] = rst.escape
<span class="w"> </span>        self.env.filters[&#39;escape&#39;] = rst.escape
<span class="w"> </span>        self.env.filters[&#39;heading&#39;] = rst.heading
<span class="gu">@@ -78,15 +109,32 @@ class ReSTRenderer(SphinxRenderer):</span>
<span class="w"> </span>class SphinxTemplateLoader(BaseLoader):
<span class="w"> </span>    &quot;&quot;&quot;A loader supporting template inheritance&quot;&quot;&quot;

<span class="gd">-    def __init__(self, confdir: (str | os.PathLike[str]), templates_paths:</span>
<span class="gd">-        Sequence[str | os.PathLike[str]], system_templates_paths: Sequence[</span>
<span class="gd">-        str | os.PathLike[str]]) -&gt;None:</span>
<span class="gi">+    def __init__(self, confdir: str | os.PathLike[str],</span>
<span class="gi">+                 templates_paths: Sequence[str | os.PathLike[str]],</span>
<span class="gi">+                 system_templates_paths: Sequence[str | os.PathLike[str]]) -&gt; None:</span>
<span class="w"> </span>        self.loaders = []
<span class="w"> </span>        self.sysloaders = []
<span class="gi">+</span>
<span class="w"> </span>        for templates_path in templates_paths:
<span class="w"> </span>            loader = SphinxFileSystemLoader(path.join(confdir, templates_path))
<span class="w"> </span>            self.loaders.append(loader)
<span class="gi">+</span>
<span class="w"> </span>        for templates_path in system_templates_paths:
<span class="w"> </span>            loader = SphinxFileSystemLoader(templates_path)
<span class="w"> </span>            self.loaders.append(loader)
<span class="w"> </span>            self.sysloaders.append(loader)
<span class="gi">+</span>
<span class="gi">+    def get_source(self, environment: Environment, template: str) -&gt; tuple[str, str, Callable]:</span>
<span class="gi">+        if template.startswith(&#39;!&#39;):</span>
<span class="gi">+            # search a template from ``system_templates_paths``</span>
<span class="gi">+            loaders = self.sysloaders</span>
<span class="gi">+            template = template[1:]</span>
<span class="gi">+        else:</span>
<span class="gi">+            loaders = self.loaders</span>
<span class="gi">+</span>
<span class="gi">+        for loader in loaders:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return loader.get_source(environment, template)</span>
<span class="gi">+            except TemplateNotFound:</span>
<span class="gi">+                pass</span>
<span class="gi">+        raise TemplateNotFound(template)</span>
<span class="gh">diff --git a/sphinx/util/texescape.py b/sphinx/util/texescape.py</span>
<span class="gh">index 2ed1eb943..8527441d7 100644</span>
<span class="gd">--- a/sphinx/util/texescape.py</span>
<span class="gi">+++ b/sphinx/util/texescape.py</span>
<span class="gu">@@ -1,47 +1,153 @@</span>
<span class="w"> </span>&quot;&quot;&quot;TeX escaping helper.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="gd">-tex_replacements = [(&#39;$&#39;, &#39;\\$&#39;), (&#39;%&#39;, &#39;\\%&#39;), (&#39;&amp;&#39;, &#39;\\&amp;&#39;), (&#39;#&#39;, &#39;\\#&#39;),</span>
<span class="gd">-    (&#39;_&#39;, &#39;\\_&#39;), (&#39;{&#39;, &#39;\\{&#39;), (&#39;}&#39;, &#39;\\}&#39;), (&#39;\\&#39;, &#39;\\textbackslash{}&#39;),</span>
<span class="gd">-    (&#39;~&#39;, &#39;\\textasciitilde{}&#39;), (&#39;^&#39;, &#39;\\textasciicircum{}&#39;), (&#39;[&#39;, &#39;{[}&#39;),</span>
<span class="gd">-    (&#39;]&#39;, &#39;{]}&#39;), (&#39;&#39;, &#39;\\(\\checkmark\\)&#39;), (&#39;&#39;,</span>
<span class="gd">-    &#39;\\(\\pmb{\\checkmark}\\)&#39;), (&#39;&#39;, &#39;\\(\\times\\)&#39;), (&#39;&#39;,</span>
<span class="gd">-    &#39;\\(\\pmb{\\times}\\)&#39;), (&#39;\ufeff&#39;, &#39;{}&#39;), (&#39;&#39;, &#39;\\_&#39;), (&#39;&#39;, &#39;e&#39;), (</span>
<span class="gd">-    &#39;&#39;, &#39;i&#39;)]</span>
<span class="gd">-ascii_tex_replacements = [(&#39;-&#39;, &#39;\\sphinxhyphen{}&#39;), (&quot;&#39;&quot;,</span>
<span class="gd">-    &#39;\\textquotesingle{}&#39;), (&#39;`&#39;, &#39;\\textasciigrave{}&#39;), (&#39;&lt;&#39;,</span>
<span class="gd">-    &#39;\\textless{}&#39;), (&#39;&gt;&#39;, &#39;\\textgreater{}&#39;)]</span>
<span class="gd">-unicode_tex_replacements = [(&#39;&#39;, &#39;\\P{}&#39;), (&#39;&#39;, &#39;\\S{}&#39;), (&#39;&#39;,</span>
<span class="gd">-    &#39;\\texteuro{}&#39;), (&#39;&#39;, &#39;\\(\\infty\\)&#39;), (&#39;&#39;, &#39;\\(\\pm\\)&#39;), (&#39;&#39;,</span>
<span class="gd">-    &#39;\\(\\rightarrow\\)&#39;), (&#39;&#39;, &#39;\\(\\rightarrow\\)&#39;), (&#39;&#39;,</span>
<span class="gd">-    &#39;\\textendash{}&#39;), (&#39;&#39;, &#39;\\(\\sp{\\text{0}}\\)&#39;), (&#39;&#39;,</span>
<span class="gd">-    &#39;\\(\\sp{\\text{1}}\\)&#39;), (&#39;&#39;, &#39;\\(\\sp{\\text{2}}\\)&#39;), (&#39;&#39;,</span>
<span class="gd">-    &#39;\\(\\sp{\\text{3}}\\)&#39;), (&#39;&#39;, &#39;\\(\\sp{\\text{4}}\\)&#39;), (&#39;&#39;,</span>
<span class="gd">-    &#39;\\(\\sp{\\text{5}}\\)&#39;), (&#39;&#39;, &#39;\\(\\sp{\\text{6}}\\)&#39;), (&#39;&#39;,</span>
<span class="gd">-    &#39;\\(\\sp{\\text{7}}\\)&#39;), (&#39;&#39;, &#39;\\(\\sp{\\text{8}}\\)&#39;), (&#39;&#39;,</span>
<span class="gd">-    &#39;\\(\\sp{\\text{9}}\\)&#39;), (&#39;&#39;, &#39;\\(\\sb{\\text{0}}\\)&#39;), (&#39;&#39;,</span>
<span class="gd">-    &#39;\\(\\sb{\\text{1}}\\)&#39;), (&#39;&#39;, &#39;\\(\\sb{\\text{2}}\\)&#39;), (&#39;&#39;,</span>
<span class="gd">-    &#39;\\(\\sb{\\text{3}}\\)&#39;), (&#39;&#39;, &#39;\\(\\sb{\\text{4}}\\)&#39;), (&#39;&#39;,</span>
<span class="gd">-    &#39;\\(\\sb{\\text{5}}\\)&#39;), (&#39;&#39;, &#39;\\(\\sb{\\text{6}}\\)&#39;), (&#39;&#39;,</span>
<span class="gd">-    &#39;\\(\\sb{\\text{7}}\\)&#39;), (&#39;&#39;, &#39;\\(\\sb{\\text{8}}\\)&#39;), (&#39;&#39;,</span>
<span class="gd">-    &#39;\\(\\sb{\\text{9}}\\)&#39;)]</span>
<span class="gi">+</span>
<span class="gi">+tex_replacements = [</span>
<span class="gi">+    # map TeX special chars</span>
<span class="gi">+    (&#39;$&#39;, r&#39;\$&#39;),</span>
<span class="gi">+    (&#39;%&#39;, r&#39;\%&#39;),</span>
<span class="gi">+    (&#39;&amp;&#39;, r&#39;\&amp;&#39;),</span>
<span class="gi">+    (&#39;#&#39;, r&#39;\#&#39;),</span>
<span class="gi">+    (&#39;_&#39;, r&#39;\_&#39;),</span>
<span class="gi">+    (&#39;{&#39;, r&#39;\{&#39;),</span>
<span class="gi">+    (&#39;}&#39;, r&#39;\}&#39;),</span>
<span class="gi">+    (&#39;\\&#39;, r&#39;\textbackslash{}&#39;),</span>
<span class="gi">+    (&#39;~&#39;, r&#39;\textasciitilde{}&#39;),</span>
<span class="gi">+    (&#39;^&#39;, r&#39;\textasciicircum{}&#39;),</span>
<span class="gi">+    # map chars to avoid mis-interpretation in LaTeX</span>
<span class="gi">+    (&#39;[&#39;, r&#39;{[}&#39;),</span>
<span class="gi">+    (&#39;]&#39;, r&#39;{]}&#39;),</span>
<span class="gi">+    # map special Unicode characters to TeX commands</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\checkmark\)&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\pmb{\checkmark}\)&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\times\)&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\pmb{\times}\)&#39;),</span>
<span class="gi">+    # used to separate -- in options</span>
<span class="gi">+    (&#39;&#39;, r&#39;{}&#39;),</span>
<span class="gi">+    # map some special Unicode characters to similar ASCII ones</span>
<span class="gi">+    # (even for Unicode LaTeX as may not be supported by OpenType font)</span>
<span class="gi">+    (&#39;&#39;, r&#39;\_&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;e&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;i&#39;),</span>
<span class="gi">+    # Greek alphabet not escaped: pdflatex handles it via textalpha and inputenc</span>
<span class="gi">+    # OHM SIGN U+2126 is handled by LaTeX textcomp package</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+# A map to avoid TeX ligatures or character replacements in PDF output</span>
<span class="gi">+# xelatex/lualatex/uplatex are handled differently (#5790, #6888)</span>
<span class="gi">+ascii_tex_replacements = [</span>
<span class="gi">+    # Note: the &quot; renders curly in OT1 encoding but straight in T1, T2A, LY1...</span>
<span class="gi">+    #       escaping it to \textquotedbl would break documents using OT1</span>
<span class="gi">+    #       Sphinx does \shorthandoff{&quot;} to avoid problems with some languages</span>
<span class="gi">+    # There is no \text... LaTeX escape for the hyphen character -</span>
<span class="gi">+    (&#39;-&#39;, r&#39;\sphinxhyphen{}&#39;),  # -- and --- are TeX ligatures</span>
<span class="gi">+    # ,, is a TeX ligature in T1 encoding, but escaping the comma adds</span>
<span class="gi">+    # complications (whether by {}, or a macro) and is not done</span>
<span class="gi">+    # the next two require textcomp package</span>
<span class="gi">+    (&quot;&#39;&quot;, r&#39;\textquotesingle{}&#39;),  # else &#39; renders curly, and &#39;&#39; is a ligature</span>
<span class="gi">+    (&#39;`&#39;, r&#39;\textasciigrave{}&#39;),   # else \` and \`\` render curly</span>
<span class="gi">+    (&#39;&lt;&#39;, r&#39;\textless{}&#39;),     # &lt; is inv. exclam in OT1, &lt;&lt; is a T1-ligature</span>
<span class="gi">+    (&#39;&gt;&#39;, r&#39;\textgreater{}&#39;),  # &gt; is inv. quest. mark in 0T1, &gt;&gt; a T1-ligature</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+# A map Unicode characters to LaTeX representation</span>
<span class="gi">+# (for LaTeX engines which don&#39;t support unicode)</span>
<span class="gi">+unicode_tex_replacements = [</span>
<span class="gi">+    # map some more common Unicode characters to TeX commands</span>
<span class="gi">+    (&#39;&#39;, r&#39;\P{}&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\S{}&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\texteuro{}&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\infty\)&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\pm\)&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\rightarrow\)&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\rightarrow\)&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\textendash{}&#39;),</span>
<span class="gi">+    # superscript</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\sp{\text{0}}\)&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\sp{\text{1}}\)&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\sp{\text{2}}\)&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\sp{\text{3}}\)&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\sp{\text{4}}\)&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\sp{\text{5}}\)&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\sp{\text{6}}\)&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\sp{\text{7}}\)&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\sp{\text{8}}\)&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\sp{\text{9}}\)&#39;),</span>
<span class="gi">+    # subscript</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\sb{\text{0}}\)&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\sb{\text{1}}\)&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\sb{\text{2}}\)&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\sb{\text{3}}\)&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\sb{\text{4}}\)&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\sb{\text{5}}\)&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\sb{\text{6}}\)&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\sb{\text{7}}\)&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\sb{\text{8}}\)&#39;),</span>
<span class="gi">+    (&#39;&#39;, r&#39;\(\sb{\text{9}}\)&#39;),</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="gi">+# TODO: this should be called tex_idescape_map because its only use is in</span>
<span class="gi">+#       sphinx.writers.latex.LaTeXTranslator.idescape()</span>
<span class="gi">+# %, {, }, \, #, and ~ are the only ones which must be replaced by _ character</span>
<span class="gi">+# It would be simpler to define it entirely here rather than in init().</span>
<span class="gi">+# Unicode replacements are superfluous, as idescape() uses backslashreplace</span>
<span class="w"> </span>tex_replace_map: dict[int, str] = {}
<span class="gi">+</span>
<span class="w"> </span>_tex_escape_map: dict[int, str] = {}
<span class="w"> </span>_tex_escape_map_without_unicode: dict[int, str] = {}
<span class="w"> </span>_tex_hlescape_map: dict[int, str] = {}
<span class="w"> </span>_tex_hlescape_map_without_unicode: dict[int, str] = {}


<span class="gd">-def escape(s: str, latex_engine: (str | None)=None) -&gt;str:</span>
<span class="gi">+def escape(s: str, latex_engine: str | None = None) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Escape text for LaTeX output.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if latex_engine in (&#39;lualatex&#39;, &#39;xelatex&#39;):</span>
<span class="gi">+        # unicode based LaTeX engine</span>
<span class="gi">+        return s.translate(_tex_escape_map_without_unicode)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return s.translate(_tex_escape_map)</span>


<span class="gd">-def hlescape(s: str, latex_engine: (str | None)=None) -&gt;str:</span>
<span class="gi">+def hlescape(s: str, latex_engine: str | None = None) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Escape text for LaTeX highlighter.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if latex_engine in (&#39;lualatex&#39;, &#39;xelatex&#39;):</span>
<span class="gi">+        # unicode based LaTeX engine</span>
<span class="gi">+        return s.translate(_tex_hlescape_map_without_unicode)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return s.translate(_tex_hlescape_map)</span>


<span class="gd">-def escape_abbr(text: str) -&gt;str:</span>
<span class="gi">+def escape_abbr(text: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Adjust spacing after abbreviations. Works with @ letter or other.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return re.sub(r&#39;\.(?=\s|$)&#39;, r&#39;.\@{}&#39;, text)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def init() -&gt; None:</span>
<span class="gi">+    for a, b in tex_replacements:</span>
<span class="gi">+        _tex_escape_map[ord(a)] = b</span>
<span class="gi">+        _tex_escape_map_without_unicode[ord(a)] = b</span>
<span class="gi">+        tex_replace_map[ord(a)] = &#39;_&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # no reason to do this for _tex_escape_map_without_unicode</span>
<span class="gi">+    for a, b in ascii_tex_replacements:</span>
<span class="gi">+        _tex_escape_map[ord(a)] = b</span>
<span class="gi">+</span>
<span class="gi">+    # but the hyphen has a specific PDF bookmark problem</span>
<span class="gi">+    # https://github.com/latex3/hyperref/issues/112</span>
<span class="gi">+    _tex_escape_map_without_unicode[ord(&#39;-&#39;)] = r&#39;\sphinxhyphen{}&#39;</span>
<span class="gi">+</span>
<span class="gi">+    for a, b in unicode_tex_replacements:</span>
<span class="gi">+        _tex_escape_map[ord(a)] = b</span>
<span class="gi">+        #  This is actually unneeded:</span>
<span class="gi">+        tex_replace_map[ord(a)] = &#39;_&#39;</span>
<span class="gi">+</span>
<span class="gi">+    for a, b in tex_replacements:</span>
<span class="gi">+        if a in &#39;[]{}\\&#39;:</span>
<span class="gi">+            continue</span>
<span class="gi">+        _tex_hlescape_map[ord(a)] = b</span>
<span class="gi">+        _tex_hlescape_map_without_unicode[ord(a)] = b</span>
<span class="gi">+</span>
<span class="gi">+    for a, b in unicode_tex_replacements:</span>
<span class="gi">+        _tex_hlescape_map[ord(a)] = b</span>
<span class="gh">diff --git a/sphinx/util/typing.py b/sphinx/util/typing.py</span>
<span class="gh">index e0151d793..dbad5457c 100644</span>
<span class="gd">--- a/sphinx/util/typing.py</span>
<span class="gi">+++ b/sphinx/util/typing.py</span>
<span class="gu">@@ -1,5 +1,7 @@</span>
<span class="w"> </span>&quot;&quot;&quot;The composite types for Sphinx.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import dataclasses
<span class="w"> </span>import sys
<span class="w"> </span>import types
<span class="gu">@@ -7,71 +9,130 @@ import typing</span>
<span class="w"> </span>from collections.abc import Callable, Sequence
<span class="w"> </span>from contextvars import Context, ContextVar, Token
<span class="w"> </span>from struct import Struct
<span class="gd">-from typing import TYPE_CHECKING, Annotated, Any, ForwardRef, NewType, TypedDict, TypeVar, Union</span>
<span class="gi">+from typing import (</span>
<span class="gi">+    TYPE_CHECKING,</span>
<span class="gi">+    Annotated,</span>
<span class="gi">+    Any,</span>
<span class="gi">+    ForwardRef,</span>
<span class="gi">+    NewType,</span>
<span class="gi">+    TypedDict,</span>
<span class="gi">+    TypeVar,</span>
<span class="gi">+    Union,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.parsers.rst.states import Inliner
<span class="gi">+</span>
<span class="w"> </span>from sphinx.util import logging
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Mapping
<span class="w"> </span>    from typing import Final, Literal, Protocol, TypeAlias
<span class="gi">+</span>
<span class="w"> </span>    from typing_extensions import TypeIs
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="gd">-    _RestifyMode: TypeAlias = Literal[&#39;fully-qualified-except-typing&#39;, &#39;smart&#39;]</span>
<span class="gd">-    _StringifyMode: TypeAlias = Literal[&#39;fully-qualified-except-typing&#39;,</span>
<span class="gd">-        &#39;fully-qualified&#39;, &#39;smart&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    _RestifyMode: TypeAlias = Literal[</span>
<span class="gi">+        &#39;fully-qualified-except-typing&#39;,</span>
<span class="gi">+        &#39;smart&#39;,</span>
<span class="gi">+    ]</span>
<span class="gi">+    _StringifyMode: TypeAlias = Literal[</span>
<span class="gi">+        &#39;fully-qualified-except-typing&#39;,</span>
<span class="gi">+        &#39;fully-qualified&#39;,</span>
<span class="gi">+        &#39;smart&#39;,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gd">-_INVALID_BUILTIN_CLASSES: Final[Mapping[object, str]] = {Context:</span>
<span class="gd">-    &#39;contextvars.Context&#39;, ContextVar: &#39;contextvars.ContextVar&#39;, Token:</span>
<span class="gd">-    &#39;contextvars.Token&#39;, Struct: &#39;struct.Struct&#39;, types.AsyncGeneratorType:</span>
<span class="gd">-    &#39;types.AsyncGeneratorType&#39;, types.BuiltinFunctionType:</span>
<span class="gd">-    &#39;types.BuiltinFunctionType&#39;, types.BuiltinMethodType:</span>
<span class="gd">-    &#39;types.BuiltinMethodType&#39;, types.CellType: &#39;types.CellType&#39;, types.</span>
<span class="gd">-    ClassMethodDescriptorType: &#39;types.ClassMethodDescriptorType&#39;, types.</span>
<span class="gd">-    CodeType: &#39;types.CodeType&#39;, types.CoroutineType: &#39;types.CoroutineType&#39;,</span>
<span class="gd">-    types.FrameType: &#39;types.FrameType&#39;, types.FunctionType:</span>
<span class="gd">-    &#39;types.FunctionType&#39;, types.GeneratorType: &#39;types.GeneratorType&#39;, types</span>
<span class="gd">-    .GetSetDescriptorType: &#39;types.GetSetDescriptorType&#39;, types.LambdaType:</span>
<span class="gd">-    &#39;types.LambdaType&#39;, types.MappingProxyType: &#39;types.MappingProxyType&#39;,</span>
<span class="gd">-    types.MemberDescriptorType: &#39;types.MemberDescriptorType&#39;, types.</span>
<span class="gd">-    MethodDescriptorType: &#39;types.MethodDescriptorType&#39;, types.MethodType:</span>
<span class="gd">-    &#39;types.MethodType&#39;, types.MethodWrapperType: &#39;types.MethodWrapperType&#39;,</span>
<span class="gd">-    types.ModuleType: &#39;types.ModuleType&#39;, types.TracebackType:</span>
<span class="gd">-    &#39;types.TracebackType&#39;, types.WrapperDescriptorType:</span>
<span class="gd">-    &#39;types.WrapperDescriptorType&#39;}</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def is_invalid_builtin_class(obj: Any) -&gt;bool:</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# classes that have an incorrect .__module__ attribute</span>
<span class="gi">+_INVALID_BUILTIN_CLASSES: Final[Mapping[object, str]] = {</span>
<span class="gi">+    Context: &#39;contextvars.Context&#39;,  # Context.__module__ == &#39;_contextvars&#39;</span>
<span class="gi">+    ContextVar: &#39;contextvars.ContextVar&#39;,  # ContextVar.__module__ == &#39;_contextvars&#39;</span>
<span class="gi">+    Token: &#39;contextvars.Token&#39;,  # Token.__module__ == &#39;_contextvars&#39;</span>
<span class="gi">+    Struct: &#39;struct.Struct&#39;,  # Struct.__module__ == &#39;_struct&#39;</span>
<span class="gi">+    # types in &#39;types&#39; with &lt;type&gt;.__module__ == &#39;builtins&#39;:</span>
<span class="gi">+    types.AsyncGeneratorType: &#39;types.AsyncGeneratorType&#39;,</span>
<span class="gi">+    types.BuiltinFunctionType: &#39;types.BuiltinFunctionType&#39;,</span>
<span class="gi">+    types.BuiltinMethodType: &#39;types.BuiltinMethodType&#39;,</span>
<span class="gi">+    types.CellType: &#39;types.CellType&#39;,</span>
<span class="gi">+    types.ClassMethodDescriptorType: &#39;types.ClassMethodDescriptorType&#39;,</span>
<span class="gi">+    types.CodeType: &#39;types.CodeType&#39;,</span>
<span class="gi">+    types.CoroutineType: &#39;types.CoroutineType&#39;,</span>
<span class="gi">+    types.FrameType: &#39;types.FrameType&#39;,</span>
<span class="gi">+    types.FunctionType: &#39;types.FunctionType&#39;,</span>
<span class="gi">+    types.GeneratorType: &#39;types.GeneratorType&#39;,</span>
<span class="gi">+    types.GetSetDescriptorType: &#39;types.GetSetDescriptorType&#39;,</span>
<span class="gi">+    types.LambdaType: &#39;types.LambdaType&#39;,</span>
<span class="gi">+    types.MappingProxyType: &#39;types.MappingProxyType&#39;,</span>
<span class="gi">+    types.MemberDescriptorType: &#39;types.MemberDescriptorType&#39;,</span>
<span class="gi">+    types.MethodDescriptorType: &#39;types.MethodDescriptorType&#39;,</span>
<span class="gi">+    types.MethodType: &#39;types.MethodType&#39;,</span>
<span class="gi">+    types.MethodWrapperType: &#39;types.MethodWrapperType&#39;,</span>
<span class="gi">+    types.ModuleType: &#39;types.ModuleType&#39;,</span>
<span class="gi">+    types.TracebackType: &#39;types.TracebackType&#39;,</span>
<span class="gi">+    types.WrapperDescriptorType: &#39;types.WrapperDescriptorType&#39;,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_invalid_builtin_class(obj: Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check *obj* is an invalid built-in class.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return obj in _INVALID_BUILTIN_CLASSES</span>
<span class="gi">+    except TypeError:  # unhashable type</span>
<span class="gi">+        return False</span>


<span class="gi">+# Text like nodes which are initialized with text and rawsource</span>
<span class="w"> </span>TextlikeNode: TypeAlias = nodes.Text | nodes.TextElement
<span class="gd">-PathMatcher: TypeAlias = Callable[[str], bool]</span>
<span class="gd">-if TYPE_CHECKING:</span>

<span class="gi">+# path matcher</span>
<span class="gi">+PathMatcher: TypeAlias = Callable[[str], bool]</span>

<span class="gi">+# common role functions</span>
<span class="gi">+if TYPE_CHECKING:</span>
<span class="w"> </span>    class RoleFunction(Protocol):
<span class="gd">-</span>
<span class="gd">-        def __call__(self, name: str, rawtext: str, text: str, lineno: int,</span>
<span class="gd">-            inliner: Inliner, /, options: (dict[str, Any] | None)=None,</span>
<span class="gd">-            content: Sequence[str]=()) -&gt;tuple[list[nodes.Node], list[nodes</span>
<span class="gd">-            .system_message]]:</span>
<span class="gi">+        def __call__(</span>
<span class="gi">+            self,</span>
<span class="gi">+            name: str,</span>
<span class="gi">+            rawtext: str,</span>
<span class="gi">+            text: str,</span>
<span class="gi">+            lineno: int,</span>
<span class="gi">+            inliner: Inliner,</span>
<span class="gi">+            /,</span>
<span class="gi">+            options: dict[str, Any] | None = None,</span>
<span class="gi">+            content: Sequence[str] = (),</span>
<span class="gi">+        ) -&gt; tuple[list[nodes.Node], list[nodes.system_message]]:</span>
<span class="w"> </span>            ...
<span class="w"> </span>else:
<span class="gd">-    RoleFunction: TypeAlias = Callable[[str, str, str, int, Inliner, dict[</span>
<span class="gd">-        str, Any], Sequence[str]], tuple[list[nodes.Node], list[nodes.</span>
<span class="gd">-        system_message]]]</span>
<span class="gi">+    RoleFunction: TypeAlias = Callable[</span>
<span class="gi">+        [str, str, str, int, Inliner, dict[str, Any], Sequence[str]],</span>
<span class="gi">+        tuple[list[nodes.Node], list[nodes.system_message]],</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+# A option spec for directive</span>
<span class="w"> </span>OptionSpec: TypeAlias = dict[str, Callable[[str], Any]]
<span class="gi">+</span>
<span class="gi">+# title getter functions for enumerable nodes (see sphinx.domains.std)</span>
<span class="w"> </span>TitleGetter: TypeAlias = Callable[[nodes.Node], str]
<span class="gd">-InventoryItem: TypeAlias = tuple[str, str, str, str]</span>
<span class="gi">+</span>
<span class="gi">+# inventory data on memory</span>
<span class="gi">+InventoryItem: TypeAlias = tuple[</span>
<span class="gi">+    str,  # project name</span>
<span class="gi">+    str,  # project version</span>
<span class="gi">+    str,  # URL</span>
<span class="gi">+    str,  # display name</span>
<span class="gi">+]</span>
<span class="w"> </span>Inventory: TypeAlias = dict[str, dict[str, InventoryItem]]


<span class="gd">-class ExtensionMetadata(TypedDict, total=(False)):</span>
<span class="gi">+class ExtensionMetadata(TypedDict, total=False):</span>
<span class="w"> </span>    &quot;&quot;&quot;The metadata returned by an extension&#39;s ``setup()`` function.

<span class="w"> </span>    See :ref:`ext-metadata`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    version: str
<span class="w"> </span>    &quot;&quot;&quot;The extension version (default: ``&#39;unknown version&#39;``).&quot;&quot;&quot;
<span class="w"> </span>    env_version: int
<span class="gu">@@ -90,35 +151,65 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>    _ExtensionSetupFunc: TypeAlias = Callable[[Sphinx], ExtensionMetadata]


<span class="gd">-def get_type_hints(obj: Any, globalns: (dict[str, Any] | None)=None,</span>
<span class="gd">-    localns: (dict[str, Any] | None)=None, include_extras: bool=False) -&gt;dict[</span>
<span class="gd">-    str, Any]:</span>
<span class="gi">+def get_type_hints(</span>
<span class="gi">+    obj: Any,</span>
<span class="gi">+    globalns: dict[str, Any] | None = None,</span>
<span class="gi">+    localns: dict[str, Any] | None = None,</span>
<span class="gi">+    include_extras: bool = False,</span>
<span class="gi">+) -&gt; dict[str, Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a dictionary containing type hints for a function, method, module or class
<span class="w"> </span>    object.

<span class="w"> </span>    This is a simple wrapper of `typing.get_type_hints()` that does not raise an error on
<span class="w"> </span>    runtime.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def is_system_TypeVar(typ: Any) -&gt;bool:</span>
<span class="gi">+    from sphinx.util.inspect import safe_getattr  # lazy loading</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return typing.get_type_hints(obj, globalns, localns, include_extras=include_extras)</span>
<span class="gi">+    except NameError:</span>
<span class="gi">+        # Failed to evaluate ForwardRef (maybe TYPE_CHECKING)</span>
<span class="gi">+        return safe_getattr(obj, &#39;__annotations__&#39;, {})</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        # Failed to evaluate ForwardRef (maybe not runtime checkable)</span>
<span class="gi">+        return safe_getattr(obj, &#39;__annotations__&#39;, {})</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        # Invalid object is given. But try to get __annotations__ as a fallback.</span>
<span class="gi">+        return safe_getattr(obj, &#39;__annotations__&#39;, {})</span>
<span class="gi">+    except KeyError:</span>
<span class="gi">+        # a broken class found (refs: https://github.com/sphinx-doc/sphinx/issues/8084)</span>
<span class="gi">+        return {}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def is_system_TypeVar(typ: Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check *typ* is system defined TypeVar.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    modname = getattr(typ, &#39;__module__&#39;, &#39;&#39;)</span>
<span class="gi">+    return modname == &#39;typing&#39; and isinstance(typ, TypeVar)</span>


<span class="gd">-def _is_annotated_form(obj: Any) -&gt;TypeIs[Annotated[Any, ...]]:</span>
<span class="gi">+def _is_annotated_form(obj: Any) -&gt; TypeIs[Annotated[Any, ...]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if *obj* is an annotated type.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return typing.get_origin(obj) is Annotated or str(obj).startswith(&#39;typing.Annotated&#39;)</span>


<span class="gd">-def _is_unpack_form(obj: Any) -&gt;bool:</span>
<span class="gi">+def _is_unpack_form(obj: Any) -&gt; bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;Check if the object is :class:`typing.Unpack` or equivalent.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if sys.version_info &gt;= (3, 11):</span>
<span class="gi">+        from typing import Unpack</span>
<span class="gi">+</span>
<span class="gi">+        # typing_extensions.Unpack != typing.Unpack for 3.11, but we assume</span>
<span class="gi">+        # that typing_extensions.Unpack should not be used in that case</span>
<span class="gi">+        return typing.get_origin(obj) is Unpack</span>
<span class="gi">+</span>
<span class="gi">+    # Python 3.10 requires typing_extensions.Unpack</span>
<span class="gi">+    origin = typing.get_origin(obj)</span>
<span class="gi">+    return (</span>
<span class="gi">+        getattr(origin, &#39;__module__&#39;, None) == &#39;typing_extensions&#39;</span>
<span class="gi">+        and origin.__name__ == &#39;Unpack&#39;</span>
<span class="gi">+    )</span>


<span class="gd">-def restify(cls: Any, mode: _RestifyMode=&#39;fully-qualified-except-typing&#39;</span>
<span class="gd">-    ) -&gt;str:</span>
<span class="gi">+def restify(cls: Any, mode: _RestifyMode = &#39;fully-qualified-except-typing&#39;) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert a type-like object to a reST reference.

<span class="w"> </span>    :param mode: Specify a method how annotations will be stringified.
<span class="gu">@@ -129,11 +220,149 @@ def restify(cls: Any, mode: _RestifyMode=&#39;fully-qualified-except-typing&#39;</span>
<span class="w"> </span>                 &#39;smart&#39;
<span class="w"> </span>                     Show the name of the annotation.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def stringify_annotation(annotation: Any, /, mode: _StringifyMode=</span>
<span class="gd">-    &#39;fully-qualified-except-typing&#39;) -&gt;str:</span>
<span class="gi">+    from sphinx.ext.autodoc.mock import ismock, ismockmodule  # lazy loading</span>
<span class="gi">+    from sphinx.util.inspect import isgenericalias, object_description  # lazy loading</span>
<span class="gi">+</span>
<span class="gi">+    valid_modes = {&#39;fully-qualified-except-typing&#39;, &#39;smart&#39;}</span>
<span class="gi">+    if mode not in valid_modes:</span>
<span class="gi">+        valid = &#39;, &#39;.join(map(repr, sorted(valid_modes)))</span>
<span class="gi">+        msg = f&#39;mode must be one of {valid}; got {mode!r}&#39;</span>
<span class="gi">+        raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    # things that are not types</span>
<span class="gi">+    if cls is None or cls == types.NoneType:</span>
<span class="gi">+        return &#39;:py:obj:`None`&#39;</span>
<span class="gi">+    if cls is Ellipsis:</span>
<span class="gi">+        return &#39;...&#39;</span>
<span class="gi">+    if isinstance(cls, str):</span>
<span class="gi">+        return cls</span>
<span class="gi">+</span>
<span class="gi">+    cls_module_is_typing = getattr(cls, &#39;__module__&#39;, &#39;&#39;) == &#39;typing&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # If the mode is &#39;smart&#39;, we always use &#39;~&#39;.</span>
<span class="gi">+    # If the mode is &#39;fully-qualified-except-typing&#39;,</span>
<span class="gi">+    # we use &#39;~&#39; only for the objects in the ``typing`` module.</span>
<span class="gi">+    module_prefix = &#39;~&#39; if mode == &#39;smart&#39; or cls_module_is_typing else &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        if ismockmodule(cls):</span>
<span class="gi">+            return f&#39;:py:class:`{module_prefix}{cls.__name__}`&#39;</span>
<span class="gi">+        elif ismock(cls):</span>
<span class="gi">+            return f&#39;:py:class:`{module_prefix}{cls.__module__}.{cls.__name__}`&#39;</span>
<span class="gi">+        elif is_invalid_builtin_class(cls):</span>
<span class="gi">+            # The above predicate never raises TypeError but should not be</span>
<span class="gi">+            # evaluated before determining whether *cls* is a mocked object</span>
<span class="gi">+            # or not; instead of two try-except blocks, we keep it here.</span>
<span class="gi">+            return f&#39;:py:class:`{module_prefix}{_INVALID_BUILTIN_CLASSES[cls]}`&#39;</span>
<span class="gi">+        elif _is_annotated_form(cls):</span>
<span class="gi">+            args = restify(cls.__args__[0], mode)</span>
<span class="gi">+            meta_args = []</span>
<span class="gi">+            for m in cls.__metadata__:</span>
<span class="gi">+                if isinstance(m, type):</span>
<span class="gi">+                    meta_args.append(restify(m, mode))</span>
<span class="gi">+                elif dataclasses.is_dataclass(m):</span>
<span class="gi">+                    # use restify for the repr of field values rather than repr</span>
<span class="gi">+                    d_fields = &#39;, &#39;.join([</span>
<span class="gi">+                        fr&quot;{f.name}=\ {restify(getattr(m, f.name), mode)}&quot;</span>
<span class="gi">+                        for f in dataclasses.fields(m) if f.repr</span>
<span class="gi">+                    ])</span>
<span class="gi">+                    meta_args.append(fr&#39;{restify(type(m), mode)}\ ({d_fields})&#39;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    meta_args.append(repr(m))</span>
<span class="gi">+            meta = &#39;, &#39;.join(meta_args)</span>
<span class="gi">+            if sys.version_info[:2] &lt;= (3, 11):</span>
<span class="gi">+                # Hardcoded to fix errors on Python 3.11 and earlier.</span>
<span class="gi">+                return fr&#39;:py:class:`~typing.Annotated`\ [{args}, {meta}]&#39;</span>
<span class="gi">+            return (f&#39;:py:class:`{module_prefix}{cls.__module__}.{cls.__name__}`&#39;</span>
<span class="gi">+                    fr&#39;\ [{args}, {meta}]&#39;)</span>
<span class="gi">+        elif isinstance(cls, NewType):</span>
<span class="gi">+            return f&#39;:py:class:`{module_prefix}{cls.__module__}.{cls.__name__}`&#39;  # type: ignore[attr-defined]</span>
<span class="gi">+        elif isinstance(cls, types.UnionType):</span>
<span class="gi">+            # Union types (PEP 585) retain their definition order when they</span>
<span class="gi">+            # are printed natively and ``None``-like types are kept as is.</span>
<span class="gi">+            return &#39; | &#39;.join(restify(a, mode) for a in cls.__args__)</span>
<span class="gi">+        elif cls.__module__ in (&#39;__builtin__&#39;, &#39;builtins&#39;):</span>
<span class="gi">+            if hasattr(cls, &#39;__args__&#39;):</span>
<span class="gi">+                if not cls.__args__:  # Empty tuple, list, ...</span>
<span class="gi">+                    return fr&#39;:py:class:`{cls.__name__}`\ [{cls.__args__!r}]&#39;</span>
<span class="gi">+</span>
<span class="gi">+                concatenated_args = &#39;, &#39;.join(restify(arg, mode) for arg in cls.__args__)</span>
<span class="gi">+                return fr&#39;:py:class:`{cls.__name__}`\ [{concatenated_args}]&#39;</span>
<span class="gi">+            return f&#39;:py:class:`{cls.__name__}`&#39;</span>
<span class="gi">+        elif (isgenericalias(cls)</span>
<span class="gi">+              and cls_module_is_typing</span>
<span class="gi">+              and cls.__origin__ is Union):</span>
<span class="gi">+            # *cls* is defined in ``typing``, and thus ``__args__`` must exist</span>
<span class="gi">+            return &#39; | &#39;.join(restify(a, mode) for a in cls.__args__)</span>
<span class="gi">+        elif isgenericalias(cls):</span>
<span class="gi">+            if isinstance(cls.__origin__, typing._SpecialForm):</span>
<span class="gi">+                # ClassVar; Concatenate; Final; Literal; Unpack; TypeGuard; TypeIs</span>
<span class="gi">+                # Required/NotRequired</span>
<span class="gi">+                text = restify(cls.__origin__, mode)</span>
<span class="gi">+            elif cls.__name__:</span>
<span class="gi">+                text = f&#39;:py:class:`{module_prefix}{cls.__module__}.{cls.__name__}`&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                text = restify(cls.__origin__, mode)</span>
<span class="gi">+</span>
<span class="gi">+            __args__ = getattr(cls, &#39;__args__&#39;, ())</span>
<span class="gi">+            if not __args__:</span>
<span class="gi">+                return text</span>
<span class="gi">+            if all(map(is_system_TypeVar, __args__)):</span>
<span class="gi">+                # Don&#39;t print the arguments; they&#39;re all system defined type variables.</span>
<span class="gi">+                return text</span>
<span class="gi">+</span>
<span class="gi">+            # Callable has special formatting</span>
<span class="gi">+            if (</span>
<span class="gi">+                (cls_module_is_typing and cls.__name__ == &#39;Callable&#39;)</span>
<span class="gi">+                or (cls.__module__ == &#39;collections.abc&#39; and cls.__name__ == &#39;Callable&#39;)</span>
<span class="gi">+            ):</span>
<span class="gi">+                args = &#39;, &#39;.join(restify(a, mode) for a in __args__[:-1])</span>
<span class="gi">+                returns = restify(__args__[-1], mode)</span>
<span class="gi">+                return fr&#39;{text}\ [[{args}], {returns}]&#39;</span>
<span class="gi">+</span>
<span class="gi">+            if cls_module_is_typing and cls.__origin__.__name__ == &#39;Literal&#39;:</span>
<span class="gi">+                args = &#39;, &#39;.join(_format_literal_arg_restify(a, mode=mode)</span>
<span class="gi">+                                 for a in cls.__args__)</span>
<span class="gi">+                return fr&#39;{text}\ [{args}]&#39;</span>
<span class="gi">+</span>
<span class="gi">+            # generic representation of the parameters</span>
<span class="gi">+            args = &#39;, &#39;.join(restify(a, mode) for a in __args__)</span>
<span class="gi">+            return fr&#39;{text}\ [{args}]&#39;</span>
<span class="gi">+        elif isinstance(cls, typing._SpecialForm):</span>
<span class="gi">+            return f&#39;:py:obj:`~{cls.__module__}.{cls.__name__}`&#39;  # type: ignore[attr-defined]</span>
<span class="gi">+        elif sys.version_info[:2] &gt;= (3, 11) and cls is typing.Any:</span>
<span class="gi">+            # handle bpo-46998</span>
<span class="gi">+            return f&#39;:py:obj:`~{cls.__module__}.{cls.__name__}`&#39;</span>
<span class="gi">+        elif hasattr(cls, &#39;__qualname__&#39;):</span>
<span class="gi">+            return f&#39;:py:class:`{module_prefix}{cls.__module__}.{cls.__qualname__}`&#39;</span>
<span class="gi">+        elif isinstance(cls, ForwardRef):</span>
<span class="gi">+            return f&#39;:py:class:`{cls.__forward_arg__}`&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            # not a class (ex. TypeVar) but should have a __name__</span>
<span class="gi">+            return f&#39;:py:obj:`{module_prefix}{cls.__module__}.{cls.__name__}`&#39;</span>
<span class="gi">+    except (AttributeError, TypeError) as exc:</span>
<span class="gi">+        logger.debug(&#39;restify on %r in mode %r failed: %r&#39;, cls, mode, exc)</span>
<span class="gi">+        return object_description(cls)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _format_literal_arg_restify(arg: Any, /, *, mode: str) -&gt; str:</span>
<span class="gi">+    from sphinx.util.inspect import isenumattribute  # lazy loading</span>
<span class="gi">+</span>
<span class="gi">+    if isenumattribute(arg):</span>
<span class="gi">+        enum_cls = arg.__class__</span>
<span class="gi">+        if mode == &#39;smart&#39; or enum_cls.__module__ == &#39;typing&#39;:</span>
<span class="gi">+            # MyEnum.member</span>
<span class="gi">+            return f&#39;:py:attr:`~{enum_cls.__module__}.{enum_cls.__qualname__}.{arg.name}`&#39;</span>
<span class="gi">+        # module.MyEnum.member</span>
<span class="gi">+        return f&#39;:py:attr:`{enum_cls.__module__}.{enum_cls.__qualname__}.{arg.name}`&#39;</span>
<span class="gi">+    return repr(arg)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def stringify_annotation(</span>
<span class="gi">+    annotation: Any,</span>
<span class="gi">+    /,</span>
<span class="gi">+    mode: _StringifyMode = &#39;fully-qualified-except-typing&#39;,</span>
<span class="gi">+) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Stringify type annotation object.

<span class="w"> </span>    :param annotation: The annotation to stringified.
<span class="gu">@@ -147,17 +376,185 @@ def stringify_annotation(annotation: Any, /, mode: _StringifyMode=</span>
<span class="w"> </span>                 &#39;fully-qualified&#39;
<span class="w"> </span>                     Show the module name and qualified name of the annotation.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-_DEPRECATED_OBJECTS: dict[str, tuple[Any, str, tuple[int, int]]] = {}</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def __getattr__(name: str) -&gt;Any:</span>
<span class="gi">+    from sphinx.ext.autodoc.mock import ismock, ismockmodule  # lazy loading</span>
<span class="gi">+</span>
<span class="gi">+    valid_modes = {&#39;fully-qualified-except-typing&#39;, &#39;fully-qualified&#39;, &#39;smart&#39;}</span>
<span class="gi">+    if mode not in valid_modes:</span>
<span class="gi">+        valid = &#39;, &#39;.join(map(repr, sorted(valid_modes)))</span>
<span class="gi">+        msg = f&#39;mode must be one of {valid}; got {mode!r}&#39;</span>
<span class="gi">+        raise ValueError(msg)</span>
<span class="gi">+</span>
<span class="gi">+    # things that are not types</span>
<span class="gi">+    if annotation is None or annotation == types.NoneType:</span>
<span class="gi">+        return &#39;None&#39;</span>
<span class="gi">+    if annotation is Ellipsis:</span>
<span class="gi">+        return &#39;...&#39;</span>
<span class="gi">+    if isinstance(annotation, str):</span>
<span class="gi">+        if annotation.startswith(&quot;&#39;&quot;) and annotation.endswith(&quot;&#39;&quot;):</span>
<span class="gi">+            # Might be a double Forward-ref&#39;ed type.  Go unquoting.</span>
<span class="gi">+            return annotation[1:-1]</span>
<span class="gi">+        return annotation</span>
<span class="gi">+    if not annotation:</span>
<span class="gi">+        return repr(annotation)</span>
<span class="gi">+</span>
<span class="gi">+    module_prefix = &#39;~&#39; if mode == &#39;smart&#39; else &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # The values below must be strings if the objects are well-formed.</span>
<span class="gi">+    annotation_qualname: str = getattr(annotation, &#39;__qualname__&#39;, &#39;&#39;)</span>
<span class="gi">+    annotation_module: str = getattr(annotation, &#39;__module__&#39;, &#39;&#39;)</span>
<span class="gi">+    annotation_name: str = getattr(annotation, &#39;__name__&#39;, &#39;&#39;)</span>
<span class="gi">+    annotation_module_is_typing = annotation_module == &#39;typing&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # Extract the annotation&#39;s base type by considering formattable cases</span>
<span class="gi">+    if isinstance(annotation, TypeVar) and not _is_unpack_form(annotation):</span>
<span class="gi">+        # typing_extensions.Unpack is incorrectly determined as a TypeVar</span>
<span class="gi">+        if annotation_module_is_typing and mode in {&#39;fully-qualified-except-typing&#39;, &#39;smart&#39;}:</span>
<span class="gi">+            return annotation_name</span>
<span class="gi">+        return module_prefix + f&#39;{annotation_module}.{annotation_name}&#39;</span>
<span class="gi">+    elif isinstance(annotation, NewType):</span>
<span class="gi">+        return module_prefix + f&#39;{annotation_module}.{annotation_name}&#39;</span>
<span class="gi">+    elif ismockmodule(annotation):</span>
<span class="gi">+        return module_prefix + annotation_name</span>
<span class="gi">+    elif ismock(annotation):</span>
<span class="gi">+        return module_prefix + f&#39;{annotation_module}.{annotation_name}&#39;</span>
<span class="gi">+    elif is_invalid_builtin_class(annotation):</span>
<span class="gi">+        return module_prefix + _INVALID_BUILTIN_CLASSES[annotation]</span>
<span class="gi">+    elif _is_annotated_form(annotation):  # for py310+</span>
<span class="gi">+        pass</span>
<span class="gi">+    elif annotation_module == &#39;builtins&#39; and annotation_qualname:</span>
<span class="gi">+        args = getattr(annotation, &#39;__args__&#39;, None)</span>
<span class="gi">+        if args is None:</span>
<span class="gi">+            return annotation_qualname</span>
<span class="gi">+</span>
<span class="gi">+        # PEP 585 generic</span>
<span class="gi">+        if not args:  # Empty tuple, list, ...</span>
<span class="gi">+            return repr(annotation)</span>
<span class="gi">+</span>
<span class="gi">+        concatenated_args = &#39;, &#39;.join(stringify_annotation(arg, mode) for arg in args)</span>
<span class="gi">+        return f&#39;{annotation_qualname}[{concatenated_args}]&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        # add other special cases that can be directly formatted</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    module_prefix = f&#39;{annotation_module}.&#39;</span>
<span class="gi">+    annotation_forward_arg: str | None = getattr(annotation, &#39;__forward_arg__&#39;, None)</span>
<span class="gi">+    if annotation_qualname or (annotation_module_is_typing and not annotation_forward_arg):</span>
<span class="gi">+        if mode == &#39;smart&#39;:</span>
<span class="gi">+            module_prefix = f&#39;~{module_prefix}&#39;</span>
<span class="gi">+        if annotation_module_is_typing and mode == &#39;fully-qualified-except-typing&#39;:</span>
<span class="gi">+            module_prefix = &#39;&#39;</span>
<span class="gi">+    elif _is_unpack_form(annotation) and annotation_module == &#39;typing_extensions&#39;:</span>
<span class="gi">+        module_prefix = &#39;~&#39; if mode == &#39;smart&#39; else &#39;&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        module_prefix = &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    if annotation_module_is_typing:</span>
<span class="gi">+        if annotation_forward_arg:</span>
<span class="gi">+            # handle ForwardRefs</span>
<span class="gi">+            qualname = annotation_forward_arg</span>
<span class="gi">+        else:</span>
<span class="gi">+            if annotation_name:</span>
<span class="gi">+                qualname = annotation_name</span>
<span class="gi">+            elif annotation_qualname:</span>
<span class="gi">+                qualname = annotation_qualname</span>
<span class="gi">+            else:</span>
<span class="gi">+                # in this case, we know that the annotation is a member</span>
<span class="gi">+                # of ``typing`` and all of them define ``__origin__``</span>
<span class="gi">+                qualname = stringify_annotation(</span>
<span class="gi">+                    annotation.__origin__, &#39;fully-qualified-except-typing&#39;,</span>
<span class="gi">+                ).replace(&#39;typing.&#39;, &#39;&#39;)  # ex. Union</span>
<span class="gi">+    elif annotation_qualname:</span>
<span class="gi">+        qualname = annotation_qualname</span>
<span class="gi">+    elif hasattr(annotation, &#39;__origin__&#39;):</span>
<span class="gi">+        # instantiated generic provided by a user</span>
<span class="gi">+        qualname = stringify_annotation(annotation.__origin__, mode)</span>
<span class="gi">+    elif isinstance(annotation, types.UnionType):</span>
<span class="gi">+        qualname = &#39;types.UnionType&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        # we weren&#39;t able to extract the base type, appending arguments would</span>
<span class="gi">+        # only make them appear twice</span>
<span class="gi">+        return repr(annotation)</span>
<span class="gi">+</span>
<span class="gi">+    # Process the generic arguments (if any).</span>
<span class="gi">+    # They must be a list or a tuple, otherwise they are considered &#39;broken&#39;.</span>
<span class="gi">+    annotation_args = getattr(annotation, &#39;__args__&#39;, ())</span>
<span class="gi">+    if annotation_args and isinstance(annotation_args, list | tuple):</span>
<span class="gi">+        if (</span>
<span class="gi">+            qualname in {&#39;Union&#39;, &#39;types.UnionType&#39;}</span>
<span class="gi">+            and all(getattr(a, &#39;__origin__&#39;, ...) is typing.Literal for a in annotation_args)</span>
<span class="gi">+        ):</span>
<span class="gi">+            # special case to flatten a Union of Literals into a literal</span>
<span class="gi">+            flattened_args = typing.Literal[annotation_args].__args__  # type: ignore[attr-defined]</span>
<span class="gi">+            args = &#39;, &#39;.join(_format_literal_arg_stringify(a, mode=mode)</span>
<span class="gi">+                             for a in flattened_args)</span>
<span class="gi">+            return f&#39;{module_prefix}Literal[{args}]&#39;</span>
<span class="gi">+        if qualname in {&#39;Optional&#39;, &#39;Union&#39;, &#39;types.UnionType&#39;}:</span>
<span class="gi">+            return &#39; | &#39;.join(stringify_annotation(a, mode) for a in annotation_args)</span>
<span class="gi">+        elif qualname == &#39;Callable&#39;:</span>
<span class="gi">+            args = &#39;, &#39;.join(stringify_annotation(a, mode) for a in annotation_args[:-1])</span>
<span class="gi">+            returns = stringify_annotation(annotation_args[-1], mode)</span>
<span class="gi">+            return f&#39;{module_prefix}Callable[[{args}], {returns}]&#39;</span>
<span class="gi">+        elif qualname == &#39;Literal&#39;:</span>
<span class="gi">+            args = &#39;, &#39;.join(_format_literal_arg_stringify(a, mode=mode)</span>
<span class="gi">+                             for a in annotation_args)</span>
<span class="gi">+            return f&#39;{module_prefix}Literal[{args}]&#39;</span>
<span class="gi">+        elif _is_annotated_form(annotation):  # for py310+</span>
<span class="gi">+            args = stringify_annotation(annotation_args[0], mode)</span>
<span class="gi">+            meta_args = []</span>
<span class="gi">+            for m in annotation.__metadata__:</span>
<span class="gi">+                if isinstance(m, type):</span>
<span class="gi">+                    meta_args.append(stringify_annotation(m, mode))</span>
<span class="gi">+                elif dataclasses.is_dataclass(m):</span>
<span class="gi">+                    # use stringify_annotation for the repr of field values rather than repr</span>
<span class="gi">+                    d_fields = &#39;, &#39;.join([</span>
<span class="gi">+                        f&quot;{f.name}={stringify_annotation(getattr(m, f.name), mode)}&quot;</span>
<span class="gi">+                        for f in dataclasses.fields(m) if f.repr</span>
<span class="gi">+                    ])</span>
<span class="gi">+                    meta_args.append(f&#39;{stringify_annotation(type(m), mode)}({d_fields})&#39;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    meta_args.append(repr(m))</span>
<span class="gi">+            meta = &#39;, &#39;.join(meta_args)</span>
<span class="gi">+            if sys.version_info[:2] &lt;= (3, 11):</span>
<span class="gi">+                if mode == &#39;fully-qualified-except-typing&#39;:</span>
<span class="gi">+                    return f&#39;Annotated[{args}, {meta}]&#39;</span>
<span class="gi">+                module_prefix = module_prefix.replace(&#39;builtins&#39;, &#39;typing&#39;)</span>
<span class="gi">+                return f&#39;{module_prefix}Annotated[{args}, {meta}]&#39;</span>
<span class="gi">+            return f&#39;{module_prefix}Annotated[{args}, {meta}]&#39;</span>
<span class="gi">+        elif all(is_system_TypeVar(a) for a in annotation_args):</span>
<span class="gi">+            # Suppress arguments if all system defined TypeVars (ex. Dict[KT, VT])</span>
<span class="gi">+            return module_prefix + qualname</span>
<span class="gi">+        else:</span>
<span class="gi">+            args = &#39;, &#39;.join(stringify_annotation(a, mode) for a in annotation_args)</span>
<span class="gi">+            return f&#39;{module_prefix}{qualname}[{args}]&#39;</span>
<span class="gi">+</span>
<span class="gi">+    return module_prefix + qualname</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _format_literal_arg_stringify(arg: Any, /, *, mode: str) -&gt; str:</span>
<span class="gi">+    from sphinx.util.inspect import isenumattribute  # lazy loading</span>
<span class="gi">+</span>
<span class="gi">+    if isenumattribute(arg):</span>
<span class="gi">+        enum_cls = arg.__class__</span>
<span class="gi">+        if mode == &#39;smart&#39; or enum_cls.__module__ == &#39;typing&#39;:</span>
<span class="gi">+            # MyEnum.member</span>
<span class="gi">+            return f&#39;{enum_cls.__qualname__}.{arg.name}&#39;</span>
<span class="gi">+        # module.MyEnum.member</span>
<span class="gi">+        return f&#39;{enum_cls.__module__}.{enum_cls.__qualname__}.{arg.name}&#39;</span>
<span class="gi">+    return repr(arg)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# deprecated name -&gt; (object to return, canonical path or empty string, removal version)</span>
<span class="gi">+_DEPRECATED_OBJECTS: dict[str, tuple[Any, str, tuple[int, int]]] = {</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def __getattr__(name: str) -&gt; Any:</span>
<span class="w"> </span>    if name not in _DEPRECATED_OBJECTS:
<span class="w"> </span>        msg = f&#39;module {__name__!r} has no attribute {name!r}&#39;
<span class="w"> </span>        raise AttributeError(msg)
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.deprecation import _deprecation_warning
<span class="gi">+</span>
<span class="w"> </span>    deprecated_object, canonical_name, remove = _DEPRECATED_OBJECTS[name]
<span class="w"> </span>    _deprecation_warning(__name__, name, canonical_name, remove=remove)
<span class="w"> </span>    return deprecated_object
<span class="gh">diff --git a/sphinx/versioning.py b/sphinx/versioning.py</span>
<span class="gh">index e75880d9e..506d7b575 100644</span>
<span class="gd">--- a/sphinx/versioning.py</span>
<span class="gi">+++ b/sphinx/versioning.py</span>
<span class="gu">@@ -1,27 +1,36 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Implements the low-level algorithms Sphinx uses for versioning doctrees.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import pickle
<span class="w"> </span>from itertools import product, zip_longest
<span class="w"> </span>from operator import itemgetter
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="w"> </span>from uuid import uuid4
<span class="gi">+</span>
<span class="w"> </span>from sphinx.transforms import SphinxTransform
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from collections.abc import Callable, Iterator
<span class="gi">+</span>
<span class="w"> </span>    from docutils.nodes import Node
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.application import Sphinx
<span class="w"> </span>    from sphinx.util.typing import ExtensionMetadata
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="gd">-    import Levenshtein</span>
<span class="gi">+    import Levenshtein  # type: ignore[import-not-found]</span>
<span class="gi">+</span>
<span class="w"> </span>    IS_SPEEDUP = True
<span class="w"> </span>except ImportError:
<span class="w"> </span>    IS_SPEEDUP = False
<span class="gi">+</span>
<span class="gi">+# anything below that ratio is considered equal/changed</span>
<span class="w"> </span>VERSIONING_RATIO = 65


<span class="gd">-def add_uids(doctree: Node, condition: Callable[[Node], bool]) -&gt;Iterator[Node</span>
<span class="gd">-    ]:</span>
<span class="gi">+def add_uids(doctree: Node, condition: Callable[[Node], bool]) -&gt; Iterator[Node]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Add a unique id to every node in the `doctree` which matches the
<span class="w"> </span>    condition and yield the nodes.

<span class="gu">@@ -31,11 +40,14 @@ def add_uids(doctree: Node, condition: Callable[[Node], bool]) -&gt;Iterator[Node</span>
<span class="w"> </span>    :param condition:
<span class="w"> </span>        A callable which returns either ``True`` or ``False`` for a given node.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for node in doctree.findall(condition):</span>
<span class="gi">+        node.uid = uuid4().hex  # type: ignore[attr-defined]</span>
<span class="gi">+        yield node</span>


<span class="gd">-def merge_doctrees(old: Node, new: Node, condition: Callable[[Node], bool]</span>
<span class="gd">-    ) -&gt;Iterator[Node]:</span>
<span class="gi">+def merge_doctrees(</span>
<span class="gi">+    old: Node, new: Node, condition: Callable[[Node], bool]</span>
<span class="gi">+) -&gt; Iterator[Node]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Merge the `old` doctree with the `new` one while looking at nodes
<span class="w"> </span>    matching the `condition`.

<span class="gu">@@ -45,21 +57,128 @@ def merge_doctrees(old: Node, new: Node, condition: Callable[[Node], bool]</span>
<span class="w"> </span>    :param condition:
<span class="w"> </span>        A callable which returns either ``True`` or ``False`` for a given node.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    old_iter = old.findall(condition)</span>
<span class="gi">+    new_iter = new.findall(condition)</span>
<span class="gi">+    old_nodes = []</span>
<span class="gi">+    new_nodes = []</span>
<span class="gi">+    ratios = {}</span>
<span class="gi">+    seen = set()</span>
<span class="gi">+    # compare the nodes each doctree in order</span>
<span class="gi">+    for old_node, new_node in zip_longest(old_iter, new_iter):</span>
<span class="gi">+        if old_node is None:</span>
<span class="gi">+            new_nodes.append(new_node)</span>
<span class="gi">+            continue</span>
<span class="gi">+        if not getattr(old_node, &#39;uid&#39;, None):</span>
<span class="gi">+            # maybe config.gettext_uuid has been changed.</span>
<span class="gi">+            old_node.uid = uuid4().hex  # type: ignore[union-attr]</span>
<span class="gi">+        if new_node is None:</span>
<span class="gi">+            old_nodes.append(old_node)</span>
<span class="gi">+            continue</span>
<span class="gi">+        ratio = get_ratio(old_node.rawsource, new_node.rawsource)  # type: ignore[union-attr]</span>
<span class="gi">+        if ratio == 0:</span>
<span class="gi">+            new_node.uid = old_node.uid  # type: ignore[union-attr]</span>
<span class="gi">+            seen.add(new_node)</span>
<span class="gi">+        else:</span>
<span class="gi">+            ratios[old_node, new_node] = ratio</span>
<span class="gi">+            old_nodes.append(old_node)</span>
<span class="gi">+            new_nodes.append(new_node)</span>
<span class="gi">+    # calculate the ratios for each unequal pair of nodes, should we stumble</span>
<span class="gi">+    # on a pair which is equal we set the uid and add it to the seen ones</span>
<span class="gi">+    for old_node, new_node in product(old_nodes, new_nodes):</span>
<span class="gi">+        if new_node in seen or (old_node, new_node) in ratios:</span>
<span class="gi">+            continue</span>
<span class="gi">+        ratio = get_ratio(old_node.rawsource, new_node.rawsource)  # type: ignore[union-attr]</span>
<span class="gi">+        if ratio == 0:</span>
<span class="gi">+            new_node.uid = old_node.uid  # type: ignore[union-attr]</span>
<span class="gi">+            seen.add(new_node)</span>
<span class="gi">+        else:</span>
<span class="gi">+            ratios[old_node, new_node] = ratio</span>
<span class="gi">+    # choose the old node with the best ratio for each new node and set the uid</span>
<span class="gi">+    # as long as the ratio is under a certain value, in which case we consider</span>
<span class="gi">+    # them not changed but different</span>
<span class="gi">+    for (old_node, new_node), ratio in sorted(ratios.items(), key=itemgetter(1)):</span>
<span class="gi">+        if new_node in seen:</span>
<span class="gi">+            continue</span>
<span class="gi">+        else:</span>
<span class="gi">+            seen.add(new_node)</span>
<span class="gi">+        if ratio &lt; VERSIONING_RATIO:</span>
<span class="gi">+            new_node.uid = old_node.uid  # type: ignore[union-attr]</span>
<span class="gi">+        else:</span>
<span class="gi">+            new_node.uid = uuid4().hex  # type: ignore[union-attr]</span>
<span class="gi">+            yield new_node</span>
<span class="gi">+    # create new uuids for any new node we left out earlier, this happens</span>
<span class="gi">+    # if one or more nodes are simply added.</span>
<span class="gi">+    for new_node in set(new_nodes) - seen:</span>
<span class="gi">+        new_node.uid = uuid4().hex  # type: ignore[union-attr]</span>
<span class="gi">+        yield new_node</span>


<span class="gd">-def get_ratio(old: str, new: str) -&gt;float:</span>
<span class="gi">+def get_ratio(old: str, new: str) -&gt; float:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a &quot;similarity ratio&quot; (in percent) representing the similarity
<span class="w"> </span>    between the two strings where 0 is equal and anything above less than equal.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not all([old, new]):</span>
<span class="gi">+        return VERSIONING_RATIO</span>

<span class="gi">+    if IS_SPEEDUP:</span>
<span class="gi">+        return Levenshtein.distance(old, new) / (len(old) / 100.0)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return levenshtein_distance(old, new) / (len(old) / 100.0)</span>

<span class="gd">-def levenshtein_distance(a: str, b: str) -&gt;int:</span>
<span class="gi">+</span>
<span class="gi">+def levenshtein_distance(a: str, b: str) -&gt; int:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return the Levenshtein edit distance between two strings *a* and *b*.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if a == b:</span>
<span class="gi">+        return 0</span>
<span class="gi">+    if len(a) &lt; len(b):</span>
<span class="gi">+        a, b = b, a</span>
<span class="gi">+    if not a:</span>
<span class="gi">+        return len(b)</span>
<span class="gi">+    previous_row = list(range(len(b) + 1))</span>
<span class="gi">+    for i, column1 in enumerate(a):</span>
<span class="gi">+        current_row = [i + 1]</span>
<span class="gi">+        for j, column2 in enumerate(b):</span>
<span class="gi">+            insertions = previous_row[j + 1] + 1</span>
<span class="gi">+            deletions = current_row[j] + 1</span>
<span class="gi">+            substitutions = previous_row[j] + (column1 != column2)</span>
<span class="gi">+            current_row.append(min(insertions, deletions, substitutions))</span>
<span class="gi">+        previous_row = current_row</span>
<span class="gi">+    return previous_row[-1]</span>


<span class="w"> </span>class UIDTransform(SphinxTransform):
<span class="w"> </span>    &quot;&quot;&quot;Add UIDs to doctree for versioning.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    default_priority = 880
<span class="gi">+</span>
<span class="gi">+    def apply(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        env = self.env</span>
<span class="gi">+        old_doctree = None</span>
<span class="gi">+        versioning_condition = env.versioning_condition</span>
<span class="gi">+        if not versioning_condition:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if env.versioning_compare:</span>
<span class="gi">+            # get old doctree</span>
<span class="gi">+            try:</span>
<span class="gi">+                filename = path.join(env.doctreedir, env.docname + &#39;.doctree&#39;)</span>
<span class="gi">+                with open(filename, &#39;rb&#39;) as f:</span>
<span class="gi">+                    old_doctree = pickle.load(f)</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+        # add uids for versioning</span>
<span class="gi">+        if not env.versioning_compare or old_doctree is None:</span>
<span class="gi">+            list(add_uids(self.document, versioning_condition))</span>
<span class="gi">+        else:</span>
<span class="gi">+            list(merge_doctrees(old_doctree, self.document, versioning_condition))</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def setup(app: Sphinx) -&gt; ExtensionMetadata:</span>
<span class="gi">+    app.add_transform(UIDTransform)</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;version&#39;: &#39;builtin&#39;,</span>
<span class="gi">+        &#39;parallel_read_safe&#39;: True,</span>
<span class="gi">+        &#39;parallel_write_safe&#39;: True,</span>
<span class="gi">+    }</span>
<span class="gh">diff --git a/sphinx/writers/html.py b/sphinx/writers/html.py</span>
<span class="gh">index 1c2f29067..242846128 100644</span>
<span class="gd">--- a/sphinx/writers/html.py</span>
<span class="gi">+++ b/sphinx/writers/html.py</span>
<span class="gu">@@ -1,18 +1,44 @@</span>
<span class="w"> </span>&quot;&quot;&quot;docutils writers handling Sphinx&#39; custom nodes.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils.writers.html4css1 import Writer
<span class="gi">+</span>
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.writers.html5 import HTML5Translator
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from sphinx.builders.html import StandaloneHTMLBuilder
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="w"> </span>HTMLTranslator = HTML5Translator

<span class="gi">+# A good overview of the purpose behind these classes can be found here:</span>
<span class="gi">+# https://www.arnebrodowski.de/blog/write-your-own-restructuredtext-writer.html</span>
<span class="gi">+</span>

<span class="gd">-class HTMLWriter(Writer):</span>
<span class="gd">-    settings_default_overrides = {&#39;embed_stylesheet&#39;: False}</span>
<span class="gi">+class HTMLWriter(Writer):  # type: ignore[misc]</span>

<span class="gd">-    def __init__(self, builder: StandaloneHTMLBuilder) -&gt;None:</span>
<span class="gi">+    # override embed-stylesheet default value to False.</span>
<span class="gi">+    settings_default_overrides = {&quot;embed_stylesheet&quot;: False}</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, builder: StandaloneHTMLBuilder) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.builder = builder
<span class="gi">+</span>
<span class="gi">+    def translate(self) -&gt; None:</span>
<span class="gi">+        # sadly, this is mostly copied from parent class</span>
<span class="gi">+        visitor = self.builder.create_translator(self.document, self.builder)</span>
<span class="gi">+        self.visitor = cast(HTML5Translator, visitor)</span>
<span class="gi">+        self.document.walkabout(visitor)</span>
<span class="gi">+        self.output = self.visitor.astext()</span>
<span class="gi">+        for attr in (&#39;head_prefix&#39;, &#39;stylesheet&#39;, &#39;head&#39;, &#39;body_prefix&#39;,</span>
<span class="gi">+                     &#39;body_pre_docinfo&#39;, &#39;docinfo&#39;, &#39;body&#39;, &#39;fragment&#39;,</span>
<span class="gi">+                     &#39;body_suffix&#39;, &#39;meta&#39;, &#39;title&#39;, &#39;subtitle&#39;, &#39;header&#39;,</span>
<span class="gi">+                     &#39;footer&#39;, &#39;html_prolog&#39;, &#39;html_head&#39;, &#39;html_title&#39;,</span>
<span class="gi">+                     &#39;html_subtitle&#39;, &#39;html_body&#39;):</span>
<span class="gi">+            setattr(self, attr, getattr(visitor, attr, None))</span>
<span class="gi">+        self.clean_meta = &#39;&#39;.join(self.visitor.meta[2:])</span>
<span class="gh">diff --git a/sphinx/writers/html5.py b/sphinx/writers/html5.py</span>
<span class="gh">index 761abb855..2d6338d8c 100644</span>
<span class="gd">--- a/sphinx/writers/html5.py</span>
<span class="gi">+++ b/sphinx/writers/html5.py</span>
<span class="gu">@@ -1,41 +1,64 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Experimental docutils writers for HTML5 handling Sphinx&#39;s custom nodes.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import os
<span class="w"> </span>import posixpath
<span class="w"> </span>import re
<span class="w"> </span>import urllib.parse
<span class="w"> </span>from collections.abc import Iterable
<span class="w"> </span>from typing import TYPE_CHECKING, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.writers.html5_polyglot import HTMLTranslator as BaseTranslator
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.locale import _, __, admonitionlabels
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.docutils import SphinxTranslator
<span class="w"> </span>from sphinx.util.images import get_image_size
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.nodes import Element, Node, Text
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.builders import Builder
<span class="w"> </span>    from sphinx.builders.html import StandaloneHTMLBuilder
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)

<span class="gi">+# A good overview of the purpose behind these classes can be found here:</span>
<span class="gi">+# https://www.arnebrodowski.de/blog/write-your-own-restructuredtext-writer.html</span>
<span class="gi">+</span>

<span class="gd">-def multiply_length(length: str, scale: int) -&gt;str:</span>
<span class="gi">+def multiply_length(length: str, scale: int) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Multiply *length* (width or height) by *scale*.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    matched = re.match(r&#39;^(\d*\.?\d*)\s*(\S*)$&#39;, length)</span>
<span class="gi">+    if not matched:</span>
<span class="gi">+        return length</span>
<span class="gi">+    if scale == 100:</span>
<span class="gi">+        return length</span>
<span class="gi">+    amount, unit = matched.groups()</span>
<span class="gi">+    result = float(amount) * scale / 100</span>
<span class="gi">+    return f&quot;{int(result)}{unit}&quot;</span>


<span class="gd">-class HTML5Translator(SphinxTranslator, BaseTranslator):</span>
<span class="gi">+class HTML5Translator(SphinxTranslator, BaseTranslator):  # type: ignore[misc]</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Our custom HTML translator.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    builder: StandaloneHTMLBuilder
<span class="gi">+    # Override docutils.writers.html5_polyglot:HTMLTranslator</span>
<span class="gi">+    # otherwise, nodes like &lt;inline classes=&quot;s&quot;&gt;...&lt;/inline&gt; will be</span>
<span class="gi">+    # converted to &lt;s&gt;...&lt;/s&gt; by `visit_inline`.</span>
<span class="w"> </span>    supported_inline_tags: set[str] = set()

<span class="gd">-    def __init__(self, document: nodes.document, builder: Builder) -&gt;None:</span>
<span class="gi">+    def __init__(self, document: nodes.document, builder: Builder) -&gt; None:</span>
<span class="w"> </span>        super().__init__(document, builder)
<span class="gi">+</span>
<span class="w"> </span>        self.highlighter = self.builder.highlighter
<span class="gd">-        self.docnames = [self.builder.current_docname]</span>
<span class="gi">+        self.docnames = [self.builder.current_docname]  # for singlehtml builder</span>
<span class="w"> </span>        self.protect_literal_text = 0
<span class="w"> </span>        self.secnumber_suffix = self.config.html_secnumber_suffix
<span class="w"> </span>        self.param_separator = &#39;&#39;
<span class="gu">@@ -44,11 +67,881 @@ class HTML5Translator(SphinxTranslator, BaseTranslator):</span>
<span class="w"> </span>        self._fieldlist_row_indices = [0]
<span class="w"> </span>        self.required_params_left = 0

<span class="gd">-    def _visit_sig_parameter_list(self, node: Element, parameter_group:</span>
<span class="gd">-        type[Element], sig_open_paren: str, sig_close_paren: str) -&gt;None:</span>
<span class="gi">+    def visit_start_of_file(self, node: Element) -&gt; None:</span>
<span class="gi">+        # only occurs in the single-file builder</span>
<span class="gi">+        self.docnames.append(node[&#39;docname&#39;])</span>
<span class="gi">+        self.body.append(&#39;&lt;span id=&quot;document-%s&quot;&gt;&lt;/span&gt;&#39; % node[&#39;docname&#39;])</span>
<span class="gi">+</span>
<span class="gi">+    def depart_start_of_file(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.docnames.pop()</span>
<span class="gi">+</span>
<span class="gi">+    #############################################################</span>
<span class="gi">+    # Domain-specific object descriptions</span>
<span class="gi">+    #############################################################</span>
<span class="gi">+</span>
<span class="gi">+    # Top-level nodes for descriptions</span>
<span class="gi">+    ##################################</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(self.starttag(node, &#39;dl&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;&lt;/dl&gt;\n\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_signature(self, node: Element) -&gt; None:</span>
<span class="gi">+        # the id is set automatically</span>
<span class="gi">+        self.body.append(self.starttag(node, &#39;dt&#39;))</span>
<span class="gi">+        self.protect_literal_text += 1</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_signature(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.protect_literal_text -= 1</span>
<span class="gi">+        if not node.get(&#39;is_multiline&#39;):</span>
<span class="gi">+            self.add_permalink_ref(node, _(&#39;Link to this definition&#39;))</span>
<span class="gi">+        self.body.append(&#39;&lt;/dt&gt;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_signature_line(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_signature_line(self, node: Element) -&gt; None:</span>
<span class="gi">+        if node.get(&#39;add_permalink&#39;):</span>
<span class="gi">+            # the permalink info is on the parent desc_signature node</span>
<span class="gi">+            self.add_permalink_ref(node.parent, _(&#39;Link to this definition&#39;))</span>
<span class="gi">+        self.body.append(&#39;&lt;br /&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_content(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(self.starttag(node, &#39;dd&#39;, &#39;&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_content(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;&lt;/dd&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_inline(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(self.starttag(node, &#39;span&#39;, &#39;&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_inline(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;&lt;/span&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # Nodes for high-level structure in signatures</span>
<span class="gi">+    ##############################################</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_name(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(self.starttag(node, &#39;span&#39;, &#39;&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_name(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;&lt;/span&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_addname(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(self.starttag(node, &#39;span&#39;, &#39;&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_addname(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;&lt;/span&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_type(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_type(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_returns(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39; &lt;span class=&quot;sig-return&quot;&gt;&#39;)</span>
<span class="gi">+        self.body.append(&#39;&lt;span class=&quot;sig-return-icon&quot;&gt;&amp;#x2192;&lt;/span&gt;&#39;)</span>
<span class="gi">+        self.body.append(&#39; &lt;span class=&quot;sig-return-typehint&quot;&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_returns(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;&lt;/span&gt;&lt;/span&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def _visit_sig_parameter_list(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: Element,</span>
<span class="gi">+        parameter_group: type[Element],</span>
<span class="gi">+        sig_open_paren: str,</span>
<span class="gi">+        sig_close_paren: str,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit a signature parameters or type parameters list.

<span class="w"> </span>        The *parameter_group* value is the type of child nodes acting as required parameters
<span class="w"> </span>        or as a set of contiguous optional parameters.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        self.body.append(f&#39;&lt;span class=&quot;sig-paren&quot;&gt;{sig_open_paren}&lt;/span&gt;&#39;)</span>
<span class="gi">+        self.is_first_param = True</span>
<span class="gi">+        self.optional_param_level = 0</span>
<span class="gi">+        self.params_left_at_level = 0</span>
<span class="gi">+        self.param_group_index = 0</span>
<span class="gi">+        # Counts as what we call a parameter group either a required parameter, or a</span>
<span class="gi">+        # set of contiguous optional ones.</span>
<span class="gi">+        self.list_is_required_param = [isinstance(c, parameter_group) for c in node.children]</span>
<span class="gi">+        # How many required parameters are left.</span>
<span class="gi">+        self.required_params_left = sum(self.list_is_required_param)</span>
<span class="gi">+        self.param_separator = node.child_text_separator</span>
<span class="gi">+        self.multi_line_parameter_list = node.get(&#39;multi_line_parameter_list&#39;, False)</span>
<span class="gi">+        if self.multi_line_parameter_list:</span>
<span class="gi">+            self.body.append(&#39;\n\n&#39;)</span>
<span class="gi">+            self.body.append(self.starttag(node, &#39;dl&#39;))</span>
<span class="gi">+            self.param_separator = self.param_separator.rstrip()</span>
<span class="gi">+        self.context.append(sig_close_paren)</span>
<span class="gi">+</span>
<span class="gi">+    def _depart_sig_parameter_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        if node.get(&#39;multi_line_parameter_list&#39;):</span>
<span class="gi">+            self.body.append(&#39;&lt;/dl&gt;\n\n&#39;)</span>
<span class="gi">+        sig_close_paren = self.context.pop()</span>
<span class="gi">+        self.body.append(f&#39;&lt;span class=&quot;sig-paren&quot;&gt;{sig_close_paren}&lt;/span&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_parameterlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        self._visit_sig_parameter_list(node, addnodes.desc_parameter, &#39;(&#39;, &#39;)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_parameterlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        self._depart_sig_parameter_list(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_type_parameter_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self._visit_sig_parameter_list(node, addnodes.desc_type_parameter, &#39;[&#39;, &#39;]&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_type_parameter_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self._depart_sig_parameter_list(node)</span>
<span class="gi">+</span>
<span class="gi">+    # If required parameters are still to come, then put the comma after</span>
<span class="gi">+    # the parameter.  Otherwise, put the comma before.  This ensures that</span>
<span class="gi">+    # signatures like the following render correctly (see issue #1001):</span>
<span class="gi">+    #</span>
<span class="gi">+    #     foo([a, ]b, c[, d])</span>
<span class="gi">+    #</span>
<span class="gi">+    def visit_desc_parameter(self, node: Element) -&gt; None:</span>
<span class="gi">+        on_separate_line = self.multi_line_parameter_list</span>
<span class="gi">+        if on_separate_line and not (self.is_first_param and self.optional_param_level &gt; 0):</span>
<span class="gi">+            self.body.append(self.starttag(node, &#39;dd&#39;, &#39;&#39;))</span>
<span class="gi">+        if self.is_first_param:</span>
<span class="gi">+            self.is_first_param = False</span>
<span class="gi">+        elif not on_separate_line and not self.required_params_left:</span>
<span class="gi">+            self.body.append(self.param_separator)</span>
<span class="gi">+        if self.optional_param_level == 0:</span>
<span class="gi">+            self.required_params_left -= 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.params_left_at_level -= 1</span>
<span class="gi">+        if not node.hasattr(&#39;noemph&#39;):</span>
<span class="gi">+            self.body.append(&#39;&lt;em class=&quot;sig-param&quot;&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_parameter(self, node: Element) -&gt; None:</span>
<span class="gi">+        if not node.hasattr(&#39;noemph&#39;):</span>
<span class="gi">+            self.body.append(&#39;&lt;/em&gt;&#39;)</span>
<span class="gi">+        is_required = self.list_is_required_param[self.param_group_index]</span>
<span class="gi">+        if self.multi_line_parameter_list:</span>
<span class="gi">+            is_last_group = self.param_group_index + 1 == len(self.list_is_required_param)</span>
<span class="gi">+            next_is_required = (</span>
<span class="gi">+                not is_last_group</span>
<span class="gi">+                and self.list_is_required_param[self.param_group_index + 1]</span>
<span class="gi">+            )</span>
<span class="gi">+            opt_param_left_at_level = self.params_left_at_level &gt; 0</span>
<span class="gi">+            if opt_param_left_at_level or is_required and (is_last_group or next_is_required):</span>
<span class="gi">+                self.body.append(self.param_separator)</span>
<span class="gi">+                self.body.append(&#39;&lt;/dd&gt;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        elif self.required_params_left:</span>
<span class="gi">+            self.body.append(self.param_separator)</span>
<span class="gi">+</span>
<span class="gi">+        if is_required:</span>
<span class="gi">+            self.param_group_index += 1</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_type_parameter(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_desc_parameter(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_type_parameter(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.depart_desc_parameter(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_optional(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.params_left_at_level = sum(isinstance(c, addnodes.desc_parameter)</span>
<span class="gi">+                                        for c in node.children)</span>
<span class="gi">+        self.optional_param_level += 1</span>
<span class="gi">+        self.max_optional_param_level = self.optional_param_level</span>
<span class="gi">+        if self.multi_line_parameter_list:</span>
<span class="gi">+            # If the first parameter is optional, start a new line and open the bracket.</span>
<span class="gi">+            if self.is_first_param:</span>
<span class="gi">+                self.body.append(self.starttag(node, &#39;dd&#39;, &#39;&#39;))</span>
<span class="gi">+                self.body.append(&#39;&lt;span class=&quot;optional&quot;&gt;[&lt;/span&gt;&#39;)</span>
<span class="gi">+            # Else, if there remains at least one required parameter, append the</span>
<span class="gi">+            # parameter separator, open a new bracket, and end the line.</span>
<span class="gi">+            elif self.required_params_left:</span>
<span class="gi">+                self.body.append(self.param_separator)</span>
<span class="gi">+                self.body.append(&#39;&lt;span class=&quot;optional&quot;&gt;[&lt;/span&gt;&#39;)</span>
<span class="gi">+                self.body.append(&#39;&lt;/dd&gt;\n&#39;)</span>
<span class="gi">+            # Else, open a new bracket, append the parameter separator,</span>
<span class="gi">+            # and end the line.</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.body.append(&#39;&lt;span class=&quot;optional&quot;&gt;[&lt;/span&gt;&#39;)</span>
<span class="gi">+                self.body.append(self.param_separator)</span>
<span class="gi">+                self.body.append(&#39;&lt;/dd&gt;\n&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.body.append(&#39;&lt;span class=&quot;optional&quot;&gt;[&lt;/span&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_optional(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.optional_param_level -= 1</span>
<span class="gi">+        if self.multi_line_parameter_list:</span>
<span class="gi">+            # If it&#39;s the first time we go down one level, add the separator</span>
<span class="gi">+            # before the bracket.</span>
<span class="gi">+            if self.optional_param_level == self.max_optional_param_level - 1:</span>
<span class="gi">+                self.body.append(self.param_separator)</span>
<span class="gi">+            self.body.append(&#39;&lt;span class=&quot;optional&quot;&gt;]&lt;/span&gt;&#39;)</span>
<span class="gi">+            # End the line if we have just closed the last bracket of this</span>
<span class="gi">+            # optional parameter group.</span>
<span class="gi">+            if self.optional_param_level == 0:</span>
<span class="gi">+                self.body.append(&#39;&lt;/dd&gt;\n&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.body.append(&#39;&lt;span class=&quot;optional&quot;&gt;]&lt;/span&gt;&#39;)</span>
<span class="gi">+        if self.optional_param_level == 0:</span>
<span class="gi">+            self.param_group_index += 1</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_annotation(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(self.starttag(node, &#39;em&#39;, &#39;&#39;, CLASS=&#39;property&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_annotation(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;&lt;/em&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    ##############################################</span>
<span class="gi">+</span>
<span class="gi">+    def visit_versionmodified(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(self.starttag(node, &#39;div&#39;, CLASS=node[&#39;type&#39;]))</span>
<span class="gi">+</span>
<span class="gi">+    def depart_versionmodified(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;&lt;/div&gt;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten</span>
<span class="gi">+    def visit_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        atts = {&#39;class&#39;: &#39;reference&#39;}</span>
<span class="gi">+        if node.get(&#39;internal&#39;) or &#39;refuri&#39; not in node:</span>
<span class="gi">+            atts[&#39;class&#39;] += &#39; internal&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            atts[&#39;class&#39;] += &#39; external&#39;</span>
<span class="gi">+        if &#39;refuri&#39; in node:</span>
<span class="gi">+            atts[&#39;href&#39;] = node[&#39;refuri&#39;] or &#39;#&#39;</span>
<span class="gi">+            if self.settings.cloak_email_addresses and atts[&#39;href&#39;].startswith(&#39;mailto:&#39;):</span>
<span class="gi">+                atts[&#39;href&#39;] = self.cloak_mailto(atts[&#39;href&#39;])</span>
<span class="gi">+                self.in_mailto = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            assert &#39;refid&#39; in node, \</span>
<span class="gi">+                   &#39;References must have &quot;refuri&quot; or &quot;refid&quot; attribute.&#39;</span>
<span class="gi">+            atts[&#39;href&#39;] = &#39;#&#39; + node[&#39;refid&#39;]</span>
<span class="gi">+        if not isinstance(node.parent, nodes.TextElement):</span>
<span class="gi">+            assert len(node) == 1 and isinstance(node[0], nodes.image)  # NoQA: PT018</span>
<span class="gi">+            atts[&#39;class&#39;] += &#39; image-reference&#39;</span>
<span class="gi">+        if &#39;reftitle&#39; in node:</span>
<span class="gi">+            atts[&#39;title&#39;] = node[&#39;reftitle&#39;]</span>
<span class="gi">+        if &#39;target&#39; in node:</span>
<span class="gi">+            atts[&#39;target&#39;] = node[&#39;target&#39;]</span>
<span class="gi">+        if &#39;rel&#39; in node:</span>
<span class="gi">+            atts[&#39;rel&#39;] = node[&#39;rel&#39;]</span>
<span class="gi">+        self.body.append(self.starttag(node, &#39;a&#39;, &#39;&#39;, **atts))</span>
<span class="gi">+</span>
<span class="gi">+        if node.get(&#39;secnumber&#39;):</span>
<span class="gi">+            self.body.append((&#39;%s&#39; + self.secnumber_suffix) %</span>
<span class="gi">+                             &#39;.&#39;.join(map(str, node[&#39;secnumber&#39;])))</span>
<span class="gi">+</span>
<span class="gi">+    def visit_number_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_reference(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_number_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.depart_reference(node)</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten -- we don&#39;t want source comments to show up in the HTML</span>
<span class="gi">+    def visit_comment(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten</span>
<span class="gi">+    def visit_admonition(self, node: Element, name: str = &#39;&#39;) -&gt; None:</span>
<span class="gi">+        self.body.append(self.starttag(</span>
<span class="gi">+            node, &#39;div&#39;, CLASS=(&#39;admonition &#39; + name)))</span>
<span class="gi">+        if name:</span>
<span class="gi">+            node.insert(0, nodes.title(name, admonitionlabels[name]))</span>
<span class="gi">+</span>
<span class="gi">+    def depart_admonition(self, node: Element | None = None) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;&lt;/div&gt;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_seealso(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_admonition(node, &#39;seealso&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_seealso(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.depart_admonition(node)</span>
<span class="gi">+</span>
<span class="gi">+    def get_secnumber(self, node: Element) -&gt; tuple[int, ...] | None:</span>
<span class="gi">+        if node.get(&#39;secnumber&#39;):</span>
<span class="gi">+            return node[&#39;secnumber&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(node.parent, nodes.section):</span>
<span class="gi">+            if self.builder.name == &#39;singlehtml&#39;:</span>
<span class="gi">+                docname = self.docnames[-1]</span>
<span class="gi">+                anchorname = &quot;{}/#{}&quot;.format(docname, node.parent[&#39;ids&#39;][0])</span>
<span class="gi">+                if anchorname not in self.builder.secnumbers:</span>
<span class="gi">+                    anchorname = &quot;%s/&quot; % docname  # try first heading which has no anchor</span>
<span class="gi">+            else:</span>
<span class="gi">+                anchorname = &#39;#&#39; + node.parent[&#39;ids&#39;][0]</span>
<span class="gi">+                if anchorname not in self.builder.secnumbers:</span>
<span class="gi">+                    anchorname = &#39;&#39;  # try first heading which has no anchor</span>
<span class="gi">+</span>
<span class="gi">+            if self.builder.secnumbers.get(anchorname):</span>
<span class="gi">+                return self.builder.secnumbers[anchorname]</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def add_secnumber(self, node: Element) -&gt; None:</span>
<span class="gi">+        secnumber = self.get_secnumber(node)</span>
<span class="gi">+        if secnumber:</span>
<span class="gi">+            self.body.append(&#39;&lt;span class=&quot;section-number&quot;&gt;%s&lt;/span&gt;&#39; %</span>
<span class="gi">+                             (&#39;.&#39;.join(map(str, secnumber)) + self.secnumber_suffix))</span>
<span class="gi">+</span>
<span class="gi">+    def add_fignumber(self, node: Element) -&gt; None:</span>
<span class="gi">+        def append_fignumber(figtype: str, figure_id: str) -&gt; None:</span>
<span class="gi">+            if self.builder.name == &#39;singlehtml&#39;:</span>
<span class="gi">+                key = f&quot;{self.docnames[-1]}/{figtype}&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                key = figtype</span>
<span class="gi">+</span>
<span class="gi">+            if figure_id in self.builder.fignumbers.get(key, {}):</span>
<span class="gi">+                self.body.append(&#39;&lt;span class=&quot;caption-number&quot;&gt;&#39;)</span>
<span class="gi">+                prefix = self.config.numfig_format.get(figtype)</span>
<span class="gi">+                if prefix is None:</span>
<span class="gi">+                    msg = __(&#39;numfig_format is not defined for %s&#39;) % figtype</span>
<span class="gi">+                    logger.warning(msg)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    numbers = self.builder.fignumbers[key][figure_id]</span>
<span class="gi">+                    self.body.append(prefix % &#39;.&#39;.join(map(str, numbers)) + &#39; &#39;)</span>
<span class="gi">+                    self.body.append(&#39;&lt;/span&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        figtype = self.builder.env.domains[&#39;std&#39;].get_enumerable_node_type(node)</span>
<span class="gi">+        if figtype:</span>
<span class="gi">+            if len(node[&#39;ids&#39;]) == 0:</span>
<span class="gi">+                msg = __(&#39;Any IDs not assigned for %s node&#39;) % node.tagname</span>
<span class="gi">+                logger.warning(msg, location=node)</span>
<span class="gi">+            else:</span>
<span class="gi">+                append_fignumber(figtype, node[&#39;ids&#39;][0])</span>
<span class="gi">+</span>
<span class="gi">+    def add_permalink_ref(self, node: Element, title: str) -&gt; None:</span>
<span class="gi">+        icon = self.config.html_permalinks_icon</span>
<span class="gi">+        if node[&#39;ids&#39;] and self.config.html_permalinks and self.builder.add_permalinks:</span>
<span class="gi">+            self.body.append(</span>
<span class="gi">+                f&#39;&lt;a class=&quot;headerlink&quot; href=&quot;#{node[&quot;ids&quot;][0]}&quot; title=&quot;{title}&quot;&gt;{icon}&lt;/a&gt;&#39;,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten</span>
<span class="gi">+    def visit_bullet_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        if len(node) == 1 and isinstance(node[0], addnodes.toctree):</span>
<span class="gi">+            # avoid emitting empty &lt;ul&gt;&lt;/ul&gt;</span>
<span class="gi">+            raise nodes.SkipNode</span>
<span class="gi">+        super().visit_bullet_list(node)</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten</span>
<span class="gi">+    def visit_definition(self, node: Element) -&gt; None:</span>
<span class="gi">+        # don&#39;t insert &lt;/dt&gt; here.</span>
<span class="gi">+        self.body.append(self.starttag(node, &#39;dd&#39;, &#39;&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten</span>
<span class="gi">+    def depart_definition(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;&lt;/dd&gt;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten</span>
<span class="gi">+    def visit_classifier(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(self.starttag(node, &#39;span&#39;, &#39;&#39;, CLASS=&#39;classifier&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten</span>
<span class="gi">+    def depart_classifier(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;&lt;/span&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        next_node: Node = node.next_node(descend=False, siblings=True)</span>
<span class="gi">+        if not isinstance(next_node, nodes.classifier):</span>
<span class="gi">+            # close `&lt;dt&gt;` tag at the tail of classifiers</span>
<span class="gi">+            self.body.append(&#39;&lt;/dt&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten</span>
<span class="gi">+    def visit_term(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(self.starttag(node, &#39;dt&#39;, &#39;&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten</span>
<span class="gi">+    def depart_term(self, node: Element) -&gt; None:</span>
<span class="gi">+        next_node: Node = node.next_node(descend=False, siblings=True)</span>
<span class="gi">+        if isinstance(next_node, nodes.classifier):</span>
<span class="gi">+            # Leave the end tag to `self.depart_classifier()`, in case</span>
<span class="gi">+            # there&#39;s a classifier.</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            if isinstance(node.parent.parent.parent, addnodes.glossary):</span>
<span class="gi">+                # add permalink if glossary terms</span>
<span class="gi">+                self.add_permalink_ref(node, _(&#39;Link to this term&#39;))</span>
<span class="gi">+</span>
<span class="gi">+            self.body.append(&#39;&lt;/dt&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten</span>
<span class="gi">+    def visit_title(self, node: Element) -&gt; None:</span>
<span class="gi">+        if isinstance(node.parent, addnodes.compact_paragraph) and node.parent.get(&#39;toctree&#39;):</span>
<span class="gi">+            self.body.append(self.starttag(node, &#39;p&#39;, &#39;&#39;, CLASS=&#39;caption&#39;, ROLE=&#39;heading&#39;))</span>
<span class="gi">+            self.body.append(&#39;&lt;span class=&quot;caption-text&quot;&gt;&#39;)</span>
<span class="gi">+            self.context.append(&#39;&lt;/span&gt;&lt;/p&gt;\n&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            super().visit_title(node)</span>
<span class="gi">+        self.add_secnumber(node)</span>
<span class="gi">+        self.add_fignumber(node.parent)</span>
<span class="gi">+        if isinstance(node.parent, nodes.table):</span>
<span class="gi">+            self.body.append(&#39;&lt;span class=&quot;caption-text&quot;&gt;&#39;)</span>
<span class="gi">+        # Partially revert https://sourceforge.net/p/docutils/code/9562/</span>
<span class="gi">+        if (</span>
<span class="gi">+                isinstance(node.parent, nodes.topic)</span>
<span class="gi">+                and self.settings.toc_backlinks</span>
<span class="gi">+                and &#39;contents&#39; in node.parent[&#39;classes&#39;]</span>
<span class="gi">+                and self.body[-1].startswith(&#39;&lt;a &#39;)</span>
<span class="gi">+                # TODO: only remove for EPUB</span>
<span class="gi">+        ):</span>
<span class="gi">+            # remove &lt;a class=&quot;reference internal&quot; href=&quot;#top&quot;&gt;</span>
<span class="gi">+            self.body.pop()</span>
<span class="gi">+            self.context[-1] = &#39;&lt;/p&gt;\n&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def depart_title(self, node: Element) -&gt; None:</span>
<span class="gi">+        close_tag = self.context[-1]</span>
<span class="gi">+        if (self.config.html_permalinks and self.builder.add_permalinks and</span>
<span class="gi">+                node.parent.hasattr(&#39;ids&#39;) and node.parent[&#39;ids&#39;]):</span>
<span class="gi">+            # add permalink anchor</span>
<span class="gi">+            if close_tag.startswith(&#39;&lt;/h&#39;):</span>
<span class="gi">+                self.add_permalink_ref(node.parent, _(&#39;Link to this heading&#39;))</span>
<span class="gi">+            elif close_tag.startswith(&#39;&lt;/a&gt;&lt;/h&#39;):</span>
<span class="gi">+                self.body.append(&#39;&lt;/a&gt;&lt;a class=&quot;headerlink&quot; href=&quot;#%s&quot; &#39; %</span>
<span class="gi">+                                 node.parent[&#39;ids&#39;][0] +</span>
<span class="gi">+                                 &#39;title=&quot;{}&quot;&gt;{}&#39;.format(</span>
<span class="gi">+                                     _(&#39;Link to this heading&#39;),</span>
<span class="gi">+                                     self.config.html_permalinks_icon))</span>
<span class="gi">+            elif isinstance(node.parent, nodes.table):</span>
<span class="gi">+                self.body.append(&#39;&lt;/span&gt;&#39;)</span>
<span class="gi">+                self.add_permalink_ref(node.parent, _(&#39;Link to this table&#39;))</span>
<span class="gi">+        elif isinstance(node.parent, nodes.table):</span>
<span class="gi">+            self.body.append(&#39;&lt;/span&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        super().depart_title(node)</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten</span>
<span class="gi">+    def visit_rubric(self, node: nodes.rubric) -&gt; None:</span>
<span class="gi">+        if &#39;heading-level&#39; in node:</span>
<span class="gi">+            level = node[&#39;heading-level&#39;]</span>
<span class="gi">+            if level in {1, 2, 3, 4, 5, 6}:</span>
<span class="gi">+                self.body.append(self.starttag(node, f&#39;h{level}&#39;, &#39;&#39;, CLASS=&#39;rubric&#39;))</span>
<span class="gi">+            else:</span>
<span class="gi">+                logger.warning(</span>
<span class="gi">+                    __(&#39;unsupported rubric heading level: %s&#39;),</span>
<span class="gi">+                    level,</span>
<span class="gi">+                    type=&#39;html&#39;,</span>
<span class="gi">+                    location=node</span>
<span class="gi">+                )</span>
<span class="gi">+                super().visit_rubric(node)</span>
<span class="gi">+        else:</span>
<span class="gi">+            super().visit_rubric(node)</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten</span>
<span class="gi">+    def depart_rubric(self, node: nodes.rubric) -&gt; None:</span>
<span class="gi">+        if (level := node.get(&#39;heading-level&#39;)) in {1, 2, 3, 4, 5, 6}:</span>
<span class="gi">+            self.body.append(f&#39;&lt;/h{level}&gt;\n&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            super().depart_rubric(node)</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten</span>
<span class="gi">+    def visit_literal_block(self, node: Element) -&gt; None:</span>
<span class="gi">+        if node.rawsource != node.astext():</span>
<span class="gi">+            # most probably a parsed-literal block -- don&#39;t highlight</span>
<span class="gi">+            return super().visit_literal_block(node)</span>
<span class="gi">+</span>
<span class="gi">+        lang = node.get(&#39;language&#39;, &#39;default&#39;)</span>
<span class="gi">+        linenos = node.get(&#39;linenos&#39;, False)</span>
<span class="gi">+        highlight_args = node.get(&#39;highlight_args&#39;, {})</span>
<span class="gi">+        highlight_args[&#39;force&#39;] = node.get(&#39;force&#39;, False)</span>
<span class="gi">+        opts = self.config.highlight_options.get(lang, {})</span>
<span class="gi">+</span>
<span class="gi">+        if linenos and self.config.html_codeblock_linenos_style:</span>
<span class="gi">+            linenos = self.config.html_codeblock_linenos_style</span>
<span class="gi">+</span>
<span class="gi">+        highlighted = self.highlighter.highlight_block(</span>
<span class="gi">+            node.rawsource, lang, opts=opts, linenos=linenos,</span>
<span class="gi">+            location=node, **highlight_args,</span>
<span class="gi">+        )</span>
<span class="gi">+        starttag = self.starttag(node, &#39;div&#39;, suffix=&#39;&#39;,</span>
<span class="gi">+                                 CLASS=&#39;highlight-%s notranslate&#39; % lang)</span>
<span class="gi">+        self.body.append(starttag + highlighted + &#39;&lt;/div&gt;\n&#39;)</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_caption(self, node: Element) -&gt; None:</span>
<span class="gi">+        if isinstance(node.parent, nodes.container) and node.parent.get(&#39;literal_block&#39;):</span>
<span class="gi">+            self.body.append(&#39;&lt;div class=&quot;code-block-caption&quot;&gt;&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            super().visit_caption(node)</span>
<span class="gi">+        self.add_fignumber(node.parent)</span>
<span class="gi">+        self.body.append(self.starttag(node, &#39;span&#39;, &#39;&#39;, CLASS=&#39;caption-text&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    def depart_caption(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;&lt;/span&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        # append permalink if available</span>
<span class="gi">+        if isinstance(node.parent, nodes.container) and node.parent.get(&#39;literal_block&#39;):</span>
<span class="gi">+            self.add_permalink_ref(node.parent, _(&#39;Link to this code&#39;))</span>
<span class="gi">+        elif isinstance(node.parent, nodes.figure):</span>
<span class="gi">+            self.add_permalink_ref(node.parent, _(&#39;Link to this image&#39;))</span>
<span class="gi">+        elif node.parent.get(&#39;toctree&#39;):</span>
<span class="gi">+            self.add_permalink_ref(node.parent.parent, _(&#39;Link to this toctree&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(node.parent, nodes.container) and node.parent.get(&#39;literal_block&#39;):</span>
<span class="gi">+            self.body.append(&#39;&lt;/div&gt;\n&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            super().depart_caption(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_doctest_block(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_literal_block(node)</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten to add the &lt;div&gt; (for XHTML compliance)</span>
<span class="gi">+    def visit_block_quote(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(self.starttag(node, &#39;blockquote&#39;) + &#39;&lt;div&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_block_quote(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;&lt;/div&gt;&lt;/blockquote&gt;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten</span>
<span class="gi">+    def visit_literal(self, node: Element) -&gt; None:</span>
<span class="gi">+        if &#39;kbd&#39; in node[&#39;classes&#39;]:</span>
<span class="gi">+            self.body.append(self.starttag(node, &#39;kbd&#39;, &#39;&#39;,</span>
<span class="gi">+                                           CLASS=&#39;docutils literal notranslate&#39;))</span>
<span class="gi">+            return</span>
<span class="gi">+        lang = node.get(&quot;language&quot;, None)</span>
<span class="gi">+        if &#39;code&#39; not in node[&#39;classes&#39;] or not lang:</span>
<span class="gi">+            self.body.append(self.starttag(node, &#39;code&#39;, &#39;&#39;,</span>
<span class="gi">+                                           CLASS=&#39;docutils literal notranslate&#39;))</span>
<span class="gi">+            self.protect_literal_text += 1</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        opts = self.config.highlight_options.get(lang, {})</span>
<span class="gi">+        highlighted = self.highlighter.highlight_block(</span>
<span class="gi">+            node.astext(), lang, opts=opts, location=node, nowrap=True)</span>
<span class="gi">+        starttag = self.starttag(</span>
<span class="gi">+            node,</span>
<span class="gi">+            &quot;code&quot;,</span>
<span class="gi">+            suffix=&quot;&quot;,</span>
<span class="gi">+            CLASS=&quot;docutils literal highlight highlight-%s&quot; % lang,</span>
<span class="gi">+        )</span>
<span class="gi">+        self.body.append(starttag + highlighted.strip() + &quot;&lt;/code&gt;&quot;)</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def depart_literal(self, node: Element) -&gt; None:</span>
<span class="gi">+        if &#39;kbd&#39; in node[&#39;classes&#39;]:</span>
<span class="gi">+            self.body.append(&#39;&lt;/kbd&gt;&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.protect_literal_text -= 1</span>
<span class="gi">+            self.body.append(&#39;&lt;/code&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_productionlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(self.starttag(node, &#39;pre&#39;))</span>
<span class="gi">+        productionlist = cast(Iterable[addnodes.production], node)</span>
<span class="gi">+        names = (production[&#39;tokenname&#39;] for production in productionlist)</span>
<span class="gi">+        maxlen = max(len(name) for name in names)</span>
<span class="gi">+        lastname = None</span>
<span class="gi">+        for production in productionlist:</span>
<span class="gi">+            if production[&#39;tokenname&#39;]:</span>
<span class="gi">+                lastname = production[&#39;tokenname&#39;].ljust(maxlen)</span>
<span class="gi">+                self.body.append(self.starttag(production, &#39;strong&#39;, &#39;&#39;))</span>
<span class="gi">+                self.body.append(lastname + &#39;&lt;/strong&gt; ::= &#39;)</span>
<span class="gi">+            elif lastname is not None:</span>
<span class="gi">+                self.body.append(&#39;%s     &#39; % (&#39; &#39; * len(lastname)))</span>
<span class="gi">+            production.walkabout(self)</span>
<span class="gi">+            self.body.append(&#39;\n&#39;)</span>
<span class="gi">+        self.body.append(&#39;&lt;/pre&gt;\n&#39;)</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def depart_productionlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_production(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_production(self, node: Element) -&gt; None:</span>
<span class="w"> </span>        pass
<span class="gi">+</span>
<span class="gi">+    def visit_centered(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(self.starttag(node, &#39;p&#39;, CLASS=&quot;centered&quot;) +</span>
<span class="gi">+                         &#39;&lt;strong&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_centered(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;&lt;/strong&gt;&lt;/p&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_compact_paragraph(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_compact_paragraph(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_download_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        atts = {&#39;class&#39;: &#39;reference download&#39;,</span>
<span class="gi">+                &#39;download&#39;: &#39;&#39;}</span>
<span class="gi">+</span>
<span class="gi">+        if not self.builder.download_support:</span>
<span class="gi">+            self.context.append(&#39;&#39;)</span>
<span class="gi">+        elif &#39;refuri&#39; in node:</span>
<span class="gi">+            atts[&#39;class&#39;] += &#39; external&#39;</span>
<span class="gi">+            atts[&#39;href&#39;] = node[&#39;refuri&#39;]</span>
<span class="gi">+            self.body.append(self.starttag(node, &#39;a&#39;, &#39;&#39;, **atts))</span>
<span class="gi">+            self.context.append(&#39;&lt;/a&gt;&#39;)</span>
<span class="gi">+        elif &#39;filename&#39; in node:</span>
<span class="gi">+            atts[&#39;class&#39;] += &#39; internal&#39;</span>
<span class="gi">+            atts[&#39;href&#39;] = posixpath.join(self.builder.dlpath,</span>
<span class="gi">+                                          urllib.parse.quote(node[&#39;filename&#39;]))</span>
<span class="gi">+            self.body.append(self.starttag(node, &#39;a&#39;, &#39;&#39;, **atts))</span>
<span class="gi">+            self.context.append(&#39;&lt;/a&gt;&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.context.append(&#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_download_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(self.context.pop())</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten</span>
<span class="gi">+    def visit_figure(self, node: Element) -&gt; None:</span>
<span class="gi">+        # set align=default if align not specified to give a default style</span>
<span class="gi">+        node.setdefault(&#39;align&#39;, &#39;default&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        return super().visit_figure(node)</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten</span>
<span class="gi">+    def visit_image(self, node: Element) -&gt; None:</span>
<span class="gi">+        olduri = node[&#39;uri&#39;]</span>
<span class="gi">+        # rewrite the URI if the environment knows about it</span>
<span class="gi">+        if olduri in self.builder.images:</span>
<span class="gi">+            node[&#39;uri&#39;] = posixpath.join(self.builder.imgpath,</span>
<span class="gi">+                                         urllib.parse.quote(self.builder.images[olduri]))</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;scale&#39; in node:</span>
<span class="gi">+            # Try to figure out image height and width.  Docutils does that too,</span>
<span class="gi">+            # but it tries the final file name, which does not necessarily exist</span>
<span class="gi">+            # yet at the time the HTML file is written.</span>
<span class="gi">+            if not (&#39;width&#39; in node and &#39;height&#39; in node):</span>
<span class="gi">+                path = os.path.join(self.builder.srcdir, olduri)  # type: ignore[has-type]</span>
<span class="gi">+                size = get_image_size(path)</span>
<span class="gi">+                if size is None:</span>
<span class="gi">+                    logger.warning(</span>
<span class="gi">+                        __(&#39;Could not obtain image size. :scale: option is ignored.&#39;),</span>
<span class="gi">+                        location=node,</span>
<span class="gi">+                    )</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if &#39;width&#39; not in node:</span>
<span class="gi">+                        node[&#39;width&#39;] = str(size[0])</span>
<span class="gi">+                    if &#39;height&#39; not in node:</span>
<span class="gi">+                        node[&#39;height&#39;] = str(size[1])</span>
<span class="gi">+</span>
<span class="gi">+        super().visit_image(node)</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten</span>
<span class="gi">+    def depart_image(self, node: Element) -&gt; None:</span>
<span class="gi">+        if node[&#39;uri&#39;].lower().endswith((&#39;svg&#39;, &#39;svgz&#39;)):</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            super().depart_image(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_toctree(self, node: Element) -&gt; None:</span>
<span class="gi">+        # this only happens when formatting a toc from env.tocs -- in this</span>
<span class="gi">+        # case we don&#39;t want to include the subtree</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_index(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_tabular_col_spec(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_glossary(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_glossary(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_acks(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_acks(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_hlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;&lt;table class=&quot;hlist&quot;&gt;&lt;tr&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_hlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;&lt;/tr&gt;&lt;/table&gt;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_hlistcol(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;&lt;td&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_hlistcol(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;&lt;/td&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten</span>
<span class="gi">+    def visit_Text(self, node: Text) -&gt; None:</span>
<span class="gi">+        text = node.astext()</span>
<span class="gi">+        encoded = self.encode(text)</span>
<span class="gi">+        if self.protect_literal_text:</span>
<span class="gi">+            # moved here from base class&#39;s visit_literal to support</span>
<span class="gi">+            # more formatting in literal nodes</span>
<span class="gi">+            for token in self.words_and_spaces.findall(encoded):</span>
<span class="gi">+                if token.strip():</span>
<span class="gi">+                    # protect literal text from line wrapping</span>
<span class="gi">+                    self.body.append(&#39;&lt;span class=&quot;pre&quot;&gt;%s&lt;/span&gt;&#39; % token)</span>
<span class="gi">+                elif token in &#39; \n&#39;:</span>
<span class="gi">+                    # allow breaks at whitespace</span>
<span class="gi">+                    self.body.append(token)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # protect runs of multiple spaces; the last one can wrap</span>
<span class="gi">+                    self.body.append(&#39;&amp;#160;&#39; * (len(token) - 1) + &#39; &#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if self.in_mailto and self.settings.cloak_email_addresses:</span>
<span class="gi">+                encoded = self.cloak_email(encoded)</span>
<span class="gi">+            self.body.append(encoded)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_note(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_admonition(node, &#39;note&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_note(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.depart_admonition(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_warning(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_admonition(node, &#39;warning&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_warning(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.depart_admonition(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_attention(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_admonition(node, &#39;attention&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_attention(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.depart_admonition(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_caution(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_admonition(node, &#39;caution&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_caution(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.depart_admonition(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_danger(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_admonition(node, &#39;danger&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_danger(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.depart_admonition(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_error(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_admonition(node, &#39;error&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_error(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.depart_admonition(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_hint(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_admonition(node, &#39;hint&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_hint(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.depart_admonition(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_important(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_admonition(node, &#39;important&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_important(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.depart_admonition(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_tip(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_admonition(node, &#39;tip&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_tip(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.depart_admonition(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_literal_emphasis(self, node: Element) -&gt; None:</span>
<span class="gi">+        return self.visit_emphasis(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_literal_emphasis(self, node: Element) -&gt; None:</span>
<span class="gi">+        return self.depart_emphasis(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_literal_strong(self, node: Element) -&gt; None:</span>
<span class="gi">+        return self.visit_strong(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_literal_strong(self, node: Element) -&gt; None:</span>
<span class="gi">+        return self.depart_strong(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_abbreviation(self, node: Element) -&gt; None:</span>
<span class="gi">+        attrs = {}</span>
<span class="gi">+        if node.hasattr(&#39;explanation&#39;):</span>
<span class="gi">+            attrs[&#39;title&#39;] = node[&#39;explanation&#39;]</span>
<span class="gi">+        self.body.append(self.starttag(node, &#39;abbr&#39;, &#39;&#39;, **attrs))</span>
<span class="gi">+</span>
<span class="gi">+    def depart_abbreviation(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;&lt;/abbr&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_manpage(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_literal_emphasis(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_manpage(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.depart_literal_emphasis(node)</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten to add even/odd classes</span>
<span class="gi">+</span>
<span class="gi">+    def visit_table(self, node: Element) -&gt; None:</span>
<span class="gi">+        self._table_row_indices.append(0)</span>
<span class="gi">+</span>
<span class="gi">+        atts = {}</span>
<span class="gi">+        classes = [cls.strip(&#39; \t\n&#39;) for cls in self.settings.table_style.split(&#39;,&#39;)]</span>
<span class="gi">+        classes.insert(0, &quot;docutils&quot;)  # compat</span>
<span class="gi">+</span>
<span class="gi">+        # set align-default if align not specified to give a default style</span>
<span class="gi">+        classes.append(&#39;align-%s&#39; % node.get(&#39;align&#39;, &#39;default&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;width&#39; in node:</span>
<span class="gi">+            atts[&#39;style&#39;] = &#39;width: %s&#39; % node[&#39;width&#39;]</span>
<span class="gi">+        tag = self.starttag(node, &#39;table&#39;, CLASS=&#39; &#39;.join(classes), **atts)</span>
<span class="gi">+        self.body.append(tag)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_table(self, node: Element) -&gt; None:</span>
<span class="gi">+        self._table_row_indices.pop()</span>
<span class="gi">+        super().depart_table(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_row(self, node: Element) -&gt; None:</span>
<span class="gi">+        self._table_row_indices[-1] += 1</span>
<span class="gi">+        if self._table_row_indices[-1] % 2 == 0:</span>
<span class="gi">+            node[&#39;classes&#39;].append(&#39;row-even&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            node[&#39;classes&#39;].append(&#39;row-odd&#39;)</span>
<span class="gi">+        self.body.append(self.starttag(node, &#39;tr&#39;, &#39;&#39;))</span>
<span class="gi">+        node.column = 0  # type: ignore[attr-defined]</span>
<span class="gi">+</span>
<span class="gi">+    def visit_field_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self._fieldlist_row_indices.append(0)</span>
<span class="gi">+        return super().visit_field_list(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_field_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self._fieldlist_row_indices.pop()</span>
<span class="gi">+        return super().depart_field_list(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_field(self, node: Element) -&gt; None:</span>
<span class="gi">+        self._fieldlist_row_indices[-1] += 1</span>
<span class="gi">+        if self._fieldlist_row_indices[-1] % 2 == 0:</span>
<span class="gi">+            node[&#39;classes&#39;].append(&#39;field-even&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            node[&#39;classes&#39;].append(&#39;field-odd&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_math(self, node: Element, math_env: str = &#39;&#39;) -&gt; None:</span>
<span class="gi">+        # see validate_math_renderer</span>
<span class="gi">+        name: str = self.builder.math_renderer_name  # type: ignore[assignment]</span>
<span class="gi">+        visit, _ = self.builder.app.registry.html_inline_math_renderers[name]</span>
<span class="gi">+        visit(self, node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_math(self, node: Element, math_env: str = &#39;&#39;) -&gt; None:</span>
<span class="gi">+        # see validate_math_renderer</span>
<span class="gi">+        name: str = self.builder.math_renderer_name  # type: ignore[assignment]</span>
<span class="gi">+        _, depart = self.builder.app.registry.html_inline_math_renderers[name]</span>
<span class="gi">+        if depart:</span>
<span class="gi">+            depart(self, node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_math_block(self, node: Element, math_env: str = &#39;&#39;) -&gt; None:</span>
<span class="gi">+        # see validate_math_renderer</span>
<span class="gi">+        name: str = self.builder.math_renderer_name  # type: ignore[assignment]</span>
<span class="gi">+        visit, _ = self.builder.app.registry.html_block_math_renderers[name]</span>
<span class="gi">+        visit(self, node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_math_block(self, node: Element, math_env: str = &#39;&#39;) -&gt; None:</span>
<span class="gi">+        # see validate_math_renderer</span>
<span class="gi">+        name: str = self.builder.math_renderer_name  # type: ignore[assignment]</span>
<span class="gi">+        _, depart = self.builder.app.registry.html_block_math_renderers[name]</span>
<span class="gi">+        if depart:</span>
<span class="gi">+            depart(self, node)</span>
<span class="gi">+</span>
<span class="gi">+    # See Docutils r9413</span>
<span class="gi">+    # Re-instate the footnote-reference class</span>
<span class="gi">+    def visit_footnote_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        href = &#39;#&#39; + node[&#39;refid&#39;]</span>
<span class="gi">+        classes = [&#39;footnote-reference&#39;, self.settings.footnote_references]</span>
<span class="gi">+        self.body.append(self.starttag(node, &#39;a&#39;, suffix=&#39;&#39;, classes=classes,</span>
<span class="gi">+                                       role=&#39;doc-noteref&#39;, href=href))</span>
<span class="gi">+        self.body.append(&#39;&lt;span class=&quot;fn-bracket&quot;&gt;[&lt;/span&gt;&#39;)</span>
<span class="gh">diff --git a/sphinx/writers/latex.py b/sphinx/writers/latex.py</span>
<span class="gh">index c0c3fff2d..0f2ffc29f 100644</span>
<span class="gd">--- a/sphinx/writers/latex.py</span>
<span class="gi">+++ b/sphinx/writers/latex.py</span>
<span class="gu">@@ -3,13 +3,17 @@</span>
<span class="w"> </span>Much of this code is adapted from Dave Kuhlman&#39;s &quot;docpy&quot; writer from his
<span class="w"> </span>docutils sandbox.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>from collections import defaultdict
<span class="w"> </span>from collections.abc import Iterable
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING, Any, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes, writers
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes, highlighting
<span class="w"> </span>from sphinx.domains.std import StandardDomain
<span class="w"> </span>from sphinx.errors import SphinxError
<span class="gu">@@ -20,25 +24,38 @@ from sphinx.util.index_entries import split_index_msg</span>
<span class="w"> </span>from sphinx.util.nodes import clean_astext, get_prev_node
<span class="w"> </span>from sphinx.util.template import LaTeXRenderer
<span class="w"> </span>from sphinx.util.texescape import tex_replace_map
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    from docutils.utils.roman import toRoman
<span class="w"> </span>except ImportError:
<span class="gd">-    from roman import toRoman</span>
<span class="gi">+    # In Debian/Ubuntu, roman package is provided as roman, not as docutils.utils.roman</span>
<span class="gi">+    from roman import toRoman  # type: ignore[no-redef, import-not-found]</span>
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.nodes import Element, Node, Text
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.builders.latex import LaTeXBuilder
<span class="w"> </span>    from sphinx.builders.latex.theming import Theme
<span class="w"> </span>    from sphinx.domains import IndexEntry
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gi">+</span>
<span class="w"> </span>MAX_CITATION_LABEL_LENGTH = 8
<span class="gd">-LATEXSECTIONNAMES = [&#39;part&#39;, &#39;chapter&#39;, &#39;section&#39;, &#39;subsection&#39;,</span>
<span class="gd">-    &#39;subsubsection&#39;, &#39;paragraph&#39;, &#39;subparagraph&#39;]</span>
<span class="gd">-ENUMERATE_LIST_STYLE = defaultdict(lambda : &#39;\\arabic&#39;, {&#39;arabic&#39;:</span>
<span class="gd">-    &#39;\\arabic&#39;, &#39;loweralpha&#39;: &#39;\\alph&#39;, &#39;upperalpha&#39;: &#39;\\Alph&#39;,</span>
<span class="gd">-    &#39;lowerroman&#39;: &#39;\\roman&#39;, &#39;upperroman&#39;: &#39;\\Roman&#39;})</span>
<span class="gi">+LATEXSECTIONNAMES = [&quot;part&quot;, &quot;chapter&quot;, &quot;section&quot;, &quot;subsection&quot;,</span>
<span class="gi">+                     &quot;subsubsection&quot;, &quot;paragraph&quot;, &quot;subparagraph&quot;]</span>
<span class="gi">+ENUMERATE_LIST_STYLE = defaultdict(lambda: r&#39;\arabic&#39;,</span>
<span class="gi">+                                   {</span>
<span class="gi">+                                       &#39;arabic&#39;: r&#39;\arabic&#39;,</span>
<span class="gi">+                                       &#39;loweralpha&#39;: r&#39;\alph&#39;,</span>
<span class="gi">+                                       &#39;upperalpha&#39;: r&#39;\Alph&#39;,</span>
<span class="gi">+                                       &#39;lowerroman&#39;: r&#39;\roman&#39;,</span>
<span class="gi">+                                       &#39;upperroman&#39;: r&#39;\Roman&#39;,</span>
<span class="gi">+                                   })</span>
<span class="gi">+</span>
<span class="w"> </span>CR = &#39;\n&#39;
<span class="w"> </span>BLANKLINE = &#39;\n\n&#39;
<span class="gd">-EXTRA_RE = re.compile(&#39;^(.*\\S)\\s+\\(([^()]*)\\)\\s*$&#39;)</span>
<span class="gi">+EXTRA_RE = re.compile(r&#39;^(.*\S)\s+\(([^()]*)\)\s*$&#39;)</span>


<span class="w"> </span>class collected_footnote(nodes.footnote):
<span class="gu">@@ -49,23 +66,35 @@ class UnsupportedError(SphinxError):</span>
<span class="w"> </span>    category = &#39;Markup is unsupported in LaTeX&#39;


<span class="gd">-class LaTeXWriter(writers.Writer):</span>
<span class="gd">-    supported = &#39;sphinxlatex&#39;,</span>
<span class="gd">-    settings_spec = &#39;LaTeX writer options&#39;, &#39;&#39;, ((&#39;Document name&#39;, [</span>
<span class="gd">-        &#39;--docname&#39;], {&#39;default&#39;: &#39;&#39;}), (&#39;Document class&#39;, [&#39;--docclass&#39;],</span>
<span class="gd">-        {&#39;default&#39;: &#39;manual&#39;}), (&#39;Author&#39;, [&#39;--author&#39;], {&#39;default&#39;: &#39;&#39;}))</span>
<span class="gi">+class LaTeXWriter(writers.Writer):  # type: ignore[misc]</span>
<span class="gi">+</span>
<span class="gi">+    supported = (&#39;sphinxlatex&#39;,)</span>
<span class="gi">+</span>
<span class="gi">+    settings_spec = (&#39;LaTeX writer options&#39;, &#39;&#39;, (</span>
<span class="gi">+        (&#39;Document name&#39;, [&#39;--docname&#39;], {&#39;default&#39;: &#39;&#39;}),</span>
<span class="gi">+        (&#39;Document class&#39;, [&#39;--docclass&#39;], {&#39;default&#39;: &#39;manual&#39;}),</span>
<span class="gi">+        (&#39;Author&#39;, [&#39;--author&#39;], {&#39;default&#39;: &#39;&#39;}),</span>
<span class="gi">+    ))</span>
<span class="w"> </span>    settings_defaults: dict[str, Any] = {}
<span class="gi">+</span>
<span class="w"> </span>    theme: Theme

<span class="gd">-    def __init__(self, builder: LaTeXBuilder) -&gt;None:</span>
<span class="gi">+    def __init__(self, builder: LaTeXBuilder) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.builder = builder

<span class="gi">+    def translate(self) -&gt; None:</span>
<span class="gi">+        visitor = self.builder.create_translator(self.document, self.builder, self.theme)</span>
<span class="gi">+        self.document.walkabout(visitor)</span>
<span class="gi">+        self.output = cast(LaTeXTranslator, visitor).astext()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Helper classes</span>

<span class="w"> </span>class Table:
<span class="w"> </span>    &quot;&quot;&quot;A table data&quot;&quot;&quot;

<span class="gd">-    def __init__(self, node: Element) -&gt;None:</span>
<span class="gi">+    def __init__(self, node: Element) -&gt; None:</span>
<span class="w"> </span>        self.header: list[str] = []
<span class="w"> </span>        self.body: list[str] = []
<span class="w"> </span>        self.align = node.get(&#39;align&#39;, &#39;default&#39;)
<span class="gu">@@ -95,16 +124,20 @@ class Table:</span>
<span class="w"> </span>        self.has_verbatim = False
<span class="w"> </span>        self.caption: list[str] = []
<span class="w"> </span>        self.stubs: list[int] = []
<span class="gi">+</span>
<span class="gi">+        # current position</span>
<span class="w"> </span>        self.col = 0
<span class="w"> </span>        self.row = 0
<span class="gi">+</span>
<span class="gi">+        # A dict mapping a table location to a cell_id (cell = rectangular area)</span>
<span class="w"> </span>        self.cells: dict[tuple[int, int], int] = defaultdict(int)
<span class="gd">-        self.cell_id = 0</span>
<span class="gi">+        self.cell_id = 0  # last assigned cell_id</span>

<span class="gd">-    def is_longtable(self) -&gt;bool:</span>
<span class="gi">+    def is_longtable(self) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;True if and only if table uses longtable environment.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.row &gt; 30 or &#39;longtable&#39; in self.classes</span>

<span class="gd">-    def get_table_type(self) -&gt;str:</span>
<span class="gi">+    def get_table_type(self) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the LaTeX environment name for the table.

<span class="w"> </span>        The class currently supports:
<span class="gu">@@ -113,83 +146,159 @@ class Table:</span>
<span class="w"> </span>        * tabular
<span class="w"> </span>        * tabulary
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.is_longtable():</span>
<span class="gi">+            return &#39;longtable&#39;</span>
<span class="gi">+        elif self.has_verbatim:</span>
<span class="gi">+            return &#39;tabular&#39;</span>
<span class="gi">+        elif self.colspec:</span>
<span class="gi">+            return &#39;tabulary&#39;</span>
<span class="gi">+        elif self.has_problematic or (self.colwidths and &#39;colwidths-given&#39; in self.classes):</span>
<span class="gi">+            return &#39;tabular&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;tabulary&#39;</span>

<span class="gd">-    def get_colspec(self) -&gt;str:</span>
<span class="gd">-        &quot;&quot;&quot;Returns a column spec of table.</span>
<span class="gi">+    def get_colspec(self) -&gt; str:</span>
<span class="gi">+        r&quot;&quot;&quot;Returns a column spec of table.</span>

<span class="w"> </span>        This is what LaTeX calls the &#39;preamble argument&#39; of the used table environment.

<span class="w"> </span>        .. note::

<span class="gd">-           The ``\\\\X`` and ``T`` column type specifiers are defined in</span>
<span class="gi">+           The ``\\X`` and ``T`` column type specifiers are defined in</span>
<span class="w"> </span>           ``sphinxlatextables.sty``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.colspec:</span>
<span class="gi">+            return self.colspec</span>
<span class="gi">+</span>
<span class="gi">+        _colsep = self.colsep</span>
<span class="gi">+        assert _colsep is not None</span>
<span class="gi">+        if self.colwidths and &#39;colwidths-given&#39; in self.classes:</span>
<span class="gi">+            total = sum(self.colwidths)</span>
<span class="gi">+            colspecs = [r&#39;\X{%d}{%d}&#39; % (width, total) for width in self.colwidths]</span>
<span class="gi">+            return f&#39;{{{_colsep}{_colsep.join(colspecs)}{_colsep}}}&#39; + CR</span>
<span class="gi">+        elif self.has_problematic:</span>
<span class="gi">+            return r&#39;{%s*{%d}{\X{1}{%d}%s}}&#39; % (_colsep, self.colcount,</span>
<span class="gi">+                                                self.colcount, _colsep) + CR</span>
<span class="gi">+        elif self.get_table_type() == &#39;tabulary&#39;:</span>
<span class="gi">+            # sphinx.sty sets T to be J by default.</span>
<span class="gi">+            return &#39;{&#39; + _colsep + ((&#39;T&#39; + _colsep) * self.colcount) + &#39;}&#39; + CR</span>
<span class="gi">+        elif self.has_oldproblematic:</span>
<span class="gi">+            return r&#39;{%s*{%d}{\X{1}{%d}%s}}&#39; % (_colsep, self.colcount,</span>
<span class="gi">+                                                self.colcount, _colsep) + CR</span>
<span class="gi">+        else:</span>
<span class="gi">+            return &#39;{&#39; + _colsep + ((&#39;l&#39; + _colsep) * self.colcount) + &#39;}&#39; + CR</span>

<span class="gd">-    def add_cell(self, height: int, width: int) -&gt;None:</span>
<span class="gi">+    def add_cell(self, height: int, width: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Adds a new cell to a table.

<span class="w"> </span>        It will be located at current position: (``self.row``, ``self.col``).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.cell_id += 1</span>
<span class="gi">+        for col in range(width):</span>
<span class="gi">+            for row in range(height):</span>
<span class="gi">+                assert self.cells[(self.row + row, self.col + col)] == 0</span>
<span class="gi">+                self.cells[(self.row + row, self.col + col)] = self.cell_id</span>

<span class="gd">-    def cell(self, row: (int | None)=None, col: (int | None)=None) -&gt;(TableCell</span>
<span class="gd">-         | None):</span>
<span class="gi">+    def cell(</span>
<span class="gi">+        self, row: int | None = None, col: int | None = None,</span>
<span class="gi">+    ) -&gt; TableCell | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a cell object (i.e. rectangular area) containing given position.

<span class="w"> </span>        If no option arguments: ``row`` or ``col`` are given, the current position;
<span class="w"> </span>        ``self.row`` and ``self.col`` are used to get a cell object by default.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            if row is None:</span>
<span class="gi">+                row = self.row</span>
<span class="gi">+            if col is None:</span>
<span class="gi">+                col = self.col</span>
<span class="gi">+            return TableCell(self, row, col)</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            return None</span>


<span class="w"> </span>class TableCell:
<span class="w"> </span>    &quot;&quot;&quot;Data of a cell in a table.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, table: Table, row: int, col: int) -&gt;None:</span>
<span class="gd">-        if table.cells[row, col] == 0:</span>
<span class="gi">+    def __init__(self, table: Table, row: int, col: int) -&gt; None:</span>
<span class="gi">+        if table.cells[(row, col)] == 0:</span>
<span class="w"> </span>            raise IndexError
<span class="gi">+</span>
<span class="w"> </span>        self.table = table
<span class="gd">-        self.cell_id = table.cells[row, col]</span>
<span class="gi">+        self.cell_id = table.cells[(row, col)]</span>
<span class="w"> </span>        self.row = row
<span class="w"> </span>        self.col = col
<span class="gd">-        while table.cells[self.row - 1, self.col] == self.cell_id:</span>
<span class="gi">+</span>
<span class="gi">+        # adjust position for multirow/multicol cell</span>
<span class="gi">+        while table.cells[(self.row - 1, self.col)] == self.cell_id:</span>
<span class="w"> </span>            self.row -= 1
<span class="gd">-        while table.cells[self.row, self.col - 1] == self.cell_id:</span>
<span class="gi">+        while table.cells[(self.row, self.col - 1)] == self.cell_id:</span>
<span class="w"> </span>            self.col -= 1

<span class="w"> </span>    @property
<span class="gd">-    def width(self) -&gt;int:</span>
<span class="gi">+    def width(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the cell width.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        width = 0</span>
<span class="gi">+        while self.table.cells[(self.row, self.col + width)] == self.cell_id:</span>
<span class="gi">+            width += 1</span>
<span class="gi">+        return width</span>

<span class="w"> </span>    @property
<span class="gd">-    def height(self) -&gt;int:</span>
<span class="gi">+    def height(self) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns the cell height.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        height = 0</span>
<span class="gi">+        while self.table.cells[(self.row + height, self.col)] == self.cell_id:</span>
<span class="gi">+            height += 1</span>
<span class="gi">+        return height</span>


<span class="gd">-def escape_abbr(text: str) -&gt;str:</span>
<span class="gi">+def escape_abbr(text: str) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Adjust spacing after abbreviations.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return re.sub(r&#39;\.(?=\s|$)&#39;, r&#39;.\@&#39;, text)</span>


<span class="gd">-def rstdim_to_latexdim(width_str: str, scale: int=100) -&gt;str:</span>
<span class="gi">+def rstdim_to_latexdim(width_str: str, scale: int = 100) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Convert `width_str` with rst length to LaTeX length.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    match = re.match(r&#39;^(\d*\.?\d*)\s*(\S*)$&#39;, width_str)</span>
<span class="gi">+    if not match:</span>
<span class="gi">+        raise ValueError</span>
<span class="gi">+    res = width_str</span>
<span class="gi">+    amount, unit = match.groups()[:2]</span>
<span class="gi">+    if scale == 100:</span>
<span class="gi">+        float(amount)  # validate amount is float</span>
<span class="gi">+        if unit in (&#39;&#39;, &quot;px&quot;):</span>
<span class="gi">+            res = r&quot;%s\sphinxpxdimen&quot; % amount</span>
<span class="gi">+        elif unit == &#39;pt&#39;:</span>
<span class="gi">+            res = &#39;%sbp&#39; % amount  # convert to &#39;bp&#39;</span>
<span class="gi">+        elif unit == &quot;%&quot;:</span>
<span class="gi">+            res = r&quot;%.3f\linewidth&quot; % (float(amount) / 100.0)</span>
<span class="gi">+    else:</span>
<span class="gi">+        amount_float = float(amount) * scale / 100.0</span>
<span class="gi">+        if unit in (&#39;&#39;, &quot;px&quot;):</span>
<span class="gi">+            res = r&quot;%.5f\sphinxpxdimen&quot; % amount_float</span>
<span class="gi">+        elif unit == &#39;pt&#39;:</span>
<span class="gi">+            res = &#39;%.5fbp&#39; % amount_float</span>
<span class="gi">+        elif unit == &quot;%&quot;:</span>
<span class="gi">+            res = r&quot;%.5f\linewidth&quot; % (amount_float / 100.0)</span>
<span class="gi">+        else:</span>
<span class="gi">+            res = f&quot;{amount_float:.5f}{unit}&quot;</span>
<span class="gi">+    return res</span>


<span class="w"> </span>class LaTeXTranslator(SphinxTranslator):
<span class="w"> </span>    builder: LaTeXBuilder
<span class="gd">-    secnumdepth = 2</span>
<span class="gi">+</span>
<span class="gi">+    secnumdepth = 2  # legacy sphinxhowto.cls uses this, whereas article.cls</span>
<span class="gi">+    # default is originally 3. For book/report, 2 is already LaTeX default.</span>
<span class="w"> </span>    ignore_missing_images = False

<span class="w"> </span>    def __init__(self, document: nodes.document, builder: LaTeXBuilder,
<span class="gd">-        theme: Theme) -&gt;None:</span>
<span class="gi">+                 theme: Theme) -&gt; None:</span>
<span class="w"> </span>        super().__init__(document, builder)
<span class="w"> </span>        self.body: list[str] = []
<span class="w"> </span>        self.theme = theme
<span class="gi">+</span>
<span class="gi">+        # flags</span>
<span class="w"> </span>        self.in_title = 0
<span class="w"> </span>        self.in_production_list = 0
<span class="w"> </span>        self.in_footnote = 0
<span class="gu">@@ -197,6 +306,7 @@ class LaTeXTranslator(SphinxTranslator):</span>
<span class="w"> </span>        self.in_term = 0
<span class="w"> </span>        self.needs_linetrimming = 0
<span class="w"> </span>        self.in_minipage = 0
<span class="gi">+        # only used by figure inside an admonition</span>
<span class="w"> </span>        self.no_latex_floats = 0
<span class="w"> </span>        self.first_document = 1
<span class="w"> </span>        self.this_is_the_title = 1
<span class="gu">@@ -205,81 +315,108 @@ class LaTeXTranslator(SphinxTranslator):</span>
<span class="w"> </span>        self.compact_list = 0
<span class="w"> </span>        self.first_param = 0
<span class="w"> </span>        self.in_desc_signature = False
<span class="gi">+</span>
<span class="w"> </span>        sphinxpkgoptions = []
<span class="gi">+</span>
<span class="gi">+        # sort out some elements</span>
<span class="w"> </span>        self.elements = self.builder.context.copy()
<span class="gi">+</span>
<span class="gi">+        # initial section names</span>
<span class="w"> </span>        self.sectionnames = LATEXSECTIONNAMES.copy()
<span class="w"> </span>        if self.theme.toplevel_sectioning == &#39;section&#39;:
<span class="w"> </span>            self.sectionnames.remove(&#39;chapter&#39;)
<span class="gi">+</span>
<span class="gi">+        # determine top section level</span>
<span class="w"> </span>        self.top_sectionlevel = 1
<span class="w"> </span>        if self.config.latex_toplevel_sectioning:
<span class="w"> </span>            try:
<span class="gd">-                self.top_sectionlevel = self.sectionnames.index(self.config</span>
<span class="gd">-                    .latex_toplevel_sectioning)</span>
<span class="gi">+                self.top_sectionlevel = \</span>
<span class="gi">+                    self.sectionnames.index(self.config.latex_toplevel_sectioning)</span>
<span class="w"> </span>            except ValueError:
<span class="gd">-                logger.warning(__(</span>
<span class="gd">-                    &#39;unknown %r toplevel_sectioning for class %r&#39;), self.</span>
<span class="gd">-                    config.latex_toplevel_sectioning, self.theme.docclass)</span>
<span class="gi">+                logger.warning(__(&#39;unknown %r toplevel_sectioning for class %r&#39;),</span>
<span class="gi">+                               self.config.latex_toplevel_sectioning, self.theme.docclass)</span>
<span class="gi">+</span>
<span class="w"> </span>        if self.config.numfig:
<span class="w"> </span>            self.numfig_secnum_depth = self.config.numfig_secnum_depth
<span class="gd">-            if self.numfig_secnum_depth &gt; 0:</span>
<span class="gd">-                if len(self.sectionnames) &lt; len(LATEXSECTIONNAMES</span>
<span class="gd">-                    ) and self.top_sectionlevel &gt; 0:</span>
<span class="gi">+            if self.numfig_secnum_depth &gt; 0:  # default is 1</span>
<span class="gi">+                # numfig_secnum_depth as passed to sphinx.sty indices same names as in</span>
<span class="gi">+                # LATEXSECTIONNAMES but with -1 for part, 0 for chapter, 1 for section...</span>
<span class="gi">+                if len(self.sectionnames) &lt; len(LATEXSECTIONNAMES) and \</span>
<span class="gi">+                   self.top_sectionlevel &gt; 0:</span>
<span class="w"> </span>                    self.numfig_secnum_depth += self.top_sectionlevel
<span class="w"> </span>                else:
<span class="w"> </span>                    self.numfig_secnum_depth += self.top_sectionlevel - 1
<span class="gd">-                self.numfig_secnum_depth = min(self.numfig_secnum_depth, </span>
<span class="gd">-                    len(LATEXSECTIONNAMES) - 1)</span>
<span class="gd">-                sphinxpkgoptions.append(&#39;numfigreset=%s&#39; % self.</span>
<span class="gd">-                    numfig_secnum_depth)</span>
<span class="gi">+                # this (minus one) will serve as minimum to LaTeX&#39;s secnumdepth</span>
<span class="gi">+                self.numfig_secnum_depth = min(self.numfig_secnum_depth,</span>
<span class="gi">+                                               len(LATEXSECTIONNAMES) - 1)</span>
<span class="gi">+                # if passed key value is &lt; 1 LaTeX will act as if 0; see sphinx.sty</span>
<span class="gi">+                sphinxpkgoptions.append(&#39;numfigreset=%s&#39; % self.numfig_secnum_depth)</span>
<span class="w"> </span>            else:
<span class="w"> </span>                sphinxpkgoptions.append(&#39;nonumfigreset&#39;)
<span class="gi">+</span>
<span class="w"> </span>        if self.config.numfig and self.config.math_numfig:
<span class="gd">-            sphinxpkgoptions.extend([&#39;mathnumfig&#39;, &#39;mathnumsep={%s}&#39; % self</span>
<span class="gd">-                .config.math_numsep])</span>
<span class="gd">-        if self.config.language not in {&#39;en&#39;, &#39;ja&#39;</span>
<span class="gd">-            } and &#39;fncychap&#39; not in self.config.latex_elements:</span>
<span class="gd">-            self.elements[&#39;fncychap&#39;] = (&#39;\\usepackage[Sonny]{fncychap}&#39; +</span>
<span class="gd">-                CR + &#39;\\ChNameVar{\\Large\\normalfont\\sffamily}&#39; + CR +</span>
<span class="gd">-                &#39;\\ChTitleVar{\\Large\\normalfont\\sffamily}&#39;)</span>
<span class="gi">+            sphinxpkgoptions.extend([</span>
<span class="gi">+                &#39;mathnumfig&#39;,</span>
<span class="gi">+                &#39;mathnumsep={%s}&#39; % self.config.math_numsep,</span>
<span class="gi">+            ])</span>
<span class="gi">+</span>
<span class="gi">+        if (self.config.language not in {&#39;en&#39;, &#39;ja&#39;} and</span>
<span class="gi">+                &#39;fncychap&#39; not in self.config.latex_elements):</span>
<span class="gi">+            # use Sonny style if any language specified (except English)</span>
<span class="gi">+            self.elements[&#39;fncychap&#39;] = (r&#39;\usepackage[Sonny]{fncychap}&#39; + CR +</span>
<span class="gi">+                                         r&#39;\ChNameVar{\Large\normalfont\sffamily}&#39; + CR +</span>
<span class="gi">+                                         r&#39;\ChTitleVar{\Large\normalfont\sffamily}&#39;)</span>
<span class="gi">+</span>
<span class="w"> </span>        self.babel = self.builder.babel
<span class="w"> </span>        if not self.babel.is_supported_language():
<span class="gi">+            # emit warning if specified language is invalid</span>
<span class="gi">+            # (only emitting, nothing changed to processing)</span>
<span class="w"> </span>            logger.warning(__(&#39;no Babel option known for language %r&#39;),
<span class="gd">-                self.config.language)</span>
<span class="gd">-        minsecnumdepth = self.secnumdepth</span>
<span class="gi">+                           self.config.language)</span>
<span class="gi">+</span>
<span class="gi">+        minsecnumdepth = self.secnumdepth  # 2 from legacy sphinx manual/howto</span>
<span class="w"> </span>        if self.document.get(&#39;tocdepth&#39;):
<span class="gd">-            tocdepth = self.document.get(&#39;tocdepth&#39;, 999</span>
<span class="gd">-                ) + self.top_sectionlevel - 2</span>
<span class="gd">-            if len(self.sectionnames) &lt; len(LATEXSECTIONNAMES</span>
<span class="gd">-                ) and self.top_sectionlevel &gt; 0:</span>
<span class="gd">-                tocdepth += 1</span>
<span class="gd">-            if tocdepth &gt; len(LATEXSECTIONNAMES) - 2:</span>
<span class="gi">+            # reduce tocdepth if `part` or `chapter` is used for top_sectionlevel</span>
<span class="gi">+            #   tocdepth = -1: show only parts</span>
<span class="gi">+            #   tocdepth =  0: show parts and chapters</span>
<span class="gi">+            #   tocdepth =  1: show parts, chapters and sections</span>
<span class="gi">+            #   tocdepth =  2: show parts, chapters, sections and subsections</span>
<span class="gi">+            #   ...</span>
<span class="gi">+            tocdepth = self.document.get(&#39;tocdepth&#39;, 999) + self.top_sectionlevel - 2</span>
<span class="gi">+            if len(self.sectionnames) &lt; len(LATEXSECTIONNAMES) and \</span>
<span class="gi">+               self.top_sectionlevel &gt; 0:</span>
<span class="gi">+                tocdepth += 1  # because top_sectionlevel is shifted by -1</span>
<span class="gi">+            if tocdepth &gt; len(LATEXSECTIONNAMES) - 2:  # default is 5 &lt;-&gt; subparagraph</span>
<span class="w"> </span>                logger.warning(__(&#39;too large :maxdepth:, ignored.&#39;))
<span class="w"> </span>                tocdepth = len(LATEXSECTIONNAMES) - 2
<span class="gd">-            self.elements[&#39;tocdepth&#39;] = &#39;\\setcounter{tocdepth}{%d}&#39; % tocdepth</span>
<span class="gi">+</span>
<span class="gi">+            self.elements[&#39;tocdepth&#39;] = r&#39;\setcounter{tocdepth}{%d}&#39; % tocdepth</span>
<span class="w"> </span>            minsecnumdepth = max(minsecnumdepth, tocdepth)
<span class="gd">-        if self.config.numfig and self.config.numfig_secnum_depth &gt; 0:</span>
<span class="gi">+</span>
<span class="gi">+        if self.config.numfig and (self.config.numfig_secnum_depth &gt; 0):</span>
<span class="w"> </span>            minsecnumdepth = max(minsecnumdepth, self.numfig_secnum_depth - 1)
<span class="gi">+</span>
<span class="w"> </span>        if minsecnumdepth &gt; self.secnumdepth:
<span class="gd">-            self.elements[&#39;secnumdepth&#39;</span>
<span class="gd">-                ] = &#39;\\setcounter{secnumdepth}{%d}&#39; % minsecnumdepth</span>
<span class="gi">+            self.elements[&#39;secnumdepth&#39;] = r&#39;\setcounter{secnumdepth}{%d}&#39; %\</span>
<span class="gi">+                                           minsecnumdepth</span>
<span class="gi">+</span>
<span class="w"> </span>        contentsname = document.get(&#39;contentsname&#39;)
<span class="w"> </span>        if contentsname:
<span class="gd">-            self.elements[&#39;contentsname&#39;] = self.babel_renewcommand(</span>
<span class="gd">-                &#39;\\contentsname&#39;, contentsname)</span>
<span class="gi">+            self.elements[&#39;contentsname&#39;] = self.babel_renewcommand(r&#39;\contentsname&#39;,</span>
<span class="gi">+                                                                    contentsname)</span>
<span class="gi">+</span>
<span class="w"> </span>        if self.elements[&#39;maxlistdepth&#39;]:
<span class="gd">-            sphinxpkgoptions.append(&#39;maxlistdepth=%s&#39; % self.elements[</span>
<span class="gd">-                &#39;maxlistdepth&#39;])</span>
<span class="gi">+            sphinxpkgoptions.append(&#39;maxlistdepth=%s&#39; % self.elements[&#39;maxlistdepth&#39;])</span>
<span class="w"> </span>        if sphinxpkgoptions:
<span class="gd">-            self.elements[&#39;sphinxpkgoptions&#39;] = &#39;[,%s]&#39; % &#39;,&#39;.join(</span>
<span class="gd">-                sphinxpkgoptions)</span>
<span class="gi">+            self.elements[&#39;sphinxpkgoptions&#39;] = &#39;[,%s]&#39; % &#39;,&#39;.join(sphinxpkgoptions)</span>
<span class="w"> </span>        if self.elements[&#39;sphinxsetup&#39;]:
<span class="gd">-            self.elements[&#39;sphinxsetup&#39;] = &#39;\\sphinxsetup{%s}&#39; % self.elements[</span>
<span class="gd">-                &#39;sphinxsetup&#39;]</span>
<span class="gi">+            self.elements[&#39;sphinxsetup&#39;] = (r&#39;\sphinxsetup{%s}&#39; % self.elements[&#39;sphinxsetup&#39;])</span>
<span class="w"> </span>        if self.elements[&#39;extraclassoptions&#39;]:
<span class="gd">-            self.elements[&#39;classoptions&#39;] += &#39;,&#39; + self.elements[</span>
<span class="gd">-                &#39;extraclassoptions&#39;]</span>
<span class="gd">-        self.highlighter = highlighting.PygmentsBridge(&#39;latex&#39;, self.config</span>
<span class="gd">-            .pygments_style, latex_engine=self.config.latex_engine)</span>
<span class="gi">+            self.elements[&#39;classoptions&#39;] += &#39;,&#39; + \</span>
<span class="gi">+                                             self.elements[&#39;extraclassoptions&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        self.highlighter = highlighting.PygmentsBridge(&#39;latex&#39;, self.config.pygments_style,</span>
<span class="gi">+                                                       latex_engine=self.config.latex_engine)</span>
<span class="w"> </span>        self.context: list[Any] = []
<span class="w"> </span>        self.descstack: list[str] = []
<span class="w"> </span>        self.tables: list[Table] = []
<span class="gu">@@ -290,14 +427,433 @@ class LaTeXTranslator(SphinxTranslator):</span>
<span class="w"> </span>        self.curfilestack: list[str] = []
<span class="w"> </span>        self.handled_abbrs: set[str] = set()

<span class="gi">+    def pushbody(self, newbody: list[str]) -&gt; None:</span>
<span class="gi">+        self.bodystack.append(self.body)</span>
<span class="gi">+        self.body = newbody</span>
<span class="gi">+</span>
<span class="gi">+    def popbody(self) -&gt; list[str]:</span>
<span class="gi">+        body = self.body</span>
<span class="gi">+        self.body = self.bodystack.pop()</span>
<span class="gi">+        return body</span>
<span class="gi">+</span>
<span class="gi">+    def astext(self) -&gt; str:</span>
<span class="gi">+        self.elements.update({</span>
<span class="gi">+            &#39;body&#39;: &#39;&#39;.join(self.body),</span>
<span class="gi">+            &#39;indices&#39;: self.generate_indices(),</span>
<span class="gi">+        })</span>
<span class="gi">+        return self.render(&#39;latex.tex.jinja&#39;, self.elements)</span>
<span class="gi">+</span>
<span class="gi">+    def hypertarget(self, id: str, withdoc: bool = True, anchor: bool = True) -&gt; str:</span>
<span class="gi">+        if withdoc:</span>
<span class="gi">+            id = self.curfilestack[-1] + &#39;:&#39; + id</span>
<span class="gi">+        return (r&#39;\phantomsection&#39; if anchor else &#39;&#39;) + r&#39;\label{%s}&#39; % self.idescape(id)</span>
<span class="gi">+</span>
<span class="gi">+    def hypertarget_to(self, node: Element, anchor: bool = False) -&gt; str:</span>
<span class="gi">+        labels = &#39;&#39;.join(self.hypertarget(node_id, anchor=False) for node_id in node[&#39;ids&#39;])</span>
<span class="gi">+        if anchor:</span>
<span class="gi">+            return r&#39;\phantomsection&#39; + labels</span>
<span class="gi">+        else:</span>
<span class="gi">+            return labels</span>
<span class="gi">+</span>
<span class="gi">+    def hyperlink(self, id: str) -&gt; str:</span>
<span class="gi">+        return r&#39;{\hyperref[%s]{&#39; % self.idescape(id)</span>
<span class="gi">+</span>
<span class="gi">+    def hyperpageref(self, id: str) -&gt; str:</span>
<span class="gi">+        return r&#39;\autopageref*{%s}&#39; % self.idescape(id)</span>
<span class="gi">+</span>
<span class="gi">+    def escape(self, s: str) -&gt; str:</span>
<span class="gi">+        return texescape.escape(s, self.config.latex_engine)</span>
<span class="gi">+</span>
<span class="gi">+    def idescape(self, id: str) -&gt; str:</span>
<span class="gi">+        return r&#39;\detokenize{%s}&#39; % str(id).translate(tex_replace_map).\</span>
<span class="gi">+            encode(&#39;ascii&#39;, &#39;backslashreplace&#39;).decode(&#39;ascii&#39;).\</span>
<span class="gi">+            replace(&#39;\\&#39;, &#39;_&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def babel_renewcommand(self, command: str, definition: str) -&gt; str:</span>
<span class="gi">+        if self.elements[&#39;multilingual&#39;]:</span>
<span class="gi">+            prefix = r&#39;\addto\captions%s{&#39; % self.babel.get_language()</span>
<span class="gi">+            suffix = &#39;}&#39;</span>
<span class="gi">+        else:  # babel is disabled (mainly for Japanese environment)</span>
<span class="gi">+            prefix = &#39;&#39;</span>
<span class="gi">+            suffix = &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        return fr&#39;{prefix}\renewcommand{{{command}}}{{{definition}}}{suffix}&#39; + CR</span>
<span class="gi">+</span>
<span class="gi">+    def generate_indices(self) -&gt; str:</span>
<span class="gi">+        def generate(content: list[tuple[str, list[IndexEntry]]], collapsed: bool) -&gt; None:</span>
<span class="gi">+            ret.append(r&#39;\begin{sphinxtheindex}&#39; + CR)</span>
<span class="gi">+            ret.append(r&#39;\let\bigletter\sphinxstyleindexlettergroup&#39; + CR)</span>
<span class="gi">+            for i, (letter, entries) in enumerate(content):</span>
<span class="gi">+                if i &gt; 0:</span>
<span class="gi">+                    ret.append(r&#39;\indexspace&#39; + CR)</span>
<span class="gi">+                ret.append(r&#39;\bigletter{%s}&#39; % self.escape(letter) + CR)</span>
<span class="gi">+                for entry in entries:</span>
<span class="gi">+                    if not entry[3]:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    ret.append(r&#39;\item\relax\sphinxstyleindexentry{%s}&#39; %</span>
<span class="gi">+                               self.encode(entry[0]))</span>
<span class="gi">+                    if entry[4]:</span>
<span class="gi">+                        # add &quot;extra&quot; info</span>
<span class="gi">+                        ret.append(r&#39;\sphinxstyleindexextra{%s}&#39; % self.encode(entry[4]))</span>
<span class="gi">+                    ret.append(r&#39;\sphinxstyleindexpageref{%s:%s}&#39; %</span>
<span class="gi">+                               (entry[2], self.idescape(entry[3])) + CR)</span>
<span class="gi">+            ret.append(r&#39;\end{sphinxtheindex}&#39; + CR)</span>
<span class="gi">+</span>
<span class="gi">+        ret = []</span>
<span class="gi">+        # latex_domain_indices can be False/True or a list of index names</span>
<span class="gi">+        if indices_config := self.config.latex_domain_indices:</span>
<span class="gi">+            if not isinstance(indices_config, bool):</span>
<span class="gi">+                check_names = True</span>
<span class="gi">+                indices_config = frozenset(indices_config)</span>
<span class="gi">+            else:</span>
<span class="gi">+                check_names = False</span>
<span class="gi">+            for domain_name in sorted(self.builder.env.domains):</span>
<span class="gi">+                domain = self.builder.env.domains[domain_name]</span>
<span class="gi">+                for index_cls in domain.indices:</span>
<span class="gi">+                    index_name = f&#39;{domain.name}-{index_cls.name}&#39;</span>
<span class="gi">+                    if check_names and index_name not in indices_config:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    content, collapsed = index_cls(domain).generate(</span>
<span class="gi">+                        self.builder.docnames)</span>
<span class="gi">+                    if content:</span>
<span class="gi">+                        ret.append(r&#39;\renewcommand{\indexname}{%s}&#39; % index_cls.localname + CR)</span>
<span class="gi">+                        generate(content, collapsed)</span>
<span class="gi">+</span>
<span class="gi">+        return &#39;&#39;.join(ret)</span>
<span class="gi">+</span>
<span class="gi">+    def render(self, template_name: str, variables: dict[str, Any]) -&gt; str:</span>
<span class="gi">+        renderer = LaTeXRenderer(latex_engine=self.config.latex_engine)</span>
<span class="gi">+        for template_dir in self.config.templates_path:</span>
<span class="gi">+            template = path.join(self.builder.confdir, template_dir,</span>
<span class="gi">+                                 template_name)</span>
<span class="gi">+            if path.exists(template):</span>
<span class="gi">+                return renderer.render(template, variables)</span>
<span class="gi">+            elif template.endswith(&#39;.jinja&#39;):</span>
<span class="gi">+                legacy_template = template.removesuffix(&#39;.jinja&#39;) + &#39;_t&#39;</span>
<span class="gi">+                if path.exists(legacy_template):</span>
<span class="gi">+                    logger.warning(__(&#39;template %s not found; loading from legacy %s instead&#39;),</span>
<span class="gi">+                                   template_name, legacy_template)</span>
<span class="gi">+                    return renderer.render(legacy_template, variables)</span>
<span class="gi">+</span>
<span class="gi">+        return renderer.render(template_name, variables)</span>
<span class="gi">+</span>
<span class="w"> </span>    @property
<span class="gd">-    def table(self) -&gt;(Table | None):</span>
<span class="gi">+    def table(self) -&gt; Table | None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Get current table.&quot;&quot;&quot;
<span class="gi">+        if self.tables:</span>
<span class="gi">+            return self.tables[-1]</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    def visit_document(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.curfilestack.append(node.get(&#39;docname&#39;, &#39;&#39;))</span>
<span class="gi">+        if self.first_document == 1:</span>
<span class="gi">+            # the first document is all the regular content ...</span>
<span class="gi">+            self.first_document = 0</span>
<span class="gi">+        elif self.first_document == 0:</span>
<span class="gi">+            # ... and all others are the appendices</span>
<span class="gi">+            self.body.append(CR + r&#39;\appendix&#39; + CR)</span>
<span class="gi">+            self.first_document = -1</span>
<span class="gi">+        if &#39;docname&#39; in node:</span>
<span class="gi">+            self.body.append(self.hypertarget(&#39;:doc&#39;))</span>
<span class="gi">+        # &quot;- 1&quot; because the level is increased before the title is visited</span>
<span class="gi">+        self.sectionlevel = self.top_sectionlevel - 1</span>
<span class="gi">+</span>
<span class="gi">+    def depart_document(self, node: Element) -&gt; None:</span>
<span class="w"> </span>        pass
<span class="gi">+</span>
<span class="gi">+    def visit_start_of_file(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.curfilestack.append(node[&#39;docname&#39;])</span>
<span class="gi">+        self.body.append(CR + r&#39;\sphinxstepscope&#39; + CR)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_start_of_file(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.curfilestack.pop()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_section(self, node: Element) -&gt; None:</span>
<span class="gi">+        if not self.this_is_the_title:</span>
<span class="gi">+            self.sectionlevel += 1</span>
<span class="gi">+        self.body.append(BLANKLINE)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_section(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.sectionlevel = max(self.sectionlevel - 1,</span>
<span class="gi">+                                self.top_sectionlevel - 1)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_problematic(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;{\color{red}\bfseries{}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_problematic(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_topic(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.in_minipage += 1</span>
<span class="gi">+        if &#39;contents&#39; in node.get(&#39;classes&#39;, []):</span>
<span class="gi">+            self.body.append(CR + r&#39;\begin{sphinxcontents}&#39; + CR)</span>
<span class="gi">+            self.context.append(r&#39;\end{sphinxcontents}&#39; + CR)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.body.append(CR + r&#39;\begin{sphinxtopic}&#39; + CR)</span>
<span class="gi">+            self.context.append(r&#39;\end{sphinxtopic}&#39; + CR)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_topic(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.in_minipage -= 1</span>
<span class="gi">+        self.body.append(self.context.pop())</span>
<span class="gi">+</span>
<span class="gi">+    def visit_sidebar(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.in_minipage += 1</span>
<span class="gi">+        self.body.append(CR + r&#39;\begin{sphinxsidebar}&#39; + CR)</span>
<span class="gi">+        self.context.append(r&#39;\end{sphinxsidebar}&#39; + CR)</span>
<span class="w"> </span>    depart_sidebar = depart_topic

<span class="gd">-    def _visit_sig_parameter_list(self, node: Element, parameter_group:</span>
<span class="gd">-        type[Element]) -&gt;None:</span>
<span class="gi">+    def visit_glossary(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_glossary(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_productionlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(BLANKLINE)</span>
<span class="gi">+        self.body.append(r&#39;\begin{productionlist}&#39; + CR)</span>
<span class="gi">+        self.in_production_list = 1</span>
<span class="gi">+</span>
<span class="gi">+    def depart_productionlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;\end{productionlist}&#39; + BLANKLINE)</span>
<span class="gi">+        self.in_production_list = 0</span>
<span class="gi">+</span>
<span class="gi">+    def visit_production(self, node: Element) -&gt; None:</span>
<span class="gi">+        if node[&#39;tokenname&#39;]:</span>
<span class="gi">+            tn = node[&#39;tokenname&#39;]</span>
<span class="gi">+            self.body.append(self.hypertarget(&#39;grammar-token-&#39; + tn))</span>
<span class="gi">+            self.body.append(r&#39;\production{%s}{&#39; % self.encode(tn))</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.body.append(r&#39;\productioncont{&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_production(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;}&#39; + CR)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_transition(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(self.elements[&#39;transition&#39;])</span>
<span class="gi">+</span>
<span class="gi">+    def depart_transition(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_title(self, node: Element) -&gt; None:</span>
<span class="gi">+        parent = node.parent</span>
<span class="gi">+        if isinstance(parent, addnodes.seealso):</span>
<span class="gi">+            # the environment already handles this</span>
<span class="gi">+            raise nodes.SkipNode</span>
<span class="gi">+        if isinstance(parent, nodes.section):</span>
<span class="gi">+            if self.this_is_the_title:</span>
<span class="gi">+                if len(node.children) != 1 and not isinstance(node.children[0],</span>
<span class="gi">+                                                              nodes.Text):</span>
<span class="gi">+                    logger.warning(__(&#39;document title is not a single Text node&#39;),</span>
<span class="gi">+                                   location=node)</span>
<span class="gi">+                if not self.elements[&#39;title&#39;]:</span>
<span class="gi">+                    # text needs to be escaped since it is inserted into</span>
<span class="gi">+                    # the output literally</span>
<span class="gi">+                    self.elements[&#39;title&#39;] = self.escape(node.astext())</span>
<span class="gi">+                self.this_is_the_title = 0</span>
<span class="gi">+                raise nodes.SkipNode</span>
<span class="gi">+            short = &#39;&#39;</span>
<span class="gi">+            if any(node.findall(nodes.image)):</span>
<span class="gi">+                short = (&#39;[%s]&#39; % self.escape(&#39; &#39;.join(clean_astext(node).split())))</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                self.body.append(fr&#39;\{self.sectionnames[self.sectionlevel]}{short}{{&#39;)</span>
<span class="gi">+            except IndexError:</span>
<span class="gi">+                # just use &quot;subparagraph&quot;, it&#39;s not numbered anyway</span>
<span class="gi">+                self.body.append(fr&#39;\{self.sectionnames[-1]}{short}{{&#39;)</span>
<span class="gi">+            self.context.append(&#39;}&#39; + CR + self.hypertarget_to(node.parent))</span>
<span class="gi">+        elif isinstance(parent, nodes.topic):</span>
<span class="gi">+            if &#39;contents&#39; in parent.get(&#39;classes&#39;, []):</span>
<span class="gi">+                self.body.append(r&#39;\sphinxstylecontentstitle{&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.body.append(r&#39;\sphinxstyletopictitle{&#39;)</span>
<span class="gi">+            self.context.append(&#39;}&#39; + CR)</span>
<span class="gi">+        elif isinstance(parent, nodes.sidebar):</span>
<span class="gi">+            self.body.append(r&#39;\sphinxstylesidebartitle{&#39;)</span>
<span class="gi">+            self.context.append(&#39;}&#39; + CR)</span>
<span class="gi">+        elif isinstance(parent, nodes.Admonition):</span>
<span class="gi">+            self.body.append(&#39;{&#39;)</span>
<span class="gi">+            self.context.append(&#39;}&#39; + CR)</span>
<span class="gi">+        elif isinstance(parent, nodes.table):</span>
<span class="gi">+            # Redirect body output until title is finished.</span>
<span class="gi">+            self.pushbody([])</span>
<span class="gi">+        else:</span>
<span class="gi">+            logger.warning(__(&#39;encountered title node not in section, topic, table, &#39;</span>
<span class="gi">+                              &#39;admonition or sidebar&#39;),</span>
<span class="gi">+                           location=node)</span>
<span class="gi">+            self.body.append(r&#39;\sphinxstyleothertitle{&#39;)</span>
<span class="gi">+            self.context.append(&#39;}&#39; + CR)</span>
<span class="gi">+        self.in_title = 1</span>
<span class="gi">+</span>
<span class="gi">+    def depart_title(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.in_title = 0</span>
<span class="gi">+        if isinstance(node.parent, nodes.table):</span>
<span class="gi">+            assert self.table is not None</span>
<span class="gi">+            self.table.caption = self.popbody()</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.body.append(self.context.pop())</span>
<span class="gi">+</span>
<span class="gi">+    def visit_subtitle(self, node: Element) -&gt; None:</span>
<span class="gi">+        if isinstance(node.parent, nodes.sidebar):</span>
<span class="gi">+            self.body.append(r&#39;\sphinxstylesidebarsubtitle{&#39;)</span>
<span class="gi">+            self.context.append(&#39;}&#39; + CR)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.context.append(&#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_subtitle(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(self.context.pop())</span>
<span class="gi">+</span>
<span class="gi">+    #############################################################</span>
<span class="gi">+    # Domain-specific object descriptions</span>
<span class="gi">+    #############################################################</span>
<span class="gi">+</span>
<span class="gi">+    # Top-level nodes for descriptions</span>
<span class="gi">+    ##################################</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc(self, node: Element) -&gt; None:</span>
<span class="gi">+        if self.config.latex_show_urls == &#39;footnote&#39;:</span>
<span class="gi">+            self.body.append(BLANKLINE)</span>
<span class="gi">+            self.body.append(r&#39;\begin{savenotes}\begin{fulllineitems}&#39; + CR)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.body.append(BLANKLINE)</span>
<span class="gi">+            self.body.append(r&#39;\begin{fulllineitems}&#39; + CR)</span>
<span class="gi">+        if self.table:</span>
<span class="gi">+            self.table.has_problematic = True</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc(self, node: Element) -&gt; None:</span>
<span class="gi">+        if self.in_desc_signature:</span>
<span class="gi">+            self.body.append(CR + r&#39;\pysigstopsignatures&#39;)</span>
<span class="gi">+            self.in_desc_signature = False</span>
<span class="gi">+        if self.config.latex_show_urls == &#39;footnote&#39;:</span>
<span class="gi">+            self.body.append(CR + r&#39;\end{fulllineitems}\end{savenotes}&#39; + BLANKLINE)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.body.append(CR + r&#39;\end{fulllineitems}&#39; + BLANKLINE)</span>
<span class="gi">+</span>
<span class="gi">+    def _visit_signature_line(self, node: Element) -&gt; None:</span>
<span class="gi">+        def next_sibling(e: Node) -&gt; Node | None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return e.parent[e.parent.index(e) + 1]</span>
<span class="gi">+            except (AttributeError, IndexError):</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+        def has_multi_line(e: Element) -&gt; bool:</span>
<span class="gi">+            return e.get(&#39;multi_line_parameter_list&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        self.has_tp_list = False</span>
<span class="gi">+        self.orphan_tp_list = False</span>
<span class="gi">+</span>
<span class="gi">+        for child in node:</span>
<span class="gi">+            if isinstance(child, addnodes.desc_type_parameter_list):</span>
<span class="gi">+                self.has_tp_list = True</span>
<span class="gi">+                multi_tp_list = has_multi_line(child)</span>
<span class="gi">+                arglist = next_sibling(child)</span>
<span class="gi">+                if isinstance(arglist, addnodes.desc_parameterlist):</span>
<span class="gi">+                    # tp_list + arglist: \macro{name}{tp_list}{arglist}{retann}</span>
<span class="gi">+                    multi_arglist = has_multi_line(arglist)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    # orphan tp_list:    \macro{name}{tp_list}{}{retann}</span>
<span class="gi">+                    # see: https://github.com/sphinx-doc/sphinx/issues/12543</span>
<span class="gi">+                    self.orphan_tp_list = True</span>
<span class="gi">+                    multi_arglist = False</span>
<span class="gi">+</span>
<span class="gi">+                if multi_tp_list:</span>
<span class="gi">+                    if multi_arglist:</span>
<span class="gi">+                        self.body.append(CR + r&#39;\pysigwithonelineperargwithonelinepertparg{&#39;)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        self.body.append(CR + r&#39;\pysiglinewithargsretwithonelinepertparg{&#39;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    if multi_arglist:</span>
<span class="gi">+                        self.body.append(CR + r&#39;\pysigwithonelineperargwithtypelist{&#39;)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        self.body.append(CR + r&#39;\pysiglinewithargsretwithtypelist{&#39;)</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(child, addnodes.desc_parameterlist):</span>
<span class="gi">+                # arglist only: \macro{name}{arglist}{retann}</span>
<span class="gi">+                if has_multi_line(child):</span>
<span class="gi">+                    self.body.append(CR + r&#39;\pysigwithonelineperarg{&#39;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.body.append(CR + r&#39;\pysiglinewithargsret{&#39;)</span>
<span class="gi">+                break</span>
<span class="gi">+        else:</span>
<span class="gi">+            # no tp_list, no arglist: \macro{name}</span>
<span class="gi">+            self.body.append(CR + r&#39;\pysigline{&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def _depart_signature_line(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_signature(self, node: Element) -&gt; None:</span>
<span class="gi">+        hyper = &#39;&#39;</span>
<span class="gi">+        if node.parent[&#39;objtype&#39;] != &#39;describe&#39; and node[&#39;ids&#39;]:</span>
<span class="gi">+            for id in node[&#39;ids&#39;]:</span>
<span class="gi">+                hyper += self.hypertarget(id)</span>
<span class="gi">+        self.body.append(hyper)</span>
<span class="gi">+        if not self.in_desc_signature:</span>
<span class="gi">+            self.in_desc_signature = True</span>
<span class="gi">+            self.body.append(CR + r&#39;\pysigstartsignatures&#39;)</span>
<span class="gi">+        if not node.get(&#39;is_multiline&#39;):</span>
<span class="gi">+            self._visit_signature_line(node)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.body.append(CR + r&#39;\pysigstartmultiline&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_signature(self, node: Element) -&gt; None:</span>
<span class="gi">+        if not node.get(&#39;is_multiline&#39;):</span>
<span class="gi">+            self._depart_signature_line(node)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.body.append(CR + r&#39;\pysigstopmultiline&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_signature_line(self, node: Element) -&gt; None:</span>
<span class="gi">+        self._visit_signature_line(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_signature_line(self, node: Element) -&gt; None:</span>
<span class="gi">+        self._depart_signature_line(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_content(self, node: Element) -&gt; None:</span>
<span class="gi">+        assert self.in_desc_signature</span>
<span class="gi">+        self.body.append(CR + r&#39;\pysigstopsignatures&#39;)</span>
<span class="gi">+        self.in_desc_signature = False</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_content(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_inline(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;\sphinxcode{\sphinxupquote{&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_inline(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;}}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # Nodes for high-level structure in signatures</span>
<span class="gi">+    ##############################################</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_name(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;\sphinxbfcode{\sphinxupquote{&#39;)</span>
<span class="gi">+        self.literal_whitespace += 1</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_name(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;}}&#39;)</span>
<span class="gi">+        self.literal_whitespace -= 1</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_addname(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;\sphinxcode{\sphinxupquote{&#39;)</span>
<span class="gi">+        self.literal_whitespace += 1</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_addname(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;}}&#39;)</span>
<span class="gi">+        self.literal_whitespace -= 1</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_type(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_type(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_returns(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;{ $\rightarrow$ &#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_returns(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def _visit_sig_parameter_list(self, node: Element, parameter_group: type[Element]) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit a signature parameters or type parameters list.

<span class="w"> </span>        The *parameter_group* value is the type of a child node acting as a required parameter
<span class="gu">@@ -306,15 +862,765 @@ class LaTeXTranslator(SphinxTranslator):</span>
<span class="w"> </span>        The caller is responsible for closing adding surrounding LaTeX macro argument start
<span class="w"> </span>        and stop tokens.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        self.is_first_param = True</span>
<span class="gi">+        self.optional_param_level = 0</span>
<span class="gi">+        self.params_left_at_level = 0</span>
<span class="gi">+        self.param_group_index = 0</span>
<span class="gi">+        # Counts as what we call a parameter group either a required parameter, or a</span>
<span class="gi">+        # set of contiguous optional ones.</span>
<span class="gi">+        self.list_is_required_param = [isinstance(c, parameter_group) for c in node.children]</span>
<span class="gi">+        # How many required parameters are left.</span>
<span class="gi">+        self.required_params_left = sum(self.list_is_required_param)</span>
<span class="gi">+        self.param_separator = r&#39;\sphinxparamcomma &#39;</span>
<span class="gi">+        self.multi_line_parameter_list = node.get(&#39;multi_line_parameter_list&#39;, False)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_parameterlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        if self.has_tp_list:</span>
<span class="gi">+            if self.orphan_tp_list:</span>
<span class="gi">+                # close type parameters list (#2)</span>
<span class="gi">+                self.body.append(&#39;}{&#39;)</span>
<span class="gi">+                # empty parameters list argument (#3)</span>
<span class="gi">+                return</span>
<span class="gi">+        else:</span>
<span class="gi">+            # close name argument (#1), open parameters list argument (#2)</span>
<span class="gi">+            self.body.append(&#39;}{&#39;)</span>
<span class="gi">+        self._visit_sig_parameter_list(node, addnodes.desc_parameter)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_parameterlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        # close parameterlist, open return annotation</span>
<span class="gi">+        self.body.append(&#39;}{&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_type_parameter_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        # close name argument (#1), open type parameters list argument (#2)</span>
<span class="gi">+        self.body.append(&#39;}{&#39;)</span>
<span class="gi">+        self._visit_sig_parameter_list(node, addnodes.desc_type_parameter)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_type_parameter_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        # close type parameters list, open parameters list argument (#3)</span>
<span class="gi">+        self.body.append(&#39;}{&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def _visit_sig_parameter(self, node: Element, parameter_macro: str) -&gt; None:</span>
<span class="gi">+        if self.is_first_param:</span>
<span class="gi">+            self.is_first_param = False</span>
<span class="gi">+        elif not self.multi_line_parameter_list and not self.required_params_left:</span>
<span class="gi">+            self.body.append(self.param_separator)</span>
<span class="gi">+        if self.optional_param_level == 0:</span>
<span class="gi">+            self.required_params_left -= 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.params_left_at_level -= 1</span>
<span class="gi">+        if not node.hasattr(&#39;noemph&#39;):</span>
<span class="gi">+            self.body.append(parameter_macro)</span>
<span class="gi">+</span>
<span class="gi">+    def _depart_sig_parameter(self, node: Element) -&gt; None:</span>
<span class="gi">+        if not node.hasattr(&#39;noemph&#39;):</span>
<span class="gi">+            self.body.append(&#39;}&#39;)</span>
<span class="gi">+        is_required = self.list_is_required_param[self.param_group_index]</span>
<span class="gi">+        if self.multi_line_parameter_list:</span>
<span class="gi">+            is_last_group = self.param_group_index + 1 == len(self.list_is_required_param)</span>
<span class="gi">+            next_is_required = (</span>
<span class="gi">+                not is_last_group</span>
<span class="gi">+                and self.list_is_required_param[self.param_group_index + 1]</span>
<span class="gi">+            )</span>
<span class="gi">+            opt_param_left_at_level = self.params_left_at_level &gt; 0</span>
<span class="gi">+            if opt_param_left_at_level or is_required and (is_last_group or next_is_required):</span>
<span class="gi">+                self.body.append(self.param_separator)</span>
<span class="gi">+</span>
<span class="gi">+        elif self.required_params_left:</span>
<span class="gi">+            self.body.append(self.param_separator)</span>
<span class="gi">+</span>
<span class="gi">+        if is_required:</span>
<span class="gi">+            self.param_group_index += 1</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_parameter(self, node: Element) -&gt; None:</span>
<span class="gi">+        self._visit_sig_parameter(node, r&#39;\sphinxparam{&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_parameter(self, node: Element) -&gt; None:</span>
<span class="gi">+        self._depart_sig_parameter(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_type_parameter(self, node: Element) -&gt; None:</span>
<span class="gi">+        self._visit_sig_parameter(node, r&#39;\sphinxtypeparam{&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_type_parameter(self, node: Element) -&gt; None:</span>
<span class="gi">+        self._depart_sig_parameter(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_optional(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.params_left_at_level = sum(isinstance(c, addnodes.desc_parameter)</span>
<span class="gi">+                                        for c in node.children)</span>
<span class="gi">+        self.optional_param_level += 1</span>
<span class="gi">+        self.max_optional_param_level = self.optional_param_level</span>
<span class="gi">+        if self.multi_line_parameter_list:</span>
<span class="gi">+            if self.is_first_param:</span>
<span class="gi">+                self.body.append(r&#39;\sphinxoptional{&#39;)</span>
<span class="gi">+            elif self.required_params_left:</span>
<span class="gi">+                self.body.append(self.param_separator)</span>
<span class="gi">+                self.body.append(r&#39;\sphinxoptional{&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.body.append(r&#39;\sphinxoptional{&#39;)</span>
<span class="gi">+                self.body.append(self.param_separator)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.body.append(r&#39;\sphinxoptional{&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_optional(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.optional_param_level -= 1</span>
<span class="gi">+        if self.multi_line_parameter_list:</span>
<span class="gi">+            # If it&#39;s the first time we go down one level, add the separator before the</span>
<span class="gi">+            # bracket.</span>
<span class="gi">+            if self.optional_param_level == self.max_optional_param_level - 1:</span>
<span class="gi">+                self.body.append(self.param_separator)</span>
<span class="gi">+        self.body.append(&#39;}&#39;)</span>
<span class="gi">+        if self.optional_param_level == 0:</span>
<span class="gi">+            self.param_group_index += 1</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_annotation(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;\sphinxbfcode{\sphinxupquote{&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_annotation(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;}}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    ##############################################</span>
<span class="gi">+</span>
<span class="gi">+    def visit_seealso(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(BLANKLINE)</span>
<span class="gi">+        self.body.append(r&#39;\begin{sphinxseealso}{%s:}&#39; % admonitionlabels[&#39;seealso&#39;] + CR)</span>
<span class="gi">+        self.no_latex_floats += 1</span>
<span class="gi">+        if self.table:</span>
<span class="gi">+            self.table.has_problematic = True</span>
<span class="gi">+</span>
<span class="gi">+    def depart_seealso(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(BLANKLINE)</span>
<span class="gi">+        self.body.append(r&#39;\end{sphinxseealso}&#39;)</span>
<span class="gi">+        self.body.append(BLANKLINE)</span>
<span class="gi">+        self.no_latex_floats -= 1</span>
<span class="gi">+</span>
<span class="gi">+    def visit_rubric(self, node: nodes.rubric) -&gt; None:</span>
<span class="gi">+        if len(node) == 1 and node.astext() in (&#39;Footnotes&#39;, _(&#39;Footnotes&#39;)):</span>
<span class="gi">+            raise nodes.SkipNode</span>
<span class="gi">+        tag = &#39;subsubsection&#39;</span>
<span class="gi">+        if &#39;heading-level&#39; in node:</span>
<span class="gi">+            level = node[&#39;heading-level&#39;]</span>
<span class="gi">+            try:</span>
<span class="gi">+                tag = self.sectionnames[self.top_sectionlevel - 1 + level]</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                logger.warning(</span>
<span class="gi">+                    __(&#39;unsupported rubric heading level: %s&#39;),</span>
<span class="gi">+                    level,</span>
<span class="gi">+                    type=&#39;latex&#39;,</span>
<span class="gi">+                    location=node</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        self.body.append(rf&#39;\{tag}*{{&#39;)</span>
<span class="gi">+        self.context.append(&#39;}&#39; + CR)</span>
<span class="gi">+        self.in_title = 1</span>
<span class="gi">+</span>
<span class="gi">+    def depart_rubric(self, node: nodes.rubric) -&gt; None:</span>
<span class="gi">+        self.in_title = 0</span>
<span class="gi">+        self.body.append(self.context.pop())</span>
<span class="gi">+</span>
<span class="gi">+    def visit_footnote(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.in_footnote += 1</span>
<span class="gi">+        label = cast(nodes.label, node[0])</span>
<span class="gi">+        if self.in_parsed_literal:</span>
<span class="gi">+            self.body.append(r&#39;\begin{footnote}[%s]&#39; % label.astext())</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.body.append(&#39;%&#39; + CR)</span>
<span class="gi">+            self.body.append(r&#39;\begin{footnote}[%s]&#39; % label.astext())</span>
<span class="gi">+        if &#39;referred&#39; in node:</span>
<span class="gi">+            # TODO: in future maybe output a latex macro with backrefs here</span>
<span class="gi">+            pass</span>
<span class="gi">+        self.body.append(r&#39;\sphinxAtStartFootnote&#39; + CR)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_footnote(self, node: Element) -&gt; None:</span>
<span class="gi">+        if self.in_parsed_literal:</span>
<span class="gi">+            self.body.append(r&#39;\end{footnote}&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.body.append(&#39;%&#39; + CR)</span>
<span class="gi">+            self.body.append(r&#39;\end{footnote}&#39;)</span>
<span class="gi">+        self.in_footnote -= 1</span>
<span class="gi">+</span>
<span class="gi">+    def visit_label(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_tabular_col_spec(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.next_table_colspec = node[&#39;spec&#39;]</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_table(self, node: Element) -&gt; None:</span>
<span class="gi">+        if len(self.tables) == 1:</span>
<span class="gi">+            assert self.table is not None</span>
<span class="gi">+            if self.table.get_table_type() == &#39;longtable&#39;:</span>
<span class="gi">+                raise UnsupportedError(</span>
<span class="gi">+                    &#39;%s:%s: longtable does not support nesting a table.&#39; %</span>
<span class="gi">+                    (self.curfilestack[-1], node.line or &#39;&#39;))</span>
<span class="gi">+            # change type of parent table to tabular</span>
<span class="gi">+            # see https://groups.google.com/d/msg/sphinx-users/7m3NeOBixeo/9LKP2B4WBQAJ</span>
<span class="gi">+            self.table.has_problematic = True</span>
<span class="gi">+        elif len(self.tables) &gt; 2:</span>
<span class="gi">+            raise UnsupportedError(</span>
<span class="gi">+                &#39;%s:%s: deeply nested tables are not implemented.&#39; %</span>
<span class="gi">+                (self.curfilestack[-1], node.line or &#39;&#39;))</span>
<span class="gi">+</span>
<span class="gi">+        table = Table(node)</span>
<span class="gi">+        self.tables.append(table)</span>
<span class="gi">+        if table.colsep is None:</span>
<span class="gi">+            table.colsep = &#39;|&#39; * (</span>
<span class="gi">+                &#39;booktabs&#39; not in self.builder.config.latex_table_style</span>
<span class="gi">+                and &#39;borderless&#39; not in self.builder.config.latex_table_style</span>
<span class="gi">+            )</span>
<span class="gi">+        if self.next_table_colspec:</span>
<span class="gi">+            table.colspec = &#39;{%s}&#39; % self.next_table_colspec + CR</span>
<span class="gi">+            if &#39;|&#39; in table.colspec:</span>
<span class="gi">+                table.styles.append(&#39;vlines&#39;)</span>
<span class="gi">+                table.colsep = &#39;|&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                table.styles.append(&#39;novlines&#39;)</span>
<span class="gi">+                table.colsep = &#39;&#39;</span>
<span class="gi">+            if &#39;colwidths-given&#39; in node.get(&#39;classes&#39;, []):</span>
<span class="gi">+                logger.info(__(&#39;both tabularcolumns and :widths: option are given. &#39;</span>
<span class="gi">+                               &#39;:widths: is ignored.&#39;), location=node)</span>
<span class="gi">+        self.next_table_colspec = None</span>
<span class="gi">+</span>
<span class="gi">+    def depart_table(self, node: Element) -&gt; None:</span>
<span class="gi">+        assert self.table is not None</span>
<span class="gi">+        labels = self.hypertarget_to(node)</span>
<span class="gi">+        table_type = self.table.get_table_type()</span>
<span class="gi">+        table = self.render(table_type + &#39;.tex.jinja&#39;,</span>
<span class="gi">+                            {&#39;table&#39;: self.table, &#39;labels&#39;: labels})</span>
<span class="gi">+        self.body.append(BLANKLINE)</span>
<span class="gi">+        self.body.append(table)</span>
<span class="gi">+        self.body.append(CR)</span>
<span class="gi">+</span>
<span class="gi">+        self.tables.pop()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_colspec(self, node: Element) -&gt; None:</span>
<span class="gi">+        assert self.table is not None</span>
<span class="gi">+        self.table.colcount += 1</span>
<span class="gi">+        if &#39;colwidth&#39; in node:</span>
<span class="gi">+            self.table.colwidths.append(node[&#39;colwidth&#39;])</span>
<span class="gi">+        if &#39;stub&#39; in node:</span>
<span class="gi">+            self.table.stubs.append(self.table.colcount - 1)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_colspec(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_tgroup(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_tgroup(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_thead(self, node: Element) -&gt; None:</span>
<span class="gi">+        assert self.table is not None</span>
<span class="gi">+        # Redirect head output until header is finished.</span>
<span class="gi">+        self.pushbody(self.table.header)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_thead(self, node: Element) -&gt; None:</span>
<span class="gi">+        if self.body and self.body[-1] == r&#39;\sphinxhline&#39;:</span>
<span class="gi">+            self.body.pop()</span>
<span class="gi">+        self.popbody()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_tbody(self, node: Element) -&gt; None:</span>
<span class="gi">+        assert self.table is not None</span>
<span class="gi">+        # Redirect body output until table is finished.</span>
<span class="gi">+        self.pushbody(self.table.body)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_tbody(self, node: Element) -&gt; None:</span>
<span class="gi">+        if self.body and self.body[-1] == r&#39;\sphinxhline&#39;:</span>
<span class="gi">+            self.body.pop()</span>
<span class="gi">+        self.popbody()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_row(self, node: Element) -&gt; None:</span>
<span class="gi">+        assert self.table is not None</span>
<span class="gi">+        self.table.col = 0</span>
<span class="gi">+        _colsep = self.table.colsep</span>
<span class="gi">+        # fill columns if the row starts with the bottom of multirow cell</span>
<span class="gi">+        while True:</span>
<span class="gi">+            cell = self.table.cell(self.table.row, self.table.col)</span>
<span class="gi">+            if cell is None:  # not a bottom of multirow cell</span>
<span class="gi">+                break</span>
<span class="gi">+            # a bottom of multirow cell</span>
<span class="gi">+            self.table.col += cell.width</span>
<span class="gi">+            if cell.col:</span>
<span class="gi">+                self.body.append(&#39;&amp;&#39;)</span>
<span class="gi">+            if cell.width == 1:</span>
<span class="gi">+                # insert suitable strut for equalizing row heights in given multirow</span>
<span class="gi">+                self.body.append(r&#39;\sphinxtablestrut{%d}&#39; % cell.cell_id)</span>
<span class="gi">+            else:  # use \multicolumn for wide multirow cell</span>
<span class="gi">+                self.body.append(r&#39;\multicolumn{%d}{%sl%s}{\sphinxtablestrut{%d}}&#39; %</span>
<span class="gi">+                                 (cell.width, _colsep, _colsep, cell.cell_id))</span>
<span class="gi">+</span>
<span class="gi">+    def depart_row(self, node: Element) -&gt; None:</span>
<span class="gi">+        assert self.table is not None</span>
<span class="gi">+        self.body.append(r&#39;\\&#39; + CR)</span>
<span class="gi">+        cells = [self.table.cell(self.table.row, i) for i in range(self.table.colcount)]</span>
<span class="gi">+        underlined = [cell.row + cell.height == self.table.row + 1  # type: ignore[union-attr]</span>
<span class="gi">+                      for cell in cells]</span>
<span class="gi">+        if all(underlined):</span>
<span class="gi">+            self.body.append(r&#39;\sphinxhline&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            i = 0</span>
<span class="gi">+            underlined.extend([False])  # sentinel</span>
<span class="gi">+            if underlined[0] is False:</span>
<span class="gi">+                i = 1</span>
<span class="gi">+                while i &lt; self.table.colcount and underlined[i] is False:</span>
<span class="gi">+                    if cells[i - 1].cell_id != cells[i].cell_id:  # type: ignore[union-attr]</span>
<span class="gi">+                        self.body.append(r&#39;\sphinxvlinecrossing{%d}&#39; % i)</span>
<span class="gi">+                    i += 1</span>
<span class="gi">+            while i &lt; self.table.colcount:</span>
<span class="gi">+                # each time here underlined[i] is True</span>
<span class="gi">+                j = underlined[i:].index(False)</span>
<span class="gi">+                self.body.append(r&#39;\sphinxcline{%d-%d}&#39; % (i + 1, i + j))</span>
<span class="gi">+                i += j</span>
<span class="gi">+                i += 1</span>
<span class="gi">+                while i &lt; self.table.colcount and underlined[i] is False:</span>
<span class="gi">+                    if cells[i - 1].cell_id != cells[i].cell_id:  # type: ignore[union-attr]</span>
<span class="gi">+                        self.body.append(r&#39;\sphinxvlinecrossing{%d}&#39; % i)</span>
<span class="gi">+                    i += 1</span>
<span class="gi">+            self.body.append(r&#39;\sphinxfixclines{%d}&#39; % self.table.colcount)</span>
<span class="gi">+        self.table.row += 1</span>
<span class="gi">+</span>
<span class="gi">+    def visit_entry(self, node: Element) -&gt; None:</span>
<span class="gi">+        assert self.table is not None</span>
<span class="gi">+        if self.table.col &gt; 0:</span>
<span class="gi">+            self.body.append(&#39;&amp;&#39;)</span>
<span class="gi">+        self.table.add_cell(node.get(&#39;morerows&#39;, 0) + 1, node.get(&#39;morecols&#39;, 0) + 1)</span>
<span class="gi">+        cell = self.table.cell()</span>
<span class="gi">+        assert cell is not None</span>
<span class="gi">+        context = &#39;&#39;</span>
<span class="gi">+        _colsep = self.table.colsep</span>
<span class="gi">+        if cell.width &gt; 1:</span>
<span class="gi">+            if self.config.latex_use_latex_multicolumn:</span>
<span class="gi">+                if self.table.col == 0:</span>
<span class="gi">+                    self.body.append(r&#39;\multicolumn{%d}{%sl%s}{%%&#39; %</span>
<span class="gi">+                                     (cell.width, _colsep, _colsep) + CR)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.body.append(r&#39;\multicolumn{%d}{l%s}{%%&#39; % (cell.width, _colsep) + CR)</span>
<span class="gi">+                context = &#39;}%&#39; + CR</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.body.append(r&#39;\sphinxstartmulticolumn{%d}%%&#39; % cell.width + CR)</span>
<span class="gi">+                context = r&#39;\sphinxstopmulticolumn&#39; + CR</span>
<span class="gi">+        if cell.height &gt; 1:</span>
<span class="gi">+            # \sphinxmultirow 2nd arg &quot;cell_id&quot; will serve as id for LaTeX macros as well</span>
<span class="gi">+            self.body.append(r&#39;\sphinxmultirow{%d}{%d}{%%&#39; % (cell.height, cell.cell_id) + CR)</span>
<span class="gi">+            context = &#39;}%&#39; + CR + context</span>
<span class="gi">+        if cell.width &gt; 1 or cell.height &gt; 1:</span>
<span class="gi">+            self.body.append(r&#39;\begin{varwidth}[t]{\sphinxcolwidth{%d}{%d}}&#39;</span>
<span class="gi">+                             % (cell.width, self.table.colcount) + CR)</span>
<span class="gi">+            context = (r&#39;\par&#39; + CR + r&#39;\vskip-\baselineskip&#39;</span>
<span class="gi">+                       r&#39;\vbox{\hbox{\strut}}\end{varwidth}%&#39; + CR + context)</span>
<span class="gi">+            self.needs_linetrimming = 1</span>
<span class="gi">+        if len(list(node.findall(nodes.paragraph))) &gt;= 2:</span>
<span class="gi">+            self.table.has_oldproblematic = True</span>
<span class="gi">+        if isinstance(node.parent.parent, nodes.thead) or (cell.col in self.table.stubs):</span>
<span class="gi">+            if len(node) == 1 and isinstance(node[0], nodes.paragraph) and node.astext() == &#39;&#39;:</span>
<span class="gi">+                pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.body.append(r&#39;\sphinxstyletheadfamily &#39;)</span>
<span class="gi">+        if self.needs_linetrimming:</span>
<span class="gi">+            self.pushbody([])</span>
<span class="gi">+        self.context.append(context)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_entry(self, node: Element) -&gt; None:</span>
<span class="gi">+        if self.needs_linetrimming:</span>
<span class="gi">+            self.needs_linetrimming = 0</span>
<span class="gi">+            body = self.popbody()</span>
<span class="gi">+</span>
<span class="gi">+            # Remove empty lines from top of merged cell</span>
<span class="gi">+            while body and body[0] == CR:</span>
<span class="gi">+                body.pop(0)</span>
<span class="gi">+            self.body.extend(body)</span>
<span class="gi">+</span>
<span class="gi">+        self.body.append(self.context.pop())</span>
<span class="gi">+</span>
<span class="gi">+        assert self.table is not None</span>
<span class="gi">+        cell = self.table.cell()</span>
<span class="gi">+        assert cell is not None</span>
<span class="gi">+        self.table.col += cell.width</span>
<span class="gi">+        _colsep = self.table.colsep</span>
<span class="gi">+</span>
<span class="gi">+        # fill columns if next ones are a bottom of wide-multirow cell</span>
<span class="gi">+        while True:</span>
<span class="gi">+            nextcell = self.table.cell()</span>
<span class="gi">+            if nextcell is None:  # not a bottom of multirow cell</span>
<span class="gi">+                break</span>
<span class="gi">+            # a bottom part of multirow cell</span>
<span class="gi">+            self.body.append(&#39;&amp;&#39;)</span>
<span class="gi">+            if nextcell.width == 1:</span>
<span class="gi">+                # insert suitable strut for equalizing row heights in multirow</span>
<span class="gi">+                # they also serve to clear colour panels which would hide the text</span>
<span class="gi">+                self.body.append(r&#39;\sphinxtablestrut{%d}&#39; % nextcell.cell_id)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # use \multicolumn for not first row of wide multirow cell</span>
<span class="gi">+                self.body.append(r&#39;\multicolumn{%d}{l%s}{\sphinxtablestrut{%d}}&#39; %</span>
<span class="gi">+                                 (nextcell.width, _colsep, nextcell.cell_id))</span>
<span class="gi">+            self.table.col += nextcell.width</span>
<span class="gi">+</span>
<span class="gi">+    def visit_acks(self, node: Element) -&gt; None:</span>
<span class="gi">+        # this is a list in the source, but should be rendered as a</span>
<span class="gi">+        # comma-separated list here</span>
<span class="gi">+        bullet_list = cast(nodes.bullet_list, node[0])</span>
<span class="gi">+        list_items = cast(Iterable[nodes.list_item], bullet_list)</span>
<span class="gi">+        self.body.append(BLANKLINE)</span>
<span class="gi">+        self.body.append(&#39;, &#39;.join(n.astext() for n in list_items) + &#39;.&#39;)</span>
<span class="gi">+        self.body.append(BLANKLINE)</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_bullet_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        if not self.compact_list:</span>
<span class="gi">+            self.body.append(r&#39;\begin{itemize}&#39; + CR)</span>
<span class="gi">+        if self.table:</span>
<span class="gi">+            self.table.has_problematic = True</span>
<span class="gi">+</span>
<span class="gi">+    def depart_bullet_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        if not self.compact_list:</span>
<span class="gi">+            self.body.append(r&#39;\end{itemize}&#39; + CR)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_enumerated_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        def get_enumtype(node: Element) -&gt; str:</span>
<span class="gi">+            enumtype = node.get(&#39;enumtype&#39;, &#39;arabic&#39;)</span>
<span class="gi">+            if &#39;alpha&#39; in enumtype and (node.get(&#39;start&#39;, 0) + len(node)) &gt; 26:</span>
<span class="gi">+                # fallback to arabic if alphabet counter overflows</span>
<span class="gi">+                enumtype = &#39;arabic&#39;</span>
<span class="gi">+</span>
<span class="gi">+            return enumtype</span>
<span class="gi">+</span>
<span class="gi">+        def get_nested_level(node: Element) -&gt; int:</span>
<span class="gi">+            if node is None:</span>
<span class="gi">+                return 0</span>
<span class="gi">+            elif isinstance(node, nodes.enumerated_list):</span>
<span class="gi">+                return get_nested_level(node.parent) + 1</span>
<span class="gi">+            else:</span>
<span class="gi">+                return get_nested_level(node.parent)</span>
<span class="gi">+</span>
<span class="gi">+        enum = &quot;enum%s&quot; % toRoman(get_nested_level(node)).lower()</span>
<span class="gi">+        enumnext = &quot;enum%s&quot; % toRoman(get_nested_level(node) + 1).lower()</span>
<span class="gi">+        style = ENUMERATE_LIST_STYLE.get(get_enumtype(node))</span>
<span class="gi">+        prefix = node.get(&#39;prefix&#39;, &#39;&#39;)</span>
<span class="gi">+        suffix = node.get(&#39;suffix&#39;, &#39;.&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        self.body.append(r&#39;\begin{enumerate}&#39; + CR)</span>
<span class="gi">+        self.body.append(r&#39;\sphinxsetlistlabels{%s}{%s}{%s}{%s}{%s}%%&#39; %</span>
<span class="gi">+                         (style, enum, enumnext, prefix, suffix) + CR)</span>
<span class="gi">+        if &#39;start&#39; in node:</span>
<span class="gi">+            self.body.append(r&#39;\setcounter{%s}{%d}&#39; % (enum, node[&#39;start&#39;] - 1) + CR)</span>
<span class="gi">+        if self.table:</span>
<span class="gi">+            self.table.has_problematic = True</span>
<span class="gi">+</span>
<span class="gi">+    def depart_enumerated_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;\end{enumerate}&#39; + CR)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_list_item(self, node: Element) -&gt; None:</span>
<span class="gi">+        # Append &quot;{}&quot; in case the next character is &quot;[&quot;, which would break</span>
<span class="gi">+        # LaTeX&#39;s list environment (no numbering and the &quot;[&quot; is not printed).</span>
<span class="gi">+        self.body.append(r&#39;\item {} &#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_list_item(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(CR)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_definition_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;\begin{description}&#39; + CR)</span>
<span class="gi">+        if self.table:</span>
<span class="gi">+            self.table.has_problematic = True</span>
<span class="gi">+</span>
<span class="gi">+    def depart_definition_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;\end{description}&#39; + CR)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_definition_list_item(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_definition_list_item(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_term(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.in_term += 1</span>
<span class="gi">+        ctx = &#39;&#39;</span>
<span class="gi">+        if node.get(&#39;ids&#39;):</span>
<span class="gi">+            ctx = r&#39;\phantomsection&#39;</span>
<span class="gi">+            for node_id in node[&#39;ids&#39;]:</span>
<span class="gi">+                ctx += self.hypertarget(node_id, anchor=False)</span>
<span class="gi">+        ctx += r&#39;}&#39;</span>
<span class="gi">+        self.body.append(r&#39;\sphinxlineitem{&#39;)</span>
<span class="gi">+        self.context.append(ctx)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_term(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(self.context.pop())</span>
<span class="gi">+        self.in_term -= 1</span>
<span class="gi">+</span>
<span class="gi">+    def visit_classifier(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;{[}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_classifier(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;{]}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_definition(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_definition(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(CR)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_field_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;\begin{quote}\begin{description}&#39; + CR)</span>
<span class="gi">+        if self.table:</span>
<span class="gi">+            self.table.has_problematic = True</span>
<span class="gi">+</span>
<span class="gi">+    def depart_field_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;\end{description}\end{quote}&#39; + CR)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_field(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_field(self, node: Element) -&gt; None:</span>
<span class="w"> </span>        pass
<span class="gi">+</span>
<span class="w"> </span>    visit_field_name = visit_term
<span class="w"> </span>    depart_field_name = depart_term
<span class="gi">+</span>
<span class="w"> </span>    visit_field_body = visit_definition
<span class="w"> </span>    depart_field_body = depart_definition

<span class="gd">-    def is_inline(self, node: Element) -&gt;bool:</span>
<span class="gi">+    def visit_paragraph(self, node: Element) -&gt; None:</span>
<span class="gi">+        index = node.parent.index(node)</span>
<span class="gi">+        if (index &gt; 0 and isinstance(node.parent, nodes.compound) and</span>
<span class="gi">+                not isinstance(node.parent[index - 1], nodes.paragraph) and</span>
<span class="gi">+                not isinstance(node.parent[index - 1], nodes.compound)):</span>
<span class="gi">+            # insert blank line, if the paragraph follows a non-paragraph node in a compound</span>
<span class="gi">+            self.body.append(r&#39;\noindent&#39; + CR)</span>
<span class="gi">+        elif index == 1 and isinstance(node.parent, nodes.footnote | footnotetext):</span>
<span class="gi">+            # don&#39;t insert blank line, if the paragraph is second child of a footnote</span>
<span class="gi">+            # (first one is label node)</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            # the \sphinxAtStartPar is to allow hyphenation of first word of</span>
<span class="gi">+            # a paragraph in narrow contexts such as in a table cell</span>
<span class="gi">+            # added as two items (cf. line trimming in depart_entry())</span>
<span class="gi">+            self.body.extend([CR, r&#39;\sphinxAtStartPar&#39; + CR])</span>
<span class="gi">+</span>
<span class="gi">+    def depart_paragraph(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(CR)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_centered(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(CR + r&#39;\begin{center}&#39;)</span>
<span class="gi">+        if self.table:</span>
<span class="gi">+            self.table.has_problematic = True</span>
<span class="gi">+</span>
<span class="gi">+    def depart_centered(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(CR + r&#39;\end{center}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_hlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.compact_list += 1</span>
<span class="gi">+        ncolumns = node[&#39;ncolumns&#39;]</span>
<span class="gi">+        if self.compact_list &gt; 1:</span>
<span class="gi">+            self.body.append(r&#39;\setlength{\multicolsep}{0pt}&#39; + CR)</span>
<span class="gi">+        self.body.append(r&#39;\begin{multicols}{&#39; + ncolumns + r&#39;}\raggedright&#39; + CR)</span>
<span class="gi">+        self.body.append(r&#39;\begin{itemize}\setlength{\itemsep}{0pt}&#39;</span>
<span class="gi">+                         r&#39;\setlength{\parskip}{0pt}&#39; + CR)</span>
<span class="gi">+        if self.table:</span>
<span class="gi">+            self.table.has_problematic = True</span>
<span class="gi">+</span>
<span class="gi">+    def depart_hlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.compact_list -= 1</span>
<span class="gi">+        self.body.append(r&#39;\end{itemize}\raggedcolumns\end{multicols}&#39; + CR)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_hlistcol(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_hlistcol(self, node: Element) -&gt; None:</span>
<span class="gi">+        # \columnbreak would guarantee same columns as in html output.  But</span>
<span class="gi">+        # some testing with long items showed that columns may be too uneven.</span>
<span class="gi">+        # And in case only of short items, the automatic column breaks should</span>
<span class="gi">+        # match the ones pre-computed by the hlist() directive.</span>
<span class="gi">+        # self.body.append(r&#39;\columnbreak\n&#39;)</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def latex_image_length(self, width_str: str, scale: int = 100) -&gt; str | None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return rstdim_to_latexdim(width_str, scale)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            logger.warning(__(&#39;dimension unit %s is invalid. Ignored.&#39;), width_str)</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+    def is_inline(self, node: Element) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;Check whether a node represents an inline element.&quot;&quot;&quot;
<span class="gi">+        return isinstance(node.parent, nodes.TextElement)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_image(self, node: Element) -&gt; None:</span>
<span class="gi">+        pre: list[str] = []  # in reverse order</span>
<span class="gi">+        post: list[str] = []</span>
<span class="gi">+        include_graphics_options = []</span>
<span class="gi">+        has_hyperlink = isinstance(node.parent, nodes.reference)</span>
<span class="gi">+        if has_hyperlink:</span>
<span class="gi">+            is_inline = self.is_inline(node.parent)</span>
<span class="gi">+        else:</span>
<span class="gi">+            is_inline = self.is_inline(node)</span>
<span class="gi">+        if &#39;width&#39; in node:</span>
<span class="gi">+            if &#39;scale&#39; in node:</span>
<span class="gi">+                w = self.latex_image_length(node[&#39;width&#39;], node[&#39;scale&#39;])</span>
<span class="gi">+            else:</span>
<span class="gi">+                w = self.latex_image_length(node[&#39;width&#39;])</span>
<span class="gi">+            if w:</span>
<span class="gi">+                include_graphics_options.append(&#39;width=%s&#39; % w)</span>
<span class="gi">+        if &#39;height&#39; in node:</span>
<span class="gi">+            if &#39;scale&#39; in node:</span>
<span class="gi">+                h = self.latex_image_length(node[&#39;height&#39;], node[&#39;scale&#39;])</span>
<span class="gi">+            else:</span>
<span class="gi">+                h = self.latex_image_length(node[&#39;height&#39;])</span>
<span class="gi">+            if h:</span>
<span class="gi">+                include_graphics_options.append(&#39;height=%s&#39; % h)</span>
<span class="gi">+        if &#39;scale&#39; in node:</span>
<span class="gi">+            if not include_graphics_options:</span>
<span class="gi">+                # if no &quot;width&quot; nor &quot;height&quot;, \sphinxincludegraphics will fit</span>
<span class="gi">+                # to the available text width if oversized after rescaling.</span>
<span class="gi">+                include_graphics_options.append(&#39;scale=%s&#39;</span>
<span class="gi">+                                                % (float(node[&#39;scale&#39;]) / 100.0))</span>
<span class="gi">+        if &#39;align&#39; in node:</span>
<span class="gi">+            align_prepost = {</span>
<span class="gi">+                # By default latex aligns the top of an image.</span>
<span class="gi">+                (1, &#39;top&#39;): (&#39;&#39;, &#39;&#39;),</span>
<span class="gi">+                (1, &#39;middle&#39;): (r&#39;\raisebox{-0.5\height}{&#39;, &#39;}&#39;),</span>
<span class="gi">+                (1, &#39;bottom&#39;): (r&#39;\raisebox{-\height}{&#39;, &#39;}&#39;),</span>
<span class="gi">+                (0, &#39;center&#39;): (r&#39;{\hspace*{\fill}&#39;, r&#39;\hspace*{\fill}}&#39;),</span>
<span class="gi">+                # These 2 don&#39;t exactly do the right thing.  The image should</span>
<span class="gi">+                # be floated alongside the paragraph.  See</span>
<span class="gi">+                # https://www.w3.org/TR/html4/struct/objects.html#adef-align-IMG</span>
<span class="gi">+                (0, &#39;left&#39;): (&#39;{&#39;, r&#39;\hspace*{\fill}}&#39;),</span>
<span class="gi">+                (0, &#39;right&#39;): (r&#39;{\hspace*{\fill}&#39;, &#39;}&#39;),</span>
<span class="gi">+            }</span>
<span class="gi">+            try:</span>
<span class="gi">+                pre.append(align_prepost[is_inline, node[&#39;align&#39;]][0])</span>
<span class="gi">+                post.append(align_prepost[is_inline, node[&#39;align&#39;]][1])</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                pass</span>
<span class="gi">+        if self.in_parsed_literal:</span>
<span class="gi">+            pre.append(r&#39;{\sphinxunactivateextrasandspace &#39;)</span>
<span class="gi">+            post.append(&#39;}&#39;)</span>
<span class="gi">+        if not is_inline and not has_hyperlink:</span>
<span class="gi">+            pre.append(CR + r&#39;\noindent&#39;)</span>
<span class="gi">+            post.append(CR)</span>
<span class="gi">+        pre.reverse()</span>
<span class="gi">+        if node[&#39;uri&#39;] in self.builder.images:</span>
<span class="gi">+            uri = self.builder.images[node[&#39;uri&#39;]]</span>
<span class="gi">+        else:</span>
<span class="gi">+            # missing image!</span>
<span class="gi">+            if self.ignore_missing_images:</span>
<span class="gi">+                return</span>
<span class="gi">+            uri = node[&#39;uri&#39;]</span>
<span class="gi">+        if uri.find(&#39;://&#39;) != -1:</span>
<span class="gi">+            # ignore remote images</span>
<span class="gi">+            return</span>
<span class="gi">+        self.body.extend(pre)</span>
<span class="gi">+        options = &#39;&#39;</span>
<span class="gi">+        if include_graphics_options:</span>
<span class="gi">+            options = &#39;[%s]&#39; % &#39;,&#39;.join(include_graphics_options)</span>
<span class="gi">+        base, ext = path.splitext(uri)</span>
<span class="gi">+</span>
<span class="gi">+        if self.in_title and base:</span>
<span class="gi">+            # Lowercase tokens forcely because some fncychap themes capitalize</span>
<span class="gi">+            # the options of \sphinxincludegraphics unexpectedly (ex. WIDTH=...).</span>
<span class="gi">+            cmd = fr&#39;\lowercase{{\sphinxincludegraphics{options}}}{{{{{base}}}{ext}}}&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            cmd = fr&#39;\sphinxincludegraphics{options}{{{{{base}}}{ext}}}&#39;</span>
<span class="gi">+        # escape filepath for includegraphics, https://tex.stackexchange.com/a/202714/41112</span>
<span class="gi">+        if &#39;#&#39; in base:</span>
<span class="gi">+            cmd = r&#39;{\catcode`\#=12&#39; + cmd + &#39;}&#39;</span>
<span class="gi">+        self.body.append(cmd)</span>
<span class="gi">+        self.body.extend(post)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_image(self, node: Element) -&gt; None:</span>
<span class="w"> </span>        pass
<span class="gi">+</span>
<span class="gi">+    def visit_figure(self, node: Element) -&gt; None:</span>
<span class="gi">+        align = self.elements[&#39;figure_align&#39;]</span>
<span class="gi">+        if self.no_latex_floats:</span>
<span class="gi">+            align = &quot;H&quot;</span>
<span class="gi">+        if self.table:</span>
<span class="gi">+            # Blank line is needed if text precedes</span>
<span class="gi">+            self.body.append(BLANKLINE)</span>
<span class="gi">+            # TODO: support align option</span>
<span class="gi">+            if &#39;width&#39; in node:</span>
<span class="gi">+                length = self.latex_image_length(node[&#39;width&#39;])</span>
<span class="gi">+                if length:</span>
<span class="gi">+                    self.body.append(r&#39;\begin{sphinxfigure-in-table}[%s]&#39; % length + CR)</span>
<span class="gi">+                    self.body.append(r&#39;\centering&#39; + CR)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.body.append(r&#39;\begin{sphinxfigure-in-table}&#39; + CR)</span>
<span class="gi">+                self.body.append(r&#39;\centering&#39; + CR)</span>
<span class="gi">+            if any(isinstance(child, nodes.caption) for child in node):</span>
<span class="gi">+                self.body.append(r&#39;\capstart&#39;)</span>
<span class="gi">+            self.context.append(r&#39;\end{sphinxfigure-in-table}\relax&#39; + CR)</span>
<span class="gi">+        elif node.get(&#39;align&#39;, &#39;&#39;) in (&#39;left&#39;, &#39;right&#39;):</span>
<span class="gi">+            length = None</span>
<span class="gi">+            if &#39;width&#39; in node:</span>
<span class="gi">+                length = self.latex_image_length(node[&#39;width&#39;])</span>
<span class="gi">+            elif isinstance(node[0], nodes.image) and &#39;width&#39; in node[0]:</span>
<span class="gi">+                length = self.latex_image_length(node[0][&#39;width&#39;])</span>
<span class="gi">+            # Insert a blank line to prevent an infinite loop</span>
<span class="gi">+            # https://github.com/sphinx-doc/sphinx/issues/7059</span>
<span class="gi">+            self.body.append(BLANKLINE)</span>
<span class="gi">+            self.body.append(r&#39;\begin{wrapfigure}{%s}{%s}&#39; %</span>
<span class="gi">+                             (&#39;r&#39; if node[&#39;align&#39;] == &#39;right&#39; else &#39;l&#39;, length or &#39;0pt&#39;) + CR)</span>
<span class="gi">+            self.body.append(r&#39;\centering&#39;)</span>
<span class="gi">+            self.context.append(r&#39;\end{wrapfigure}&#39; +</span>
<span class="gi">+                                BLANKLINE +</span>
<span class="gi">+                                r&#39;\mbox{}\par\vskip-\dimexpr\baselineskip+\parskip\relax&#39; +</span>
<span class="gi">+                                CR)  # avoid disappearance if no text next issues/11079</span>
<span class="gi">+        elif self.in_minipage:</span>
<span class="gi">+            self.body.append(CR + r&#39;\begin{center}&#39;)</span>
<span class="gi">+            self.context.append(r&#39;\end{center}&#39; + CR)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.body.append(CR + r&#39;\begin{figure}[%s]&#39; % align + CR)</span>
<span class="gi">+            self.body.append(r&#39;\centering&#39; + CR)</span>
<span class="gi">+            if any(isinstance(child, nodes.caption) for child in node):</span>
<span class="gi">+                self.body.append(r&#39;\capstart&#39; + CR)</span>
<span class="gi">+            self.context.append(r&#39;\end{figure}&#39; + CR)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_figure(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(self.context.pop())</span>
<span class="gi">+</span>
<span class="gi">+    def visit_caption(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.in_caption += 1</span>
<span class="gi">+        if isinstance(node.parent, captioned_literal_block):</span>
<span class="gi">+            self.body.append(r&#39;\sphinxSetupCaptionForVerbatim{&#39;)</span>
<span class="gi">+        elif self.in_minipage and isinstance(node.parent, nodes.figure):</span>
<span class="gi">+            self.body.append(r&#39;\captionof{figure}{&#39;)</span>
<span class="gi">+        elif self.table and node.parent.tagname == &#39;figure&#39;:</span>
<span class="gi">+            self.body.append(r&#39;\sphinxfigcaption{&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.body.append(r&#39;\caption{&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_caption(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;}&#39;)</span>
<span class="gi">+        if isinstance(node.parent, nodes.figure):</span>
<span class="gi">+            labels = self.hypertarget_to(node.parent)</span>
<span class="gi">+            self.body.append(labels)</span>
<span class="gi">+        self.in_caption -= 1</span>
<span class="gi">+</span>
<span class="gi">+    def visit_legend(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(CR + r&#39;\begin{sphinxlegend}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_legend(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;\end{sphinxlegend}&#39; + CR)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_admonition(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(CR + r&#39;\begin{sphinxadmonition}{note}&#39;)</span>
<span class="gi">+        self.no_latex_floats += 1</span>
<span class="gi">+        if self.table:</span>
<span class="gi">+            self.table.has_problematic = True</span>
<span class="gi">+</span>
<span class="gi">+    def depart_admonition(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;\end{sphinxadmonition}&#39; + CR)</span>
<span class="gi">+        self.no_latex_floats -= 1</span>
<span class="gi">+</span>
<span class="gi">+    def _visit_named_admonition(self, node: Element) -&gt; None:</span>
<span class="gi">+        label = admonitionlabels[node.tagname]</span>
<span class="gi">+        self.body.append(CR + r&#39;\begin{sphinxadmonition}{%s}{%s:}&#39; %</span>
<span class="gi">+                         (node.tagname, label))</span>
<span class="gi">+        self.no_latex_floats += 1</span>
<span class="gi">+        if self.table:</span>
<span class="gi">+            self.table.has_problematic = True</span>
<span class="gi">+</span>
<span class="gi">+    def _depart_named_admonition(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;\end{sphinxadmonition}&#39; + CR)</span>
<span class="gi">+        self.no_latex_floats -= 1</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_attention = _visit_named_admonition
<span class="w"> </span>    depart_attention = _depart_named_admonition
<span class="w"> </span>    visit_caution = _visit_named_admonition
<span class="gu">@@ -333,12 +1639,684 @@ class LaTeXTranslator(SphinxTranslator):</span>
<span class="w"> </span>    depart_tip = _depart_named_admonition
<span class="w"> </span>    visit_warning = _visit_named_admonition
<span class="w"> </span>    depart_warning = _depart_named_admonition
<span class="gi">+</span>
<span class="gi">+    def visit_versionmodified(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_versionmodified(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_target(self, node: Element) -&gt; None:</span>
<span class="gi">+        def add_target(id: str) -&gt; None:</span>
<span class="gi">+            # indexing uses standard LaTeX index markup, so the targets</span>
<span class="gi">+            # will be generated differently</span>
<span class="gi">+            if id.startswith(&#39;index-&#39;):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            # equations also need no extra blank line nor hypertarget</span>
<span class="gi">+            # TODO: fix this dependency on mathbase extension internals</span>
<span class="gi">+            if id.startswith(&#39;equation-&#39;):</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            # insert blank line, if the target follows a paragraph node</span>
<span class="gi">+            index = node.parent.index(node)</span>
<span class="gi">+            if index &gt; 0 and isinstance(node.parent[index - 1], nodes.paragraph):</span>
<span class="gi">+                self.body.append(CR)</span>
<span class="gi">+</span>
<span class="gi">+            # do not generate \phantomsection in \section{}</span>
<span class="gi">+            anchor = not self.in_title</span>
<span class="gi">+            self.body.append(self.hypertarget(id, anchor=anchor))</span>
<span class="gi">+</span>
<span class="gi">+        # skip if visitor for next node supports hyperlink</span>
<span class="gi">+        next_node: Node = node</span>
<span class="gi">+        while isinstance(next_node, nodes.target):</span>
<span class="gi">+            next_node = next_node.next_node(ascend=True)</span>
<span class="gi">+</span>
<span class="gi">+        domain = cast(StandardDomain, self.builder.env.get_domain(&#39;std&#39;))</span>
<span class="gi">+        if isinstance(next_node, HYPERLINK_SUPPORT_NODES):</span>
<span class="gi">+            return</span>
<span class="gi">+        if domain.get_enumerable_node_type(next_node) and domain.get_numfig_title(next_node):</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;refuri&#39; in node:</span>
<span class="gi">+            return</span>
<span class="gi">+        if &#39;anonymous&#39; in node:</span>
<span class="gi">+            return</span>
<span class="gi">+        if node.get(&#39;refid&#39;):</span>
<span class="gi">+            prev_node = get_prev_node(node)</span>
<span class="gi">+            if isinstance(prev_node, nodes.reference) and node[&#39;refid&#39;] == prev_node[&#39;refid&#39;]:</span>
<span class="gi">+                # a target for a hyperlink reference having alias</span>
<span class="gi">+                pass</span>
<span class="gi">+            else:</span>
<span class="gi">+                add_target(node[&#39;refid&#39;])</span>
<span class="gi">+        # Temporary fix for https://github.com/sphinx-doc/sphinx/issues/11093</span>
<span class="gi">+        # TODO: investigate if a more elegant solution exists (see comments of #11093)</span>
<span class="gi">+        if node.get(&#39;ismod&#39;, False):</span>
<span class="gi">+            # Detect if the previous nodes are label targets. If so, remove</span>
<span class="gi">+            # the refid thereof from node[&#39;ids&#39;] to avoid duplicated ids.</span>
<span class="gi">+            def has_dup_label(sib: Node | None) -&gt; bool:</span>
<span class="gi">+                return isinstance(sib, nodes.target) and sib.get(&#39;refid&#39;) in node[&#39;ids&#39;]</span>
<span class="gi">+</span>
<span class="gi">+            prev = get_prev_node(node)</span>
<span class="gi">+            if has_dup_label(prev):</span>
<span class="gi">+                ids = node[&#39;ids&#39;][:]  # copy to avoid side-effects</span>
<span class="gi">+                while has_dup_label(prev):</span>
<span class="gi">+                    ids.remove(prev[&#39;refid&#39;])  # type: ignore[index]</span>
<span class="gi">+                    prev = get_prev_node(prev)  # type: ignore[arg-type]</span>
<span class="gi">+            else:</span>
<span class="gi">+                ids = iter(node[&#39;ids&#39;])  # read-only iterator</span>
<span class="gi">+        else:</span>
<span class="gi">+            ids = iter(node[&#39;ids&#39;])  # read-only iterator</span>
<span class="gi">+</span>
<span class="gi">+        for id in ids:</span>
<span class="gi">+            add_target(id)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_target(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_attribution(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(CR + r&#39;\begin{flushright}&#39; + CR)</span>
<span class="gi">+        self.body.append(&#39;---&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_attribution(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(CR + r&#39;\end{flushright}&#39; + CR)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_index(self, node: Element) -&gt; None:</span>
<span class="gi">+        def escape(value: str) -&gt; str:</span>
<span class="gi">+            value = self.encode(value)</span>
<span class="gi">+            value = value.replace(r&#39;\{&#39;, r&#39;\sphinxleftcurlybrace{}&#39;)</span>
<span class="gi">+            value = value.replace(r&#39;\}&#39;, r&#39;\sphinxrightcurlybrace{}&#39;)</span>
<span class="gi">+            value = value.replace(&#39;&quot;&#39;, &#39;&quot;&quot;&#39;)</span>
<span class="gi">+            value = value.replace(&#39;@&#39;, &#39;&quot;@&#39;)</span>
<span class="gi">+            value = value.replace(&#39;!&#39;, &#39;&quot;!&#39;)</span>
<span class="gi">+            value = value.replace(&#39;|&#39;, r&#39;\textbar{}&#39;)</span>
<span class="gi">+            return value</span>
<span class="gi">+</span>
<span class="gi">+        def style(string: str) -&gt; str:</span>
<span class="gi">+            match = EXTRA_RE.match(string)</span>
<span class="gi">+            if match:</span>
<span class="gi">+                return match.expand(r&#39;\\spxentry{\1}\\spxextra{\2}&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return r&#39;\spxentry{%s}&#39; % string</span>
<span class="gi">+</span>
<span class="gi">+        if not node.get(&#39;inline&#39;, True):</span>
<span class="gi">+            self.body.append(CR)</span>
<span class="gi">+        entries = node[&#39;entries&#39;]</span>
<span class="gi">+        for type, string, _tid, ismain, _key in entries:</span>
<span class="gi">+            m = &#39;&#39;</span>
<span class="gi">+            if ismain:</span>
<span class="gi">+                m = &#39;|spxpagem&#39;</span>
<span class="gi">+            try:</span>
<span class="gi">+                parts = tuple(map(escape, split_index_msg(type, string)))</span>
<span class="gi">+                styled = tuple(map(style, parts))</span>
<span class="gi">+                if type == &#39;single&#39;:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        p1, p2 = parts</span>
<span class="gi">+                        P1, P2 = styled</span>
<span class="gi">+                        self.body.append(fr&#39;\index{{{p1}@{P1}!{p2}@{P2}{m}}}&#39;)</span>
<span class="gi">+                    except ValueError:</span>
<span class="gi">+                        p, = parts</span>
<span class="gi">+                        P, = styled</span>
<span class="gi">+                        self.body.append(fr&#39;\index{{{p}@{P}{m}}}&#39;)</span>
<span class="gi">+                elif type == &#39;pair&#39;:</span>
<span class="gi">+                    p1, p2 = parts</span>
<span class="gi">+                    P1, P2 = styled</span>
<span class="gi">+                    self.body.append(fr&#39;\index{{{p1}@{P1}!{p2}@{P2}{m}}}&#39;</span>
<span class="gi">+                                     fr&#39;\index{{{p2}@{P2}!{p1}@{P1}{m}}}&#39;)</span>
<span class="gi">+                elif type == &#39;triple&#39;:</span>
<span class="gi">+                    p1, p2, p3 = parts</span>
<span class="gi">+                    P1, P2, P3 = styled</span>
<span class="gi">+                    self.body.append(</span>
<span class="gi">+                        fr&#39;\index{{{p1}@{P1}!{p2} {p3}@{P2} {P3}{m}}}&#39;</span>
<span class="gi">+                        fr&#39;\index{{{p2}@{P2}!{p3}, {p1}@{P3}, {P1}{m}}}&#39;</span>
<span class="gi">+                        fr&#39;\index{{{p3}@{P3}!{p1} {p2}@{P1} {P2}{m}}}&#39;)</span>
<span class="gi">+                elif type in {&#39;see&#39;, &#39;seealso&#39;}:</span>
<span class="gi">+                    p1, p2 = parts</span>
<span class="gi">+                    P1, _P2 = styled</span>
<span class="gi">+                    self.body.append(fr&#39;\index{{{p1}@{P1}|see{{{p2}}}}}&#39;)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    logger.warning(__(&#39;unknown index entry type %s found&#39;), type)</span>
<span class="gi">+            except ValueError as err:</span>
<span class="gi">+                logger.warning(str(err))</span>
<span class="gi">+        if not node.get(&#39;inline&#39;, True):</span>
<span class="gi">+            self.body.append(r&#39;\ignorespaces &#39;)</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_raw(self, node: Element) -&gt; None:</span>
<span class="gi">+        if not self.is_inline(node):</span>
<span class="gi">+            self.body.append(CR)</span>
<span class="gi">+        if &#39;latex&#39; in node.get(&#39;format&#39;, &#39;&#39;).split():</span>
<span class="gi">+            self.body.append(node.astext())</span>
<span class="gi">+        if not self.is_inline(node):</span>
<span class="gi">+            self.body.append(CR)</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        if not self.in_title:</span>
<span class="gi">+            for id in node.get(&#39;ids&#39;):</span>
<span class="gi">+                anchor = not self.in_caption</span>
<span class="gi">+                self.body += self.hypertarget(id, anchor=anchor)</span>
<span class="gi">+        if not self.is_inline(node):</span>
<span class="gi">+            self.body.append(CR)</span>
<span class="gi">+        uri = node.get(&#39;refuri&#39;, &#39;&#39;)</span>
<span class="gi">+        if not uri and node.get(&#39;refid&#39;):</span>
<span class="gi">+            uri = &#39;%&#39; + self.curfilestack[-1] + &#39;#&#39; + node[&#39;refid&#39;]</span>
<span class="gi">+        if self.in_title or not uri:</span>
<span class="gi">+            self.context.append(&#39;&#39;)</span>
<span class="gi">+        elif uri.startswith(&#39;#&#39;):</span>
<span class="gi">+            # references to labels in the same document</span>
<span class="gi">+            id = self.curfilestack[-1] + &#39;:&#39; + uri[1:]</span>
<span class="gi">+            self.body.append(self.hyperlink(id))</span>
<span class="gi">+            self.body.append(r&#39;\sphinxsamedocref{&#39;)</span>
<span class="gi">+            if self.config.latex_show_pagerefs and not \</span>
<span class="gi">+                    self.in_production_list:</span>
<span class="gi">+                self.context.append(&#39;}}} (%s)&#39; % self.hyperpageref(id))</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.context.append(&#39;}}}&#39;)</span>
<span class="gi">+        elif uri.startswith(&#39;%&#39;):</span>
<span class="gi">+            # references to documents or labels inside documents</span>
<span class="gi">+            hashindex = uri.find(&#39;#&#39;)</span>
<span class="gi">+            if hashindex == -1:</span>
<span class="gi">+                # reference to the document</span>
<span class="gi">+                id = uri[1:] + &#39;::doc&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                # reference to a label</span>
<span class="gi">+                id = uri[1:].replace(&#39;#&#39;, &#39;:&#39;)</span>
<span class="gi">+            self.body.append(self.hyperlink(id))</span>
<span class="gi">+            if (len(node) and</span>
<span class="gi">+                    isinstance(node[0], nodes.Element) and</span>
<span class="gi">+                    &#39;std-term&#39; in node[0].get(&#39;classes&#39;, [])):</span>
<span class="gi">+                # don&#39;t add a pageref for glossary terms</span>
<span class="gi">+                self.context.append(&#39;}}}&#39;)</span>
<span class="gi">+                # mark up as termreference</span>
<span class="gi">+                self.body.append(r&#39;\sphinxtermref{&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.body.append(r&#39;\sphinxcrossref{&#39;)</span>
<span class="gi">+                if self.config.latex_show_pagerefs and not self.in_production_list:</span>
<span class="gi">+                    self.context.append(&#39;}}} (%s)&#39; % self.hyperpageref(id))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.context.append(&#39;}}}&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if len(node) == 1 and uri == node[0]:</span>
<span class="gi">+                if node.get(&#39;nolinkurl&#39;):</span>
<span class="gi">+                    self.body.append(r&#39;\sphinxnolinkurl{%s}&#39; % self.encode_uri(uri))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.body.append(r&#39;\sphinxurl{%s}&#39; % self.encode_uri(uri))</span>
<span class="gi">+                raise nodes.SkipNode</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.body.append(r&#39;\sphinxhref{%s}{&#39; % self.encode_uri(uri))</span>
<span class="gi">+                self.context.append(&#39;}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(self.context.pop())</span>
<span class="gi">+        if not self.is_inline(node):</span>
<span class="gi">+            self.body.append(CR)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_number_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        if node.get(&#39;refid&#39;):</span>
<span class="gi">+            id = self.curfilestack[-1] + &#39;:&#39; + node[&#39;refid&#39;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            id = node.get(&#39;refuri&#39;, &#39;&#39;)[1:].replace(&#39;#&#39;, &#39;:&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        title = self.escape(node.get(&#39;title&#39;, &#39;%s&#39;)).replace(r&#39;\%s&#39;, &#39;%s&#39;)</span>
<span class="gi">+        if r&#39;\{name\}&#39; in title or r&#39;\{number\}&#39; in title:</span>
<span class="gi">+            # new style format (cf. &quot;Fig.%{number}&quot;)</span>
<span class="gi">+            title = title.replace(r&#39;\{name\}&#39;, &#39;{name}&#39;).replace(r&#39;\{number\}&#39;, &#39;{number}&#39;)</span>
<span class="gi">+            text = escape_abbr(title).format(name=r&#39;\nameref{%s}&#39; % self.idescape(id),</span>
<span class="gi">+                                             number=r&#39;\ref{%s}&#39; % self.idescape(id))</span>
<span class="gi">+        else:</span>
<span class="gi">+            # old style format (cf. &quot;Fig.%{number}&quot;)</span>
<span class="gi">+            text = escape_abbr(title) % (r&#39;\ref{%s}&#39; % self.idescape(id))</span>
<span class="gi">+        hyperref = fr&#39;\hyperref[{self.idescape(id)}]{{{text}}}&#39;</span>
<span class="gi">+        self.body.append(hyperref)</span>
<span class="gi">+</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_download_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_download_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_pending_xref(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_pending_xref(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_emphasis(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;\sphinxstyleemphasis{&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_emphasis(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_literal_emphasis(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;\sphinxstyleliteralemphasis{\sphinxupquote{&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_literal_emphasis(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;}}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_strong(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;\sphinxstylestrong{&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_strong(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_literal_strong(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;\sphinxstyleliteralstrong{\sphinxupquote{&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_literal_strong(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;}}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_abbreviation(self, node: Element) -&gt; None:</span>
<span class="gi">+        abbr = node.astext()</span>
<span class="gi">+        self.body.append(r&#39;\sphinxstyleabbreviation{&#39;)</span>
<span class="gi">+        # spell out the explanation once</span>
<span class="gi">+        if node.hasattr(&#39;explanation&#39;) and abbr not in self.handled_abbrs:</span>
<span class="gi">+            self.context.append(&#39;} (%s)&#39; % self.encode(node[&#39;explanation&#39;]))</span>
<span class="gi">+            self.handled_abbrs.add(abbr)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.context.append(&#39;}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_abbreviation(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(self.context.pop())</span>
<span class="gi">+</span>
<span class="gi">+    def visit_manpage(self, node: Element) -&gt; None:</span>
<span class="gi">+        return self.visit_literal_emphasis(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_manpage(self, node: Element) -&gt; None:</span>
<span class="gi">+        return self.depart_literal_emphasis(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_title_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;\sphinxtitleref{&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_title_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_thebibliography(self, node: Element) -&gt; None:</span>
<span class="gi">+        citations = cast(Iterable[nodes.citation], node)</span>
<span class="gi">+        labels = (cast(nodes.label, citation[0]) for citation in citations)</span>
<span class="gi">+        longest_label = max((label.astext() for label in labels), key=len)</span>
<span class="gi">+        if len(longest_label) &gt; MAX_CITATION_LABEL_LENGTH:</span>
<span class="gi">+            # adjust max width of citation labels not to break the layout</span>
<span class="gi">+            longest_label = longest_label[:MAX_CITATION_LABEL_LENGTH]</span>
<span class="gi">+</span>
<span class="gi">+        self.body.append(CR + r&#39;\begin{sphinxthebibliography}{%s}&#39; %</span>
<span class="gi">+                         self.encode(longest_label) + CR)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_thebibliography(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;\end{sphinxthebibliography}&#39; + CR)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_citation(self, node: Element) -&gt; None:</span>
<span class="gi">+        label = cast(nodes.label, node[0])</span>
<span class="gi">+        self.body.append(fr&#39;\bibitem[{self.encode(label.astext())}]&#39;</span>
<span class="gi">+                         fr&#39;{{{node[&quot;docname&quot;]}:{node[&quot;ids&quot;][0]}}}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_citation(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_citation_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        if self.in_title:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.body.append(fr&#39;\sphinxcite{{{node[&quot;docname&quot;]}:{node[&quot;refname&quot;]}}}&#39;)</span>
<span class="gi">+            raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def depart_citation_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_literal(self, node: Element) -&gt; None:</span>
<span class="gi">+        if self.in_title:</span>
<span class="gi">+            self.body.append(r&#39;\sphinxstyleliteralintitle{\sphinxupquote{&#39;)</span>
<span class="gi">+            return</span>
<span class="gi">+        elif &#39;kbd&#39; in node[&#39;classes&#39;]:</span>
<span class="gi">+            self.body.append(r&#39;\sphinxkeyboard{\sphinxupquote{&#39;)</span>
<span class="gi">+            return</span>
<span class="gi">+        lang = node.get(&quot;language&quot;, None)</span>
<span class="gi">+        if &#39;code&#39; not in node[&#39;classes&#39;] or not lang:</span>
<span class="gi">+            self.body.append(r&#39;\sphinxcode{\sphinxupquote{&#39;)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        opts = self.config.highlight_options.get(lang, {})</span>
<span class="gi">+        hlcode = self.highlighter.highlight_block(</span>
<span class="gi">+            node.astext(), lang, opts=opts, location=node, nowrap=True)</span>
<span class="gi">+        self.body.append(r&#39;\sphinxcode{\sphinxupquote{%&#39; + CR</span>
<span class="gi">+                         + hlcode.rstrip() + &#39;%&#39; + CR</span>
<span class="gi">+                         + &#39;}}&#39;)</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def depart_literal(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;}}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_footnote_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_footnotemark(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;\sphinxfootnotemark[&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_footnotemark(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;]&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_footnotetext(self, node: Element) -&gt; None:</span>
<span class="gi">+        label = cast(nodes.label, node[0])</span>
<span class="gi">+        self.body.append(&#39;%&#39; + CR)</span>
<span class="gi">+        self.body.append(r&#39;\begin{footnotetext}[%s]&#39; % label.astext())</span>
<span class="gi">+        self.body.append(r&#39;\sphinxAtStartFootnote&#39; + CR)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_footnotetext(self, node: Element) -&gt; None:</span>
<span class="gi">+        # the \ignorespaces in particular for after table header use</span>
<span class="gi">+        self.body.append(&#39;%&#39; + CR)</span>
<span class="gi">+        self.body.append(r&#39;\end{footnotetext}\ignorespaces &#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_captioned_literal_block(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_captioned_literal_block(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_literal_block(self, node: Element) -&gt; None:</span>
<span class="gi">+        if node.rawsource != node.astext():</span>
<span class="gi">+            # most probably a parsed-literal block -- don&#39;t highlight</span>
<span class="gi">+            self.in_parsed_literal += 1</span>
<span class="gi">+            self.body.append(r&#39;\begin{sphinxalltt}&#39; + CR)</span>
<span class="gi">+        else:</span>
<span class="gi">+            labels = self.hypertarget_to(node)</span>
<span class="gi">+            if isinstance(node.parent, captioned_literal_block):</span>
<span class="gi">+                labels += self.hypertarget_to(node.parent)</span>
<span class="gi">+            if labels and not self.in_footnote:</span>
<span class="gi">+                self.body.append(CR + r&#39;\def\sphinxLiteralBlockLabel{&#39; + labels + &#39;}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            lang = node.get(&#39;language&#39;, &#39;default&#39;)</span>
<span class="gi">+            linenos = node.get(&#39;linenos&#39;, False)</span>
<span class="gi">+            highlight_args = node.get(&#39;highlight_args&#39;, {})</span>
<span class="gi">+            highlight_args[&#39;force&#39;] = node.get(&#39;force&#39;, False)</span>
<span class="gi">+            opts = self.config.highlight_options.get(lang, {})</span>
<span class="gi">+</span>
<span class="gi">+            hlcode = self.highlighter.highlight_block(</span>
<span class="gi">+                node.rawsource, lang, opts=opts, linenos=linenos,</span>
<span class="gi">+                location=node, **highlight_args,</span>
<span class="gi">+            )</span>
<span class="gi">+            if self.in_footnote:</span>
<span class="gi">+                self.body.append(CR + r&#39;\sphinxSetupCodeBlockInFootnote&#39;)</span>
<span class="gi">+                hlcode = hlcode.replace(r&#39;\begin{Verbatim}&#39;,</span>
<span class="gi">+                                        r&#39;\begin{sphinxVerbatim}&#39;)</span>
<span class="gi">+            # if in table raise verbatim flag to avoid &quot;tabulary&quot; environment</span>
<span class="gi">+            # and opt for sphinxVerbatimintable to handle caption &amp; long lines</span>
<span class="gi">+            elif self.table:</span>
<span class="gi">+                self.table.has_problematic = True</span>
<span class="gi">+                self.table.has_verbatim = True</span>
<span class="gi">+                hlcode = hlcode.replace(r&#39;\begin{Verbatim}&#39;,</span>
<span class="gi">+                                        r&#39;\begin{sphinxVerbatimintable}&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                hlcode = hlcode.replace(r&#39;\begin{Verbatim}&#39;,</span>
<span class="gi">+                                        r&#39;\begin{sphinxVerbatim}&#39;)</span>
<span class="gi">+            # get consistent trailer</span>
<span class="gi">+            hlcode = hlcode.rstrip()[:-14]  # strip \end{Verbatim}</span>
<span class="gi">+            if self.table and not self.in_footnote:</span>
<span class="gi">+                hlcode += r&#39;\end{sphinxVerbatimintable}&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                hlcode += r&#39;\end{sphinxVerbatim}&#39;</span>
<span class="gi">+</span>
<span class="gi">+            hllines = str(highlight_args.get(&#39;hl_lines&#39;, []))[1:-1]</span>
<span class="gi">+            if hllines:</span>
<span class="gi">+                self.body.append(CR + r&#39;\fvset{hllines={, %s,}}%%&#39; % hllines)</span>
<span class="gi">+            self.body.append(CR + hlcode + CR)</span>
<span class="gi">+            if hllines:</span>
<span class="gi">+                self.body.append(r&#39;\sphinxresetverbatimhllines&#39; + CR)</span>
<span class="gi">+            raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def depart_literal_block(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(CR + r&#39;\end{sphinxalltt}&#39; + CR)</span>
<span class="gi">+        self.in_parsed_literal -= 1</span>
<span class="w"> </span>    visit_doctest_block = visit_literal_block
<span class="w"> </span>    depart_doctest_block = depart_literal_block

<span class="gd">-    def visit_option_argument(self, node: Element) -&gt;None:</span>
<span class="gi">+    def visit_line(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;\item[] &#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_line(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(CR)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_line_block(self, node: Element) -&gt; None:</span>
<span class="gi">+        if isinstance(node.parent, nodes.line_block):</span>
<span class="gi">+            self.body.append(r&#39;\item[]&#39; + CR)</span>
<span class="gi">+            self.body.append(r&#39;\begin{DUlineblock}{\DUlineblockindent}&#39; + CR)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.body.append(CR + r&#39;\begin{DUlineblock}{0em}&#39; + CR)</span>
<span class="gi">+        if self.table:</span>
<span class="gi">+            self.table.has_problematic = True</span>
<span class="gi">+</span>
<span class="gi">+    def depart_line_block(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;\end{DUlineblock}&#39; + CR)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_block_quote(self, node: Element) -&gt; None:</span>
<span class="gi">+        # If the block quote contains a single object and that object</span>
<span class="gi">+        # is a list, then generate a list not a block quote.</span>
<span class="gi">+        # This lets us indent lists.</span>
<span class="gi">+        done = 0</span>
<span class="gi">+        if len(node.children) == 1:</span>
<span class="gi">+            child = node.children[0]</span>
<span class="gi">+            if isinstance(child, nodes.bullet_list | nodes.enumerated_list):</span>
<span class="gi">+                done = 1</span>
<span class="gi">+        if not done:</span>
<span class="gi">+            self.body.append(r&#39;\begin{quote}&#39; + CR)</span>
<span class="gi">+            if self.table:</span>
<span class="gi">+                self.table.has_problematic = True</span>
<span class="gi">+</span>
<span class="gi">+    def depart_block_quote(self, node: Element) -&gt; None:</span>
<span class="gi">+        done = 0</span>
<span class="gi">+        if len(node.children) == 1:</span>
<span class="gi">+            child = node.children[0]</span>
<span class="gi">+            if isinstance(child, nodes.bullet_list | nodes.enumerated_list):</span>
<span class="gi">+                done = 1</span>
<span class="gi">+        if not done:</span>
<span class="gi">+            self.body.append(r&#39;\end{quote}&#39; + CR)</span>
<span class="gi">+</span>
<span class="gi">+    # option node handling copied from docutils&#39; latex writer</span>
<span class="gi">+</span>
<span class="gi">+    def visit_option(self, node: Element) -&gt; None:</span>
<span class="gi">+        if self.context[-1]:</span>
<span class="gi">+            # this is not the first option</span>
<span class="gi">+            self.body.append(&#39;, &#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_option(self, node: Element) -&gt; None:</span>
<span class="gi">+        # flag that the first option is done.</span>
<span class="gi">+        self.context[-1] += 1</span>
<span class="gi">+</span>
<span class="gi">+    def visit_option_argument(self, node: Element) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;The delimiter between an option and its argument.&quot;&quot;&quot;
<span class="gi">+        self.body.append(node.get(&#39;delimiter&#39;, &#39; &#39;))</span>
<span class="gi">+</span>
<span class="gi">+    def depart_option_argument(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_option_group(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;\item [&#39;)</span>
<span class="gi">+        # flag for first option</span>
<span class="gi">+        self.context.append(0)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_option_group(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.context.pop()  # the flag</span>
<span class="gi">+        self.body.append(&#39;] &#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_option_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;\begin{optionlist}{3cm}&#39; + CR)</span>
<span class="gi">+        if self.table:</span>
<span class="gi">+            self.table.has_problematic = True</span>
<span class="gi">+</span>
<span class="gi">+    def depart_option_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;\end{optionlist}&#39; + CR)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_option_list_item(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_option_list_item(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_option_string(self, node: Element) -&gt; None:</span>
<span class="gi">+        ostring = node.astext()</span>
<span class="gi">+        self.body.append(self.encode(ostring))</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_description(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39; &#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_description(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_superscript(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;$^{\text{&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_superscript(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;}}$&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_subscript(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(r&#39;$_{\text{&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_subscript(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;}}$&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_inline(self, node: Element) -&gt; None:</span>
<span class="gi">+        classes = node.get(&#39;classes&#39;, [])  # type: ignore[var-annotated]</span>
<span class="gi">+        if classes == [&#39;menuselection&#39;]:</span>
<span class="gi">+            self.body.append(r&#39;\sphinxmenuselection{&#39;)</span>
<span class="gi">+            self.context.append(&#39;}&#39;)</span>
<span class="gi">+        elif classes == [&#39;guilabel&#39;]:</span>
<span class="gi">+            self.body.append(r&#39;\sphinxguilabel{&#39;)</span>
<span class="gi">+            self.context.append(&#39;}&#39;)</span>
<span class="gi">+        elif classes == [&#39;accelerator&#39;]:</span>
<span class="gi">+            self.body.append(r&#39;\sphinxaccelerator{&#39;)</span>
<span class="gi">+            self.context.append(&#39;}&#39;)</span>
<span class="gi">+        elif classes and not self.in_title:</span>
<span class="gi">+            self.body.append(r&#39;\DUrole{&#39; + r&#39;}{\DUrole{&#39;.join(classes) + &#39;}{&#39;)</span>
<span class="gi">+            self.context.append(&#39;}&#39; * len(classes))</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.context.append(&#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_inline(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(self.context.pop())</span>
<span class="gi">+</span>
<span class="gi">+    def visit_generated(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_generated(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_compound(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_compound(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_container(self, node: Element) -&gt; None:</span>
<span class="gi">+        classes = node.get(&#39;classes&#39;, [])  # type: ignore[var-annotated]</span>
<span class="gi">+        for c in classes:</span>
<span class="gi">+            self.body.append(&#39;\n\\begin{sphinxuseclass}{%s}&#39; % c)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_container(self, node: Element) -&gt; None:</span>
<span class="gi">+        classes = node.get(&#39;classes&#39;, [])  # type: ignore[var-annotated]</span>
<span class="gi">+        for _c in classes:</span>
<span class="gi">+            self.body.append(&#39;\n\\end{sphinxuseclass}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_decoration(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_decoration(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    # docutils-generated elements that we don&#39;t support</span>
<span class="gi">+</span>
<span class="gi">+    def visit_header(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_footer(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_docinfo(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    # text handling</span>
<span class="gi">+</span>
<span class="gi">+    def encode(self, text: str) -&gt; str:</span>
<span class="gi">+        text = self.escape(text)</span>
<span class="gi">+        if self.literal_whitespace:</span>
<span class="gi">+            # Insert a blank before the newline, to avoid</span>
<span class="gi">+            # ! LaTeX Error: There&#39;s no line here to end.</span>
<span class="gi">+            text = text.replace(CR, r&#39;~\\&#39; + CR).replace(&#39; &#39;, &#39;~&#39;)</span>
<span class="gi">+        return text</span>
<span class="gi">+</span>
<span class="gi">+    def encode_uri(self, text: str) -&gt; str:</span>
<span class="gi">+        # TODO: it is probably wrong that this uses texescape.escape()</span>
<span class="gi">+        #       this must be checked against hyperref package exact dealings</span>
<span class="gi">+        #       mainly, %, #, {, } and \ need escaping via a \ escape</span>
<span class="gi">+        # in \href, the tilde is allowed and must be represented literally</span>
<span class="gi">+        return self.encode(text).replace(r&#39;\textasciitilde{}&#39;, &#39;~&#39;).\</span>
<span class="gi">+            replace(r&#39;\sphinxhyphen{}&#39;, &#39;-&#39;).\</span>
<span class="gi">+            replace(r&#39;\textquotesingle{}&#39;, &quot;&#39;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Text(self, node: Text) -&gt; None:</span>
<span class="gi">+        text = self.encode(node.astext())</span>
<span class="gi">+        self.body.append(text)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_Text(self, node: Text) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_comment(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_meta(self, node: Element) -&gt; None:</span>
<span class="gi">+        # only valid for HTML</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_system_message(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_system_message(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(CR)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_math(self, node: Element) -&gt; None:</span>
<span class="gi">+        if self.in_title:</span>
<span class="gi">+            self.body.append(r&#39;\protect\(%s\protect\)&#39; % node.astext())</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.body.append(r&#39;\(%s\)&#39; % node.astext())</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_math_block(self, node: Element) -&gt; None:</span>
<span class="gi">+        if node.get(&#39;label&#39;):</span>
<span class="gi">+            label = f&quot;equation:{node[&#39;docname&#39;]}:{node[&#39;label&#39;]}&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            label = None</span>
<span class="gi">+</span>
<span class="gi">+        if node.get(&#39;nowrap&#39;):</span>
<span class="gi">+            if label:</span>
<span class="gi">+                self.body.append(r&#39;\label{%s}&#39; % label)</span>
<span class="gi">+            self.body.append(node.astext())</span>
<span class="gi">+        else:</span>
<span class="gi">+            from sphinx.util.math import wrap_displaymath</span>
<span class="gi">+            self.body.append(wrap_displaymath(node.astext(), label,</span>
<span class="gi">+                                              self.config.math_number_all))</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_math_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        label = f&quot;equation:{node[&#39;docname&#39;]}:{node[&#39;target&#39;]}&quot;</span>
<span class="gi">+        eqref_format = self.config.math_eqref_format</span>
<span class="gi">+        if eqref_format:</span>
<span class="gi">+            try:</span>
<span class="gi">+                ref = r&#39;\ref{%s}&#39; % label</span>
<span class="gi">+                self.body.append(eqref_format.format(number=ref))</span>
<span class="gi">+            except KeyError as exc:</span>
<span class="gi">+                logger.warning(__(&#39;Invalid math_eqref_format: %r&#39;), exc,</span>
<span class="gi">+                               location=node)</span>
<span class="gi">+                self.body.append(r&#39;\eqref{%s}&#39; % label)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.body.append(r&#39;\eqref{%s}&#39; % label)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_math_reference(self, node: Element) -&gt; None:</span>
<span class="w"> </span>        pass


<span class="gd">-from sphinx.builders.latex.nodes import HYPERLINK_SUPPORT_NODES, captioned_literal_block, footnotetext</span>
<span class="gi">+# FIXME: Workaround to avoid circular import</span>
<span class="gi">+# refs: https://github.com/sphinx-doc/sphinx/issues/5433</span>
<span class="gi">+from sphinx.builders.latex.nodes import (  # NoQA: E402  # isort:skip</span>
<span class="gi">+    HYPERLINK_SUPPORT_NODES, captioned_literal_block, footnotetext,</span>
<span class="gi">+)</span>
<span class="gh">diff --git a/sphinx/writers/manpage.py b/sphinx/writers/manpage.py</span>
<span class="gh">index 06eeeaee2..2f066e410 100644</span>
<span class="gd">--- a/sphinx/writers/manpage.py</span>
<span class="gi">+++ b/sphinx/writers/manpage.py</span>
<span class="gu">@@ -1,28 +1,42 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Manual page writer, extended for Sphinx custom nodes.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from collections.abc import Iterable
<span class="w"> </span>from typing import TYPE_CHECKING, Any, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes
<span class="w"> </span>from docutils.writers.manpage import Translator as BaseTranslator
<span class="w"> </span>from docutils.writers.manpage import Writer
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.locale import _, admonitionlabels
<span class="w"> </span>from sphinx.util import logging
<span class="w"> </span>from sphinx.util.docutils import SphinxTranslator
<span class="w"> </span>from sphinx.util.i18n import format_date
<span class="w"> </span>from sphinx.util.nodes import NodeMatcher
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.nodes import Element
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.builders import Builder
<span class="gd">-logger = logging.getLogger(__name__)</span>

<span class="gi">+logger = logging.getLogger(__name__)</span>

<span class="gd">-class ManualPageWriter(Writer):</span>

<span class="gd">-    def __init__(self, builder: Builder) -&gt;None:</span>
<span class="gi">+class ManualPageWriter(Writer):  # type: ignore[misc]</span>
<span class="gi">+    def __init__(self, builder: Builder) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.builder = builder

<span class="gi">+    def translate(self) -&gt; None:</span>
<span class="gi">+        transform = NestedInlineTransform(self.document)</span>
<span class="gi">+        transform.apply()</span>
<span class="gi">+        visitor = self.builder.create_translator(self.document, self.builder)</span>
<span class="gi">+        self.visitor = cast(ManualPageTranslator, visitor)</span>
<span class="gi">+        self.document.walkabout(visitor)</span>
<span class="gi">+        self.output = self.visitor.astext()</span>
<span class="gi">+</span>

<span class="w"> </span>class NestedInlineTransform:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -36,33 +50,431 @@ class NestedInlineTransform:</span>
<span class="w"> </span>        &lt;strong&gt;&amp;bar=&lt;/strong&gt;&lt;emphasis&gt;2&lt;/emphasis&gt;
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, document: nodes.document) -&gt;None:</span>
<span class="gi">+    def __init__(self, document: nodes.document) -&gt; None:</span>
<span class="w"> </span>        self.document = document

<span class="gi">+    def apply(self, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        matcher = NodeMatcher(nodes.literal, nodes.emphasis, nodes.strong)</span>
<span class="gi">+        for node in list(matcher.findall(self.document)):</span>
<span class="gi">+            if any(matcher(subnode) for subnode in node):</span>
<span class="gi">+                pos = node.parent.index(node)</span>
<span class="gi">+                for subnode in reversed(list(node)):</span>
<span class="gi">+                    node.remove(subnode)</span>
<span class="gi">+                    if matcher(subnode):</span>
<span class="gi">+                        node.parent.insert(pos + 1, subnode)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        newnode = node.__class__(&#39;&#39;, &#39;&#39;, subnode, **node.attributes)</span>
<span class="gi">+                        node.parent.insert(pos + 1, newnode)</span>
<span class="gi">+                # move node if all children became siblings of the node</span>
<span class="gi">+                if not len(node):</span>
<span class="gi">+                    node.parent.remove(node)</span>

<span class="gd">-class ManualPageTranslator(SphinxTranslator, BaseTranslator):</span>
<span class="gi">+</span>
<span class="gi">+class ManualPageTranslator(SphinxTranslator, BaseTranslator):  # type: ignore[misc]</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Custom man page translator.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    _docinfo: dict[str, Any] = {}

<span class="gd">-    def __init__(self, document: nodes.document, builder: Builder) -&gt;None:</span>
<span class="gi">+    def __init__(self, document: nodes.document, builder: Builder) -&gt; None:</span>
<span class="w"> </span>        super().__init__(document, builder)
<span class="gi">+</span>
<span class="w"> </span>        self.in_productionlist = 0
<span class="gi">+</span>
<span class="gi">+        # first title is the manpage title</span>
<span class="w"> </span>        self.section_level = -1
<span class="gi">+</span>
<span class="gi">+        # docinfo set by man_pages config value</span>
<span class="w"> </span>        self._docinfo[&#39;title&#39;] = self.settings.title
<span class="w"> </span>        self._docinfo[&#39;subtitle&#39;] = self.settings.subtitle
<span class="w"> </span>        if self.settings.authors:
<span class="gi">+            # don&#39;t set it if no author given</span>
<span class="w"> </span>            self._docinfo[&#39;author&#39;] = self.settings.authors
<span class="w"> </span>        self._docinfo[&#39;manual_section&#39;] = self.settings.section
<span class="gi">+</span>
<span class="gi">+        # docinfo set by other config values</span>
<span class="w"> </span>        self._docinfo[&#39;title_upper&#39;] = self._docinfo[&#39;title&#39;].upper()
<span class="w"> </span>        if self.config.today:
<span class="w"> </span>            self._docinfo[&#39;date&#39;] = self.config.today
<span class="w"> </span>        else:
<span class="gd">-            self._docinfo[&#39;date&#39;] = format_date(self.config.today_fmt or _(</span>
<span class="gd">-                &#39;%b %d, %Y&#39;), language=self.config.language)</span>
<span class="gi">+            self._docinfo[&#39;date&#39;] = format_date(self.config.today_fmt or _(&#39;%b %d, %Y&#39;),</span>
<span class="gi">+                                                language=self.config.language)</span>
<span class="w"> </span>        self._docinfo[&#39;copyright&#39;] = self.config.copyright
<span class="w"> </span>        self._docinfo[&#39;version&#39;] = self.config.version
<span class="w"> </span>        self._docinfo[&#39;manual_group&#39;] = self.config.project
<span class="gi">+</span>
<span class="gi">+        # Overwrite admonition label translations with our own</span>
<span class="w"> </span>        for label, translation in admonitionlabels.items():
<span class="w"> </span>            self.language.labels[label] = self.deunicode(translation)
<span class="gi">+</span>
<span class="gi">+    # overwritten -- added quotes around all .TH arguments</span>
<span class="gi">+    def header(self) -&gt; str:</span>
<span class="gi">+        tmpl = (&quot;.TH \&quot;%(title_upper)s\&quot; \&quot;%(manual_section)s\&quot;&quot;</span>
<span class="gi">+                &quot; \&quot;%(date)s\&quot; \&quot;%(version)s\&quot; \&quot;%(manual_group)s\&quot;\n&quot;)</span>
<span class="gi">+        if self._docinfo[&#39;subtitle&#39;]:</span>
<span class="gi">+            tmpl += (&quot;.SH NAME\n&quot;</span>
<span class="gi">+                     &quot;%(title)s \\- %(subtitle)s\n&quot;)</span>
<span class="gi">+        return tmpl % self._docinfo</span>
<span class="gi">+</span>
<span class="gi">+    def visit_start_of_file(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_start_of_file(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    #############################################################</span>
<span class="gi">+    # Domain-specific object descriptions</span>
<span class="gi">+    #############################################################</span>
<span class="gi">+</span>
<span class="gi">+    # Top-level nodes for descriptions</span>
<span class="gi">+    ##################################</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_definition_list(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.depart_definition_list(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_signature(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_definition_list_item(node)</span>
<span class="gi">+        self.visit_term(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_signature(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.depart_term(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_signature_line(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_signature_line(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39; &#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_content(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_definition(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_content(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.depart_definition(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_inline(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_inline(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    # Nodes for high-level structure in signatures</span>
<span class="gi">+    ##############################################</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_name(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_name(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_addname(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_addname(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_type(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_type(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_returns(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39; -&gt; &#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_returns(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_parameterlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;(&#39;)</span>
<span class="gi">+        self.first_param = 1</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_parameterlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_type_parameter_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;[&#39;)</span>
<span class="gi">+        self.first_param = 1</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_type_parameter_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;]&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_parameter(self, node: Element) -&gt; None:</span>
<span class="gi">+        if not self.first_param:</span>
<span class="gi">+            self.body.append(&#39;, &#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.first_param = 0</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_parameter(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_type_parameter(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_desc_parameter(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_type_parameter(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.depart_desc_parameter(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_optional(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;[&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_optional(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;]&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_annotation(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_annotation(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    ##############################################</span>
<span class="gi">+</span>
<span class="gi">+    def visit_versionmodified(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_paragraph(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_versionmodified(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.depart_paragraph(node)</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten -- don&#39;t make whole of term bold if it includes strong node</span>
<span class="gi">+    def visit_term(self, node: Element) -&gt; None:</span>
<span class="gi">+        if any(node.findall(nodes.strong)):</span>
<span class="gi">+            self.body.append(&#39;\n&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            super().visit_term(node)</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten -- we don&#39;t want source comments to show up</span>
<span class="gi">+    def visit_comment(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten -- added ensure_eol()</span>
<span class="gi">+    def visit_footnote(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.ensure_eol()</span>
<span class="gi">+        super().visit_footnote(node)</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten -- handle footnotes rubric</span>
<span class="gi">+    def visit_rubric(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.ensure_eol()</span>
<span class="gi">+        if len(node) == 1 and node.astext() in (&#39;Footnotes&#39;, _(&#39;Footnotes&#39;)):</span>
<span class="gi">+            self.body.append(&#39;.SH &#39; + self.deunicode(node.astext()).upper() + &#39;\n&#39;)</span>
<span class="gi">+            raise nodes.SkipNode</span>
<span class="gi">+        self.body.append(&#39;.sp\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_rubric(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_seealso(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_admonition(node, &#39;seealso&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_seealso(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.depart_admonition(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_productionlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.ensure_eol()</span>
<span class="gi">+        self.in_productionlist += 1</span>
<span class="gi">+        self.body.append(&#39;.sp\n.nf\n&#39;)</span>
<span class="gi">+        productionlist = cast(Iterable[addnodes.production], node)</span>
<span class="gi">+        names = (production[&#39;tokenname&#39;] for production in productionlist)</span>
<span class="gi">+        maxlen = max(len(name) for name in names)</span>
<span class="gi">+        lastname = None</span>
<span class="gi">+        for production in productionlist:</span>
<span class="gi">+            if production[&#39;tokenname&#39;]:</span>
<span class="gi">+                lastname = production[&#39;tokenname&#39;].ljust(maxlen)</span>
<span class="gi">+                self.body.append(self.defs[&#39;strong&#39;][0])</span>
<span class="gi">+                self.body.append(self.deunicode(lastname))</span>
<span class="gi">+                self.body.append(self.defs[&#39;strong&#39;][1])</span>
<span class="gi">+                self.body.append(&#39; ::= &#39;)</span>
<span class="gi">+            elif lastname is not None:</span>
<span class="gi">+                self.body.append(&#39;%s     &#39; % (&#39; &#39; * len(lastname)))</span>
<span class="gi">+            production.walkabout(self)</span>
<span class="gi">+            self.body.append(&#39;\n&#39;)</span>
<span class="gi">+        self.body.append(&#39;\n.fi\n&#39;)</span>
<span class="gi">+        self.in_productionlist -= 1</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_production(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_production(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten -- don&#39;t emit a warning for images</span>
<span class="gi">+    def visit_image(self, node: Element) -&gt; None:</span>
<span class="gi">+        if &#39;alt&#39; in node.attributes:</span>
<span class="gi">+            self.body.append(_(&#39;[image: %s]&#39;) % node[&#39;alt&#39;] + &#39;\n&#39;)</span>
<span class="gi">+        self.body.append(_(&#39;[image]&#39;) + &#39;\n&#39;)</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten -- don&#39;t visit inner marked up nodes</span>
<span class="gi">+    def visit_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        uri = node.get(&#39;refuri&#39;, &#39;&#39;)</span>
<span class="gi">+        is_safe_to_click = uri.startswith((&#39;mailto:&#39;, &#39;http:&#39;, &#39;https:&#39;, &#39;ftp:&#39;))</span>
<span class="gi">+        if is_safe_to_click:</span>
<span class="gi">+            # OSC 8 link start (using groff&#39;s device control directive).</span>
<span class="gi">+            self.body.append(fr&quot;\X&#39;tty: link {uri}&#39;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        self.body.append(self.defs[&#39;reference&#39;][0])</span>
<span class="gi">+        # avoid repeating escaping code... fine since</span>
<span class="gi">+        # visit_Text calls astext() and only works on that afterwards</span>
<span class="gi">+        self.visit_Text(node)</span>
<span class="gi">+        self.body.append(self.defs[&#39;reference&#39;][1])</span>
<span class="gi">+</span>
<span class="gi">+        if uri and not uri.startswith(&#39;#&#39;):</span>
<span class="gi">+            # if configured, put the URL after the link</span>
<span class="gi">+            if self.config.man_show_urls and node.astext() != uri:</span>
<span class="gi">+                if uri.startswith(&#39;mailto:&#39;):</span>
<span class="gi">+                    uri = uri[7:]</span>
<span class="gi">+                self.body.extend([</span>
<span class="gi">+                    &#39; &lt;&#39;,</span>
<span class="gi">+                    self.defs[&#39;strong&#39;][0], uri, self.defs[&#39;strong&#39;][1],</span>
<span class="gi">+                    &#39;&gt;&#39;])</span>
<span class="gi">+        if is_safe_to_click:</span>
<span class="gi">+            # OSC 8 link end.</span>
<span class="gi">+            self.body.append(r&quot;\X&#39;tty: link&#39;&quot;)</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_number_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        text = nodes.Text(node.get(&#39;title&#39;, &#39;#&#39;))</span>
<span class="gi">+        self.visit_Text(text)</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_centered(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.ensure_eol()</span>
<span class="gi">+        self.body.append(&#39;.sp\n.ce\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_centered(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n.ce 0\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_compact_paragraph(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_compact_paragraph(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_download_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_download_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_toctree(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_index(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_tabular_col_spec(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_glossary(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_glossary(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_acks(self, node: Element) -&gt; None:</span>
<span class="gi">+        bullet_list = cast(nodes.bullet_list, node[0])</span>
<span class="gi">+        list_items = cast(Iterable[nodes.list_item], bullet_list)</span>
<span class="gi">+        self.ensure_eol()</span>
<span class="gi">+        bullet_list = cast(nodes.bullet_list, node[0])</span>
<span class="gi">+        list_items = cast(Iterable[nodes.list_item], bullet_list)</span>
<span class="gi">+        self.body.append(&#39;, &#39;.join(n.astext() for n in list_items) + &#39;.&#39;)</span>
<span class="gi">+        self.body.append(&#39;\n&#39;)</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_hlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_bullet_list(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_hlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.depart_bullet_list(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_hlistcol(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_hlistcol(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_literal_emphasis(self, node: Element) -&gt; None:</span>
<span class="gi">+        return self.visit_emphasis(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_literal_emphasis(self, node: Element) -&gt; None:</span>
<span class="gi">+        return self.depart_emphasis(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_literal_strong(self, node: Element) -&gt; None:</span>
<span class="gi">+        return self.visit_strong(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_literal_strong(self, node: Element) -&gt; None:</span>
<span class="gi">+        return self.depart_strong(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_abbreviation(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_abbreviation(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_manpage(self, node: Element) -&gt; None:</span>
<span class="gi">+        return self.visit_strong(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_manpage(self, node: Element) -&gt; None:</span>
<span class="gi">+        return self.depart_strong(node)</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten: handle section titles better than in 0.6 release</span>
<span class="gi">+    def visit_caption(self, node: Element) -&gt; None:</span>
<span class="gi">+        if isinstance(node.parent, nodes.container) and node.parent.get(&#39;literal_block&#39;):</span>
<span class="gi">+            self.body.append(&#39;.sp\n&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            super().visit_caption(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_caption(self, node: Element) -&gt; None:</span>
<span class="gi">+        if isinstance(node.parent, nodes.container) and node.parent.get(&#39;literal_block&#39;):</span>
<span class="gi">+            self.body.append(&#39;\n&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            super().depart_caption(node)</span>
<span class="gi">+</span>
<span class="gi">+    # overwritten: handle section titles better than in 0.6 release</span>
<span class="gi">+    def visit_title(self, node: Element) -&gt; None:</span>
<span class="gi">+        if isinstance(node.parent, addnodes.seealso):</span>
<span class="gi">+            self.body.append(&#39;.IP &quot;&#39;)</span>
<span class="gi">+            return None</span>
<span class="gi">+        elif isinstance(node.parent, nodes.section):</span>
<span class="gi">+            if self.section_level == 0:</span>
<span class="gi">+                # skip the document title</span>
<span class="gi">+                raise nodes.SkipNode</span>
<span class="gi">+            elif self.section_level == 1:</span>
<span class="gi">+                self.body.append(&#39;.SH %s\n&#39; %</span>
<span class="gi">+                                 self.deunicode(node.astext().upper()))</span>
<span class="gi">+                raise nodes.SkipNode</span>
<span class="gi">+        return super().visit_title(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_title(self, node: Element) -&gt; None:</span>
<span class="gi">+        if isinstance(node.parent, addnodes.seealso):</span>
<span class="gi">+            self.body.append(&#39;&quot;\n&#39;)</span>
<span class="gi">+            return None</span>
<span class="gi">+        return super().depart_title(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_raw(self, node: Element) -&gt; None:</span>
<span class="gi">+        if &#39;manpage&#39; in node.get(&#39;format&#39;, &#39;&#39;).split():</span>
<span class="gi">+            self.body.append(node.astext())</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_meta(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_inline(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_inline(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_math(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_math(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_math_block(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_centered(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_math_block(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.depart_centered(node)</span>
<span class="gh">diff --git a/sphinx/writers/texinfo.py b/sphinx/writers/texinfo.py</span>
<span class="gh">index ff82196df..953115e5d 100644</span>
<span class="gd">--- a/sphinx/writers/texinfo.py</span>
<span class="gi">+++ b/sphinx/writers/texinfo.py</span>
<span class="gu">@@ -1,11 +1,15 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Custom docutils writer for Texinfo.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import re
<span class="w"> </span>import textwrap
<span class="w"> </span>from collections.abc import Iterable, Iterator
<span class="w"> </span>from os import path
<span class="w"> </span>from typing import TYPE_CHECKING, Any, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes, writers
<span class="gi">+</span>
<span class="w"> </span>from sphinx import __display_version__, addnodes
<span class="w"> </span>from sphinx.domains.index import IndexDomain
<span class="w"> </span>from sphinx.errors import ExtensionError
<span class="gu">@@ -14,12 +18,19 @@ from sphinx.util import logging</span>
<span class="w"> </span>from sphinx.util.docutils import SphinxTranslator
<span class="w"> </span>from sphinx.util.i18n import format_date
<span class="w"> </span>from sphinx.writers.latex import collected_footnote
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.nodes import Element, Node, Text
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.builders.texinfo import TexinfoBuilder
<span class="w"> </span>    from sphinx.domains import IndexEntry
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gd">-COPYING = &quot;&quot;&quot;@quotation</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+COPYING = &quot;&quot;&quot;\</span>
<span class="gi">+@quotation</span>
<span class="w"> </span>%(project)s %(release)s, %(date)s

<span class="w"> </span>%(author)s
<span class="gu">@@ -27,7 +38,9 @@ COPYING = &quot;&quot;&quot;@quotation</span>
<span class="w"> </span>Copyright @copyright{} %(copyright)s
<span class="w"> </span>@end quotation
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-TEMPLATE = &quot;&quot;&quot;\\input texinfo   @c -*-texinfo-*-</span>
<span class="gi">+</span>
<span class="gi">+TEMPLATE = &quot;&quot;&quot;\</span>
<span class="gi">+\\input texinfo   @c -*-texinfo-*-</span>
<span class="w"> </span>@c %%**start of header
<span class="w"> </span>@setfilename %(filename)s
<span class="w"> </span>@documentencoding UTF-8
<span class="gu">@@ -69,59 +82,99 @@ TEMPLATE = &quot;&quot;&quot;\\input texinfo   @c -*-texinfo-*-</span>
<span class="w"> </span>&quot;&quot;&quot;


<span class="gd">-def find_subsections(section: Element) -&gt;list[nodes.section]:</span>
<span class="gi">+def find_subsections(section: Element) -&gt; list[nodes.section]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Return a list of subsections for the given ``section``.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = []</span>
<span class="gi">+    for child in section:</span>
<span class="gi">+        if isinstance(child, nodes.section):</span>
<span class="gi">+            result.append(child)</span>
<span class="gi">+            continue</span>
<span class="gi">+        if isinstance(child, nodes.Element):</span>
<span class="gi">+            result.extend(find_subsections(child))</span>
<span class="gi">+    return result</span>


<span class="gd">-def smart_capwords(s: str, sep: (str | None)=None) -&gt;str:</span>
<span class="gi">+def smart_capwords(s: str, sep: str | None = None) -&gt; str:</span>
<span class="w"> </span>    &quot;&quot;&quot;Like string.capwords() but does not capitalize words that already
<span class="w"> </span>    contain a capital letter.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    words = s.split(sep)</span>
<span class="gi">+    for i, word in enumerate(words):</span>
<span class="gi">+        if all(x.islower() for x in word):</span>
<span class="gi">+            words[i] = word.capitalize()</span>
<span class="gi">+    return (sep or &#39; &#39;).join(words)</span>


<span class="gd">-class TexinfoWriter(writers.Writer):</span>
<span class="gi">+class TexinfoWriter(writers.Writer):  # type: ignore[misc]</span>
<span class="w"> </span>    &quot;&quot;&quot;Texinfo writer for generating Texinfo documents.&quot;&quot;&quot;
<span class="gd">-    supported = &#39;texinfo&#39;, &#39;texi&#39;</span>
<span class="gd">-    settings_spec: tuple[str, Any, tuple[tuple[str, list[str], dict[str,</span>
<span class="gd">-        str]], ...]] = (&#39;Texinfo Specific Options&#39;, None, ((</span>
<span class="gd">-        &#39;Name of the Info file&#39;, [&#39;--texinfo-filename&#39;], {&#39;default&#39;: &#39;&#39;}),</span>
<span class="gd">-        (&#39;Dir entry&#39;, [&#39;--texinfo-dir-entry&#39;], {&#39;default&#39;: &#39;&#39;}), (</span>
<span class="gd">-        &#39;Description&#39;, [&#39;--texinfo-dir-description&#39;], {&#39;default&#39;: &#39;&#39;}), (</span>
<span class="gd">-        &#39;Category&#39;, [&#39;--texinfo-dir-category&#39;], {&#39;default&#39;: &#39;Miscellaneous&#39;})))</span>
<span class="gi">+</span>
<span class="gi">+    supported = (&#39;texinfo&#39;, &#39;texi&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    settings_spec: tuple[str, Any, tuple[tuple[str, list[str], dict[str, str]], ...]] = (</span>
<span class="gi">+        &#39;Texinfo Specific Options&#39;, None, (</span>
<span class="gi">+            (&quot;Name of the Info file&quot;, [&#39;--texinfo-filename&#39;], {&#39;default&#39;: &#39;&#39;}),</span>
<span class="gi">+            (&#39;Dir entry&#39;, [&#39;--texinfo-dir-entry&#39;], {&#39;default&#39;: &#39;&#39;}),</span>
<span class="gi">+            (&#39;Description&#39;, [&#39;--texinfo-dir-description&#39;], {&#39;default&#39;: &#39;&#39;}),</span>
<span class="gi">+            (&#39;Category&#39;, [&#39;--texinfo-dir-category&#39;], {&#39;default&#39;:</span>
<span class="gi">+                                                      &#39;Miscellaneous&#39;})))</span>
<span class="gi">+</span>
<span class="w"> </span>    settings_defaults: dict[str, Any] = {}
<span class="gi">+</span>
<span class="w"> </span>    output: str
<span class="gd">-    visitor_attributes = &#39;output&#39;, &#39;fragment&#39;</span>

<span class="gd">-    def __init__(self, builder: TexinfoBuilder) -&gt;None:</span>
<span class="gi">+    visitor_attributes = (&#39;output&#39;, &#39;fragment&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, builder: TexinfoBuilder) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.builder = builder

<span class="gi">+    def translate(self) -&gt; None:</span>
<span class="gi">+        visitor = self.builder.create_translator(self.document, self.builder)</span>
<span class="gi">+        self.visitor = cast(TexinfoTranslator, visitor)</span>
<span class="gi">+        self.document.walkabout(visitor)</span>
<span class="gi">+        self.visitor.finish()</span>
<span class="gi">+        for attr in self.visitor_attributes:</span>
<span class="gi">+            setattr(self, attr, getattr(self.visitor, attr))</span>
<span class="gi">+</span>

<span class="w"> </span>class TexinfoTranslator(SphinxTranslator):
<span class="gi">+</span>
<span class="w"> </span>    ignore_missing_images = False
<span class="w"> </span>    builder: TexinfoBuilder
<span class="gd">-    default_elements = {&#39;author&#39;: &#39;&#39;, &#39;body&#39;: &#39;&#39;, &#39;copying&#39;: &#39;&#39;, &#39;date&#39;: &#39;&#39;,</span>
<span class="gd">-        &#39;direntry&#39;: &#39;&#39;, &#39;exampleindent&#39;: 4, &#39;filename&#39;: &#39;&#39;,</span>
<span class="gd">-        &#39;paragraphindent&#39;: 0, &#39;preamble&#39;: &#39;&#39;, &#39;project&#39;: &#39;&#39;, &#39;release&#39;: &#39;&#39;,</span>
<span class="gd">-        &#39;title&#39;: &#39;&#39;}</span>

<span class="gd">-    def __init__(self, document: nodes.document, builder: TexinfoBuilder</span>
<span class="gd">-        ) -&gt;None:</span>
<span class="gi">+    default_elements = {</span>
<span class="gi">+        &#39;author&#39;: &#39;&#39;,</span>
<span class="gi">+        &#39;body&#39;: &#39;&#39;,</span>
<span class="gi">+        &#39;copying&#39;: &#39;&#39;,</span>
<span class="gi">+        &#39;date&#39;: &#39;&#39;,</span>
<span class="gi">+        &#39;direntry&#39;: &#39;&#39;,</span>
<span class="gi">+        &#39;exampleindent&#39;: 4,</span>
<span class="gi">+        &#39;filename&#39;: &#39;&#39;,</span>
<span class="gi">+        &#39;paragraphindent&#39;: 0,</span>
<span class="gi">+        &#39;preamble&#39;: &#39;&#39;,</span>
<span class="gi">+        &#39;project&#39;: &#39;&#39;,</span>
<span class="gi">+        &#39;release&#39;: &#39;&#39;,</span>
<span class="gi">+        &#39;title&#39;: &#39;&#39;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, document: nodes.document, builder: TexinfoBuilder) -&gt; None:</span>
<span class="w"> </span>        super().__init__(document, builder)
<span class="w"> </span>        self.init_settings()
<span class="gd">-        self.written_ids: set[str] = set()</span>
<span class="gi">+</span>
<span class="gi">+        self.written_ids: set[str] = set()          # node names and anchors in output</span>
<span class="gi">+        # node names and anchors that should be in output</span>
<span class="w"> </span>        self.referenced_ids: set[str] = set()
<span class="gd">-        self.indices: list[tuple[str, str]] = []</span>
<span class="gd">-        self.short_ids: dict[str, str] = {}</span>
<span class="gd">-        self.node_names: dict[str, str] = {}</span>
<span class="gd">-        self.node_menus: dict[str, list[str]] = {}</span>
<span class="gd">-        self.rellinks: dict[str, list[str]] = {}</span>
<span class="gi">+        self.indices: list[tuple[str, str]] = []    # (node name, content)</span>
<span class="gi">+        self.short_ids: dict[str, str] = {}         # anchors --&gt; short ids</span>
<span class="gi">+        self.node_names: dict[str, str] = {}        # node name --&gt; node&#39;s name to display</span>
<span class="gi">+        self.node_menus: dict[str, list[str]] = {}  # node name --&gt; node&#39;s menu entries</span>
<span class="gi">+        self.rellinks: dict[str, list[str]] = {}    # node name --&gt; (next, previous, up)</span>
<span class="gi">+</span>
<span class="w"> </span>        self.collect_indices()
<span class="w"> </span>        self.collect_node_names()
<span class="w"> </span>        self.collect_node_menus()
<span class="w"> </span>        self.collect_rellinks()
<span class="gi">+</span>
<span class="w"> </span>        self.body: list[str] = []
<span class="w"> </span>        self.context: list[str] = []
<span class="w"> </span>        self.descs: list[addnodes.desc] = []
<span class="gu">@@ -132,58 +185,931 @@ class TexinfoTranslator(SphinxTranslator):</span>
<span class="w"> </span>        self.escape_newlines = 0
<span class="w"> </span>        self.escape_hyphens = 0
<span class="w"> </span>        self.curfilestack: list[str] = []
<span class="gd">-        self.footnotestack: list[dict[str, list[collected_footnote | bool]]</span>
<span class="gd">-            ] = []</span>
<span class="gi">+        self.footnotestack: list[dict[str, list[collected_footnote | bool]]] = []</span>
<span class="w"> </span>        self.in_footnote = 0
<span class="w"> </span>        self.in_samp = 0
<span class="w"> </span>        self.handled_abbrs: set[str] = set()
<span class="w"> </span>        self.colwidths: list[int] = []

<span class="gd">-    def collect_node_names(self) -&gt;None:</span>
<span class="gi">+    def finish(self) -&gt; None:</span>
<span class="gi">+        if self.previous_section is None:</span>
<span class="gi">+            self.add_menu(&#39;Top&#39;)</span>
<span class="gi">+        for index in self.indices:</span>
<span class="gi">+            name, content = index</span>
<span class="gi">+            pointers = tuple([name] + self.rellinks[name])</span>
<span class="gi">+            self.body.append(&#39;\n@node %s,%s,%s,%s\n&#39; % pointers)</span>
<span class="gi">+            self.body.append(f&#39;@unnumbered {name}\n\n{content}\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        while self.referenced_ids:</span>
<span class="gi">+            # handle xrefs with missing anchors</span>
<span class="gi">+            r = self.referenced_ids.pop()</span>
<span class="gi">+            if r not in self.written_ids:</span>
<span class="gi">+                self.body.append(&#39;@anchor{{{}}}@w{{{}}}\n&#39;.format(r, &#39; &#39; * 30))</span>
<span class="gi">+        self.ensure_eol()</span>
<span class="gi">+        self.fragment = &#39;&#39;.join(self.body)</span>
<span class="gi">+        self.elements[&#39;body&#39;] = self.fragment</span>
<span class="gi">+        self.output = TEMPLATE % self.elements</span>
<span class="gi">+</span>
<span class="gi">+    # -- Helper routines</span>
<span class="gi">+</span>
<span class="gi">+    def init_settings(self) -&gt; None:</span>
<span class="gi">+        elements = self.elements = self.default_elements.copy()</span>
<span class="gi">+        elements.update({</span>
<span class="gi">+            # if empty, the title is set to the first section title</span>
<span class="gi">+            &#39;title&#39;: self.settings.title,</span>
<span class="gi">+            &#39;author&#39;: self.settings.author,</span>
<span class="gi">+            # if empty, use basename of input file</span>
<span class="gi">+            &#39;filename&#39;: self.settings.texinfo_filename,</span>
<span class="gi">+            &#39;release&#39;: self.escape(self.config.release),</span>
<span class="gi">+            &#39;project&#39;: self.escape(self.config.project),</span>
<span class="gi">+            &#39;copyright&#39;: self.escape(self.config.copyright),</span>
<span class="gi">+            &#39;date&#39;: self.escape(self.config.today or</span>
<span class="gi">+                                format_date(self.config.today_fmt or _(&#39;%b %d, %Y&#39;),</span>
<span class="gi">+                                            language=self.config.language)),</span>
<span class="gi">+        })</span>
<span class="gi">+        # title</span>
<span class="gi">+        title: str = self.settings.title</span>
<span class="gi">+        if not title:</span>
<span class="gi">+            title_node = self.document.next_node(nodes.title)</span>
<span class="gi">+            title = title_node.astext() if title_node else &#39;&lt;untitled&gt;&#39;</span>
<span class="gi">+        elements[&#39;title&#39;] = self.escape_id(title) or &#39;&lt;untitled&gt;&#39;</span>
<span class="gi">+        # filename</span>
<span class="gi">+        if not elements[&#39;filename&#39;]:</span>
<span class="gi">+            elements[&#39;filename&#39;] = self.document.get(&#39;source&#39;) or &#39;untitled&#39;</span>
<span class="gi">+            if elements[&#39;filename&#39;][-4:] in (&#39;.txt&#39;, &#39;.rst&#39;):  # type: ignore[index]</span>
<span class="gi">+                elements[&#39;filename&#39;] = elements[&#39;filename&#39;][:-4]  # type: ignore[index]</span>
<span class="gi">+            elements[&#39;filename&#39;] += &#39;.info&#39;  # type: ignore[operator]</span>
<span class="gi">+        # direntry</span>
<span class="gi">+        if self.settings.texinfo_dir_entry:</span>
<span class="gi">+            entry = self.format_menu_entry(</span>
<span class="gi">+                self.escape_menu(self.settings.texinfo_dir_entry),</span>
<span class="gi">+                &#39;(%s)&#39; % elements[&#39;filename&#39;],</span>
<span class="gi">+                self.escape_arg(self.settings.texinfo_dir_description))</span>
<span class="gi">+            elements[&#39;direntry&#39;] = (&#39;@dircategory %s\n&#39;</span>
<span class="gi">+                                    &#39;@direntry\n&#39;</span>
<span class="gi">+                                    &#39;%s&#39;</span>
<span class="gi">+                                    &#39;@end direntry\n&#39;) % (</span>
<span class="gi">+                self.escape_id(self.settings.texinfo_dir_category), entry)</span>
<span class="gi">+        elements[&#39;copying&#39;] = COPYING % elements</span>
<span class="gi">+        # allow the user to override them all</span>
<span class="gi">+        elements.update(self.settings.texinfo_elements)</span>
<span class="gi">+</span>
<span class="gi">+    def collect_node_names(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Generates a unique id for each section.

<span class="w"> </span>        Assigns the attribute ``node_name`` to each section.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def collect_node_menus(self) -&gt;None:</span>
<span class="gi">+        def add_node_name(name: str) -&gt; str:</span>
<span class="gi">+            node_id = self.escape_id(name)</span>
<span class="gi">+            nth, suffix = 1, &#39;&#39;</span>
<span class="gi">+            while node_id + suffix in self.written_ids or \</span>
<span class="gi">+                    node_id + suffix in self.node_names:</span>
<span class="gi">+                nth += 1</span>
<span class="gi">+                suffix = &#39;&lt;%s&gt;&#39; % nth</span>
<span class="gi">+            node_id += suffix</span>
<span class="gi">+            self.written_ids.add(node_id)</span>
<span class="gi">+            self.node_names[node_id] = name</span>
<span class="gi">+            return node_id</span>
<span class="gi">+</span>
<span class="gi">+        # must have a &quot;Top&quot; node</span>
<span class="gi">+        self.document[&#39;node_name&#39;] = &#39;Top&#39;</span>
<span class="gi">+        add_node_name(&#39;Top&#39;)</span>
<span class="gi">+        add_node_name(&#39;top&#39;)</span>
<span class="gi">+        # each index is a node</span>
<span class="gi">+        self.indices = [(add_node_name(name), content)</span>
<span class="gi">+                        for name, content in self.indices]</span>
<span class="gi">+        # each section is also a node</span>
<span class="gi">+        for section in self.document.findall(nodes.section):</span>
<span class="gi">+            title = cast(nodes.TextElement, section.next_node(nodes.Titular))  # type: ignore[type-var]</span>
<span class="gi">+            name = title.astext() if title else &#39;&lt;untitled&gt;&#39;</span>
<span class="gi">+            section[&#39;node_name&#39;] = add_node_name(name)</span>
<span class="gi">+</span>
<span class="gi">+    def collect_node_menus(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Collect the menu entries for each &quot;node&quot; section.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        node_menus = self.node_menus</span>
<span class="gi">+        targets: list[Element] = [self.document]</span>
<span class="gi">+        targets.extend(self.document.findall(nodes.section))</span>
<span class="gi">+        for node in targets:</span>
<span class="gi">+            assert node.get(&#39;node_name&#39;, False)</span>
<span class="gi">+            entries = [s[&#39;node_name&#39;] for s in find_subsections(node)]</span>
<span class="gi">+            node_menus[node[&#39;node_name&#39;]] = entries</span>
<span class="gi">+        # try to find a suitable &quot;Top&quot; node</span>
<span class="gi">+        title = self.document.next_node(nodes.title)</span>
<span class="gi">+        top = title.parent if title else self.document</span>
<span class="gi">+        if not isinstance(top, nodes.document | nodes.section):</span>
<span class="gi">+            top = self.document</span>
<span class="gi">+        if top is not self.document:</span>
<span class="gi">+            entries = node_menus[top[&#39;node_name&#39;]]</span>
<span class="gi">+            entries += node_menus[&#39;Top&#39;][1:]</span>
<span class="gi">+            node_menus[&#39;Top&#39;] = entries</span>
<span class="gi">+            del node_menus[top[&#39;node_name&#39;]]</span>
<span class="gi">+            top[&#39;node_name&#39;] = &#39;Top&#39;</span>
<span class="gi">+        # handle the indices</span>
<span class="gi">+        for name, _content in self.indices:</span>
<span class="gi">+            node_menus[name] = []</span>
<span class="gi">+            node_menus[&#39;Top&#39;].append(name)</span>

<span class="gd">-    def collect_rellinks(self) -&gt;None:</span>
<span class="gi">+    def collect_rellinks(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Collect the relative links (next, previous, up) for each &quot;node&quot;.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rellinks = self.rellinks</span>
<span class="gi">+        node_menus = self.node_menus</span>
<span class="gi">+        for id in node_menus:</span>
<span class="gi">+            rellinks[id] = [&#39;&#39;, &#39;&#39;, &#39;&#39;]</span>
<span class="gi">+        # up&#39;s</span>
<span class="gi">+        for id, entries in node_menus.items():</span>
<span class="gi">+            for e in entries:</span>
<span class="gi">+                rellinks[e][2] = id</span>
<span class="gi">+        # next&#39;s and prev&#39;s</span>
<span class="gi">+        for id, entries in node_menus.items():</span>
<span class="gi">+            for i, id in enumerate(entries):</span>
<span class="gi">+                # First child&#39;s prev is empty</span>
<span class="gi">+                if i != 0:</span>
<span class="gi">+                    rellinks[id][1] = entries[i - 1]</span>
<span class="gi">+                # Last child&#39;s next is empty</span>
<span class="gi">+                if i != len(entries) - 1:</span>
<span class="gi">+                    rellinks[id][0] = entries[i + 1]</span>
<span class="gi">+        # top&#39;s next is its first child</span>
<span class="gi">+        try:</span>
<span class="gi">+            first = node_menus[&#39;Top&#39;][0]</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            rellinks[&#39;Top&#39;][0] = first</span>
<span class="gi">+            rellinks[first][1] = &#39;Top&#39;</span>

<span class="gd">-    def escape(self, s: str) -&gt;str:</span>
<span class="gi">+    # -- Escaping</span>
<span class="gi">+    # Which characters to escape depends on the context.  In some cases,</span>
<span class="gi">+    # namely menus and node names, it&#39;s not possible to escape certain</span>
<span class="gi">+    # characters.</span>
<span class="gi">+</span>
<span class="gi">+    def escape(self, s: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a string with Texinfo command characters escaped.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        s = s.replace(&#39;@&#39;, &#39;@@&#39;)</span>
<span class="gi">+        s = s.replace(&#39;{&#39;, &#39;@{&#39;)</span>
<span class="gi">+        s = s.replace(&#39;}&#39;, &#39;@}&#39;)</span>
<span class="gi">+        # prevent `` and &#39;&#39; quote conversion</span>
<span class="gi">+        s = s.replace(&#39;``&#39;, &quot;`@w{`}&quot;)</span>
<span class="gi">+        s = s.replace(&quot;&#39;&#39;&quot;, &quot;&#39;@w{&#39;}&quot;)</span>
<span class="gi">+        return s</span>

<span class="gd">-    def escape_arg(self, s: str) -&gt;str:</span>
<span class="gi">+    def escape_arg(self, s: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return an escaped string suitable for use as an argument
<span class="w"> </span>        to a Texinfo command.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        s = self.escape(s)</span>
<span class="gi">+        # commas are the argument delimiters</span>
<span class="gi">+        s = s.replace(&#39;,&#39;, &#39;@comma{}&#39;)</span>
<span class="gi">+        # normalize white space</span>
<span class="gi">+        s = &#39; &#39;.join(s.split()).strip()</span>
<span class="gi">+        return s</span>

<span class="gd">-    def escape_id(self, s: str) -&gt;str:</span>
<span class="gi">+    def escape_id(self, s: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return an escaped string suitable for node names and anchors.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        bad_chars = &#39;,:()&#39;</span>
<span class="gi">+        for bc in bad_chars:</span>
<span class="gi">+            s = s.replace(bc, &#39; &#39;)</span>
<span class="gi">+        if re.search(&#39;[^ .]&#39;, s):</span>
<span class="gi">+            # remove DOTs if name contains other characters</span>
<span class="gi">+            s = s.replace(&#39;.&#39;, &#39; &#39;)</span>
<span class="gi">+        s = &#39; &#39;.join(s.split()).strip()</span>
<span class="gi">+        return self.escape(s)</span>

<span class="gd">-    def escape_menu(self, s: str) -&gt;str:</span>
<span class="gi">+    def escape_menu(self, s: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return an escaped string suitable for menu entries.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        s = self.escape_arg(s)</span>
<span class="gi">+        s = s.replace(&#39;:&#39;, &#39;;&#39;)</span>
<span class="gi">+        s = &#39; &#39;.join(s.split()).strip()</span>
<span class="gi">+        return s</span>

<span class="gd">-    def ensure_eol(self) -&gt;None:</span>
<span class="gi">+    def ensure_eol(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Ensure the last line in body is terminated by new line.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self.body and self.body[-1][-1:] != &#39;\n&#39;:</span>
<span class="gi">+            self.body.append(&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def format_menu_entry(self, name: str, node_name: str, desc: str) -&gt; str:</span>
<span class="gi">+        if name == node_name:</span>
<span class="gi">+            s = f&#39;* {name}:: &#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            s = f&#39;* {name}: {node_name}. &#39;</span>
<span class="gi">+        offset = max((24, (len(name) + 4) % 78))</span>
<span class="gi">+        wdesc = &#39;\n&#39;.join(&#39; &#39; * offset + l for l in</span>
<span class="gi">+                          textwrap.wrap(desc, width=78 - offset))</span>
<span class="gi">+        return s + wdesc.strip() + &#39;\n&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def add_menu_entries(</span>
<span class="gi">+        self,</span>
<span class="gi">+        entries: list[str],</span>
<span class="gi">+        reg: re.Pattern[str] = re.compile(r&#39;\s+---?\s+&#39;),</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        for entry in entries:</span>
<span class="gi">+            name = self.node_names[entry]</span>
<span class="gi">+            # special formatting for entries that are divided by an em-dash</span>
<span class="gi">+            try:</span>
<span class="gi">+                parts = reg.split(name, 1)</span>
<span class="gi">+            except TypeError:</span>
<span class="gi">+                # could be a gettext proxy</span>
<span class="gi">+                parts = [name]</span>
<span class="gi">+            if len(parts) == 2:</span>
<span class="gi">+                name, desc = parts</span>
<span class="gi">+            else:</span>
<span class="gi">+                desc = &#39;&#39;</span>
<span class="gi">+            name = self.escape_menu(name)</span>
<span class="gi">+            desc = self.escape(desc)</span>
<span class="gi">+            self.body.append(self.format_menu_entry(name, entry, desc))</span>
<span class="gi">+</span>
<span class="gi">+    def add_menu(self, node_name: str) -&gt; None:</span>
<span class="gi">+        entries = self.node_menus[node_name]</span>
<span class="gi">+        if not entries:</span>
<span class="gi">+            return</span>
<span class="gi">+        self.body.append(&#39;\n@menu\n&#39;)</span>
<span class="gi">+        self.add_menu_entries(entries)</span>
<span class="gi">+        if (node_name != &#39;Top&#39; or</span>
<span class="gi">+                not self.node_menus[entries[0]] or</span>
<span class="gi">+                self.config.texinfo_no_detailmenu):</span>
<span class="gi">+            self.body.append(&#39;\n@end menu\n&#39;)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        def _add_detailed_menu(name: str) -&gt; None:</span>
<span class="gi">+            entries = self.node_menus[name]</span>
<span class="gi">+            if not entries:</span>
<span class="gi">+                return</span>
<span class="gi">+            self.body.append(f&#39;\n{self.escape(self.node_names[name])}\n\n&#39;)</span>
<span class="gi">+            self.add_menu_entries(entries)</span>
<span class="gi">+            for subentry in entries:</span>
<span class="gi">+                _add_detailed_menu(subentry)</span>
<span class="gi">+</span>
<span class="gi">+        self.body.append(&#39;\n@detailmenu\n&#39;</span>
<span class="gi">+                         &#39; --- The Detailed Node Listing ---\n&#39;)</span>
<span class="gi">+        for entry in entries:</span>
<span class="gi">+            _add_detailed_menu(entry)</span>
<span class="gi">+        self.body.append(&#39;\n@end detailmenu\n&#39;</span>
<span class="gi">+                         &#39;@end menu\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def tex_image_length(self, width_str: str) -&gt; str:</span>
<span class="gi">+        match = re.match(r&#39;(\d*\.?\d*)\s*(\S*)&#39;, width_str)</span>
<span class="gi">+        if not match:</span>
<span class="gi">+            # fallback</span>
<span class="gi">+            return width_str</span>
<span class="gi">+        res = width_str</span>
<span class="gi">+        amount, unit = match.groups()[:2]</span>
<span class="gi">+        if not unit or unit == &quot;px&quot;:</span>
<span class="gi">+            # pixels: let TeX alone</span>
<span class="gi">+            return &#39;&#39;</span>
<span class="gi">+        elif unit == &quot;%&quot;:</span>
<span class="gi">+            # a4paper: textwidth=418.25368pt</span>
<span class="gi">+            res = &quot;%d.0pt&quot; % (float(amount) * 4.1825368)</span>
<span class="gi">+        return res</span>

<span class="gd">-    def get_short_id(self, id: str) -&gt;str:</span>
<span class="gi">+    def collect_indices(self) -&gt; None:</span>
<span class="gi">+        def generate(content: list[tuple[str, list[IndexEntry]]], collapsed: bool) -&gt; str:</span>
<span class="gi">+            ret = [&#39;\n@menu\n&#39;]</span>
<span class="gi">+            for _letter, entries in content:</span>
<span class="gi">+                for entry in entries:</span>
<span class="gi">+                    if not entry[3]:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    name = self.escape_menu(entry[0])</span>
<span class="gi">+                    sid = self.get_short_id(f&#39;{entry[2]}:{entry[3]}&#39;)</span>
<span class="gi">+                    desc = self.escape_arg(entry[6])</span>
<span class="gi">+                    me = self.format_menu_entry(name, sid, desc)</span>
<span class="gi">+                    ret.append(me)</span>
<span class="gi">+            ret.append(&#39;@end menu\n&#39;)</span>
<span class="gi">+            return &#39;&#39;.join(ret)</span>
<span class="gi">+</span>
<span class="gi">+        if indices_config := self.config.texinfo_domain_indices:</span>
<span class="gi">+            if not isinstance(indices_config, bool):</span>
<span class="gi">+                check_names = True</span>
<span class="gi">+                indices_config = frozenset(indices_config)</span>
<span class="gi">+            else:</span>
<span class="gi">+                check_names = False</span>
<span class="gi">+            for domain_name in sorted(self.builder.env.domains):</span>
<span class="gi">+                domain = self.builder.env.domains[domain_name]</span>
<span class="gi">+                for index_cls in domain.indices:</span>
<span class="gi">+                    index_name = f&#39;{domain.name}-{index_cls.name}&#39;</span>
<span class="gi">+                    if check_names and index_name not in indices_config:</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    content, collapsed = index_cls(domain).generate(</span>
<span class="gi">+                        self.builder.docnames)</span>
<span class="gi">+                    if content:</span>
<span class="gi">+                        self.indices.append((</span>
<span class="gi">+                            index_cls.localname,</span>
<span class="gi">+                            generate(content, collapsed),</span>
<span class="gi">+                        ))</span>
<span class="gi">+        # only add the main Index if it&#39;s not empty</span>
<span class="gi">+        domain = cast(IndexDomain, self.builder.env.get_domain(&#39;index&#39;))</span>
<span class="gi">+        for docname in self.builder.docnames:</span>
<span class="gi">+            if domain.entries[docname]:</span>
<span class="gi">+                self.indices.append((_(&#39;Index&#39;), &#39;\n@printindex ge\n&#39;))</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+    # this is copied from the latex writer</span>
<span class="gi">+    # TODO: move this to sphinx.util</span>
<span class="gi">+</span>
<span class="gi">+    def collect_footnotes(</span>
<span class="gi">+        self, node: Element,</span>
<span class="gi">+    ) -&gt; dict[str, list[collected_footnote | bool]]:</span>
<span class="gi">+        def footnotes_under(n: Element) -&gt; Iterator[nodes.footnote]:</span>
<span class="gi">+            if isinstance(n, nodes.footnote):</span>
<span class="gi">+                yield n</span>
<span class="gi">+            else:</span>
<span class="gi">+                for c in n.children:</span>
<span class="gi">+                    if isinstance(c, addnodes.start_of_file):</span>
<span class="gi">+                        continue</span>
<span class="gi">+                    elif isinstance(c, nodes.Element):</span>
<span class="gi">+                        yield from footnotes_under(c)</span>
<span class="gi">+        fnotes: dict[str, list[collected_footnote | bool]] = {}</span>
<span class="gi">+        for fn in footnotes_under(node):</span>
<span class="gi">+            label = cast(nodes.label, fn[0])</span>
<span class="gi">+            num = label.astext().strip()</span>
<span class="gi">+            fnotes[num] = [collected_footnote(&#39;&#39;, *fn.children), False]</span>
<span class="gi">+        return fnotes</span>
<span class="gi">+</span>
<span class="gi">+    # -- xref handling</span>
<span class="gi">+</span>
<span class="gi">+    def get_short_id(self, id: str) -&gt; str:</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a shorter &#39;id&#39; associated with ``id``.&quot;&quot;&quot;
<span class="gi">+        # Shorter ids improve paragraph filling in places</span>
<span class="gi">+        # that the id is hidden by Emacs.</span>
<span class="gi">+        try:</span>
<span class="gi">+            sid = self.short_ids[id]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            sid = f&#39;{len(self.short_ids):x}&#39;</span>
<span class="gi">+            self.short_ids[id] = sid</span>
<span class="gi">+        return sid</span>
<span class="gi">+</span>
<span class="gi">+    def add_anchor(self, id: str, node: Node) -&gt; None:</span>
<span class="gi">+        if id.startswith(&#39;index-&#39;):</span>
<span class="gi">+            return</span>
<span class="gi">+        id = self.curfilestack[-1] + &#39;:&#39; + id</span>
<span class="gi">+        eid = self.escape_id(id)</span>
<span class="gi">+        sid = self.get_short_id(id)</span>
<span class="gi">+        for id in (eid, sid):</span>
<span class="gi">+            if id not in self.written_ids:</span>
<span class="gi">+                self.body.append(&#39;@anchor{%s}&#39; % id)</span>
<span class="gi">+                self.written_ids.add(id)</span>
<span class="gi">+</span>
<span class="gi">+    def add_xref(self, id: str, name: str, node: Node) -&gt; None:</span>
<span class="gi">+        name = self.escape_menu(name)</span>
<span class="gi">+        sid = self.get_short_id(id)</span>
<span class="gi">+        if self.config.texinfo_cross_references:</span>
<span class="gi">+            self.body.append(f&#39;@ref{{{sid},,{name}}}&#39;)</span>
<span class="gi">+            self.referenced_ids.add(sid)</span>
<span class="gi">+            self.referenced_ids.add(self.escape_id(id))</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.body.append(name)</span>
<span class="gi">+</span>
<span class="gi">+    # -- Visiting</span>
<span class="gi">+</span>
<span class="gi">+    def visit_document(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.footnotestack.append(self.collect_footnotes(node))</span>
<span class="gi">+        self.curfilestack.append(node.get(&#39;docname&#39;, &#39;&#39;))</span>
<span class="gi">+        if &#39;docname&#39; in node:</span>
<span class="gi">+            self.add_anchor(&#39;:doc&#39;, node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_document(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.footnotestack.pop()</span>
<span class="gi">+        self.curfilestack.pop()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Text(self, node: Text) -&gt; None:</span>
<span class="gi">+        s = self.escape(node.astext())</span>
<span class="gi">+        if self.escape_newlines:</span>
<span class="gi">+            s = s.replace(&#39;\n&#39;, &#39; &#39;)</span>
<span class="gi">+        if self.escape_hyphens:</span>
<span class="gi">+            # prevent &quot;--&quot; and &quot;---&quot; conversion</span>
<span class="gi">+            s = s.replace(&#39;-&#39;, &#39;@w{-}&#39;)</span>
<span class="gi">+        self.body.append(s)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_Text(self, node: Text) -&gt; None:</span>
<span class="w"> </span>        pass
<span class="gd">-    headings = (&#39;@unnumbered&#39;, &#39;@chapter&#39;, &#39;@section&#39;, &#39;@subsection&#39;,</span>
<span class="gd">-        &#39;@subsubsection&#39;)</span>
<span class="gd">-    rubrics = &#39;@heading&#39;, &#39;@subheading&#39;, &#39;@subsubheading&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def visit_section(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.next_section_ids.update(node.get(&#39;ids&#39;, []))</span>
<span class="gi">+        if not self.seen_title:</span>
<span class="gi">+            return</span>
<span class="gi">+        if self.previous_section:</span>
<span class="gi">+            self.add_menu(self.previous_section[&#39;node_name&#39;])</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.add_menu(&#39;Top&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        node_name = node[&#39;node_name&#39;]</span>
<span class="gi">+        pointers = tuple([node_name] + self.rellinks[node_name])</span>
<span class="gi">+        self.body.append(&#39;\n@node %s,%s,%s,%s\n&#39; % pointers)</span>
<span class="gi">+        for id in sorted(self.next_section_ids):</span>
<span class="gi">+            self.add_anchor(id, node)</span>
<span class="gi">+</span>
<span class="gi">+        self.next_section_ids.clear()</span>
<span class="gi">+        self.previous_section = cast(nodes.section, node)</span>
<span class="gi">+        self.section_level += 1</span>
<span class="gi">+</span>
<span class="gi">+    def depart_section(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.section_level -= 1</span>
<span class="gi">+</span>
<span class="gi">+    headings = (</span>
<span class="gi">+        &#39;@unnumbered&#39;,</span>
<span class="gi">+        &#39;@chapter&#39;,</span>
<span class="gi">+        &#39;@section&#39;,</span>
<span class="gi">+        &#39;@subsection&#39;,</span>
<span class="gi">+        &#39;@subsubsection&#39;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    rubrics = (</span>
<span class="gi">+        &#39;@heading&#39;,</span>
<span class="gi">+        &#39;@subheading&#39;,</span>
<span class="gi">+        &#39;@subsubheading&#39;,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def visit_title(self, node: Element) -&gt; None:</span>
<span class="gi">+        if not self.seen_title:</span>
<span class="gi">+            self.seen_title = True</span>
<span class="gi">+            raise nodes.SkipNode</span>
<span class="gi">+        parent = node.parent</span>
<span class="gi">+        if isinstance(parent, nodes.table):</span>
<span class="gi">+            return</span>
<span class="gi">+        if isinstance(parent, nodes.Admonition | nodes.sidebar | nodes.topic):</span>
<span class="gi">+            raise nodes.SkipNode</span>
<span class="gi">+        if not isinstance(parent, nodes.section):</span>
<span class="gi">+            logger.warning(__(&#39;encountered title node not in section, topic, table, &#39;</span>
<span class="gi">+                              &#39;admonition or sidebar&#39;),</span>
<span class="gi">+                           location=node)</span>
<span class="gi">+            self.visit_rubric(node)</span>
<span class="gi">+        else:</span>
<span class="gi">+            try:</span>
<span class="gi">+                heading = self.headings[self.section_level]</span>
<span class="gi">+            except IndexError:</span>
<span class="gi">+                heading = self.headings[-1]</span>
<span class="gi">+            self.body.append(&#39;\n%s &#39; % heading)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_title(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_rubric(self, node: Element) -&gt; None:</span>
<span class="gi">+        if len(node) == 1 and node.astext() in (&#39;Footnotes&#39;, _(&#39;Footnotes&#39;)):</span>
<span class="gi">+            raise nodes.SkipNode</span>
<span class="gi">+        try:</span>
<span class="gi">+            rubric = self.rubrics[self.section_level]</span>
<span class="gi">+        except IndexError:</span>
<span class="gi">+            rubric = self.rubrics[-1]</span>
<span class="gi">+        self.body.append(&#39;\n%s &#39; % rubric)</span>
<span class="gi">+        self.escape_newlines += 1</span>
<span class="gi">+</span>
<span class="gi">+    def depart_rubric(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.escape_newlines -= 1</span>
<span class="gi">+        self.body.append(&#39;\n\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_subtitle(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n\n@noindent\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_subtitle(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # -- References</span>
<span class="gi">+</span>
<span class="gi">+    def visit_target(self, node: Element) -&gt; None:</span>
<span class="gi">+        # postpone the labels until after the sectioning command</span>
<span class="gi">+        parindex = node.parent.index(node)</span>
<span class="gi">+        try:</span>
<span class="gi">+            try:</span>
<span class="gi">+                next = node.parent[parindex + 1]</span>
<span class="gi">+            except IndexError:</span>
<span class="gi">+                # last node in parent, look at next after parent</span>
<span class="gi">+                # (for section of equal level)</span>
<span class="gi">+                next = node.parent.parent[node.parent.parent.index(node.parent)]</span>
<span class="gi">+            if isinstance(next, nodes.section):</span>
<span class="gi">+                if node.get(&#39;refid&#39;):</span>
<span class="gi">+                    self.next_section_ids.add(node[&#39;refid&#39;])</span>
<span class="gi">+                self.next_section_ids.update(node[&#39;ids&#39;])</span>
<span class="gi">+                return</span>
<span class="gi">+        except (IndexError, AttributeError):</span>
<span class="gi">+            pass</span>
<span class="gi">+        if &#39;refuri&#39; in node:</span>
<span class="gi">+            return</span>
<span class="gi">+        if node.get(&#39;refid&#39;):</span>
<span class="gi">+            self.add_anchor(node[&#39;refid&#39;], node)</span>
<span class="gi">+        for id in node[&#39;ids&#39;]:</span>
<span class="gi">+            self.add_anchor(id, node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_target(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        # an xref&#39;s target is displayed in Info so we ignore a few</span>
<span class="gi">+        # cases for the sake of appearance</span>
<span class="gi">+        if isinstance(node.parent, nodes.title | addnodes.desc_type):</span>
<span class="gi">+            return</span>
<span class="gi">+        if len(node) != 0 and isinstance(node[0], nodes.image):</span>
<span class="gi">+            return</span>
<span class="gi">+        name = node.get(&#39;name&#39;, node.astext()).strip()</span>
<span class="gi">+        uri = node.get(&#39;refuri&#39;, &#39;&#39;)</span>
<span class="gi">+        if not uri and node.get(&#39;refid&#39;):</span>
<span class="gi">+            uri = &#39;%&#39; + self.curfilestack[-1] + &#39;#&#39; + node[&#39;refid&#39;]</span>
<span class="gi">+        if not uri:</span>
<span class="gi">+            return</span>
<span class="gi">+        if uri.startswith(&#39;mailto:&#39;):</span>
<span class="gi">+            uri = self.escape_arg(uri[7:])</span>
<span class="gi">+            name = self.escape_arg(name)</span>
<span class="gi">+            if not name or name == uri:</span>
<span class="gi">+                self.body.append(&#39;@email{%s}&#39; % uri)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.body.append(f&#39;@email{{{uri},{name}}}&#39;)</span>
<span class="gi">+        elif uri.startswith(&#39;#&#39;):</span>
<span class="gi">+            # references to labels in the same document</span>
<span class="gi">+            id = self.curfilestack[-1] + &#39;:&#39; + uri[1:]</span>
<span class="gi">+            self.add_xref(id, name, node)</span>
<span class="gi">+        elif uri.startswith(&#39;%&#39;):</span>
<span class="gi">+            # references to documents or labels inside documents</span>
<span class="gi">+            hashindex = uri.find(&#39;#&#39;)</span>
<span class="gi">+            if hashindex == -1:</span>
<span class="gi">+                # reference to the document</span>
<span class="gi">+                id = uri[1:] + &#39;::doc&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                # reference to a label</span>
<span class="gi">+                id = uri[1:].replace(&#39;#&#39;, &#39;:&#39;)</span>
<span class="gi">+            self.add_xref(id, name, node)</span>
<span class="gi">+        elif uri.startswith(&#39;info:&#39;):</span>
<span class="gi">+            # references to an external Info file</span>
<span class="gi">+            uri = uri[5:].replace(&#39;_&#39;, &#39; &#39;)</span>
<span class="gi">+            uri = self.escape_arg(uri)</span>
<span class="gi">+            id = &#39;Top&#39;</span>
<span class="gi">+            if &#39;#&#39; in uri:</span>
<span class="gi">+                uri, id = uri.split(&#39;#&#39;, 1)</span>
<span class="gi">+            id = self.escape_id(id)</span>
<span class="gi">+            name = self.escape_menu(name)</span>
<span class="gi">+            if name == id:</span>
<span class="gi">+                self.body.append(f&#39;@ref{{{id},,,{uri}}}&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.body.append(f&#39;@ref{{{id},,{name},{uri}}}&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            uri = self.escape_arg(uri)</span>
<span class="gi">+            name = self.escape_arg(name)</span>
<span class="gi">+            show_urls = self.config.texinfo_show_urls</span>
<span class="gi">+            if self.in_footnote:</span>
<span class="gi">+                show_urls = &#39;inline&#39;</span>
<span class="gi">+            if not name or uri == name:</span>
<span class="gi">+                self.body.append(&#39;@indicateurl{%s}&#39; % uri)</span>
<span class="gi">+            elif show_urls == &#39;inline&#39;:</span>
<span class="gi">+                self.body.append(f&#39;@uref{{{uri},{name}}}&#39;)</span>
<span class="gi">+            elif show_urls == &#39;no&#39;:</span>
<span class="gi">+                self.body.append(f&#39;@uref{{{uri},,{name}}}&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.body.append(f&#39;{name}@footnote{{{uri}}}&#39;)</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def depart_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_number_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        text = nodes.Text(node.get(&#39;title&#39;, &#39;#&#39;))</span>
<span class="gi">+        self.visit_Text(text)</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_title_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        text = node.astext()</span>
<span class="gi">+        self.body.append(&#39;@cite{%s}&#39; % self.escape_arg(text))</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    # -- Blocks</span>
<span class="gi">+</span>
<span class="gi">+    def visit_paragraph(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_paragraph(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_block_quote(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n@quotation\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_block_quote(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.ensure_eol()</span>
<span class="gi">+        self.body.append(&#39;@end quotation\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_literal_block(self, node: Element | None) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n@example\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_literal_block(self, node: Element | None) -&gt; None:</span>
<span class="gi">+        self.ensure_eol()</span>
<span class="gi">+        self.body.append(&#39;@end example\n&#39;)</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_doctest_block = visit_literal_block
<span class="w"> </span>    depart_doctest_block = depart_literal_block
<span class="gi">+</span>
<span class="gi">+    def visit_line_block(self, node: Element) -&gt; None:</span>
<span class="gi">+        if not isinstance(node.parent, nodes.line_block):</span>
<span class="gi">+            self.body.append(&#39;\n\n&#39;)</span>
<span class="gi">+        self.body.append(&#39;@display\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_line_block(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;@end display\n&#39;)</span>
<span class="gi">+        if not isinstance(node.parent, nodes.line_block):</span>
<span class="gi">+            self.body.append(&#39;\n\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_line(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.escape_newlines += 1</span>
<span class="gi">+</span>
<span class="gi">+    def depart_line(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;@w{ }\n&#39;)</span>
<span class="gi">+        self.escape_newlines -= 1</span>
<span class="gi">+</span>
<span class="gi">+    # -- Inline</span>
<span class="gi">+</span>
<span class="gi">+    def visit_strong(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;`&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_strong(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&quot;&#39;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_emphasis(self, node: Element) -&gt; None:</span>
<span class="gi">+        if self.in_samp:</span>
<span class="gi">+            self.body.append(&#39;@var{&#39;)</span>
<span class="gi">+            self.context.append(&#39;}&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.body.append(&#39;`&#39;)</span>
<span class="gi">+            self.context.append(&quot;&#39;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_emphasis(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(self.context.pop())</span>
<span class="gi">+</span>
<span class="gi">+    def is_samp(self, node: Element) -&gt; bool:</span>
<span class="gi">+        return &#39;samp&#39; in node[&#39;classes&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    def visit_literal(self, node: Element) -&gt; None:</span>
<span class="gi">+        if self.is_samp(node):</span>
<span class="gi">+            self.in_samp += 1</span>
<span class="gi">+        self.body.append(&#39;@code{&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_literal(self, node: Element) -&gt; None:</span>
<span class="gi">+        if self.is_samp(node):</span>
<span class="gi">+            self.in_samp -= 1</span>
<span class="gi">+        self.body.append(&#39;}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_superscript(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;@w{^&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_superscript(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_subscript(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;@w{[&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_subscript(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;]}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # -- Footnotes</span>
<span class="gi">+</span>
<span class="gi">+    def visit_footnote(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_collected_footnote(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.in_footnote += 1</span>
<span class="gi">+        self.body.append(&#39;@footnote{&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_collected_footnote(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;}&#39;)</span>
<span class="gi">+        self.in_footnote -= 1</span>
<span class="gi">+</span>
<span class="gi">+    def visit_footnote_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        num = node.astext().strip()</span>
<span class="gi">+        try:</span>
<span class="gi">+            footnode, used = self.footnotestack[-1][num]</span>
<span class="gi">+        except (KeyError, IndexError) as exc:</span>
<span class="gi">+            raise nodes.SkipNode from exc</span>
<span class="gi">+        # footnotes are repeated for each reference</span>
<span class="gi">+        footnode.walkabout(self)  # type: ignore[union-attr]</span>
<span class="gi">+        raise nodes.SkipChildren</span>
<span class="gi">+</span>
<span class="gi">+    def visit_citation(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n&#39;)</span>
<span class="gi">+        for id in node.get(&#39;ids&#39;):</span>
<span class="gi">+            self.add_anchor(id, node)</span>
<span class="gi">+        self.escape_newlines += 1</span>
<span class="gi">+</span>
<span class="gi">+    def depart_citation(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.escape_newlines -= 1</span>
<span class="gi">+</span>
<span class="gi">+    def visit_citation_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;@w{[&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_citation_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;]}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # -- Lists</span>
<span class="gi">+</span>
<span class="gi">+    def visit_bullet_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        bullet = node.get(&#39;bullet&#39;, &#39;*&#39;)</span>
<span class="gi">+        self.body.append(&#39;\n\n@itemize %s\n&#39; % bullet)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_bullet_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.ensure_eol()</span>
<span class="gi">+        self.body.append(&#39;@end itemize\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_enumerated_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        # doesn&#39;t support Roman numerals</span>
<span class="gi">+        enum = node.get(&#39;enumtype&#39;, &#39;arabic&#39;)</span>
<span class="gi">+        starters = {&#39;arabic&#39;: &#39;&#39;,</span>
<span class="gi">+                    &#39;loweralpha&#39;: &#39;a&#39;,</span>
<span class="gi">+                    &#39;upperalpha&#39;: &#39;A&#39;}</span>
<span class="gi">+        start = node.get(&#39;start&#39;, starters.get(enum, &#39;&#39;))</span>
<span class="gi">+        self.body.append(&#39;\n\n@enumerate %s\n&#39; % start)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_enumerated_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.ensure_eol()</span>
<span class="gi">+        self.body.append(&#39;@end enumerate\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_list_item(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n@item &#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_list_item(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    # -- Option List</span>
<span class="gi">+</span>
<span class="gi">+    def visit_option_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n\n@table @option\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_option_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.ensure_eol()</span>
<span class="gi">+        self.body.append(&#39;@end table\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_option_list_item(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_option_list_item(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_option_group(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.at_item_x = &#39;@item&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def depart_option_group(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_option(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.escape_hyphens += 1</span>
<span class="gi">+        self.body.append(&#39;\n%s &#39; % self.at_item_x)</span>
<span class="gi">+        self.at_item_x = &#39;@itemx&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def depart_option(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.escape_hyphens -= 1</span>
<span class="gi">+</span>
<span class="gi">+    def visit_option_string(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_option_string(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_option_argument(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(node.get(&#39;delimiter&#39;, &#39; &#39;))</span>
<span class="gi">+</span>
<span class="gi">+    def depart_option_argument(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_description(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_description(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    # -- Definitions</span>
<span class="gi">+</span>
<span class="gi">+    def visit_definition_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n\n@table @asis\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_definition_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.ensure_eol()</span>
<span class="gi">+        self.body.append(&#39;@end table\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_definition_list_item(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.at_item_x = &#39;@item&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def depart_definition_list_item(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_term(self, node: Element) -&gt; None:</span>
<span class="gi">+        for id in node.get(&#39;ids&#39;):</span>
<span class="gi">+            self.add_anchor(id, node)</span>
<span class="gi">+        # anchors and indexes need to go in front</span>
<span class="gi">+        for n in node[::]:</span>
<span class="gi">+            if isinstance(n, addnodes.index | nodes.target):</span>
<span class="gi">+                n.walkabout(self)</span>
<span class="gi">+                node.remove(n)</span>
<span class="gi">+        self.body.append(&#39;\n%s &#39; % self.at_item_x)</span>
<span class="gi">+        self.at_item_x = &#39;@itemx&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def depart_term(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_classifier(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39; : &#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_classifier(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_definition(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_definition(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    # -- Tables</span>
<span class="gi">+</span>
<span class="gi">+    def visit_table(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.entry_sep = &#39;@item&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def depart_table(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n@end multitable\n\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_tabular_col_spec(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_tabular_col_spec(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_colspec(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.colwidths.append(node[&#39;colwidth&#39;])</span>
<span class="gi">+        if len(self.colwidths) != self.n_cols:</span>
<span class="gi">+            return</span>
<span class="gi">+        self.body.append(&#39;\n\n@multitable &#39;)</span>
<span class="gi">+        for n in self.colwidths:</span>
<span class="gi">+            self.body.append(&#39;{%s} &#39; % (&#39;x&#39; * (n + 2)))</span>
<span class="gi">+</span>
<span class="gi">+    def depart_colspec(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_tgroup(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.colwidths = []</span>
<span class="gi">+        self.n_cols = node[&#39;cols&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    def depart_tgroup(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_thead(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.entry_sep = &#39;@headitem&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def depart_thead(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_tbody(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_tbody(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_row(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_row(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.entry_sep = &#39;@item&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def visit_entry(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n%s\n&#39; % self.entry_sep)</span>
<span class="gi">+        self.entry_sep = &#39;@tab&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def depart_entry(self, node: Element) -&gt; None:</span>
<span class="gi">+        for _i in range(node.get(&#39;morecols&#39;, 0)):</span>
<span class="gi">+            self.body.append(&#39;\n@tab\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # -- Field Lists</span>
<span class="gi">+</span>
<span class="gi">+    def visit_field_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_field_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_field(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_field(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_field_name(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.ensure_eol()</span>
<span class="gi">+        self.body.append(&#39;@*&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_field_name(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;: &#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_field_body(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_field_body(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    # -- Admonitions</span>
<span class="gi">+</span>
<span class="gi">+    def visit_admonition(self, node: Element, name: str = &#39;&#39;) -&gt; None:</span>
<span class="gi">+        if not name:</span>
<span class="gi">+            title = cast(nodes.title, node[0])</span>
<span class="gi">+            name = self.escape(title.astext())</span>
<span class="gi">+        self.body.append(&#39;\n@cartouche\n@quotation %s &#39; % name)</span>
<span class="gi">+</span>
<span class="gi">+    def _visit_named_admonition(self, node: Element) -&gt; None:</span>
<span class="gi">+        label = admonitionlabels[node.tagname]</span>
<span class="gi">+        self.body.append(&#39;\n@cartouche\n@quotation %s &#39; % label)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_admonition(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.ensure_eol()</span>
<span class="gi">+        self.body.append(&#39;@end quotation\n&#39;</span>
<span class="gi">+                         &#39;@end cartouche\n&#39;)</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_attention = _visit_named_admonition
<span class="w"> </span>    depart_attention = depart_admonition
<span class="w"> </span>    visit_caution = _visit_named_admonition
<span class="gu">@@ -202,3 +1128,453 @@ class TexinfoTranslator(SphinxTranslator):</span>
<span class="w"> </span>    depart_tip = depart_admonition
<span class="w"> </span>    visit_warning = _visit_named_admonition
<span class="w"> </span>    depart_warning = depart_admonition
<span class="gi">+</span>
<span class="gi">+    # -- Misc</span>
<span class="gi">+</span>
<span class="gi">+    def visit_docinfo(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_generated(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_header(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_footer(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_container(self, node: Element) -&gt; None:</span>
<span class="gi">+        if node.get(&#39;literal_block&#39;):</span>
<span class="gi">+            self.body.append(&#39;\n\n@float LiteralBlock\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_container(self, node: Element) -&gt; None:</span>
<span class="gi">+        if node.get(&#39;literal_block&#39;):</span>
<span class="gi">+            self.body.append(&#39;\n@end float\n\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_decoration(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_decoration(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_topic(self, node: Element) -&gt; None:</span>
<span class="gi">+        # ignore TOC&#39;s since we have to have a &quot;menu&quot; anyway</span>
<span class="gi">+        if &#39;contents&#39; in node.get(&#39;classes&#39;, []):</span>
<span class="gi">+            raise nodes.SkipNode</span>
<span class="gi">+        title = cast(nodes.title, node[0])</span>
<span class="gi">+        self.visit_rubric(title)</span>
<span class="gi">+        self.body.append(&#39;%s\n&#39; % self.escape(title.astext()))</span>
<span class="gi">+        self.depart_rubric(title)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_topic(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_transition(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n\n%s\n\n&#39; % (&#39;_&#39; * 66))</span>
<span class="gi">+</span>
<span class="gi">+    def depart_transition(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_attribution(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n\n@center --- &#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_attribution(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_raw(self, node: Element) -&gt; None:</span>
<span class="gi">+        format = node.get(&#39;format&#39;, &#39;&#39;).split()</span>
<span class="gi">+        if &#39;texinfo&#39; in format or &#39;texi&#39; in format:</span>
<span class="gi">+            self.body.append(node.astext())</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_figure(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n\n@float Figure\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_figure(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n@end float\n\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_caption(self, node: Element) -&gt; None:</span>
<span class="gi">+        if (isinstance(node.parent, nodes.figure) or</span>
<span class="gi">+           (isinstance(node.parent, nodes.container) and</span>
<span class="gi">+                node.parent.get(&#39;literal_block&#39;))):</span>
<span class="gi">+            self.body.append(&#39;\n@caption{&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            logger.warning(__(&#39;caption not inside a figure.&#39;),</span>
<span class="gi">+                           location=node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_caption(self, node: Element) -&gt; None:</span>
<span class="gi">+        if (isinstance(node.parent, nodes.figure) or</span>
<span class="gi">+           (isinstance(node.parent, nodes.container) and</span>
<span class="gi">+                node.parent.get(&#39;literal_block&#39;))):</span>
<span class="gi">+            self.body.append(&#39;}\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_image(self, node: Element) -&gt; None:</span>
<span class="gi">+        if node[&#39;uri&#39;] in self.builder.images:</span>
<span class="gi">+            uri = self.builder.images[node[&#39;uri&#39;]]</span>
<span class="gi">+        else:</span>
<span class="gi">+            # missing image!</span>
<span class="gi">+            if self.ignore_missing_images:</span>
<span class="gi">+                return</span>
<span class="gi">+            uri = node[&#39;uri&#39;]</span>
<span class="gi">+        if uri.find(&#39;://&#39;) != -1:</span>
<span class="gi">+            # ignore remote images</span>
<span class="gi">+            return</span>
<span class="gi">+        name, ext = path.splitext(uri)</span>
<span class="gi">+        # width and height ignored in non-tex output</span>
<span class="gi">+        width = self.tex_image_length(node.get(&#39;width&#39;, &#39;&#39;))</span>
<span class="gi">+        height = self.tex_image_length(node.get(&#39;height&#39;, &#39;&#39;))</span>
<span class="gi">+        alt = self.escape_arg(node.get(&#39;alt&#39;, &#39;&#39;))</span>
<span class="gi">+        filename = f&quot;{self.elements[&#39;filename&#39;][:-5]}-figures/{name}&quot;  # type: ignore[index]</span>
<span class="gi">+        self.body.append(&#39;\n@image{%s,%s,%s,%s,%s}\n&#39; %</span>
<span class="gi">+                         (filename, width, height, alt, ext[1:]))</span>
<span class="gi">+</span>
<span class="gi">+    def depart_image(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_compound(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_compound(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_sidebar(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_topic(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_sidebar(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.depart_topic(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_label(self, node: Element) -&gt; None:</span>
<span class="gi">+        # label numbering is automatically generated by Texinfo</span>
<span class="gi">+        if self.in_footnote:</span>
<span class="gi">+            raise nodes.SkipNode</span>
<span class="gi">+        self.body.append(&#39;@w{(&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_label(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;)} &#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_legend(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_legend(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_substitution_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_substitution_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_substitution_definition(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_system_message(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n@verbatim\n&#39;</span>
<span class="gi">+                         &#39;&lt;SYSTEM MESSAGE: %s&gt;\n&#39;</span>
<span class="gi">+                         &#39;@end verbatim\n&#39; % node.astext())</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_comment(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n&#39;)</span>
<span class="gi">+        for line in node.astext().splitlines():</span>
<span class="gi">+            self.body.append(&#39;@c %s\n&#39; % line)</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_problematic(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;&gt;&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_problematic(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;&lt;&lt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def unimplemented_visit(self, node: Element) -&gt; None:</span>
<span class="gi">+        logger.warning(__(&quot;unimplemented node type: %r&quot;), node,</span>
<span class="gi">+                       location=node)</span>
<span class="gi">+</span>
<span class="gi">+    def unknown_departure(self, node: Node) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    # -- Sphinx specific</span>
<span class="gi">+</span>
<span class="gi">+    def visit_productionlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_literal_block(None)</span>
<span class="gi">+        productionlist = cast(Iterable[addnodes.production], node)</span>
<span class="gi">+        names = (production[&#39;tokenname&#39;] for production in productionlist)</span>
<span class="gi">+        maxlen = max(len(name) for name in names)</span>
<span class="gi">+</span>
<span class="gi">+        for production in productionlist:</span>
<span class="gi">+            if production[&#39;tokenname&#39;]:</span>
<span class="gi">+                for id in production.get(&#39;ids&#39;):</span>
<span class="gi">+                    self.add_anchor(id, production)</span>
<span class="gi">+                s = production[&#39;tokenname&#39;].ljust(maxlen) + &#39; ::=&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                s = &#39;%s    &#39; % (&#39; &#39; * maxlen)</span>
<span class="gi">+            self.body.append(self.escape(s))</span>
<span class="gi">+            self.body.append(self.escape(production.astext() + &#39;\n&#39;))</span>
<span class="gi">+        self.depart_literal_block(None)</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_production(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_production(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_literal_emphasis(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;@code{&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_literal_emphasis(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_literal_strong(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;@code{&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_literal_strong(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_index(self, node: Element) -&gt; None:</span>
<span class="gi">+        # terminate the line but don&#39;t prevent paragraph breaks</span>
<span class="gi">+        if isinstance(node.parent, nodes.paragraph):</span>
<span class="gi">+            self.ensure_eol()</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.body.append(&#39;\n&#39;)</span>
<span class="gi">+        for (_entry_type, value, _target_id, _main, _category_key) in node[&#39;entries&#39;]:</span>
<span class="gi">+            text = self.escape_menu(value)</span>
<span class="gi">+            self.body.append(&#39;@geindex %s\n&#39; % text)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_versionmodified(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_versionmodified(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_start_of_file(self, node: Element) -&gt; None:</span>
<span class="gi">+        # add a document target</span>
<span class="gi">+        self.next_section_ids.add(&#39;:doc&#39;)</span>
<span class="gi">+        self.curfilestack.append(node[&#39;docname&#39;])</span>
<span class="gi">+        self.footnotestack.append(self.collect_footnotes(node))</span>
<span class="gi">+</span>
<span class="gi">+    def depart_start_of_file(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.curfilestack.pop()</span>
<span class="gi">+        self.footnotestack.pop()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_centered(self, node: Element) -&gt; None:</span>
<span class="gi">+        txt = self.escape_arg(node.astext())</span>
<span class="gi">+        self.body.append(&#39;\n\n@center %s\n\n&#39; % txt)</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_seealso(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n\n@subsubheading %s\n\n&#39; %</span>
<span class="gi">+                         admonitionlabels[&#39;seealso&#39;])</span>
<span class="gi">+</span>
<span class="gi">+    def depart_seealso(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_meta(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_glossary(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_glossary(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_acks(self, node: Element) -&gt; None:</span>
<span class="gi">+        bullet_list = cast(nodes.bullet_list, node[0])</span>
<span class="gi">+        list_items = cast(Iterable[nodes.list_item], bullet_list)</span>
<span class="gi">+        self.body.append(&#39;\n\n&#39;)</span>
<span class="gi">+        self.body.append(&#39;, &#39;.join(n.astext() for n in list_items) + &#39;.&#39;)</span>
<span class="gi">+        self.body.append(&#39;\n\n&#39;)</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    #############################################################</span>
<span class="gi">+    # Domain-specific object descriptions</span>
<span class="gi">+    #############################################################</span>
<span class="gi">+</span>
<span class="gi">+    # Top-level nodes for descriptions</span>
<span class="gi">+    ##################################</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc(self, node: addnodes.desc) -&gt; None:</span>
<span class="gi">+        self.descs.append(node)</span>
<span class="gi">+        self.at_deffnx = &#39;@deffn&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc(self, node: addnodes.desc) -&gt; None:</span>
<span class="gi">+        self.descs.pop()</span>
<span class="gi">+        self.ensure_eol()</span>
<span class="gi">+        self.body.append(&#39;@end deffn\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_signature(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.escape_hyphens += 1</span>
<span class="gi">+        objtype = node.parent[&#39;objtype&#39;]</span>
<span class="gi">+        if objtype != &#39;describe&#39;:</span>
<span class="gi">+            for id in node.get(&#39;ids&#39;):</span>
<span class="gi">+                self.add_anchor(id, node)</span>
<span class="gi">+        # use the full name of the objtype for the category</span>
<span class="gi">+        try:</span>
<span class="gi">+            domain = self.builder.env.get_domain(node.parent[&#39;domain&#39;])</span>
<span class="gi">+            name = domain.get_type_name(domain.object_types[objtype],</span>
<span class="gi">+                                        self.config.primary_domain == domain.name)</span>
<span class="gi">+        except (KeyError, ExtensionError):</span>
<span class="gi">+            name = objtype</span>
<span class="gi">+        # by convention, the deffn category should be capitalized like a title</span>
<span class="gi">+        category = self.escape_arg(smart_capwords(name))</span>
<span class="gi">+        self.body.append(f&#39;\n{self.at_deffnx} {{{category}}} &#39;)</span>
<span class="gi">+        self.at_deffnx = &#39;@deffnx&#39;</span>
<span class="gi">+        self.desc_type_name: str | None = name</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_signature(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&quot;\n&quot;)</span>
<span class="gi">+        self.escape_hyphens -= 1</span>
<span class="gi">+        self.desc_type_name = None</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_signature_line(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_signature_line(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_content(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_content(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_inline(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_inline(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    # Nodes for high-level structure in signatures</span>
<span class="gi">+    ##############################################</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_name(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_name(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_addname(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_addname(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_type(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_type(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_returns(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39; -&gt; &#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_returns(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_parameterlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39; (&#39;)</span>
<span class="gi">+        self.first_param = 1</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_parameterlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_type_parameter_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39; [&#39;)</span>
<span class="gi">+        self.first_param = 1</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_type_parameter_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;]&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_parameter(self, node: Element) -&gt; None:</span>
<span class="gi">+        if not self.first_param:</span>
<span class="gi">+            self.body.append(&#39;, &#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.first_param = 0</span>
<span class="gi">+        text = self.escape(node.astext())</span>
<span class="gi">+        # replace no-break spaces with normal ones</span>
<span class="gi">+        text = text.replace(&#39;&#39;, &#39;@w{ }&#39;)</span>
<span class="gi">+        self.body.append(text)</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_type_parameter(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_desc_parameter(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_optional(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;[&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_optional(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;]&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_annotation(self, node: Element) -&gt; None:</span>
<span class="gi">+        # Try to avoid duplicating info already displayed by the deffn category.</span>
<span class="gi">+        # e.g.</span>
<span class="gi">+        #     @deffn {Class} Foo</span>
<span class="gi">+        #     -- instead of --</span>
<span class="gi">+        #     @deffn {Class} class Foo</span>
<span class="gi">+        txt = node.astext().strip()</span>
<span class="gi">+        if ((self.descs and txt == self.descs[-1][&#39;objtype&#39;]) or</span>
<span class="gi">+                (self.desc_type_name and txt in self.desc_type_name.split())):</span>
<span class="gi">+            raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_annotation(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    ##############################################</span>
<span class="gi">+</span>
<span class="gi">+    def visit_inline(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_inline(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_abbreviation(self, node: Element) -&gt; None:</span>
<span class="gi">+        abbr = node.astext()</span>
<span class="gi">+        self.body.append(&#39;@abbr{&#39;)</span>
<span class="gi">+        if node.hasattr(&#39;explanation&#39;) and abbr not in self.handled_abbrs:</span>
<span class="gi">+            self.context.append(&#39;,%s}&#39; % self.escape_arg(node[&#39;explanation&#39;]))</span>
<span class="gi">+            self.handled_abbrs.add(abbr)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.context.append(&#39;}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_abbreviation(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(self.context.pop())</span>
<span class="gi">+</span>
<span class="gi">+    def visit_manpage(self, node: Element) -&gt; None:</span>
<span class="gi">+        return self.visit_literal_emphasis(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_manpage(self, node: Element) -&gt; None:</span>
<span class="gi">+        return self.depart_literal_emphasis(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_download_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_download_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_hlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_bullet_list(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_hlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.depart_bullet_list(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_hlistcol(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_hlistcol(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_pending_xref(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_pending_xref(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_math(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.body.append(&#39;@math{&#39; + self.escape_arg(node.astext()) + &#39;}&#39;)</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_math_block(self, node: Element) -&gt; None:</span>
<span class="gi">+        if node.get(&#39;label&#39;):</span>
<span class="gi">+            self.add_anchor(node[&#39;label&#39;], node)</span>
<span class="gi">+        self.body.append(&#39;\n\n@example\n%s\n@end example\n\n&#39; %</span>
<span class="gi">+                         self.escape_arg(node.astext()))</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gh">diff --git a/sphinx/writers/text.py b/sphinx/writers/text.py</span>
<span class="gh">index 2e3317450..67eca45f1 100644</span>
<span class="gd">--- a/sphinx/writers/text.py</span>
<span class="gi">+++ b/sphinx/writers/text.py</span>
<span class="gu">@@ -1,5 +1,6 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Custom docutils writer for plain text.&quot;&quot;&quot;
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>import math
<span class="w"> </span>import os
<span class="w"> </span>import re
<span class="gu">@@ -7,13 +8,17 @@ import textwrap</span>
<span class="w"> </span>from collections.abc import Iterable, Iterator, Sequence
<span class="w"> </span>from itertools import chain, groupby, pairwise
<span class="w"> </span>from typing import TYPE_CHECKING, Any, cast
<span class="gi">+</span>
<span class="w"> </span>from docutils import nodes, writers
<span class="w"> </span>from docutils.utils import column_width
<span class="gi">+</span>
<span class="w"> </span>from sphinx import addnodes
<span class="w"> </span>from sphinx.locale import _, admonitionlabels
<span class="w"> </span>from sphinx.util.docutils import SphinxTranslator
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from docutils.nodes import Element, Text
<span class="gi">+</span>
<span class="w"> </span>    from sphinx.builders.text import TextBuilder


<span class="gu">@@ -22,7 +27,7 @@ class Cell:</span>
<span class="w"> </span>    It can span multiple columns or multiple lines.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, text: str=&#39;&#39;, rowspan: int=1, colspan: int=1) -&gt;None:</span>
<span class="gi">+    def __init__(self, text: str = &quot;&quot;, rowspan: int = 1, colspan: int = 1) -&gt; None:</span>
<span class="w"> </span>        self.text = text
<span class="w"> </span>        self.wrapped: list[str] = []
<span class="w"> </span>        self.rowspan = rowspan
<span class="gu">@@ -30,17 +35,17 @@ class Cell:</span>
<span class="w"> </span>        self.col: int | None = None
<span class="w"> </span>        self.row: int | None = None

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return (</span>
<span class="gd">-            f&#39;&lt;Cell {self.text!r} {self.row}v{self.rowspan}/{self.col}&gt;{self.colspan}&gt;&#39;</span>
<span class="gd">-            )</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&quot;&lt;Cell {self.text!r} {self.row}v{self.rowspan}/{self.col}&gt;{self.colspan}&gt;&quot;</span>

<span class="gd">-    def __hash__(self) -&gt;int:</span>
<span class="gi">+    def __hash__(self) -&gt; int:</span>
<span class="w"> </span>        return hash((self.col, self.row))

<span class="gd">-    def __bool__(self) -&gt;bool:</span>
<span class="gd">-        return (self.text != &#39;&#39; and self.col is not None and self.row is not</span>
<span class="gd">-            None)</span>
<span class="gi">+    def __bool__(self) -&gt; bool:</span>
<span class="gi">+        return self.text != &#39;&#39; and self.col is not None and self.row is not None</span>
<span class="gi">+</span>
<span class="gi">+    def wrap(self, width: int) -&gt; None:</span>
<span class="gi">+        self.wrapped = my_wrap(self.text, width)</span>


<span class="w"> </span>class Table:
<span class="gu">@@ -90,38 +95,42 @@ class Table:</span>

<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, colwidth: (list[int] | None)=None) -&gt;None:</span>
<span class="gi">+    def __init__(self, colwidth: list[int] | None = None) -&gt; None:</span>
<span class="w"> </span>        self.lines: list[list[Cell]] = []
<span class="w"> </span>        self.separator = 0
<span class="gd">-        self.colwidth: list[int] = colwidth if colwidth is not None else []</span>
<span class="gi">+        self.colwidth: list[int] = (colwidth if colwidth is not None else [])</span>
<span class="w"> </span>        self.current_line = 0
<span class="w"> </span>        self.current_col = 0

<span class="gd">-    def add_row(self) -&gt;None:</span>
<span class="gi">+    def add_row(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a row to the table, to use with ``add_cell()``.  It is not needed
<span class="w"> </span>        to call ``add_row()`` before the first ``add_cell()``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.current_line += 1</span>
<span class="gi">+        self.current_col = 0</span>

<span class="gd">-    def set_separator(self) -&gt;None:</span>
<span class="gi">+    def set_separator(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Sets the separator below the current line.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.separator = len(self.lines)</span>

<span class="gd">-    def add_cell(self, cell: Cell) -&gt;None:</span>
<span class="gi">+    def add_cell(self, cell: Cell) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Add a cell to the current line, to use with ``add_row()``.  To add
<span class="w"> </span>        a cell spanning multiple lines or rows, simply set the
<span class="w"> </span>        ``cell.colspan`` or ``cell.rowspan`` BEFORE inserting it into
<span class="w"> </span>        the table.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        while self[self.current_line, self.current_col]:</span>
<span class="gi">+            self.current_col += 1</span>
<span class="gi">+        self[self.current_line, self.current_col] = cell</span>
<span class="gi">+        self.current_col += cell.colspan</span>

<span class="gd">-    def __getitem__(self, pos: tuple[int, int]) -&gt;Cell:</span>
<span class="gi">+    def __getitem__(self, pos: tuple[int, int]) -&gt; Cell:</span>
<span class="w"> </span>        line, col = pos
<span class="w"> </span>        self._ensure_has_line(line + 1)
<span class="w"> </span>        self._ensure_has_column(col + 1)
<span class="w"> </span>        return self.lines[line][col]

<span class="gd">-    def __setitem__(self, pos: tuple[int, int], cell: Cell) -&gt;None:</span>
<span class="gi">+    def __setitem__(self, pos: tuple[int, int], cell: Cell) -&gt; None:</span>
<span class="w"> </span>        line, col = pos
<span class="w"> </span>        self._ensure_has_line(line + cell.rowspan)
<span class="w"> </span>        self._ensure_has_column(col + cell.colspan)
<span class="gu">@@ -131,126 +140,245 @@ class Table:</span>
<span class="w"> </span>                cell.row = line
<span class="w"> </span>                cell.col = col

<span class="gd">-    def __repr__(self) -&gt;str:</span>
<span class="gd">-        return &#39;\n&#39;.join(map(repr, self.lines))</span>
<span class="gi">+    def _ensure_has_line(self, line: int) -&gt; None:</span>
<span class="gi">+        while len(self.lines) &lt; line:</span>
<span class="gi">+            self.lines.append([])</span>

<span class="gd">-    def cell_width(self, cell: Cell, source: list[int]) -&gt;int:</span>
<span class="gi">+    def _ensure_has_column(self, col: int) -&gt; None:</span>
<span class="gi">+        for line in self.lines:</span>
<span class="gi">+            while len(line) &lt; col:</span>
<span class="gi">+                line.append(Cell())</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return &quot;\n&quot;.join(map(repr, self.lines))</span>
<span class="gi">+</span>
<span class="gi">+    def cell_width(self, cell: Cell, source: list[int]) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;Give the cell width, according to the given source (either
<span class="w"> </span>        ``self.colwidth`` or ``self.measured_widths``).
<span class="w"> </span>        This takes into account cells spanning multiple columns.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if cell.row is None or cell.col is None:</span>
<span class="gi">+            msg = &#39;Cell co-ordinates have not been set&#39;</span>
<span class="gi">+            raise ValueError(msg)</span>
<span class="gi">+        width = 0</span>
<span class="gi">+        for i in range(self[cell.row, cell.col].colspan):</span>
<span class="gi">+            width += source[cell.col + i]</span>
<span class="gi">+        return width + (cell.colspan - 1) * 3</span>

<span class="gd">-    def rewrap(self) -&gt;None:</span>
<span class="gi">+    @property</span>
<span class="gi">+    def cells(self) -&gt; Iterator[Cell]:</span>
<span class="gi">+        seen: set[Cell] = set()</span>
<span class="gi">+        for line in self.lines:</span>
<span class="gi">+            for cell in line:</span>
<span class="gi">+                if cell and cell not in seen:</span>
<span class="gi">+                    yield cell</span>
<span class="gi">+                    seen.add(cell)</span>
<span class="gi">+</span>
<span class="gi">+    def rewrap(self) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Call ``cell.wrap()`` on all cells, and measure each column width
<span class="w"> </span>        after wrapping (result written in ``self.measured_widths``).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.measured_widths = self.colwidth[:]</span>
<span class="gi">+        for cell in self.cells:</span>
<span class="gi">+            cell.wrap(width=self.cell_width(cell, self.colwidth))</span>
<span class="gi">+            if not cell.wrapped:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if cell.row is None or cell.col is None:</span>
<span class="gi">+                msg = &#39;Cell co-ordinates have not been set&#39;</span>
<span class="gi">+                raise ValueError(msg)</span>
<span class="gi">+            width = math.ceil(max(column_width(x) for x in cell.wrapped) / cell.colspan)</span>
<span class="gi">+            for col in range(cell.col, cell.col + cell.colspan):</span>
<span class="gi">+                self.measured_widths[col] = max(self.measured_widths[col], width)</span>

<span class="gd">-    def physical_lines_for_line(self, line: list[Cell]) -&gt;int:</span>
<span class="gi">+    def physical_lines_for_line(self, line: list[Cell]) -&gt; int:</span>
<span class="w"> </span>        &quot;&quot;&quot;For a given line, compute the number of physical lines it spans
<span class="w"> </span>        due to text wrapping.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        physical_lines = 1</span>
<span class="gi">+        for cell in line:</span>
<span class="gi">+            physical_lines = max(physical_lines, len(cell.wrapped))</span>
<span class="gi">+        return physical_lines</span>

<span class="gd">-    def __str__(self) -&gt;str:</span>
<span class="gi">+    def __str__(self) -&gt; str:</span>
<span class="w"> </span>        out = []
<span class="w"> </span>        self.rewrap()

<span class="gd">-        def writesep(char: str=&#39;-&#39;, lineno: (int | None)=None) -&gt;str:</span>
<span class="gi">+        def writesep(char: str = &quot;-&quot;, lineno: int | None = None) -&gt; str:</span>
<span class="w"> </span>            &quot;&quot;&quot;Called on the line *before* lineno.
<span class="w"> </span>            Called with no *lineno* for the last sep.
<span class="w"> </span>            &quot;&quot;&quot;
<span class="w"> </span>            out: list[str] = []
<span class="w"> </span>            for colno, width in enumerate(self.measured_widths):
<span class="gd">-                if lineno is not None and lineno &gt; 0 and self[lineno, colno</span>
<span class="gd">-                    ] is self[lineno - 1, colno]:</span>
<span class="gd">-                    out.append(&#39; &#39; * (width + 2))</span>
<span class="gi">+                if (</span>
<span class="gi">+                    lineno is not None and</span>
<span class="gi">+                    lineno &gt; 0 and</span>
<span class="gi">+                    self[lineno, colno] is self[lineno - 1, colno]</span>
<span class="gi">+                ):</span>
<span class="gi">+                    out.append(&quot; &quot; * (width + 2))</span>
<span class="w"> </span>                else:
<span class="w"> </span>                    out.append(char * (width + 2))
<span class="gd">-            head = &#39;+&#39; if out[0][0] == &#39;-&#39; else &#39;|&#39;</span>
<span class="gd">-            tail = &#39;+&#39; if out[-1][0] == &#39;-&#39; else &#39;|&#39;</span>
<span class="gd">-            glue = [(&#39;+&#39; if left[0] == &#39;-&#39; or right[0] == &#39;-&#39; else &#39;|&#39;) for</span>
<span class="gd">-                left, right in pairwise(out)]</span>
<span class="gi">+            head = &quot;+&quot; if out[0][0] == &quot;-&quot; else &quot;|&quot;</span>
<span class="gi">+            tail = &quot;+&quot; if out[-1][0] == &quot;-&quot; else &quot;|&quot;</span>
<span class="gi">+            glue = [</span>
<span class="gi">+                &quot;+&quot; if left[0] == &quot;-&quot; or right[0] == &quot;-&quot; else &quot;|&quot;</span>
<span class="gi">+                for left, right in pairwise(out)</span>
<span class="gi">+            ]</span>
<span class="w"> </span>            glue.append(tail)
<span class="gd">-            return head + &#39;&#39;.join(chain.from_iterable(zip(out, glue, strict</span>
<span class="gd">-                =False)))</span>
<span class="gi">+            return head + &quot;&quot;.join(chain.from_iterable(zip(out, glue, strict=False)))</span>
<span class="gi">+</span>
<span class="w"> </span>        for lineno, line in enumerate(self.lines):
<span class="w"> </span>            if self.separator and lineno == self.separator:
<span class="gd">-                out.append(writesep(&#39;=&#39;, lineno))</span>
<span class="gi">+                out.append(writesep(&quot;=&quot;, lineno))</span>
<span class="w"> </span>            else:
<span class="gd">-                out.append(writesep(&#39;-&#39;, lineno))</span>
<span class="gi">+                out.append(writesep(&quot;-&quot;, lineno))</span>
<span class="w"> </span>            for physical_line in range(self.physical_lines_for_line(line)):
<span class="gd">-                linestr = [&#39;|&#39;]</span>
<span class="gi">+                linestr = [&quot;|&quot;]</span>
<span class="w"> </span>                for colno, cell in enumerate(line):
<span class="w"> </span>                    if cell.col != colno:
<span class="w"> </span>                        continue
<span class="gd">-                    if lineno != cell.row:</span>
<span class="gd">-                        physical_text = &#39;&#39;</span>
<span class="gi">+                    if lineno != cell.row:  # NoQA: SIM114</span>
<span class="gi">+                        physical_text = &quot;&quot;</span>
<span class="w"> </span>                    elif physical_line &gt;= len(cell.wrapped):
<span class="gd">-                        physical_text = &#39;&#39;</span>
<span class="gi">+                        physical_text = &quot;&quot;</span>
<span class="w"> </span>                    else:
<span class="w"> </span>                        physical_text = cell.wrapped[physical_line]
<span class="gd">-                    adjust_len = len(physical_text) - column_width(</span>
<span class="gd">-                        physical_text)</span>
<span class="gd">-                    linestr.append(&#39; &#39; + physical_text.ljust(self.</span>
<span class="gd">-                        cell_width(cell, self.measured_widths) + 1 +</span>
<span class="gd">-                        adjust_len) + &#39;|&#39;)</span>
<span class="gd">-                out.append(&#39;&#39;.join(linestr))</span>
<span class="gd">-        out.append(writesep(&#39;-&#39;))</span>
<span class="gd">-        return &#39;\n&#39;.join(out)</span>
<span class="gi">+                    adjust_len = len(physical_text) - column_width(physical_text)</span>
<span class="gi">+                    linestr.append(</span>
<span class="gi">+                        &quot; &quot; +</span>
<span class="gi">+                        physical_text.ljust(</span>
<span class="gi">+                            self.cell_width(cell, self.measured_widths) + 1 + adjust_len,</span>
<span class="gi">+                        ) + &quot;|&quot;,</span>
<span class="gi">+                    )</span>
<span class="gi">+                out.append(&quot;&quot;.join(linestr))</span>
<span class="gi">+        out.append(writesep(&quot;-&quot;))</span>
<span class="gi">+        return &quot;\n&quot;.join(out)</span>


<span class="w"> </span>class TextWrapper(textwrap.TextWrapper):
<span class="w"> </span>    &quot;&quot;&quot;Custom subclass that uses a different word separator regex.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    wordsep_re = re.compile(
<span class="gd">-        &#39;(\\s+|(?&lt;=\\s)(?::[a-z-]+:)?`\\S+|[^\\s\\w]*\\w+[a-zA-Z]-(?=\\w+[a-zA-Z])|(?&lt;=[\\w\\!\\&quot;\\\&#39;\\&amp;\\.\\,\\?])-{2,}(?=\\w))&#39;</span>
<span class="gd">-        )</span>
<span class="gi">+        r&#39;(\s+|&#39;                                  # any whitespace</span>
<span class="gi">+        r&#39;(?&lt;=\s)(?::[a-z-]+:)?`\S+|&#39;             # interpreted text start</span>
<span class="gi">+        r&#39;[^\s\w]*\w+[a-zA-Z]-(?=\w+[a-zA-Z])|&#39;   # hyphenated words</span>
<span class="gi">+        r&#39;(?&lt;=[\w\!\&quot;\&#39;\&amp;\.\,\?])-{2,}(?=\w))&#39;)   # em-dash</span>

<span class="gd">-    def _wrap_chunks(self, chunks: list[str]) -&gt;list[str]:</span>
<span class="gi">+    def _wrap_chunks(self, chunks: list[str]) -&gt; list[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;The original _wrap_chunks uses len() to calculate width.

<span class="w"> </span>        This method respects wide/fullwidth characters for width adjustment.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        lines: list[str] = []</span>
<span class="gi">+        if self.width &lt;= 0:</span>
<span class="gi">+            raise ValueError(&quot;invalid width %r (must be &gt; 0)&quot; % self.width)</span>

<span class="gd">-    def _break_word(self, word: str, space_left: int) -&gt;tuple[str, str]:</span>
<span class="gi">+        chunks.reverse()</span>
<span class="gi">+</span>
<span class="gi">+        while chunks:</span>
<span class="gi">+            cur_line = []</span>
<span class="gi">+            cur_len = 0</span>
<span class="gi">+</span>
<span class="gi">+            if lines:</span>
<span class="gi">+                indent = self.subsequent_indent</span>
<span class="gi">+            else:</span>
<span class="gi">+                indent = self.initial_indent</span>
<span class="gi">+</span>
<span class="gi">+            width = self.width - column_width(indent)</span>
<span class="gi">+</span>
<span class="gi">+            if self.drop_whitespace and chunks[-1].strip() == &#39;&#39; and lines:</span>
<span class="gi">+                del chunks[-1]</span>
<span class="gi">+</span>
<span class="gi">+            while chunks:</span>
<span class="gi">+                l = column_width(chunks[-1])</span>
<span class="gi">+</span>
<span class="gi">+                if cur_len + l &lt;= width:</span>
<span class="gi">+                    cur_line.append(chunks.pop())</span>
<span class="gi">+                    cur_len += l</span>
<span class="gi">+</span>
<span class="gi">+                else:</span>
<span class="gi">+                    break</span>
<span class="gi">+</span>
<span class="gi">+            if chunks and column_width(chunks[-1]) &gt; width:</span>
<span class="gi">+                self._handle_long_word(chunks, cur_line, cur_len, width)</span>
<span class="gi">+</span>
<span class="gi">+            if self.drop_whitespace and cur_line and cur_line[-1].strip() == &#39;&#39;:</span>
<span class="gi">+                del cur_line[-1]</span>
<span class="gi">+</span>
<span class="gi">+            if cur_line:</span>
<span class="gi">+                lines.append(indent + &#39;&#39;.join(cur_line))</span>
<span class="gi">+</span>
<span class="gi">+        return lines</span>
<span class="gi">+</span>
<span class="gi">+    def _break_word(self, word: str, space_left: int) -&gt; tuple[str, str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Break line by unicode width instead of len(word).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        total = 0</span>
<span class="gi">+        for i, c in enumerate(word):</span>
<span class="gi">+            total += column_width(c)</span>
<span class="gi">+            if total &gt; space_left:</span>
<span class="gi">+                return word[:i - 1], word[i - 1:]</span>
<span class="gi">+        return word, &#39;&#39;</span>

<span class="gd">-    def _split(self, text: str) -&gt;list[str]:</span>
<span class="gi">+    def _split(self, text: str) -&gt; list[str]:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override original method that only split by &#39;wordsep_re&#39;.

<span class="w"> </span>        This &#39;_split&#39; splits wide-characters into chunks by one character.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        def split(t: str) -&gt; list[str]:</span>
<span class="gi">+            return super(TextWrapper, self)._split(t)</span>
<span class="gi">+        chunks: list[str] = []</span>
<span class="gi">+        for chunk in split(text):</span>
<span class="gi">+            for w, g in groupby(chunk, column_width):</span>
<span class="gi">+                if w == 1:</span>
<span class="gi">+                    chunks.extend(split(&#39;&#39;.join(g)))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    chunks.extend(list(g))</span>
<span class="gi">+        return chunks</span>

<span class="gd">-    def _handle_long_word(self, reversed_chunks: list[str], cur_line: list[</span>
<span class="gd">-        str], cur_len: int, width: int) -&gt;None:</span>
<span class="gi">+    def _handle_long_word(self, reversed_chunks: list[str], cur_line: list[str],</span>
<span class="gi">+                          cur_len: int, width: int) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Override original method for using self._break_word() instead of slice.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        space_left = max(width - cur_len, 1)</span>
<span class="gi">+        if self.break_long_words:</span>
<span class="gi">+            l, r = self._break_word(reversed_chunks[-1], space_left)</span>
<span class="gi">+            cur_line.append(l)</span>
<span class="gi">+            reversed_chunks[-1] = r</span>
<span class="gi">+</span>
<span class="gi">+        elif not cur_line:</span>
<span class="gi">+            cur_line.append(reversed_chunks.pop())</span>


<span class="w"> </span>MAXWIDTH = 70
<span class="w"> </span>STDINDENT = 3


<span class="gd">-class TextWriter(writers.Writer):</span>
<span class="gd">-    supported = &#39;text&#39;,</span>
<span class="gd">-    settings_spec = &#39;No options here.&#39;, &#39;&#39;, ()</span>
<span class="gi">+def my_wrap(text: str, width: int = MAXWIDTH, **kwargs: Any) -&gt; list[str]:</span>
<span class="gi">+    w = TextWrapper(width=width, **kwargs)</span>
<span class="gi">+    return w.wrap(text)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class TextWriter(writers.Writer):  # type: ignore[misc]</span>
<span class="gi">+    supported = (&#39;text&#39;,)</span>
<span class="gi">+    settings_spec = (&#39;No options here.&#39;, &#39;&#39;, ())</span>
<span class="w"> </span>    settings_defaults: dict[str, Any] = {}
<span class="gi">+</span>
<span class="w"> </span>    output: str

<span class="gd">-    def __init__(self, builder: TextBuilder) -&gt;None:</span>
<span class="gi">+    def __init__(self, builder: TextBuilder) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.builder = builder

<span class="gi">+    def translate(self) -&gt; None:</span>
<span class="gi">+        visitor = self.builder.create_translator(self.document, self.builder)</span>
<span class="gi">+        self.document.walkabout(visitor)</span>
<span class="gi">+        self.output = cast(TextTranslator, visitor).body</span>
<span class="gi">+</span>

<span class="w"> </span>class TextTranslator(SphinxTranslator):
<span class="w"> </span>    builder: TextBuilder

<span class="gd">-    def __init__(self, document: nodes.document, builder: TextBuilder) -&gt;None:</span>
<span class="gi">+    def __init__(self, document: nodes.document, builder: TextBuilder) -&gt; None:</span>
<span class="w"> </span>        super().__init__(document, builder)
<span class="gi">+</span>
<span class="w"> </span>        newlines = self.config.text_newlines
<span class="w"> </span>        if newlines == &#39;windows&#39;:
<span class="w"> </span>            self.nl = &#39;\r\n&#39;
<span class="gu">@@ -267,23 +395,657 @@ class TextTranslator(SphinxTranslator):</span>
<span class="w"> </span>        self.sectionlevel = 0
<span class="w"> </span>        self.lineblocklevel = 0
<span class="w"> </span>        self.table: Table
<span class="gi">+</span>
<span class="w"> </span>        self.context: list[str] = []
<span class="w"> </span>        &quot;&quot;&quot;Heterogeneous stack.

<span class="w"> </span>        Used by visit_* and depart_* functions in conjunction with the tree
<span class="w"> </span>        traversal. Make sure that the pops correspond to the pushes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    def add_text(self, text: str) -&gt; None:</span>
<span class="gi">+        self.states[-1].append((-1, text))</span>
<span class="gi">+</span>
<span class="gi">+    def new_state(self, indent: int = STDINDENT) -&gt; None:</span>
<span class="gi">+        self.states.append([])</span>
<span class="gi">+        self.stateindent.append(indent)</span>
<span class="gi">+</span>
<span class="gi">+    def end_state(</span>
<span class="gi">+        self, wrap: bool = True, end: Sequence[str] | None = (&#39;&#39;,), first: str | None = None,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="gi">+        content = self.states.pop()</span>
<span class="gi">+        maxindent = sum(self.stateindent)</span>
<span class="gi">+        indent = self.stateindent.pop()</span>
<span class="gi">+        result: list[tuple[int, list[str]]] = []</span>
<span class="gi">+        toformat: list[str] = []</span>
<span class="gi">+</span>
<span class="gi">+        def do_format() -&gt; None:</span>
<span class="gi">+            if not toformat:</span>
<span class="gi">+                return</span>
<span class="gi">+            if wrap:</span>
<span class="gi">+                res = my_wrap(&#39;&#39;.join(toformat), width=MAXWIDTH - maxindent)</span>
<span class="gi">+            else:</span>
<span class="gi">+                res = &#39;&#39;.join(toformat).splitlines()</span>
<span class="gi">+            if end:</span>
<span class="gi">+                res += end</span>
<span class="gi">+            result.append((indent, res))</span>
<span class="gi">+        for itemindent, item in content:</span>
<span class="gi">+            if itemindent == -1:</span>
<span class="gi">+                toformat.append(item)  # type: ignore[arg-type]</span>
<span class="gi">+            else:</span>
<span class="gi">+                do_format()</span>
<span class="gi">+                result.append((indent + itemindent, item))  # type: ignore[arg-type]</span>
<span class="gi">+                toformat = []</span>
<span class="gi">+        do_format()</span>
<span class="gi">+        if first is not None and result:</span>
<span class="gi">+            # insert prefix into first line (ex. *, [1], See also, etc.)</span>
<span class="gi">+            newindent = result[0][0] - indent</span>
<span class="gi">+            if result[0][1] == [&#39;&#39;]:</span>
<span class="gi">+                result.insert(0, (newindent, [first]))</span>
<span class="gi">+            else:</span>
<span class="gi">+                text = first + result[0][1].pop(0)</span>
<span class="gi">+                result.insert(0, (newindent, [text]))</span>
<span class="gi">+</span>
<span class="gi">+        self.states[-1].extend(result)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_document(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.new_state(0)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_document(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.end_state()</span>
<span class="gi">+        self.body = self.nl.join(line and (&#39; &#39; * indent + line)</span>
<span class="gi">+                                 for indent, lines in self.states[0]</span>
<span class="gi">+                                 for line in lines)</span>
<span class="gi">+        # XXX header/footer?</span>
<span class="gi">+</span>
<span class="gi">+    def visit_section(self, node: Element) -&gt; None:</span>
<span class="gi">+        self._title_char = self.sectionchars[self.sectionlevel]</span>
<span class="gi">+        self.sectionlevel += 1</span>
<span class="gi">+</span>
<span class="gi">+    def depart_section(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.sectionlevel -= 1</span>
<span class="gi">+</span>
<span class="gi">+    def visit_topic(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.new_state(0)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_topic(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.end_state()</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_sidebar = visit_topic
<span class="w"> </span>    depart_sidebar = depart_topic

<span class="gd">-    def _visit_sig_parameter_list(self, node: Element, parameter_group:</span>
<span class="gd">-        type[Element], sig_open_paren: str, sig_close_paren: str) -&gt;None:</span>
<span class="gi">+    def visit_rubric(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.new_state(0)</span>
<span class="gi">+        self.add_text(&#39;-[ &#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_rubric(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39; ]-&#39;)</span>
<span class="gi">+        self.end_state()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_compound(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_compound(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_glossary(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_glossary(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_title(self, node: Element) -&gt; None:</span>
<span class="gi">+        if isinstance(node.parent, nodes.Admonition):</span>
<span class="gi">+            self.add_text(node.astext() + &#39;: &#39;)</span>
<span class="gi">+            raise nodes.SkipNode</span>
<span class="gi">+        self.new_state(0)</span>
<span class="gi">+</span>
<span class="gi">+    def get_section_number_string(self, node: Element) -&gt; str:</span>
<span class="gi">+        if isinstance(node.parent, nodes.section):</span>
<span class="gi">+            anchorname = &#39;#&#39; + node.parent[&#39;ids&#39;][0]</span>
<span class="gi">+            numbers = self.builder.secnumbers.get(anchorname)</span>
<span class="gi">+            if numbers is None:</span>
<span class="gi">+                numbers = self.builder.secnumbers.get(&#39;&#39;)</span>
<span class="gi">+            if numbers is not None:</span>
<span class="gi">+                return &#39;.&#39;.join(map(str, numbers)) + self.secnumber_suffix</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def depart_title(self, node: Element) -&gt; None:</span>
<span class="gi">+        if isinstance(node.parent, nodes.section):</span>
<span class="gi">+            char = self._title_char</span>
<span class="gi">+        else:</span>
<span class="gi">+            char = &#39;^&#39;</span>
<span class="gi">+        text = &#39;&#39;</span>
<span class="gi">+        text = &#39;&#39;.join(x[1] for x in self.states.pop() if x[0] == -1)  # type: ignore[misc]</span>
<span class="gi">+        if self.add_secnumbers:</span>
<span class="gi">+            text = self.get_section_number_string(node) + text</span>
<span class="gi">+        self.stateindent.pop()</span>
<span class="gi">+        title = [&#39;&#39;, text, &#39;%s&#39; % (char * column_width(text)), &#39;&#39;]</span>
<span class="gi">+        if len(self.states) == 2 and len(self.states[-1]) == 0:</span>
<span class="gi">+            # remove an empty line before title if it is first section title in the document</span>
<span class="gi">+            title.pop(0)</span>
<span class="gi">+        self.states[-1].append((0, title))</span>
<span class="gi">+</span>
<span class="gi">+    def visit_subtitle(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_subtitle(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_attribution(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39;-- &#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_attribution(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    #############################################################</span>
<span class="gi">+    # Domain-specific object descriptions</span>
<span class="gi">+    #############################################################</span>
<span class="gi">+</span>
<span class="gi">+    # Top-level nodes</span>
<span class="gi">+    #################</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_signature(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.new_state(0)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_signature(self, node: Element) -&gt; None:</span>
<span class="gi">+        # XXX: wrap signatures in a way that makes sense</span>
<span class="gi">+        self.end_state(wrap=False, end=None)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_signature_line(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_signature_line(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_content(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.new_state()</span>
<span class="gi">+        self.add_text(self.nl)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_content(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.end_state()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_inline(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_inline(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    # Nodes for high-level structure in signatures</span>
<span class="gi">+    ##############################################</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_name(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_name(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_addname(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_addname(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_type(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_type(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_returns(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39; -&gt; &#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_returns(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def _visit_sig_parameter_list(</span>
<span class="gi">+        self,</span>
<span class="gi">+        node: Element,</span>
<span class="gi">+        parameter_group: type[Element],</span>
<span class="gi">+        sig_open_paren: str,</span>
<span class="gi">+        sig_close_paren: str,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        &quot;&quot;&quot;Visit a signature parameters or type parameters list.

<span class="w"> </span>        The *parameter_group* value is the type of a child node acting as a required parameter
<span class="w"> </span>        or as a set of contiguous optional parameters.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        self.add_text(sig_open_paren)</span>
<span class="gi">+        self.is_first_param = True</span>
<span class="gi">+        self.optional_param_level = 0</span>
<span class="gi">+        self.params_left_at_level = 0</span>
<span class="gi">+        self.param_group_index = 0</span>
<span class="gi">+        # Counts as what we call a parameter group are either a required parameter, or a</span>
<span class="gi">+        # set of contiguous optional ones.</span>
<span class="gi">+        self.list_is_required_param = [isinstance(c, parameter_group) for c in node.children]</span>
<span class="gi">+        self.required_params_left = sum(self.list_is_required_param)</span>
<span class="gi">+        self.param_separator = &#39;, &#39;</span>
<span class="gi">+        self.multi_line_parameter_list = node.get(&#39;multi_line_parameter_list&#39;, False)</span>
<span class="gi">+        if self.multi_line_parameter_list:</span>
<span class="gi">+            self.param_separator = self.param_separator.rstrip()</span>
<span class="gi">+        self.context.append(sig_close_paren)</span>
<span class="gi">+</span>
<span class="gi">+    def _depart_sig_parameter_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        sig_close_paren = self.context.pop()</span>
<span class="gi">+        self.add_text(sig_close_paren)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_parameterlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        self._visit_sig_parameter_list(node, addnodes.desc_parameter, &#39;(&#39;, &#39;)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_parameterlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        self._depart_sig_parameter_list(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_type_parameter_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self._visit_sig_parameter_list(node, addnodes.desc_type_parameter, &#39;[&#39;, &#39;]&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_type_parameter_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self._depart_sig_parameter_list(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_parameter(self, node: Element) -&gt; None:</span>
<span class="gi">+        on_separate_line = self.multi_line_parameter_list</span>
<span class="gi">+        if on_separate_line and not (self.is_first_param and self.optional_param_level &gt; 0):</span>
<span class="gi">+            self.new_state()</span>
<span class="gi">+        if self.is_first_param:</span>
<span class="gi">+            self.is_first_param = False</span>
<span class="gi">+        elif not on_separate_line and not self.required_params_left:</span>
<span class="gi">+            self.add_text(self.param_separator)</span>
<span class="gi">+        if self.optional_param_level == 0:</span>
<span class="gi">+            self.required_params_left -= 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.params_left_at_level -= 1</span>
<span class="gi">+</span>
<span class="gi">+        self.add_text(node.astext())</span>
<span class="gi">+</span>
<span class="gi">+        is_required = self.list_is_required_param[self.param_group_index]</span>
<span class="gi">+        if on_separate_line:</span>
<span class="gi">+            is_last_group = self.param_group_index + 1 == len(self.list_is_required_param)</span>
<span class="gi">+            next_is_required = (</span>
<span class="gi">+                not is_last_group</span>
<span class="gi">+                and self.list_is_required_param[self.param_group_index + 1]</span>
<span class="gi">+            )</span>
<span class="gi">+            opt_param_left_at_level = self.params_left_at_level &gt; 0</span>
<span class="gi">+            if opt_param_left_at_level or is_required and (is_last_group or next_is_required):</span>
<span class="gi">+                self.add_text(self.param_separator)</span>
<span class="gi">+                self.end_state(wrap=False, end=None)</span>
<span class="gi">+</span>
<span class="gi">+        elif self.required_params_left:</span>
<span class="gi">+            self.add_text(self.param_separator)</span>
<span class="gi">+</span>
<span class="gi">+        if is_required:</span>
<span class="gi">+            self.param_group_index += 1</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_type_parameter(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.visit_desc_parameter(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_optional(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.params_left_at_level = sum(isinstance(c, addnodes.desc_parameter)</span>
<span class="gi">+                                        for c in node.children)</span>
<span class="gi">+        self.optional_param_level += 1</span>
<span class="gi">+        self.max_optional_param_level = self.optional_param_level</span>
<span class="gi">+        if self.multi_line_parameter_list:</span>
<span class="gi">+            # If the first parameter is optional, start a new line and open the bracket.</span>
<span class="gi">+            if self.is_first_param:</span>
<span class="gi">+                self.new_state()</span>
<span class="gi">+                self.add_text(&#39;[&#39;)</span>
<span class="gi">+            # Else, if there remains at least one required parameter, append the</span>
<span class="gi">+            # parameter separator, open a new bracket, and end the line.</span>
<span class="gi">+            elif self.required_params_left:</span>
<span class="gi">+                self.add_text(self.param_separator)</span>
<span class="gi">+                self.add_text(&#39;[&#39;)</span>
<span class="gi">+                self.end_state(wrap=False, end=None)</span>
<span class="gi">+            # Else, open a new bracket, append the parameter separator, and end the</span>
<span class="gi">+            # line.</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.add_text(&#39;[&#39;)</span>
<span class="gi">+                self.add_text(self.param_separator)</span>
<span class="gi">+                self.end_state(wrap=False, end=None)</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.add_text(&#39;[&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_optional(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.optional_param_level -= 1</span>
<span class="gi">+        if self.multi_line_parameter_list:</span>
<span class="gi">+            # If it&#39;s the first time we go down one level, add the separator before the</span>
<span class="gi">+            # bracket.</span>
<span class="gi">+            if self.optional_param_level == self.max_optional_param_level - 1:</span>
<span class="gi">+                self.add_text(self.param_separator)</span>
<span class="gi">+            self.add_text(&#39;]&#39;)</span>
<span class="gi">+            # End the line if we have just closed the last bracket of this group of</span>
<span class="gi">+            # optional parameters.</span>
<span class="gi">+            if self.optional_param_level == 0:</span>
<span class="gi">+                self.end_state(wrap=False, end=None)</span>
<span class="gi">+</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.add_text(&#39;]&#39;)</span>
<span class="gi">+        if self.optional_param_level == 0:</span>
<span class="gi">+            self.param_group_index += 1</span>
<span class="gi">+</span>
<span class="gi">+    def visit_desc_annotation(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_desc_annotation(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    ##############################################</span>
<span class="gi">+</span>
<span class="gi">+    def visit_figure(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.new_state()</span>
<span class="gi">+</span>
<span class="gi">+    def depart_figure(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.end_state()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_caption(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_caption(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_productionlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.new_state()</span>
<span class="gi">+        productionlist = cast(Iterable[addnodes.production], node)</span>
<span class="gi">+        names = (production[&#39;tokenname&#39;] for production in productionlist)</span>
<span class="gi">+        maxlen = max(len(name) for name in names)</span>
<span class="gi">+        lastname = None</span>
<span class="gi">+        for production in productionlist:</span>
<span class="gi">+            if production[&#39;tokenname&#39;]:</span>
<span class="gi">+                self.add_text(production[&#39;tokenname&#39;].ljust(maxlen) + &#39; ::=&#39;)</span>
<span class="gi">+                lastname = production[&#39;tokenname&#39;]</span>
<span class="gi">+            elif lastname is not None:</span>
<span class="gi">+                self.add_text(&#39;%s    &#39; % (&#39; &#39; * len(lastname)))</span>
<span class="gi">+            self.add_text(production.astext() + self.nl)</span>
<span class="gi">+        self.end_state(wrap=False)</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_footnote(self, node: Element) -&gt; None:</span>
<span class="gi">+        label = cast(nodes.label, node[0])</span>
<span class="gi">+        self._footnote = label.astext().strip()</span>
<span class="gi">+        self.new_state(len(self._footnote) + 3)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_footnote(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.end_state(first=&#39;[%s] &#39; % self._footnote)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_citation(self, node: Element) -&gt; None:</span>
<span class="gi">+        if len(node) and isinstance(node[0], nodes.label):</span>
<span class="gi">+            self._citlabel = node[0].astext()</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._citlabel = &#39;&#39;</span>
<span class="gi">+        self.new_state(len(self._citlabel) + 3)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_citation(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.end_state(first=&#39;[%s] &#39; % self._citlabel)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_label(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_legend(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_legend(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    # XXX: option list could use some better styling</span>
<span class="gi">+</span>
<span class="gi">+    def visit_option_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_option_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_option_list_item(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.new_state(0)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_option_list_item(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.end_state()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_option_group(self, node: Element) -&gt; None:</span>
<span class="gi">+        self._firstoption = True</span>
<span class="gi">+</span>
<span class="gi">+    def depart_option_group(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39;     &#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_option(self, node: Element) -&gt; None:</span>
<span class="gi">+        if self._firstoption:</span>
<span class="gi">+            self._firstoption = False</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.add_text(&#39;, &#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_option(self, node: Element) -&gt; None:</span>
<span class="w"> </span>        pass
<span class="gi">+</span>
<span class="gi">+    def visit_option_string(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_option_string(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_option_argument(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(node[&#39;delimiter&#39;])</span>
<span class="gi">+</span>
<span class="gi">+    def depart_option_argument(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_description(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_description(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_tabular_col_spec(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_colspec(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.table.colwidth.append(node[&quot;colwidth&quot;])</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_tgroup(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_tgroup(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_thead(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_thead(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_tbody(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.table.set_separator()</span>
<span class="gi">+</span>
<span class="gi">+    def depart_tbody(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_row(self, node: Element) -&gt; None:</span>
<span class="gi">+        if self.table.lines:</span>
<span class="gi">+            self.table.add_row()</span>
<span class="gi">+</span>
<span class="gi">+    def depart_row(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_entry(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.entry = Cell(</span>
<span class="gi">+            rowspan=node.get(&quot;morerows&quot;, 0) + 1, colspan=node.get(&quot;morecols&quot;, 0) + 1,</span>
<span class="gi">+        )</span>
<span class="gi">+        self.new_state(0)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_entry(self, node: Element) -&gt; None:</span>
<span class="gi">+        text = self.nl.join(self.nl.join(x[1]) for x in self.states.pop())</span>
<span class="gi">+        self.stateindent.pop()</span>
<span class="gi">+        self.entry.text = text</span>
<span class="gi">+        self.table.add_cell(self.entry)</span>
<span class="gi">+        del self.entry</span>
<span class="gi">+</span>
<span class="gi">+    def visit_table(self, node: Element) -&gt; None:</span>
<span class="gi">+        if hasattr(self, &#39;table&#39;):</span>
<span class="gi">+            msg = &#39;Nested tables are not supported.&#39;</span>
<span class="gi">+            raise NotImplementedError(msg)</span>
<span class="gi">+        self.new_state(0)</span>
<span class="gi">+        self.table = Table()</span>
<span class="gi">+</span>
<span class="gi">+    def depart_table(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(str(self.table))</span>
<span class="gi">+        del self.table</span>
<span class="gi">+        self.end_state(wrap=False)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_acks(self, node: Element) -&gt; None:</span>
<span class="gi">+        bullet_list = cast(nodes.bullet_list, node[0])</span>
<span class="gi">+        list_items = cast(Iterable[nodes.list_item], bullet_list)</span>
<span class="gi">+        self.new_state(0)</span>
<span class="gi">+        self.add_text(&#39;, &#39;.join(n.astext() for n in list_items) + &#39;.&#39;)</span>
<span class="gi">+        self.end_state()</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_image(self, node: Element) -&gt; None:</span>
<span class="gi">+        if &#39;alt&#39; in node.attributes:</span>
<span class="gi">+            self.add_text(_(&#39;[image: %s]&#39;) % node[&#39;alt&#39;])</span>
<span class="gi">+        self.add_text(_(&#39;[image]&#39;))</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_transition(self, node: Element) -&gt; None:</span>
<span class="gi">+        indent = sum(self.stateindent)</span>
<span class="gi">+        self.new_state(0)</span>
<span class="gi">+        self.add_text(&#39;=&#39; * (MAXWIDTH - indent))</span>
<span class="gi">+        self.end_state()</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_bullet_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.list_counter.append(-1)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_bullet_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.list_counter.pop()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_enumerated_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.list_counter.append(node.get(&#39;start&#39;, 1) - 1)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_enumerated_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.list_counter.pop()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_definition_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.list_counter.append(-2)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_definition_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.list_counter.pop()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_list_item(self, node: Element) -&gt; None:</span>
<span class="gi">+        if self.list_counter[-1] == -1:</span>
<span class="gi">+            # bullet list</span>
<span class="gi">+            self.new_state(2)</span>
<span class="gi">+        elif self.list_counter[-1] == -2:</span>
<span class="gi">+            # definition list</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            # enumerated list</span>
<span class="gi">+            self.list_counter[-1] += 1</span>
<span class="gi">+            self.new_state(len(str(self.list_counter[-1])) + 2)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_list_item(self, node: Element) -&gt; None:</span>
<span class="gi">+        if self.list_counter[-1] == -1:</span>
<span class="gi">+            self.end_state(first=&#39;* &#39;)</span>
<span class="gi">+        elif self.list_counter[-1] == -2:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            self.end_state(first=&#39;%s. &#39; % self.list_counter[-1])</span>
<span class="gi">+</span>
<span class="gi">+    def visit_definition_list_item(self, node: Element) -&gt; None:</span>
<span class="gi">+        self._classifier_count_in_li = len(list(node.findall(nodes.classifier)))</span>
<span class="gi">+</span>
<span class="gi">+    def depart_definition_list_item(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_term(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.new_state(0)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_term(self, node: Element) -&gt; None:</span>
<span class="gi">+        if not self._classifier_count_in_li:</span>
<span class="gi">+            self.end_state(end=None)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_classifier(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39; : &#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_classifier(self, node: Element) -&gt; None:</span>
<span class="gi">+        self._classifier_count_in_li -= 1</span>
<span class="gi">+        if not self._classifier_count_in_li:</span>
<span class="gi">+            self.end_state(end=None)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_definition(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.new_state()</span>
<span class="gi">+</span>
<span class="gi">+    def depart_definition(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.end_state()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_field_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_field_list(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_field(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_field(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_field_name(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.new_state(0)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_field_name(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39;:&#39;)</span>
<span class="gi">+        self.end_state(end=None)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_field_body(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.new_state()</span>
<span class="gi">+</span>
<span class="gi">+    def depart_field_body(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.end_state()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_centered(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_centered(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_hlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_hlist(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_hlistcol(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_hlistcol(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_admonition(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.new_state(0)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_admonition(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.end_state()</span>
<span class="gi">+</span>
<span class="gi">+    def _visit_admonition(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.new_state(2)</span>
<span class="gi">+</span>
<span class="gi">+    def _depart_admonition(self, node: Element) -&gt; None:</span>
<span class="gi">+        label = admonitionlabels[node.tagname]</span>
<span class="gi">+        indent = sum(self.stateindent) + len(label)</span>
<span class="gi">+        if (len(self.states[-1]) == 1 and</span>
<span class="gi">+                self.states[-1][0][0] == 0 and</span>
<span class="gi">+                MAXWIDTH - indent &gt;= sum(len(s) for s in self.states[-1][0][1])):</span>
<span class="gi">+            # short text: append text after admonition label</span>
<span class="gi">+            self.stateindent[-1] += len(label)</span>
<span class="gi">+            self.end_state(first=label + &#39;: &#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # long text: append label before the block</span>
<span class="gi">+            self.states[-1].insert(0, (0, [self.nl]))</span>
<span class="gi">+            self.end_state(first=label + &#39;:&#39;)</span>
<span class="gi">+</span>
<span class="w"> </span>    visit_attention = _visit_admonition
<span class="w"> </span>    depart_attention = _depart_admonition
<span class="w"> </span>    visit_caution = _visit_admonition
<span class="gu">@@ -304,3 +1066,230 @@ class TextTranslator(SphinxTranslator):</span>
<span class="w"> </span>    depart_warning = _depart_admonition
<span class="w"> </span>    visit_seealso = _visit_admonition
<span class="w"> </span>    depart_seealso = _depart_admonition
<span class="gi">+</span>
<span class="gi">+    def visit_versionmodified(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.new_state(0)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_versionmodified(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.end_state()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_literal_block(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.new_state()</span>
<span class="gi">+</span>
<span class="gi">+    def depart_literal_block(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.end_state(wrap=False)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_doctest_block(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.new_state(0)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_doctest_block(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.end_state(wrap=False)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_line_block(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.new_state()</span>
<span class="gi">+        self.lineblocklevel += 1</span>
<span class="gi">+</span>
<span class="gi">+    def depart_line_block(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.lineblocklevel -= 1</span>
<span class="gi">+        self.end_state(wrap=False, end=None)</span>
<span class="gi">+        if not self.lineblocklevel:</span>
<span class="gi">+            self.add_text(&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_line(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_line(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39;\n&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_block_quote(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.new_state()</span>
<span class="gi">+</span>
<span class="gi">+    def depart_block_quote(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.end_state()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_compact_paragraph(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_compact_paragraph(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_paragraph(self, node: Element) -&gt; None:</span>
<span class="gi">+        if not isinstance(node.parent, nodes.Admonition) or \</span>
<span class="gi">+           isinstance(node.parent, addnodes.seealso):</span>
<span class="gi">+            self.new_state(0)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_paragraph(self, node: Element) -&gt; None:</span>
<span class="gi">+        if not isinstance(node.parent, nodes.Admonition) or \</span>
<span class="gi">+           isinstance(node.parent, addnodes.seealso):</span>
<span class="gi">+            self.end_state()</span>
<span class="gi">+</span>
<span class="gi">+    def visit_target(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_index(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_toctree(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_substitution_definition(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_pending_xref(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_pending_xref(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        if self.add_secnumbers:</span>
<span class="gi">+            numbers = node.get(&quot;secnumber&quot;)</span>
<span class="gi">+            if numbers is not None:</span>
<span class="gi">+                self.add_text(&#39;.&#39;.join(map(str, numbers)) + self.secnumber_suffix)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_number_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        text = nodes.Text(node.get(&#39;title&#39;, &#39;#&#39;))</span>
<span class="gi">+        self.visit_Text(text)</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_download_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_download_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_emphasis(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39;*&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_emphasis(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39;*&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_literal_emphasis(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39;*&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_literal_emphasis(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39;*&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_strong(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39;**&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_strong(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39;**&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_literal_strong(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39;**&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_literal_strong(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39;**&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_abbreviation(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_abbreviation(self, node: Element) -&gt; None:</span>
<span class="gi">+        if node.hasattr(&#39;explanation&#39;):</span>
<span class="gi">+            self.add_text(&#39; (%s)&#39; % node[&#39;explanation&#39;])</span>
<span class="gi">+</span>
<span class="gi">+    def visit_manpage(self, node: Element) -&gt; None:</span>
<span class="gi">+        return self.visit_literal_emphasis(node)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_manpage(self, node: Element) -&gt; None:</span>
<span class="gi">+        return self.depart_literal_emphasis(node)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_title_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39;*&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_title_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39;*&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_literal(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39;&quot;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_literal(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39;&quot;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_subscript(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39;_&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_subscript(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_superscript(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39;^&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_superscript(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_footnote_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39;[%s]&#39; % node.astext())</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_citation_reference(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39;[%s]&#39; % node.astext())</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_Text(self, node: Text) -&gt; None:</span>
<span class="gi">+        self.add_text(node.astext())</span>
<span class="gi">+</span>
<span class="gi">+    def depart_Text(self, node: Text) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_generated(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_generated(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_inline(self, node: Element) -&gt; None:</span>
<span class="gi">+        if &#39;xref&#39; in node[&#39;classes&#39;] or &#39;term&#39; in node[&#39;classes&#39;]:</span>
<span class="gi">+            self.add_text(&#39;*&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_inline(self, node: Element) -&gt; None:</span>
<span class="gi">+        if &#39;xref&#39; in node[&#39;classes&#39;] or &#39;term&#39; in node[&#39;classes&#39;]:</span>
<span class="gi">+            self.add_text(&#39;*&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_container(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_container(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_problematic(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39;&gt;&gt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def depart_problematic(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.add_text(&#39;&lt;&lt;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def visit_system_message(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.new_state(0)</span>
<span class="gi">+        self.add_text(&#39;&lt;SYSTEM MESSAGE: %s&gt;&#39; % node.astext())</span>
<span class="gi">+        self.end_state()</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_comment(self, node: Element) -&gt; None:</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_meta(self, node: Element) -&gt; None:</span>
<span class="gi">+        # only valid for HTML</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_raw(self, node: Element) -&gt; None:</span>
<span class="gi">+        if &#39;text&#39; in node.get(&#39;format&#39;, &#39;&#39;).split():</span>
<span class="gi">+            self.new_state(0)</span>
<span class="gi">+            self.add_text(node.astext())</span>
<span class="gi">+            self.end_state(wrap=False)</span>
<span class="gi">+        raise nodes.SkipNode</span>
<span class="gi">+</span>
<span class="gi">+    def visit_math(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def depart_math(self, node: Element) -&gt; None:</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def visit_math_block(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.new_state()</span>
<span class="gi">+</span>
<span class="gi">+    def depart_math_block(self, node: Element) -&gt; None:</span>
<span class="gi">+        self.end_state()</span>
<span class="gh">diff --git a/sphinx/writers/xml.py b/sphinx/writers/xml.py</span>
<span class="gh">index 47b7357a7..1ae8cc1ab 100644</span>
<span class="gd">--- a/sphinx/writers/xml.py</span>
<span class="gi">+++ b/sphinx/writers/xml.py</span>
<span class="gu">@@ -1,33 +1,52 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Docutils-native XML and pseudo-XML writers.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from __future__ import annotations
<span class="gi">+</span>
<span class="w"> </span>from typing import TYPE_CHECKING, Any
<span class="gi">+</span>
<span class="w"> </span>from docutils.writers.docutils_xml import Writer as BaseXMLWriter
<span class="gi">+</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from sphinx.builders import Builder


<span class="gd">-class XMLWriter(BaseXMLWriter):</span>
<span class="gi">+class XMLWriter(BaseXMLWriter):  # type: ignore[misc]</span>
<span class="w"> </span>    output: str

<span class="gd">-    def __init__(self, builder: Builder) -&gt;None:</span>
<span class="gi">+    def __init__(self, builder: Builder) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.builder = builder
<span class="gd">-        self.translator_class = (lambda document: self.builder.</span>
<span class="gd">-            create_translator(document))</span>

<span class="gi">+        # A lambda function to generate translator lazily</span>
<span class="gi">+        self.translator_class = lambda document: self.builder.create_translator(document)</span>
<span class="gi">+</span>
<span class="gi">+    def translate(self, *args: Any, **kwargs: Any) -&gt; None:</span>
<span class="gi">+        self.document.settings.newlines = \</span>
<span class="gi">+            self.document.settings.indents = \</span>
<span class="gi">+            self.builder.env.config.xml_pretty</span>
<span class="gi">+        self.document.settings.xml_declaration = True</span>
<span class="gi">+        self.document.settings.doctype_declaration = True</span>
<span class="gi">+        return super().translate()</span>

<span class="gd">-class PseudoXMLWriter(BaseXMLWriter):</span>
<span class="gd">-    supported = &#39;pprint&#39;, &#39;pformat&#39;, &#39;pseudoxml&#39;</span>
<span class="gi">+</span>
<span class="gi">+class PseudoXMLWriter(BaseXMLWriter):  # type: ignore[misc]</span>
<span class="gi">+</span>
<span class="gi">+    supported = (&#39;pprint&#39;, &#39;pformat&#39;, &#39;pseudoxml&#39;)</span>
<span class="w"> </span>    &quot;&quot;&quot;Formats this writer supports.&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>    config_section = &#39;pseudoxml writer&#39;
<span class="gd">-    config_section_dependencies = &#39;writers&#39;,</span>
<span class="gi">+    config_section_dependencies = (&#39;writers&#39;,)</span>
<span class="gi">+</span>
<span class="w"> </span>    output: str
<span class="w"> </span>    &quot;&quot;&quot;Final translated form of `document`.&quot;&quot;&quot;

<span class="gd">-    def __init__(self, builder: Builder) -&gt;None:</span>
<span class="gi">+    def __init__(self, builder: Builder) -&gt; None:</span>
<span class="w"> </span>        super().__init__()
<span class="w"> </span>        self.builder = builder

<span class="gd">-    def supports(self, format: str) -&gt;bool:</span>
<span class="gi">+    def translate(self) -&gt; None:</span>
<span class="gi">+        self.output = self.document.pformat()</span>
<span class="gi">+</span>
<span class="gi">+    def supports(self, format: str) -&gt; bool:</span>
<span class="w"> </span>        &quot;&quot;&quot;All format-specific elements are supported.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return True</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>