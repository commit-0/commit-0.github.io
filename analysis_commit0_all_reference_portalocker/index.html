
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference portalocker - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-portalocker" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference portalocker
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-portalocker_tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test portalocker_tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-portalocker"><strong>Reference (Gold)</strong>: portalocker</h1>
<h2 id="pytest-summary-for-test-portalocker_tests">Pytest Summary for test <code>portalocker_tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">40</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">40</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">40</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/portalocker/__about__.py b/portalocker/__about__.py</span>
<span class="gh">index fc965bf..a0b817a 100644</span>
<span class="gd">--- a/portalocker/__about__.py</span>
<span class="gi">+++ b/portalocker/__about__.py</span>
<span class="gu">@@ -2,5 +2,5 @@ __package_name__ = &#39;portalocker&#39;</span>
<span class="w"> </span>__author__ = &#39;Rick van Hattem&#39;
<span class="w"> </span>__email__ = &#39;wolph@wol.ph&#39;
<span class="w"> </span>__version__ = &#39;2.10.1&#39;
<span class="gd">-__description__ = &#39;Wraps the portalocker recipe for easy usage&#39;</span>
<span class="gi">+__description__ = &#39;&#39;&#39;Wraps the portalocker recipe for easy usage&#39;&#39;&#39;</span>
<span class="w"> </span>__url__ = &#39;https://github.com/WoLpH/portalocker&#39;
<span class="gh">diff --git a/portalocker/constants.py b/portalocker/constants.py</span>
<span class="gh">index 12b8ef6..2099f1f 100644</span>
<span class="gd">--- a/portalocker/constants.py</span>
<span class="gi">+++ b/portalocker/constants.py</span>
<span class="gu">@@ -1,4 +1,4 @@</span>
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gi">+&#39;&#39;&#39;</span>
<span class="w"> </span>Locking constants

<span class="w"> </span>Lock types:
<span class="gu">@@ -13,27 +13,47 @@ Lock flags:</span>
<span class="w"> </span>Manually unlock, only needed internally

<span class="w"> </span>- `UNBLOCK` unlock
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gi">+&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>import enum
<span class="w"> </span>import os
<span class="gd">-if os.name == &#39;nt&#39;:</span>
<span class="gi">+</span>
<span class="gi">+# The actual tests will execute the code anyhow so the following code can</span>
<span class="gi">+# safely be ignored from the coverage tests</span>
<span class="gi">+if os.name == &#39;nt&#39;:  # pragma: no cover</span>
<span class="w"> </span>    import msvcrt
<span class="gd">-    LOCK_EX = 1</span>
<span class="gd">-    LOCK_SH = 2</span>
<span class="gd">-    LOCK_NB = 4</span>
<span class="gd">-    LOCK_UN = msvcrt.LK_UNLCK</span>
<span class="gd">-elif os.name == &#39;posix&#39;:</span>
<span class="gi">+</span>
<span class="gi">+    #: exclusive lock</span>
<span class="gi">+    LOCK_EX = 0x1</span>
<span class="gi">+    #: shared lock</span>
<span class="gi">+    LOCK_SH = 0x2</span>
<span class="gi">+    #: non-blocking</span>
<span class="gi">+    LOCK_NB = 0x4</span>
<span class="gi">+    #: unlock</span>
<span class="gi">+    LOCK_UN = msvcrt.LK_UNLCK  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+elif os.name == &#39;posix&#39;:  # pragma: no cover</span>
<span class="w"> </span>    import fcntl
<span class="gi">+</span>
<span class="gi">+    #: exclusive lock</span>
<span class="w"> </span>    LOCK_EX = fcntl.LOCK_EX
<span class="gi">+    #: shared lock</span>
<span class="w"> </span>    LOCK_SH = fcntl.LOCK_SH
<span class="gi">+    #: non-blocking</span>
<span class="w"> </span>    LOCK_NB = fcntl.LOCK_NB
<span class="gi">+    #: unlock</span>
<span class="w"> </span>    LOCK_UN = fcntl.LOCK_UN
<span class="gd">-else:</span>
<span class="gi">+</span>
<span class="gi">+else:  # pragma: no cover</span>
<span class="w"> </span>    raise RuntimeError(&#39;PortaLocker only defined for nt and posix platforms&#39;)


<span class="w"> </span>class LockFlags(enum.IntFlag):
<span class="gi">+    #: exclusive lock</span>
<span class="w"> </span>    EXCLUSIVE = LOCK_EX
<span class="gi">+    #: shared lock</span>
<span class="w"> </span>    SHARED = LOCK_SH
<span class="gi">+    #: non-blocking</span>
<span class="w"> </span>    NON_BLOCKING = LOCK_NB
<span class="gi">+    #: unlock</span>
<span class="w"> </span>    UNBLOCK = LOCK_UN
<span class="gh">diff --git a/portalocker/exceptions.py b/portalocker/exceptions.py</span>
<span class="gh">index 9c73924..e871d13 100644</span>
<span class="gd">--- a/portalocker/exceptions.py</span>
<span class="gi">+++ b/portalocker/exceptions.py</span>
<span class="gu">@@ -1,11 +1,16 @@</span>
<span class="w"> </span>import typing


<span class="gd">-class BaseLockException(Exception):</span>
<span class="gi">+class BaseLockException(Exception):  # noqa: N818</span>
<span class="gi">+    # Error codes:</span>
<span class="w"> </span>    LOCK_FAILED = 1

<span class="gd">-    def __init__(self, *args: typing.Any, fh: typing.Union[typing.IO, None,</span>
<span class="gd">-        int]=None, **kwargs: typing.Any) -&gt;None:</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *args: typing.Any,</span>
<span class="gi">+        fh: typing.Union[typing.IO, None, int] = None,</span>
<span class="gi">+        **kwargs: typing.Any,</span>
<span class="gi">+    ) -&gt; None:</span>
<span class="w"> </span>        self.fh = fh
<span class="w"> </span>        Exception.__init__(self, *args)

<span class="gh">diff --git a/portalocker/portalocker.py b/portalocker/portalocker.py</span>
<span class="gh">index e718322..ceceeaa 100644</span>
<span class="gd">--- a/portalocker/portalocker.py</span>
<span class="gi">+++ b/portalocker/portalocker.py</span>
<span class="gu">@@ -1,25 +1,154 @@</span>
<span class="w"> </span>import os
<span class="w"> </span>import typing
<span class="gi">+</span>
<span class="w"> </span>from . import constants, exceptions
<span class="gi">+</span>
<span class="gi">+# Alias for readability. Due to import recursion issues we cannot do:</span>
<span class="gi">+# from .constants import LockFlags</span>
<span class="w"> </span>LockFlags = constants.LockFlags


<span class="w"> </span>class HasFileno(typing.Protocol):
<span class="gd">-    pass</span>
<span class="gi">+    def fileno(self) -&gt; int: ...</span>
<span class="gi">+</span>

<span class="gi">+LOCKER: typing.Optional[typing.Callable[</span>
<span class="gi">+    [typing.Union[int, HasFileno], int], typing.Any]] = None</span>

<span class="gd">-LOCKER: typing.Optional[typing.Callable[[typing.Union[int, HasFileno], int],</span>
<span class="gd">-    typing.Any]] = None</span>
<span class="gd">-if os.name == &#39;nt&#39;:</span>
<span class="gi">+</span>
<span class="gi">+if os.name == &#39;nt&#39;:  # pragma: no cover</span>
<span class="w"> </span>    import msvcrt
<span class="gi">+</span>
<span class="w"> </span>    import pywintypes
<span class="w"> </span>    import win32con
<span class="w"> </span>    import win32file
<span class="w"> </span>    import winerror
<span class="gi">+</span>
<span class="w"> </span>    __overlapped = pywintypes.OVERLAPPED()
<span class="gd">-elif os.name == &#39;posix&#39;:</span>
<span class="gi">+</span>
<span class="gi">+    def lock(file_: typing.Union[typing.IO, int], flags: LockFlags):</span>
<span class="gi">+        # Windows locking does not support locking through `fh.fileno()` so</span>
<span class="gi">+        # we cast it to make mypy and pyright happy</span>
<span class="gi">+        file_ = typing.cast(typing.IO, file_)</span>
<span class="gi">+</span>
<span class="gi">+        mode = 0</span>
<span class="gi">+        if flags &amp; LockFlags.NON_BLOCKING:</span>
<span class="gi">+            mode |= win32con.LOCKFILE_FAIL_IMMEDIATELY</span>
<span class="gi">+</span>
<span class="gi">+        if flags &amp; LockFlags.EXCLUSIVE:</span>
<span class="gi">+            mode |= win32con.LOCKFILE_EXCLUSIVE_LOCK</span>
<span class="gi">+</span>
<span class="gi">+        # Save the old position so we can go back to that position but</span>
<span class="gi">+        # still lock from the beginning of the file</span>
<span class="gi">+        savepos = file_.tell()</span>
<span class="gi">+        if savepos:</span>
<span class="gi">+            file_.seek(0)</span>
<span class="gi">+</span>
<span class="gi">+        os_fh = msvcrt.get_osfhandle(file_.fileno())  # type: ignore</span>
<span class="gi">+        try:</span>
<span class="gi">+            win32file.LockFileEx(os_fh, mode, 0, -0x10000, __overlapped)</span>
<span class="gi">+        except pywintypes.error as exc_value:</span>
<span class="gi">+            # error: (33, &#39;LockFileEx&#39;, &#39;The process cannot access the file</span>
<span class="gi">+            # because another process has locked a portion of the file.&#39;)</span>
<span class="gi">+            if exc_value.winerror == winerror.ERROR_LOCK_VIOLATION:</span>
<span class="gi">+                raise exceptions.AlreadyLocked(</span>
<span class="gi">+                    exceptions.LockException.LOCK_FAILED,</span>
<span class="gi">+                    exc_value.strerror,</span>
<span class="gi">+                    fh=file_,</span>
<span class="gi">+                ) from exc_value</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Q:  Are there exceptions/codes we should be dealing with</span>
<span class="gi">+                # here?</span>
<span class="gi">+                raise</span>
<span class="gi">+        finally:</span>
<span class="gi">+            if savepos:</span>
<span class="gi">+                file_.seek(savepos)</span>
<span class="gi">+</span>
<span class="gi">+    def unlock(file_: typing.IO):</span>
<span class="gi">+        try:</span>
<span class="gi">+            savepos = file_.tell()</span>
<span class="gi">+            if savepos:</span>
<span class="gi">+                file_.seek(0)</span>
<span class="gi">+</span>
<span class="gi">+            os_fh = msvcrt.get_osfhandle(file_.fileno())  # type: ignore</span>
<span class="gi">+            try:</span>
<span class="gi">+                win32file.UnlockFileEx(</span>
<span class="gi">+                    os_fh,</span>
<span class="gi">+                    0,</span>
<span class="gi">+                    -0x10000,</span>
<span class="gi">+                    __overlapped,</span>
<span class="gi">+                )</span>
<span class="gi">+            except pywintypes.error as exc:</span>
<span class="gi">+                if exc.winerror != winerror.ERROR_NOT_LOCKED:</span>
<span class="gi">+                    # Q:  Are there exceptions/codes we should be</span>
<span class="gi">+                    # dealing with here?</span>
<span class="gi">+                    raise</span>
<span class="gi">+            finally:</span>
<span class="gi">+                if savepos:</span>
<span class="gi">+                    file_.seek(savepos)</span>
<span class="gi">+        except OSError as exc:</span>
<span class="gi">+            raise exceptions.LockException(</span>
<span class="gi">+                exceptions.LockException.LOCK_FAILED,</span>
<span class="gi">+                exc.strerror,</span>
<span class="gi">+                fh=file_,</span>
<span class="gi">+            ) from exc</span>
<span class="gi">+</span>
<span class="gi">+elif os.name == &#39;posix&#39;:  # pragma: no cover</span>
<span class="w"> </span>    import errno
<span class="w"> </span>    import fcntl
<span class="gi">+</span>
<span class="gi">+    # The locking implementation.</span>
<span class="gi">+    # Expected values are either fcntl.flock() or fcntl.lockf(),</span>
<span class="gi">+    # but any callable that matches the syntax will be accepted.</span>
<span class="w"> </span>    LOCKER = fcntl.flock
<span class="gd">-else:</span>
<span class="gi">+</span>
<span class="gi">+    def lock(file_: typing.Union[typing.IO, int], flags: LockFlags):</span>
<span class="gi">+        assert LOCKER is not None, &#39;We need a locking function in `LOCKER` &#39;</span>
<span class="gi">+        # Locking with NON_BLOCKING without EXCLUSIVE or SHARED enabled</span>
<span class="gi">+        # results in an error</span>
<span class="gi">+        if (flags &amp; LockFlags.NON_BLOCKING) and not flags &amp; (</span>
<span class="gi">+            LockFlags.SHARED | LockFlags.EXCLUSIVE</span>
<span class="gi">+        ):</span>
<span class="gi">+            raise RuntimeError(</span>
<span class="gi">+                &#39;When locking in non-blocking mode the SHARED &#39;</span>
<span class="gi">+                &#39;or EXCLUSIVE flag must be specified as well&#39;,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            LOCKER(file_, flags)</span>
<span class="gi">+        except OSError as exc_value:</span>
<span class="gi">+            # Python can use one of several different exception classes to</span>
<span class="gi">+            # represent timeout (most likely is BlockingIOError and IOError),</span>
<span class="gi">+            # but these errors may also represent other failures. On some</span>
<span class="gi">+            # systems, `IOError is OSError` which means checking for either</span>
<span class="gi">+            # IOError or OSError can mask other errors.</span>
<span class="gi">+            # The safest check is to catch OSError (from which the others</span>
<span class="gi">+            # inherit) and check the errno (which should be EACCESS or EAGAIN</span>
<span class="gi">+            # according to the spec).</span>
<span class="gi">+            if exc_value.errno in (errno.EACCES, errno.EAGAIN):</span>
<span class="gi">+                # A timeout exception, wrap this so the outer code knows to try</span>
<span class="gi">+                # again (if it wants to).</span>
<span class="gi">+                raise exceptions.AlreadyLocked(</span>
<span class="gi">+                    exc_value,</span>
<span class="gi">+                    fh=file_,</span>
<span class="gi">+                ) from exc_value</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Something else went wrong; don&#39;t wrap this so we stop</span>
<span class="gi">+                # immediately.</span>
<span class="gi">+                raise exceptions.LockException(</span>
<span class="gi">+                    exc_value,</span>
<span class="gi">+                    fh=file_,</span>
<span class="gi">+                ) from exc_value</span>
<span class="gi">+        except EOFError as exc_value:</span>
<span class="gi">+            # On NFS filesystems, flock can raise an EOFError</span>
<span class="gi">+            raise exceptions.LockException(</span>
<span class="gi">+                exc_value,</span>
<span class="gi">+                fh=file_,</span>
<span class="gi">+            ) from exc_value</span>
<span class="gi">+</span>
<span class="gi">+    def unlock(file_: typing.IO):</span>
<span class="gi">+        assert LOCKER is not None, &#39;We need a locking function in `LOCKER` &#39;</span>
<span class="gi">+        LOCKER(file_.fileno(), LockFlags.UNBLOCK)</span>
<span class="gi">+</span>
<span class="gi">+else:  # pragma: no cover</span>
<span class="w"> </span>    raise RuntimeError(&#39;PortaLocker only defined for nt and posix platforms&#39;)
<span class="gh">diff --git a/portalocker/redis.py b/portalocker/redis.py</span>
<span class="gh">index f02a9d9..11ee876 100644</span>
<span class="gd">--- a/portalocker/redis.py</span>
<span class="gi">+++ b/portalocker/redis.py</span>
<span class="gu">@@ -4,19 +4,28 @@ import logging</span>
<span class="w"> </span>import random
<span class="w"> </span>import time
<span class="w"> </span>import typing
<span class="gi">+</span>
<span class="w"> </span>from redis import client
<span class="gi">+</span>
<span class="w"> </span>from . import exceptions, utils
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gi">+</span>
<span class="w"> </span>DEFAULT_UNAVAILABLE_TIMEOUT = 1
<span class="w"> </span>DEFAULT_THREAD_SLEEP_TIME = 0.1


<span class="gd">-class PubSubWorkerThread(client.PubSubWorkerThread):</span>
<span class="gd">-    pass</span>
<span class="gi">+class PubSubWorkerThread(client.PubSubWorkerThread):  # type: ignore</span>
<span class="gi">+    def run(self):</span>
<span class="gi">+        try:</span>
<span class="gi">+            super().run()</span>
<span class="gi">+        except Exception:  # pragma: no cover</span>
<span class="gi">+            _thread.interrupt_main()</span>
<span class="gi">+            raise</span>


<span class="w"> </span>class RedisLock(utils.LockBase):
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="w"> </span>    An extremely reliable Redis lock based on pubsub with a keep-alive thread

<span class="w"> </span>    As opposed to most Redis locking systems based on key/value pairs,
<span class="gu">@@ -50,7 +59,8 @@ class RedisLock(utils.LockBase):</span>
<span class="w"> </span>            to override these you need to explicitly specify a value (e.g.
<span class="w"> </span>            `health_check_interval=0`)

<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>    redis_kwargs: typing.Dict[str, typing.Any]
<span class="w"> </span>    thread: typing.Optional[PubSubWorkerThread]
<span class="w"> </span>    channel: str
<span class="gu">@@ -58,26 +68,169 @@ class RedisLock(utils.LockBase):</span>
<span class="w"> </span>    connection: typing.Optional[client.Redis]
<span class="w"> </span>    pubsub: typing.Optional[client.PubSub] = None
<span class="w"> </span>    close_connection: bool
<span class="gi">+</span>
<span class="w"> </span>    DEFAULT_REDIS_KWARGS: typing.ClassVar[typing.Dict[str, typing.Any]] = dict(
<span class="gd">-        health_check_interval=10)</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, channel: str, connection: typing.Optional[client.</span>
<span class="gd">-        Redis]=None, timeout: typing.Optional[float]=None, check_interval:</span>
<span class="gd">-        typing.Optional[float]=None, fail_when_locked: typing.Optional[bool</span>
<span class="gd">-        ]=False, thread_sleep_time: float=DEFAULT_THREAD_SLEEP_TIME,</span>
<span class="gd">-        unavailable_timeout: float=DEFAULT_UNAVAILABLE_TIMEOUT,</span>
<span class="gd">-        redis_kwargs: typing.Optional[typing.Dict]=None):</span>
<span class="gi">+        health_check_interval=10,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        channel: str,</span>
<span class="gi">+        connection: typing.Optional[client.Redis] = None,</span>
<span class="gi">+        timeout: typing.Optional[float] = None,</span>
<span class="gi">+        check_interval: typing.Optional[float] = None,</span>
<span class="gi">+        fail_when_locked: typing.Optional[bool] = False,</span>
<span class="gi">+        thread_sleep_time: float = DEFAULT_THREAD_SLEEP_TIME,</span>
<span class="gi">+        unavailable_timeout: float = DEFAULT_UNAVAILABLE_TIMEOUT,</span>
<span class="gi">+        redis_kwargs: typing.Optional[typing.Dict] = None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        # We don&#39;t want to close connections given as an argument</span>
<span class="w"> </span>        self.close_connection = not connection
<span class="gi">+</span>
<span class="w"> </span>        self.thread = None
<span class="w"> </span>        self.channel = channel
<span class="w"> </span>        self.connection = connection
<span class="w"> </span>        self.thread_sleep_time = thread_sleep_time
<span class="w"> </span>        self.unavailable_timeout = unavailable_timeout
<span class="w"> </span>        self.redis_kwargs = redis_kwargs or dict()
<span class="gi">+</span>
<span class="w"> </span>        for key, value in self.DEFAULT_REDIS_KWARGS.items():
<span class="w"> </span>            self.redis_kwargs.setdefault(key, value)
<span class="gd">-        super().__init__(timeout=timeout, check_interval=check_interval,</span>
<span class="gd">-            fail_when_locked=fail_when_locked)</span>
<span class="gi">+</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            timeout=timeout,</span>
<span class="gi">+            check_interval=check_interval,</span>
<span class="gi">+            fail_when_locked=fail_when_locked,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def get_connection(self) -&gt; client.Redis:</span>
<span class="gi">+        if not self.connection:</span>
<span class="gi">+            self.connection = client.Redis(**self.redis_kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        return self.connection</span>
<span class="gi">+</span>
<span class="gi">+    def channel_handler(self, message):</span>
<span class="gi">+        if message.get(&#39;type&#39;) != &#39;message&#39;:  # pragma: no cover</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            data = json.loads(message.get(&#39;data&#39;))</span>
<span class="gi">+        except TypeError:  # pragma: no cover</span>
<span class="gi">+            logger.debug(&#39;TypeError while parsing: %r&#39;, message)</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        assert self.connection is not None</span>
<span class="gi">+        self.connection.publish(data[&#39;response_channel&#39;], str(time.time()))</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def client_name(self):</span>
<span class="gi">+        return f&#39;{self.channel}-lock&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def acquire(  # type: ignore[override]</span>
<span class="gi">+        self,</span>
<span class="gi">+        timeout: typing.Optional[float] = None,</span>
<span class="gi">+        check_interval: typing.Optional[float] = None,</span>
<span class="gi">+        fail_when_locked: typing.Optional[bool] = None,</span>
<span class="gi">+    ) -&gt; &#39;RedisLock&#39;:</span>
<span class="gi">+        timeout = utils.coalesce(timeout, self.timeout, 0.0)</span>
<span class="gi">+        check_interval = utils.coalesce(</span>
<span class="gi">+            check_interval,</span>
<span class="gi">+            self.check_interval,</span>
<span class="gi">+            0.0,</span>
<span class="gi">+        )</span>
<span class="gi">+        fail_when_locked = utils.coalesce(</span>
<span class="gi">+            fail_when_locked,</span>
<span class="gi">+            self.fail_when_locked,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        assert not self.pubsub, &#39;This lock is already active&#39;</span>
<span class="gi">+        connection = self.get_connection()</span>
<span class="gi">+</span>
<span class="gi">+        timeout_generator = self._timeout_generator(timeout, check_interval)</span>
<span class="gi">+        for _ in timeout_generator:  # pragma: no branch</span>
<span class="gi">+            subscribers = connection.pubsub_numsub(self.channel)[0][1]</span>
<span class="gi">+</span>
<span class="gi">+            if subscribers:</span>
<span class="gi">+                logger.debug(</span>
<span class="gi">+                    &#39;Found %d lock subscribers for %s&#39;,</span>
<span class="gi">+                    subscribers,</span>
<span class="gi">+                    self.channel,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                if self.check_or_kill_lock(</span>
<span class="gi">+                    connection,</span>
<span class="gi">+                    self.unavailable_timeout,</span>
<span class="gi">+                ):  # pragma: no branch</span>
<span class="gi">+                    continue</span>
<span class="gi">+                else:  # pragma: no cover</span>
<span class="gi">+                    subscribers = 0</span>
<span class="gi">+</span>
<span class="gi">+            # Note: this should not be changed to an elif because the if</span>
<span class="gi">+            # above can still end up here</span>
<span class="gi">+            if not subscribers:</span>
<span class="gi">+                connection.client_setname(self.client_name)</span>
<span class="gi">+                self.pubsub = connection.pubsub()</span>
<span class="gi">+                self.pubsub.subscribe(**{self.channel: self.channel_handler})</span>
<span class="gi">+                self.thread = PubSubWorkerThread(</span>
<span class="gi">+                    self.pubsub,</span>
<span class="gi">+                    sleep_time=self.thread_sleep_time,</span>
<span class="gi">+                )</span>
<span class="gi">+                self.thread.start()</span>
<span class="gi">+</span>
<span class="gi">+                subscribers = connection.pubsub_numsub(self.channel)[0][1]</span>
<span class="gi">+                if subscribers == 1:  # pragma: no branch</span>
<span class="gi">+                    return self</span>
<span class="gi">+                else:  # pragma: no cover</span>
<span class="gi">+                    # Race condition, let&#39;s try again</span>
<span class="gi">+                    self.release()</span>
<span class="gi">+</span>
<span class="gi">+            if fail_when_locked:  # pragma: no cover</span>
<span class="gi">+                raise exceptions.AlreadyLocked(exceptions)</span>
<span class="gi">+</span>
<span class="gi">+        raise exceptions.AlreadyLocked(exceptions)</span>
<span class="gi">+</span>
<span class="gi">+    def check_or_kill_lock(self, connection, timeout):</span>
<span class="gi">+        # Random channel name to get messages back from the lock</span>
<span class="gi">+        response_channel = f&#39;{self.channel}-{random.random()}&#39;</span>
<span class="gi">+</span>
<span class="gi">+        pubsub = connection.pubsub()</span>
<span class="gi">+        pubsub.subscribe(response_channel)</span>
<span class="gi">+        connection.publish(</span>
<span class="gi">+            self.channel,</span>
<span class="gi">+            json.dumps(</span>
<span class="gi">+                dict(</span>
<span class="gi">+                    response_channel=response_channel,</span>
<span class="gi">+                    message=&#39;ping&#39;,</span>
<span class="gi">+                ),</span>
<span class="gi">+            ),</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        check_interval = min(self.thread_sleep_time, timeout / 10)</span>
<span class="gi">+        for _ in self._timeout_generator(</span>
<span class="gi">+            timeout,</span>
<span class="gi">+            check_interval,</span>
<span class="gi">+        ):  # pragma: no branch</span>
<span class="gi">+            if pubsub.get_message(timeout=check_interval):</span>
<span class="gi">+                pubsub.close()</span>
<span class="gi">+                return True</span>
<span class="gi">+</span>
<span class="gi">+        for client_ in connection.client_list(&#39;pubsub&#39;):  # pragma: no cover</span>
<span class="gi">+            if client_.get(&#39;name&#39;) == self.client_name:</span>
<span class="gi">+                logger.warning(&#39;Killing unavailable redis client: %r&#39;, client_)</span>
<span class="gi">+                connection.client_kill_filter(client_.get(&#39;id&#39;))</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def release(self):</span>
<span class="gi">+        if self.thread:  # pragma: no branch</span>
<span class="gi">+            self.thread.stop()</span>
<span class="gi">+            self.thread.join()</span>
<span class="gi">+            self.thread = None</span>
<span class="gi">+            time.sleep(0.01)</span>
<span class="gi">+</span>
<span class="gi">+        if self.pubsub:  # pragma: no branch</span>
<span class="gi">+            self.pubsub.unsubscribe(self.channel)</span>
<span class="gi">+            self.pubsub.close()</span>
<span class="gi">+            self.pubsub = None</span>

<span class="w"> </span>    def __del__(self):
<span class="w"> </span>        self.release()
<span class="gh">diff --git a/portalocker/utils.py b/portalocker/utils.py</span>
<span class="gh">index a482b38..5115b0e 100644</span>
<span class="gd">--- a/portalocker/utils.py</span>
<span class="gi">+++ b/portalocker/utils.py</span>
<span class="gu">@@ -9,18 +9,26 @@ import tempfile</span>
<span class="w"> </span>import time
<span class="w"> </span>import typing
<span class="w"> </span>import warnings
<span class="gi">+</span>
<span class="w"> </span>from . import constants, exceptions, portalocker
<span class="gi">+</span>
<span class="w"> </span>logger = logging.getLogger(__name__)
<span class="gi">+</span>
<span class="w"> </span>DEFAULT_TIMEOUT = 5
<span class="w"> </span>DEFAULT_CHECK_INTERVAL = 0.25
<span class="w"> </span>DEFAULT_FAIL_WHEN_LOCKED = False
<span class="w"> </span>LOCK_METHOD = constants.LockFlags.EXCLUSIVE | constants.LockFlags.NON_BLOCKING
<span class="gd">-__all__ = [&#39;Lock&#39;, &#39;open_atomic&#39;]</span>
<span class="gi">+</span>
<span class="gi">+__all__ = [</span>
<span class="gi">+    &#39;Lock&#39;,</span>
<span class="gi">+    &#39;open_atomic&#39;,</span>
<span class="gi">+]</span>
<span class="gi">+</span>
<span class="w"> </span>Filename = typing.Union[str, pathlib.Path]


<span class="gd">-def coalesce(*args: typing.Any, test_value: typing.Any=None) -&gt;typing.Any:</span>
<span class="gd">-    &quot;&quot;&quot;Simple coalescing function that returns the first value that is not</span>
<span class="gi">+def coalesce(*args: typing.Any, test_value: typing.Any = None) -&gt; typing.Any:</span>
<span class="gi">+    &#39;&#39;&#39;Simple coalescing function that returns the first value that is not</span>
<span class="w"> </span>    equal to the `test_value`. Or `None` if no value is valid. Usually this
<span class="w"> </span>    means that the last given value is the default value.

<span class="gu">@@ -40,14 +48,16 @@ def coalesce(*args: typing.Any, test_value: typing.Any=None) -&gt;typing.Any:</span>
<span class="w"> </span>    # This won&#39;t work because of the `is not test_value` type testing:
<span class="w"> </span>    &gt;&gt;&gt; coalesce([], dict(spam=&#39;eggs&#39;), test_value=[])
<span class="w"> </span>    []
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+    return next((arg for arg in args if arg is not test_value), None)</span>


<span class="w"> </span>@contextlib.contextmanager
<span class="gd">-def open_atomic(filename: Filename, binary: bool=True) -&gt;typing.Iterator[typing</span>
<span class="gd">-    .IO]:</span>
<span class="gd">-    &quot;&quot;&quot;Open a file for atomic writing. Instead of locking this method allows</span>
<span class="gi">+def open_atomic(</span>
<span class="gi">+    filename: Filename,</span>
<span class="gi">+    binary: bool = True,</span>
<span class="gi">+) -&gt; typing.Iterator[typing.IO]:</span>
<span class="gi">+    &#39;&#39;&#39;Open a file for atomic writing. Instead of locking this method allows</span>
<span class="w"> </span>    you to write the entire file and move it to the actual location. Note that
<span class="w"> </span>    this makes the assumption that a rename is atomic on your platform which
<span class="w"> </span>    is generally the case but not a guarantee.
<span class="gu">@@ -70,29 +80,92 @@ def open_atomic(filename: Filename, binary: bool=True) -&gt;typing.Iterator[typing</span>
<span class="w"> </span>    ...     written = fh.write(b&#39;test&#39;)
<span class="w"> </span>    &gt;&gt;&gt; assert path_filename.exists()
<span class="w"> </span>    &gt;&gt;&gt; path_filename.unlink()
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-class LockBase(abc.ABC):</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+    # `pathlib.Path` cast in case `path` is a `str`</span>
<span class="gi">+    path: pathlib.Path = pathlib.Path(filename)</span>
<span class="gi">+</span>
<span class="gi">+    assert not path.exists(), f&#39;{path!r} exists&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # Create the parent directory if it doesn&#39;t exist</span>
<span class="gi">+    path.parent.mkdir(parents=True, exist_ok=True)</span>
<span class="gi">+</span>
<span class="gi">+    temp_fh = tempfile.NamedTemporaryFile(</span>
<span class="gi">+        mode=binary and &#39;wb&#39; or &#39;w&#39;,</span>
<span class="gi">+        dir=str(path.parent),</span>
<span class="gi">+        delete=False,</span>
<span class="gi">+    )</span>
<span class="gi">+    yield temp_fh</span>
<span class="gi">+    temp_fh.flush()</span>
<span class="gi">+    os.fsync(temp_fh.fileno())</span>
<span class="gi">+    temp_fh.close()</span>
<span class="gi">+    try:</span>
<span class="gi">+        os.rename(temp_fh.name, path)</span>
<span class="gi">+    finally:</span>
<span class="gi">+        with contextlib.suppress(Exception):</span>
<span class="gi">+            os.remove(temp_fh.name)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class LockBase(abc.ABC):  # pragma: no cover</span>
<span class="gi">+    #: timeout when trying to acquire a lock</span>
<span class="w"> </span>    timeout: float
<span class="gi">+    #: check interval while waiting for `timeout`</span>
<span class="w"> </span>    check_interval: float
<span class="gi">+    #: skip the timeout and immediately fail if the initial lock fails</span>
<span class="w"> </span>    fail_when_locked: bool

<span class="gd">-    def __init__(self, timeout: typing.Optional[float]=None, check_interval:</span>
<span class="gd">-        typing.Optional[float]=None, fail_when_locked: typing.Optional[bool</span>
<span class="gd">-        ]=None):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        timeout: typing.Optional[float] = None,</span>
<span class="gi">+        check_interval: typing.Optional[float] = None,</span>
<span class="gi">+        fail_when_locked: typing.Optional[bool] = None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.timeout = coalesce(timeout, DEFAULT_TIMEOUT)
<span class="w"> </span>        self.check_interval = coalesce(check_interval, DEFAULT_CHECK_INTERVAL)
<span class="gd">-        self.fail_when_locked = coalesce(fail_when_locked,</span>
<span class="gd">-            DEFAULT_FAIL_WHEN_LOCKED)</span>
<span class="gd">-</span>
<span class="gd">-    def __enter__(self) -&gt;typing.IO[typing.AnyStr]:</span>
<span class="gi">+        self.fail_when_locked = coalesce(</span>
<span class="gi">+            fail_when_locked,</span>
<span class="gi">+            DEFAULT_FAIL_WHEN_LOCKED,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    @abc.abstractmethod</span>
<span class="gi">+    def acquire(</span>
<span class="gi">+        self,</span>
<span class="gi">+        timeout: typing.Optional[float] = None,</span>
<span class="gi">+        check_interval: typing.Optional[float] = None,</span>
<span class="gi">+        fail_when_locked: typing.Optional[bool] = None,</span>
<span class="gi">+    ) -&gt; typing.IO[typing.AnyStr]: ...</span>
<span class="gi">+</span>
<span class="gi">+    def _timeout_generator(</span>
<span class="gi">+        self,</span>
<span class="gi">+        timeout: typing.Optional[float],</span>
<span class="gi">+        check_interval: typing.Optional[float],</span>
<span class="gi">+    ) -&gt; typing.Iterator[int]:</span>
<span class="gi">+        f_timeout = coalesce(timeout, self.timeout, 0.0)</span>
<span class="gi">+        f_check_interval = coalesce(check_interval, self.check_interval, 0.0)</span>
<span class="gi">+</span>
<span class="gi">+        yield 0</span>
<span class="gi">+        i = 0</span>
<span class="gi">+</span>
<span class="gi">+        start_time = time.perf_counter()</span>
<span class="gi">+        while start_time + f_timeout &gt; time.perf_counter():</span>
<span class="gi">+            i += 1</span>
<span class="gi">+            yield i</span>
<span class="gi">+</span>
<span class="gi">+            # Take low lock checks into account to stay within the interval</span>
<span class="gi">+            since_start_time = time.perf_counter() - start_time</span>
<span class="gi">+            time.sleep(max(0.001, (i * f_check_interval) - since_start_time))</span>
<span class="gi">+</span>
<span class="gi">+    @abc.abstractmethod</span>
<span class="gi">+    def release(self): ...</span>
<span class="gi">+</span>
<span class="gi">+    def __enter__(self) -&gt; typing.IO[typing.AnyStr]:</span>
<span class="w"> </span>        return self.acquire()

<span class="gd">-    def __exit__(self, exc_type: typing.Optional[typing.Type[BaseException]</span>
<span class="gd">-        ], exc_value: typing.Optional[BaseException], traceback: typing.Any</span>
<span class="gd">-        ) -&gt;typing.Optional[bool]:</span>
<span class="gi">+    def __exit__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        exc_type: typing.Optional[typing.Type[BaseException]],</span>
<span class="gi">+        exc_value: typing.Optional[BaseException],</span>
<span class="gi">+        traceback: typing.Any,  # Should be typing.TracebackType</span>
<span class="gi">+    ) -&gt; typing.Optional[bool]:</span>
<span class="w"> </span>        self.release()
<span class="w"> </span>        return None

<span class="gu">@@ -101,7 +174,7 @@ class LockBase(abc.ABC):</span>


<span class="w"> </span>class Lock(LockBase):
<span class="gd">-    &quot;&quot;&quot;Lock manager with built-in timeout</span>
<span class="gi">+    &#39;&#39;&#39;Lock manager with built-in timeout</span>

<span class="w"> </span>    Args:
<span class="w"> </span>        filename: filename
<span class="gu">@@ -119,22 +192,32 @@ class Lock(LockBase):</span>

<span class="w"> </span>    Note that the file is opened first and locked later. So using &#39;w&#39; as
<span class="w"> </span>    mode will result in truncate _BEFORE_ the lock is checked.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, filename: Filename, mode: str=&#39;a&#39;, timeout: typing.</span>
<span class="gd">-        Optional[float]=None, check_interval: float=DEFAULT_CHECK_INTERVAL,</span>
<span class="gd">-        fail_when_locked: bool=DEFAULT_FAIL_WHEN_LOCKED, flags: constants.</span>
<span class="gd">-        LockFlags=LOCK_METHOD, **file_open_kwargs):</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        filename: Filename,</span>
<span class="gi">+        mode: str = &#39;a&#39;,</span>
<span class="gi">+        timeout: typing.Optional[float] = None,</span>
<span class="gi">+        check_interval: float = DEFAULT_CHECK_INTERVAL,</span>
<span class="gi">+        fail_when_locked: bool = DEFAULT_FAIL_WHEN_LOCKED,</span>
<span class="gi">+        flags: constants.LockFlags = LOCK_METHOD,</span>
<span class="gi">+        **file_open_kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        if &#39;w&#39; in mode:
<span class="w"> </span>            truncate = True
<span class="w"> </span>            mode = mode.replace(&#39;w&#39;, &#39;a&#39;)
<span class="w"> </span>        else:
<span class="w"> </span>            truncate = False
<span class="gi">+</span>
<span class="w"> </span>        if timeout is None:
<span class="w"> </span>            timeout = DEFAULT_TIMEOUT
<span class="gd">-        elif not flags &amp; constants.LockFlags.NON_BLOCKING:</span>
<span class="gd">-            warnings.warn(&#39;timeout has no effect in blocking mode&#39;,</span>
<span class="gd">-                stacklevel=1)</span>
<span class="gi">+        elif not (flags &amp; constants.LockFlags.NON_BLOCKING):</span>
<span class="gi">+            warnings.warn(</span>
<span class="gi">+                &#39;timeout has no effect in blocking mode&#39;,</span>
<span class="gi">+                stacklevel=1,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="w"> </span>        self.fh: typing.Optional[typing.IO] = None
<span class="w"> </span>        self.filename: str = str(filename)
<span class="w"> </span>        self.mode: str = mode
<span class="gu">@@ -145,68 +228,195 @@ class Lock(LockBase):</span>
<span class="w"> </span>        self.flags: constants.LockFlags = flags
<span class="w"> </span>        self.file_open_kwargs = file_open_kwargs

<span class="gd">-    def acquire(self, timeout: typing.Optional[float]=None, check_interval:</span>
<span class="gd">-        typing.Optional[float]=None, fail_when_locked: typing.Optional[bool</span>
<span class="gd">-        ]=None) -&gt;typing.IO[typing.AnyStr]:</span>
<span class="gd">-        &quot;&quot;&quot;Acquire the locked filehandle&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    def acquire(</span>
<span class="gi">+        self,</span>
<span class="gi">+        timeout: typing.Optional[float] = None,</span>
<span class="gi">+        check_interval: typing.Optional[float] = None,</span>
<span class="gi">+        fail_when_locked: typing.Optional[bool] = None,</span>
<span class="gi">+    ) -&gt; typing.IO[typing.AnyStr]:</span>
<span class="gi">+        &#39;&#39;&#39;Acquire the locked filehandle&#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        fail_when_locked = coalesce(fail_when_locked, self.fail_when_locked)</span>

<span class="gd">-    def __enter__(self) -&gt;typing.IO[typing.AnyStr]:</span>
<span class="gi">+        if (</span>
<span class="gi">+            not (self.flags &amp; constants.LockFlags.NON_BLOCKING)</span>
<span class="gi">+            and timeout is not None</span>
<span class="gi">+        ):</span>
<span class="gi">+            warnings.warn(</span>
<span class="gi">+                &#39;timeout has no effect in blocking mode&#39;,</span>
<span class="gi">+                stacklevel=1,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        # If we already have a filehandle, return it</span>
<span class="gi">+        fh: typing.Optional[typing.IO] = self.fh</span>
<span class="gi">+        if fh:</span>
<span class="gi">+            return fh</span>
<span class="gi">+</span>
<span class="gi">+        # Get a new filehandler</span>
<span class="gi">+        fh = self._get_fh()</span>
<span class="gi">+</span>
<span class="gi">+        def try_close():  # pragma: no cover</span>
<span class="gi">+            # Silently try to close the handle if possible, ignore all issues</span>
<span class="gi">+            if fh is not None:</span>
<span class="gi">+                with contextlib.suppress(Exception):</span>
<span class="gi">+                    fh.close()</span>
<span class="gi">+</span>
<span class="gi">+        exception = None</span>
<span class="gi">+        # Try till the timeout has passed</span>
<span class="gi">+        for _ in self._timeout_generator(timeout, check_interval):</span>
<span class="gi">+            exception = None</span>
<span class="gi">+            try:</span>
<span class="gi">+                # Try to lock</span>
<span class="gi">+                fh = self._get_lock(fh)</span>
<span class="gi">+                break</span>
<span class="gi">+            except exceptions.LockException as exc:</span>
<span class="gi">+                # Python will automatically remove the variable from memory</span>
<span class="gi">+                # unless you save it in a different location</span>
<span class="gi">+                exception = exc</span>
<span class="gi">+</span>
<span class="gi">+                # We already tried to the get the lock</span>
<span class="gi">+                # If fail_when_locked is True, stop trying</span>
<span class="gi">+                if fail_when_locked:</span>
<span class="gi">+                    try_close()</span>
<span class="gi">+                    raise exceptions.AlreadyLocked(exception) from exc</span>
<span class="gi">+            except Exception as exc:</span>
<span class="gi">+                # Something went wrong with the locking mechanism.</span>
<span class="gi">+                # Wrap in a LockException and re-raise:</span>
<span class="gi">+                try_close()</span>
<span class="gi">+                raise exceptions.LockException(exc) from exc</span>
<span class="gi">+</span>
<span class="gi">+            # Wait a bit</span>
<span class="gi">+</span>
<span class="gi">+        if exception:</span>
<span class="gi">+            try_close()</span>
<span class="gi">+            # We got a timeout... reraising</span>
<span class="gi">+            raise exception</span>
<span class="gi">+</span>
<span class="gi">+        # Prepare the filehandle (truncate if needed)</span>
<span class="gi">+        fh = self._prepare_fh(fh)</span>
<span class="gi">+</span>
<span class="gi">+        self.fh = fh</span>
<span class="gi">+        return fh</span>
<span class="gi">+</span>
<span class="gi">+    def __enter__(self) -&gt; typing.IO[typing.AnyStr]:</span>
<span class="w"> </span>        return self.acquire()

<span class="w"> </span>    def release(self):
<span class="gd">-        &quot;&quot;&quot;Releases the currently locked file handle&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _get_fh(self) -&gt;typing.IO:</span>
<span class="gd">-        &quot;&quot;&quot;Get a new filehandle&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def _get_lock(self, fh: typing.IO) -&gt;typing.IO:</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gi">+        &#39;&#39;&#39;Releases the currently locked file handle&#39;&#39;&#39;</span>
<span class="gi">+        if self.fh:</span>
<span class="gi">+            portalocker.unlock(self.fh)</span>
<span class="gi">+            self.fh.close()</span>
<span class="gi">+            self.fh = None</span>
<span class="gi">+</span>
<span class="gi">+    def _get_fh(self) -&gt; typing.IO:</span>
<span class="gi">+        &#39;&#39;&#39;Get a new filehandle&#39;&#39;&#39;</span>
<span class="gi">+        return open(  # noqa: SIM115</span>
<span class="gi">+            self.filename,</span>
<span class="gi">+            self.mode,</span>
<span class="gi">+            **self.file_open_kwargs,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def _get_lock(self, fh: typing.IO) -&gt; typing.IO:</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="w"> </span>        Try to lock the given filehandle

<span class="gd">-        returns LockException if it fails&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        returns LockException if it fails&#39;&#39;&#39;</span>
<span class="gi">+        portalocker.lock(fh, self.flags)</span>
<span class="gi">+        return fh</span>

<span class="gd">-    def _prepare_fh(self, fh: typing.IO) -&gt;typing.IO:</span>
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gi">+    def _prepare_fh(self, fh: typing.IO) -&gt; typing.IO:</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="w"> </span>        Prepare the filehandle for usage

<span class="w"> </span>        If truncate is a number, the file will be truncated to that amount of
<span class="w"> </span>        bytes
<span class="gd">-        &quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        &#39;&#39;&#39;</span>
<span class="gi">+        if self.truncate:</span>
<span class="gi">+            fh.seek(0)</span>
<span class="gi">+            fh.truncate(0)</span>
<span class="gi">+</span>
<span class="gi">+        return fh</span>


<span class="w"> </span>class RLock(Lock):
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="w"> </span>    A reentrant lock, functions in a similar way to threading.RLock in that it
<span class="w"> </span>    can be acquired multiple times.  When the corresponding number of release()
<span class="w"> </span>    calls are made the lock will finally release the underlying file lock.
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, filename, mode=&#39;a&#39;, timeout=DEFAULT_TIMEOUT,</span>
<span class="gd">-        check_interval=DEFAULT_CHECK_INTERVAL, fail_when_locked=False,</span>
<span class="gd">-        flags=LOCK_METHOD):</span>
<span class="gd">-        super().__init__(filename, mode, timeout, check_interval,</span>
<span class="gd">-            fail_when_locked, flags)</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        filename,</span>
<span class="gi">+        mode=&#39;a&#39;,</span>
<span class="gi">+        timeout=DEFAULT_TIMEOUT,</span>
<span class="gi">+        check_interval=DEFAULT_CHECK_INTERVAL,</span>
<span class="gi">+        fail_when_locked=False,</span>
<span class="gi">+        flags=LOCK_METHOD,</span>
<span class="gi">+    ):</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            filename,</span>
<span class="gi">+            mode,</span>
<span class="gi">+            timeout,</span>
<span class="gi">+            check_interval,</span>
<span class="gi">+            fail_when_locked,</span>
<span class="gi">+            flags,</span>
<span class="gi">+        )</span>
<span class="w"> </span>        self._acquire_count = 0

<span class="gi">+    def acquire(</span>
<span class="gi">+        self,</span>
<span class="gi">+        timeout: typing.Optional[float] = None,</span>
<span class="gi">+        check_interval: typing.Optional[float] = None,</span>
<span class="gi">+        fail_when_locked: typing.Optional[bool] = None,</span>
<span class="gi">+    ) -&gt; typing.IO:</span>
<span class="gi">+        if self._acquire_count &gt;= 1:</span>
<span class="gi">+            fh = self.fh</span>
<span class="gi">+        else:</span>
<span class="gi">+            fh = super().acquire(timeout, check_interval, fail_when_locked)</span>
<span class="gi">+        self._acquire_count += 1</span>
<span class="gi">+        assert fh</span>
<span class="gi">+        return fh</span>

<span class="gd">-class TemporaryFileLock(Lock):</span>
<span class="gi">+    def release(self):</span>
<span class="gi">+        if self._acquire_count == 0:</span>
<span class="gi">+            raise exceptions.LockException(</span>
<span class="gi">+                &#39;Cannot release more times than acquired&#39;,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if self._acquire_count == 1:</span>
<span class="gi">+            super().release()</span>
<span class="gi">+        self._acquire_count -= 1</span>

<span class="gd">-    def __init__(self, filename=&#39;.lock&#39;, timeout=DEFAULT_TIMEOUT,</span>
<span class="gd">-        check_interval=DEFAULT_CHECK_INTERVAL, fail_when_locked=True, flags</span>
<span class="gd">-        =LOCK_METHOD):</span>
<span class="gd">-        Lock.__init__(self, filename=filename, mode=&#39;w&#39;, timeout=timeout,</span>
<span class="gd">-            check_interval=check_interval, fail_when_locked=</span>
<span class="gd">-            fail_when_locked, flags=flags)</span>
<span class="gi">+</span>
<span class="gi">+class TemporaryFileLock(Lock):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        filename=&#39;.lock&#39;,</span>
<span class="gi">+        timeout=DEFAULT_TIMEOUT,</span>
<span class="gi">+        check_interval=DEFAULT_CHECK_INTERVAL,</span>
<span class="gi">+        fail_when_locked=True,</span>
<span class="gi">+        flags=LOCK_METHOD,</span>
<span class="gi">+    ):</span>
<span class="gi">+        Lock.__init__(</span>
<span class="gi">+            self,</span>
<span class="gi">+            filename=filename,</span>
<span class="gi">+            mode=&#39;w&#39;,</span>
<span class="gi">+            timeout=timeout,</span>
<span class="gi">+            check_interval=check_interval,</span>
<span class="gi">+            fail_when_locked=fail_when_locked,</span>
<span class="gi">+            flags=flags,</span>
<span class="gi">+        )</span>
<span class="w"> </span>        atexit.register(self.release)

<span class="gi">+    def release(self):</span>
<span class="gi">+        Lock.release(self)</span>
<span class="gi">+        if os.path.isfile(self.filename):  # pragma: no branch</span>
<span class="gi">+            os.unlink(self.filename)</span>
<span class="gi">+</span>

<span class="w"> </span>class BoundedSemaphore(LockBase):
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="w"> </span>    Bounded semaphore to prevent too many parallel processes from running

<span class="w"> </span>    This method is deprecated because multiple processes that are completely
<span class="gu">@@ -219,29 +429,100 @@ class BoundedSemaphore(LockBase):</span>
<span class="w"> </span>    &#39;bounded_semaphore.00.lock&#39;
<span class="w"> </span>    &gt;&gt;&gt; str(sorted(semaphore.get_random_filenames())[1])
<span class="w"> </span>    &#39;bounded_semaphore.01.lock&#39;
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>    lock: typing.Optional[Lock]

<span class="gd">-    def __init__(self, maximum: int, name: str=&#39;bounded_semaphore&#39;,</span>
<span class="gd">-        filename_pattern: str=&#39;{name}.{number:02d}.lock&#39;, directory: str=</span>
<span class="gd">-        tempfile.gettempdir(), timeout: typing.Optional[float]=</span>
<span class="gd">-        DEFAULT_TIMEOUT, check_interval: typing.Optional[float]=</span>
<span class="gd">-        DEFAULT_CHECK_INTERVAL, fail_when_locked: typing.Optional[bool]=True):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        maximum: int,</span>
<span class="gi">+        name: str = &#39;bounded_semaphore&#39;,</span>
<span class="gi">+        filename_pattern: str = &#39;{name}.{number:02d}.lock&#39;,</span>
<span class="gi">+        directory: str = tempfile.gettempdir(),</span>
<span class="gi">+        timeout: typing.Optional[float] = DEFAULT_TIMEOUT,</span>
<span class="gi">+        check_interval: typing.Optional[float] = DEFAULT_CHECK_INTERVAL,</span>
<span class="gi">+        fail_when_locked: typing.Optional[bool] = True,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.maximum = maximum
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.filename_pattern = filename_pattern
<span class="w"> </span>        self.directory = directory
<span class="w"> </span>        self.lock: typing.Optional[Lock] = None
<span class="gd">-        super().__init__(timeout=timeout, check_interval=check_interval,</span>
<span class="gd">-            fail_when_locked=fail_when_locked)</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            timeout=timeout,</span>
<span class="gi">+            check_interval=check_interval,</span>
<span class="gi">+            fail_when_locked=fail_when_locked,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="w"> </span>        if not name or name == &#39;bounded_semaphore&#39;:
<span class="w"> </span>            warnings.warn(
<span class="gd">-                &#39;`BoundedSemaphore` without an explicit `name` argument is deprecated, use NamedBoundedSemaphore&#39;</span>
<span class="gd">-                , DeprecationWarning, stacklevel=1)</span>
<span class="gi">+                &#39;`BoundedSemaphore` without an explicit `name` &#39;</span>
<span class="gi">+                &#39;argument is deprecated, use NamedBoundedSemaphore&#39;,</span>
<span class="gi">+                DeprecationWarning,</span>
<span class="gi">+                stacklevel=1,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    def get_filenames(self) -&gt; typing.Sequence[pathlib.Path]:</span>
<span class="gi">+        return [self.get_filename(n) for n in range(self.maximum)]</span>
<span class="gi">+</span>
<span class="gi">+    def get_random_filenames(self) -&gt; typing.Sequence[pathlib.Path]:</span>
<span class="gi">+        filenames = list(self.get_filenames())</span>
<span class="gi">+        random.shuffle(filenames)</span>
<span class="gi">+        return filenames</span>
<span class="gi">+</span>
<span class="gi">+    def get_filename(self, number) -&gt; pathlib.Path:</span>
<span class="gi">+        return pathlib.Path(self.directory) / self.filename_pattern.format(</span>
<span class="gi">+            name=self.name,</span>
<span class="gi">+            number=number,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def acquire(  # type: ignore[override]</span>
<span class="gi">+        self,</span>
<span class="gi">+        timeout: typing.Optional[float] = None,</span>
<span class="gi">+        check_interval: typing.Optional[float] = None,</span>
<span class="gi">+        fail_when_locked: typing.Optional[bool] = None,</span>
<span class="gi">+    ) -&gt; typing.Optional[Lock]:</span>
<span class="gi">+        assert not self.lock, &#39;Already locked&#39;</span>
<span class="gi">+</span>
<span class="gi">+        filenames = self.get_filenames()</span>
<span class="gi">+</span>
<span class="gi">+        for n in self._timeout_generator(timeout, check_interval):  # pragma:</span>
<span class="gi">+            logger.debug(&#39;trying lock (attempt %d) %r&#39;, n, filenames)</span>
<span class="gi">+            # no branch</span>
<span class="gi">+            if self.try_lock(filenames):  # pragma: no branch</span>
<span class="gi">+                return self.lock  # pragma: no cover</span>
<span class="gi">+</span>
<span class="gi">+        if fail_when_locked := coalesce(</span>
<span class="gi">+            fail_when_locked,</span>
<span class="gi">+            self.fail_when_locked,</span>
<span class="gi">+        ):</span>
<span class="gi">+            raise exceptions.AlreadyLocked()</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def try_lock(self, filenames: typing.Sequence[Filename]) -&gt; bool:</span>
<span class="gi">+        filename: Filename</span>
<span class="gi">+        for filename in filenames:</span>
<span class="gi">+            logger.debug(&#39;trying lock for %r&#39;, filename)</span>
<span class="gi">+            self.lock = Lock(filename, fail_when_locked=True)</span>
<span class="gi">+            try:</span>
<span class="gi">+                self.lock.acquire()</span>
<span class="gi">+            except exceptions.AlreadyLocked:</span>
<span class="gi">+                self.lock = None</span>
<span class="gi">+            else:</span>
<span class="gi">+                logger.debug(&#39;locked %r&#39;, filename)</span>
<span class="gi">+                return True</span>
<span class="gi">+</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def release(self):  # pragma: no cover</span>
<span class="gi">+        if self.lock is not None:</span>
<span class="gi">+            self.lock.release()</span>
<span class="gi">+            self.lock = None</span>


<span class="w"> </span>class NamedBoundedSemaphore(BoundedSemaphore):
<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="w"> </span>    Bounded semaphore to prevent too many parallel processes from running

<span class="w"> </span>    It&#39;s also possible to specify a timeout when acquiring the lock to wait
<span class="gu">@@ -263,14 +544,26 @@ class NamedBoundedSemaphore(BoundedSemaphore):</span>
<span class="w"> </span>    &gt;&gt;&gt; &#39;bounded_semaphore&#39; in str(semaphore.get_filenames()[0])
<span class="w"> </span>    True

<span class="gd">-    &quot;&quot;&quot;</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, maximum: int, name: typing.Optional[str]=None,</span>
<span class="gd">-        filename_pattern: str=&#39;{name}.{number:02d}.lock&#39;, directory: str=</span>
<span class="gd">-        tempfile.gettempdir(), timeout: typing.Optional[float]=</span>
<span class="gd">-        DEFAULT_TIMEOUT, check_interval: typing.Optional[float]=</span>
<span class="gd">-        DEFAULT_CHECK_INTERVAL, fail_when_locked: typing.Optional[bool]=True):</span>
<span class="gi">+    &#39;&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        maximum: int,</span>
<span class="gi">+        name: typing.Optional[str] = None,</span>
<span class="gi">+        filename_pattern: str = &#39;{name}.{number:02d}.lock&#39;,</span>
<span class="gi">+        directory: str = tempfile.gettempdir(),</span>
<span class="gi">+        timeout: typing.Optional[float] = DEFAULT_TIMEOUT,</span>
<span class="gi">+        check_interval: typing.Optional[float] = DEFAULT_CHECK_INTERVAL,</span>
<span class="gi">+        fail_when_locked: typing.Optional[bool] = True,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        if name is None:
<span class="w"> </span>            name = &#39;bounded_semaphore.%d&#39; % random.randint(0, 1000000)
<span class="gd">-        super().__init__(maximum, name, filename_pattern, directory,</span>
<span class="gd">-            timeout, check_interval, fail_when_locked)</span>
<span class="gi">+        super().__init__(</span>
<span class="gi">+            maximum,</span>
<span class="gi">+            name,</span>
<span class="gi">+            filename_pattern,</span>
<span class="gi">+            directory,</span>
<span class="gi">+            timeout,</span>
<span class="gi">+            check_interval,</span>
<span class="gi">+            fail_when_locked,</span>
<span class="gi">+        )</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>