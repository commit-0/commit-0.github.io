
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference loguru - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-loguru" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference loguru
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_loggerymlbasic_logger_usagemethodtrace" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::basic_logger_usage[method=trace]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlbasic_logger_usagemethoddebug" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::basic_logger_usage[method=debug]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlbasic_logger_usagemethodinfo" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::basic_logger_usage[method=info]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlbasic_logger_usagemethodsuccess" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::basic_logger_usage[method=success]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlbasic_logger_usagemethodwarning" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::basic_logger_usage[method=warning]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlbasic_logger_usagemethoderror" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::basic_logger_usage[method=error]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlbasic_logger_usagemethodexception" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::basic_logger_usage[method=exception]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlbasic_logger_usagemethodcritical" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::basic_logger_usage[method=critical]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlusing_log_functionlevelinfo" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::using_log_function[level='INFO']
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlusing_log_functionlevel30" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::using_log_function[level=30]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlusing_logging_arguments" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::using_logging_arguments
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymllogging_non_stringmessage123" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::logging_non_string[message=123]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymllogging_non_stringmessagedictfoo456" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::logging_non_string[message=dict(foo=456)]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymllogging_non_stringmessageobject" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::logging_non_string[message=object()]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymladd_sinksinksysstderr" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::add_sink[sink=sys.stderr]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymladd_sinksinktesttxt" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::add_sink[sink='test.txt']
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymladd_sinksinkpathfilelog" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::add_sink[sink=Path('file.log')]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymladd_sinksinklambda-m-none" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::add_sink[sink=lambda m: None]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymladd_sinksinkstreamhandler" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::add_sink[sink=StreamHandler()]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlbasic_sink_optionsformatmessagefiltermodulecontextfork" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::basic_sink_options[format='{message}',filter='module',context='fork']
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlbasic_sink_optionsformatlambda-r-messagenfilterlambda-r-truecontextget_contextfork" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::basic_sink_options[format=lambda r: '{message}\n',filter=lambda r: True,context=get_context('fork')]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlfile_sink_options" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::file_sink_options
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlasync_sink_options" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::async_sink_options
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlremove_sink" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::remove_sink
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlawait_completion" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::await_completion
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlcatch_as_decorator_with_parentheses" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::catch_as_decorator_with_parentheses
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlcatch_as_decorator_without_parentheses" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::catch_as_decorator_without_parentheses
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlcatch_as_context_manager" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::catch_as_context_manager
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlopt" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::opt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlbind" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::bind
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlpatch" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::patch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlcontextualize" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::contextualize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymllevel_get" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::level_get
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymllevel_set" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::level_set
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymllevel_update" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::level_update
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlenable_and_disable_logger" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::enable_and_disable_logger
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlconfigure" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::configure
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlparse" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::parse
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlinvalid_add_argument" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::invalid_add_argument
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlinvalid_logged_object_formatting" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::invalid_logged_object_formatting
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_loggerymlinvalid_configuration" class="md-nav__link">
    <span class="md-ellipsis">
      test_logger.yml::invalid_configuration
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-loguru"><strong>Reference (Gold)</strong>: loguru</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">1459</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">38</td>
</tr>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">41</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">1538</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">1538</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_loggerymlbasic_logger_usagemethodtrace">test_logger.yml::basic_logger_usage[method=trace]</h3>
<details><summary> <pre>test_logger.yml::basic_logger_usage[method=trace]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:14: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:3: note: Revealed type is "Any"          (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:3: note: Revealed type is "loguru.Logger" (diff)
E     main:4: note: Revealed type is "None"         (diff)
E   Alignment of first line difference:
E     E: main:3: note: Revealed type is "loguru.Logger"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlbasic_logger_usagemethoddebug">test_logger.yml::basic_logger_usage[method=debug]</h3>
<details><summary> <pre>test_logger.yml::basic_logger_usage[method=debug]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:14: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:3: note: Revealed type is "Any"          (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:3: note: Revealed type is "loguru.Logger" (diff)
E     main:4: note: Revealed type is "None"         (diff)
E   Alignment of first line difference:
E     E: main:3: note: Revealed type is "loguru.Logger"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlbasic_logger_usagemethodinfo">test_logger.yml::basic_logger_usage[method=info]</h3>
<details><summary> <pre>test_logger.yml::basic_logger_usage[method=info]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:14: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:3: note: Revealed type is "Any"          (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:3: note: Revealed type is "loguru.Logger" (diff)
E     main:4: note: Revealed type is "None"         (diff)
E   Alignment of first line difference:
E     E: main:3: note: Revealed type is "loguru.Logger"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlbasic_logger_usagemethodsuccess">test_logger.yml::basic_logger_usage[method=success]</h3>
<details><summary> <pre>test_logger.yml::basic_logger_usage[method=success]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:14: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:3: note: Revealed type is "Any"          (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:3: note: Revealed type is "loguru.Logger" (diff)
E     main:4: note: Revealed type is "None"         (diff)
E   Alignment of first line difference:
E     E: main:3: note: Revealed type is "loguru.Logger"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlbasic_logger_usagemethodwarning">test_logger.yml::basic_logger_usage[method=warning]</h3>
<details><summary> <pre>test_logger.yml::basic_logger_usage[method=warning]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:14: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:3: note: Revealed type is "Any"          (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:3: note: Revealed type is "loguru.Logger" (diff)
E     main:4: note: Revealed type is "None"         (diff)
E   Alignment of first line difference:
E     E: main:3: note: Revealed type is "loguru.Logger"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlbasic_logger_usagemethoderror">test_logger.yml::basic_logger_usage[method=error]</h3>
<details><summary> <pre>test_logger.yml::basic_logger_usage[method=error]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:14: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:3: note: Revealed type is "Any"          (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:3: note: Revealed type is "loguru.Logger" (diff)
E     main:4: note: Revealed type is "None"         (diff)
E   Alignment of first line difference:
E     E: main:3: note: Revealed type is "loguru.Logger"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlbasic_logger_usagemethodexception">test_logger.yml::basic_logger_usage[method=exception]</h3>
<details><summary> <pre>test_logger.yml::basic_logger_usage[method=exception]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:14: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:3: note: Revealed type is "Any"          (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:3: note: Revealed type is "loguru.Logger" (diff)
E     main:4: note: Revealed type is "None"         (diff)
E   Alignment of first line difference:
E     E: main:3: note: Revealed type is "loguru.Logger"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlbasic_logger_usagemethodcritical">test_logger.yml::basic_logger_usage[method=critical]</h3>
<details><summary> <pre>test_logger.yml::basic_logger_usage[method=critical]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:14: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:3: note: Revealed type is "Any"          (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:3: note: Revealed type is "loguru.Logger" (diff)
E     main:4: note: Revealed type is "None"         (diff)
E   Alignment of first line difference:
E     E: main:3: note: Revealed type is "loguru.Logger"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlusing_log_functionlevelinfo">test_logger.yml::using_log_function[level='INFO']</h3>
<details><summary> <pre>test_logger.yml::using_log_function[level='INFO']</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:24: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Output is not expected: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     (empty)
</pre>
</details>
<h3 id="test_loggerymlusing_log_functionlevel30">test_logger.yml::using_log_function[level=30]</h3>
<details><summary> <pre>test_logger.yml::using_log_function[level=30]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:24: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Output is not expected: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     (empty)
</pre>
</details>
<h3 id="test_loggerymlusing_logging_arguments">test_logger.yml::using_logging_arguments</h3>
<details><summary> <pre>test_logger.yml::using_logging_arguments</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:29: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Output is not expected: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     (empty)
</pre>
</details>
<h3 id="test_loggerymllogging_non_stringmessage123">test_logger.yml::logging_non_string[message=123]</h3>
<details><summary> <pre>test_logger.yml::logging_non_string[message=123]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:38: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Output is not expected: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     (empty)
</pre>
</details>
<h3 id="test_loggerymllogging_non_stringmessagedictfoo456">test_logger.yml::logging_non_string[message=dict(foo=456)]</h3>
<details><summary> <pre>test_logger.yml::logging_non_string[message=dict(foo=456)]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:38: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Output is not expected: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     (empty)
</pre>
</details>
<h3 id="test_loggerymllogging_non_stringmessageobject">test_logger.yml::logging_non_string[message=object()]</h3>
<details><summary> <pre>test_logger.yml::logging_non_string[message=object()]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:38: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Output is not expected: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     (empty)
</pre>
</details>
<h3 id="test_loggerymladd_sinksinksysstderr">test_logger.yml::add_sink[sink=sys.stderr]</h3>
<details><summary> <pre>test_logger.yml::add_sink[sink=sys.stderr]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:55: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:2: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:2: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:6: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:6: note: Revealed type is "builtins.int" (diff)
E   Alignment of first line difference:
E     E: main:6: note: Revealed type is "builtins.int"...
E     A: main:2: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymladd_sinksinktesttxt">test_logger.yml::add_sink[sink='test.txt']</h3>
<details><summary> <pre>test_logger.yml::add_sink[sink='test.txt']</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:55: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:2: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:2: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:6: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:6: note: Revealed type is "builtins.int" (diff)
E   Alignment of first line difference:
E     E: main:6: note: Revealed type is "builtins.int"...
E     A: main:2: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymladd_sinksinkpathfilelog">test_logger.yml::add_sink[sink=Path('file.log')]</h3>
<details><summary> <pre>test_logger.yml::add_sink[sink=Path('file.log')]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:55: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:2: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:2: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:6: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:6: note: Revealed type is "builtins.int" (diff)
E   Alignment of first line difference:
E     E: main:6: note: Revealed type is "builtins.int"...
E     A: main:2: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymladd_sinksinklambda-m-none">test_logger.yml::add_sink[sink=lambda m: None]</h3>
<details><summary> <pre>test_logger.yml::add_sink[sink=lambda m: None]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:55: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:2: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:2: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:6: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:6: note: Revealed type is "builtins.int" (diff)
E   Alignment of first line difference:
E     E: main:6: note: Revealed type is "builtins.int"...
E     A: main:2: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymladd_sinksinkstreamhandler">test_logger.yml::add_sink[sink=StreamHandler()]</h3>
<details><summary> <pre>test_logger.yml::add_sink[sink=StreamHandler()]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:55: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:2: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:2: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:6: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:6: note: Revealed type is "builtins.int" (diff)
E   Alignment of first line difference:
E     E: main:6: note: Revealed type is "builtins.int"...
E     A: main:2: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlbasic_sink_optionsformatmessagefiltermodulecontextfork">test_logger.yml::basic_sink_options[format='{message}',filter='module',context='fork']</h3>
<details><summary> <pre>test_logger.yml::basic_sink_options[format='{message}',filter='module',context='fork']</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:67: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Output is not expected: 
E   Actual:
E     main:3: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:3: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     (empty)
</pre>
</details>
<h3 id="test_loggerymlbasic_sink_optionsformatlambda-r-messagenfilterlambda-r-truecontextget_contextfork">test_logger.yml::basic_sink_options[format=lambda r: '{message}\n',filter=lambda r: True,context=get_context('fork')]</h3>
<details><summary> <pre>test_logger.yml::basic_sink_options[format=lambda r: '{message}\n',filter=lambda r: True,context=get_context('fork')]</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:67: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Output is not expected: 
E   Actual:
E     main:3: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:3: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     (empty)
</pre>
</details>
<h3 id="test_loggerymlfile_sink_options">test_logger.yml::file_sink_options</h3>
<details><summary> <pre>test_logger.yml::file_sink_options</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:85: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Output is not expected: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     (empty)
</pre>
</details>
<h3 id="test_loggerymlasync_sink_options">test_logger.yml::async_sink_options</h3>
<details><summary> <pre>test_logger.yml::async_sink_options</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:101: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Output is not expected: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     (empty)
</pre>
</details>
<h3 id="test_loggerymlremove_sink">test_logger.yml::remove_sink</h3>
<details><summary> <pre>test_logger.yml::remove_sink</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:113: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Output is not expected: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     (empty)
</pre>
</details>
<h3 id="test_loggerymlawait_completion">test_logger.yml::await_completion</h3>
<details><summary> <pre>test_logger.yml::await_completion</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:123: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:5: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:5: note: Revealed type is "typing.Awaitable[None]" (diff)
E   Alignment of first line difference:
E     E: main:5: note: Revealed type is "typing.Awaitable[None]"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlcatch_as_decorator_with_parentheses">test_logger.yml::catch_as_decorator_with_parentheses</h3>
<details><summary> <pre>test_logger.yml::catch_as_decorator_with_parentheses</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:134: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:6: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:6: note: Revealed type is "def (a: builtins.int, b: builtins.int) -> builtins.int" (diff)
E   Alignment of first line difference:
E     E: main:6: note: Revealed type is "def (a: builtins.int, b: builtins.int) -...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlcatch_as_decorator_without_parentheses">test_logger.yml::catch_as_decorator_without_parentheses</h3>
<details><summary> <pre>test_logger.yml::catch_as_decorator_without_parentheses</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:145: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:6: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:6: note: Revealed type is "def (a: builtins.int, b: builtins.int) -> builtins.int" (diff)
E   Alignment of first line difference:
E     E: main:6: note: Revealed type is "def (a: builtins.int, b: builtins.int) -...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlcatch_as_context_manager">test_logger.yml::catch_as_context_manager</h3>
<details><summary> <pre>test_logger.yml::catch_as_context_manager</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:155: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:5: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:5: note: Revealed type is "loguru.Catcher" (diff)
E   Alignment of first line difference:
E     E: main:5: note: Revealed type is "loguru.Catcher"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlopt">test_logger.yml::opt</h3>
<details><summary> <pre>test_logger.yml::opt</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:164: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:4: note: Revealed type is "loguru.Logger" (diff)
E   Alignment of first line difference:
E     E: main:4: note: Revealed type is "loguru.Logger"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlbind">test_logger.yml::bind</h3>
<details><summary> <pre>test_logger.yml::bind</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:173: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:4: note: Revealed type is "loguru.Logger" (diff)
E   Alignment of first line difference:
E     E: main:4: note: Revealed type is "loguru.Logger"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlpatch">test_logger.yml::patch</h3>
<details><summary> <pre>test_logger.yml::patch</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:182: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:4: note: Revealed type is "loguru.Logger" (diff)
E   Alignment of first line difference:
E     E: main:4: note: Revealed type is "loguru.Logger"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlcontextualize">test_logger.yml::contextualize</h3>
<details><summary> <pre>test_logger.yml::contextualize</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:192: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:5: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:5: note: Revealed type is "loguru.Contextualizer" (diff)
E   Alignment of first line difference:
E     E: main:5: note: Revealed type is "loguru.Contextualizer"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymllevel_get">test_logger.yml::level_get</h3>
<details><summary> <pre>test_logger.yml::level_get</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:202: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:4: note: Revealed type is "tuple[builtins.str, builtins.int, builtins.str, builtins.str, fallback=loguru.Level]" (diff)
E   Alignment of first line difference:
E     E: main:4: note: Revealed type is "tuple[builtins.str, builtins.int, builti...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymllevel_set">test_logger.yml::level_set</h3>
<details><summary> <pre>test_logger.yml::level_set</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:222: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:4: note: Revealed type is "tuple[builtins.str, builtins.int, builtins.str, builtins.str, fallback=loguru.Level]" (diff)
E   Alignment of first line difference:
E     E: main:4: note: Revealed type is "tuple[builtins.str, builtins.int, builti...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymllevel_update">test_logger.yml::level_update</h3>
<details><summary> <pre>test_logger.yml::level_update</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:242: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:4: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:4: note: Revealed type is "tuple[builtins.str, builtins.int, builtins.str, builtins.str, fallback=loguru.Level]" (diff)
E   Alignment of first line difference:
E     E: main:4: note: Revealed type is "tuple[builtins.str, builtins.int, builti...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlenable_and_disable_logger">test_logger.yml::enable_and_disable_logger</h3>
<details><summary> <pre>test_logger.yml::enable_and_disable_logger</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:257: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Output is not expected: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     (empty)
</pre>
</details>
<h3 id="test_loggerymlconfigure">test_logger.yml::configure</h3>
<details><summary> <pre>test_logger.yml::configure</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:272: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:9: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:9: note: Revealed type is "builtins.list[builtins.int]" (diff)
E   Alignment of first line difference:
E     E: main:9: note: Revealed type is "builtins.list[builtins.int]"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlparse">test_logger.yml::parse</h3>
<details><summary> <pre>test_logger.yml::parse</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:282: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru"  [import] (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E     main:5: note: Revealed type is "Any"          (diff)
E     main:6: note: Revealed type is "Any"          (diff)
E   Expected:
E     main:5: note: Revealed type is "typing.Generator[builtins.dict[builtins.str, Any], None, None]" (diff)
E     main:6: note: Revealed type is "builtins.dict[builtins.str, Any]" (diff)
E   Alignment of first line difference:
E     E: main:5: note: Revealed type is "typing.Generator[builtins.dict[builtins....
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlinvalid_add_argument">test_logger.yml::invalid_add_argument</h3>
<details><summary> <pre>test_logger.yml::invalid_add_argument</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:292: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru" (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     main:2: error: No overload variant of "add" of "Logger" matches argument types "Callable[[Any], None]", "int" (diff)
E     main:2: note: Possible overload variants:     (diff)
E     main:2: note:     def add(self, sink: TextIO | Writable | Callable[[Message], None] | Handler, *, level: str | int = ..., format: str | Callable[[Record], str] = ..., filter: str | Callable[[Record], bool] | dict[str | None, str | int | bool] | None = ..., colorize: bool | None = ..., serialize: bool = ..., backtrace: bool = ..., diagnose: bool = ..., enqueue: bool = ..., context: str | BaseContext | None = ..., catch: bool = ...) -> int (diff)
E     main:2: note:     def add(self, sink: Callable[[Message], Awaitable[None]], *, level: str | int = ..., format: str | Callable[[Record], str] = ..., filter: str | Callable[[Record], bool] | dict[str | None, str | int | bool] | None = ..., colorize: bool | None = ..., serialize: bool = ..., backtrace: bool = ..., diagnose: bool = ..., enqueue: bool = ..., context: str | BaseContext | None = ..., catch: bool = ..., loop: AbstractEventLoop | None = ...) -> int (diff)
E     main:2: note:     def add(self, sink: str | PathLike[str], *, level: str | int = ..., format: str | Callable[[Record], str] = ..., filter: str | Callable[[Record], bool] | dict[str | None, str | int | bool] | None = ..., colorize: bool | None = ..., serialize: bool = ..., backtrace: bool = ..., diagnose: bool = ..., enqueue: bool = ..., context: str | BaseContext | None = ..., catch: bool = ..., rotation: str | int | time | timedelta | Callable[[Message, TextIO], bool] | None = ..., retention: str | int | timedelta | Callable[[list[str]], None] | None = ..., compression: str | Callable[[str], None] | None = ..., delay: bool = ..., watch: bool = ..., mode: str = ..., buffering: int = ..., encoding: str = ..., **kwargs: Any) -> int (diff)
E   Alignment of first line difference:
E     E: main:2: error: No overload variant of "add" of "Logger" matches argument...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlinvalid_logged_object_formatting">test_logger.yml::invalid_logged_object_formatting</h3>
<details><summary> <pre>test_logger.yml::invalid_logged_object_formatting</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:334: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru" (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     main:2: error: No overload variant of "info" of "Logger" matches argument types "int", "int" (diff)
E     main:2: note: Possible overload variants:     (diff)
E     main:2: note:     def info(__self, str, /, *args: Any, **kwargs: Any) -> None (diff)
E     main:2: note:     def info(__self, Any, /) -> None (diff)
E   Alignment of first line difference:
E     E: main:2: error: No overload variant of "info" of "Logger" matches argumen...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>
<h3 id="test_loggerymlinvalid_configuration">test_logger.yml::invalid_configuration</h3>
<details><summary> <pre>test_logger.yml::invalid_configuration</pre></summary><pre>
/testbed/tests/typesafety/test_logger.yml:362: 
E   pytest_mypy_plugins.utils.TypecheckAssertionError: Invalid output: 
E   Actual:
E     main:1: error: Cannot find implementation or library stub for module named "loguru" (diff)
E     main:1: note: See https://mypy.readthedocs.io/en/stable/running_mypy.html#missing-imports (diff)
E   Expected:
E     main:4: error: Extra key "baz" for TypedDict "LevelConfig" (diff)
E     main:5: error: Argument "patcher" to "configure" of "Logger" has incompatible type "int"; expected "Callable[[Record], None] | None" (diff)
E     main:6: error: List item 0 has incompatible type "dict[str, str]"; expected "tuple[str | None, bool]" (diff)
E     main:7: error: Argument "extra" to "configure" of "Logger" has incompatible type "list[<nothing>]"; expected "dict[Any, Any] | None" (diff)
E   Alignment of first line difference:
E     E: main:4: error: Extra key "baz" for TypedDict "LevelConfig"...
E     A: main:1: error: Cannot find implementation or library stub for module nam...
E             ^
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/loguru/_asyncio_loop.py b/loguru/_asyncio_loop.py</span>
<span class="gh">index a1d4421..e981955 100644</span>
<span class="gd">--- a/loguru/_asyncio_loop.py</span>
<span class="gi">+++ b/loguru/_asyncio_loop.py</span>
<span class="gu">@@ -1,3 +1,27 @@</span>
<span class="w"> </span>import asyncio
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def load_loop_functions():</span>
<span class="gi">+    if sys.version_info &gt;= (3, 7):</span>
<span class="gi">+</span>
<span class="gi">+        def get_task_loop(task):</span>
<span class="gi">+            return task.get_loop()</span>
<span class="gi">+</span>
<span class="gi">+        get_running_loop = asyncio.get_running_loop</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+</span>
<span class="gi">+        def get_task_loop(task):</span>
<span class="gi">+            return task._loop</span>
<span class="gi">+</span>
<span class="gi">+        def get_running_loop():</span>
<span class="gi">+            loop = asyncio.get_event_loop()</span>
<span class="gi">+            if not loop.is_running():</span>
<span class="gi">+                raise RuntimeError(&quot;There is no running event loop&quot;)</span>
<span class="gi">+            return loop</span>
<span class="gi">+</span>
<span class="gi">+    return get_task_loop, get_running_loop</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>get_task_loop, get_running_loop = load_loop_functions()
<span class="gh">diff --git a/loguru/_better_exceptions.py b/loguru/_better_exceptions.py</span>
<span class="gh">index 6b15688..8327a13 100644</span>
<span class="gd">--- a/loguru/_better_exceptions.py</span>
<span class="gi">+++ b/loguru/_better_exceptions.py</span>
<span class="gu">@@ -9,46 +9,142 @@ import sys</span>
<span class="w"> </span>import sysconfig
<span class="w"> </span>import tokenize
<span class="w"> </span>import traceback
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &gt;= (3, 11):
<span class="gi">+</span>
<span class="gi">+    def is_exception_group(exc):</span>
<span class="gi">+        return isinstance(exc, ExceptionGroup)</span>
<span class="gi">+</span>
<span class="w"> </span>else:
<span class="w"> </span>    try:
<span class="w"> </span>        from exceptiongroup import ExceptionGroup
<span class="w"> </span>    except ImportError:

<span class="gi">+        def is_exception_group(exc):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    else:</span>
<span class="gi">+</span>
<span class="gi">+        def is_exception_group(exc):</span>
<span class="gi">+            return isinstance(exc, ExceptionGroup)</span>
<span class="gi">+</span>

<span class="w"> </span>class SyntaxHighlighter:
<span class="gd">-    _default_style = {&#39;comment&#39;: &#39;\x1b[30m\x1b[1m{}\x1b[0m&#39;, &#39;keyword&#39;:</span>
<span class="gd">-        &#39;\x1b[35m\x1b[1m{}\x1b[0m&#39;, &#39;builtin&#39;: &#39;\x1b[1m{}\x1b[0m&#39;, &#39;string&#39;:</span>
<span class="gd">-        &#39;\x1b[36m{}\x1b[0m&#39;, &#39;number&#39;: &#39;\x1b[34m\x1b[1m{}\x1b[0m&#39;,</span>
<span class="gd">-        &#39;operator&#39;: &#39;\x1b[35m\x1b[1m{}\x1b[0m&#39;, &#39;punctuation&#39;:</span>
<span class="gd">-        &#39;\x1b[1m{}\x1b[0m&#39;, &#39;constant&#39;: &#39;\x1b[36m\x1b[1m{}\x1b[0m&#39;,</span>
<span class="gd">-        &#39;identifier&#39;: &#39;\x1b[1m{}\x1b[0m&#39;, &#39;other&#39;: &#39;{}&#39;}</span>
<span class="gi">+    _default_style = {</span>
<span class="gi">+        &quot;comment&quot;: &quot;\x1b[30m\x1b[1m{}\x1b[0m&quot;,</span>
<span class="gi">+        &quot;keyword&quot;: &quot;\x1b[35m\x1b[1m{}\x1b[0m&quot;,</span>
<span class="gi">+        &quot;builtin&quot;: &quot;\x1b[1m{}\x1b[0m&quot;,</span>
<span class="gi">+        &quot;string&quot;: &quot;\x1b[36m{}\x1b[0m&quot;,</span>
<span class="gi">+        &quot;number&quot;: &quot;\x1b[34m\x1b[1m{}\x1b[0m&quot;,</span>
<span class="gi">+        &quot;operator&quot;: &quot;\x1b[35m\x1b[1m{}\x1b[0m&quot;,</span>
<span class="gi">+        &quot;punctuation&quot;: &quot;\x1b[1m{}\x1b[0m&quot;,</span>
<span class="gi">+        &quot;constant&quot;: &quot;\x1b[36m\x1b[1m{}\x1b[0m&quot;,</span>
<span class="gi">+        &quot;identifier&quot;: &quot;\x1b[1m{}\x1b[0m&quot;,</span>
<span class="gi">+        &quot;other&quot;: &quot;{}&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="w"> </span>    _builtins = set(dir(builtins))
<span class="gd">-    _constants = {&#39;True&#39;, &#39;False&#39;, &#39;None&#39;}</span>
<span class="gd">-    _punctation = {&#39;(&#39;, &#39;)&#39;, &#39;[&#39;, &#39;]&#39;, &#39;{&#39;, &#39;}&#39;, &#39;:&#39;, &#39;,&#39;, &#39;;&#39;}</span>
<span class="gi">+    _constants = {&quot;True&quot;, &quot;False&quot;, &quot;None&quot;}</span>
<span class="gi">+    _punctation = {&quot;(&quot;, &quot;)&quot;, &quot;[&quot;, &quot;]&quot;, &quot;{&quot;, &quot;}&quot;, &quot;:&quot;, &quot;,&quot;, &quot;;&quot;}</span>
<span class="w"> </span>    _strings = {tokenize.STRING}
<span class="w"> </span>    _fstring_middle = None
<span class="gi">+</span>
<span class="w"> </span>    if sys.version_info &gt;= (3, 12):
<span class="gd">-        _strings.update({tokenize.FSTRING_START, tokenize.FSTRING_MIDDLE,</span>
<span class="gd">-            tokenize.FSTRING_END})</span>
<span class="gi">+        _strings.update({tokenize.FSTRING_START, tokenize.FSTRING_MIDDLE, tokenize.FSTRING_END})</span>
<span class="w"> </span>        _fstring_middle = tokenize.FSTRING_MIDDLE

<span class="w"> </span>    def __init__(self, style=None):
<span class="w"> </span>        self._style = style or self._default_style

<span class="gi">+    def highlight(self, source):</span>
<span class="gi">+        style = self._style</span>
<span class="gi">+        row, column = 0, 0</span>
<span class="gi">+        output = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        for token in self.tokenize(source):</span>
<span class="gi">+            type_, string, (start_row, start_column), (_, end_column), line = token</span>
<span class="gi">+</span>
<span class="gi">+            if type_ == self._fstring_middle:</span>
<span class="gi">+                # When an f-string contains &quot;{{&quot; or &quot;}}&quot;, they appear as &quot;{&quot; or &quot;}&quot; in the &quot;string&quot;</span>
<span class="gi">+                # attribute of the token. However, they do not count in the column position.</span>
<span class="gi">+                end_column += string.count(&quot;{&quot;) + string.count(&quot;}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            if type_ == tokenize.NAME:</span>
<span class="gi">+                if string in self._constants:</span>
<span class="gi">+                    color = style[&quot;constant&quot;]</span>
<span class="gi">+                elif keyword.iskeyword(string):</span>
<span class="gi">+                    color = style[&quot;keyword&quot;]</span>
<span class="gi">+                elif string in self._builtins:</span>
<span class="gi">+                    color = style[&quot;builtin&quot;]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    color = style[&quot;identifier&quot;]</span>
<span class="gi">+            elif type_ == tokenize.OP:</span>
<span class="gi">+                if string in self._punctation:</span>
<span class="gi">+                    color = style[&quot;punctuation&quot;]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    color = style[&quot;operator&quot;]</span>
<span class="gi">+            elif type_ == tokenize.NUMBER:</span>
<span class="gi">+                color = style[&quot;number&quot;]</span>
<span class="gi">+            elif type_ in self._strings:</span>
<span class="gi">+                color = style[&quot;string&quot;]</span>
<span class="gi">+            elif type_ == tokenize.COMMENT:</span>
<span class="gi">+                color = style[&quot;comment&quot;]</span>
<span class="gi">+            else:</span>
<span class="gi">+                color = style[&quot;other&quot;]</span>
<span class="gi">+</span>
<span class="gi">+            if start_row != row:</span>
<span class="gi">+                source = source[column:]</span>
<span class="gi">+                row, column = start_row, 0</span>
<span class="gi">+</span>
<span class="gi">+            if type_ != tokenize.ENCODING:</span>
<span class="gi">+                output += line[column:start_column]</span>
<span class="gi">+                output += color.format(line[start_column:end_column])</span>
<span class="gi">+</span>
<span class="gi">+            column = end_column</span>
<span class="gi">+</span>
<span class="gi">+        output += source[column:]</span>
<span class="gi">+</span>
<span class="gi">+        return output</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def tokenize(source):</span>
<span class="gi">+        # Worth reading: https://www.asmeurer.com/brown-water-python/</span>
<span class="gi">+        source = source.encode(&quot;utf-8&quot;)</span>
<span class="gi">+        source = io.BytesIO(source)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield from tokenize.tokenize(source.readline)</span>
<span class="gi">+        except tokenize.TokenError:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>

<span class="w"> </span>class ExceptionFormatter:
<span class="gd">-    _default_theme = {&#39;introduction&#39;: &#39;\x1b[33m\x1b[1m{}\x1b[0m&#39;, &#39;cause&#39;:</span>
<span class="gd">-        &#39;\x1b[1m{}\x1b[0m&#39;, &#39;context&#39;: &#39;\x1b[1m{}\x1b[0m&#39;, &#39;dirname&#39;:</span>
<span class="gd">-        &#39;\x1b[32m{}\x1b[0m&#39;, &#39;basename&#39;: &#39;\x1b[32m\x1b[1m{}\x1b[0m&#39;, &#39;line&#39;:</span>
<span class="gd">-        &#39;\x1b[33m{}\x1b[0m&#39;, &#39;function&#39;: &#39;\x1b[35m{}\x1b[0m&#39;,</span>
<span class="gd">-        &#39;exception_type&#39;: &#39;\x1b[31m\x1b[1m{}\x1b[0m&#39;, &#39;exception_value&#39;:</span>
<span class="gd">-        &#39;\x1b[1m{}\x1b[0m&#39;, &#39;arrows&#39;: &#39;\x1b[36m{}\x1b[0m&#39;, &#39;value&#39;:</span>
<span class="gd">-        &#39;\x1b[36m\x1b[1m{}\x1b[0m&#39;}</span>
<span class="gd">-</span>
<span class="gd">-    def __init__(self, colorize=False, backtrace=False, diagnose=True,</span>
<span class="gd">-        theme=None, style=None, max_length=128, encoding=&#39;ascii&#39;,</span>
<span class="gd">-        hidden_frames_filename=None, prefix=&#39;&#39;):</span>
<span class="gi">+    _default_theme = {</span>
<span class="gi">+        &quot;introduction&quot;: &quot;\x1b[33m\x1b[1m{}\x1b[0m&quot;,</span>
<span class="gi">+        &quot;cause&quot;: &quot;\x1b[1m{}\x1b[0m&quot;,</span>
<span class="gi">+        &quot;context&quot;: &quot;\x1b[1m{}\x1b[0m&quot;,</span>
<span class="gi">+        &quot;dirname&quot;: &quot;\x1b[32m{}\x1b[0m&quot;,</span>
<span class="gi">+        &quot;basename&quot;: &quot;\x1b[32m\x1b[1m{}\x1b[0m&quot;,</span>
<span class="gi">+        &quot;line&quot;: &quot;\x1b[33m{}\x1b[0m&quot;,</span>
<span class="gi">+        &quot;function&quot;: &quot;\x1b[35m{}\x1b[0m&quot;,</span>
<span class="gi">+        &quot;exception_type&quot;: &quot;\x1b[31m\x1b[1m{}\x1b[0m&quot;,</span>
<span class="gi">+        &quot;exception_value&quot;: &quot;\x1b[1m{}\x1b[0m&quot;,</span>
<span class="gi">+        &quot;arrows&quot;: &quot;\x1b[36m{}\x1b[0m&quot;,</span>
<span class="gi">+        &quot;value&quot;: &quot;\x1b[36m\x1b[1m{}\x1b[0m&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        colorize=False,</span>
<span class="gi">+        backtrace=False,</span>
<span class="gi">+        diagnose=True,</span>
<span class="gi">+        theme=None,</span>
<span class="gi">+        style=None,</span>
<span class="gi">+        max_length=128,</span>
<span class="gi">+        encoding=&quot;ascii&quot;,</span>
<span class="gi">+        hidden_frames_filename=None,</span>
<span class="gi">+        prefix=&quot;&quot;,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self._colorize = colorize
<span class="w"> </span>        self._diagnose = diagnose
<span class="w"> </span>        self._theme = theme or self._default_theme
<span class="gu">@@ -59,6 +155,374 @@ class ExceptionFormatter:</span>
<span class="w"> </span>        self._hidden_frames_filename = hidden_frames_filename
<span class="w"> </span>        self._prefix = prefix
<span class="w"> </span>        self._lib_dirs = self._get_lib_dirs()
<span class="gd">-        self._pipe_char = self._get_char(&#39;│&#39;, &#39;|&#39;)</span>
<span class="gd">-        self._cap_char = self._get_char(&#39;└&#39;, &#39;-&gt;&#39;)</span>
<span class="gd">-        self._catch_point_identifier = &#39; &lt;Loguru catch point here&gt;&#39;</span>
<span class="gi">+        self._pipe_char = self._get_char(&quot;\u2502&quot;, &quot;|&quot;)</span>
<span class="gi">+        self._cap_char = self._get_char(&quot;\u2514&quot;, &quot;-&gt;&quot;)</span>
<span class="gi">+        self._catch_point_identifier = &quot; &lt;Loguru catch point here&gt;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _get_lib_dirs():</span>
<span class="gi">+        schemes = sysconfig.get_scheme_names()</span>
<span class="gi">+        names = [&quot;stdlib&quot;, &quot;platstdlib&quot;, &quot;platlib&quot;, &quot;purelib&quot;]</span>
<span class="gi">+        paths = {sysconfig.get_path(name, scheme) for scheme in schemes for name in names}</span>
<span class="gi">+        return [os.path.abspath(path).lower() + os.sep for path in paths if path in sys.path]</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _indent(text, count, *, prefix=&quot;| &quot;):</span>
<span class="gi">+        if count == 0:</span>
<span class="gi">+            yield text</span>
<span class="gi">+            return</span>
<span class="gi">+        for line in text.splitlines(True):</span>
<span class="gi">+            indented = &quot;  &quot; * count + prefix + line</span>
<span class="gi">+            yield indented.rstrip() + &quot;\n&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _get_char(self, char, default):</span>
<span class="gi">+        try:</span>
<span class="gi">+            char.encode(self._encoding)</span>
<span class="gi">+        except (UnicodeEncodeError, LookupError):</span>
<span class="gi">+            return default</span>
<span class="gi">+        else:</span>
<span class="gi">+            return char</span>
<span class="gi">+</span>
<span class="gi">+    def _is_file_mine(self, file):</span>
<span class="gi">+        filepath = os.path.abspath(file).lower()</span>
<span class="gi">+        if not filepath.endswith(&quot;.py&quot;):</span>
<span class="gi">+            return False</span>
<span class="gi">+        return not any(filepath.startswith(d) for d in self._lib_dirs)</span>
<span class="gi">+</span>
<span class="gi">+    def _extract_frames(self, tb, is_first, *, limit=None, from_decorator=False):</span>
<span class="gi">+        frames, final_source = [], None</span>
<span class="gi">+</span>
<span class="gi">+        if tb is None or (limit is not None and limit &lt;= 0):</span>
<span class="gi">+            return frames, final_source</span>
<span class="gi">+</span>
<span class="gi">+        def is_valid(frame):</span>
<span class="gi">+            return frame.f_code.co_filename != self._hidden_frames_filename</span>
<span class="gi">+</span>
<span class="gi">+        def get_info(frame, lineno):</span>
<span class="gi">+            filename = frame.f_code.co_filename</span>
<span class="gi">+            function = frame.f_code.co_name</span>
<span class="gi">+            source = linecache.getline(filename, lineno).strip()</span>
<span class="gi">+            return filename, lineno, function, source</span>
<span class="gi">+</span>
<span class="gi">+        infos = []</span>
<span class="gi">+</span>
<span class="gi">+        if is_valid(tb.tb_frame):</span>
<span class="gi">+            infos.append((get_info(tb.tb_frame, tb.tb_lineno), tb.tb_frame))</span>
<span class="gi">+</span>
<span class="gi">+        get_parent_only = from_decorator and not self._backtrace</span>
<span class="gi">+</span>
<span class="gi">+        if (self._backtrace and is_first) or get_parent_only:</span>
<span class="gi">+            frame = tb.tb_frame.f_back</span>
<span class="gi">+            while frame:</span>
<span class="gi">+                if is_valid(frame):</span>
<span class="gi">+                    infos.insert(0, (get_info(frame, frame.f_lineno), frame))</span>
<span class="gi">+                    if get_parent_only:</span>
<span class="gi">+                        break</span>
<span class="gi">+                frame = frame.f_back</span>
<span class="gi">+</span>
<span class="gi">+            if infos and not get_parent_only:</span>
<span class="gi">+                (filename, lineno, function, source), frame = infos[-1]</span>
<span class="gi">+                function += self._catch_point_identifier</span>
<span class="gi">+                infos[-1] = ((filename, lineno, function, source), frame)</span>
<span class="gi">+</span>
<span class="gi">+        tb = tb.tb_next</span>
<span class="gi">+</span>
<span class="gi">+        while tb:</span>
<span class="gi">+            if is_valid(tb.tb_frame):</span>
<span class="gi">+                infos.append((get_info(tb.tb_frame, tb.tb_lineno), tb.tb_frame))</span>
<span class="gi">+            tb = tb.tb_next</span>
<span class="gi">+</span>
<span class="gi">+        if limit is not None:</span>
<span class="gi">+            infos = infos[-limit:]</span>
<span class="gi">+</span>
<span class="gi">+        for (filename, lineno, function, source), frame in infos:</span>
<span class="gi">+            final_source = source</span>
<span class="gi">+            if source:</span>
<span class="gi">+                colorize = self._colorize and self._is_file_mine(filename)</span>
<span class="gi">+                lines = []</span>
<span class="gi">+                if colorize:</span>
<span class="gi">+                    lines.append(self._syntax_highlighter.highlight(source))</span>
<span class="gi">+                else:</span>
<span class="gi">+                    lines.append(source)</span>
<span class="gi">+                if self._diagnose:</span>
<span class="gi">+                    relevant_values = self._get_relevant_values(source, frame)</span>
<span class="gi">+                    values = self._format_relevant_values(list(relevant_values), colorize)</span>
<span class="gi">+                    lines += list(values)</span>
<span class="gi">+                source = &quot;\n    &quot;.join(lines)</span>
<span class="gi">+            frames.append((filename, lineno, function, source))</span>
<span class="gi">+</span>
<span class="gi">+        return frames, final_source</span>
<span class="gi">+</span>
<span class="gi">+    def _get_relevant_values(self, source, frame):</span>
<span class="gi">+        value = None</span>
<span class="gi">+        pending = None</span>
<span class="gi">+        is_attribute = False</span>
<span class="gi">+        is_valid_value = False</span>
<span class="gi">+        is_assignment = True</span>
<span class="gi">+</span>
<span class="gi">+        for token in self._syntax_highlighter.tokenize(source):</span>
<span class="gi">+            type_, string, (_, col), *_ = token</span>
<span class="gi">+</span>
<span class="gi">+            if pending is not None:</span>
<span class="gi">+                # Keyword arguments are ignored</span>
<span class="gi">+                if type_ != tokenize.OP or string != &quot;=&quot; or is_assignment:</span>
<span class="gi">+                    yield pending</span>
<span class="gi">+                pending = None</span>
<span class="gi">+</span>
<span class="gi">+            if type_ == tokenize.NAME and not keyword.iskeyword(string):</span>
<span class="gi">+                if not is_attribute:</span>
<span class="gi">+                    for variables in (frame.f_locals, frame.f_globals):</span>
<span class="gi">+                        try:</span>
<span class="gi">+                            value = variables[string]</span>
<span class="gi">+                        except KeyError:</span>
<span class="gi">+                            continue</span>
<span class="gi">+                        else:</span>
<span class="gi">+                            is_valid_value = True</span>
<span class="gi">+                            pending = (col, self._format_value(value))</span>
<span class="gi">+                            break</span>
<span class="gi">+                elif is_valid_value:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        value = inspect.getattr_static(value, string)</span>
<span class="gi">+                    except AttributeError:</span>
<span class="gi">+                        is_valid_value = False</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        yield (col, self._format_value(value))</span>
<span class="gi">+            elif type_ == tokenize.OP and string == &quot;.&quot;:</span>
<span class="gi">+                is_attribute = True</span>
<span class="gi">+                is_assignment = False</span>
<span class="gi">+            elif type_ == tokenize.OP and string == &quot;;&quot;:</span>
<span class="gi">+                is_assignment = True</span>
<span class="gi">+                is_attribute = False</span>
<span class="gi">+                is_valid_value = False</span>
<span class="gi">+            else:</span>
<span class="gi">+                is_attribute = False</span>
<span class="gi">+                is_valid_value = False</span>
<span class="gi">+                is_assignment = False</span>
<span class="gi">+</span>
<span class="gi">+        if pending is not None:</span>
<span class="gi">+            yield pending</span>
<span class="gi">+</span>
<span class="gi">+    def _format_relevant_values(self, relevant_values, colorize):</span>
<span class="gi">+        for i in reversed(range(len(relevant_values))):</span>
<span class="gi">+            col, value = relevant_values[i]</span>
<span class="gi">+            pipe_cols = [pcol for pcol, _ in relevant_values[:i]]</span>
<span class="gi">+            pre_line = &quot;&quot;</span>
<span class="gi">+            index = 0</span>
<span class="gi">+</span>
<span class="gi">+            for pc in pipe_cols:</span>
<span class="gi">+                pre_line += (&quot; &quot; * (pc - index)) + self._pipe_char</span>
<span class="gi">+                index = pc + 1</span>
<span class="gi">+</span>
<span class="gi">+            pre_line += &quot; &quot; * (col - index)</span>
<span class="gi">+            value_lines = value.split(&quot;\n&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            for n, value_line in enumerate(value_lines):</span>
<span class="gi">+                if n == 0:</span>
<span class="gi">+                    arrows = pre_line + self._cap_char + &quot; &quot;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    arrows = pre_line + &quot; &quot; * (len(self._cap_char) + 1)</span>
<span class="gi">+</span>
<span class="gi">+                if colorize:</span>
<span class="gi">+                    arrows = self._theme[&quot;arrows&quot;].format(arrows)</span>
<span class="gi">+                    value_line = self._theme[&quot;value&quot;].format(value_line)</span>
<span class="gi">+</span>
<span class="gi">+                yield arrows + value_line</span>
<span class="gi">+</span>
<span class="gi">+    def _format_value(self, v):</span>
<span class="gi">+        try:</span>
<span class="gi">+            v = repr(v)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            v = &quot;&lt;unprintable %s object&gt;&quot; % type(v).__name__</span>
<span class="gi">+</span>
<span class="gi">+        max_length = self._max_length</span>
<span class="gi">+        if max_length is not None and len(v) &gt; max_length:</span>
<span class="gi">+            v = v[: max_length - 3] + &quot;...&quot;</span>
<span class="gi">+        return v</span>
<span class="gi">+</span>
<span class="gi">+    def _format_locations(self, frames_lines, *, has_introduction):</span>
<span class="gi">+        prepend_with_new_line = has_introduction</span>
<span class="gi">+        regex = r&#39;^  File &quot;(?P&lt;file&gt;.*?)&quot;, line (?P&lt;line&gt;[^,]+)(?:, in (?P&lt;function&gt;.*))?\n&#39;</span>
<span class="gi">+</span>
<span class="gi">+        for frame in frames_lines:</span>
<span class="gi">+            match = re.match(regex, frame)</span>
<span class="gi">+</span>
<span class="gi">+            if match:</span>
<span class="gi">+                file, line, function = match.group(&quot;file&quot;, &quot;line&quot;, &quot;function&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                is_mine = self._is_file_mine(file)</span>
<span class="gi">+</span>
<span class="gi">+                if function is not None:</span>
<span class="gi">+                    pattern = &#39;  File &quot;{}&quot;, line {}, in {}\n&#39;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    pattern = &#39;  File &quot;{}&quot;, line {}\n&#39;</span>
<span class="gi">+</span>
<span class="gi">+                if self._backtrace and function and function.endswith(self._catch_point_identifier):</span>
<span class="gi">+                    function = function[: -len(self._catch_point_identifier)]</span>
<span class="gi">+                    pattern = &quot;&gt;&quot; + pattern[1:]</span>
<span class="gi">+</span>
<span class="gi">+                if self._colorize and is_mine:</span>
<span class="gi">+                    dirname, basename = os.path.split(file)</span>
<span class="gi">+                    if dirname:</span>
<span class="gi">+                        dirname += os.sep</span>
<span class="gi">+                    dirname = self._theme[&quot;dirname&quot;].format(dirname)</span>
<span class="gi">+                    basename = self._theme[&quot;basename&quot;].format(basename)</span>
<span class="gi">+                    file = dirname + basename</span>
<span class="gi">+                    line = self._theme[&quot;line&quot;].format(line)</span>
<span class="gi">+                    function = self._theme[&quot;function&quot;].format(function)</span>
<span class="gi">+</span>
<span class="gi">+                if self._diagnose and (is_mine or prepend_with_new_line):</span>
<span class="gi">+                    pattern = &quot;\n&quot; + pattern</span>
<span class="gi">+</span>
<span class="gi">+                location = pattern.format(file, line, function)</span>
<span class="gi">+                frame = location + frame[match.end() :]</span>
<span class="gi">+                prepend_with_new_line = is_mine</span>
<span class="gi">+</span>
<span class="gi">+            yield frame</span>
<span class="gi">+</span>
<span class="gi">+    def _format_exception(</span>
<span class="gi">+        self, value, tb, *, seen=None, is_first=False, from_decorator=False, group_nesting=0</span>
<span class="gi">+    ):</span>
<span class="gi">+        # Implemented from built-in traceback module:</span>
<span class="gi">+        # https://github.com/python/cpython/blob/a5b76167/Lib/traceback.py#L468</span>
<span class="gi">+        exc_type, exc_value, exc_traceback = type(value), value, tb</span>
<span class="gi">+</span>
<span class="gi">+        if seen is None:</span>
<span class="gi">+            seen = set()</span>
<span class="gi">+</span>
<span class="gi">+        seen.add(id(exc_value))</span>
<span class="gi">+</span>
<span class="gi">+        if exc_value:</span>
<span class="gi">+            if exc_value.__cause__ is not None and id(exc_value.__cause__) not in seen:</span>
<span class="gi">+                yield from self._format_exception(</span>
<span class="gi">+                    exc_value.__cause__,</span>
<span class="gi">+                    exc_value.__cause__.__traceback__,</span>
<span class="gi">+                    seen=seen,</span>
<span class="gi">+                    group_nesting=group_nesting,</span>
<span class="gi">+                )</span>
<span class="gi">+                cause = &quot;The above exception was the direct cause of the following exception:&quot;</span>
<span class="gi">+                if self._colorize:</span>
<span class="gi">+                    cause = self._theme[&quot;cause&quot;].format(cause)</span>
<span class="gi">+                if self._diagnose:</span>
<span class="gi">+                    yield from self._indent(&quot;\n\n&quot; + cause + &quot;\n\n\n&quot;, group_nesting)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield from self._indent(&quot;\n&quot; + cause + &quot;\n\n&quot;, group_nesting)</span>
<span class="gi">+</span>
<span class="gi">+            elif (</span>
<span class="gi">+                exc_value.__context__ is not None</span>
<span class="gi">+                and id(exc_value.__context__) not in seen</span>
<span class="gi">+                and not exc_value.__suppress_context__</span>
<span class="gi">+            ):</span>
<span class="gi">+                yield from self._format_exception(</span>
<span class="gi">+                    exc_value.__context__,</span>
<span class="gi">+                    exc_value.__context__.__traceback__,</span>
<span class="gi">+                    seen=seen,</span>
<span class="gi">+                    group_nesting=group_nesting,</span>
<span class="gi">+                )</span>
<span class="gi">+                context = &quot;During handling of the above exception, another exception occurred:&quot;</span>
<span class="gi">+                if self._colorize:</span>
<span class="gi">+                    context = self._theme[&quot;context&quot;].format(context)</span>
<span class="gi">+                if self._diagnose:</span>
<span class="gi">+                    yield from self._indent(&quot;\n\n&quot; + context + &quot;\n\n\n&quot;, group_nesting)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield from self._indent(&quot;\n&quot; + context + &quot;\n\n&quot;, group_nesting)</span>
<span class="gi">+</span>
<span class="gi">+        is_grouped = is_exception_group(value)</span>
<span class="gi">+</span>
<span class="gi">+        if is_grouped and group_nesting == 0:</span>
<span class="gi">+            yield from self._format_exception(</span>
<span class="gi">+                value,</span>
<span class="gi">+                tb,</span>
<span class="gi">+                seen=seen,</span>
<span class="gi">+                group_nesting=1,</span>
<span class="gi">+                is_first=is_first,</span>
<span class="gi">+                from_decorator=from_decorator,</span>
<span class="gi">+            )</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            traceback_limit = sys.tracebacklimit</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            traceback_limit = None</span>
<span class="gi">+</span>
<span class="gi">+        frames, final_source = self._extract_frames(</span>
<span class="gi">+            exc_traceback, is_first, limit=traceback_limit, from_decorator=from_decorator</span>
<span class="gi">+        )</span>
<span class="gi">+        exception_only = traceback.format_exception_only(exc_type, exc_value)</span>
<span class="gi">+</span>
<span class="gi">+        # Determining the correct index for the &quot;Exception: message&quot; part in the formatted exception</span>
<span class="gi">+        # is challenging. This is because it might be preceded by multiple lines specific to</span>
<span class="gi">+        # &quot;SyntaxError&quot; or followed by various notes. However, we can make an educated guess based</span>
<span class="gi">+        # on the indentation; the preliminary context for &quot;SyntaxError&quot; is always indented, while</span>
<span class="gi">+        # the Exception itself is not. This allows us to identify the correct index for the</span>
<span class="gi">+        # exception message.</span>
<span class="gi">+        for error_message_index, part in enumerate(exception_only):  # noqa: B007</span>
<span class="gi">+            if not part.startswith(&quot; &quot;):</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        error_message = exception_only[error_message_index][:-1]  # Remove last new line temporarily</span>
<span class="gi">+</span>
<span class="gi">+        if self._colorize:</span>
<span class="gi">+            if &quot;:&quot; in error_message:</span>
<span class="gi">+                exception_type, exception_value = error_message.split(&quot;:&quot;, 1)</span>
<span class="gi">+                exception_type = self._theme[&quot;exception_type&quot;].format(exception_type)</span>
<span class="gi">+                exception_value = self._theme[&quot;exception_value&quot;].format(exception_value)</span>
<span class="gi">+                error_message = exception_type + &quot;:&quot; + exception_value</span>
<span class="gi">+            else:</span>
<span class="gi">+                error_message = self._theme[&quot;exception_type&quot;].format(error_message)</span>
<span class="gi">+</span>
<span class="gi">+        if self._diagnose and frames:</span>
<span class="gi">+            if issubclass(exc_type, AssertionError) and not str(exc_value) and final_source:</span>
<span class="gi">+                if self._colorize:</span>
<span class="gi">+                    final_source = self._syntax_highlighter.highlight(final_source)</span>
<span class="gi">+                error_message += &quot;: &quot; + final_source</span>
<span class="gi">+</span>
<span class="gi">+            error_message = &quot;\n&quot; + error_message</span>
<span class="gi">+</span>
<span class="gi">+        exception_only[error_message_index] = error_message + &quot;\n&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if is_first:</span>
<span class="gi">+            yield self._prefix</span>
<span class="gi">+</span>
<span class="gi">+        has_introduction = bool(frames)</span>
<span class="gi">+</span>
<span class="gi">+        if has_introduction:</span>
<span class="gi">+            if is_grouped:</span>
<span class="gi">+                introduction = &quot;Exception Group Traceback (most recent call last):&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                introduction = &quot;Traceback (most recent call last):&quot;</span>
<span class="gi">+            if self._colorize:</span>
<span class="gi">+                introduction = self._theme[&quot;introduction&quot;].format(introduction)</span>
<span class="gi">+            if group_nesting == 1:  # Implies we&#39;re processing the root ExceptionGroup.</span>
<span class="gi">+                yield from self._indent(introduction + &quot;\n&quot;, group_nesting, prefix=&quot;+ &quot;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                yield from self._indent(introduction + &quot;\n&quot;, group_nesting)</span>
<span class="gi">+</span>
<span class="gi">+        frames_lines = traceback.format_list(frames) + exception_only</span>
<span class="gi">+        if self._colorize or self._backtrace or self._diagnose:</span>
<span class="gi">+            frames_lines = self._format_locations(frames_lines, has_introduction=has_introduction)</span>
<span class="gi">+</span>
<span class="gi">+        yield from self._indent(&quot;&quot;.join(frames_lines), group_nesting)</span>
<span class="gi">+</span>
<span class="gi">+        if is_grouped:</span>
<span class="gi">+            for n, exc in enumerate(value.exceptions, start=1):</span>
<span class="gi">+                ruler = &quot;+&quot; + (&quot; %s &quot; % (&quot;...&quot; if n &gt; 15 else n)).center(35, &quot;-&quot;)</span>
<span class="gi">+                yield from self._indent(ruler, group_nesting, prefix=&quot;+-&quot; if n == 1 else &quot;  &quot;)</span>
<span class="gi">+                if n &gt; 15:</span>
<span class="gi">+                    message = &quot;and %d more exceptions\n&quot; % (len(value.exceptions) - 15)</span>
<span class="gi">+                    yield from self._indent(message, group_nesting + 1)</span>
<span class="gi">+                    break</span>
<span class="gi">+                elif group_nesting == 10 and is_exception_group(exc):</span>
<span class="gi">+                    message = &quot;... (max_group_depth is 10)\n&quot;</span>
<span class="gi">+                    yield from self._indent(message, group_nesting + 1)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    yield from self._format_exception(</span>
<span class="gi">+                        exc,</span>
<span class="gi">+                        exc.__traceback__,</span>
<span class="gi">+                        seen=seen,</span>
<span class="gi">+                        group_nesting=group_nesting + 1,</span>
<span class="gi">+                    )</span>
<span class="gi">+            if not is_exception_group(exc) or group_nesting == 10:</span>
<span class="gi">+                yield from self._indent(&quot;-&quot; * 35, group_nesting + 1, prefix=&quot;+-&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def format_exception(self, type_, value, tb, *, from_decorator=False):</span>
<span class="gi">+        yield from self._format_exception(value, tb, is_first=True, from_decorator=from_decorator)</span>
<span class="gh">diff --git a/loguru/_colorama.py b/loguru/_colorama.py</span>
<span class="gh">index 82cda0b..b69c700 100644</span>
<span class="gd">--- a/loguru/_colorama.py</span>
<span class="gi">+++ b/loguru/_colorama.py</span>
<span class="gu">@@ -1,2 +1,66 @@</span>
<span class="w"> </span>import os
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def should_colorize(stream):</span>
<span class="gi">+    if stream is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if stream is sys.stdout or stream is sys.stderr:</span>
<span class="gi">+        try:</span>
<span class="gi">+            import ipykernel</span>
<span class="gi">+            import IPython</span>
<span class="gi">+</span>
<span class="gi">+            ipython = IPython.get_ipython()</span>
<span class="gi">+            is_jupyter_stream = isinstance(stream, ipykernel.iostream.OutStream)</span>
<span class="gi">+            is_jupyter_shell = isinstance(ipython, ipykernel.zmqshell.ZMQInteractiveShell)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            if is_jupyter_stream and is_jupyter_shell:</span>
<span class="gi">+                return True</span>
<span class="gi">+</span>
<span class="gi">+    if stream is sys.__stdout__ or stream is sys.__stderr__:</span>
<span class="gi">+        if &quot;CI&quot; in os.environ and any(</span>
<span class="gi">+            ci in os.environ</span>
<span class="gi">+            for ci in [&quot;TRAVIS&quot;, &quot;CIRCLECI&quot;, &quot;APPVEYOR&quot;, &quot;GITLAB_CI&quot;, &quot;GITHUB_ACTIONS&quot;]</span>
<span class="gi">+        ):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if &quot;PYCHARM_HOSTED&quot; in os.environ:</span>
<span class="gi">+            return True</span>
<span class="gi">+        if os.name == &quot;nt&quot; and &quot;TERM&quot; in os.environ:</span>
<span class="gi">+            return True</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return stream.isatty()</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def should_wrap(stream):</span>
<span class="gi">+    if os.name != &quot;nt&quot;:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    if stream is not sys.__stdout__ and stream is not sys.__stderr__:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    from colorama.win32 import winapi_test</span>
<span class="gi">+</span>
<span class="gi">+    if not winapi_test():</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        from colorama.winterm import enable_vt_processing</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        return not enable_vt_processing(stream.fileno())</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def wrap(stream):</span>
<span class="gi">+    from colorama import AnsiToWin32</span>
<span class="gi">+</span>
<span class="gi">+    return AnsiToWin32(stream, convert=True, strip=True, autoreset=False).stream</span>
<span class="gh">diff --git a/loguru/_colorizer.py b/loguru/_colorizer.py</span>
<span class="gh">index b5aa9a1..ed87cdb 100644</span>
<span class="gd">--- a/loguru/_colorizer.py</span>
<span class="gi">+++ b/loguru/_colorizer.py</span>
<span class="gu">@@ -25,6 +25,7 @@ class Fore:</span>
<span class="w"> </span>    CYAN = 36
<span class="w"> </span>    WHITE = 37
<span class="w"> </span>    RESET = 39
<span class="gi">+</span>
<span class="w"> </span>    LIGHTBLACK_EX = 90
<span class="w"> </span>    LIGHTRED_EX = 91
<span class="w"> </span>    LIGHTGREEN_EX = 92
<span class="gu">@@ -45,6 +46,7 @@ class Back:</span>
<span class="w"> </span>    CYAN = 46
<span class="w"> </span>    WHITE = 47
<span class="w"> </span>    RESET = 49
<span class="gi">+</span>
<span class="w"> </span>    LIGHTBLACK_EX = 100
<span class="w"> </span>    LIGHTRED_EX = 101
<span class="w"> </span>    LIGHTGREEN_EX = 102
<span class="gu">@@ -55,6 +57,10 @@ class Back:</span>
<span class="w"> </span>    LIGHTWHITE_EX = 107


<span class="gi">+def ansi_escape(codes):</span>
<span class="gi">+    return {name: &quot;\033[%dm&quot; % code for name, code in codes.items()}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class TokenType:
<span class="w"> </span>    TEXT = 1
<span class="w"> </span>    ANSI = 2
<span class="gu">@@ -63,66 +69,403 @@ class TokenType:</span>


<span class="w"> </span>class AnsiParser:
<span class="gd">-    _style = ansi_escape({&#39;b&#39;: Style.BOLD, &#39;d&#39;: Style.DIM, &#39;n&#39;: Style.</span>
<span class="gd">-        NORMAL, &#39;h&#39;: Style.HIDE, &#39;i&#39;: Style.ITALIC, &#39;l&#39;: Style.BLINK, &#39;s&#39;:</span>
<span class="gd">-        Style.STRIKE, &#39;u&#39;: Style.UNDERLINE, &#39;v&#39;: Style.REVERSE, &#39;bold&#39;:</span>
<span class="gd">-        Style.BOLD, &#39;dim&#39;: Style.DIM, &#39;normal&#39;: Style.NORMAL, &#39;hide&#39;: Style</span>
<span class="gd">-        .HIDE, &#39;italic&#39;: Style.ITALIC, &#39;blink&#39;: Style.BLINK, &#39;strike&#39;:</span>
<span class="gd">-        Style.STRIKE, &#39;underline&#39;: Style.UNDERLINE, &#39;reverse&#39;: Style.REVERSE})</span>
<span class="gd">-    _foreground = ansi_escape({&#39;k&#39;: Fore.BLACK, &#39;r&#39;: Fore.RED, &#39;g&#39;: Fore.</span>
<span class="gd">-        GREEN, &#39;y&#39;: Fore.YELLOW, &#39;e&#39;: Fore.BLUE, &#39;m&#39;: Fore.MAGENTA, &#39;c&#39;:</span>
<span class="gd">-        Fore.CYAN, &#39;w&#39;: Fore.WHITE, &#39;lk&#39;: Fore.LIGHTBLACK_EX, &#39;lr&#39;: Fore.</span>
<span class="gd">-        LIGHTRED_EX, &#39;lg&#39;: Fore.LIGHTGREEN_EX, &#39;ly&#39;: Fore.LIGHTYELLOW_EX,</span>
<span class="gd">-        &#39;le&#39;: Fore.LIGHTBLUE_EX, &#39;lm&#39;: Fore.LIGHTMAGENTA_EX, &#39;lc&#39;: Fore.</span>
<span class="gd">-        LIGHTCYAN_EX, &#39;lw&#39;: Fore.LIGHTWHITE_EX, &#39;black&#39;: Fore.BLACK, &#39;red&#39;:</span>
<span class="gd">-        Fore.RED, &#39;green&#39;: Fore.GREEN, &#39;yellow&#39;: Fore.YELLOW, &#39;blue&#39;: Fore.</span>
<span class="gd">-        BLUE, &#39;magenta&#39;: Fore.MAGENTA, &#39;cyan&#39;: Fore.CYAN, &#39;white&#39;: Fore.</span>
<span class="gd">-        WHITE, &#39;light-black&#39;: Fore.LIGHTBLACK_EX, &#39;light-red&#39;: Fore.</span>
<span class="gd">-        LIGHTRED_EX, &#39;light-green&#39;: Fore.LIGHTGREEN_EX, &#39;light-yellow&#39;:</span>
<span class="gd">-        Fore.LIGHTYELLOW_EX, &#39;light-blue&#39;: Fore.LIGHTBLUE_EX,</span>
<span class="gd">-        &#39;light-magenta&#39;: Fore.LIGHTMAGENTA_EX, &#39;light-cyan&#39;: Fore.</span>
<span class="gd">-        LIGHTCYAN_EX, &#39;light-white&#39;: Fore.LIGHTWHITE_EX})</span>
<span class="gd">-    _background = ansi_escape({&#39;K&#39;: Back.BLACK, &#39;R&#39;: Back.RED, &#39;G&#39;: Back.</span>
<span class="gd">-        GREEN, &#39;Y&#39;: Back.YELLOW, &#39;E&#39;: Back.BLUE, &#39;M&#39;: Back.MAGENTA, &#39;C&#39;:</span>
<span class="gd">-        Back.CYAN, &#39;W&#39;: Back.WHITE, &#39;LK&#39;: Back.LIGHTBLACK_EX, &#39;LR&#39;: Back.</span>
<span class="gd">-        LIGHTRED_EX, &#39;LG&#39;: Back.LIGHTGREEN_EX, &#39;LY&#39;: Back.LIGHTYELLOW_EX,</span>
<span class="gd">-        &#39;LE&#39;: Back.LIGHTBLUE_EX, &#39;LM&#39;: Back.LIGHTMAGENTA_EX, &#39;LC&#39;: Back.</span>
<span class="gd">-        LIGHTCYAN_EX, &#39;LW&#39;: Back.LIGHTWHITE_EX, &#39;BLACK&#39;: Back.BLACK, &#39;RED&#39;:</span>
<span class="gd">-        Back.RED, &#39;GREEN&#39;: Back.GREEN, &#39;YELLOW&#39;: Back.YELLOW, &#39;BLUE&#39;: Back.</span>
<span class="gd">-        BLUE, &#39;MAGENTA&#39;: Back.MAGENTA, &#39;CYAN&#39;: Back.CYAN, &#39;WHITE&#39;: Back.</span>
<span class="gd">-        WHITE, &#39;LIGHT-BLACK&#39;: Back.LIGHTBLACK_EX, &#39;LIGHT-RED&#39;: Back.</span>
<span class="gd">-        LIGHTRED_EX, &#39;LIGHT-GREEN&#39;: Back.LIGHTGREEN_EX, &#39;LIGHT-YELLOW&#39;:</span>
<span class="gd">-        Back.LIGHTYELLOW_EX, &#39;LIGHT-BLUE&#39;: Back.LIGHTBLUE_EX,</span>
<span class="gd">-        &#39;LIGHT-MAGENTA&#39;: Back.LIGHTMAGENTA_EX, &#39;LIGHT-CYAN&#39;: Back.</span>
<span class="gd">-        LIGHTCYAN_EX, &#39;LIGHT-WHITE&#39;: Back.LIGHTWHITE_EX})</span>
<span class="gd">-    _regex_tag = re.compile(&#39;\\\\?&lt;/?((?:[fb]g\\s)?[^&lt;&gt;\\s]*)&gt;&#39;)</span>
<span class="gi">+    _style = ansi_escape(</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;b&quot;: Style.BOLD,</span>
<span class="gi">+            &quot;d&quot;: Style.DIM,</span>
<span class="gi">+            &quot;n&quot;: Style.NORMAL,</span>
<span class="gi">+            &quot;h&quot;: Style.HIDE,</span>
<span class="gi">+            &quot;i&quot;: Style.ITALIC,</span>
<span class="gi">+            &quot;l&quot;: Style.BLINK,</span>
<span class="gi">+            &quot;s&quot;: Style.STRIKE,</span>
<span class="gi">+            &quot;u&quot;: Style.UNDERLINE,</span>
<span class="gi">+            &quot;v&quot;: Style.REVERSE,</span>
<span class="gi">+            &quot;bold&quot;: Style.BOLD,</span>
<span class="gi">+            &quot;dim&quot;: Style.DIM,</span>
<span class="gi">+            &quot;normal&quot;: Style.NORMAL,</span>
<span class="gi">+            &quot;hide&quot;: Style.HIDE,</span>
<span class="gi">+            &quot;italic&quot;: Style.ITALIC,</span>
<span class="gi">+            &quot;blink&quot;: Style.BLINK,</span>
<span class="gi">+            &quot;strike&quot;: Style.STRIKE,</span>
<span class="gi">+            &quot;underline&quot;: Style.UNDERLINE,</span>
<span class="gi">+            &quot;reverse&quot;: Style.REVERSE,</span>
<span class="gi">+        }</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    _foreground = ansi_escape(</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;k&quot;: Fore.BLACK,</span>
<span class="gi">+            &quot;r&quot;: Fore.RED,</span>
<span class="gi">+            &quot;g&quot;: Fore.GREEN,</span>
<span class="gi">+            &quot;y&quot;: Fore.YELLOW,</span>
<span class="gi">+            &quot;e&quot;: Fore.BLUE,</span>
<span class="gi">+            &quot;m&quot;: Fore.MAGENTA,</span>
<span class="gi">+            &quot;c&quot;: Fore.CYAN,</span>
<span class="gi">+            &quot;w&quot;: Fore.WHITE,</span>
<span class="gi">+            &quot;lk&quot;: Fore.LIGHTBLACK_EX,</span>
<span class="gi">+            &quot;lr&quot;: Fore.LIGHTRED_EX,</span>
<span class="gi">+            &quot;lg&quot;: Fore.LIGHTGREEN_EX,</span>
<span class="gi">+            &quot;ly&quot;: Fore.LIGHTYELLOW_EX,</span>
<span class="gi">+            &quot;le&quot;: Fore.LIGHTBLUE_EX,</span>
<span class="gi">+            &quot;lm&quot;: Fore.LIGHTMAGENTA_EX,</span>
<span class="gi">+            &quot;lc&quot;: Fore.LIGHTCYAN_EX,</span>
<span class="gi">+            &quot;lw&quot;: Fore.LIGHTWHITE_EX,</span>
<span class="gi">+            &quot;black&quot;: Fore.BLACK,</span>
<span class="gi">+            &quot;red&quot;: Fore.RED,</span>
<span class="gi">+            &quot;green&quot;: Fore.GREEN,</span>
<span class="gi">+            &quot;yellow&quot;: Fore.YELLOW,</span>
<span class="gi">+            &quot;blue&quot;: Fore.BLUE,</span>
<span class="gi">+            &quot;magenta&quot;: Fore.MAGENTA,</span>
<span class="gi">+            &quot;cyan&quot;: Fore.CYAN,</span>
<span class="gi">+            &quot;white&quot;: Fore.WHITE,</span>
<span class="gi">+            &quot;light-black&quot;: Fore.LIGHTBLACK_EX,</span>
<span class="gi">+            &quot;light-red&quot;: Fore.LIGHTRED_EX,</span>
<span class="gi">+            &quot;light-green&quot;: Fore.LIGHTGREEN_EX,</span>
<span class="gi">+            &quot;light-yellow&quot;: Fore.LIGHTYELLOW_EX,</span>
<span class="gi">+            &quot;light-blue&quot;: Fore.LIGHTBLUE_EX,</span>
<span class="gi">+            &quot;light-magenta&quot;: Fore.LIGHTMAGENTA_EX,</span>
<span class="gi">+            &quot;light-cyan&quot;: Fore.LIGHTCYAN_EX,</span>
<span class="gi">+            &quot;light-white&quot;: Fore.LIGHTWHITE_EX,</span>
<span class="gi">+        }</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    _background = ansi_escape(</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;K&quot;: Back.BLACK,</span>
<span class="gi">+            &quot;R&quot;: Back.RED,</span>
<span class="gi">+            &quot;G&quot;: Back.GREEN,</span>
<span class="gi">+            &quot;Y&quot;: Back.YELLOW,</span>
<span class="gi">+            &quot;E&quot;: Back.BLUE,</span>
<span class="gi">+            &quot;M&quot;: Back.MAGENTA,</span>
<span class="gi">+            &quot;C&quot;: Back.CYAN,</span>
<span class="gi">+            &quot;W&quot;: Back.WHITE,</span>
<span class="gi">+            &quot;LK&quot;: Back.LIGHTBLACK_EX,</span>
<span class="gi">+            &quot;LR&quot;: Back.LIGHTRED_EX,</span>
<span class="gi">+            &quot;LG&quot;: Back.LIGHTGREEN_EX,</span>
<span class="gi">+            &quot;LY&quot;: Back.LIGHTYELLOW_EX,</span>
<span class="gi">+            &quot;LE&quot;: Back.LIGHTBLUE_EX,</span>
<span class="gi">+            &quot;LM&quot;: Back.LIGHTMAGENTA_EX,</span>
<span class="gi">+            &quot;LC&quot;: Back.LIGHTCYAN_EX,</span>
<span class="gi">+            &quot;LW&quot;: Back.LIGHTWHITE_EX,</span>
<span class="gi">+            &quot;BLACK&quot;: Back.BLACK,</span>
<span class="gi">+            &quot;RED&quot;: Back.RED,</span>
<span class="gi">+            &quot;GREEN&quot;: Back.GREEN,</span>
<span class="gi">+            &quot;YELLOW&quot;: Back.YELLOW,</span>
<span class="gi">+            &quot;BLUE&quot;: Back.BLUE,</span>
<span class="gi">+            &quot;MAGENTA&quot;: Back.MAGENTA,</span>
<span class="gi">+            &quot;CYAN&quot;: Back.CYAN,</span>
<span class="gi">+            &quot;WHITE&quot;: Back.WHITE,</span>
<span class="gi">+            &quot;LIGHT-BLACK&quot;: Back.LIGHTBLACK_EX,</span>
<span class="gi">+            &quot;LIGHT-RED&quot;: Back.LIGHTRED_EX,</span>
<span class="gi">+            &quot;LIGHT-GREEN&quot;: Back.LIGHTGREEN_EX,</span>
<span class="gi">+            &quot;LIGHT-YELLOW&quot;: Back.LIGHTYELLOW_EX,</span>
<span class="gi">+            &quot;LIGHT-BLUE&quot;: Back.LIGHTBLUE_EX,</span>
<span class="gi">+            &quot;LIGHT-MAGENTA&quot;: Back.LIGHTMAGENTA_EX,</span>
<span class="gi">+            &quot;LIGHT-CYAN&quot;: Back.LIGHTCYAN_EX,</span>
<span class="gi">+            &quot;LIGHT-WHITE&quot;: Back.LIGHTWHITE_EX,</span>
<span class="gi">+        }</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    _regex_tag = re.compile(r&quot;\\?&lt;/?((?:[fb]g\s)?[^&lt;&gt;\s]*)&gt;&quot;)</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        self._tokens = []
<span class="w"> </span>        self._tags = []
<span class="w"> </span>        self._color_tokens = []

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def strip(tokens):</span>
<span class="gi">+        output = &quot;&quot;</span>
<span class="gi">+        for type_, value in tokens:</span>
<span class="gi">+            if type_ == TokenType.TEXT:</span>
<span class="gi">+                output += value</span>
<span class="gi">+        return output</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def colorize(tokens, ansi_level):</span>
<span class="gi">+        output = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        for type_, value in tokens:</span>
<span class="gi">+            if type_ == TokenType.LEVEL:</span>
<span class="gi">+                if ansi_level is None:</span>
<span class="gi">+                    raise ValueError(</span>
<span class="gi">+                        &quot;The &#39;&lt;level&gt;&#39; color tag is not allowed in this context, &quot;</span>
<span class="gi">+                        &quot;it has not yet been associated to any color value.&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+                value = ansi_level</span>
<span class="gi">+            output += value</span>
<span class="gi">+</span>
<span class="gi">+        return output</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def wrap(tokens, *, ansi_level, color_tokens):</span>
<span class="gi">+        output = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        for type_, value in tokens:</span>
<span class="gi">+            if type_ == TokenType.LEVEL:</span>
<span class="gi">+                value = ansi_level</span>
<span class="gi">+            output += value</span>
<span class="gi">+            if type_ == TokenType.CLOSING:</span>
<span class="gi">+                for subtype, subvalue in color_tokens:</span>
<span class="gi">+                    if subtype == TokenType.LEVEL:</span>
<span class="gi">+                        subvalue = ansi_level</span>
<span class="gi">+                    output += subvalue</span>
<span class="gi">+</span>
<span class="gi">+        return output</span>
<span class="gi">+</span>
<span class="gi">+    def feed(self, text, *, raw=False):</span>
<span class="gi">+        if raw:</span>
<span class="gi">+            self._tokens.append((TokenType.TEXT, text))</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        position = 0</span>
<span class="gi">+</span>
<span class="gi">+        for match in self._regex_tag.finditer(text):</span>
<span class="gi">+            markup, tag = match.group(0), match.group(1)</span>
<span class="gi">+</span>
<span class="gi">+            self._tokens.append((TokenType.TEXT, text[position : match.start()]))</span>
<span class="gi">+</span>
<span class="gi">+            position = match.end()</span>
<span class="gi">+</span>
<span class="gi">+            if markup[0] == &quot;\\&quot;:</span>
<span class="gi">+                self._tokens.append((TokenType.TEXT, markup[1:]))</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if markup[1] == &quot;/&quot;:</span>
<span class="gi">+                if self._tags and (tag == &quot;&quot; or tag == self._tags[-1]):</span>
<span class="gi">+                    self._tags.pop()</span>
<span class="gi">+                    self._color_tokens.pop()</span>
<span class="gi">+                    self._tokens.append((TokenType.CLOSING, &quot;\033[0m&quot;))</span>
<span class="gi">+                    self._tokens.extend(self._color_tokens)</span>
<span class="gi">+                    continue</span>
<span class="gi">+                elif tag in self._tags:</span>
<span class="gi">+                    raise ValueError(&#39;Closing tag &quot;%s&quot; violates nesting rules&#39; % markup)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise ValueError(&#39;Closing tag &quot;%s&quot; has no corresponding opening tag&#39; % markup)</span>
<span class="gi">+</span>
<span class="gi">+            if tag in {&quot;lvl&quot;, &quot;level&quot;}:</span>
<span class="gi">+                token = (TokenType.LEVEL, None)</span>
<span class="gi">+            else:</span>
<span class="gi">+                ansi = self._get_ansicode(tag)</span>
<span class="gi">+</span>
<span class="gi">+                if ansi is None:</span>
<span class="gi">+                    raise ValueError(</span>
<span class="gi">+                        &#39;Tag &quot;%s&quot; does not correspond to any known color directive, &#39;</span>
<span class="gi">+                        &quot;make sure you did not misspelled it (or prepend &#39;\\&#39; to escape it)&quot;</span>
<span class="gi">+                        % markup</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+                token = (TokenType.ANSI, ansi)</span>
<span class="gi">+</span>
<span class="gi">+            self._tags.append(tag)</span>
<span class="gi">+            self._color_tokens.append(token)</span>
<span class="gi">+            self._tokens.append(token)</span>
<span class="gi">+</span>
<span class="gi">+        self._tokens.append((TokenType.TEXT, text[position:]))</span>
<span class="gi">+</span>
<span class="gi">+    def done(self, *, strict=True):</span>
<span class="gi">+        if strict and self._tags:</span>
<span class="gi">+            faulty_tag = self._tags.pop(0)</span>
<span class="gi">+            raise ValueError(&#39;Opening tag &quot;&lt;%s&gt;&quot; has no corresponding closing tag&#39; % faulty_tag)</span>
<span class="gi">+        return self._tokens</span>
<span class="gi">+</span>
<span class="gi">+    def current_color_tokens(self):</span>
<span class="gi">+        return list(self._color_tokens)</span>
<span class="gi">+</span>
<span class="gi">+    def _get_ansicode(self, tag):</span>
<span class="gi">+        style = self._style</span>
<span class="gi">+        foreground = self._foreground</span>
<span class="gi">+        background = self._background</span>
<span class="gi">+</span>
<span class="gi">+        # Substitute on a direct match.</span>
<span class="gi">+        if tag in style:</span>
<span class="gi">+            return style[tag]</span>
<span class="gi">+        elif tag in foreground:</span>
<span class="gi">+            return foreground[tag]</span>
<span class="gi">+        elif tag in background:</span>
<span class="gi">+            return background[tag]</span>
<span class="gi">+</span>
<span class="gi">+        # An alternative syntax for setting the color (e.g. &lt;fg red&gt;, &lt;bg red&gt;).</span>
<span class="gi">+        elif tag.startswith(&quot;fg &quot;) or tag.startswith(&quot;bg &quot;):</span>
<span class="gi">+            st, color = tag[:2], tag[3:]</span>
<span class="gi">+            code = &quot;38&quot; if st == &quot;fg&quot; else &quot;48&quot;</span>
<span class="gi">+</span>
<span class="gi">+            if st == &quot;fg&quot; and color.lower() in foreground:</span>
<span class="gi">+                return foreground[color.lower()]</span>
<span class="gi">+            elif st == &quot;bg&quot; and color.upper() in background:</span>
<span class="gi">+                return background[color.upper()]</span>
<span class="gi">+            elif color.isdigit() and int(color) &lt;= 255:</span>
<span class="gi">+                return &quot;\033[%s;5;%sm&quot; % (code, color)</span>
<span class="gi">+            elif re.match(r&quot;#(?:[a-fA-F0-9]{3}){1,2}$&quot;, color):</span>
<span class="gi">+                hex_color = color[1:]</span>
<span class="gi">+                if len(hex_color) == 3:</span>
<span class="gi">+                    hex_color *= 2</span>
<span class="gi">+                rgb = tuple(int(hex_color[i : i + 2], 16) for i in (0, 2, 4))</span>
<span class="gi">+                return &quot;\033[%s;2;%s;%s;%sm&quot; % ((code,) + rgb)</span>
<span class="gi">+            elif color.count(&quot;,&quot;) == 2:</span>
<span class="gi">+                colors = tuple(color.split(&quot;,&quot;))</span>
<span class="gi">+                if all(x.isdigit() and int(x) &lt;= 255 for x in colors):</span>
<span class="gi">+                    return &quot;\033[%s;2;%s;%s;%sm&quot; % ((code,) + colors)</span>
<span class="gi">+</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>

<span class="w"> </span>class ColoringMessage(str):
<span class="gd">-    __fields__ = &#39;_messages&#39;,</span>
<span class="gi">+    __fields__ = (&quot;_messages&quot;,)</span>

<span class="w"> </span>    def __format__(self, spec):
<span class="w"> </span>        return next(self._messages).__format__(spec)


<span class="w"> </span>class ColoredMessage:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, tokens):
<span class="w"> </span>        self.tokens = tokens
<span class="w"> </span>        self.stripped = AnsiParser.strip(tokens)

<span class="gi">+    def colorize(self, ansi_level):</span>
<span class="gi">+        return AnsiParser.colorize(self.tokens, ansi_level)</span>

<span class="gd">-class ColoredFormat:</span>

<span class="gi">+class ColoredFormat:</span>
<span class="w"> </span>    def __init__(self, tokens, messages_color_tokens):
<span class="w"> </span>        self._tokens = tokens
<span class="w"> </span>        self._messages_color_tokens = messages_color_tokens

<span class="gi">+    def strip(self):</span>
<span class="gi">+        return AnsiParser.strip(self._tokens)</span>
<span class="gi">+</span>
<span class="gi">+    def colorize(self, ansi_level):</span>
<span class="gi">+        return AnsiParser.colorize(self._tokens, ansi_level)</span>
<span class="gi">+</span>
<span class="gi">+    def make_coloring_message(self, message, *, ansi_level, colored_message):</span>
<span class="gi">+        messages = [</span>
<span class="gi">+            message</span>
<span class="gi">+            if color_tokens is None</span>
<span class="gi">+            else AnsiParser.wrap(</span>
<span class="gi">+                colored_message.tokens, ansi_level=ansi_level, color_tokens=color_tokens</span>
<span class="gi">+            )</span>
<span class="gi">+            for color_tokens in self._messages_color_tokens</span>
<span class="gi">+        ]</span>
<span class="gi">+        coloring = ColoringMessage(message)</span>
<span class="gi">+        coloring._messages = iter(messages)</span>
<span class="gi">+        return coloring</span>
<span class="gi">+</span>

<span class="w"> </span>class Colorizer:
<span class="gd">-    pass</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def prepare_format(string):</span>
<span class="gi">+        tokens, messages_color_tokens = Colorizer._parse_without_formatting(string)</span>
<span class="gi">+        return ColoredFormat(tokens, messages_color_tokens)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def prepare_message(string, args=(), kwargs={}):  # noqa: B006</span>
<span class="gi">+        tokens = Colorizer._parse_with_formatting(string, args, kwargs)</span>
<span class="gi">+        return ColoredMessage(tokens)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def prepare_simple_message(string):</span>
<span class="gi">+        parser = AnsiParser()</span>
<span class="gi">+        parser.feed(string)</span>
<span class="gi">+        tokens = parser.done()</span>
<span class="gi">+        return ColoredMessage(tokens)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def ansify(text):</span>
<span class="gi">+        parser = AnsiParser()</span>
<span class="gi">+        parser.feed(text.strip())</span>
<span class="gi">+        tokens = parser.done(strict=False)</span>
<span class="gi">+        return AnsiParser.colorize(tokens, None)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _parse_with_formatting(</span>
<span class="gi">+        string, args, kwargs, *, recursion_depth=2, auto_arg_index=0, recursive=False</span>
<span class="gi">+    ):</span>
<span class="gi">+        # This function re-implements Formatter._vformat()</span>
<span class="gi">+</span>
<span class="gi">+        if recursion_depth &lt; 0:</span>
<span class="gi">+            raise ValueError(&quot;Max string recursion exceeded&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        formatter = Formatter()</span>
<span class="gi">+        parser = AnsiParser()</span>
<span class="gi">+</span>
<span class="gi">+        for literal_text, field_name, format_spec, conversion in formatter.parse(string):</span>
<span class="gi">+            parser.feed(literal_text, raw=recursive)</span>
<span class="gi">+</span>
<span class="gi">+            if field_name is not None:</span>
<span class="gi">+                if field_name == &quot;&quot;:</span>
<span class="gi">+                    if auto_arg_index is False:</span>
<span class="gi">+                        raise ValueError(</span>
<span class="gi">+                            &quot;cannot switch from manual field &quot;</span>
<span class="gi">+                            &quot;specification to automatic field &quot;</span>
<span class="gi">+                            &quot;numbering&quot;</span>
<span class="gi">+                        )</span>
<span class="gi">+                    field_name = str(auto_arg_index)</span>
<span class="gi">+                    auto_arg_index += 1</span>
<span class="gi">+                elif field_name.isdigit():</span>
<span class="gi">+                    if auto_arg_index:</span>
<span class="gi">+                        raise ValueError(</span>
<span class="gi">+                            &quot;cannot switch from manual field &quot;</span>
<span class="gi">+                            &quot;specification to automatic field &quot;</span>
<span class="gi">+                            &quot;numbering&quot;</span>
<span class="gi">+                        )</span>
<span class="gi">+                    auto_arg_index = False</span>
<span class="gi">+</span>
<span class="gi">+                obj, _ = formatter.get_field(field_name, args, kwargs)</span>
<span class="gi">+                obj = formatter.convert_field(obj, conversion)</span>
<span class="gi">+</span>
<span class="gi">+                format_spec, auto_arg_index = Colorizer._parse_with_formatting(</span>
<span class="gi">+                    format_spec,</span>
<span class="gi">+                    args,</span>
<span class="gi">+                    kwargs,</span>
<span class="gi">+                    recursion_depth=recursion_depth - 1,</span>
<span class="gi">+                    auto_arg_index=auto_arg_index,</span>
<span class="gi">+                    recursive=True,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                formatted = formatter.format_field(obj, format_spec)</span>
<span class="gi">+                parser.feed(formatted, raw=True)</span>
<span class="gi">+</span>
<span class="gi">+        tokens = parser.done()</span>
<span class="gi">+</span>
<span class="gi">+        if recursive:</span>
<span class="gi">+            return AnsiParser.strip(tokens), auto_arg_index</span>
<span class="gi">+</span>
<span class="gi">+        return tokens</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _parse_without_formatting(string, *, recursion_depth=2, recursive=False):</span>
<span class="gi">+        if recursion_depth &lt; 0:</span>
<span class="gi">+            raise ValueError(&quot;Max string recursion exceeded&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        formatter = Formatter()</span>
<span class="gi">+        parser = AnsiParser()</span>
<span class="gi">+</span>
<span class="gi">+        messages_color_tokens = []</span>
<span class="gi">+</span>
<span class="gi">+        for literal_text, field_name, format_spec, conversion in formatter.parse(string):</span>
<span class="gi">+            if literal_text and literal_text[-1] in &quot;{}&quot;:</span>
<span class="gi">+                literal_text += literal_text[-1]</span>
<span class="gi">+</span>
<span class="gi">+            parser.feed(literal_text, raw=recursive)</span>
<span class="gi">+</span>
<span class="gi">+            if field_name is not None:</span>
<span class="gi">+                if field_name == &quot;message&quot;:</span>
<span class="gi">+                    if recursive:</span>
<span class="gi">+                        messages_color_tokens.append(None)</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        color_tokens = parser.current_color_tokens()</span>
<span class="gi">+                        messages_color_tokens.append(color_tokens)</span>
<span class="gi">+                field = &quot;{%s&quot; % field_name</span>
<span class="gi">+                if conversion:</span>
<span class="gi">+                    field += &quot;!%s&quot; % conversion</span>
<span class="gi">+                if format_spec:</span>
<span class="gi">+                    field += &quot;:%s&quot; % format_spec</span>
<span class="gi">+                field += &quot;}&quot;</span>
<span class="gi">+                parser.feed(field, raw=True)</span>
<span class="gi">+</span>
<span class="gi">+                _, color_tokens = Colorizer._parse_without_formatting(</span>
<span class="gi">+                    format_spec, recursion_depth=recursion_depth - 1, recursive=True</span>
<span class="gi">+                )</span>
<span class="gi">+                messages_color_tokens.extend(color_tokens)</span>
<span class="gi">+</span>
<span class="gi">+        return parser.done(), messages_color_tokens</span>
<span class="gh">diff --git a/loguru/_contextvars.py b/loguru/_contextvars.py</span>
<span class="gh">index 69d6932..2e8bbb2 100644</span>
<span class="gd">--- a/loguru/_contextvars.py</span>
<span class="gi">+++ b/loguru/_contextvars.py</span>
<span class="gu">@@ -1,2 +1,15 @@</span>
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def load_contextvar_class():</span>
<span class="gi">+    if sys.version_info &gt;= (3, 7):</span>
<span class="gi">+        from contextvars import ContextVar</span>
<span class="gi">+    elif sys.version_info &gt;= (3, 5, 3):</span>
<span class="gi">+        from aiocontextvars import ContextVar</span>
<span class="gi">+    else:</span>
<span class="gi">+        from contextvars import ContextVar</span>
<span class="gi">+</span>
<span class="gi">+    return ContextVar</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>ContextVar = load_contextvar_class()
<span class="gh">diff --git a/loguru/_ctime_functions.py b/loguru/_ctime_functions.py</span>
<span class="gh">index 0e6aed3..e232b42 100644</span>
<span class="gd">--- a/loguru/_ctime_functions.py</span>
<span class="gi">+++ b/loguru/_ctime_functions.py</span>
<span class="gu">@@ -1,2 +1,57 @@</span>
<span class="w"> </span>import os
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def load_ctime_functions():</span>
<span class="gi">+    if os.name == &quot;nt&quot;:</span>
<span class="gi">+        import win32_setctime</span>
<span class="gi">+</span>
<span class="gi">+        def get_ctime_windows(filepath):</span>
<span class="gi">+            return os.stat(filepath).st_ctime</span>
<span class="gi">+</span>
<span class="gi">+        def set_ctime_windows(filepath, timestamp):</span>
<span class="gi">+            if not win32_setctime.SUPPORTED:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                win32_setctime.setctime(filepath, timestamp)</span>
<span class="gi">+            except (OSError, ValueError):</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+        return get_ctime_windows, set_ctime_windows</span>
<span class="gi">+</span>
<span class="gi">+    elif hasattr(os.stat_result, &quot;st_birthtime&quot;):</span>
<span class="gi">+</span>
<span class="gi">+        def get_ctime_macos(filepath):</span>
<span class="gi">+            return os.stat(filepath).st_birthtime</span>
<span class="gi">+</span>
<span class="gi">+        def set_ctime_macos(filepath, timestamp):</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+        return get_ctime_macos, set_ctime_macos</span>
<span class="gi">+</span>
<span class="gi">+    elif hasattr(os, &quot;getxattr&quot;) and hasattr(os, &quot;setxattr&quot;):</span>
<span class="gi">+</span>
<span class="gi">+        def get_ctime_linux(filepath):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return float(os.getxattr(filepath, b&quot;user.loguru_crtime&quot;))</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                return os.stat(filepath).st_mtime</span>
<span class="gi">+</span>
<span class="gi">+        def set_ctime_linux(filepath, timestamp):</span>
<span class="gi">+            try:</span>
<span class="gi">+                os.setxattr(filepath, b&quot;user.loguru_crtime&quot;, str(timestamp).encode(&quot;ascii&quot;))</span>
<span class="gi">+            except OSError:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+        return get_ctime_linux, set_ctime_linux</span>
<span class="gi">+</span>
<span class="gi">+    def get_ctime_fallback(filepath):</span>
<span class="gi">+        return os.stat(filepath).st_mtime</span>
<span class="gi">+</span>
<span class="gi">+    def set_ctime_fallback(filepath, timestamp):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    return get_ctime_fallback, set_ctime_fallback</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>get_ctime, set_ctime = load_ctime_functions()
<span class="gh">diff --git a/loguru/_datetime.py b/loguru/_datetime.py</span>
<span class="gh">index 754c834..76626db 100644</span>
<span class="gd">--- a/loguru/_datetime.py</span>
<span class="gi">+++ b/loguru/_datetime.py</span>
<span class="gu">@@ -3,58 +3,103 @@ from calendar import day_abbr, day_name, month_abbr, month_name</span>
<span class="w"> </span>from datetime import datetime as datetime_
<span class="w"> </span>from datetime import timedelta, timezone
<span class="w"> </span>from time import localtime, strftime
<span class="gd">-tokens = (</span>
<span class="gd">-    &#39;H{1,2}|h{1,2}|m{1,2}|s{1,2}|S+|YYYY|YY|M{1,4}|D{1,4}|Z{1,2}|zz|A|X|x|E|Q|dddd|ddd|d&#39;</span>
<span class="gd">-    )</span>
<span class="gd">-pattern = re.compile(&#39;(?:{0})|\\[(?:{0}|!UTC|)\\]&#39;.format(tokens))</span>

<span class="gi">+tokens = r&quot;H{1,2}|h{1,2}|m{1,2}|s{1,2}|S+|YYYY|YY|M{1,4}|D{1,4}|Z{1,2}|zz|A|X|x|E|Q|dddd|ddd|d&quot;</span>

<span class="gd">-class datetime(datetime_):</span>
<span class="gi">+pattern = re.compile(r&quot;(?:{0})|\[(?:{0}|!UTC|)\]&quot;.format(tokens))</span>

<span class="gi">+</span>
<span class="gi">+class datetime(datetime_):  # noqa: N801</span>
<span class="w"> </span>    def __format__(self, spec):
<span class="gd">-        if spec.endswith(&#39;!UTC&#39;):</span>
<span class="gi">+        if spec.endswith(&quot;!UTC&quot;):</span>
<span class="w"> </span>            dt = self.astimezone(timezone.utc)
<span class="w"> </span>            spec = spec[:-4]
<span class="w"> </span>        else:
<span class="w"> </span>            dt = self
<span class="gi">+</span>
<span class="w"> </span>        if not spec:
<span class="gd">-            spec = &#39;%Y-%m-%dT%H:%M:%S.%f%z&#39;</span>
<span class="gd">-        if &#39;%&#39; in spec:</span>
<span class="gi">+            spec = &quot;%Y-%m-%dT%H:%M:%S.%f%z&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;%&quot; in spec:</span>
<span class="w"> </span>            return datetime_.__format__(dt, spec)
<span class="gd">-        if &#39;SSSSSSS&#39; in spec:</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;SSSSSSS&quot; in spec:</span>
<span class="w"> </span>            raise ValueError(
<span class="gd">-                &quot;Invalid time format: the provided format string contains more than six successive &#39;S&#39; characters. This may be due to an attempt to use nanosecond precision, which is not supported.&quot;</span>
<span class="gd">-                )</span>
<span class="gd">-        year, month, day, hour, minute, second, weekday, yearday, _ = (dt.</span>
<span class="gd">-            timetuple())</span>
<span class="gi">+                &quot;Invalid time format: the provided format string contains more than six successive &quot;</span>
<span class="gi">+                &quot;&#39;S&#39; characters. This may be due to an attempt to use nanosecond precision, which &quot;</span>
<span class="gi">+                &quot;is not supported.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        year, month, day, hour, minute, second, weekday, yearday, _ = dt.timetuple()</span>
<span class="w"> </span>        microsecond = dt.microsecond
<span class="w"> </span>        timestamp = dt.timestamp()
<span class="w"> </span>        tzinfo = dt.tzinfo or timezone(timedelta(seconds=0))
<span class="w"> </span>        offset = tzinfo.utcoffset(dt).total_seconds()
<span class="gd">-        sign = (&#39;-&#39;, &#39;+&#39;)[offset &gt;= 0]</span>
<span class="gi">+        sign = (&quot;-&quot;, &quot;+&quot;)[offset &gt;= 0]</span>
<span class="w"> </span>        (h, m), s = divmod(abs(offset // 60), 60), abs(offset) % 60
<span class="gd">-        rep = {&#39;YYYY&#39;: &#39;%04d&#39; % year, &#39;YY&#39;: &#39;%02d&#39; % (year % 100), &#39;Q&#39;: </span>
<span class="gd">-            &#39;%d&#39; % ((month - 1) // 3 + 1), &#39;MMMM&#39;: month_name[month], &#39;MMM&#39;:</span>
<span class="gd">-            month_abbr[month], &#39;MM&#39;: &#39;%02d&#39; % month, &#39;M&#39;: &#39;%d&#39; % month,</span>
<span class="gd">-            &#39;DDDD&#39;: &#39;%03d&#39; % yearday, &#39;DDD&#39;: &#39;%d&#39; % yearday, &#39;DD&#39;: &#39;%02d&#39; %</span>
<span class="gd">-            day, &#39;D&#39;: &#39;%d&#39; % day, &#39;dddd&#39;: day_name[weekday], &#39;ddd&#39;:</span>
<span class="gd">-            day_abbr[weekday], &#39;d&#39;: &#39;%d&#39; % weekday, &#39;E&#39;: &#39;%d&#39; % (weekday + </span>
<span class="gd">-            1), &#39;HH&#39;: &#39;%02d&#39; % hour, &#39;H&#39;: &#39;%d&#39; % hour, &#39;hh&#39;: &#39;%02d&#39; % ((</span>
<span class="gd">-            hour - 1) % 12 + 1), &#39;h&#39;: &#39;%d&#39; % ((hour - 1) % 12 + 1), &#39;mm&#39;: </span>
<span class="gd">-            &#39;%02d&#39; % minute, &#39;m&#39;: &#39;%d&#39; % minute, &#39;ss&#39;: &#39;%02d&#39; % second, &#39;s&#39;:</span>
<span class="gd">-            &#39;%d&#39; % second, &#39;S&#39;: &#39;%d&#39; % (microsecond // 100000), &#39;SS&#39;: </span>
<span class="gd">-            &#39;%02d&#39; % (microsecond // 10000), &#39;SSS&#39;: &#39;%03d&#39; % (microsecond //</span>
<span class="gd">-            1000), &#39;SSSS&#39;: &#39;%04d&#39; % (microsecond // 100), &#39;SSSSS&#39;: &#39;%05d&#39; %</span>
<span class="gd">-            (microsecond // 10), &#39;SSSSSS&#39;: &#39;%06d&#39; % microsecond, &#39;A&#39;: (&#39;AM&#39;,</span>
<span class="gd">-            &#39;PM&#39;)[hour // 12], &#39;Z&#39;: &#39;%s%02d:%02d%s&#39; % (sign, h, m, (</span>
<span class="gd">-            &#39;:%09.06f&#39; % s)[:11 if s % 1 else 3] * (s &gt; 0)), &#39;ZZ&#39;: </span>
<span class="gd">-            &#39;%s%02d%02d%s&#39; % (sign, h, m, (&#39;%09.06f&#39; % s)[:10 if s % 1 else</span>
<span class="gd">-            2] * (s &gt; 0)), &#39;zz&#39;: tzinfo.tzname(dt) or &#39;&#39;, &#39;X&#39;: &#39;%d&#39; %</span>
<span class="gd">-            timestamp, &#39;x&#39;: &#39;%d&#39; % (int(timestamp) * 1000000 + microsecond)}</span>
<span class="gi">+</span>
<span class="gi">+        rep = {</span>
<span class="gi">+            &quot;YYYY&quot;: &quot;%04d&quot; % year,</span>
<span class="gi">+            &quot;YY&quot;: &quot;%02d&quot; % (year % 100),</span>
<span class="gi">+            &quot;Q&quot;: &quot;%d&quot; % ((month - 1) // 3 + 1),</span>
<span class="gi">+            &quot;MMMM&quot;: month_name[month],</span>
<span class="gi">+            &quot;MMM&quot;: month_abbr[month],</span>
<span class="gi">+            &quot;MM&quot;: &quot;%02d&quot; % month,</span>
<span class="gi">+            &quot;M&quot;: &quot;%d&quot; % month,</span>
<span class="gi">+            &quot;DDDD&quot;: &quot;%03d&quot; % yearday,</span>
<span class="gi">+            &quot;DDD&quot;: &quot;%d&quot; % yearday,</span>
<span class="gi">+            &quot;DD&quot;: &quot;%02d&quot; % day,</span>
<span class="gi">+            &quot;D&quot;: &quot;%d&quot; % day,</span>
<span class="gi">+            &quot;dddd&quot;: day_name[weekday],</span>
<span class="gi">+            &quot;ddd&quot;: day_abbr[weekday],</span>
<span class="gi">+            &quot;d&quot;: &quot;%d&quot; % weekday,</span>
<span class="gi">+            &quot;E&quot;: &quot;%d&quot; % (weekday + 1),</span>
<span class="gi">+            &quot;HH&quot;: &quot;%02d&quot; % hour,</span>
<span class="gi">+            &quot;H&quot;: &quot;%d&quot; % hour,</span>
<span class="gi">+            &quot;hh&quot;: &quot;%02d&quot; % ((hour - 1) % 12 + 1),</span>
<span class="gi">+            &quot;h&quot;: &quot;%d&quot; % ((hour - 1) % 12 + 1),</span>
<span class="gi">+            &quot;mm&quot;: &quot;%02d&quot; % minute,</span>
<span class="gi">+            &quot;m&quot;: &quot;%d&quot; % minute,</span>
<span class="gi">+            &quot;ss&quot;: &quot;%02d&quot; % second,</span>
<span class="gi">+            &quot;s&quot;: &quot;%d&quot; % second,</span>
<span class="gi">+            &quot;S&quot;: &quot;%d&quot; % (microsecond // 100000),</span>
<span class="gi">+            &quot;SS&quot;: &quot;%02d&quot; % (microsecond // 10000),</span>
<span class="gi">+            &quot;SSS&quot;: &quot;%03d&quot; % (microsecond // 1000),</span>
<span class="gi">+            &quot;SSSS&quot;: &quot;%04d&quot; % (microsecond // 100),</span>
<span class="gi">+            &quot;SSSSS&quot;: &quot;%05d&quot; % (microsecond // 10),</span>
<span class="gi">+            &quot;SSSSSS&quot;: &quot;%06d&quot; % microsecond,</span>
<span class="gi">+            &quot;A&quot;: (&quot;AM&quot;, &quot;PM&quot;)[hour // 12],</span>
<span class="gi">+            &quot;Z&quot;: &quot;%s%02d:%02d%s&quot; % (sign, h, m, (&quot;:%09.06f&quot; % s)[: 11 if s % 1 else 3] * (s &gt; 0)),</span>
<span class="gi">+            &quot;ZZ&quot;: &quot;%s%02d%02d%s&quot; % (sign, h, m, (&quot;%09.06f&quot; % s)[: 10 if s % 1 else 2] * (s &gt; 0)),</span>
<span class="gi">+            &quot;zz&quot;: tzinfo.tzname(dt) or &quot;&quot;,</span>
<span class="gi">+            &quot;X&quot;: &quot;%d&quot; % timestamp,</span>
<span class="gi">+            &quot;x&quot;: &quot;%d&quot; % (int(timestamp) * 1000000 + microsecond),</span>
<span class="gi">+        }</span>

<span class="w"> </span>        def get(m):
<span class="w"> </span>            try:
<span class="w"> </span>                return rep[m.group(0)]
<span class="w"> </span>            except KeyError:
<span class="w"> </span>                return m.group(0)[1:-1]
<span class="gi">+</span>
<span class="w"> </span>        return pattern.sub(get, spec)
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def aware_now():</span>
<span class="gi">+    now = datetime_.now()</span>
<span class="gi">+    timestamp = now.timestamp()</span>
<span class="gi">+    local = localtime(timestamp)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        seconds = local.tm_gmtoff</span>
<span class="gi">+        zone = local.tm_zone</span>
<span class="gi">+    except AttributeError:</span>
<span class="gi">+        # Workaround for Python 3.5.</span>
<span class="gi">+        utc_naive = datetime_.fromtimestamp(timestamp, tz=timezone.utc).replace(tzinfo=None)</span>
<span class="gi">+        offset = datetime_.fromtimestamp(timestamp) - utc_naive</span>
<span class="gi">+        seconds = offset.total_seconds()</span>
<span class="gi">+        zone = strftime(&quot;%Z&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    tzinfo = timezone(timedelta(seconds=seconds), zone)</span>
<span class="gi">+</span>
<span class="gi">+    return datetime.combine(now.date(), now.time().replace(tzinfo=tzinfo))</span>
<span class="gh">diff --git a/loguru/_defaults.py b/loguru/_defaults.py</span>
<span class="gh">index 2e33c3d..d3d8de7 100644</span>
<span class="gd">--- a/loguru/_defaults.py</span>
<span class="gi">+++ b/loguru/_defaults.py</span>
<span class="gu">@@ -1,35 +1,74 @@</span>
<span class="w"> </span>from os import environ
<span class="gd">-LOGURU_AUTOINIT = env(&#39;LOGURU_AUTOINIT&#39;, bool, True)</span>
<span class="gd">-LOGURU_FORMAT = env(&#39;LOGURU_FORMAT&#39;, str,</span>
<span class="gd">-    &#39;&lt;green&gt;{time:YYYY-MM-DD HH:mm:ss.SSS}&lt;/green&gt; | &lt;level&gt;{level: &lt;8}&lt;/level&gt; | &lt;cyan&gt;{name}&lt;/cyan&gt;:&lt;cyan&gt;{function}&lt;/cyan&gt;:&lt;cyan&gt;{line}&lt;/cyan&gt; - &lt;level&gt;{message}&lt;/level&gt;&#39;</span>
<span class="gd">-    )</span>
<span class="gd">-LOGURU_FILTER = env(&#39;LOGURU_FILTER&#39;, str, None)</span>
<span class="gd">-LOGURU_LEVEL = env(&#39;LOGURU_LEVEL&#39;, str, &#39;DEBUG&#39;)</span>
<span class="gd">-LOGURU_COLORIZE = env(&#39;LOGURU_COLORIZE&#39;, bool, None)</span>
<span class="gd">-LOGURU_SERIALIZE = env(&#39;LOGURU_SERIALIZE&#39;, bool, False)</span>
<span class="gd">-LOGURU_BACKTRACE = env(&#39;LOGURU_BACKTRACE&#39;, bool, True)</span>
<span class="gd">-LOGURU_DIAGNOSE = env(&#39;LOGURU_DIAGNOSE&#39;, bool, True)</span>
<span class="gd">-LOGURU_ENQUEUE = env(&#39;LOGURU_ENQUEUE&#39;, bool, False)</span>
<span class="gd">-LOGURU_CONTEXT = env(&#39;LOGURU_CONTEXT&#39;, str, None)</span>
<span class="gd">-LOGURU_CATCH = env(&#39;LOGURU_CATCH&#39;, bool, True)</span>
<span class="gd">-LOGURU_TRACE_NO = env(&#39;LOGURU_TRACE_NO&#39;, int, 5)</span>
<span class="gd">-LOGURU_TRACE_COLOR = env(&#39;LOGURU_TRACE_COLOR&#39;, str, &#39;&lt;cyan&gt;&lt;bold&gt;&#39;)</span>
<span class="gd">-LOGURU_TRACE_ICON = env(&#39;LOGURU_TRACE_ICON&#39;, str, &#39;✏️&#39;)</span>
<span class="gd">-LOGURU_DEBUG_NO = env(&#39;LOGURU_DEBUG_NO&#39;, int, 10)</span>
<span class="gd">-LOGURU_DEBUG_COLOR = env(&#39;LOGURU_DEBUG_COLOR&#39;, str, &#39;&lt;blue&gt;&lt;bold&gt;&#39;)</span>
<span class="gd">-LOGURU_DEBUG_ICON = env(&#39;LOGURU_DEBUG_ICON&#39;, str, &#39;🐞&#39;)</span>
<span class="gd">-LOGURU_INFO_NO = env(&#39;LOGURU_INFO_NO&#39;, int, 20)</span>
<span class="gd">-LOGURU_INFO_COLOR = env(&#39;LOGURU_INFO_COLOR&#39;, str, &#39;&lt;bold&gt;&#39;)</span>
<span class="gd">-LOGURU_INFO_ICON = env(&#39;LOGURU_INFO_ICON&#39;, str, &#39;ℹ️&#39;)</span>
<span class="gd">-LOGURU_SUCCESS_NO = env(&#39;LOGURU_SUCCESS_NO&#39;, int, 25)</span>
<span class="gd">-LOGURU_SUCCESS_COLOR = env(&#39;LOGURU_SUCCESS_COLOR&#39;, str, &#39;&lt;green&gt;&lt;bold&gt;&#39;)</span>
<span class="gd">-LOGURU_SUCCESS_ICON = env(&#39;LOGURU_SUCCESS_ICON&#39;, str, &#39;✅&#39;)</span>
<span class="gd">-LOGURU_WARNING_NO = env(&#39;LOGURU_WARNING_NO&#39;, int, 30)</span>
<span class="gd">-LOGURU_WARNING_COLOR = env(&#39;LOGURU_WARNING_COLOR&#39;, str, &#39;&lt;yellow&gt;&lt;bold&gt;&#39;)</span>
<span class="gd">-LOGURU_WARNING_ICON = env(&#39;LOGURU_WARNING_ICON&#39;, str, &#39;⚠️&#39;)</span>
<span class="gd">-LOGURU_ERROR_NO = env(&#39;LOGURU_ERROR_NO&#39;, int, 40)</span>
<span class="gd">-LOGURU_ERROR_COLOR = env(&#39;LOGURU_ERROR_COLOR&#39;, str, &#39;&lt;red&gt;&lt;bold&gt;&#39;)</span>
<span class="gd">-LOGURU_ERROR_ICON = env(&#39;LOGURU_ERROR_ICON&#39;, str, &#39;❌&#39;)</span>
<span class="gd">-LOGURU_CRITICAL_NO = env(&#39;LOGURU_CRITICAL_NO&#39;, int, 50)</span>
<span class="gd">-LOGURU_CRITICAL_COLOR = env(&#39;LOGURU_CRITICAL_COLOR&#39;, str, &#39;&lt;RED&gt;&lt;bold&gt;&#39;)</span>
<span class="gd">-LOGURU_CRITICAL_ICON = env(&#39;LOGURU_CRITICAL_ICON&#39;, str, &#39;☠️&#39;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def env(key, type_, default=None):</span>
<span class="gi">+    if key not in environ:</span>
<span class="gi">+        return default</span>
<span class="gi">+</span>
<span class="gi">+    val = environ[key]</span>
<span class="gi">+</span>
<span class="gi">+    if type_ == str:</span>
<span class="gi">+        return val</span>
<span class="gi">+    elif type_ == bool:</span>
<span class="gi">+        if val.lower() in [&quot;1&quot;, &quot;true&quot;, &quot;yes&quot;, &quot;y&quot;, &quot;ok&quot;, &quot;on&quot;]:</span>
<span class="gi">+            return True</span>
<span class="gi">+        if val.lower() in [&quot;0&quot;, &quot;false&quot;, &quot;no&quot;, &quot;n&quot;, &quot;nok&quot;, &quot;off&quot;]:</span>
<span class="gi">+            return False</span>
<span class="gi">+        raise ValueError(</span>
<span class="gi">+            &quot;Invalid environment variable &#39;%s&#39; (expected a boolean): &#39;%s&#39;&quot; % (key, val)</span>
<span class="gi">+        )</span>
<span class="gi">+    elif type_ == int:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return int(val)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                &quot;Invalid environment variable &#39;%s&#39; (expected an integer): &#39;%s&#39;&quot; % (key, val)</span>
<span class="gi">+            ) from None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+LOGURU_AUTOINIT = env(&quot;LOGURU_AUTOINIT&quot;, bool, True)</span>
<span class="gi">+</span>
<span class="gi">+LOGURU_FORMAT = env(</span>
<span class="gi">+    &quot;LOGURU_FORMAT&quot;,</span>
<span class="gi">+    str,</span>
<span class="gi">+    &quot;&lt;green&gt;{time:YYYY-MM-DD HH:mm:ss.SSS}&lt;/green&gt; | &quot;</span>
<span class="gi">+    &quot;&lt;level&gt;{level: &lt;8}&lt;/level&gt; | &quot;</span>
<span class="gi">+    &quot;&lt;cyan&gt;{name}&lt;/cyan&gt;:&lt;cyan&gt;{function}&lt;/cyan&gt;:&lt;cyan&gt;{line}&lt;/cyan&gt; - &lt;level&gt;{message}&lt;/level&gt;&quot;,</span>
<span class="gi">+)</span>
<span class="gi">+LOGURU_FILTER = env(&quot;LOGURU_FILTER&quot;, str, None)</span>
<span class="gi">+LOGURU_LEVEL = env(&quot;LOGURU_LEVEL&quot;, str, &quot;DEBUG&quot;)</span>
<span class="gi">+LOGURU_COLORIZE = env(&quot;LOGURU_COLORIZE&quot;, bool, None)</span>
<span class="gi">+LOGURU_SERIALIZE = env(&quot;LOGURU_SERIALIZE&quot;, bool, False)</span>
<span class="gi">+LOGURU_BACKTRACE = env(&quot;LOGURU_BACKTRACE&quot;, bool, True)</span>
<span class="gi">+LOGURU_DIAGNOSE = env(&quot;LOGURU_DIAGNOSE&quot;, bool, True)</span>
<span class="gi">+LOGURU_ENQUEUE = env(&quot;LOGURU_ENQUEUE&quot;, bool, False)</span>
<span class="gi">+LOGURU_CONTEXT = env(&quot;LOGURU_CONTEXT&quot;, str, None)</span>
<span class="gi">+LOGURU_CATCH = env(&quot;LOGURU_CATCH&quot;, bool, True)</span>
<span class="gi">+</span>
<span class="gi">+LOGURU_TRACE_NO = env(&quot;LOGURU_TRACE_NO&quot;, int, 5)</span>
<span class="gi">+LOGURU_TRACE_COLOR = env(&quot;LOGURU_TRACE_COLOR&quot;, str, &quot;&lt;cyan&gt;&lt;bold&gt;&quot;)</span>
<span class="gi">+LOGURU_TRACE_ICON = env(&quot;LOGURU_TRACE_ICON&quot;, str, &quot;\u270F\uFE0F&quot;)  # Pencil</span>
<span class="gi">+</span>
<span class="gi">+LOGURU_DEBUG_NO = env(&quot;LOGURU_DEBUG_NO&quot;, int, 10)</span>
<span class="gi">+LOGURU_DEBUG_COLOR = env(&quot;LOGURU_DEBUG_COLOR&quot;, str, &quot;&lt;blue&gt;&lt;bold&gt;&quot;)</span>
<span class="gi">+LOGURU_DEBUG_ICON = env(&quot;LOGURU_DEBUG_ICON&quot;, str, &quot;\U0001F41E&quot;)  # Lady Beetle</span>
<span class="gi">+</span>
<span class="gi">+LOGURU_INFO_NO = env(&quot;LOGURU_INFO_NO&quot;, int, 20)</span>
<span class="gi">+LOGURU_INFO_COLOR = env(&quot;LOGURU_INFO_COLOR&quot;, str, &quot;&lt;bold&gt;&quot;)</span>
<span class="gi">+LOGURU_INFO_ICON = env(&quot;LOGURU_INFO_ICON&quot;, str, &quot;\u2139\uFE0F&quot;)  # Information</span>
<span class="gi">+</span>
<span class="gi">+LOGURU_SUCCESS_NO = env(&quot;LOGURU_SUCCESS_NO&quot;, int, 25)</span>
<span class="gi">+LOGURU_SUCCESS_COLOR = env(&quot;LOGURU_SUCCESS_COLOR&quot;, str, &quot;&lt;green&gt;&lt;bold&gt;&quot;)</span>
<span class="gi">+LOGURU_SUCCESS_ICON = env(&quot;LOGURU_SUCCESS_ICON&quot;, str, &quot;\u2705&quot;)  # White Heavy Check Mark</span>
<span class="gi">+</span>
<span class="gi">+LOGURU_WARNING_NO = env(&quot;LOGURU_WARNING_NO&quot;, int, 30)</span>
<span class="gi">+LOGURU_WARNING_COLOR = env(&quot;LOGURU_WARNING_COLOR&quot;, str, &quot;&lt;yellow&gt;&lt;bold&gt;&quot;)</span>
<span class="gi">+LOGURU_WARNING_ICON = env(&quot;LOGURU_WARNING_ICON&quot;, str, &quot;\u26A0\uFE0F&quot;)  # Warning</span>
<span class="gi">+</span>
<span class="gi">+LOGURU_ERROR_NO = env(&quot;LOGURU_ERROR_NO&quot;, int, 40)</span>
<span class="gi">+LOGURU_ERROR_COLOR = env(&quot;LOGURU_ERROR_COLOR&quot;, str, &quot;&lt;red&gt;&lt;bold&gt;&quot;)</span>
<span class="gi">+LOGURU_ERROR_ICON = env(&quot;LOGURU_ERROR_ICON&quot;, str, &quot;\u274C&quot;)  # Cross Mark</span>
<span class="gi">+</span>
<span class="gi">+LOGURU_CRITICAL_NO = env(&quot;LOGURU_CRITICAL_NO&quot;, int, 50)</span>
<span class="gi">+LOGURU_CRITICAL_COLOR = env(&quot;LOGURU_CRITICAL_COLOR&quot;, str, &quot;&lt;RED&gt;&lt;bold&gt;&quot;)</span>
<span class="gi">+LOGURU_CRITICAL_ICON = env(&quot;LOGURU_CRITICAL_ICON&quot;, str, &quot;\u2620\uFE0F&quot;)  # Skull and Crossbones</span>
<span class="gh">diff --git a/loguru/_error_interceptor.py b/loguru/_error_interceptor.py</span>
<span class="gh">index e9758e4..9f63d3d 100644</span>
<span class="gd">--- a/loguru/_error_interceptor.py</span>
<span class="gi">+++ b/loguru/_error_interceptor.py</span>
<span class="gu">@@ -3,7 +3,32 @@ import traceback</span>


<span class="w"> </span>class ErrorInterceptor:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, should_catch, handler_id):
<span class="w"> </span>        self._should_catch = should_catch
<span class="w"> </span>        self._handler_id = handler_id
<span class="gi">+</span>
<span class="gi">+    def should_catch(self):</span>
<span class="gi">+        return self._should_catch</span>
<span class="gi">+</span>
<span class="gi">+    def print(self, record=None, *, exception=None):</span>
<span class="gi">+        if not sys.stderr:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if exception is None:</span>
<span class="gi">+            type_, value, traceback_ = sys.exc_info()</span>
<span class="gi">+        else:</span>
<span class="gi">+            type_, value, traceback_ = (type(exception), exception, exception.__traceback__)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            sys.stderr.write(&quot;--- Logging error in Loguru Handler #%d ---\n&quot; % self._handler_id)</span>
<span class="gi">+            try:</span>
<span class="gi">+                record_repr = str(record)</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                record_repr = &quot;/!\\ Unprintable record /!\\&quot;</span>
<span class="gi">+            sys.stderr.write(&quot;Record was: %s\n&quot; % record_repr)</span>
<span class="gi">+            traceback.print_exception(type_, value, traceback_, None, sys.stderr)</span>
<span class="gi">+            sys.stderr.write(&quot;--- End of logging error ---\n&quot;)</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        finally:</span>
<span class="gi">+            del type_, value, traceback_</span>
<span class="gh">diff --git a/loguru/_file_sink.py b/loguru/_file_sink.py</span>
<span class="gh">index 8053660..bdc6ccd 100644</span>
<span class="gd">--- a/loguru/_file_sink.py</span>
<span class="gi">+++ b/loguru/_file_sink.py</span>
<span class="gu">@@ -7,66 +7,146 @@ import shutil</span>
<span class="w"> </span>import string
<span class="w"> </span>from functools import partial
<span class="w"> </span>from stat import ST_DEV, ST_INO
<span class="gi">+</span>
<span class="w"> </span>from . import _string_parsers as string_parsers
<span class="w"> </span>from ._ctime_functions import get_ctime, set_ctime
<span class="w"> </span>from ._datetime import aware_now


<span class="gd">-class FileDateFormatter:</span>
<span class="gi">+def generate_rename_path(root, ext, creation_time):</span>
<span class="gi">+    creation_datetime = datetime.datetime.fromtimestamp(creation_time)</span>
<span class="gi">+    date = FileDateFormatter(creation_datetime)</span>
<span class="gi">+</span>
<span class="gi">+    renamed_path = &quot;{}.{}{}&quot;.format(root, date, ext)</span>
<span class="gi">+    counter = 1</span>
<span class="gi">+</span>
<span class="gi">+    while os.path.exists(renamed_path):</span>
<span class="gi">+        counter += 1</span>
<span class="gi">+        renamed_path = &quot;{}.{}.{}{}&quot;.format(root, date, counter, ext)</span>
<span class="gi">+</span>
<span class="gi">+    return renamed_path</span>
<span class="gi">+</span>

<span class="gi">+class FileDateFormatter:</span>
<span class="w"> </span>    def __init__(self, datetime=None):
<span class="w"> </span>        self.datetime = datetime or aware_now()

<span class="w"> </span>    def __format__(self, spec):
<span class="w"> </span>        if not spec:
<span class="gd">-            spec = &#39;%Y-%m-%d_%H-%M-%S_%f&#39;</span>
<span class="gi">+            spec = &quot;%Y-%m-%d_%H-%M-%S_%f&quot;</span>
<span class="w"> </span>        return self.datetime.__format__(spec)


<span class="w"> </span>class Compression:
<span class="gd">-    pass</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def add_compress(path_in, path_out, opener, **kwargs):</span>
<span class="gi">+        with opener(path_out, **kwargs) as f_comp:</span>
<span class="gi">+            f_comp.add(path_in, os.path.basename(path_in))</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def write_compress(path_in, path_out, opener, **kwargs):</span>
<span class="gi">+        with opener(path_out, **kwargs) as f_comp:</span>
<span class="gi">+            f_comp.write(path_in, os.path.basename(path_in))</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def copy_compress(path_in, path_out, opener, **kwargs):</span>
<span class="gi">+        with open(path_in, &quot;rb&quot;) as f_in:</span>
<span class="gi">+            with opener(path_out, **kwargs) as f_out:</span>
<span class="gi">+                shutil.copyfileobj(f_in, f_out)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def compression(path_in, ext, compress_function):</span>
<span class="gi">+        path_out = &quot;{}{}&quot;.format(path_in, ext)</span>
<span class="gi">+</span>
<span class="gi">+        if os.path.exists(path_out):</span>
<span class="gi">+            creation_time = get_ctime(path_out)</span>
<span class="gi">+            root, ext_before = os.path.splitext(path_in)</span>
<span class="gi">+            renamed_path = generate_rename_path(root, ext_before + ext, creation_time)</span>
<span class="gi">+            os.rename(path_out, renamed_path)</span>
<span class="gi">+        compress_function(path_in, path_out)</span>
<span class="gi">+        os.remove(path_in)</span>


<span class="w"> </span>class Retention:
<span class="gd">-    pass</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def retention_count(logs, number):</span>
<span class="gi">+        def key_log(log):</span>
<span class="gi">+            return (-os.stat(log).st_mtime, log)</span>
<span class="gi">+</span>
<span class="gi">+        for log in sorted(logs, key=key_log)[number:]:</span>
<span class="gi">+            os.remove(log)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def retention_age(logs, seconds):</span>
<span class="gi">+        t = datetime.datetime.now().timestamp()</span>
<span class="gi">+        for log in logs:</span>
<span class="gi">+            if os.stat(log).st_mtime &lt;= t - seconds:</span>
<span class="gi">+                os.remove(log)</span>


<span class="w"> </span>class Rotation:
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def forward_day(t):</span>
<span class="gi">+        return t + datetime.timedelta(days=1)</span>

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def forward_weekday(t, weekday):</span>
<span class="gi">+        while True:</span>
<span class="gi">+            t += datetime.timedelta(days=1)</span>
<span class="gi">+            if t.weekday() == weekday:</span>
<span class="gi">+                return t</span>

<span class="gd">-    class RotationTime:</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def forward_interval(t, interval):</span>
<span class="gi">+        return t + interval</span>

<span class="gi">+    @staticmethod</span>
<span class="gi">+    def rotation_size(message, file, size_limit):</span>
<span class="gi">+        file.seek(0, 2)</span>
<span class="gi">+        return file.tell() + len(message) &gt; size_limit</span>
<span class="gi">+</span>
<span class="gi">+    class RotationTime:</span>
<span class="w"> </span>        def __init__(self, step_forward, time_init=None):
<span class="w"> </span>            self._step_forward = step_forward
<span class="w"> </span>            self._time_init = time_init
<span class="w"> </span>            self._limit = None

<span class="w"> </span>        def __call__(self, message, file):
<span class="gd">-            record_time = message.record[&#39;time&#39;]</span>
<span class="gi">+            record_time = message.record[&quot;time&quot;]</span>
<span class="gi">+</span>
<span class="w"> </span>            if self._limit is None:
<span class="w"> </span>                filepath = os.path.realpath(file.name)
<span class="w"> </span>                creation_time = get_ctime(filepath)
<span class="w"> </span>                set_ctime(filepath, creation_time)
<span class="gd">-                start_time = datetime.datetime.fromtimestamp(creation_time,</span>
<span class="gd">-                    tz=datetime.timezone.utc)</span>
<span class="gi">+                start_time = datetime.datetime.fromtimestamp(</span>
<span class="gi">+                    creation_time, tz=datetime.timezone.utc</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="w"> </span>                time_init = self._time_init
<span class="gi">+</span>
<span class="w"> </span>                if time_init is None:
<span class="gd">-                    limit = start_time.astimezone(record_time.tzinfo).replace(</span>
<span class="gd">-                        tzinfo=None)</span>
<span class="gi">+                    limit = start_time.astimezone(record_time.tzinfo).replace(tzinfo=None)</span>
<span class="w"> </span>                    limit = self._step_forward(limit)
<span class="w"> </span>                else:
<span class="gd">-                    tzinfo = (record_time.tzinfo if time_init.tzinfo is</span>
<span class="gd">-                        None else time_init.tzinfo)</span>
<span class="gd">-                    limit = start_time.astimezone(tzinfo).replace(hour=</span>
<span class="gd">-                        time_init.hour, minute=time_init.minute, second=</span>
<span class="gd">-                        time_init.second, microsecond=time_init.microsecond)</span>
<span class="gi">+                    tzinfo = record_time.tzinfo if time_init.tzinfo is None else time_init.tzinfo</span>
<span class="gi">+                    limit = start_time.astimezone(tzinfo).replace(</span>
<span class="gi">+                        hour=time_init.hour,</span>
<span class="gi">+                        minute=time_init.minute,</span>
<span class="gi">+                        second=time_init.second,</span>
<span class="gi">+                        microsecond=time_init.microsecond,</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="w"> </span>                    if limit &lt;= start_time:
<span class="w"> </span>                        limit = self._step_forward(limit)
<span class="gi">+</span>
<span class="w"> </span>                    if time_init.tzinfo is None:
<span class="w"> </span>                        limit = limit.replace(tzinfo=None)
<span class="gi">+</span>
<span class="w"> </span>                self._limit = limit
<span class="gi">+</span>
<span class="w"> </span>            if self._limit.tzinfo is None:
<span class="w"> </span>                record_time = record_time.replace(tzinfo=None)
<span class="gi">+</span>
<span class="w"> </span>            if record_time &gt;= self._limit:
<span class="w"> </span>                while self._limit &lt;= record_time:
<span class="w"> </span>                    self._limit = self._step_forward(self._limit)
<span class="gu">@@ -75,25 +155,280 @@ class Rotation:</span>


<span class="w"> </span>class FileSink:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, path, *, rotation=None, retention=None, compression=</span>
<span class="gd">-        None, delay=False, watch=False, mode=&#39;a&#39;, buffering=1, encoding=</span>
<span class="gd">-        &#39;utf8&#39;, **kwargs):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        path,</span>
<span class="gi">+        *,</span>
<span class="gi">+        rotation=None,</span>
<span class="gi">+        retention=None,</span>
<span class="gi">+        compression=None,</span>
<span class="gi">+        delay=False,</span>
<span class="gi">+        watch=False,</span>
<span class="gi">+        mode=&quot;a&quot;,</span>
<span class="gi">+        buffering=1,</span>
<span class="gi">+        encoding=&quot;utf8&quot;,</span>
<span class="gi">+        **kwargs</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self.encoding = encoding
<span class="gd">-        self._kwargs = {**kwargs, &#39;mode&#39;: mode, &#39;buffering&#39;: buffering,</span>
<span class="gd">-            &#39;encoding&#39;: self.encoding}</span>
<span class="gi">+</span>
<span class="gi">+        self._kwargs = {**kwargs, &quot;mode&quot;: mode, &quot;buffering&quot;: buffering, &quot;encoding&quot;: self.encoding}</span>
<span class="w"> </span>        self._path = str(path)
<span class="gi">+</span>
<span class="w"> </span>        self._glob_patterns = self._make_glob_patterns(self._path)
<span class="w"> </span>        self._rotation_function = self._make_rotation_function(rotation)
<span class="w"> </span>        self._retention_function = self._make_retention_function(retention)
<span class="gd">-        self._compression_function = self._make_compression_function(</span>
<span class="gd">-            compression)</span>
<span class="gi">+        self._compression_function = self._make_compression_function(compression)</span>
<span class="gi">+</span>
<span class="w"> </span>        self._file = None
<span class="w"> </span>        self._file_path = None
<span class="gi">+</span>
<span class="w"> </span>        self._watch = watch
<span class="w"> </span>        self._file_dev = -1
<span class="w"> </span>        self._file_ino = -1
<span class="gi">+</span>
<span class="w"> </span>        if not delay:
<span class="w"> </span>            path = self._create_path()
<span class="w"> </span>            self._create_dirs(path)
<span class="w"> </span>            self._create_file(path)
<span class="gi">+</span>
<span class="gi">+    def write(self, message):</span>
<span class="gi">+        if self._file is None:</span>
<span class="gi">+            path = self._create_path()</span>
<span class="gi">+            self._create_dirs(path)</span>
<span class="gi">+            self._create_file(path)</span>
<span class="gi">+</span>
<span class="gi">+        if self._watch:</span>
<span class="gi">+            self._reopen_if_needed()</span>
<span class="gi">+</span>
<span class="gi">+        if self._rotation_function is not None and self._rotation_function(message, self._file):</span>
<span class="gi">+            self._terminate_file(is_rotating=True)</span>
<span class="gi">+</span>
<span class="gi">+        self._file.write(message)</span>
<span class="gi">+</span>
<span class="gi">+    def stop(self):</span>
<span class="gi">+        if self._watch:</span>
<span class="gi">+            self._reopen_if_needed()</span>
<span class="gi">+</span>
<span class="gi">+        self._terminate_file(is_rotating=False)</span>
<span class="gi">+</span>
<span class="gi">+    def tasks_to_complete(self):</span>
<span class="gi">+        return []</span>
<span class="gi">+</span>
<span class="gi">+    def _create_path(self):</span>
<span class="gi">+        path = self._path.format_map({&quot;time&quot;: FileDateFormatter()})</span>
<span class="gi">+        return os.path.abspath(path)</span>
<span class="gi">+</span>
<span class="gi">+    def _create_dirs(self, path):</span>
<span class="gi">+        dirname = os.path.dirname(path)</span>
<span class="gi">+        os.makedirs(dirname, exist_ok=True)</span>
<span class="gi">+</span>
<span class="gi">+    def _create_file(self, path):</span>
<span class="gi">+        self._file = open(path, **self._kwargs)</span>
<span class="gi">+        self._file_path = path</span>
<span class="gi">+</span>
<span class="gi">+        if self._watch:</span>
<span class="gi">+            fileno = self._file.fileno()</span>
<span class="gi">+            result = os.fstat(fileno)</span>
<span class="gi">+            self._file_dev = result[ST_DEV]</span>
<span class="gi">+            self._file_ino = result[ST_INO]</span>
<span class="gi">+</span>
<span class="gi">+    def _close_file(self):</span>
<span class="gi">+        self._file.flush()</span>
<span class="gi">+        self._file.close()</span>
<span class="gi">+</span>
<span class="gi">+        self._file = None</span>
<span class="gi">+        self._file_path = None</span>
<span class="gi">+        self._file_dev = -1</span>
<span class="gi">+        self._file_ino = -1</span>
<span class="gi">+</span>
<span class="gi">+    def _reopen_if_needed(self):</span>
<span class="gi">+        # Implemented based on standard library:</span>
<span class="gi">+        # https://github.com/python/cpython/blob/cb589d1b/Lib/logging/handlers.py#L486</span>
<span class="gi">+        if not self._file:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        filepath = self._file_path</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            result = os.stat(filepath)</span>
<span class="gi">+        except FileNotFoundError:</span>
<span class="gi">+            result = None</span>
<span class="gi">+</span>
<span class="gi">+        if not result or result[ST_DEV] != self._file_dev or result[ST_INO] != self._file_ino:</span>
<span class="gi">+            self._close_file()</span>
<span class="gi">+            self._create_dirs(filepath)</span>
<span class="gi">+            self._create_file(filepath)</span>
<span class="gi">+</span>
<span class="gi">+    def _terminate_file(self, *, is_rotating=False):</span>
<span class="gi">+        old_path = self._file_path</span>
<span class="gi">+</span>
<span class="gi">+        if self._file is not None:</span>
<span class="gi">+            self._close_file()</span>
<span class="gi">+</span>
<span class="gi">+        if is_rotating:</span>
<span class="gi">+            new_path = self._create_path()</span>
<span class="gi">+            self._create_dirs(new_path)</span>
<span class="gi">+</span>
<span class="gi">+            if new_path == old_path:</span>
<span class="gi">+                creation_time = get_ctime(old_path)</span>
<span class="gi">+                root, ext = os.path.splitext(old_path)</span>
<span class="gi">+                renamed_path = generate_rename_path(root, ext, creation_time)</span>
<span class="gi">+                os.rename(old_path, renamed_path)</span>
<span class="gi">+                old_path = renamed_path</span>
<span class="gi">+</span>
<span class="gi">+        if is_rotating or self._rotation_function is None:</span>
<span class="gi">+            if self._compression_function is not None and old_path is not None:</span>
<span class="gi">+                self._compression_function(old_path)</span>
<span class="gi">+</span>
<span class="gi">+            if self._retention_function is not None:</span>
<span class="gi">+                logs = {</span>
<span class="gi">+                    file</span>
<span class="gi">+                    for pattern in self._glob_patterns</span>
<span class="gi">+                    for file in glob.glob(pattern)</span>
<span class="gi">+                    if os.path.isfile(file)</span>
<span class="gi">+                }</span>
<span class="gi">+                self._retention_function(list(logs))</span>
<span class="gi">+</span>
<span class="gi">+        if is_rotating:</span>
<span class="gi">+            self._create_file(new_path)</span>
<span class="gi">+            set_ctime(new_path, datetime.datetime.now().timestamp())</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _make_glob_patterns(path):</span>
<span class="gi">+        formatter = string.Formatter()</span>
<span class="gi">+        tokens = formatter.parse(path)</span>
<span class="gi">+        escaped = &quot;&quot;.join(glob.escape(text) + &quot;*&quot; * (name is not None) for text, name, *_ in tokens)</span>
<span class="gi">+</span>
<span class="gi">+        root, ext = os.path.splitext(escaped)</span>
<span class="gi">+</span>
<span class="gi">+        if not ext:</span>
<span class="gi">+            return [escaped, escaped + &quot;.*&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        return [escaped, escaped + &quot;.*&quot;, root + &quot;.*&quot; + ext, root + &quot;.*&quot; + ext + &quot;.*&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _make_rotation_function(rotation):</span>
<span class="gi">+        if rotation is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        elif isinstance(rotation, str):</span>
<span class="gi">+            size = string_parsers.parse_size(rotation)</span>
<span class="gi">+            if size is not None:</span>
<span class="gi">+                return FileSink._make_rotation_function(size)</span>
<span class="gi">+            interval = string_parsers.parse_duration(rotation)</span>
<span class="gi">+            if interval is not None:</span>
<span class="gi">+                return FileSink._make_rotation_function(interval)</span>
<span class="gi">+            frequency = string_parsers.parse_frequency(rotation)</span>
<span class="gi">+            if frequency is not None:</span>
<span class="gi">+                return Rotation.RotationTime(frequency)</span>
<span class="gi">+            daytime = string_parsers.parse_daytime(rotation)</span>
<span class="gi">+            if daytime is not None:</span>
<span class="gi">+                day, time = daytime</span>
<span class="gi">+                if day is None:</span>
<span class="gi">+                    return FileSink._make_rotation_function(time)</span>
<span class="gi">+                if time is None:</span>
<span class="gi">+                    time = datetime.time(0, 0, 0)</span>
<span class="gi">+                step_forward = partial(Rotation.forward_weekday, weekday=day)</span>
<span class="gi">+                return Rotation.RotationTime(step_forward, time)</span>
<span class="gi">+            raise ValueError(&quot;Cannot parse rotation from: &#39;%s&#39;&quot; % rotation)</span>
<span class="gi">+        elif isinstance(rotation, (numbers.Real, decimal.Decimal)):</span>
<span class="gi">+            return partial(Rotation.rotation_size, size_limit=rotation)</span>
<span class="gi">+        elif isinstance(rotation, datetime.time):</span>
<span class="gi">+            return Rotation.RotationTime(Rotation.forward_day, rotation)</span>
<span class="gi">+        elif isinstance(rotation, datetime.timedelta):</span>
<span class="gi">+            step_forward = partial(Rotation.forward_interval, interval=rotation)</span>
<span class="gi">+            return Rotation.RotationTime(step_forward)</span>
<span class="gi">+        elif callable(rotation):</span>
<span class="gi">+            return rotation</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                &quot;Cannot infer rotation for objects of type: &#39;%s&#39;&quot; % type(rotation).__name__</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _make_retention_function(retention):</span>
<span class="gi">+        if retention is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        elif isinstance(retention, str):</span>
<span class="gi">+            interval = string_parsers.parse_duration(retention)</span>
<span class="gi">+            if interval is None:</span>
<span class="gi">+                raise ValueError(&quot;Cannot parse retention from: &#39;%s&#39;&quot; % retention)</span>
<span class="gi">+            return FileSink._make_retention_function(interval)</span>
<span class="gi">+        elif isinstance(retention, int):</span>
<span class="gi">+            return partial(Retention.retention_count, number=retention)</span>
<span class="gi">+        elif isinstance(retention, datetime.timedelta):</span>
<span class="gi">+            return partial(Retention.retention_age, seconds=retention.total_seconds())</span>
<span class="gi">+        elif callable(retention):</span>
<span class="gi">+            return retention</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                &quot;Cannot infer retention for objects of type: &#39;%s&#39;&quot; % type(retention).__name__</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _make_compression_function(compression):</span>
<span class="gi">+        if compression is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        elif isinstance(compression, str):</span>
<span class="gi">+            ext = compression.strip().lstrip(&quot;.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            if ext == &quot;gz&quot;:</span>
<span class="gi">+                import gzip</span>
<span class="gi">+</span>
<span class="gi">+                compress = partial(Compression.copy_compress, opener=gzip.open, mode=&quot;wb&quot;)</span>
<span class="gi">+            elif ext == &quot;bz2&quot;:</span>
<span class="gi">+                import bz2</span>
<span class="gi">+</span>
<span class="gi">+                compress = partial(Compression.copy_compress, opener=bz2.open, mode=&quot;wb&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            elif ext == &quot;xz&quot;:</span>
<span class="gi">+                import lzma</span>
<span class="gi">+</span>
<span class="gi">+                compress = partial(</span>
<span class="gi">+                    Compression.copy_compress, opener=lzma.open, mode=&quot;wb&quot;, format=lzma.FORMAT_XZ</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            elif ext == &quot;lzma&quot;:</span>
<span class="gi">+                import lzma</span>
<span class="gi">+</span>
<span class="gi">+                compress = partial(</span>
<span class="gi">+                    Compression.copy_compress, opener=lzma.open, mode=&quot;wb&quot;, format=lzma.FORMAT_ALONE</span>
<span class="gi">+                )</span>
<span class="gi">+            elif ext == &quot;tar&quot;:</span>
<span class="gi">+                import tarfile</span>
<span class="gi">+</span>
<span class="gi">+                compress = partial(Compression.add_compress, opener=tarfile.open, mode=&quot;w:&quot;)</span>
<span class="gi">+            elif ext == &quot;tar.gz&quot;:</span>
<span class="gi">+                import gzip</span>
<span class="gi">+                import tarfile</span>
<span class="gi">+</span>
<span class="gi">+                compress = partial(Compression.add_compress, opener=tarfile.open, mode=&quot;w:gz&quot;)</span>
<span class="gi">+            elif ext == &quot;tar.bz2&quot;:</span>
<span class="gi">+                import bz2</span>
<span class="gi">+                import tarfile</span>
<span class="gi">+</span>
<span class="gi">+                compress = partial(Compression.add_compress, opener=tarfile.open, mode=&quot;w:bz2&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            elif ext == &quot;tar.xz&quot;:</span>
<span class="gi">+                import lzma</span>
<span class="gi">+                import tarfile</span>
<span class="gi">+</span>
<span class="gi">+                compress = partial(Compression.add_compress, opener=tarfile.open, mode=&quot;w:xz&quot;)</span>
<span class="gi">+            elif ext == &quot;zip&quot;:</span>
<span class="gi">+                import zipfile</span>
<span class="gi">+</span>
<span class="gi">+                compress = partial(</span>
<span class="gi">+                    Compression.write_compress,</span>
<span class="gi">+                    opener=zipfile.ZipFile,</span>
<span class="gi">+                    mode=&quot;w&quot;,</span>
<span class="gi">+                    compression=zipfile.ZIP_DEFLATED,</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise ValueError(&quot;Invalid compression format: &#39;%s&#39;&quot; % ext)</span>
<span class="gi">+</span>
<span class="gi">+            return partial(Compression.compression, ext=&quot;.&quot; + ext, compress_function=compress)</span>
<span class="gi">+        elif callable(compression):</span>
<span class="gi">+            return compression</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                &quot;Cannot infer compression for objects of type: &#39;%s&#39;&quot; % type(compression).__name__</span>
<span class="gi">+            )</span>
<span class="gh">diff --git a/loguru/_filters.py b/loguru/_filters.py</span>
<span class="gh">index e69de29..a192b26 100644</span>
<span class="gd">--- a/loguru/_filters.py</span>
<span class="gi">+++ b/loguru/_filters.py</span>
<span class="gu">@@ -0,0 +1,24 @@</span>
<span class="gi">+def filter_none(record):</span>
<span class="gi">+    return record[&quot;name&quot;] is not None</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def filter_by_name(record, parent, length):</span>
<span class="gi">+    name = record[&quot;name&quot;]</span>
<span class="gi">+    if name is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+    return (name + &quot;.&quot;)[:length] == parent</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def filter_by_level(record, level_per_module):</span>
<span class="gi">+    name = record[&quot;name&quot;]</span>
<span class="gi">+</span>
<span class="gi">+    while True:</span>
<span class="gi">+        level = level_per_module.get(name, None)</span>
<span class="gi">+        if level is False:</span>
<span class="gi">+            return False</span>
<span class="gi">+        if level is not None:</span>
<span class="gi">+            return record[&quot;level&quot;].no &gt;= level</span>
<span class="gi">+        if not name:</span>
<span class="gi">+            return True</span>
<span class="gi">+        index = name.rfind(&quot;.&quot;)</span>
<span class="gi">+        name = name[:index] if index != -1 else &quot;&quot;</span>
<span class="gh">diff --git a/loguru/_get_frame.py b/loguru/_get_frame.py</span>
<span class="gh">index 2acdfbf..ee6eaab 100644</span>
<span class="gd">--- a/loguru/_get_frame.py</span>
<span class="gi">+++ b/loguru/_get_frame.py</span>
<span class="gu">@@ -1,3 +1,23 @@</span>
<span class="w"> </span>import sys
<span class="w"> </span>from sys import exc_info
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def get_frame_fallback(n):</span>
<span class="gi">+    try:</span>
<span class="gi">+        raise Exception</span>
<span class="gi">+    except Exception:</span>
<span class="gi">+        frame = exc_info()[2].tb_frame.f_back</span>
<span class="gi">+        for _ in range(n):</span>
<span class="gi">+            frame = frame.f_back</span>
<span class="gi">+        return frame</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def load_get_frame_function():</span>
<span class="gi">+    if hasattr(sys, &quot;_getframe&quot;):</span>
<span class="gi">+        get_frame = sys._getframe</span>
<span class="gi">+    else:</span>
<span class="gi">+        get_frame = get_frame_fallback</span>
<span class="gi">+    return get_frame</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>get_frame = load_get_frame_function()
<span class="gh">diff --git a/loguru/_handler.py b/loguru/_handler.py</span>
<span class="gh">index cbb5940..81a3dca 100644</span>
<span class="gd">--- a/loguru/_handler.py</span>
<span class="gi">+++ b/loguru/_handler.py</span>
<span class="gu">@@ -5,20 +5,48 @@ import os</span>
<span class="w"> </span>import threading
<span class="w"> </span>from contextlib import contextmanager
<span class="w"> </span>from threading import Thread
<span class="gi">+</span>
<span class="w"> </span>from ._colorizer import Colorizer
<span class="w"> </span>from ._locks_machinery import create_handler_lock


<span class="gi">+def prepare_colored_format(format_, ansi_level):</span>
<span class="gi">+    colored = Colorizer.prepare_format(format_)</span>
<span class="gi">+    return colored, colored.colorize(ansi_level)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def prepare_stripped_format(format_):</span>
<span class="gi">+    colored = Colorizer.prepare_format(format_)</span>
<span class="gi">+    return colored.strip()</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def memoize(function):</span>
<span class="gi">+    return functools.lru_cache(maxsize=64)(function)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class Message(str):
<span class="gd">-    __slots__ = &#39;record&#39;,</span>
<span class="gi">+    __slots__ = (&quot;record&quot;,)</span>


<span class="w"> </span>class Handler:
<span class="gd">-</span>
<span class="gd">-    def __init__(self, *, sink, name, levelno, formatter,</span>
<span class="gd">-        is_formatter_dynamic, filter_, colorize, serialize, enqueue,</span>
<span class="gd">-        multiprocessing_context, error_interceptor, exception_formatter,</span>
<span class="gd">-        id_, levels_ansi_codes):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        sink,</span>
<span class="gi">+        name,</span>
<span class="gi">+        levelno,</span>
<span class="gi">+        formatter,</span>
<span class="gi">+        is_formatter_dynamic,</span>
<span class="gi">+        filter_,</span>
<span class="gi">+        colorize,</span>
<span class="gi">+        serialize,</span>
<span class="gi">+        enqueue,</span>
<span class="gi">+        multiprocessing_context,</span>
<span class="gi">+        error_interceptor,</span>
<span class="gi">+        exception_formatter,</span>
<span class="gi">+        id_,</span>
<span class="gi">+        levels_ansi_codes</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        self._name = name
<span class="w"> </span>        self._sink = sink
<span class="w"> </span>        self._levelno = levelno
<span class="gu">@@ -32,10 +60,12 @@ class Handler:</span>
<span class="w"> </span>        self._error_interceptor = error_interceptor
<span class="w"> </span>        self._exception_formatter = exception_formatter
<span class="w"> </span>        self._id = id_
<span class="gd">-        self._levels_ansi_codes = levels_ansi_codes</span>
<span class="gi">+        self._levels_ansi_codes = levels_ansi_codes  # Warning, reference shared among handlers</span>
<span class="gi">+</span>
<span class="w"> </span>        self._decolorized_format = None
<span class="w"> </span>        self._precolorized_formats = {}
<span class="w"> </span>        self._memoize_dynamic_format = None
<span class="gi">+</span>
<span class="w"> </span>        self._stopped = False
<span class="w"> </span>        self._lock = create_handler_lock()
<span class="w"> </span>        self._lock_acquired = threading.local()
<span class="gu">@@ -45,16 +75,19 @@ class Handler:</span>
<span class="w"> </span>        self._confirmation_lock = None
<span class="w"> </span>        self._owner_process_pid = None
<span class="w"> </span>        self._thread = None
<span class="gi">+</span>
<span class="w"> </span>        if self._is_formatter_dynamic:
<span class="w"> </span>            if self._colorize:
<span class="w"> </span>                self._memoize_dynamic_format = memoize(prepare_colored_format)
<span class="w"> </span>            else:
<span class="w"> </span>                self._memoize_dynamic_format = memoize(prepare_stripped_format)
<span class="gd">-        elif self._colorize:</span>
<span class="gd">-            for level_name in self._levels_ansi_codes:</span>
<span class="gd">-                self.update_format(level_name)</span>
<span class="w"> </span>        else:
<span class="gd">-            self._decolorized_format = self._formatter.strip()</span>
<span class="gi">+            if self._colorize:</span>
<span class="gi">+                for level_name in self._levels_ansi_codes:</span>
<span class="gi">+                    self.update_format(level_name)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._decolorized_format = self._formatter.strip()</span>
<span class="gi">+</span>
<span class="w"> </span>        if self._enqueue:
<span class="w"> </span>            if self._multiprocessing_context is None:
<span class="w"> </span>                self._queue = multiprocessing.SimpleQueue()
<span class="gu">@@ -62,34 +95,237 @@ class Handler:</span>
<span class="w"> </span>                self._confirmation_lock = multiprocessing.Lock()
<span class="w"> </span>            else:
<span class="w"> </span>                self._queue = self._multiprocessing_context.SimpleQueue()
<span class="gd">-                self._confirmation_event = self._multiprocessing_context.Event(</span>
<span class="gd">-                    )</span>
<span class="gi">+                self._confirmation_event = self._multiprocessing_context.Event()</span>
<span class="w"> </span>                self._confirmation_lock = self._multiprocessing_context.Lock()
<span class="w"> </span>            self._queue_lock = create_handler_lock()
<span class="w"> </span>            self._owner_process_pid = os.getpid()
<span class="gd">-            self._thread = Thread(target=self._queued_writer, daemon=True,</span>
<span class="gd">-                name=&#39;loguru-writer-%d&#39; % self._id)</span>
<span class="gi">+            self._thread = Thread(</span>
<span class="gi">+                target=self._queued_writer, daemon=True, name=&quot;loguru-writer-%d&quot; % self._id</span>
<span class="gi">+            )</span>
<span class="w"> </span>            self._thread.start()

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;(id=%d, level=%d, sink=%s)&#39; % (self._id, self._levelno,</span>
<span class="gd">-            self._name)</span>
<span class="gi">+        return &quot;(id=%d, level=%d, sink=%s)&quot; % (self._id, self._levelno, self._name)</span>

<span class="w"> </span>    @contextmanager
<span class="w"> </span>    def _protected_lock(self):
<span class="w"> </span>        &quot;&quot;&quot;Acquire the lock, but fail fast if its already acquired by the current thread.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if getattr(self._lock_acquired, &quot;acquired&quot;, False):</span>
<span class="gi">+            raise RuntimeError(</span>
<span class="gi">+                &quot;Could not acquire internal lock because it was already in use (deadlock avoided). &quot;</span>
<span class="gi">+                &quot;This likely happened because the logger was re-used inside a sink, a signal &quot;</span>
<span class="gi">+                &quot;handler or a &#39;__del__&#39; method. This is not permitted because the logger and its &quot;</span>
<span class="gi">+                &quot;handlers are not re-entrant.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        self._lock_acquired.acquired = True</span>
<span class="gi">+        try:</span>
<span class="gi">+            with self._lock:</span>
<span class="gi">+                yield</span>
<span class="gi">+        finally:</span>
<span class="gi">+            self._lock_acquired.acquired = False</span>
<span class="gi">+</span>
<span class="gi">+    def emit(self, record, level_id, from_decorator, is_raw, colored_message):</span>
<span class="gi">+        try:</span>
<span class="gi">+            if self._levelno &gt; record[&quot;level&quot;].no:</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            if self._filter is not None:</span>
<span class="gi">+                if not self._filter(record):</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+            if self._is_formatter_dynamic:</span>
<span class="gi">+                dynamic_format = self._formatter(record)</span>
<span class="gi">+</span>
<span class="gi">+            formatter_record = record.copy()</span>
<span class="gi">+</span>
<span class="gi">+            if not record[&quot;exception&quot;]:</span>
<span class="gi">+                formatter_record[&quot;exception&quot;] = &quot;&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                type_, value, tb = record[&quot;exception&quot;]</span>
<span class="gi">+                formatter = self._exception_formatter</span>
<span class="gi">+                lines = formatter.format_exception(type_, value, tb, from_decorator=from_decorator)</span>
<span class="gi">+                formatter_record[&quot;exception&quot;] = &quot;&quot;.join(lines)</span>
<span class="gi">+</span>
<span class="gi">+            if colored_message is not None and colored_message.stripped != record[&quot;message&quot;]:</span>
<span class="gi">+                colored_message = None</span>
<span class="gi">+</span>
<span class="gi">+            if is_raw:</span>
<span class="gi">+                if colored_message is None or not self._colorize:</span>
<span class="gi">+                    formatted = record[&quot;message&quot;]</span>
<span class="gi">+                else:</span>
<span class="gi">+                    ansi_level = self._levels_ansi_codes[level_id]</span>
<span class="gi">+                    formatted = colored_message.colorize(ansi_level)</span>
<span class="gi">+            elif self._is_formatter_dynamic:</span>
<span class="gi">+                if not self._colorize:</span>
<span class="gi">+                    precomputed_format = self._memoize_dynamic_format(dynamic_format)</span>
<span class="gi">+                    formatted = precomputed_format.format_map(formatter_record)</span>
<span class="gi">+                elif colored_message is None:</span>
<span class="gi">+                    ansi_level = self._levels_ansi_codes[level_id]</span>
<span class="gi">+                    _, precomputed_format = self._memoize_dynamic_format(dynamic_format, ansi_level)</span>
<span class="gi">+                    formatted = precomputed_format.format_map(formatter_record)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    ansi_level = self._levels_ansi_codes[level_id]</span>
<span class="gi">+                    formatter, precomputed_format = self._memoize_dynamic_format(</span>
<span class="gi">+                        dynamic_format, ansi_level</span>
<span class="gi">+                    )</span>
<span class="gi">+                    coloring_message = formatter.make_coloring_message(</span>
<span class="gi">+                        record[&quot;message&quot;], ansi_level=ansi_level, colored_message=colored_message</span>
<span class="gi">+                    )</span>
<span class="gi">+                    formatter_record[&quot;message&quot;] = coloring_message</span>
<span class="gi">+                    formatted = precomputed_format.format_map(formatter_record)</span>
<span class="gi">+</span>
<span class="gi">+            else:</span>
<span class="gi">+                if not self._colorize:</span>
<span class="gi">+                    precomputed_format = self._decolorized_format</span>
<span class="gi">+                    formatted = precomputed_format.format_map(formatter_record)</span>
<span class="gi">+                elif colored_message is None:</span>
<span class="gi">+                    ansi_level = self._levels_ansi_codes[level_id]</span>
<span class="gi">+                    precomputed_format = self._precolorized_formats[level_id]</span>
<span class="gi">+                    formatted = precomputed_format.format_map(formatter_record)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    ansi_level = self._levels_ansi_codes[level_id]</span>
<span class="gi">+                    precomputed_format = self._precolorized_formats[level_id]</span>
<span class="gi">+                    coloring_message = self._formatter.make_coloring_message(</span>
<span class="gi">+                        record[&quot;message&quot;], ansi_level=ansi_level, colored_message=colored_message</span>
<span class="gi">+                    )</span>
<span class="gi">+                    formatter_record[&quot;message&quot;] = coloring_message</span>
<span class="gi">+                    formatted = precomputed_format.format_map(formatter_record)</span>
<span class="gi">+</span>
<span class="gi">+            if self._serialize:</span>
<span class="gi">+                formatted = self._serialize_record(formatted, record)</span>
<span class="gi">+</span>
<span class="gi">+            str_record = Message(formatted)</span>
<span class="gi">+            str_record.record = record</span>
<span class="gi">+</span>
<span class="gi">+            with self._protected_lock():</span>
<span class="gi">+                if self._stopped:</span>
<span class="gi">+                    return</span>
<span class="gi">+                if self._enqueue:</span>
<span class="gi">+                    self._queue.put(str_record)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self._sink.write(str_record)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            if not self._error_interceptor.should_catch():</span>
<span class="gi">+                raise</span>
<span class="gi">+            self._error_interceptor.print(record)</span>
<span class="gi">+</span>
<span class="gi">+    def stop(self):</span>
<span class="gi">+        with self._protected_lock():</span>
<span class="gi">+            self._stopped = True</span>
<span class="gi">+            if self._enqueue:</span>
<span class="gi">+                if self._owner_process_pid != os.getpid():</span>
<span class="gi">+                    return</span>
<span class="gi">+                self._queue.put(None)</span>
<span class="gi">+                self._thread.join()</span>
<span class="gi">+                if hasattr(self._queue, &quot;close&quot;):</span>
<span class="gi">+                    self._queue.close()</span>
<span class="gi">+</span>
<span class="gi">+            self._sink.stop()</span>
<span class="gi">+</span>
<span class="gi">+    def complete_queue(self):</span>
<span class="gi">+        if not self._enqueue:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        with self._confirmation_lock:</span>
<span class="gi">+            self._queue.put(True)</span>
<span class="gi">+            self._confirmation_event.wait()</span>
<span class="gi">+            self._confirmation_event.clear()</span>
<span class="gi">+</span>
<span class="gi">+    def tasks_to_complete(self):</span>
<span class="gi">+        if self._enqueue and self._owner_process_pid != os.getpid():</span>
<span class="gi">+            return []</span>
<span class="gi">+        lock = self._queue_lock if self._enqueue else self._protected_lock()</span>
<span class="gi">+        with lock:</span>
<span class="gi">+            return self._sink.tasks_to_complete()</span>
<span class="gi">+</span>
<span class="gi">+    def update_format(self, level_id):</span>
<span class="gi">+        if not self._colorize or self._is_formatter_dynamic:</span>
<span class="gi">+            return</span>
<span class="gi">+        ansi_code = self._levels_ansi_codes[level_id]</span>
<span class="gi">+        self._precolorized_formats[level_id] = self._formatter.colorize(ansi_code)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def levelno(self):</span>
<span class="gi">+        return self._levelno</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _serialize_record(text, record):</span>
<span class="gi">+        exception = record[&quot;exception&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        if exception is not None:</span>
<span class="gi">+            exception = {</span>
<span class="gi">+                &quot;type&quot;: None if exception.type is None else exception.type.__name__,</span>
<span class="gi">+                &quot;value&quot;: exception.value,</span>
<span class="gi">+                &quot;traceback&quot;: bool(exception.traceback),</span>
<span class="gi">+            }</span>
<span class="gi">+</span>
<span class="gi">+        serializable = {</span>
<span class="gi">+            &quot;text&quot;: text,</span>
<span class="gi">+            &quot;record&quot;: {</span>
<span class="gi">+                &quot;elapsed&quot;: {</span>
<span class="gi">+                    &quot;repr&quot;: record[&quot;elapsed&quot;],</span>
<span class="gi">+                    &quot;seconds&quot;: record[&quot;elapsed&quot;].total_seconds(),</span>
<span class="gi">+                },</span>
<span class="gi">+                &quot;exception&quot;: exception,</span>
<span class="gi">+                &quot;extra&quot;: record[&quot;extra&quot;],</span>
<span class="gi">+                &quot;file&quot;: {&quot;name&quot;: record[&quot;file&quot;].name, &quot;path&quot;: record[&quot;file&quot;].path},</span>
<span class="gi">+                &quot;function&quot;: record[&quot;function&quot;],</span>
<span class="gi">+                &quot;level&quot;: {</span>
<span class="gi">+                    &quot;icon&quot;: record[&quot;level&quot;].icon,</span>
<span class="gi">+                    &quot;name&quot;: record[&quot;level&quot;].name,</span>
<span class="gi">+                    &quot;no&quot;: record[&quot;level&quot;].no,</span>
<span class="gi">+                },</span>
<span class="gi">+                &quot;line&quot;: record[&quot;line&quot;],</span>
<span class="gi">+                &quot;message&quot;: record[&quot;message&quot;],</span>
<span class="gi">+                &quot;module&quot;: record[&quot;module&quot;],</span>
<span class="gi">+                &quot;name&quot;: record[&quot;name&quot;],</span>
<span class="gi">+                &quot;process&quot;: {&quot;id&quot;: record[&quot;process&quot;].id, &quot;name&quot;: record[&quot;process&quot;].name},</span>
<span class="gi">+                &quot;thread&quot;: {&quot;id&quot;: record[&quot;thread&quot;].id, &quot;name&quot;: record[&quot;thread&quot;].name},</span>
<span class="gi">+                &quot;time&quot;: {&quot;repr&quot;: record[&quot;time&quot;], &quot;timestamp&quot;: record[&quot;time&quot;].timestamp()},</span>
<span class="gi">+            },</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        return json.dumps(serializable, default=str, ensure_ascii=False) + &quot;\n&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def _queued_writer(self):</span>
<span class="gi">+        message = None</span>
<span class="gi">+        queue = self._queue</span>
<span class="gi">+</span>
<span class="gi">+        # We need to use a lock to protect sink during fork.</span>
<span class="gi">+        # Particularly, writing to stderr may lead to deadlock in child process.</span>
<span class="gi">+        lock = self._queue_lock</span>
<span class="gi">+</span>
<span class="gi">+        while True:</span>
<span class="gi">+            try:</span>
<span class="gi">+                message = queue.get()</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                with lock:</span>
<span class="gi">+                    self._error_interceptor.print(None)</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if message is None:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            if message is True:</span>
<span class="gi">+                self._confirmation_event.set()</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            with lock:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    self._sink.write(message)</span>
<span class="gi">+                except Exception:</span>
<span class="gi">+                    self._error_interceptor.print(message.record)</span>

<span class="w"> </span>    def __getstate__(self):
<span class="w"> </span>        state = self.__dict__.copy()
<span class="gd">-        state[&#39;_lock&#39;] = None</span>
<span class="gd">-        state[&#39;_lock_acquired&#39;] = None</span>
<span class="gd">-        state[&#39;_memoize_dynamic_format&#39;] = None</span>
<span class="gi">+        state[&quot;_lock&quot;] = None</span>
<span class="gi">+        state[&quot;_lock_acquired&quot;] = None</span>
<span class="gi">+        state[&quot;_memoize_dynamic_format&quot;] = None</span>
<span class="w"> </span>        if self._enqueue:
<span class="gd">-            state[&#39;_sink&#39;] = None</span>
<span class="gd">-            state[&#39;_thread&#39;] = None</span>
<span class="gd">-            state[&#39;_owner_process&#39;] = None</span>
<span class="gd">-            state[&#39;_queue_lock&#39;] = None</span>
<span class="gi">+            state[&quot;_sink&quot;] = None</span>
<span class="gi">+            state[&quot;_thread&quot;] = None</span>
<span class="gi">+            state[&quot;_owner_process&quot;] = None</span>
<span class="gi">+            state[&quot;_queue_lock&quot;] = None</span>
<span class="w"> </span>        return state

<span class="w"> </span>    def __setstate__(self, state):
<span class="gh">diff --git a/loguru/_locks_machinery.py b/loguru/_locks_machinery.py</span>
<span class="gh">index a65aee1..6f02110 100644</span>
<span class="gd">--- a/loguru/_locks_machinery.py</span>
<span class="gi">+++ b/loguru/_locks_machinery.py</span>
<span class="gu">@@ -1,9 +1,50 @@</span>
<span class="w"> </span>import os
<span class="w"> </span>import threading
<span class="w"> </span>import weakref
<span class="gd">-if not hasattr(os, &#39;register_at_fork&#39;):</span>
<span class="gi">+</span>
<span class="gi">+if not hasattr(os, &quot;register_at_fork&quot;):</span>
<span class="gi">+</span>
<span class="gi">+    def create_logger_lock():</span>
<span class="gi">+        return threading.Lock()</span>
<span class="gi">+</span>
<span class="gi">+    def create_handler_lock():</span>
<span class="gi">+        return threading.Lock()</span>
<span class="gi">+</span>
<span class="w"> </span>else:
<span class="gi">+    # While forking, we need to sanitize all locks to make sure the child process doesn&#39;t run into</span>
<span class="gi">+    # a deadlock (if a lock already acquired is inherited) and to protect sink from corrupted state.</span>
<span class="gi">+    # It&#39;s very important to acquire logger locks before handlers one to prevent possible deadlock</span>
<span class="gi">+    # while &#39;remove()&#39; is called for example.</span>
<span class="gi">+</span>
<span class="w"> </span>    logger_locks = weakref.WeakSet()
<span class="w"> </span>    handler_locks = weakref.WeakSet()
<span class="gd">-    os.register_at_fork(before=acquire_locks, after_in_parent=release_locks,</span>
<span class="gd">-        after_in_child=release_locks)</span>
<span class="gi">+</span>
<span class="gi">+    def acquire_locks():</span>
<span class="gi">+        for lock in logger_locks:</span>
<span class="gi">+            lock.acquire()</span>
<span class="gi">+</span>
<span class="gi">+        for lock in handler_locks:</span>
<span class="gi">+            lock.acquire()</span>
<span class="gi">+</span>
<span class="gi">+    def release_locks():</span>
<span class="gi">+        for lock in logger_locks:</span>
<span class="gi">+            lock.release()</span>
<span class="gi">+</span>
<span class="gi">+        for lock in handler_locks:</span>
<span class="gi">+            lock.release()</span>
<span class="gi">+</span>
<span class="gi">+    os.register_at_fork(</span>
<span class="gi">+        before=acquire_locks,</span>
<span class="gi">+        after_in_parent=release_locks,</span>
<span class="gi">+        after_in_child=release_locks,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def create_logger_lock():</span>
<span class="gi">+        lock = threading.Lock()</span>
<span class="gi">+        logger_locks.add(lock)</span>
<span class="gi">+        return lock</span>
<span class="gi">+</span>
<span class="gi">+    def create_handler_lock():</span>
<span class="gi">+        lock = threading.Lock()</span>
<span class="gi">+        handler_locks.add(lock)</span>
<span class="gi">+        return lock</span>
<span class="gh">diff --git a/loguru/_logger.py b/loguru/_logger.py</span>
<span class="gh">index 8812d5c..f750967 100644</span>
<span class="gd">--- a/loguru/_logger.py</span>
<span class="gi">+++ b/loguru/_logger.py</span>
<span class="gu">@@ -95,6 +95,7 @@ from multiprocessing import current_process, get_context</span>
<span class="w"> </span>from multiprocessing.context import BaseContext
<span class="w"> </span>from os.path import basename, splitext
<span class="w"> </span>from threading import current_thread
<span class="gi">+</span>
<span class="w"> </span>from . import _asyncio_loop, _colorama, _defaults, _filters
<span class="w"> </span>from ._better_exceptions import ExceptionFormatter
<span class="w"> </span>from ._colorizer import Colorizer
<span class="gu">@@ -107,49 +108,95 @@ from ._handler import Handler</span>
<span class="w"> </span>from ._locks_machinery import create_logger_lock
<span class="w"> </span>from ._recattrs import RecordException, RecordFile, RecordLevel, RecordProcess, RecordThread
<span class="w"> </span>from ._simple_sinks import AsyncSink, CallableSink, StandardSink, StreamSink
<span class="gi">+</span>
<span class="w"> </span>if sys.version_info &gt;= (3, 6):
<span class="w"> </span>    from os import PathLike
<span class="w"> </span>else:
<span class="w"> </span>    from pathlib import PurePath as PathLike
<span class="gd">-Level = namedtuple(&#39;Level&#39;, [&#39;name&#39;, &#39;no&#39;, &#39;color&#39;, &#39;icon&#39;])</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+Level = namedtuple(&quot;Level&quot;, [&quot;name&quot;, &quot;no&quot;, &quot;color&quot;, &quot;icon&quot;])</span>
<span class="gi">+</span>
<span class="w"> </span>start_time = aware_now()
<span class="gd">-context = ContextVar(&#39;loguru_context&#39;, default={})</span>

<span class="gi">+context = ContextVar(&quot;loguru_context&quot;, default={})</span>

<span class="gd">-class Core:</span>

<span class="gi">+class Core:</span>
<span class="w"> </span>    def __init__(self):
<span class="gd">-        levels = [Level(&#39;TRACE&#39;, _defaults.LOGURU_TRACE_NO, _defaults.</span>
<span class="gd">-            LOGURU_TRACE_COLOR, _defaults.LOGURU_TRACE_ICON), Level(&#39;DEBUG&#39;,</span>
<span class="gd">-            _defaults.LOGURU_DEBUG_NO, _defaults.LOGURU_DEBUG_COLOR,</span>
<span class="gd">-            _defaults.LOGURU_DEBUG_ICON), Level(&#39;INFO&#39;, _defaults.</span>
<span class="gd">-            LOGURU_INFO_NO, _defaults.LOGURU_INFO_COLOR, _defaults.</span>
<span class="gd">-            LOGURU_INFO_ICON), Level(&#39;SUCCESS&#39;, _defaults.LOGURU_SUCCESS_NO,</span>
<span class="gd">-            _defaults.LOGURU_SUCCESS_COLOR, _defaults.LOGURU_SUCCESS_ICON),</span>
<span class="gd">-            Level(&#39;WARNING&#39;, _defaults.LOGURU_WARNING_NO, _defaults.</span>
<span class="gd">-            LOGURU_WARNING_COLOR, _defaults.LOGURU_WARNING_ICON), Level(</span>
<span class="gd">-            &#39;ERROR&#39;, _defaults.LOGURU_ERROR_NO, _defaults.</span>
<span class="gd">-            LOGURU_ERROR_COLOR, _defaults.LOGURU_ERROR_ICON), Level(</span>
<span class="gd">-            &#39;CRITICAL&#39;, _defaults.LOGURU_CRITICAL_NO, _defaults.</span>
<span class="gd">-            LOGURU_CRITICAL_COLOR, _defaults.LOGURU_CRITICAL_ICON)]</span>
<span class="gi">+        levels = [</span>
<span class="gi">+            Level(</span>
<span class="gi">+                &quot;TRACE&quot;,</span>
<span class="gi">+                _defaults.LOGURU_TRACE_NO,</span>
<span class="gi">+                _defaults.LOGURU_TRACE_COLOR,</span>
<span class="gi">+                _defaults.LOGURU_TRACE_ICON,</span>
<span class="gi">+            ),</span>
<span class="gi">+            Level(</span>
<span class="gi">+                &quot;DEBUG&quot;,</span>
<span class="gi">+                _defaults.LOGURU_DEBUG_NO,</span>
<span class="gi">+                _defaults.LOGURU_DEBUG_COLOR,</span>
<span class="gi">+                _defaults.LOGURU_DEBUG_ICON,</span>
<span class="gi">+            ),</span>
<span class="gi">+            Level(</span>
<span class="gi">+                &quot;INFO&quot;,</span>
<span class="gi">+                _defaults.LOGURU_INFO_NO,</span>
<span class="gi">+                _defaults.LOGURU_INFO_COLOR,</span>
<span class="gi">+                _defaults.LOGURU_INFO_ICON,</span>
<span class="gi">+            ),</span>
<span class="gi">+            Level(</span>
<span class="gi">+                &quot;SUCCESS&quot;,</span>
<span class="gi">+                _defaults.LOGURU_SUCCESS_NO,</span>
<span class="gi">+                _defaults.LOGURU_SUCCESS_COLOR,</span>
<span class="gi">+                _defaults.LOGURU_SUCCESS_ICON,</span>
<span class="gi">+            ),</span>
<span class="gi">+            Level(</span>
<span class="gi">+                &quot;WARNING&quot;,</span>
<span class="gi">+                _defaults.LOGURU_WARNING_NO,</span>
<span class="gi">+                _defaults.LOGURU_WARNING_COLOR,</span>
<span class="gi">+                _defaults.LOGURU_WARNING_ICON,</span>
<span class="gi">+            ),</span>
<span class="gi">+            Level(</span>
<span class="gi">+                &quot;ERROR&quot;,</span>
<span class="gi">+                _defaults.LOGURU_ERROR_NO,</span>
<span class="gi">+                _defaults.LOGURU_ERROR_COLOR,</span>
<span class="gi">+                _defaults.LOGURU_ERROR_ICON,</span>
<span class="gi">+            ),</span>
<span class="gi">+            Level(</span>
<span class="gi">+                &quot;CRITICAL&quot;,</span>
<span class="gi">+                _defaults.LOGURU_CRITICAL_NO,</span>
<span class="gi">+                _defaults.LOGURU_CRITICAL_COLOR,</span>
<span class="gi">+                _defaults.LOGURU_CRITICAL_ICON,</span>
<span class="gi">+            ),</span>
<span class="gi">+        ]</span>
<span class="w"> </span>        self.levels = {level.name: level for level in levels}
<span class="gd">-        self.levels_ansi_codes = {**{name: Colorizer.ansify(level.color) for</span>
<span class="gd">-            name, level in self.levels.items()}, None: &#39;&#39;}</span>
<span class="gd">-        self.levels_lookup = {name: (name, name, level.no, level.icon) for </span>
<span class="gd">-            name, level in self.levels.items()}</span>
<span class="gi">+        self.levels_ansi_codes = {</span>
<span class="gi">+            **{name: Colorizer.ansify(level.color) for name, level in self.levels.items()},</span>
<span class="gi">+            None: &quot;&quot;,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        # Cache used internally to quickly access level attributes based on their name or severity.</span>
<span class="gi">+        # It can also contain integers as keys, it serves to avoid calling &quot;isinstance()&quot; repeatedly</span>
<span class="gi">+        # when &quot;logger.log()&quot; is used.</span>
<span class="gi">+        self.levels_lookup = {</span>
<span class="gi">+            name: (name, name, level.no, level.icon) for name, level in self.levels.items()</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="w"> </span>        self.handlers_count = 0
<span class="w"> </span>        self.handlers = {}
<span class="gi">+</span>
<span class="w"> </span>        self.extra = {}
<span class="w"> </span>        self.patcher = None
<span class="gd">-        self.min_level = float(&#39;inf&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        self.min_level = float(&quot;inf&quot;)</span>
<span class="w"> </span>        self.enabled = {}
<span class="w"> </span>        self.activation_list = []
<span class="w"> </span>        self.activation_none = True
<span class="gi">+</span>
<span class="w"> </span>        self.lock = create_logger_lock()

<span class="w"> </span>    def __getstate__(self):
<span class="w"> </span>        state = self.__dict__.copy()
<span class="gd">-        state[&#39;lock&#39;] = None</span>
<span class="gi">+        state[&quot;lock&quot;] = None</span>
<span class="w"> </span>        return state

<span class="w"> </span>    def __setstate__(self, state):
<span class="gu">@@ -180,23 +227,30 @@ class Logger:</span>
<span class="w"> </span>    You should not instantiate a |Logger| by yourself, use ``from loguru import logger`` instead.
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, core, exception, depth, record, lazy, colors, raw,</span>
<span class="gd">-        capture, patchers, extra):</span>
<span class="gi">+    def __init__(self, core, exception, depth, record, lazy, colors, raw, capture, patchers, extra):</span>
<span class="w"> </span>        self._core = core
<span class="gd">-        self._options = (exception, depth, record, lazy, colors, raw,</span>
<span class="gd">-            capture, patchers, extra)</span>
<span class="gi">+        self._options = (exception, depth, record, lazy, colors, raw, capture, patchers, extra)</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;&lt;loguru.logger handlers=%r&gt;&#39; % list(self._core.handlers.</span>
<span class="gd">-            values())</span>
<span class="gd">-</span>
<span class="gd">-    def add(self, sink, *, level=_defaults.LOGURU_LEVEL, format=_defaults.</span>
<span class="gd">-        LOGURU_FORMAT, filter=_defaults.LOGURU_FILTER, colorize=_defaults.</span>
<span class="gd">-        LOGURU_COLORIZE, serialize=_defaults.LOGURU_SERIALIZE, backtrace=</span>
<span class="gd">-        _defaults.LOGURU_BACKTRACE, diagnose=_defaults.LOGURU_DIAGNOSE,</span>
<span class="gd">-        enqueue=_defaults.LOGURU_ENQUEUE, context=_defaults.LOGURU_CONTEXT,</span>
<span class="gd">-        catch=_defaults.LOGURU_CATCH, **kwargs):</span>
<span class="gd">-        &quot;&quot;&quot;Add a handler sending log messages to a sink adequately configured.</span>
<span class="gi">+        return &quot;&lt;loguru.logger handlers=%r&gt;&quot; % list(self._core.handlers.values())</span>
<span class="gi">+</span>
<span class="gi">+    def add(</span>
<span class="gi">+        self,</span>
<span class="gi">+        sink,</span>
<span class="gi">+        *,</span>
<span class="gi">+        level=_defaults.LOGURU_LEVEL,</span>
<span class="gi">+        format=_defaults.LOGURU_FORMAT,</span>
<span class="gi">+        filter=_defaults.LOGURU_FILTER,</span>
<span class="gi">+        colorize=_defaults.LOGURU_COLORIZE,</span>
<span class="gi">+        serialize=_defaults.LOGURU_SERIALIZE,</span>
<span class="gi">+        backtrace=_defaults.LOGURU_BACKTRACE,</span>
<span class="gi">+        diagnose=_defaults.LOGURU_DIAGNOSE,</span>
<span class="gi">+        enqueue=_defaults.LOGURU_ENQUEUE,</span>
<span class="gi">+        context=_defaults.LOGURU_CONTEXT,</span>
<span class="gi">+        catch=_defaults.LOGURU_CATCH,</span>
<span class="gi">+        **kwargs</span>
<span class="gi">+    ):</span>
<span class="gi">+        r&quot;&quot;&quot;Add a handler sending log messages to a sink adequately configured.</span>

<span class="w"> </span>        Parameters
<span class="w"> </span>        ----------
<span class="gu">@@ -334,7 +388,7 @@ class Logger:</span>
<span class="w"> </span>        If fine-grained control is needed, the ``format`` can also be a function which takes the
<span class="w"> </span>        record as parameter and return the format template string. However, note that in such a
<span class="w"> </span>        case, you should take care of appending the line ending and exception field to the returned
<span class="gd">-        format, while ``&quot;\\n{exception}&quot;`` is automatically appended for convenience if ``format`` is</span>
<span class="gi">+        format, while ``&quot;\n{exception}&quot;`` is automatically appended for convenience if ``format`` is</span>
<span class="w"> </span>        a string.

<span class="w"> </span>        The ``filter`` attribute can be used to control which messages are effectively passed to the
<span class="gu">@@ -604,9 +658,9 @@ class Logger:</span>

<span class="w"> </span>        Tags which are not recognized will raise an exception during parsing, to inform you about
<span class="w"> </span>        possible misuse. If you wish to display a markup tag literally, you can escape it by
<span class="gd">-        prepending a ``\\`` like for example ``\\&lt;blue&gt;``. If, for some reason, you need to escape a</span>
<span class="gi">+        prepending a ``\`` like for example ``\&lt;blue&gt;``. If, for some reason, you need to escape a</span>
<span class="w"> </span>        string programmatically, note that the regex used internally to parse markup tags is
<span class="gd">-        ``r&quot;\\\\?&lt;/?((?:[fb]g\\s)?[^&lt;&gt;\\s]*)&gt;&quot;``.</span>
<span class="gi">+        ``r&quot;\\?&lt;/?((?:[fb]g\s)?[^&lt;&gt;\s]*)&gt;&quot;``.</span>

<span class="w"> </span>        Note that when logging a message with ``opt(colors=True)``, color tags present in the
<span class="w"> </span>        formatting arguments (``args`` and ``kwargs``) are completely ignored. This is important if
<span class="gu">@@ -722,7 +776,239 @@ class Logger:</span>
<span class="w"> </span>        &gt;&gt;&gt; stream_object = RandomStream(seed=12345, threshold=0.25)
<span class="w"> </span>        &gt;&gt;&gt; logger.add(stream_object, level=&quot;INFO&quot;)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self._core.lock:</span>
<span class="gi">+            handler_id = self._core.handlers_count</span>
<span class="gi">+            self._core.handlers_count += 1</span>
<span class="gi">+</span>
<span class="gi">+        error_interceptor = ErrorInterceptor(catch, handler_id)</span>
<span class="gi">+</span>
<span class="gi">+        if colorize is None and serialize:</span>
<span class="gi">+            colorize = False</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(sink, (str, PathLike)):</span>
<span class="gi">+            path = sink</span>
<span class="gi">+            name = &quot;&#39;%s&#39;&quot; % path</span>
<span class="gi">+</span>
<span class="gi">+            if colorize is None:</span>
<span class="gi">+                colorize = False</span>
<span class="gi">+</span>
<span class="gi">+            wrapped_sink = FileSink(path, **kwargs)</span>
<span class="gi">+            kwargs = {}</span>
<span class="gi">+            encoding = wrapped_sink.encoding</span>
<span class="gi">+            terminator = &quot;\n&quot;</span>
<span class="gi">+            exception_prefix = &quot;&quot;</span>
<span class="gi">+        elif hasattr(sink, &quot;write&quot;) and callable(sink.write):</span>
<span class="gi">+            name = getattr(sink, &quot;name&quot;, None) or repr(sink)</span>
<span class="gi">+</span>
<span class="gi">+            if colorize is None:</span>
<span class="gi">+                colorize = _colorama.should_colorize(sink)</span>
<span class="gi">+</span>
<span class="gi">+            if colorize is True and _colorama.should_wrap(sink):</span>
<span class="gi">+                stream = _colorama.wrap(sink)</span>
<span class="gi">+            else:</span>
<span class="gi">+                stream = sink</span>
<span class="gi">+</span>
<span class="gi">+            wrapped_sink = StreamSink(stream)</span>
<span class="gi">+            encoding = getattr(sink, &quot;encoding&quot;, None)</span>
<span class="gi">+            terminator = &quot;\n&quot;</span>
<span class="gi">+            exception_prefix = &quot;&quot;</span>
<span class="gi">+        elif isinstance(sink, logging.Handler):</span>
<span class="gi">+            name = repr(sink)</span>
<span class="gi">+</span>
<span class="gi">+            if colorize is None:</span>
<span class="gi">+                colorize = False</span>
<span class="gi">+</span>
<span class="gi">+            wrapped_sink = StandardSink(sink)</span>
<span class="gi">+            encoding = getattr(sink, &quot;encoding&quot;, None)</span>
<span class="gi">+            terminator = &quot;&quot;</span>
<span class="gi">+            exception_prefix = &quot;\n&quot;</span>
<span class="gi">+        elif iscoroutinefunction(sink) or iscoroutinefunction(</span>
<span class="gi">+            getattr(sink, &quot;__call__&quot;, None)  # noqa: B004</span>
<span class="gi">+        ):</span>
<span class="gi">+            name = getattr(sink, &quot;__name__&quot;, None) or repr(sink)</span>
<span class="gi">+</span>
<span class="gi">+            if colorize is None:</span>
<span class="gi">+                colorize = False</span>
<span class="gi">+</span>
<span class="gi">+            loop = kwargs.pop(&quot;loop&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+            # The worker thread needs an event loop, it can&#39;t create a new one internally because it</span>
<span class="gi">+            # has to be accessible by the user while calling &quot;complete()&quot;, instead we use the global</span>
<span class="gi">+            # one when the sink is added. If &quot;enqueue=False&quot; the event loop is dynamically retrieved</span>
<span class="gi">+            # at each logging call, which is much more convenient. However, coroutine can&#39;t access</span>
<span class="gi">+            # running loop in Python 3.5.2 and earlier versions, see python/asyncio#452.</span>
<span class="gi">+            if enqueue and loop is None:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    loop = _asyncio_loop.get_running_loop()</span>
<span class="gi">+                except RuntimeError as e:</span>
<span class="gi">+                    raise ValueError(</span>
<span class="gi">+                        &quot;An event loop is required to add a coroutine sink with `enqueue=True`, &quot;</span>
<span class="gi">+                        &quot;but none has been passed as argument and none is currently running.&quot;</span>
<span class="gi">+                    ) from e</span>
<span class="gi">+</span>
<span class="gi">+            coro = sink if iscoroutinefunction(sink) else sink.__call__</span>
<span class="gi">+            wrapped_sink = AsyncSink(coro, loop, error_interceptor)</span>
<span class="gi">+            encoding = &quot;utf8&quot;</span>
<span class="gi">+            terminator = &quot;\n&quot;</span>
<span class="gi">+            exception_prefix = &quot;&quot;</span>
<span class="gi">+        elif callable(sink):</span>
<span class="gi">+            name = getattr(sink, &quot;__name__&quot;, None) or repr(sink)</span>
<span class="gi">+</span>
<span class="gi">+            if colorize is None:</span>
<span class="gi">+                colorize = False</span>
<span class="gi">+</span>
<span class="gi">+            wrapped_sink = CallableSink(sink)</span>
<span class="gi">+            encoding = &quot;utf8&quot;</span>
<span class="gi">+            terminator = &quot;\n&quot;</span>
<span class="gi">+            exception_prefix = &quot;&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(&quot;Cannot log to objects of type &#39;%s&#39;&quot; % type(sink).__name__)</span>
<span class="gi">+</span>
<span class="gi">+        if kwargs:</span>
<span class="gi">+            raise TypeError(&quot;add() got an unexpected keyword argument &#39;%s&#39;&quot; % next(iter(kwargs)))</span>
<span class="gi">+</span>
<span class="gi">+        if filter is None:</span>
<span class="gi">+            filter_func = None</span>
<span class="gi">+        elif filter == &quot;&quot;:</span>
<span class="gi">+            filter_func = _filters.filter_none</span>
<span class="gi">+        elif isinstance(filter, str):</span>
<span class="gi">+            parent = filter + &quot;.&quot;</span>
<span class="gi">+            length = len(parent)</span>
<span class="gi">+            filter_func = functools.partial(_filters.filter_by_name, parent=parent, length=length)</span>
<span class="gi">+        elif isinstance(filter, dict):</span>
<span class="gi">+            level_per_module = {}</span>
<span class="gi">+            for module, level_ in filter.items():</span>
<span class="gi">+                if module is not None and not isinstance(module, str):</span>
<span class="gi">+                    raise TypeError(</span>
<span class="gi">+                        &quot;The filter dict contains an invalid module, &quot;</span>
<span class="gi">+                        &quot;it should be a string (or None), not: &#39;%s&#39;&quot; % type(module).__name__</span>
<span class="gi">+                    )</span>
<span class="gi">+                if level_ is False:</span>
<span class="gi">+                    levelno_ = False</span>
<span class="gi">+                elif level_ is True:</span>
<span class="gi">+                    levelno_ = 0</span>
<span class="gi">+                elif isinstance(level_, str):</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        levelno_ = self.level(level_).no</span>
<span class="gi">+                    except ValueError:</span>
<span class="gi">+                        raise ValueError(</span>
<span class="gi">+                            &quot;The filter dict contains a module &#39;%s&#39; associated to a level name &quot;</span>
<span class="gi">+                            &quot;which does not exist: &#39;%s&#39;&quot; % (module, level_)</span>
<span class="gi">+                        ) from None</span>
<span class="gi">+                elif isinstance(level_, int):</span>
<span class="gi">+                    levelno_ = level_</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise TypeError(</span>
<span class="gi">+                        &quot;The filter dict contains a module &#39;%s&#39; associated to an invalid level, &quot;</span>
<span class="gi">+                        &quot;it should be an integer, a string or a boolean, not: &#39;%s&#39;&quot;</span>
<span class="gi">+                        % (module, type(level_).__name__)</span>
<span class="gi">+                    )</span>
<span class="gi">+                if levelno_ &lt; 0:</span>
<span class="gi">+                    raise ValueError(</span>
<span class="gi">+                        &quot;The filter dict contains a module &#39;%s&#39; associated to an invalid level, &quot;</span>
<span class="gi">+                        &quot;it should be a positive integer, not: &#39;%d&#39;&quot; % (module, levelno_)</span>
<span class="gi">+                    )</span>
<span class="gi">+                level_per_module[module] = levelno_</span>
<span class="gi">+            filter_func = functools.partial(</span>
<span class="gi">+                _filters.filter_by_level, level_per_module=level_per_module</span>
<span class="gi">+            )</span>
<span class="gi">+        elif callable(filter):</span>
<span class="gi">+            if filter == builtins.filter:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    &quot;The built-in &#39;filter()&#39; function cannot be used as a &#39;filter&#39; parameter, &quot;</span>
<span class="gi">+                    &quot;this is most likely a mistake (please double-check the arguments passed &quot;</span>
<span class="gi">+                    &quot;to &#39;logger.add()&#39;).&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            filter_func = filter</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                &quot;Invalid filter, it should be a function, a string or a dict, not: &#39;%s&#39;&quot;</span>
<span class="gi">+                % type(filter).__name__</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(level, str):</span>
<span class="gi">+            levelno = self.level(level).no</span>
<span class="gi">+        elif isinstance(level, int):</span>
<span class="gi">+            levelno = level</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                &quot;Invalid level, it should be an integer or a string, not: &#39;%s&#39;&quot;</span>
<span class="gi">+                % type(level).__name__</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if levelno &lt; 0:</span>
<span class="gi">+            raise ValueError(</span>
<span class="gi">+                &quot;Invalid level value, it should be a positive integer, not: %d&quot; % levelno</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(format, str):</span>
<span class="gi">+            try:</span>
<span class="gi">+                formatter = Colorizer.prepare_format(format + terminator + &quot;{exception}&quot;)</span>
<span class="gi">+            except ValueError as e:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    &quot;Invalid format, color markups could not be parsed correctly&quot;</span>
<span class="gi">+                ) from e</span>
<span class="gi">+            is_formatter_dynamic = False</span>
<span class="gi">+        elif callable(format):</span>
<span class="gi">+            if format == builtins.format:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    &quot;The built-in &#39;format()&#39; function cannot be used as a &#39;format&#39; parameter, &quot;</span>
<span class="gi">+                    &quot;this is most likely a mistake (please double-check the arguments passed &quot;</span>
<span class="gi">+                    &quot;to &#39;logger.add()&#39;).&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            formatter = format</span>
<span class="gi">+            is_formatter_dynamic = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                &quot;Invalid format, it should be a string or a function, not: &#39;%s&#39;&quot;</span>
<span class="gi">+                % type(format).__name__</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(encoding, str):</span>
<span class="gi">+            encoding = &quot;ascii&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(context, str):</span>
<span class="gi">+            context = get_context(context)</span>
<span class="gi">+        elif context is not None and not isinstance(context, BaseContext):</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                &quot;Invalid context, it should be a string or a multiprocessing context, &quot;</span>
<span class="gi">+                &quot;not: &#39;%s&#39;&quot; % type(context).__name__</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        with self._core.lock:</span>
<span class="gi">+            exception_formatter = ExceptionFormatter(</span>
<span class="gi">+                colorize=colorize,</span>
<span class="gi">+                encoding=encoding,</span>
<span class="gi">+                diagnose=diagnose,</span>
<span class="gi">+                backtrace=backtrace,</span>
<span class="gi">+                hidden_frames_filename=self.catch.__code__.co_filename,</span>
<span class="gi">+                prefix=exception_prefix,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            handler = Handler(</span>
<span class="gi">+                name=name,</span>
<span class="gi">+                sink=wrapped_sink,</span>
<span class="gi">+                levelno=levelno,</span>
<span class="gi">+                formatter=formatter,</span>
<span class="gi">+                is_formatter_dynamic=is_formatter_dynamic,</span>
<span class="gi">+                filter_=filter_func,</span>
<span class="gi">+                colorize=colorize,</span>
<span class="gi">+                serialize=serialize,</span>
<span class="gi">+                enqueue=enqueue,</span>
<span class="gi">+                multiprocessing_context=context,</span>
<span class="gi">+                id_=handler_id,</span>
<span class="gi">+                error_interceptor=error_interceptor,</span>
<span class="gi">+                exception_formatter=exception_formatter,</span>
<span class="gi">+                levels_ansi_codes=self._core.levels_ansi_codes,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            handlers = self._core.handlers.copy()</span>
<span class="gi">+            handlers[handler_id] = handler</span>
<span class="gi">+</span>
<span class="gi">+            self._core.min_level = min(self._core.min_level, levelno)</span>
<span class="gi">+            self._core.handlers = handlers</span>
<span class="gi">+</span>
<span class="gi">+        return handler_id</span>

<span class="w"> </span>    def remove(self, handler_id=None):
<span class="w"> </span>        &quot;&quot;&quot;Remove a previously added handler and stop sending logs to its sink.
<span class="gu">@@ -746,7 +1032,32 @@ class Logger:</span>
<span class="w"> </span>        &gt;&gt;&gt; logger.remove(i)
<span class="w"> </span>        &gt;&gt;&gt; logger.info(&quot;No longer logging&quot;)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not (handler_id is None or isinstance(handler_id, int)):</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                &quot;Invalid handler id, it should be an integer as returned &quot;</span>
<span class="gi">+                &quot;by the &#39;add()&#39; method (or None), not: &#39;%s&#39;&quot; % type(handler_id).__name__</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        with self._core.lock:</span>
<span class="gi">+            handlers = self._core.handlers.copy()</span>
<span class="gi">+</span>
<span class="gi">+            if handler_id is not None and handler_id not in handlers:</span>
<span class="gi">+                raise ValueError(&quot;There is no existing handler with id %d&quot; % handler_id) from None</span>
<span class="gi">+</span>
<span class="gi">+            if handler_id is None:</span>
<span class="gi">+                handler_ids = list(handlers.keys())</span>
<span class="gi">+            else:</span>
<span class="gi">+                handler_ids = [handler_id]</span>
<span class="gi">+</span>
<span class="gi">+            for handler_id in handler_ids:</span>
<span class="gi">+                handler = handlers.pop(handler_id)</span>
<span class="gi">+</span>
<span class="gi">+                # This needs to be done first in case &quot;stop()&quot; raises an exception</span>
<span class="gi">+                levelnos = (h.levelno for h in handlers.values())</span>
<span class="gi">+                self._core.min_level = min(levelnos, default=float(&quot;inf&quot;))</span>
<span class="gi">+                self._core.handlers = handlers</span>
<span class="gi">+</span>
<span class="gi">+                handler.stop()</span>

<span class="w"> </span>    def complete(self):
<span class="w"> </span>        &quot;&quot;&quot;Wait for the end of enqueued messages and asynchronous tasks scheduled by handlers.
<span class="gu">@@ -798,12 +1109,34 @@ class Logger:</span>
<span class="w"> </span>        &gt;&gt;&gt; process.join()
<span class="w"> </span>        Message sent from the child
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def catch(self, exception=Exception, *, level=&#39;ERROR&#39;, reraise=False,</span>
<span class="gd">-        onerror=None, exclude=None, default=None, message=</span>
<span class="gd">-        &quot;An error has been caught in function &#39;{record[function]}&#39;, process &#39;{record[process].name}&#39; ({record[process].id}), thread &#39;{record[thread].name}&#39; ({record[thread].id}):&quot;</span>
<span class="gd">-        ):</span>
<span class="gi">+        tasks = []</span>
<span class="gi">+</span>
<span class="gi">+        with self._core.lock:</span>
<span class="gi">+            handlers = self._core.handlers.copy()</span>
<span class="gi">+            for handler in handlers.values():</span>
<span class="gi">+                handler.complete_queue()</span>
<span class="gi">+                tasks.extend(handler.tasks_to_complete())</span>
<span class="gi">+</span>
<span class="gi">+        class AwaitableCompleter:</span>
<span class="gi">+            def __await__(self):</span>
<span class="gi">+                for task in tasks:</span>
<span class="gi">+                    yield from task.__await__()</span>
<span class="gi">+</span>
<span class="gi">+        return AwaitableCompleter()</span>
<span class="gi">+</span>
<span class="gi">+    def catch(</span>
<span class="gi">+        self,</span>
<span class="gi">+        exception=Exception,</span>
<span class="gi">+        *,</span>
<span class="gi">+        level=&quot;ERROR&quot;,</span>
<span class="gi">+        reraise=False,</span>
<span class="gi">+        onerror=None,</span>
<span class="gi">+        exclude=None,</span>
<span class="gi">+        default=None,</span>
<span class="gi">+        message=&quot;An error has been caught in function &#39;{record[function]}&#39;, &quot;</span>
<span class="gi">+        &quot;process &#39;{record[process].name}&#39; ({record[process].id}), &quot;</span>
<span class="gi">+        &quot;thread &#39;{record[thread].name}&#39; ({record[thread].id}):&quot;</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Return a decorator to automatically log possibly caught error in wrapped function.

<span class="w"> </span>        This is useful to ensure unexpected exceptions are logged, the entire program can be
<span class="gu">@@ -876,11 +1209,92 @@ class Logger:</span>
<span class="w"> </span>        ... def main():
<span class="w"> </span>        ...     1 / 0
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if callable(exception) and (</span>
<span class="gi">+            not isclass(exception) or not issubclass(exception, BaseException)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return self.catch()(exception)</span>
<span class="gi">+</span>
<span class="gi">+        logger = self</span>
<span class="gi">+</span>
<span class="gi">+        class Catcher:</span>
<span class="gi">+            def __init__(self, from_decorator):</span>
<span class="gi">+                self._from_decorator = from_decorator</span>
<span class="gi">+</span>
<span class="gi">+            def __enter__(self):</span>
<span class="gi">+                return None</span>
<span class="gi">+</span>
<span class="gi">+            def __exit__(self, type_, value, traceback_):</span>
<span class="gi">+                if type_ is None:</span>
<span class="gi">+                    return</span>
<span class="gi">+</span>
<span class="gi">+                if not issubclass(type_, exception):</span>
<span class="gi">+                    return False</span>
<span class="gi">+</span>
<span class="gi">+                if exclude is not None and issubclass(type_, exclude):</span>
<span class="gi">+                    return False</span>
<span class="gi">+</span>
<span class="gi">+                from_decorator = self._from_decorator</span>
<span class="gi">+                _, depth, _, *options = logger._options</span>
<span class="gi">+</span>
<span class="gi">+                if from_decorator:</span>
<span class="gi">+                    depth += 1</span>
<span class="gi">+</span>
<span class="gi">+                catch_options = [(type_, value, traceback_), depth, True] + options</span>
<span class="gi">+                logger._log(level, from_decorator, catch_options, message, (), {})</span>
<span class="gi">+</span>
<span class="gi">+                if onerror is not None:</span>
<span class="gi">+                    onerror(value)</span>
<span class="gi">+</span>
<span class="gi">+                return not reraise</span>
<span class="gi">+</span>
<span class="gi">+            def __call__(self, function):</span>
<span class="gi">+                if isclass(function):</span>
<span class="gi">+                    raise TypeError(</span>
<span class="gi">+                        &quot;Invalid object decorated with &#39;catch()&#39;, it must be a function, &quot;</span>
<span class="gi">+                        &quot;not a class (tried to wrap &#39;%s&#39;)&quot; % function.__name__</span>
<span class="gi">+                    )</span>

<span class="gd">-    def opt(self, *, exception=None, record=False, lazy=False, colors=False,</span>
<span class="gd">-        raw=False, capture=True, depth=0, ansi=False):</span>
<span class="gd">-        &quot;&quot;&quot;Parametrize a logging call to slightly change generated log message.</span>
<span class="gi">+                catcher = Catcher(True)</span>
<span class="gi">+</span>
<span class="gi">+                if iscoroutinefunction(function):</span>
<span class="gi">+</span>
<span class="gi">+                    async def catch_wrapper(*args, **kwargs):</span>
<span class="gi">+                        with catcher:</span>
<span class="gi">+                            return await function(*args, **kwargs)</span>
<span class="gi">+                        return default</span>
<span class="gi">+</span>
<span class="gi">+                elif isgeneratorfunction(function):</span>
<span class="gi">+</span>
<span class="gi">+                    def catch_wrapper(*args, **kwargs):</span>
<span class="gi">+                        with catcher:</span>
<span class="gi">+                            return (yield from function(*args, **kwargs))</span>
<span class="gi">+                        return default</span>
<span class="gi">+</span>
<span class="gi">+                else:</span>
<span class="gi">+</span>
<span class="gi">+                    def catch_wrapper(*args, **kwargs):</span>
<span class="gi">+                        with catcher:</span>
<span class="gi">+                            return function(*args, **kwargs)</span>
<span class="gi">+                        return default</span>
<span class="gi">+</span>
<span class="gi">+                functools.update_wrapper(catch_wrapper, function)</span>
<span class="gi">+                return catch_wrapper</span>
<span class="gi">+</span>
<span class="gi">+        return Catcher(False)</span>
<span class="gi">+</span>
<span class="gi">+    def opt(</span>
<span class="gi">+        self,</span>
<span class="gi">+        *,</span>
<span class="gi">+        exception=None,</span>
<span class="gi">+        record=False,</span>
<span class="gi">+        lazy=False,</span>
<span class="gi">+        colors=False,</span>
<span class="gi">+        raw=False,</span>
<span class="gi">+        capture=True,</span>
<span class="gi">+        depth=0,</span>
<span class="gi">+        ansi=False</span>
<span class="gi">+    ):</span>
<span class="gi">+        r&quot;&quot;&quot;Parametrize a logging call to slightly change generated log message.</span>

<span class="w"> </span>        Note that it&#39;s not possible to chain |opt| calls, the last one takes precedence over the
<span class="w"> </span>        others as it will &quot;reset&quot; the options to their default values.
<span class="gu">@@ -942,7 +1356,7 @@ class Logger:</span>
<span class="w"> </span>        &gt;&gt;&gt; logger.opt(colors=True).warning(&quot;We got a &lt;red&gt;BIG&lt;/red&gt; problem&quot;)
<span class="w"> </span>        [18:11:30] WARNING in &#39;&lt;module&gt;&#39; - We got a BIG problem

<span class="gd">-        &gt;&gt;&gt; logger.opt(raw=True).debug(&quot;No formatting\\n&quot;)</span>
<span class="gi">+        &gt;&gt;&gt; logger.opt(raw=True).debug(&quot;No formatting\n&quot;)</span>
<span class="w"> </span>        No formatting

<span class="w"> </span>        &gt;&gt;&gt; logger.opt(capture=False).info(&quot;Displayed but not captured: {value}&quot;, value=123)
<span class="gu">@@ -957,9 +1371,18 @@ class Logger:</span>
<span class="w"> </span>        &gt;&gt;&gt; func()
<span class="w"> </span>        [18:11:54] DEBUG in &#39;func&#39; - Get parent context
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def bind(__self, **kwargs):</span>
<span class="gi">+        if ansi:</span>
<span class="gi">+            colors = True</span>
<span class="gi">+            warnings.warn(</span>
<span class="gi">+                &quot;The &#39;ansi&#39; parameter is deprecated, please use &#39;colors&#39; instead&quot;,</span>
<span class="gi">+                DeprecationWarning,</span>
<span class="gi">+                stacklevel=2,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        args = self._options[-2:]</span>
<span class="gi">+        return Logger(self._core, exception, depth, record, lazy, colors, raw, capture, *args)</span>
<span class="gi">+</span>
<span class="gi">+    def bind(__self, **kwargs):  # noqa: N805</span>
<span class="w"> </span>        &quot;&quot;&quot;Bind attributes to the ``extra`` dict of each logged message record.

<span class="w"> </span>        This is used to add custom context to each logging call.
<span class="gu">@@ -992,10 +1415,11 @@ class Logger:</span>
<span class="w"> </span>        &gt;&gt;&gt; instance_2.call(&quot;Second instance&quot;)
<span class="w"> </span>        127.0.0.1 - Second instance
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        *options, extra = __self._options</span>
<span class="gi">+        return Logger(__self._core, *options, {**extra, **kwargs})</span>

<span class="w"> </span>    @contextlib.contextmanager
<span class="gd">-    def contextualize(__self, **kwargs):</span>
<span class="gi">+    def contextualize(__self, **kwargs):  # noqa: N805</span>
<span class="w"> </span>        &quot;&quot;&quot;Bind attributes to the context-local ``extra`` dict while inside the ``with`` block.

<span class="w"> </span>        Contrary to |bind| there is no ``logger`` returned, the ``extra`` dict is modified in-place
<span class="gu">@@ -1029,7 +1453,15 @@ class Logger:</span>
<span class="w"> </span>        &gt;&gt;&gt; logger.info(&quot;Done.&quot;)
<span class="w"> </span>        Done. | {}
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with __self._core.lock:</span>
<span class="gi">+            new_context = {**context.get(), **kwargs}</span>
<span class="gi">+            token = context.set(new_context)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield</span>
<span class="gi">+        finally:</span>
<span class="gi">+            with __self._core.lock:</span>
<span class="gi">+                context.reset(token)</span>

<span class="w"> </span>    def patch(self, patcher):
<span class="w"> </span>        &quot;&quot;&quot;Attach a function to modify the record dict created by each logging call.
<span class="gu">@@ -1077,7 +1509,8 @@ class Logger:</span>
<span class="w"> </span>        ...     level, message = record[&quot;level&quot;], record[&quot;message&quot;]
<span class="w"> </span>        ...     logger.patch(lambda r: r.update(record)).log(level, message)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        *options, patchers, extra = self._options</span>
<span class="gi">+        return Logger(self._core, *options, patchers + [patcher], extra)</span>

<span class="w"> </span>    def level(self, name, no=None, color=None, icon=None):
<span class="w"> </span>        &quot;&quot;&quot;Add, update or retrieve a logging level.
<span class="gu">@@ -1132,7 +1565,55 @@ class Logger:</span>
<span class="w"> </span>        &gt;&gt;&gt; logger.warning(&quot;Updated!&quot;)
<span class="w"> </span>        30 /!\\ Updated!
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(name, str):</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                &quot;Invalid level name, it should be a string, not: &#39;%s&#39;&quot; % type(name).__name__</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if no is color is icon is None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return self._core.levels[name]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                raise ValueError(&quot;Level &#39;%s&#39; does not exist&quot; % name) from None</span>
<span class="gi">+</span>
<span class="gi">+        if name not in self._core.levels:</span>
<span class="gi">+            if no is None:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    &quot;Level &#39;%s&#39; does not exist, you have to create it by specifying a level no&quot;</span>
<span class="gi">+                    % name</span>
<span class="gi">+                )</span>
<span class="gi">+            else:</span>
<span class="gi">+                old_color, old_icon = &quot;&quot;, &quot; &quot;</span>
<span class="gi">+        elif no is not None:</span>
<span class="gi">+            raise TypeError(&quot;Level &#39;%s&#39; already exists, you can&#39;t update its severity no&quot; % name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            _, no, old_color, old_icon = self.level(name)</span>
<span class="gi">+</span>
<span class="gi">+        if color is None:</span>
<span class="gi">+            color = old_color</span>
<span class="gi">+</span>
<span class="gi">+        if icon is None:</span>
<span class="gi">+            icon = old_icon</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(no, int):</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                &quot;Invalid level no, it should be an integer, not: &#39;%s&#39;&quot; % type(no).__name__</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if no &lt; 0:</span>
<span class="gi">+            raise ValueError(&quot;Invalid level no, it should be a positive integer, not: %d&quot; % no)</span>
<span class="gi">+</span>
<span class="gi">+        ansi = Colorizer.ansify(color)</span>
<span class="gi">+        level = Level(name, no, color, icon)</span>
<span class="gi">+</span>
<span class="gi">+        with self._core.lock:</span>
<span class="gi">+            self._core.levels[name] = level</span>
<span class="gi">+            self._core.levels_ansi_codes[name] = ansi</span>
<span class="gi">+            self._core.levels_lookup[name] = (name, name, no, icon)</span>
<span class="gi">+            for handler in self._core.handlers.values():</span>
<span class="gi">+                handler.update_format(name)</span>
<span class="gi">+</span>
<span class="gi">+        return level</span>

<span class="w"> </span>    def disable(self, name):
<span class="w"> </span>        &quot;&quot;&quot;Disable logging of messages coming from ``name`` module and its children.
<span class="gu">@@ -1156,7 +1637,7 @@ class Logger:</span>
<span class="w"> </span>        &gt;&gt;&gt; logger.disable(&quot;my_library&quot;)
<span class="w"> </span>        &gt;&gt;&gt; logger.info(&quot;While publishing a library, don&#39;t forget to disable logging&quot;)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._change_activation(name, False)</span>

<span class="w"> </span>    def enable(self, name):
<span class="w"> </span>        &quot;&quot;&quot;Enable logging of messages coming from ``name`` module and its children.
<span class="gu">@@ -1180,10 +1661,9 @@ class Logger:</span>
<span class="w"> </span>        &gt;&gt;&gt; logger.info(&quot;Re-enabled, messages are logged.&quot;)
<span class="w"> </span>        [22:46:12] Re-enabled, messages are logged.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self._change_activation(name, True)</span>

<span class="gd">-    def configure(self, *, handlers=None, levels=None, extra=None, patcher=</span>
<span class="gd">-        None, activation=None):</span>
<span class="gi">+    def configure(self, *, handlers=None, levels=None, extra=None, patcher=None, activation=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Configure the core logger.

<span class="w"> </span>        It should be noted that ``extra`` values set using this function are available across all
<span class="gu">@@ -1246,10 +1726,75 @@ class Logger:</span>
<span class="w"> </span>        &gt;&gt;&gt; logger.bind(context=&quot;bar&quot;).info(&quot;Suppress global context&quot;)
<span class="w"> </span>        &gt;&gt;&gt; # =&gt; &quot;bar - Suppress global context&quot;
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if handlers is not None:</span>
<span class="gi">+            self.remove()</span>
<span class="gi">+        else:</span>
<span class="gi">+            handlers = []</span>
<span class="gi">+</span>
<span class="gi">+        if levels is not None:</span>
<span class="gi">+            for params in levels:</span>
<span class="gi">+                self.level(**params)</span>
<span class="gi">+</span>
<span class="gi">+        if patcher is not None:</span>
<span class="gi">+            with self._core.lock:</span>
<span class="gi">+                self._core.patcher = patcher</span>
<span class="gi">+</span>
<span class="gi">+        if extra is not None:</span>
<span class="gi">+            with self._core.lock:</span>
<span class="gi">+                self._core.extra.clear()</span>
<span class="gi">+                self._core.extra.update(extra)</span>
<span class="gi">+</span>
<span class="gi">+        if activation is not None:</span>
<span class="gi">+            for name, state in activation:</span>
<span class="gi">+                if state:</span>
<span class="gi">+                    self.enable(name)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self.disable(name)</span>
<span class="gi">+</span>
<span class="gi">+        return [self.add(**params) for params in handlers]</span>
<span class="gi">+</span>
<span class="gi">+    def _change_activation(self, name, status):</span>
<span class="gi">+        if not (name is None or isinstance(name, str)):</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                &quot;Invalid name, it should be a string (or None), not: &#39;%s&#39;&quot; % type(name).__name__</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        with self._core.lock:</span>
<span class="gi">+            enabled = self._core.enabled.copy()</span>
<span class="gi">+</span>
<span class="gi">+            if name is None:</span>
<span class="gi">+                for n in enabled:</span>
<span class="gi">+                    if n is None:</span>
<span class="gi">+                        enabled[n] = status</span>
<span class="gi">+                self._core.activation_none = status</span>
<span class="gi">+                self._core.enabled = enabled</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            if name != &quot;&quot;:</span>
<span class="gi">+                name += &quot;.&quot;</span>
<span class="gi">+</span>
<span class="gi">+            activation_list = [</span>
<span class="gi">+                (n, s) for n, s in self._core.activation_list if n[: len(name)] != name</span>
<span class="gi">+            ]</span>
<span class="gi">+</span>
<span class="gi">+            parent_status = next((s for n, s in activation_list if name[: len(n)] == n), None)</span>
<span class="gi">+            if parent_status != status and not (name == &quot;&quot; and status is True):</span>
<span class="gi">+                activation_list.append((name, status))</span>
<span class="gi">+</span>
<span class="gi">+                def modules_depth(x):</span>
<span class="gi">+                    return x[0].count(&quot;.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+                activation_list.sort(key=modules_depth, reverse=True)</span>
<span class="gi">+</span>
<span class="gi">+            for n in enabled:</span>
<span class="gi">+                if n is not None and (n + &quot;.&quot;)[: len(name)] == name:</span>
<span class="gi">+                    enabled[n] = status</span>
<span class="gi">+</span>
<span class="gi">+            self._core.activation_list = activation_list</span>
<span class="gi">+            self._core.enabled = enabled</span>

<span class="w"> </span>    @staticmethod
<span class="gd">-    def parse(file, pattern, *, cast={}, chunk=2 ** 16):</span>
<span class="gi">+    def parse(file, pattern, *, cast={}, chunk=2**16):  # noqa: B006</span>
<span class="w"> </span>        &quot;&quot;&quot;Parse raw logs and extract each entry as a |dict|.

<span class="w"> </span>        The logging format has to be specified as the regex ``pattern``, it will then be
<span class="gu">@@ -1296,43 +1841,232 @@ class Logger:</span>
<span class="w"> </span>        ...     for log in logger.parse(file, reg, cast=cast):
<span class="w"> </span>        ...         print(log[&quot;date&quot;], log[&quot;something_else&quot;])
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def trace(__self, __message, *args, **kwargs):</span>
<span class="gd">-        &quot;&quot;&quot;Log ``message.format(*args, **kwargs)`` with severity ``&#39;TRACE&#39;``.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(file, (str, PathLike)):</span>
<span class="gi">+            should_close = True</span>
<span class="gi">+            fileobj = open(str(file))</span>
<span class="gi">+        elif hasattr(file, &quot;read&quot;) and callable(file.read):</span>
<span class="gi">+            should_close = False</span>
<span class="gi">+            fileobj = file</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                &quot;Invalid file, it should be a string path or a file object, not: &#39;%s&#39;&quot;</span>
<span class="gi">+                % type(file).__name__</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(cast, dict):</span>
<span class="gi">+</span>
<span class="gi">+            def cast_function(groups):</span>
<span class="gi">+                for key, converter in cast.items():</span>
<span class="gi">+                    if key in groups:</span>
<span class="gi">+                        groups[key] = converter(groups[key])</span>
<span class="gi">+</span>
<span class="gi">+        elif callable(cast):</span>
<span class="gi">+            cast_function = cast</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                &quot;Invalid cast, it should be a function or a dict, not: &#39;%s&#39;&quot; % type(cast).__name__</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            regex = re.compile(pattern)</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                &quot;Invalid pattern, it should be a string or a compiled regex, not: &#39;%s&#39;&quot;</span>
<span class="gi">+                % type(pattern).__name__</span>
<span class="gi">+            ) from None</span>
<span class="gi">+</span>
<span class="gi">+        matches = Logger._find_iter(fileobj, regex, chunk)</span>
<span class="gi">+</span>
<span class="gi">+        for match in matches:</span>
<span class="gi">+            groups = match.groupdict()</span>
<span class="gi">+            cast_function(groups)</span>
<span class="gi">+            yield groups</span>
<span class="gi">+</span>
<span class="gi">+        if should_close:</span>
<span class="gi">+            fileobj.close()</span>

<span class="gd">-    def debug(__self, __message, *args, **kwargs):</span>
<span class="gd">-        &quot;&quot;&quot;Log ``message.format(*args, **kwargs)`` with severity ``&#39;DEBUG&#39;``.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def info(__self, __message, *args, **kwargs):</span>
<span class="gd">-        &quot;&quot;&quot;Log ``message.format(*args, **kwargs)`` with severity ``&#39;INFO&#39;``.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def success(__self, __message, *args, **kwargs):</span>
<span class="gd">-        &quot;&quot;&quot;Log ``message.format(*args, **kwargs)`` with severity ``&#39;SUCCESS&#39;``.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def warning(__self, __message, *args, **kwargs):</span>
<span class="gd">-        &quot;&quot;&quot;Log ``message.format(*args, **kwargs)`` with severity ``&#39;WARNING&#39;``.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def error(__self, __message, *args, **kwargs):</span>
<span class="gd">-        &quot;&quot;&quot;Log ``message.format(*args, **kwargs)`` with severity ``&#39;ERROR&#39;``.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def critical(__self, __message, *args, **kwargs):</span>
<span class="gd">-        &quot;&quot;&quot;Log ``message.format(*args, **kwargs)`` with severity ``&#39;CRITICAL&#39;``.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def exception(__self, __message, *args, **kwargs):</span>
<span class="gd">-        &quot;&quot;&quot;Convenience method for logging an ``&#39;ERROR&#39;`` with exception information.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def log(__self, __level, __message, *args, **kwargs):</span>
<span class="gd">-        &quot;&quot;&quot;Log ``message.format(*args, **kwargs)`` with severity ``level``.&quot;&quot;&quot;</span>
<span class="gd">-        pass</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _find_iter(fileobj, regex, chunk):</span>
<span class="gi">+        buffer = fileobj.read(0)</span>
<span class="gi">+</span>
<span class="gi">+        while 1:</span>
<span class="gi">+            text = fileobj.read(chunk)</span>
<span class="gi">+            buffer += text</span>
<span class="gi">+            matches = list(regex.finditer(buffer))</span>
<span class="gi">+</span>
<span class="gi">+            if not text:</span>
<span class="gi">+                yield from matches</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            if len(matches) &gt; 1:</span>
<span class="gi">+                end = matches[-2].end()</span>
<span class="gi">+                buffer = buffer[end:]</span>
<span class="gi">+                yield from matches[:-1]</span>
<span class="gi">+</span>
<span class="gi">+    def _log(self, level, from_decorator, options, message, args, kwargs):</span>
<span class="gi">+        core = self._core</span>
<span class="gi">+</span>
<span class="gi">+        if not core.handlers:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            level_id, level_name, level_no, level_icon = core.levels_lookup[level]</span>
<span class="gi">+        except (KeyError, TypeError):</span>
<span class="gi">+            if isinstance(level, str):</span>
<span class="gi">+                raise ValueError(&quot;Level &#39;%s&#39; does not exist&quot; % level) from None</span>
<span class="gi">+            if not isinstance(level, int):</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    &quot;Invalid level, it should be an integer or a string, not: &#39;%s&#39;&quot;</span>
<span class="gi">+                    % type(level).__name__</span>
<span class="gi">+                ) from None</span>
<span class="gi">+            if level &lt; 0:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    &quot;Invalid level value, it should be a positive integer, not: %d&quot; % level</span>
<span class="gi">+                ) from None</span>
<span class="gi">+            cache = (None, &quot;Level %d&quot; % level, level, &quot; &quot;)</span>
<span class="gi">+            level_id, level_name, level_no, level_icon = cache</span>
<span class="gi">+            core.levels_lookup[level] = cache</span>
<span class="gi">+</span>
<span class="gi">+        if level_no &lt; core.min_level:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        (exception, depth, record, lazy, colors, raw, capture, patchers, extra) = options</span>
<span class="gi">+</span>
<span class="gi">+        frame = get_frame(depth + 2)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            name = frame.f_globals[&quot;__name__&quot;]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            name = None</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            if not core.enabled[name]:</span>
<span class="gi">+                return</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            enabled = core.enabled</span>
<span class="gi">+            if name is None:</span>
<span class="gi">+                status = core.activation_none</span>
<span class="gi">+                enabled[name] = status</span>
<span class="gi">+                if not status:</span>
<span class="gi">+                    return</span>
<span class="gi">+            else:</span>
<span class="gi">+                dotted_name = name + &quot;.&quot;</span>
<span class="gi">+                for dotted_module_name, status in core.activation_list:</span>
<span class="gi">+                    if dotted_name[: len(dotted_module_name)] == dotted_module_name:</span>
<span class="gi">+                        if status:</span>
<span class="gi">+                            break</span>
<span class="gi">+                        enabled[name] = False</span>
<span class="gi">+                        return</span>
<span class="gi">+                enabled[name] = True</span>
<span class="gi">+</span>
<span class="gi">+        current_datetime = aware_now()</span>
<span class="gi">+</span>
<span class="gi">+        code = frame.f_code</span>
<span class="gi">+        file_path = code.co_filename</span>
<span class="gi">+        file_name = basename(file_path)</span>
<span class="gi">+        thread = current_thread()</span>
<span class="gi">+        process = current_process()</span>
<span class="gi">+        elapsed = current_datetime - start_time</span>
<span class="gi">+</span>
<span class="gi">+        if exception:</span>
<span class="gi">+            if isinstance(exception, BaseException):</span>
<span class="gi">+                type_, value, traceback = (type(exception), exception, exception.__traceback__)</span>
<span class="gi">+            elif isinstance(exception, tuple):</span>
<span class="gi">+                type_, value, traceback = exception</span>
<span class="gi">+            else:</span>
<span class="gi">+                type_, value, traceback = sys.exc_info()</span>
<span class="gi">+            exception = RecordException(type_, value, traceback)</span>
<span class="gi">+        else:</span>
<span class="gi">+            exception = None</span>
<span class="gi">+</span>
<span class="gi">+        log_record = {</span>
<span class="gi">+            &quot;elapsed&quot;: elapsed,</span>
<span class="gi">+            &quot;exception&quot;: exception,</span>
<span class="gi">+            &quot;extra&quot;: {**core.extra, **context.get(), **extra},</span>
<span class="gi">+            &quot;file&quot;: RecordFile(file_name, file_path),</span>
<span class="gi">+            &quot;function&quot;: code.co_name,</span>
<span class="gi">+            &quot;level&quot;: RecordLevel(level_name, level_no, level_icon),</span>
<span class="gi">+            &quot;line&quot;: frame.f_lineno,</span>
<span class="gi">+            &quot;message&quot;: str(message),</span>
<span class="gi">+            &quot;module&quot;: splitext(file_name)[0],</span>
<span class="gi">+            &quot;name&quot;: name,</span>
<span class="gi">+            &quot;process&quot;: RecordProcess(process.ident, process.name),</span>
<span class="gi">+            &quot;thread&quot;: RecordThread(thread.ident, thread.name),</span>
<span class="gi">+            &quot;time&quot;: current_datetime,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        if lazy:</span>
<span class="gi">+            args = [arg() for arg in args]</span>
<span class="gi">+            kwargs = {key: value() for key, value in kwargs.items()}</span>
<span class="gi">+</span>
<span class="gi">+        if capture and kwargs:</span>
<span class="gi">+            log_record[&quot;extra&quot;].update(kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        if record:</span>
<span class="gi">+            if &quot;record&quot; in kwargs:</span>
<span class="gi">+                raise TypeError(</span>
<span class="gi">+                    &quot;The message can&#39;t be formatted: &#39;record&#39; shall not be used as a keyword &quot;</span>
<span class="gi">+                    &quot;argument while logger has been configured with &#39;.opt(record=True)&#39;&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            kwargs.update(record=log_record)</span>
<span class="gi">+</span>
<span class="gi">+        if colors:</span>
<span class="gi">+            if args or kwargs:</span>
<span class="gi">+                colored_message = Colorizer.prepare_message(message, args, kwargs)</span>
<span class="gi">+            else:</span>
<span class="gi">+                colored_message = Colorizer.prepare_simple_message(str(message))</span>
<span class="gi">+            log_record[&quot;message&quot;] = colored_message.stripped</span>
<span class="gi">+        elif args or kwargs:</span>
<span class="gi">+            colored_message = None</span>
<span class="gi">+            log_record[&quot;message&quot;] = message.format(*args, **kwargs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            colored_message = None</span>
<span class="gi">+</span>
<span class="gi">+        if core.patcher:</span>
<span class="gi">+            core.patcher(log_record)</span>
<span class="gi">+</span>
<span class="gi">+        for patcher in patchers:</span>
<span class="gi">+            patcher(log_record)</span>
<span class="gi">+</span>
<span class="gi">+        for handler in core.handlers.values():</span>
<span class="gi">+            handler.emit(log_record, level_id, from_decorator, raw, colored_message)</span>
<span class="gi">+</span>
<span class="gi">+    def trace(__self, __message, *args, **kwargs):  # noqa: N805</span>
<span class="gi">+        r&quot;&quot;&quot;Log ``message.format(*args, **kwargs)`` with severity ``&#39;TRACE&#39;``.&quot;&quot;&quot;</span>
<span class="gi">+        __self._log(&quot;TRACE&quot;, False, __self._options, __message, args, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def debug(__self, __message, *args, **kwargs):  # noqa: N805</span>
<span class="gi">+        r&quot;&quot;&quot;Log ``message.format(*args, **kwargs)`` with severity ``&#39;DEBUG&#39;``.&quot;&quot;&quot;</span>
<span class="gi">+        __self._log(&quot;DEBUG&quot;, False, __self._options, __message, args, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def info(__self, __message, *args, **kwargs):  # noqa: N805</span>
<span class="gi">+        r&quot;&quot;&quot;Log ``message.format(*args, **kwargs)`` with severity ``&#39;INFO&#39;``.&quot;&quot;&quot;</span>
<span class="gi">+        __self._log(&quot;INFO&quot;, False, __self._options, __message, args, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def success(__self, __message, *args, **kwargs):  # noqa: N805</span>
<span class="gi">+        r&quot;&quot;&quot;Log ``message.format(*args, **kwargs)`` with severity ``&#39;SUCCESS&#39;``.&quot;&quot;&quot;</span>
<span class="gi">+        __self._log(&quot;SUCCESS&quot;, False, __self._options, __message, args, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def warning(__self, __message, *args, **kwargs):  # noqa: N805</span>
<span class="gi">+        r&quot;&quot;&quot;Log ``message.format(*args, **kwargs)`` with severity ``&#39;WARNING&#39;``.&quot;&quot;&quot;</span>
<span class="gi">+        __self._log(&quot;WARNING&quot;, False, __self._options, __message, args, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def error(__self, __message, *args, **kwargs):  # noqa: N805</span>
<span class="gi">+        r&quot;&quot;&quot;Log ``message.format(*args, **kwargs)`` with severity ``&#39;ERROR&#39;``.&quot;&quot;&quot;</span>
<span class="gi">+        __self._log(&quot;ERROR&quot;, False, __self._options, __message, args, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def critical(__self, __message, *args, **kwargs):  # noqa: N805</span>
<span class="gi">+        r&quot;&quot;&quot;Log ``message.format(*args, **kwargs)`` with severity ``&#39;CRITICAL&#39;``.&quot;&quot;&quot;</span>
<span class="gi">+        __self._log(&quot;CRITICAL&quot;, False, __self._options, __message, args, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def exception(__self, __message, *args, **kwargs):  # noqa: N805</span>
<span class="gi">+        r&quot;&quot;&quot;Convenience method for logging an ``&#39;ERROR&#39;`` with exception information.&quot;&quot;&quot;</span>
<span class="gi">+        options = (True,) + __self._options[1:]</span>
<span class="gi">+        __self._log(&quot;ERROR&quot;, False, options, __message, args, kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def log(__self, __level, __message, *args, **kwargs):  # noqa: N805</span>
<span class="gi">+        r&quot;&quot;&quot;Log ``message.format(*args, **kwargs)`` with severity ``level``.&quot;&quot;&quot;</span>
<span class="gi">+        __self._log(__level, False, __self._options, __message, args, kwargs)</span>

<span class="w"> </span>    def start(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Deprecated function to |add| a new handler.
<span class="gu">@@ -1343,7 +2077,12 @@ class Logger:</span>
<span class="w"> </span>          ``start()`` will be removed in Loguru 1.0.0, it is replaced by ``add()`` which is a less
<span class="w"> </span>          confusing name.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;The &#39;start()&#39; method is deprecated, please use &#39;add()&#39; instead&quot;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+        return self.add(*args, **kwargs)</span>

<span class="w"> </span>    def stop(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Deprecated function to |remove| an existing handler.
<span class="gu">@@ -1354,4 +2093,9 @@ class Logger:</span>
<span class="w"> </span>          ``stop()`` will be removed in Loguru 1.0.0, it is replaced by ``remove()`` which is a less
<span class="w"> </span>          confusing name.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;The &#39;stop()&#39; method is deprecated, please use &#39;remove()&#39; instead&quot;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+        return self.remove(*args, **kwargs)</span>
<span class="gh">diff --git a/loguru/_recattrs.py b/loguru/_recattrs.py</span>
<span class="gh">index d344c9f..b09426e 100644</span>
<span class="gd">--- a/loguru/_recattrs.py</span>
<span class="gi">+++ b/loguru/_recattrs.py</span>
<span class="gu">@@ -3,7 +3,7 @@ from collections import namedtuple</span>


<span class="w"> </span>class RecordLevel:
<span class="gd">-    __slots__ = &#39;name&#39;, &#39;no&#39;, &#39;icon&#39;</span>
<span class="gi">+    __slots__ = (&quot;name&quot;, &quot;no&quot;, &quot;icon&quot;)</span>

<span class="w"> </span>    def __init__(self, name, no, icon):
<span class="w"> </span>        self.name = name
<span class="gu">@@ -11,66 +11,80 @@ class RecordLevel:</span>
<span class="w"> </span>        self.icon = icon

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;(name=%r, no=%r, icon=%r)&#39; % (self.name, self.no, self.icon)</span>
<span class="gi">+        return &quot;(name=%r, no=%r, icon=%r)&quot; % (self.name, self.no, self.icon)</span>

<span class="w"> </span>    def __format__(self, spec):
<span class="w"> </span>        return self.name.__format__(spec)


<span class="w"> </span>class RecordFile:
<span class="gd">-    __slots__ = &#39;name&#39;, &#39;path&#39;</span>
<span class="gi">+    __slots__ = (&quot;name&quot;, &quot;path&quot;)</span>

<span class="w"> </span>    def __init__(self, name, path):
<span class="w"> </span>        self.name = name
<span class="w"> </span>        self.path = path

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;(name=%r, path=%r)&#39; % (self.name, self.path)</span>
<span class="gi">+        return &quot;(name=%r, path=%r)&quot; % (self.name, self.path)</span>

<span class="w"> </span>    def __format__(self, spec):
<span class="w"> </span>        return self.name.__format__(spec)


<span class="w"> </span>class RecordThread:
<span class="gd">-    __slots__ = &#39;id&#39;, &#39;name&#39;</span>
<span class="gi">+    __slots__ = (&quot;id&quot;, &quot;name&quot;)</span>

<span class="w"> </span>    def __init__(self, id_, name):
<span class="w"> </span>        self.id = id_
<span class="w"> </span>        self.name = name

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;(id=%r, name=%r)&#39; % (self.id, self.name)</span>
<span class="gi">+        return &quot;(id=%r, name=%r)&quot; % (self.id, self.name)</span>

<span class="w"> </span>    def __format__(self, spec):
<span class="w"> </span>        return self.id.__format__(spec)


<span class="w"> </span>class RecordProcess:
<span class="gd">-    __slots__ = &#39;id&#39;, &#39;name&#39;</span>
<span class="gi">+    __slots__ = (&quot;id&quot;, &quot;name&quot;)</span>

<span class="w"> </span>    def __init__(self, id_, name):
<span class="w"> </span>        self.id = id_
<span class="w"> </span>        self.name = name

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;(id=%r, name=%r)&#39; % (self.id, self.name)</span>
<span class="gi">+        return &quot;(id=%r, name=%r)&quot; % (self.id, self.name)</span>

<span class="w"> </span>    def __format__(self, spec):
<span class="w"> </span>        return self.id.__format__(spec)


<span class="gd">-class RecordException(namedtuple(&#39;RecordException&#39;, (&#39;type&#39;, &#39;value&#39;,</span>
<span class="gd">-    &#39;traceback&#39;))):</span>
<span class="gd">-</span>
<span class="gi">+class RecordException(namedtuple(&quot;RecordException&quot;, (&quot;type&quot;, &quot;value&quot;, &quot;traceback&quot;))):</span>
<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return &#39;(type=%r, value=%r, traceback=%r)&#39; % (self.type, self.value,</span>
<span class="gd">-            self.traceback)</span>
<span class="gi">+        return &quot;(type=%r, value=%r, traceback=%r)&quot; % (self.type, self.value, self.traceback)</span>

<span class="w"> </span>    def __reduce__(self):
<span class="gi">+        # The traceback is not picklable, therefore it needs to be removed. Additionally, there&#39;s a</span>
<span class="gi">+        # possibility that the exception value is not picklable either. In such cases, we also need</span>
<span class="gi">+        # to remove it. This is done for user convenience, aiming to prevent error logging caused by</span>
<span class="gi">+        # custom exceptions from third-party libraries. If the serialization succeeds, we can reuse</span>
<span class="gi">+        # the pickled value later for optimization (so that it&#39;s not pickled twice). It&#39;s important</span>
<span class="gi">+        # to note that custom exceptions might not necessarily raise a PickleError, hence the</span>
<span class="gi">+        # generic Exception catch.</span>
<span class="w"> </span>        try:
<span class="w"> </span>            pickled_value = pickle.dumps(self.value)
<span class="w"> </span>        except Exception:
<span class="gd">-            return RecordException, (self.type, None, None)</span>
<span class="gi">+            return (RecordException, (self.type, None, None))</span>
<span class="gi">+        else:</span>
<span class="gi">+            return (RecordException._from_pickled_value, (self.type, pickled_value, None))</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def _from_pickled_value(cls, type_, pickled_value, traceback_):</span>
<span class="gi">+        try:</span>
<span class="gi">+            # It&#39;s safe to use &quot;pickle.loads()&quot; in this case because the pickled value is generated</span>
<span class="gi">+            # by the same code and is not coming from an untrusted source.</span>
<span class="gi">+            value = pickle.loads(pickled_value)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            return cls(type_, None, traceback_)</span>
<span class="w"> </span>        else:
<span class="gd">-            return RecordException._from_pickled_value, (self.type,</span>
<span class="gd">-                pickled_value, None)</span>
<span class="gi">+            return cls(type_, value, traceback_)</span>
<span class="gh">diff --git a/loguru/_simple_sinks.py b/loguru/_simple_sinks.py</span>
<span class="gh">index a21a218..068f1e1 100644</span>
<span class="gd">--- a/loguru/_simple_sinks.py</span>
<span class="gi">+++ b/loguru/_simple_sinks.py</span>
<span class="gu">@@ -1,36 +1,112 @@</span>
<span class="w"> </span>import asyncio
<span class="w"> </span>import logging
<span class="w"> </span>import weakref
<span class="gi">+</span>
<span class="w"> </span>from ._asyncio_loop import get_running_loop, get_task_loop


<span class="w"> </span>class StreamSink:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, stream):
<span class="w"> </span>        self._stream = stream
<span class="gd">-        self._flushable = callable(getattr(stream, &#39;flush&#39;, None))</span>
<span class="gd">-        self._stoppable = callable(getattr(stream, &#39;stop&#39;, None))</span>
<span class="gd">-        self._completable = asyncio.iscoroutinefunction(getattr(stream,</span>
<span class="gd">-            &#39;complete&#39;, None))</span>
<span class="gi">+        self._flushable = callable(getattr(stream, &quot;flush&quot;, None))</span>
<span class="gi">+        self._stoppable = callable(getattr(stream, &quot;stop&quot;, None))</span>
<span class="gi">+        self._completable = asyncio.iscoroutinefunction(getattr(stream, &quot;complete&quot;, None))</span>

<span class="gi">+    def write(self, message):</span>
<span class="gi">+        self._stream.write(message)</span>
<span class="gi">+        if self._flushable:</span>
<span class="gi">+            self._stream.flush()</span>

<span class="gd">-class StandardSink:</span>
<span class="gi">+    def stop(self):</span>
<span class="gi">+        if self._stoppable:</span>
<span class="gi">+            self._stream.stop()</span>

<span class="gi">+    def tasks_to_complete(self):</span>
<span class="gi">+        if not self._completable:</span>
<span class="gi">+            return []</span>
<span class="gi">+        return [self._stream.complete()]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+class StandardSink:</span>
<span class="w"> </span>    def __init__(self, handler):
<span class="w"> </span>        self._handler = handler

<span class="gi">+    def write(self, message):</span>
<span class="gi">+        record = message.record</span>
<span class="gi">+        message = str(message)</span>
<span class="gi">+        exc = record[&quot;exception&quot;]</span>
<span class="gi">+        record = logging.getLogger().makeRecord(</span>
<span class="gi">+            record[&quot;name&quot;],</span>
<span class="gi">+            record[&quot;level&quot;].no,</span>
<span class="gi">+            record[&quot;file&quot;].path,</span>
<span class="gi">+            record[&quot;line&quot;],</span>
<span class="gi">+            message,</span>
<span class="gi">+            (),</span>
<span class="gi">+            (exc.type, exc.value, exc.traceback) if exc else None,</span>
<span class="gi">+            record[&quot;function&quot;],</span>
<span class="gi">+            {&quot;extra&quot;: record[&quot;extra&quot;]},</span>
<span class="gi">+        )</span>
<span class="gi">+        if exc:</span>
<span class="gi">+            record.exc_text = &quot;\n&quot;</span>
<span class="gi">+        self._handler.handle(record)</span>
<span class="gi">+</span>
<span class="gi">+    def stop(self):</span>
<span class="gi">+        self._handler.close()</span>
<span class="gi">+</span>
<span class="gi">+    def tasks_to_complete(self):</span>
<span class="gi">+        return []</span>

<span class="gd">-class AsyncSink:</span>

<span class="gi">+class AsyncSink:</span>
<span class="w"> </span>    def __init__(self, function, loop, error_interceptor):
<span class="w"> </span>        self._function = function
<span class="w"> </span>        self._loop = loop
<span class="w"> </span>        self._error_interceptor = error_interceptor
<span class="w"> </span>        self._tasks = weakref.WeakSet()

<span class="gi">+    def write(self, message):</span>
<span class="gi">+        try:</span>
<span class="gi">+            loop = self._loop or get_running_loop()</span>
<span class="gi">+        except RuntimeError:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        coroutine = self._function(message)</span>
<span class="gi">+        task = loop.create_task(coroutine)</span>
<span class="gi">+</span>
<span class="gi">+        def check_exception(future):</span>
<span class="gi">+            if future.cancelled() or future.exception() is None:</span>
<span class="gi">+                return</span>
<span class="gi">+            if not self._error_interceptor.should_catch():</span>
<span class="gi">+                raise future.exception()</span>
<span class="gi">+            self._error_interceptor.print(message.record, exception=future.exception())</span>
<span class="gi">+</span>
<span class="gi">+        task.add_done_callback(check_exception)</span>
<span class="gi">+        self._tasks.add(task)</span>
<span class="gi">+</span>
<span class="gi">+    def stop(self):</span>
<span class="gi">+        for task in self._tasks:</span>
<span class="gi">+            task.cancel()</span>
<span class="gi">+</span>
<span class="gi">+    def tasks_to_complete(self):</span>
<span class="gi">+        # To avoid errors due to &quot;self._tasks&quot; being mutated while iterated, the</span>
<span class="gi">+        # &quot;tasks_to_complete()&quot; method must be protected by the same lock as &quot;write()&quot; (which</span>
<span class="gi">+        # happens to be the handler lock). However, the tasks must not be awaited while the lock is</span>
<span class="gi">+        # acquired as this could lead to a deadlock. Therefore, we first need to collect the tasks</span>
<span class="gi">+        # to complete, then return them so that they can be awaited outside of the lock.</span>
<span class="gi">+        return [self._complete_task(task) for task in self._tasks]</span>
<span class="gi">+</span>
<span class="gi">+    async def _complete_task(self, task):</span>
<span class="gi">+        loop = get_running_loop()</span>
<span class="gi">+        if get_task_loop(task) is not loop:</span>
<span class="gi">+            return</span>
<span class="gi">+        try:</span>
<span class="gi">+            await task</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            pass  # Handled in &quot;check_exception()&quot;</span>
<span class="gi">+</span>
<span class="w"> </span>    def __getstate__(self):
<span class="w"> </span>        state = self.__dict__.copy()
<span class="gd">-        state[&#39;_tasks&#39;] = None</span>
<span class="gi">+        state[&quot;_tasks&quot;] = None</span>
<span class="w"> </span>        return state

<span class="w"> </span>    def __setstate__(self, state):
<span class="gu">@@ -39,6 +115,14 @@ class AsyncSink:</span>


<span class="w"> </span>class CallableSink:
<span class="gd">-</span>
<span class="w"> </span>    def __init__(self, function):
<span class="w"> </span>        self._function = function
<span class="gi">+</span>
<span class="gi">+    def write(self, message):</span>
<span class="gi">+        self._function(message)</span>
<span class="gi">+</span>
<span class="gi">+    def stop(self):</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    def tasks_to_complete(self):</span>
<span class="gi">+        return []</span>
<span class="gh">diff --git a/loguru/_string_parsers.py b/loguru/_string_parsers.py</span>
<span class="gh">index 520211d..da00904 100644</span>
<span class="gd">--- a/loguru/_string_parsers.py</span>
<span class="gi">+++ b/loguru/_string_parsers.py</span>
<span class="gu">@@ -3,4 +3,185 @@ import re</span>


<span class="w"> </span>class Frequencies:
<span class="gd">-    pass</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def hourly(t):</span>
<span class="gi">+        dt = t + datetime.timedelta(hours=1)</span>
<span class="gi">+        return dt.replace(minute=0, second=0, microsecond=0)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def daily(t):</span>
<span class="gi">+        dt = t + datetime.timedelta(days=1)</span>
<span class="gi">+        return dt.replace(hour=0, minute=0, second=0, microsecond=0)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def weekly(t):</span>
<span class="gi">+        dt = t + datetime.timedelta(days=7 - t.weekday())</span>
<span class="gi">+        return dt.replace(hour=0, minute=0, second=0, microsecond=0)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def monthly(t):</span>
<span class="gi">+        if t.month == 12:</span>
<span class="gi">+            y, m = t.year + 1, 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            y, m = t.year, t.month + 1</span>
<span class="gi">+        return t.replace(year=y, month=m, day=1, hour=0, minute=0, second=0, microsecond=0)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def yearly(t):</span>
<span class="gi">+        y = t.year + 1</span>
<span class="gi">+        return t.replace(year=y, month=1, day=1, hour=0, minute=0, second=0, microsecond=0)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_size(size):</span>
<span class="gi">+    size = size.strip()</span>
<span class="gi">+    reg = re.compile(r&quot;([e\+\-\.\d]+)\s*([kmgtpezy])?(i)?(b)&quot;, flags=re.I)</span>
<span class="gi">+</span>
<span class="gi">+    match = reg.fullmatch(size)</span>
<span class="gi">+</span>
<span class="gi">+    if not match:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    s, u, i, b = match.groups()</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        s = float(s)</span>
<span class="gi">+    except ValueError as e:</span>
<span class="gi">+        raise ValueError(&quot;Invalid float value while parsing size: &#39;%s&#39;&quot; % s) from e</span>
<span class="gi">+</span>
<span class="gi">+    u = &quot;kmgtpezy&quot;.index(u.lower()) + 1 if u else 0</span>
<span class="gi">+    i = 1024 if i else 1000</span>
<span class="gi">+    b = {&quot;b&quot;: 8, &quot;B&quot;: 1}[b] if b else 1</span>
<span class="gi">+    size = s * i**u / b</span>
<span class="gi">+</span>
<span class="gi">+    return size</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_duration(duration):</span>
<span class="gi">+    duration = duration.strip()</span>
<span class="gi">+    reg = r&quot;(?:([e\+\-\.\d]+)\s*([a-z]+)[\s\,]*)&quot;</span>
<span class="gi">+</span>
<span class="gi">+    units = [</span>
<span class="gi">+        (&quot;y|years?&quot;, 31536000),</span>
<span class="gi">+        (&quot;months?&quot;, 2628000),</span>
<span class="gi">+        (&quot;w|weeks?&quot;, 604800),</span>
<span class="gi">+        (&quot;d|days?&quot;, 86400),</span>
<span class="gi">+        (&quot;h|hours?&quot;, 3600),</span>
<span class="gi">+        (&quot;min(?:ute)?s?&quot;, 60),</span>
<span class="gi">+        (&quot;s|sec(?:ond)?s?&quot;, 1),</span>
<span class="gi">+        (&quot;ms|milliseconds?&quot;, 0.001),</span>
<span class="gi">+        (&quot;us|microseconds?&quot;, 0.000001),</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    if not re.fullmatch(reg + &quot;+&quot;, duration, flags=re.I):</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    seconds = 0</span>
<span class="gi">+</span>
<span class="gi">+    for value, unit in re.findall(reg, duration, flags=re.I):</span>
<span class="gi">+        try:</span>
<span class="gi">+            value = float(value)</span>
<span class="gi">+        except ValueError as e:</span>
<span class="gi">+            raise ValueError(&quot;Invalid float value while parsing duration: &#39;%s&#39;&quot; % value) from e</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            unit = next(u for r, u in units if re.fullmatch(r, unit, flags=re.I))</span>
<span class="gi">+        except StopIteration:</span>
<span class="gi">+            raise ValueError(&quot;Invalid unit value while parsing duration: &#39;%s&#39;&quot; % unit) from None</span>
<span class="gi">+</span>
<span class="gi">+        seconds += value * unit</span>
<span class="gi">+</span>
<span class="gi">+    return datetime.timedelta(seconds=seconds)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_frequency(frequency):</span>
<span class="gi">+    frequencies = {</span>
<span class="gi">+        &quot;hourly&quot;: Frequencies.hourly,</span>
<span class="gi">+        &quot;daily&quot;: Frequencies.daily,</span>
<span class="gi">+        &quot;weekly&quot;: Frequencies.weekly,</span>
<span class="gi">+        &quot;monthly&quot;: Frequencies.monthly,</span>
<span class="gi">+        &quot;yearly&quot;: Frequencies.yearly,</span>
<span class="gi">+    }</span>
<span class="gi">+    frequency = frequency.strip().lower()</span>
<span class="gi">+    return frequencies.get(frequency, None)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_day(day):</span>
<span class="gi">+    days = {</span>
<span class="gi">+        &quot;monday&quot;: 0,</span>
<span class="gi">+        &quot;tuesday&quot;: 1,</span>
<span class="gi">+        &quot;wednesday&quot;: 2,</span>
<span class="gi">+        &quot;thursday&quot;: 3,</span>
<span class="gi">+        &quot;friday&quot;: 4,</span>
<span class="gi">+        &quot;saturday&quot;: 5,</span>
<span class="gi">+        &quot;sunday&quot;: 6,</span>
<span class="gi">+    }</span>
<span class="gi">+    day = day.strip().lower()</span>
<span class="gi">+    if day in days:</span>
<span class="gi">+        return days[day]</span>
<span class="gi">+    elif day.startswith(&quot;w&quot;) and day[1:].isdigit():</span>
<span class="gi">+        day = int(day[1:])</span>
<span class="gi">+        if not 0 &lt;= day &lt; 7:</span>
<span class="gi">+            raise ValueError(&quot;Invalid weekday value while parsing day (expected [0-6]): &#39;%d&#39;&quot; % day)</span>
<span class="gi">+    else:</span>
<span class="gi">+        day = None</span>
<span class="gi">+</span>
<span class="gi">+    return day</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_time(time):</span>
<span class="gi">+    time = time.strip()</span>
<span class="gi">+    reg = re.compile(r&quot;^[\d\.\:]+\s*(?:[ap]m)?$&quot;, flags=re.I)</span>
<span class="gi">+</span>
<span class="gi">+    if not reg.match(time):</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    formats = [</span>
<span class="gi">+        &quot;%H&quot;,</span>
<span class="gi">+        &quot;%H:%M&quot;,</span>
<span class="gi">+        &quot;%H:%M:%S&quot;,</span>
<span class="gi">+        &quot;%H:%M:%S.%f&quot;,</span>
<span class="gi">+        &quot;%I %p&quot;,</span>
<span class="gi">+        &quot;%I:%M %S&quot;,</span>
<span class="gi">+        &quot;%I:%M:%S %p&quot;,</span>
<span class="gi">+        &quot;%I:%M:%S.%f %p&quot;,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    for format_ in formats:</span>
<span class="gi">+        try:</span>
<span class="gi">+            dt = datetime.datetime.strptime(time, format_)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            return dt.time()</span>
<span class="gi">+</span>
<span class="gi">+    raise ValueError(&quot;Unrecognized format while parsing time: &#39;%s&#39;&quot; % time)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def parse_daytime(daytime):</span>
<span class="gi">+    daytime = daytime.strip()</span>
<span class="gi">+    reg = re.compile(r&quot;^(.*?)\s+at\s+(.*)$&quot;, flags=re.I)</span>
<span class="gi">+</span>
<span class="gi">+    match = reg.match(daytime)</span>
<span class="gi">+    if match:</span>
<span class="gi">+        day, time = match.groups()</span>
<span class="gi">+    else:</span>
<span class="gi">+        day = time = daytime</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        day = parse_day(day)</span>
<span class="gi">+        if match and day is None:</span>
<span class="gi">+            raise ValueError</span>
<span class="gi">+    except ValueError as e:</span>
<span class="gi">+        raise ValueError(&quot;Invalid day while parsing daytime: &#39;%s&#39;&quot; % day) from e</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        time = parse_time(time)</span>
<span class="gi">+        if match and time is None:</span>
<span class="gi">+            raise ValueError</span>
<span class="gi">+    except ValueError as e:</span>
<span class="gi">+        raise ValueError(&quot;Invalid time while parsing daytime: &#39;%s&#39;&quot; % time) from e</span>
<span class="gi">+</span>
<span class="gi">+    if day is None and time is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    return day, time</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>