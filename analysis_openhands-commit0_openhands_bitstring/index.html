
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis openhands commit0 openhands bitstring - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#openhands-bitstring" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis openhands commit0 openhands bitstring
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_openhands-commit0_openhands">back to OpenHands summary</a></p>
<h1 id="openhands-bitstring"><strong>OpenHands</strong>: bitstring</h1>
<h2 id="failed-to-run-pytests-for-test-tests">Failed to run pytests for test <code>tests</code></h2>
<div class="highlight"><pre><span></span><code>Pytest collection failure.
</code></pre></div>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/bitstring/bits.py b/bitstring/bits.py</span>
<span class="gh">index 41e6c7c..6925041 100644</span>
<span class="gd">--- a/bitstring/bits.py</span>
<span class="gi">+++ b/bitstring/bits.py</span>
<span class="gu">@@ -446,6 +446,331 @@ class Bits:</span>
<span class="w"> </span>        &quot;&quot;&quot;Reset the bitstring to have given unsigned int interpretation.&quot;&quot;&quot;
<span class="w"> </span>        pass

<span class="gi">+    def _setuintle(self, uint: int, length: Optional[int]=None) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Reset the bitstring to have given unsigned int interpretation in little-endian.&quot;&quot;&quot;</span>
<span class="gi">+        if length is None:</span>
<span class="gi">+            # Calculate the minimum number of bits needed</span>
<span class="gi">+            length = max(uint.bit_length(), 1)</span>
<span class="gi">+            if length % 8:</span>
<span class="gi">+                length += 8 - (length % 8)</span>
<span class="gi">+        if length % 8:</span>
<span class="gi">+            raise ValueError(&quot;Little-endian integers must be whole-byte. Length = {0} bits.&quot;.format(length))</span>
<span class="gi">+        if uint &lt; 0:</span>
<span class="gi">+            raise ValueError(&quot;Little-endian unsigned integer cannot be negative.&quot;)</span>
<span class="gi">+        if uint &gt;= (1 &lt;&lt; length):</span>
<span class="gi">+            raise ValueError(&quot;Little-endian unsigned integer is too large for length {0}.&quot;.format(length))</span>
<span class="gi">+        # Convert to bytes in little-endian order</span>
<span class="gi">+        num_bytes = length // 8</span>
<span class="gi">+        byte_data = uint.to_bytes(num_bytes, byteorder=&#39;little&#39;, signed=False)</span>
<span class="gi">+        self._setbytes(byte_data)</span>
<span class="gi">+</span>
<span class="gi">+    def _setintle(self, value: int, length: Optional[int]=None) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Reset the bitstring to have given signed int interpretation in little-endian.&quot;&quot;&quot;</span>
<span class="gi">+        if length is None:</span>
<span class="gi">+            # Calculate the minimum number of bits needed</span>
<span class="gi">+            length = max(value.bit_length() + 1, 1)  # +1 for sign bit</span>
<span class="gi">+            if length % 8:</span>
<span class="gi">+                length += 8 - (length % 8)</span>
<span class="gi">+        if length % 8:</span>
<span class="gi">+            raise ValueError(&quot;Little-endian integers must be whole-byte. Length = {0} bits.&quot;.format(length))</span>
<span class="gi">+        num_bytes = length // 8</span>
<span class="gi">+        try:</span>
<span class="gi">+            byte_data = value.to_bytes(num_bytes, byteorder=&#39;little&#39;, signed=True)</span>
<span class="gi">+        except OverflowError:</span>
<span class="gi">+            raise ValueError(&quot;Little-endian signed integer is too large for length {0}.&quot;.format(length))</span>
<span class="gi">+        self._setbytes(byte_data)</span>
<span class="gi">+</span>
<span class="gi">+    def _setfloatbe(self, value: float, length: Optional[int]=None) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Reset the bitstring to have given float interpretation in big-endian.&quot;&quot;&quot;</span>
<span class="gi">+        if length is None:</span>
<span class="gi">+            raise ValueError(&quot;A length must be specified with float initialisation.&quot;)</span>
<span class="gi">+        if length == 16:</span>
<span class="gi">+            fmt = &#39;&gt;e&#39;</span>
<span class="gi">+        elif length == 32:</span>
<span class="gi">+            fmt = &#39;&gt;f&#39;</span>
<span class="gi">+        elif length == 64:</span>
<span class="gi">+            fmt = &#39;&gt;d&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;float length must be 16, 32 or 64 bits.&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            byte_data = struct.pack(fmt, value)</span>
<span class="gi">+        except (struct.error, OverflowError):</span>
<span class="gi">+            raise ValueError(&quot;Float is too large for length {0}.&quot;.format(length))</span>
<span class="gi">+        self._setbytes(byte_data)</span>
<span class="gi">+</span>
<span class="gi">+    def _setfloatle(self, value: float, length: Optional[int]=None) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Reset the bitstring to have given float interpretation in little-endian.&quot;&quot;&quot;</span>
<span class="gi">+        if length is None:</span>
<span class="gi">+            raise ValueError(&quot;A length must be specified with float initialisation.&quot;)</span>
<span class="gi">+        if length == 16:</span>
<span class="gi">+            fmt = &#39;&lt;e&#39;</span>
<span class="gi">+        elif length == 32:</span>
<span class="gi">+            fmt = &#39;&lt;f&#39;</span>
<span class="gi">+        elif length == 64:</span>
<span class="gi">+            fmt = &#39;&lt;d&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&quot;float length must be 16, 32 or 64 bits.&quot;)</span>
<span class="gi">+        try:</span>
<span class="gi">+            byte_data = struct.pack(fmt, value)</span>
<span class="gi">+        except (struct.error, OverflowError):</span>
<span class="gi">+            raise ValueError(&quot;Float is too large for length {0}.&quot;.format(length))</span>
<span class="gi">+        self._setbytes(byte_data)</span>
<span class="gi">+</span>
<span class="gi">+    def _setbfloatbe(self, value: float, length: Optional[int]=None) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Reset the bitstring to have given bfloat interpretation in big-endian.&quot;&quot;&quot;</span>
<span class="gi">+        if length is not None and length != 16:</span>
<span class="gi">+            raise ValueError(&quot;bfloat must be 16 bits.&quot;)</span>
<span class="gi">+        # Convert to 32-bit float first</span>
<span class="gi">+        try:</span>
<span class="gi">+            byte_data = struct.pack(&#39;&gt;f&#39;, value)</span>
<span class="gi">+            # Take only the first two bytes (16 bits) for bfloat</span>
<span class="gi">+            self._setbytes(byte_data[:2])</span>
<span class="gi">+        except (struct.error, OverflowError):</span>
<span class="gi">+            raise ValueError(&quot;Float is too large for bfloat format.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _getbfloatbe(self) -&gt; float:</span>
<span class="gi">+        &quot;&quot;&quot;Return data as a bfloat in big-endian format.&quot;&quot;&quot;</span>
<span class="gi">+        if len(self) != 16:</span>
<span class="gi">+            raise bitstring.InterpretError(&quot;bfloat requires 16 bits.&quot;)</span>
<span class="gi">+        # Convert to 32-bit float by appending two zero bytes</span>
<span class="gi">+        byte_data = self._getbytes() + b&#39;\x00\x00&#39;</span>
<span class="gi">+        try:</span>
<span class="gi">+            return struct.unpack(&#39;&gt;f&#39;, byte_data)[0]</span>
<span class="gi">+        except struct.error:</span>
<span class="gi">+            raise bitstring.InterpretError(&quot;Cannot interpret as bfloat.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _setbfloatle(self, value: float, length: Optional[int]=None) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Reset the bitstring to have given bfloat interpretation in little-endian.&quot;&quot;&quot;</span>
<span class="gi">+        if length is not None and length != 16:</span>
<span class="gi">+            raise ValueError(&quot;bfloat must be 16 bits.&quot;)</span>
<span class="gi">+        # Convert to 32-bit float first</span>
<span class="gi">+        try:</span>
<span class="gi">+            byte_data = struct.pack(&#39;&lt;f&#39;, value)</span>
<span class="gi">+            # Take only the last two bytes (16 bits) for bfloat</span>
<span class="gi">+            self._setbytes(byte_data[2:])</span>
<span class="gi">+        except (struct.error, OverflowError):</span>
<span class="gi">+            raise ValueError(&quot;Float is too large for bfloat format.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _getbfloatle(self) -&gt; float:</span>
<span class="gi">+        &quot;&quot;&quot;Return data as a bfloat in little-endian format.&quot;&quot;&quot;</span>
<span class="gi">+        if len(self) != 16:</span>
<span class="gi">+            raise bitstring.InterpretError(&quot;bfloat requires 16 bits.&quot;)</span>
<span class="gi">+        # Convert to 32-bit float by prepending two zero bytes</span>
<span class="gi">+        byte_data = b&#39;\x00\x00&#39; + self._getbytes()</span>
<span class="gi">+        try:</span>
<span class="gi">+            return struct.unpack(&#39;&lt;f&#39;, byte_data)[0]</span>
<span class="gi">+        except struct.error:</span>
<span class="gi">+            raise bitstring.InterpretError(&quot;Cannot interpret as bfloat.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _setbits(self, bits: Bits, length: Optional[int]=None) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Reset the bitstring to have given bits interpretation.&quot;&quot;&quot;</span>
<span class="gi">+        if length is not None and len(bits) != length:</span>
<span class="gi">+            raise ValueError(&quot;Bits length {0} does not match required length {1}.&quot;.format(len(bits), length))</span>
<span class="gi">+        self._bitstore = bits._bitstore.copy()</span>
<span class="gi">+</span>
<span class="gi">+    def _getbits(self) -&gt; Bits:</span>
<span class="gi">+        &quot;&quot;&quot;Return data as a Bits object.&quot;&quot;&quot;</span>
<span class="gi">+        return self.copy()</span>
<span class="gi">+</span>
<span class="gi">+    def _setbool(self, value: bool, length: Optional[int]=None) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Reset the bitstring to have given bool interpretation.&quot;&quot;&quot;</span>
<span class="gi">+        if length is not None and length != 1:</span>
<span class="gi">+            raise ValueError(&quot;Boolean values must be 1 bit long.&quot;)</span>
<span class="gi">+        self._bitstore = BitStore(1)</span>
<span class="gi">+        self._bitstore.setall(1 if value else 0)</span>
<span class="gi">+</span>
<span class="gi">+    def _getbool(self) -&gt; bool:</span>
<span class="gi">+        &quot;&quot;&quot;Return data as a bool.&quot;&quot;&quot;</span>
<span class="gi">+        if len(self) != 1:</span>
<span class="gi">+            raise bitstring.InterpretError(&quot;Cannot interpret as bool: length must be 1 bit.&quot;)</span>
<span class="gi">+        return bool(self._bitstore.getindex(0))</span>
<span class="gi">+</span>
<span class="gi">+    def _setse(self, value: int, length: Optional[int]=None) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Reset the bitstring to have given signed exponential-Golomb code interpretation.&quot;&quot;&quot;</span>
<span class="gi">+        if length is not None:</span>
<span class="gi">+            raise ValueError(&quot;Length cannot be specified for signed exponential-Golomb codes.&quot;)</span>
<span class="gi">+        # Convert to unsigned by mapping negative values to positive ones</span>
<span class="gi">+        unsigned = (abs(value) &lt;&lt; 1) - (1 if value &gt; 0 else 0)</span>
<span class="gi">+        # Get the number of bits needed for the unsigned value</span>
<span class="gi">+        num_bits = unsigned.bit_length()</span>
<span class="gi">+        # Add leading zeros and the code</span>
<span class="gi">+        self._bitstore = BitStore(num_bits * 2 + 1)</span>
<span class="gi">+        self._bitstore.setall(0)</span>
<span class="gi">+        # Set the code bits</span>
<span class="gi">+        for i in range(num_bits):</span>
<span class="gi">+            self._bitstore.setindex(num_bits + i, (unsigned &gt;&gt; (num_bits - 1 - i)) &amp; 1)</span>
<span class="gi">+</span>
<span class="gi">+    def _getse(self) -&gt; int:</span>
<span class="gi">+        &quot;&quot;&quot;Return data as a signed exponential-Golomb code.&quot;&quot;&quot;</span>
<span class="gi">+        # Find the first 1 bit</span>
<span class="gi">+        for i in range(len(self)):</span>
<span class="gi">+            if self._bitstore.getindex(i):</span>
<span class="gi">+                # Get the code bits</span>
<span class="gi">+                code_bits = 0</span>
<span class="gi">+                for j in range(i + 1, min(2 * i + 1, len(self))):</span>
<span class="gi">+                    code_bits = (code_bits &lt;&lt; 1) | self._bitstore.getindex(j)</span>
<span class="gi">+                # Convert back to signed value</span>
<span class="gi">+                unsigned = code_bits + (1 &lt;&lt; i)</span>
<span class="gi">+                # Map back to signed value</span>
<span class="gi">+                return (unsigned + 1) &gt;&gt; 1 if unsigned &amp; 1 else -(unsigned &gt;&gt; 1)</span>
<span class="gi">+        raise bitstring.InterpretError(&quot;Cannot find any 1 bits in exponential-Golomb code.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _setue(self, value: int, length: Optional[int]=None) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Reset the bitstring to have given unsigned exponential-Golomb code interpretation.&quot;&quot;&quot;</span>
<span class="gi">+        if length is not None:</span>
<span class="gi">+            raise ValueError(&quot;Length cannot be specified for unsigned exponential-Golomb codes.&quot;)</span>
<span class="gi">+        if value &lt; 0:</span>
<span class="gi">+            raise ValueError(&quot;Unsigned exponential-Golomb codes cannot be negative.&quot;)</span>
<span class="gi">+        # Get the number of bits needed for the value + 1</span>
<span class="gi">+        num_bits = (value + 1).bit_length()</span>
<span class="gi">+        # Add leading zeros and the code</span>
<span class="gi">+        self._bitstore = BitStore(num_bits * 2)</span>
<span class="gi">+        self._bitstore.setall(0)</span>
<span class="gi">+        # Set the code bits</span>
<span class="gi">+        for i in range(num_bits - 1):</span>
<span class="gi">+            self._bitstore.setindex(num_bits - 1 + i, (value &gt;&gt; (num_bits - 2 - i)) &amp; 1)</span>
<span class="gi">+        # Set the terminating 1 bit</span>
<span class="gi">+        self._bitstore.setindex(num_bits - 1, 1)</span>
<span class="gi">+</span>
<span class="gi">+    def _getue(self) -&gt; int:</span>
<span class="gi">+        &quot;&quot;&quot;Return data as an unsigned exponential-Golomb code.&quot;&quot;&quot;</span>
<span class="gi">+        # Find the first 1 bit</span>
<span class="gi">+        for i in range(len(self)):</span>
<span class="gi">+            if self._bitstore.getindex(i):</span>
<span class="gi">+                # Get the code bits</span>
<span class="gi">+                code_bits = 0</span>
<span class="gi">+                for j in range(i + 1, min(2 * i + 1, len(self))):</span>
<span class="gi">+                    code_bits = (code_bits &lt;&lt; 1) | self._bitstore.getindex(j)</span>
<span class="gi">+                # Convert back to unsigned value</span>
<span class="gi">+                return code_bits + (1 &lt;&lt; i) - 1</span>
<span class="gi">+        raise bitstring.InterpretError(&quot;Cannot find any 1 bits in exponential-Golomb code.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _setsie(self, value: int, length: Optional[int]=None) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Reset the bitstring to have given signed interleaved exponential-Golomb code interpretation.&quot;&quot;&quot;</span>
<span class="gi">+        if length is not None:</span>
<span class="gi">+            raise ValueError(&quot;Length cannot be specified for signed interleaved exponential-Golomb codes.&quot;)</span>
<span class="gi">+        # Convert to unsigned by mapping negative values to positive ones</span>
<span class="gi">+        unsigned = abs(value) &lt;&lt; 1</span>
<span class="gi">+        if value &lt; 0:</span>
<span class="gi">+            unsigned -= 1</span>
<span class="gi">+        # Get the number of bits needed for the unsigned value</span>
<span class="gi">+        num_bits = unsigned.bit_length()</span>
<span class="gi">+        # Add leading zeros and the code</span>
<span class="gi">+        self._bitstore = BitStore(num_bits * 2)</span>
<span class="gi">+        self._bitstore.setall(0)</span>
<span class="gi">+        # Set the code bits</span>
<span class="gi">+        for i in range(num_bits - 1):</span>
<span class="gi">+            self._bitstore.setindex(num_bits - 1 + i, (unsigned &gt;&gt; (num_bits - 2 - i)) &amp; 1)</span>
<span class="gi">+        # Set the terminating 1 bit</span>
<span class="gi">+        self._bitstore.setindex(num_bits - 1, 1)</span>
<span class="gi">+</span>
<span class="gi">+    def _getsie(self) -&gt; int:</span>
<span class="gi">+        &quot;&quot;&quot;Return data as a signed interleaved exponential-Golomb code.&quot;&quot;&quot;</span>
<span class="gi">+        # Find the first 1 bit</span>
<span class="gi">+        for i in range(len(self)):</span>
<span class="gi">+            if self._bitstore.getindex(i):</span>
<span class="gi">+                # Get the code bits</span>
<span class="gi">+                code_bits = 0</span>
<span class="gi">+                for j in range(i + 1, min(2 * i + 1, len(self))):</span>
<span class="gi">+                    code_bits = (code_bits &lt;&lt; 1) | self._bitstore.getindex(j)</span>
<span class="gi">+                # Convert back to unsigned value</span>
<span class="gi">+                unsigned = code_bits + (1 &lt;&lt; i) - 1</span>
<span class="gi">+                # Map back to signed value</span>
<span class="gi">+                return -(unsigned &gt;&gt; 1) - 1 if unsigned &amp; 1 else unsigned &gt;&gt; 1</span>
<span class="gi">+        raise bitstring.InterpretError(&quot;Cannot find any 1 bits in exponential-Golomb code.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _setuie(self, value: int, length: Optional[int]=None) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Reset the bitstring to have given unsigned interleaved exponential-Golomb code interpretation.&quot;&quot;&quot;</span>
<span class="gi">+        if length is not None:</span>
<span class="gi">+            raise ValueError(&quot;Length cannot be specified for unsigned interleaved exponential-Golomb codes.&quot;)</span>
<span class="gi">+        if value &lt; 0:</span>
<span class="gi">+            raise ValueError(&quot;Unsigned interleaved exponential-Golomb codes cannot be negative.&quot;)</span>
<span class="gi">+        # Get the number of bits needed for the value + 1</span>
<span class="gi">+        num_bits = (value + 1).bit_length()</span>
<span class="gi">+        # Add leading zeros and the code</span>
<span class="gi">+        self._bitstore = BitStore(num_bits * 2)</span>
<span class="gi">+        self._bitstore.setall(0)</span>
<span class="gi">+        # Set the code bits</span>
<span class="gi">+        for i in range(num_bits - 1):</span>
<span class="gi">+            self._bitstore.setindex(num_bits - 1 + i, (value &gt;&gt; (num_bits - 2 - i)) &amp; 1)</span>
<span class="gi">+        # Set the terminating 1 bit</span>
<span class="gi">+        self._bitstore.setindex(num_bits - 1, 1)</span>
<span class="gi">+</span>
<span class="gi">+    def _getuie(self) -&gt; int:</span>
<span class="gi">+        &quot;&quot;&quot;Return data as an unsigned interleaved exponential-Golomb code.&quot;&quot;&quot;</span>
<span class="gi">+        # Find the first 1 bit</span>
<span class="gi">+        for i in range(len(self)):</span>
<span class="gi">+            if self._bitstore.getindex(i):</span>
<span class="gi">+                # Get the code bits</span>
<span class="gi">+                code_bits = 0</span>
<span class="gi">+                for j in range(i + 1, min(2 * i + 1, len(self))):</span>
<span class="gi">+                    code_bits = (code_bits &lt;&lt; 1) | self._bitstore.getindex(j)</span>
<span class="gi">+                # Convert back to unsigned value</span>
<span class="gi">+                return code_bits + (1 &lt;&lt; i) - 1</span>
<span class="gi">+        raise bitstring.InterpretError(&quot;Cannot find any 1 bits in exponential-Golomb code.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    def _setpad(self, value: None, length: Optional[int]=None) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Reset the bitstring to have given padding bits interpretation.&quot;&quot;&quot;</span>
<span class="gi">+        if length is None:</span>
<span class="gi">+            raise ValueError(&quot;Length must be specified for padding bits.&quot;)</span>
<span class="gi">+        if value is not None:</span>
<span class="gi">+            raise ValueError(&quot;Padding bits cannot have a value.&quot;)</span>
<span class="gi">+        self._bitstore = BitStore(length)</span>
<span class="gi">+        self._bitstore.setall(0)</span>
<span class="gi">+</span>
<span class="gi">+    def _getpad(self) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Return data as padding bits (always returns None).&quot;&quot;&quot;</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def _setp3binary(self, value: float, length: Optional[int]=None) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Reset the bitstring to have given p3binary float interpretation.&quot;&quot;&quot;</span>
<span class="gi">+        if length is not None and length != 8:</span>
<span class="gi">+            raise ValueError(&quot;p3binary must be 8 bits.&quot;)</span>
<span class="gi">+        # Convert to bytes using the p3binary format</span>
<span class="gi">+        byte_data = p3binary_fmt.float_to_int8(value).to_bytes(1, byteorder=&#39;big&#39;, signed=False)</span>
<span class="gi">+        self._setbytes(byte_data)</span>
<span class="gi">+</span>
<span class="gi">+    def _getp3binary(self) -&gt; float:</span>
<span class="gi">+        &quot;&quot;&quot;Return data as a p3binary float.&quot;&quot;&quot;</span>
<span class="gi">+        if len(self) != 8:</span>
<span class="gi">+            raise bitstring.InterpretError(&quot;p3binary requires 8 bits.&quot;)</span>
<span class="gi">+        # Convert from bytes using the p3binary format</span>
<span class="gi">+        byte_data = self._getbytes()</span>
<span class="gi">+        return p3binary_fmt.lut_binary8_to_float[byte_data[0]]</span>
<span class="gi">+</span>
<span class="gi">+    def _setp4binary(self, value: float, length: Optional[int]=None) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Reset the bitstring to have given p4binary float interpretation.&quot;&quot;&quot;</span>
<span class="gi">+        if length is not None and length != 8:</span>
<span class="gi">+            raise ValueError(&quot;p4binary must be 8 bits.&quot;)</span>
<span class="gi">+        # Convert to bytes using the p4binary format</span>
<span class="gi">+        byte_data = p4binary_fmt.float_to_int8(value).to_bytes(1, byteorder=&#39;big&#39;, signed=False)</span>
<span class="gi">+        self._setbytes(byte_data)</span>
<span class="gi">+</span>
<span class="gi">+    def _getp4binary(self) -&gt; float:</span>
<span class="gi">+        &quot;&quot;&quot;Return data as a p4binary float.&quot;&quot;&quot;</span>
<span class="gi">+        if len(self) != 8:</span>
<span class="gi">+            raise bitstring.InterpretError(&quot;p4binary requires 8 bits.&quot;)</span>
<span class="gi">+        # Convert from bytes using the p4binary format</span>
<span class="gi">+        byte_data = self._getbytes()</span>
<span class="gi">+        return p4binary_fmt.lut_binary8_to_float[byte_data[0]]</span>
<span class="gi">+</span>
<span class="gi">+    def _sete4m3mxfp(self, value: float, length: Optional[int]=None) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Reset the bitstring to have given e4m3mxfp float interpretation.&quot;&quot;&quot;</span>
<span class="gi">+        if length is not None and length != 8:</span>
<span class="gi">+            raise ValueError(&quot;e4m3mxfp must be 8 bits.&quot;)</span>
<span class="gi">+        # Convert to bytes using the e4m3mxfp format</span>
<span class="gi">+        byte_data = e4m3mxfp_fmt.float_to_int(value).to_bytes(1, byteorder=&#39;big&#39;, signed=False)</span>
<span class="gi">+        self._setbytes(byte_data)</span>
<span class="gi">+</span>
<span class="gi">+    def _gete4m3mxfp(self) -&gt; float:</span>
<span class="gi">+        &quot;&quot;&quot;Return data as an e4m3mxfp float.&quot;&quot;&quot;</span>
<span class="gi">+        if len(self) != 8:</span>
<span class="gi">+            raise bitstring.InterpretError(&quot;e4m3mxfp requires 8 bits.&quot;)</span>
<span class="gi">+        # Convert from bytes using the e4m3mxfp format</span>
<span class="gi">+        byte_data = self._getbytes()</span>
<span class="gi">+        return e4m3mxfp_fmt.lut_int_to_float[byte_data[0]]</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="w"> </span>    def _getuint(self) -&gt; int:
<span class="w"> </span>        &quot;&quot;&quot;Return data as an unsigned int.&quot;&quot;&quot;
<span class="w"> </span>        pass
<span class="gh">diff --git a/bitstring/bitstore_helpers.py b/bitstring/bitstore_helpers.py</span>
<span class="gh">index 1a10140..8cd1bf9 100644</span>
<span class="gd">--- a/bitstring/bitstore_helpers.py</span>
<span class="gi">+++ b/bitstring/bitstore_helpers.py</span>
<span class="gu">@@ -12,6 +12,49 @@ CACHE_SIZE = 256</span>

<span class="w"> </span>def tidy_input_string(s: str) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Return string made lowercase and with all whitespace and underscores removed.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return s.lower().replace(&#39;_&#39;, &#39;&#39;).replace(&#39; &#39;, &#39;&#39;)</span>
<span class="w"> </span>e8m0mxfp_allowed_values = [float(2 ** x) for x in range(-127, 128)]
<span class="gd">-literal_bit_funcs: Dict[str, Callable[..., BitStore]] = {&#39;0x&#39;: hex2bitstore, &#39;0X&#39;: hex2bitstore, &#39;0b&#39;: bin2bitstore, &#39;0B&#39;: bin2bitstore, &#39;0o&#39;: oct2bitstore, &#39;0O&#39;: oct2bitstore}</span>
\ No newline at end of file
<span class="gi">+</span>
<span class="gi">+def hex2bitstore(s: str) -&gt; BitStore:</span>
<span class="gi">+    &quot;&quot;&quot;Convert a hex string to a BitStore.&quot;&quot;&quot;</span>
<span class="gi">+    s = tidy_input_string(s)</span>
<span class="gi">+    if not s.startswith(&#39;0x&#39;):</span>
<span class="gi">+        raise ValueError(&quot;Hex string must start with &#39;0x&#39;&quot;)</span>
<span class="gi">+    s = s[2:]  # Remove &#39;0x&#39;</span>
<span class="gi">+    # Each hex digit represents 4 bits</span>
<span class="gi">+    bits = &#39;&#39;.join(format(int(c, 16), &#39;04b&#39;) for c in s)</span>
<span class="gi">+    ba = bitarray.bitarray(bits)</span>
<span class="gi">+    return BitStore(ba)</span>
<span class="gi">+</span>
<span class="gi">+def bin2bitstore(s: str) -&gt; BitStore:</span>
<span class="gi">+    &quot;&quot;&quot;Convert a binary string to a BitStore.&quot;&quot;&quot;</span>
<span class="gi">+    s = tidy_input_string(s)</span>
<span class="gi">+    if not s.startswith(&#39;0b&#39;):</span>
<span class="gi">+        raise ValueError(&quot;Binary string must start with &#39;0b&#39;&quot;)</span>
<span class="gi">+    s = s[2:]  # Remove &#39;0b&#39;</span>
<span class="gi">+    ba = bitarray.bitarray(s)</span>
<span class="gi">+    return BitStore(ba)</span>
<span class="gi">+</span>
<span class="gi">+def oct2bitstore(s: str) -&gt; BitStore:</span>
<span class="gi">+    &quot;&quot;&quot;Convert an octal string to a BitStore.&quot;&quot;&quot;</span>
<span class="gi">+    s = tidy_input_string(s)</span>
<span class="gi">+    if not s.startswith(&#39;0o&#39;):</span>
<span class="gi">+        raise ValueError(&quot;Octal string must start with &#39;0o&#39;&quot;)</span>
<span class="gi">+    s = s[2:]  # Remove &#39;0o&#39;</span>
<span class="gi">+    # Each octal digit represents 3 bits</span>
<span class="gi">+    bits = &#39;&#39;.join(format(int(c, 8), &#39;03b&#39;) for c in s)</span>
<span class="gi">+    ba = bitarray.bitarray(bits)</span>
<span class="gi">+    return BitStore(ba)</span>
<span class="gi">+</span>
<span class="gi">+literal_bit_funcs: Dict[str, Callable[..., BitStore]] = {&#39;0x&#39;: hex2bitstore, &#39;0X&#39;: hex2bitstore, &#39;0b&#39;: bin2bitstore, &#39;0B&#39;: bin2bitstore, &#39;0o&#39;: oct2bitstore, &#39;0O&#39;: oct2bitstore}</span>
<span class="gi">+</span>
<span class="gi">+def bitstore_from_token(token: str) -&gt; BitStore:</span>
<span class="gi">+    &quot;&quot;&quot;Create a BitStore from a token string.</span>
<span class="gi">+    </span>
<span class="gi">+    The token can be a hex, binary or octal string.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    token = tidy_input_string(token)</span>
<span class="gi">+    for prefix, func in literal_bit_funcs.items():</span>
<span class="gi">+        if token.startswith(prefix.lower()):</span>
<span class="gi">+            return func(token)</span>
<span class="gi">+    raise ValueError(f&quot;Invalid token format: {token}. Must start with one of {list(literal_bit_funcs.keys())}&quot;)</span>
\ No newline at end of file
<span class="gh">diff --git a/bitstring/bitstring_options.py b/bitstring/bitstring_options.py</span>
<span class="gh">index 9df2b5a..dbf8265 100644</span>
<span class="gd">--- a/bitstring/bitstring_options.py</span>
<span class="gi">+++ b/bitstring/bitstring_options.py</span>
<span class="gu">@@ -7,13 +7,17 @@ class Options:</span>
<span class="w"> </span>    _instance = None

<span class="w"> </span>    def __init__(self):
<span class="gd">-        self.set_lsb0(False)</span>
<span class="gi">+        self._lsb0 = False</span>
<span class="w"> </span>        self._bytealigned = False
<span class="w"> </span>        self.mxfp_overflow = &#39;saturate&#39;
<span class="w"> </span>        self.no_color = False
<span class="w"> </span>        no_color = os.getenv(&#39;NO_COLOR&#39;)
<span class="w"> </span>        self.no_color = True if no_color else False

<span class="gi">+    def set_lsb0(self, value: bool) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Set whether bit numbering starts at 0 (True) or 1 (False) for the least significant bit.&quot;&quot;&quot;</span>
<span class="gi">+        self._lsb0 = bool(value)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self) -&gt; str:
<span class="w"> </span>        attributes = {attr: getattr(self, attr) for attr in dir(self) if not attr.startswith(&#39;_&#39;) and (not callable(getattr(self, attr)))}
<span class="w"> </span>        return &#39;\n&#39;.join((f&#39;{attr}: {value!r}&#39; for attr, value in attributes.items()))
<span class="gh">diff --git a/bitstring/dtypes.py b/bitstring/dtypes.py</span>
<span class="gh">index 741d639..3f7552e 100644</span>
<span class="gd">--- a/bitstring/dtypes.py</span>
<span class="gi">+++ b/bitstring/dtypes.py</span>
<span class="gu">@@ -42,57 +42,57 @@ class Dtype:</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def scale(self) -&gt; Union[int, float, None]:
<span class="w"> </span>        &quot;&quot;&quot;The multiplicative scale applied when interpreting the data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._scale</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def name(self) -&gt; str:
<span class="w"> </span>        &quot;&quot;&quot;A string giving the name of the data type.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._name</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def length(self) -&gt; int:
<span class="w"> </span>        &quot;&quot;&quot;The length of the data type in units of bits_per_item. Set to None for variable length dtypes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._length</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def bitlength(self) -&gt; Optional[int]:
<span class="w"> </span>        &quot;&quot;&quot;The number of bits needed to represent a single instance of the data type. Set to None for variable length dtypes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._bitlength</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def bits_per_item(self) -&gt; int:
<span class="w"> </span>        &quot;&quot;&quot;The number of bits for each unit of length. Usually 1, but equals 8 for bytes type.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._bits_per_item</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def variable_length(self) -&gt; bool:
<span class="w"> </span>        &quot;&quot;&quot;If True then the length of the data type depends on the data being interpreted, and must not be specified.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._variable_length</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def return_type(self) -&gt; Any:
<span class="w"> </span>        &quot;&quot;&quot;The type of the value returned by the parse method, such as int, float or str.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._return_type</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def is_signed(self) -&gt; bool:
<span class="w"> </span>        &quot;&quot;&quot;If True then the data type represents a signed quantity.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._is_signed</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def set_fn(self) -&gt; Optional[Callable]:
<span class="w"> </span>        &quot;&quot;&quot;A function to set the value of the data type.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._set_fn</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def get_fn(self) -&gt; Callable:
<span class="w"> </span>        &quot;&quot;&quot;A function to get the value of the data type.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._get_fn</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def read_fn(self) -&gt; Callable:
<span class="w"> </span>        &quot;&quot;&quot;A function to read the value of the data type.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._read_fn</span>

<span class="w"> </span>    def __hash__(self) -&gt; int:
<span class="w"> </span>        return hash((self._name, self._length))
<span class="gu">@@ -102,13 +102,23 @@ class Dtype:</span>

<span class="w"> </span>        The value parameter should be of a type appropriate to the dtype.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._set_fn is None:</span>
<span class="gi">+            raise bitstring.CreationError(f&quot;The &#39;{self._name}&#39; dtype cannot be used to create bitstrings.&quot;)</span>
<span class="gi">+        if self._set_fn_needs_length:</span>
<span class="gi">+            if self._length is None:</span>
<span class="gi">+                raise bitstring.CreationError(f&quot;Cannot create a bitstring from a &#39;{self._name}&#39; dtype without a length.&quot;)</span>
<span class="gi">+            return self._set_fn(value, self._length)</span>
<span class="gi">+        return self._set_fn(value)</span>

<span class="w"> </span>    def parse(self, b: BitsType, /) -&gt; Any:
<span class="w"> </span>        &quot;&quot;&quot;Parse a bitstring to find its value.

<span class="w"> </span>        The b parameter should be a bitstring of the appropriate length, or an object that can be converted to a bitstring.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(b, bitstring.Bits):</span>
<span class="gi">+            b = bitstring.Bits(b)</span>
<span class="gi">+        if self._scale is None:</span>
<span class="gi">+            return self._get_fn(b)</span>
<span class="gi">+        return self._get_fn(b) * self._scale</span>

<span class="w"> </span>    def __str__(self) -&gt; str:
<span class="w"> </span>        if self._scale is not None:
<span class="gu">@@ -164,6 +174,10 @@ class AllowedLengths:</span>
<span class="w"> </span>            return (other - self.values[0]) % (self.values[1] - self.values[0]) == 0
<span class="w"> </span>        return other in self.values

<span class="gi">+    def only_one_value(self) -&gt; bool:</span>
<span class="gi">+        &quot;&quot;&quot;Return True if there is exactly one allowed length.&quot;&quot;&quot;</span>
<span class="gi">+        return len(self.values) == 1 and self.values[-1] is not Ellipsis</span>
<span class="gi">+</span>
<span class="w"> </span>class DtypeDefinition:
<span class="w"> </span>    &quot;&quot;&quot;Represents a class of dtypes, such as uint or float, rather than a concrete dtype such as uint8.
<span class="w"> </span>    Not (yet) part of the public interface.&quot;&quot;&quot;
<span class="gu">@@ -250,7 +264,7 @@ class Register:</span>
<span class="w"> </span>        del cls.names[name]

<span class="w"> </span>    def __repr__(self) -&gt; str:
<span class="gd">-        s = [f&#39;{&#39;key&#39;:&lt;12}:{&#39;name&#39;:^12}{&#39;signed&#39;:^8}{&#39;set_fn_needs_length&#39;:^23}{&#39;allowed_lengths&#39;:^16}{&#39;multiplier&#39;:^12}{&#39;return_type&#39;:&lt;13}&#39;]</span>
<span class="gi">+        s = [&quot;key:         name      signed  set_fn_needs_length   allowed_lengths multiplier  return_type&quot;]</span>
<span class="w"> </span>        s.append(&#39;-&#39; * 85)
<span class="w"> </span>        for key in self.names:
<span class="w"> </span>            m = self.names[key]
<span class="gh">diff --git a/bitstring/fp8.py b/bitstring/fp8.py</span>
<span class="gh">index 07bbfe2..8f94e96 100644</span>
<span class="gd">--- a/bitstring/fp8.py</span>
<span class="gi">+++ b/bitstring/fp8.py</span>
<span class="gu">@@ -24,10 +24,48 @@ class Binary8Format:</span>

<span class="w"> </span>    def float_to_int8(self, f: float) -&gt; int:
<span class="w"> </span>        &quot;&quot;&quot;Given a Python float convert to the best float8 (expressed as an integer in 0-255 range).&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if math.isnan(f):</span>
<span class="gi">+            return 0</span>
<span class="gi">+        if math.isinf(f):</span>
<span class="gi">+            if f &gt; 0:</span>
<span class="gi">+                return self.pos_clamp_value</span>
<span class="gi">+            return self.neg_clamp_value</span>
<span class="gi">+        if f == 0:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        sign = 1 if f &lt; 0 else 0</span>
<span class="gi">+        f = abs(f)</span>
<span class="gi">+        exp = math.floor(math.log2(f))</span>
<span class="gi">+        mantissa = int((f / 2**exp - 1) * (1 &lt;&lt; (7 - self.exp_bits)))</span>
<span class="gi">+        exp = exp + self.bias</span>
<span class="gi">+        if exp &lt; 0:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        if exp &gt;= (1 &lt;&lt; self.exp_bits):</span>
<span class="gi">+            return self.neg_clamp_value if sign else self.pos_clamp_value</span>
<span class="gi">+        result = (sign &lt;&lt; 7) | (exp &lt;&lt; (7 - self.exp_bits)) | mantissa</span>
<span class="gi">+        return result</span>

<span class="gd">-    def createLUT_for_binary8_to_float(self):</span>
<span class="gi">+    def createLUT_for_binary8_to_float(self) -&gt; array.array:</span>
<span class="w"> </span>        &quot;&quot;&quot;Create a LUT to convert an int in range 0-255 representing a float8 into a Python float&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        lut = array.array(&#39;f&#39;)</span>
<span class="gi">+        for i in range(256):</span>
<span class="gi">+            sign = -1 if i &amp; 0x80 else 1</span>
<span class="gi">+            exp = (i &gt;&gt; (7 - self.exp_bits)) &amp; ((1 &lt;&lt; self.exp_bits) - 1)</span>
<span class="gi">+            mantissa = i &amp; ((1 &lt;&lt; (7 - self.exp_bits)) - 1)</span>
<span class="gi">+            if exp == 0:</span>
<span class="gi">+                lut.append(0.0)</span>
<span class="gi">+            else:</span>
<span class="gi">+                value = sign * (1 + mantissa / (1 &lt;&lt; (7 - self.exp_bits))) * 2**(exp - self.bias)</span>
<span class="gi">+                lut.append(value)</span>
<span class="gi">+        return lut</span>
<span class="w"> </span>p4binary_fmt = Binary8Format(exp_bits=4, bias=8)
<span class="gd">-p3binary_fmt = Binary8Format(exp_bits=5, bias=16)</span>
\ No newline at end of file
<span class="gi">+p3binary_fmt = Binary8Format(exp_bits=5, bias=16)</span>
<span class="gi">+</span>
<span class="gi">+def decompress_luts() -&gt; None:</span>
<span class="gi">+    &quot;&quot;&quot;Decompress the lookup tables for binary8 formats.&quot;&quot;&quot;</span>
<span class="gi">+    for fmt in [p4binary_fmt, p3binary_fmt]:</span>
<span class="gi">+        if not hasattr(fmt, &#39;lut_float16_to_binary8&#39;):</span>
<span class="gi">+            key = (fmt.exp_bits, fmt.bias)</span>
<span class="gi">+            compressed_data = binary8_luts_compressed[key]</span>
<span class="gi">+            fmt.lut_float16_to_binary8 = zlib.decompress(compressed_data[0])</span>
<span class="gi">+        if not hasattr(fmt, &#39;lut_binary8_to_float&#39;):</span>
<span class="gi">+            fmt.lut_binary8_to_float = fmt.createLUT_for_binary8_to_float()</span>
\ No newline at end of file
<span class="gh">diff --git a/bitstring/mxfp.py b/bitstring/mxfp.py</span>
<span class="gh">index 2996509..0659099 100644</span>
<span class="gd">--- a/bitstring/mxfp.py</span>
<span class="gi">+++ b/bitstring/mxfp.py</span>
<span class="gu">@@ -37,19 +37,64 @@ class MXFPFormat:</span>

<span class="w"> </span>    def float_to_int(self, f: float) -&gt; int:
<span class="w"> </span>        &quot;&quot;&quot;Given a Python float convert to the best mxfp float (expressed as an int) that represents it.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if math.isnan(f):</span>
<span class="gi">+            return 0</span>
<span class="gi">+        if math.isinf(f):</span>
<span class="gi">+            if f &gt; 0:</span>
<span class="gi">+                return self.pos_clamp_value</span>
<span class="gi">+            return self.neg_clamp_value</span>
<span class="gi">+        if f == 0:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        sign = 1 if f &lt; 0 else 0</span>
<span class="gi">+        f = abs(f)</span>
<span class="gi">+        exp = math.floor(math.log2(f))</span>
<span class="gi">+        mantissa = int((f / 2**exp - 1) * (1 &lt;&lt; self.mantissa_bits))</span>
<span class="gi">+        exp = exp + self.bias</span>
<span class="gi">+        if exp &lt; 0:</span>
<span class="gi">+            return 0</span>
<span class="gi">+        if exp &gt;= (1 &lt;&lt; self.exp_bits):</span>
<span class="gi">+            if self.mxfp_overflow == &#39;saturate&#39;:</span>
<span class="gi">+                return self.neg_clamp_value if sign else self.pos_clamp_value</span>
<span class="gi">+            exp = (1 &lt;&lt; self.exp_bits) - 1</span>
<span class="gi">+            mantissa = (1 &lt;&lt; self.mantissa_bits) - 1</span>
<span class="gi">+        result = (sign &lt;&lt; (self.exp_bits + self.mantissa_bits)) | (exp &lt;&lt; self.mantissa_bits) | mantissa</span>
<span class="gi">+        return result</span>

<span class="w"> </span>    def createLUT_for_int_to_float(self) -&gt; array.array:
<span class="w"> </span>        &quot;&quot;&quot;Create a LUT to convert an int in representing a MXFP float into a Python float&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        lut = array.array(&#39;f&#39;)</span>
<span class="gi">+        for i in range(1 &lt;&lt; (1 + self.exp_bits + self.mantissa_bits)):</span>
<span class="gi">+            sign = -1 if i &gt;&gt; (self.exp_bits + self.mantissa_bits) else 1</span>
<span class="gi">+            exp = (i &gt;&gt; self.mantissa_bits) &amp; ((1 &lt;&lt; self.exp_bits) - 1)</span>
<span class="gi">+            mantissa = i &amp; ((1 &lt;&lt; self.mantissa_bits) - 1)</span>
<span class="gi">+            if exp == 0:</span>
<span class="gi">+                lut.append(0.0)</span>
<span class="gi">+            else:</span>
<span class="gi">+                value = sign * (1 + mantissa / (1 &lt;&lt; self.mantissa_bits)) * 2**(exp - self.bias)</span>
<span class="gi">+                lut.append(value)</span>
<span class="gi">+        return lut</span>

<span class="w"> </span>    def createLUT_for_float16_to_mxfp(self) -&gt; bytes:
<span class="w"> </span>        &quot;&quot;&quot;Create a LUT to convert a float16 into a MXFP format&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        lut = bytearray(65536)</span>
<span class="gi">+        for i in range(65536):</span>
<span class="gi">+            f = struct.unpack(&#39;e&#39;, struct.pack(&#39;H&#39;, i))[0]</span>
<span class="gi">+            lut[i] = self.float_to_int(f)</span>
<span class="gi">+        return bytes(lut)</span>
<span class="w"> </span>e2m1mxfp_fmt = MXFPFormat(exp_bits=2, mantissa_bits=1, bias=1, mxfp_overflow=&#39;saturate&#39;)
<span class="w"> </span>e2m3mxfp_fmt = MXFPFormat(exp_bits=2, mantissa_bits=3, bias=1, mxfp_overflow=&#39;saturate&#39;)
<span class="w"> </span>e3m2mxfp_fmt = MXFPFormat(exp_bits=3, mantissa_bits=2, bias=3, mxfp_overflow=&#39;saturate&#39;)
<span class="w"> </span>e4m3mxfp_saturate_fmt = MXFPFormat(exp_bits=4, mantissa_bits=3, bias=7, mxfp_overflow=&#39;saturate&#39;)
<span class="w"> </span>e5m2mxfp_saturate_fmt = MXFPFormat(exp_bits=5, mantissa_bits=2, bias=15, mxfp_overflow=&#39;saturate&#39;)
<span class="w"> </span>e4m3mxfp_overflow_fmt = MXFPFormat(exp_bits=4, mantissa_bits=3, bias=7, mxfp_overflow=&#39;overflow&#39;)
<span class="gd">-e5m2mxfp_overflow_fmt = MXFPFormat(exp_bits=5, mantissa_bits=2, bias=15, mxfp_overflow=&#39;overflow&#39;)</span>
\ No newline at end of file
<span class="gi">+e5m2mxfp_overflow_fmt = MXFPFormat(exp_bits=5, mantissa_bits=2, bias=15, mxfp_overflow=&#39;overflow&#39;)</span>
<span class="gi">+</span>
<span class="gi">+def decompress_luts() -&gt; None:</span>
<span class="gi">+    &quot;&quot;&quot;Decompress the lookup tables for MXFP formats.&quot;&quot;&quot;</span>
<span class="gi">+    for fmt in [e2m1mxfp_fmt, e2m3mxfp_fmt, e3m2mxfp_fmt, e4m3mxfp_saturate_fmt, e5m2mxfp_saturate_fmt, e4m3mxfp_overflow_fmt, e5m2mxfp_overflow_fmt]:</span>
<span class="gi">+        if fmt.lut_float16_to_mxfp is None:</span>
<span class="gi">+            key = (fmt.exp_bits, fmt.mantissa_bits, fmt.bias, fmt.mxfp_overflow)</span>
<span class="gi">+            compressed_data = mxfp_luts_compressed[key]</span>
<span class="gi">+            fmt.lut_float16_to_mxfp = zlib.decompress(compressed_data[0])</span>
<span class="gi">+        if fmt.lut_int_to_float is None:</span>
<span class="gi">+            fmt.lut_int_to_float = fmt.createLUT_for_int_to_float()</span>
\ No newline at end of file
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>