
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all plain fillin requests - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#claude-sonnet-35-fill-in-requests" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all plain fillin requests
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0-all-plain_fillin">back to Claude Sonnet 3.5 - Fill-in summary</a></p>
<h1 id="claude-sonnet-35-fill-in-requests"><strong>Claude Sonnet 3.5 - Fill-in</strong>: requests</h1>
<h2 id="failed-to-run-pytests-for-test-tests">Failed to run pytests for test <code>tests</code></h2>
<div class="highlight"><pre><span></span><code>/testbed/.venv/lib/python3.12/site-packages/httpbin/helpers.py:32: SyntaxWarning: invalid escape sequence &#39;\_&#39;
  ASCII_ART = &quot;&quot;&quot;
/testbed/.venv/lib/python3.12/site-packages/httpbin/helpers.py:77: SyntaxWarning: invalid escape sequence &#39;\ &#39;
  ANGRY_ASCII =&quot;&quot;&quot;
/testbed/.venv/lib/python3.12/site-packages/httpbin/helpers.py:444: SyntaxWarning: invalid escape sequence &#39;\s&#39;
  match = re.search(&#39;\s*(W/)?\&quot;?([^&quot;]*)\&quot;?\s*&#39;, part)
ImportError while loading conftest &#39;/testbed/tests/conftest.py&#39;.
tests/conftest.py:12: in &lt;module&gt;
    from requests.compat import urljoin
src/requests/__init__.py:164: in &lt;module&gt;
    from .api import delete, get, head, options, patch, post, put, request
src/requests/api.py:10: in &lt;module&gt;
    from . import sessions
src/requests/sessions.py:14: in &lt;module&gt;
    from .adapters import HTTPAdapter
E     File &quot;/testbed/src/requests/adapters.py&quot;, line 34
E       if typing.TYPE_CHECKING:
E       ^^
E   IndentationError: expected an indented block after &#39;except&#39; statement on line 33
</code></pre></div>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/src/requests/_internal_utils.py b/src/requests/_internal_utils.py</span>
<span class="gh">index 4342cd14..1712c808 100644</span>
<span class="gd">--- a/src/requests/_internal_utils.py</span>
<span class="gi">+++ b/src/requests/_internal_utils.py</span>
<span class="gu">@@ -23,7 +23,11 @@ def to_native_string(string, encoding=&#39;ascii&#39;):</span>
<span class="w"> </span>    that string in the native string type, encoding and decoding where
<span class="w"> </span>    necessary. This assumes ASCII unless told otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(string, builtin_str):</span>
<span class="gi">+        return string</span>
<span class="gi">+    if isinstance(string, bytes):</span>
<span class="gi">+        return string.decode(encoding)</span>
<span class="gi">+    return string.encode(encoding).decode(encoding)</span>


<span class="w"> </span>def unicode_is_ascii(u_string):
<span class="gu">@@ -33,4 +37,4 @@ def unicode_is_ascii(u_string):</span>
<span class="w"> </span>        and not Python 2 `str`.
<span class="w"> </span>    :rtype: bool
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return all(ord(c) &lt; 128 for c in u_string)</span>
<span class="gh">diff --git a/src/requests/adapters.py b/src/requests/adapters.py</span>
<span class="gh">index 57d9ddf8..85f70894 100644</span>
<span class="gd">--- a/src/requests/adapters.py</span>
<span class="gi">+++ b/src/requests/adapters.py</span>
<span class="gu">@@ -143,7 +143,13 @@ class HTTPAdapter(BaseAdapter):</span>
<span class="w"> </span>        :param block: Block when no free connections are available.
<span class="w"> </span>        :param pool_kwargs: Extra keyword arguments used to initialize the Pool Manager.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.poolmanager = PoolManager(</span>
<span class="gi">+            num_pools=connections,</span>
<span class="gi">+            maxsize=maxsize,</span>
<span class="gi">+            block=block,</span>
<span class="gi">+            strict=True,</span>
<span class="gi">+            **pool_kwargs</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def proxy_manager_for(self, proxy, **proxy_kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Return urllib3 ProxyManager for the given proxy.
<span class="gu">@@ -157,7 +163,36 @@ class HTTPAdapter(BaseAdapter):</span>
<span class="w"> </span>        :returns: ProxyManager
<span class="w"> </span>        :rtype: urllib3.ProxyManager
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if proxy in self.proxy_manager:</span>
<span class="gi">+            return self.proxy_manager[proxy]</span>
<span class="gi">+</span>
<span class="gi">+        proxy_headers = self.proxy_headers(proxy)</span>
<span class="gi">+        if proxy_headers:</span>
<span class="gi">+            proxy_kwargs[&#39;proxy_headers&#39;] = proxy_kwargs.get(&#39;proxy_headers&#39;, {})</span>
<span class="gi">+            proxy_kwargs[&#39;proxy_headers&#39;].update(proxy_headers)</span>
<span class="gi">+</span>
<span class="gi">+        if proxy.lower().startswith(&#39;socks&#39;):</span>
<span class="gi">+            username, password = get_auth_from_url(proxy)</span>
<span class="gi">+            manager = SOCKSProxyManager(</span>
<span class="gi">+                proxy,</span>
<span class="gi">+                username=username,</span>
<span class="gi">+                password=password,</span>
<span class="gi">+                num_pools=self._pool_connections,</span>
<span class="gi">+                maxsize=self._pool_maxsize,</span>
<span class="gi">+                block=self._pool_block,</span>
<span class="gi">+                **proxy_kwargs</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            manager = proxy_from_url(</span>
<span class="gi">+                proxy,</span>
<span class="gi">+                num_pools=self._pool_connections,</span>
<span class="gi">+                maxsize=self._pool_maxsize,</span>
<span class="gi">+                block=self._pool_block,</span>
<span class="gi">+                **proxy_kwargs</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        self.proxy_manager[proxy] = manager</span>
<span class="gi">+        return manager</span>

<span class="w"> </span>    def cert_verify(self, conn, url, verify, cert):
<span class="w"> </span>        &quot;&quot;&quot;Verify a SSL certificate. This method should not be called from user
<span class="gu">@@ -171,7 +206,22 @@ class HTTPAdapter(BaseAdapter):</span>
<span class="w"> </span>            to a CA bundle to use
<span class="w"> </span>        :param cert: The SSL certificate to verify.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(verify, str):</span>
<span class="gi">+            conn.cert_reqs = &#39;CERT_REQUIRED&#39;</span>
<span class="gi">+            conn.ca_certs = verify</span>
<span class="gi">+        elif verify is False:</span>
<span class="gi">+            conn.cert_reqs = &#39;CERT_NONE&#39;</span>
<span class="gi">+            conn.ca_certs = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            conn.cert_reqs = &#39;CERT_REQUIRED&#39;</span>
<span class="gi">+            conn.ca_certs = DEFAULT_CA_BUNDLE_PATH</span>
<span class="gi">+</span>
<span class="gi">+        if cert:</span>
<span class="gi">+            if isinstance(cert, str):</span>
<span class="gi">+                conn.cert_file = cert</span>
<span class="gi">+            else:</span>
<span class="gi">+                conn.cert_file = cert[0]</span>
<span class="gi">+                conn.key_file = cert[1]</span>

<span class="w"> </span>    def build_response(self, req, resp):
<span class="w"> </span>        &quot;&quot;&quot;Builds a :class:`Response &lt;requests.Response&gt;` object from a urllib3
<span class="gu">@@ -183,7 +233,32 @@ class HTTPAdapter(BaseAdapter):</span>
<span class="w"> </span>        :param resp: The urllib3 response object.
<span class="w"> </span>        :rtype: requests.Response
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        response = Response()</span>
<span class="gi">+</span>
<span class="gi">+        # Fallback to None if there&#39;s no status_code, for whatever reason.</span>
<span class="gi">+        response.status_code = getattr(resp, &#39;status&#39;, None)</span>
<span class="gi">+</span>
<span class="gi">+        # Make headers case-insensitive.</span>
<span class="gi">+        response.headers = CaseInsensitiveDict(getattr(resp, &#39;headers&#39;, {}))</span>
<span class="gi">+</span>
<span class="gi">+        # Set encoding.</span>
<span class="gi">+        response.encoding = get_encoding_from_headers(response.headers)</span>
<span class="gi">+        response.raw = resp</span>
<span class="gi">+        response.reason = response.raw.reason</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(req.url, bytes):</span>
<span class="gi">+            response.url = req.url.decode(&#39;utf-8&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            response.url = req.url</span>
<span class="gi">+</span>
<span class="gi">+        # Add new cookies from the server.</span>
<span class="gi">+        extract_cookies_to_jar(response.cookies, req, resp)</span>
<span class="gi">+</span>
<span class="gi">+        # Give the Response some context.</span>
<span class="gi">+        response.request = req</span>
<span class="gi">+        response.connection = self</span>
<span class="gi">+</span>
<span class="gi">+        return response</span>

<span class="w"> </span>    def build_connection_pool_key_attributes(self, request, verify, cert=None):
<span class="w"> </span>        &quot;&quot;&quot;Build the PoolKey attributes used by urllib3 to return a connection.
<span class="gu">@@ -270,7 +345,18 @@ class HTTPAdapter(BaseAdapter):</span>
<span class="w"> </span>        :param proxies: (optional) A Requests-style dictionary of proxies used on this request.
<span class="w"> </span>        :rtype: urllib3.ConnectionPool
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;get_connection is deprecated and will be removed in a future version. &quot;</span>
<span class="gi">+            &quot;Please use get_connection_with_tls_context instead.&quot;,</span>
<span class="gi">+            DeprecationWarning</span>
<span class="gi">+        )</span>
<span class="gi">+        proxy = select_proxy(url, proxies)</span>
<span class="gi">+</span>
<span class="gi">+        if proxy:</span>
<span class="gi">+            proxy = prepend_scheme_if_needed(proxy, &#39;http&#39;)</span>
<span class="gi">+            return self.proxy_manager_for(proxy)</span>
<span class="gi">+</span>
<span class="gi">+        return self.poolmanager.connection_from_url(url)</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;Disposes of any internal state.
<span class="gu">@@ -278,7 +364,10 @@ class HTTPAdapter(BaseAdapter):</span>
<span class="w"> </span>        Currently, this closes the PoolManager and any active ProxyManager,
<span class="w"> </span>        which closes any pooled connections.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.poolmanager.clear()</span>
<span class="gi">+        for proxy in self.proxy_manager.values():</span>
<span class="gi">+            proxy.clear()</span>
<span class="gi">+        self.proxy_manager.clear()</span>

<span class="w"> </span>    def request_url(self, request, proxies):
<span class="w"> </span>        &quot;&quot;&quot;Obtain the url to use when making the final request.
<span class="gu">@@ -294,7 +383,13 @@ class HTTPAdapter(BaseAdapter):</span>
<span class="w"> </span>        :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs.
<span class="w"> </span>        :rtype: str
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        proxy = select_proxy(request.url, proxies)</span>
<span class="gi">+        scheme = urlparse(request.url).scheme</span>
<span class="gi">+</span>
<span class="gi">+        if proxy and scheme != &#39;https&#39;:</span>
<span class="gi">+            return request.url</span>
<span class="gi">+        else:</span>
<span class="gi">+            return request.path_url</span>

<span class="w"> </span>    def add_headers(self, request, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Add any headers needed by the connection. As of v2.0 this does
<span class="gu">@@ -323,7 +418,13 @@ class HTTPAdapter(BaseAdapter):</span>
<span class="w"> </span>        :param proxy: The url of the proxy being used for this request.
<span class="w"> </span>        :rtype: dict
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        headers = {}</span>
<span class="gi">+        username, password = get_auth_from_url(proxy)</span>
<span class="gi">+</span>
<span class="gi">+        if username and password:</span>
<span class="gi">+            headers[&#39;Proxy-Authorization&#39;] = _basic_auth_str(username, password)</span>
<span class="gi">+</span>
<span class="gi">+        return headers</span>

<span class="w"> </span>    def send(self, request, stream=False, timeout=None, verify=True, cert=
<span class="w"> </span>        None, proxies=None):
<span class="gh">diff --git a/src/requests/auth.py b/src/requests/auth.py</span>
<span class="gh">index f08aecf6..c7fddca4 100644</span>
<span class="gd">--- a/src/requests/auth.py</span>
<span class="gi">+++ b/src/requests/auth.py</span>
<span class="gu">@@ -21,7 +21,8 @@ CONTENT_TYPE_MULTI_PART = &#39;multipart/form-data&#39;</span>

<span class="w"> </span>def _basic_auth_str(username, password):
<span class="w"> </span>    &quot;&quot;&quot;Returns a Basic Auth string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    auth = f&quot;{username}:{password}&quot;</span>
<span class="gi">+    return f&quot;Basic {b64encode(auth.encode(&#39;utf-8&#39;)).decode(&#39;ascii&#39;)}&quot;</span>


<span class="w"> </span>class AuthBase:
<span class="gu">@@ -72,11 +73,92 @@ class HTTPDigestAuth(AuthBase):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :rtype: str
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        realm = self._thread_local.chal[&#39;realm&#39;]</span>
<span class="gi">+        nonce = self._thread_local.chal[&#39;nonce&#39;]</span>
<span class="gi">+        qop = self._thread_local.chal.get(&#39;qop&#39;)</span>
<span class="gi">+        algorithm = self._thread_local.chal.get(&#39;algorithm&#39;)</span>
<span class="gi">+        opaque = self._thread_local.chal.get(&#39;opaque&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if algorithm is None:</span>
<span class="gi">+            _algorithm = &#39;MD5&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            _algorithm = algorithm.upper()</span>
<span class="gi">+        </span>
<span class="gi">+        if _algorithm == &#39;MD5&#39; or _algorithm == &#39;MD5-SESS&#39;:</span>
<span class="gi">+            def md5_utf8(x):</span>
<span class="gi">+                if isinstance(x, str):</span>
<span class="gi">+                    x = x.encode(&#39;utf-8&#39;)</span>
<span class="gi">+                return hashlib.md5(x).hexdigest()</span>
<span class="gi">+            hash_utf8 = md5_utf8</span>
<span class="gi">+        elif _algorithm == &#39;SHA&#39;:</span>
<span class="gi">+            def sha_utf8(x):</span>
<span class="gi">+                if isinstance(x, str):</span>
<span class="gi">+                    x = x.encode(&#39;utf-8&#39;)</span>
<span class="gi">+                return hashlib.sha1(x).hexdigest()</span>
<span class="gi">+            hash_utf8 = sha_utf8</span>
<span class="gi">+        elif _algorithm == &#39;SHA-256&#39;:</span>
<span class="gi">+            def sha256_utf8(x):</span>
<span class="gi">+                if isinstance(x, str):</span>
<span class="gi">+                    x = x.encode(&#39;utf-8&#39;)</span>
<span class="gi">+                return hashlib.sha256(x).hexdigest()</span>
<span class="gi">+            hash_utf8 = sha256_utf8</span>
<span class="gi">+        elif _algorithm == &#39;SHA-512&#39;:</span>
<span class="gi">+            def sha512_utf8(x):</span>
<span class="gi">+                if isinstance(x, str):</span>
<span class="gi">+                    x = x.encode(&#39;utf-8&#39;)</span>
<span class="gi">+                return hashlib.sha512(x).hexdigest()</span>
<span class="gi">+            hash_utf8 = sha512_utf8</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&quot;Unsupported algorithm: {_algorithm}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        KD = lambda s, d: hash_utf8(f&quot;{s}:{d}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if hash_utf8 is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        entdig = None</span>
<span class="gi">+        p_parsed = urlparse(url)</span>
<span class="gi">+        path = p_parsed.path or &quot;/&quot;</span>
<span class="gi">+        if p_parsed.query:</span>
<span class="gi">+            path += f&quot;?{p_parsed.query}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        A1 = f&quot;{self.username}:{realm}:{self.password}&quot;</span>
<span class="gi">+        A2 = f&quot;{method}:{path}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        HA1 = hash_utf8(A1)</span>
<span class="gi">+        HA2 = hash_utf8(A2)</span>
<span class="gi">+</span>
<span class="gi">+        if qop is None:</span>
<span class="gi">+            respdig = KD(HA1, f&quot;{nonce}:{HA2}&quot;)</span>
<span class="gi">+        elif qop == &#39;auth&#39; or &#39;auth&#39; in qop.split(&#39;,&#39;):</span>
<span class="gi">+            nc = f&quot;{self._thread_local.nonce_count:08x}&quot;</span>
<span class="gi">+            cnonce = self._thread_local.cnonce</span>
<span class="gi">+            noncebit = f&quot;{nonce}:{nc}:{cnonce}:{qop}&quot;</span>
<span class="gi">+            respdig = KD(HA1, f&quot;{noncebit}:{HA2}&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        self._thread_local.nonce_count += 1</span>
<span class="gi">+</span>
<span class="gi">+        base = (f&#39;username=&quot;{self.username}&quot;, realm=&quot;{realm}&quot;, nonce=&quot;{nonce}&quot;, &#39;</span>
<span class="gi">+                f&#39;uri=&quot;{path}&quot;, response=&quot;{respdig}&quot;&#39;)</span>
<span class="gi">+        if opaque:</span>
<span class="gi">+            base += f&#39;, opaque=&quot;{opaque}&quot;&#39;</span>
<span class="gi">+        if algorithm:</span>
<span class="gi">+            base += f&#39;, algorithm=&quot;{algorithm}&quot;&#39;</span>
<span class="gi">+        if entdig:</span>
<span class="gi">+            base += f&#39;, digest=&quot;{entdig}&quot;&#39;</span>
<span class="gi">+        if qop:</span>
<span class="gi">+            base += f&#39;, qop=&quot;{qop}&quot;&#39;</span>
<span class="gi">+        if &#39;auth&#39; in qop.split(&#39;,&#39;):</span>
<span class="gi">+            base += f&#39;, nc={nc}, cnonce=&quot;{cnonce}&quot;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        return f&#39;Digest {base}&#39;</span>

<span class="w"> </span>    def handle_redirect(self, r, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Reset num_401_calls counter on redirects.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if r.is_redirect:</span>
<span class="gi">+            self._thread_local.num_401_calls = 1</span>

<span class="w"> </span>    def handle_401(self, r, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -84,7 +166,35 @@ class HTTPDigestAuth(AuthBase):</span>

<span class="w"> </span>        :rtype: requests.Response
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if r.status_code != 401:</span>
<span class="gi">+            self._thread_local.num_401_calls = 1</span>
<span class="gi">+            return r</span>
<span class="gi">+</span>
<span class="gi">+        s_auth = r.headers.get(&#39;www-authenticate&#39;, &#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if &#39;digest&#39; in s_auth.lower() and self._thread_local.num_401_calls &lt; 2:</span>
<span class="gi">+            self._thread_local.num_401_calls += 1</span>
<span class="gi">+            pat = re.compile(r&#39;digest &#39;, flags=re.IGNORECASE)</span>
<span class="gi">+            self._thread_local.chal = parse_dict_header(pat.sub(&#39;&#39;, s_auth, count=1))</span>
<span class="gi">+</span>
<span class="gi">+            # Consume content and release the original connection</span>
<span class="gi">+            # to allow our new request to reuse the same one.</span>
<span class="gi">+            r.content</span>
<span class="gi">+            r.close()</span>
<span class="gi">+            prep = r.request.copy()</span>
<span class="gi">+            extract_cookies_to_jar(prep._cookies, r.request, r.raw)</span>
<span class="gi">+            prep.prepare_cookies(prep._cookies)</span>
<span class="gi">+</span>
<span class="gi">+            prep.headers[&#39;Authorization&#39;] = self.build_digest_header(</span>
<span class="gi">+                prep.method, prep.url)</span>
<span class="gi">+            _r = r.connection.send(prep, **kwargs)</span>
<span class="gi">+            _r.history.append(r)</span>
<span class="gi">+            _r.request = prep</span>
<span class="gi">+</span>
<span class="gi">+            return _r</span>
<span class="gi">+</span>
<span class="gi">+        self._thread_local.num_401_calls = 1</span>
<span class="gi">+        return r</span>

<span class="w"> </span>    def __call__(self, r):
<span class="w"> </span>        self.init_per_thread_state()
<span class="gh">diff --git a/src/requests/compat.py b/src/requests/compat.py</span>
<span class="gh">index d4d04060..f792e4a5 100644</span>
<span class="gd">--- a/src/requests/compat.py</span>
<span class="gi">+++ b/src/requests/compat.py</span>
<span class="gu">@@ -12,7 +12,15 @@ import sys</span>

<span class="w"> </span>def _resolve_char_detection():
<span class="w"> </span>    &quot;&quot;&quot;Find supported character detection libraries.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        import charset_normalizer</span>
<span class="gi">+        return charset_normalizer</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        try:</span>
<span class="gi">+            import chardet</span>
<span class="gi">+            return chardet</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            return None</span>


<span class="w"> </span>chardet = _resolve_char_detection()
<span class="gh">diff --git a/src/requests/cookies.py b/src/requests/cookies.py</span>
<span class="gh">index 6392b7bc..4079fe6d 100644</span>
<span class="gd">--- a/src/requests/cookies.py</span>
<span class="gi">+++ b/src/requests/cookies.py</span>
<span class="gu">@@ -61,7 +61,13 @@ def extract_cookies_to_jar(jar, request, response):</span>
<span class="w"> </span>    :param request: our own requests.Request object
<span class="w"> </span>    :param response: urllib3.HTTPResponse object
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not (hasattr(response, &#39;_original_response&#39;) and</span>
<span class="gi">+            hasattr(response._original_response, &#39;msg&#39;)):</span>
<span class="gi">+        return</span>
<span class="gi">+    req = MockRequest(request)</span>
<span class="gi">+    # the _original_response field is the wrapped httplib.HTTPResponse object</span>
<span class="gi">+    res = MockResponse(response._original_response.msg)</span>
<span class="gi">+    jar.extract_cookies(res, req)</span>


<span class="w"> </span>def get_cookie_header(jar, request):
<span class="gu">@@ -70,7 +76,9 @@ def get_cookie_header(jar, request):</span>

<span class="w"> </span>    :rtype: str
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    r = MockRequest(request)</span>
<span class="gi">+    jar.add_cookie_header(r)</span>
<span class="gi">+    return r.get_new_headers().get(&#39;Cookie&#39;)</span>


<span class="w"> </span>def remove_cookie_by_name(cookiejar, name, domain=None, path=None):
<span class="gu">@@ -78,7 +86,18 @@ def remove_cookie_by_name(cookiejar, name, domain=None, path=None):</span>

<span class="w"> </span>    Wraps CookieJar.clear(), is O(n).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    clearables = []</span>
<span class="gi">+    for cookie in cookiejar:</span>
<span class="gi">+        if cookie.name != name:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if domain is not None and domain != cookie.domain:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if path is not None and path != cookie.path:</span>
<span class="gi">+            continue</span>
<span class="gi">+        clearables.append((cookie.domain, cookie.path, cookie.name))</span>
<span class="gi">+</span>
<span class="gi">+    for domain, path, name in clearables:</span>
<span class="gi">+        cookiejar.clear(domain, path, name)</span>


<span class="w"> </span>class CookieConflictError(RuntimeError):
<span class="gu">@@ -112,14 +131,22 @@ class RequestsCookieJar(cookielib.CookieJar, MutableMapping):</span>

<span class="w"> </span>        .. warning:: operation is O(n), not O(1).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._find_no_duplicates(name, domain, path)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return default</span>

<span class="w"> </span>    def set(self, name, value, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Dict-like set() that also supports optional domain and path args in
<span class="w"> </span>        order to resolve naming collisions from using one cookie jar over
<span class="w"> </span>        multiple domains.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(value, Morsel):</span>
<span class="gi">+            c = morsel_to_cookie(value)</span>
<span class="gi">+        else:</span>
<span class="gi">+            c = create_cookie(name, value, **kwargs)</span>
<span class="gi">+        self.set_cookie(c)</span>
<span class="gi">+        return c</span>

<span class="w"> </span>    def iterkeys(self):
<span class="w"> </span>        &quot;&quot;&quot;Dict-like iterkeys() that returns an iterator of names of cookies
<span class="gu">@@ -127,7 +154,8 @@ class RequestsCookieJar(cookielib.CookieJar, MutableMapping):</span>

<span class="w"> </span>        .. seealso:: itervalues() and iteritems().
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for cookie in iter(self):</span>
<span class="gi">+            yield cookie.name</span>

<span class="w"> </span>    def keys(self):
<span class="w"> </span>        &quot;&quot;&quot;Dict-like keys() that returns a list of names of cookies from the
<span class="gu">@@ -135,7 +163,7 @@ class RequestsCookieJar(cookielib.CookieJar, MutableMapping):</span>

<span class="w"> </span>        .. seealso:: values() and items().
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return list(self.iterkeys())</span>

<span class="w"> </span>    def itervalues(self):
<span class="w"> </span>        &quot;&quot;&quot;Dict-like itervalues() that returns an iterator of values of cookies
<span class="gu">@@ -143,7 +171,8 @@ class RequestsCookieJar(cookielib.CookieJar, MutableMapping):</span>

<span class="w"> </span>        .. seealso:: iterkeys() and iteritems().
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for cookie in iter(self):</span>
<span class="gi">+            yield cookie.value</span>

<span class="w"> </span>    def values(self):
<span class="w"> </span>        &quot;&quot;&quot;Dict-like values() that returns a list of values of cookies from the
<span class="gu">@@ -151,7 +180,7 @@ class RequestsCookieJar(cookielib.CookieJar, MutableMapping):</span>

<span class="w"> </span>        .. seealso:: keys() and items().
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return list(self.itervalues())</span>

<span class="w"> </span>    def iteritems(self):
<span class="w"> </span>        &quot;&quot;&quot;Dict-like iteritems() that returns an iterator of name-value tuples
<span class="gu">@@ -159,7 +188,8 @@ class RequestsCookieJar(cookielib.CookieJar, MutableMapping):</span>

<span class="w"> </span>        .. seealso:: iterkeys() and itervalues().
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for cookie in iter(self):</span>
<span class="gi">+            yield cookie.name, cookie.value</span>

<span class="w"> </span>    def items(self):
<span class="w"> </span>        &quot;&quot;&quot;Dict-like items() that returns a list of name-value tuples from the
<span class="gu">@@ -168,15 +198,23 @@ class RequestsCookieJar(cookielib.CookieJar, MutableMapping):</span>

<span class="w"> </span>        .. seealso:: keys() and values().
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return list(self.iteritems())</span>

<span class="w"> </span>    def list_domains(self):
<span class="w"> </span>        &quot;&quot;&quot;Utility method to list all the domains in the jar.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        domains = []</span>
<span class="gi">+        for cookie in iter(self):</span>
<span class="gi">+            if cookie.domain not in domains:</span>
<span class="gi">+                domains.append(cookie.domain)</span>
<span class="gi">+        return domains</span>

<span class="w"> </span>    def list_paths(self):
<span class="w"> </span>        &quot;&quot;&quot;Utility method to list all the paths in the jar.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        paths = []</span>
<span class="gi">+        for cookie in iter(self):</span>
<span class="gi">+            if cookie.path not in paths:</span>
<span class="gi">+                paths.append(cookie.path)</span>
<span class="gi">+        return paths</span>

<span class="w"> </span>    def multiple_domains(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if there are multiple domains in the jar.
<span class="gu">@@ -184,7 +222,8 @@ class RequestsCookieJar(cookielib.CookieJar, MutableMapping):</span>

<span class="w"> </span>        :rtype: bool
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        domains = self.list_domains()</span>
<span class="gi">+        return len(domains) &gt; 1</span>

<span class="w"> </span>    def get_dict(self, domain=None, path=None):
<span class="w"> </span>        &quot;&quot;&quot;Takes as an argument an optional domain and path and returns a plain
<span class="gu">@@ -193,7 +232,12 @@ class RequestsCookieJar(cookielib.CookieJar, MutableMapping):</span>

<span class="w"> </span>        :rtype: dict
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        dictionary = {}</span>
<span class="gi">+        for cookie in iter(self):</span>
<span class="gi">+            if (domain is None or cookie.domain == domain) and \</span>
<span class="gi">+               (path is None or cookie.path == path):</span>
<span class="gi">+                dictionary[cookie.name] = cookie.value</span>
<span class="gi">+        return dictionary</span>

<span class="w"> </span>    def __contains__(self, name):
<span class="w"> </span>        try:
<span class="gu">@@ -282,12 +326,68 @@ def create_cookie(name, value, **kwargs):</span>
<span class="w"> </span>    By default, the pair of `name` and `value` will be set for the domain &#39;&#39;
<span class="w"> </span>    and sent on every request (this is sometimes called a &quot;supercookie&quot;).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = {</span>
<span class="gi">+        &#39;version&#39;: 0,</span>
<span class="gi">+        &#39;name&#39;: name,</span>
<span class="gi">+        &#39;value&#39;: value,</span>
<span class="gi">+        &#39;port&#39;: None,</span>
<span class="gi">+        &#39;domain&#39;: &#39;&#39;,</span>
<span class="gi">+        &#39;path&#39;: &#39;/&#39;,</span>
<span class="gi">+        &#39;secure&#39;: False,</span>
<span class="gi">+        &#39;expires&#39;: None,</span>
<span class="gi">+        &#39;discard&#39;: True,</span>
<span class="gi">+        &#39;comment&#39;: None,</span>
<span class="gi">+        &#39;comment_url&#39;: None,</span>
<span class="gi">+        &#39;rest&#39;: {&#39;HttpOnly&#39;: None},</span>
<span class="gi">+        &#39;rfc2109&#39;: False,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    badargs = set(kwargs) - set(result)</span>
<span class="gi">+    if badargs:</span>
<span class="gi">+        err = &#39;create_cookie() got unexpected keyword arguments: %s&#39;</span>
<span class="gi">+        raise TypeError(err % list(badargs))</span>
<span class="gi">+</span>
<span class="gi">+    result.update(kwargs)</span>
<span class="gi">+    result[&#39;port_specified&#39;] = bool(result[&#39;port&#39;])</span>
<span class="gi">+    result[&#39;domain_specified&#39;] = bool(result[&#39;domain&#39;])</span>
<span class="gi">+    result[&#39;domain_initial_dot&#39;] = result[&#39;domain&#39;].startswith(&#39;.&#39;)</span>
<span class="gi">+    result[&#39;path_specified&#39;] = bool(result[&#39;path&#39;])</span>
<span class="gi">+</span>
<span class="gi">+    return cookielib.Cookie(**result)</span>


<span class="w"> </span>def morsel_to_cookie(morsel):
<span class="w"> </span>    &quot;&quot;&quot;Convert a Morsel object into a Cookie containing the one k/v pair.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    expires = None</span>
<span class="gi">+    if morsel[&#39;max-age&#39;]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            expires = int(time.time() + int(morsel[&#39;max-age&#39;]))</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            pass</span>
<span class="gi">+    elif morsel[&#39;expires&#39;]:</span>
<span class="gi">+        time_template = &quot;%a, %d-%b-%Y %H:%M:%S GMT&quot;</span>
<span class="gi">+        expires = calendar.timegm(</span>
<span class="gi">+            time.strptime(morsel[&#39;expires&#39;], time_template)</span>
<span class="gi">+        )</span>
<span class="gi">+    return create_cookie(</span>
<span class="gi">+        name=morsel.key,</span>
<span class="gi">+        value=morsel.value,</span>
<span class="gi">+        version=0,</span>
<span class="gi">+        port=None,</span>
<span class="gi">+        port_specified=False,</span>
<span class="gi">+        domain=morsel[&#39;domain&#39;],</span>
<span class="gi">+        domain_specified=bool(morsel[&#39;domain&#39;]),</span>
<span class="gi">+        domain_initial_dot=morsel[&#39;domain&#39;].startswith(&#39;.&#39;),</span>
<span class="gi">+        path=morsel[&#39;path&#39;],</span>
<span class="gi">+        path_specified=bool(morsel[&#39;path&#39;]),</span>
<span class="gi">+        secure=bool(morsel[&#39;secure&#39;]),</span>
<span class="gi">+        expires=expires,</span>
<span class="gi">+        discard=False,</span>
<span class="gi">+        comment=morsel[&#39;comment&#39;],</span>
<span class="gi">+        comment_url=bool(morsel[&#39;comment&#39;]),</span>
<span class="gi">+        rest={&#39;HttpOnly&#39;: morsel[&#39;httponly&#39;]},</span>
<span class="gi">+        rfc2109=False,</span>
<span class="gi">+    )</span>


<span class="w"> </span>def cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True):
<span class="gu">@@ -299,7 +399,16 @@ def cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True):</span>
<span class="w"> </span>        already in the jar with new ones.
<span class="w"> </span>    :rtype: CookieJar
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if cookiejar is None:</span>
<span class="gi">+        cookiejar = RequestsCookieJar()</span>
<span class="gi">+</span>
<span class="gi">+    if cookie_dict is not None:</span>
<span class="gi">+        names_from_jar = [cookie.name for cookie in cookiejar]</span>
<span class="gi">+        for name in cookie_dict:</span>
<span class="gi">+            if overwrite or (name not in names_from_jar):</span>
<span class="gi">+                cookiejar.set_cookie(create_cookie(name, cookie_dict[name]))</span>
<span class="gi">+</span>
<span class="gi">+    return cookiejar</span>


<span class="w"> </span>def merge_cookies(cookiejar, cookies):
<span class="gu">@@ -309,4 +418,14 @@ def merge_cookies(cookiejar, cookies):</span>
<span class="w"> </span>    :param cookies: Dictionary or CookieJar object to be added.
<span class="w"> </span>    :rtype: CookieJar
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(cookiejar, cookielib.CookieJar):</span>
<span class="gi">+        raise ValueError(&#39;You can only merge into CookieJar&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(cookies, dict):</span>
<span class="gi">+        cookiejar = cookiejar_from_dict(</span>
<span class="gi">+            cookies, cookiejar=cookiejar, overwrite=False)</span>
<span class="gi">+    elif isinstance(cookies, cookielib.CookieJar):</span>
<span class="gi">+        for cookie in cookies:</span>
<span class="gi">+            cookiejar.set_cookie(cookie)</span>
<span class="gi">+</span>
<span class="gi">+    return cookiejar</span>
<span class="gh">diff --git a/src/requests/help.py b/src/requests/help.py</span>
<span class="gh">index 8057ee09..91dae62e 100644</span>
<span class="gd">--- a/src/requests/help.py</span>
<span class="gi">+++ b/src/requests/help.py</span>
<span class="gu">@@ -36,17 +36,83 @@ def _implementation():</span>
<span class="w"> </span>    doesn&#39;t work for Jython or IronPython. Future investigation should be done
<span class="w"> </span>    to work out the correct shape of the code for those platforms.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    implementation = platform.python_implementation()</span>
<span class="gi">+    version = platform.python_version()</span>
<span class="gi">+    return {&#39;name&#39;: implementation, &#39;version&#39;: version}</span>


<span class="w"> </span>def info():
<span class="w"> </span>    &quot;&quot;&quot;Generate information for a bug report.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        import urllib3</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        urllib3 = None</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        import chardet</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        chardet = None</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        import charset_normalizer</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        charset_normalizer = None</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        from urllib3.contrib import pyopenssl</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        pyopenssl = None</span>
<span class="gi">+        OpenSSL = None</span>
<span class="gi">+        cryptography = None</span>
<span class="gi">+    else:</span>
<span class="gi">+        import cryptography</span>
<span class="gi">+        import OpenSSL</span>
<span class="gi">+</span>
<span class="gi">+    system_ssl = ssl.OPENSSL_VERSION_INFO</span>
<span class="gi">+    system_ssl_info = {&#39;name&#39;: &#39;OpenSSL&#39;, &#39;version&#39;: f&#39;{system_ssl[0]}.{system_ssl[1]}.{system_ssl[2]}&#39;}</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &#39;platform&#39;: {</span>
<span class="gi">+            &#39;system&#39;: platform.system(),</span>
<span class="gi">+            &#39;release&#39;: platform.release(),</span>
<span class="gi">+        },</span>
<span class="gi">+        &#39;implementation&#39;: _implementation(),</span>
<span class="gi">+        &#39;python&#39;: {</span>
<span class="gi">+            &#39;version&#39;: platform.python_version(),</span>
<span class="gi">+            &#39;executable&#39;: sys.executable,</span>
<span class="gi">+            &#39;build&#39;: platform.python_build(),</span>
<span class="gi">+        },</span>
<span class="gi">+        &#39;requests&#39;: {</span>
<span class="gi">+            &#39;version&#39;: requests_version,</span>
<span class="gi">+        },</span>
<span class="gi">+        &#39;urllib3&#39;: {</span>
<span class="gi">+            &#39;version&#39;: urllib3.__version__ if urllib3 else None,</span>
<span class="gi">+        },</span>
<span class="gi">+        &#39;chardet&#39;: {</span>
<span class="gi">+            &#39;version&#39;: chardet.__version__ if chardet else None,</span>
<span class="gi">+        },</span>
<span class="gi">+        &#39;charset_normalizer&#39;: {</span>
<span class="gi">+            &#39;version&#39;: charset_normalizer.__version__ if charset_normalizer else None,</span>
<span class="gi">+        },</span>
<span class="gi">+        &#39;idna&#39;: {</span>
<span class="gi">+            &#39;version&#39;: idna.__version__,</span>
<span class="gi">+        },</span>
<span class="gi">+        &#39;system_ssl&#39;: system_ssl_info,</span>
<span class="gi">+        &#39;pyopenssl&#39;: {</span>
<span class="gi">+            &#39;version&#39;: OpenSSL.version.__version__ if OpenSSL else None,</span>
<span class="gi">+            &#39;openssl_version&#39;: OpenSSL.SSL.SSLeay_version(OpenSSL.SSL.SSLEAY_VERSION).decode(&#39;utf-8&#39;) if OpenSSL else None,</span>
<span class="gi">+        },</span>
<span class="gi">+        &#39;cryptography&#39;: {</span>
<span class="gi">+            &#39;version&#39;: cryptography.__version__ if cryptography else None,</span>
<span class="gi">+        },</span>
<span class="gi">+        &#39;pyopenssl_subject&#39;: pyopenssl.get_subject() if pyopenssl else None,</span>
<span class="gi">+        &#39;pyopenssl_issuer&#39;: pyopenssl.get_issuer() if pyopenssl else None,</span>
<span class="gi">+    }</span>


<span class="w"> </span>def main():
<span class="w"> </span>    &quot;&quot;&quot;Pretty-print the bug information as JSON.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    print(json.dumps(info(), sort_keys=True, indent=2))</span>


<span class="w"> </span>if __name__ == &#39;__main__&#39;:
<span class="gh">diff --git a/src/requests/hooks.py b/src/requests/hooks.py</span>
<span class="gh">index 8dfca96f..6de12ac2 100644</span>
<span class="gd">--- a/src/requests/hooks.py</span>
<span class="gi">+++ b/src/requests/hooks.py</span>
<span class="gu">@@ -14,4 +14,16 @@ HOOKS = [&#39;response&#39;]</span>

<span class="w"> </span>def dispatch_hook(key, hooks, hook_data, **kwargs):
<span class="w"> </span>    &quot;&quot;&quot;Dispatches a hook dictionary on a given piece of data.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    hooks = hooks or {}</span>
<span class="gi">+    if key not in hooks:</span>
<span class="gi">+        return hook_data</span>
<span class="gi">+    </span>
<span class="gi">+    if hasattr(hooks[key], &#39;__call__&#39;):</span>
<span class="gi">+        hooks[key] = [hooks[key]]</span>
<span class="gi">+    </span>
<span class="gi">+    for hook in hooks[key]:</span>
<span class="gi">+        _hook_data = hook(hook_data, **kwargs)</span>
<span class="gi">+        if _hook_data is not None:</span>
<span class="gi">+            hook_data = _hook_data</span>
<span class="gi">+    </span>
<span class="gi">+    return hook_data</span>
<span class="gh">diff --git a/src/requests/structures.py b/src/requests/structures.py</span>
<span class="gh">index b389ca26..d3d96e7d 100644</span>
<span class="gd">--- a/src/requests/structures.py</span>
<span class="gi">+++ b/src/requests/structures.py</span>
<span class="gu">@@ -58,7 +58,7 @@ class CaseInsensitiveDict(MutableMapping):</span>

<span class="w"> </span>    def lower_items(self):
<span class="w"> </span>        &quot;&quot;&quot;Like iteritems(), but with all lowercase keys.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return ((key.lower(), value) for key, value in self._store.values())</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        if isinstance(other, Mapping):
<span class="gh">diff --git a/src/requests/utils.py b/src/requests/utils.py</span>
<span class="gh">index 504e22fc..536e053d 100644</span>
<span class="gd">--- a/src/requests/utils.py</span>
<span class="gi">+++ b/src/requests/utils.py</span>
<span class="gu">@@ -40,22 +40,71 @@ if sys.platform == &#39;win32&#39;:</span>
<span class="w"> </span>        Checks proxy settings gathered from the environment, if specified,
<span class="w"> </span>        or the registry.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return proxy_bypass_environment(host)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return False</span>


<span class="w"> </span>def dict_to_sequence(d):
<span class="w"> </span>    &quot;&quot;&quot;Returns an internal sequence dictionary update.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(d, Mapping):</span>
<span class="gi">+        return d.items()</span>
<span class="gi">+    return d</span>


<span class="w"> </span>def get_netrc_auth(url, raise_errors=False):
<span class="w"> </span>    &quot;&quot;&quot;Returns the Requests tuple auth for a given url from netrc.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        from netrc import netrc, NetrcParseError</span>
<span class="gi">+</span>
<span class="gi">+        netrc_path = None</span>
<span class="gi">+        for f in NETRC_FILES:</span>
<span class="gi">+            try:</span>
<span class="gi">+                loc = os.path.expanduser(&#39;~/{}&#39;.format(f))</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                # os.path.expanduser can fail when $HOME is undefined and</span>
<span class="gi">+                # getpwuid fails. See https://bugs.python.org/issue20164</span>
<span class="gi">+                continue</span>
<span class="gi">+</span>
<span class="gi">+            if os.path.exists(loc):</span>
<span class="gi">+                netrc_path = loc</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        # Abort early if there isn&#39;t one.</span>
<span class="gi">+        if netrc_path is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        ri = urlparse(url)</span>
<span class="gi">+</span>
<span class="gi">+        # Strip port numbers from netloc</span>
<span class="gi">+        host = ri.netloc.split(&#39;:&#39;)[0]</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            _netrc = netrc(netrc_path).authenticators(host)</span>
<span class="gi">+            if _netrc:</span>
<span class="gi">+                # Return with login / password</span>
<span class="gi">+                login_i = (0 if _netrc[0] else 1)</span>
<span class="gi">+                return (_netrc[login_i], _netrc[2])</span>
<span class="gi">+        except (NetrcParseError, IOError):</span>
<span class="gi">+            # If there was a parsing error or the file doesn&#39;t exist</span>
<span class="gi">+            if raise_errors:</span>
<span class="gi">+                raise</span>
<span class="gi">+</span>
<span class="gi">+    except (ImportError, AttributeError):</span>
<span class="gi">+        # netrc module not available or not supported</span>
<span class="gi">+        pass</span>
<span class="gi">+</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def guess_filename(obj):
<span class="w"> </span>    &quot;&quot;&quot;Tries to guess the filename of the given object.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    name = getattr(obj, &#39;name&#39;, None)</span>
<span class="gi">+    if name and isinstance(name, basestring) and name[0] != &#39;&lt;&#39; and name[-1] != &#39;&gt;&#39;:</span>
<span class="gi">+        return os.path.basename(name)</span>
<span class="gi">+</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def extract_zipped_paths(path):
<span class="gu">@@ -63,13 +112,42 @@ def extract_zipped_paths(path):</span>
<span class="w"> </span>    archive with the location of an extracted copy of the target, or else
<span class="w"> </span>    just return the provided path unchanged.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if os.path.exists(path):</span>
<span class="gi">+        return path</span>
<span class="gi">+</span>
<span class="gi">+    archive, member = os.path.split(path)</span>
<span class="gi">+    while archive and not os.path.exists(archive):</span>
<span class="gi">+        archive, prefix = os.path.split(archive)</span>
<span class="gi">+        member = &#39;/&#39;.join([prefix, member])</span>
<span class="gi">+</span>
<span class="gi">+    if not zipfile.is_zipfile(archive):</span>
<span class="gi">+        return path</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        zip_file = zipfile.ZipFile(archive)</span>
<span class="gi">+        if member not in zip_file.namelist():</span>
<span class="gi">+            return path</span>
<span class="gi">+</span>
<span class="gi">+        extracted_path = os.path.join(tempfile.gettempdir(), &#39;requests-temp&#39;, member.split(&#39;/&#39;)[-1])</span>
<span class="gi">+        if not os.path.exists(extracted_path):</span>
<span class="gi">+            extracted_path = zip_file.extract(member, path=os.path.dirname(extracted_path))</span>
<span class="gi">+        zip_file.close()</span>
<span class="gi">+        return extracted_path</span>
<span class="gi">+    except (zipfile.BadZipFile, OSError):</span>
<span class="gi">+        return path</span>


<span class="w"> </span>@contextlib.contextmanager
<span class="w"> </span>def atomic_open(filename):
<span class="w"> </span>    &quot;&quot;&quot;Write a file to the disk in an atomic fashion&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    tmp_descriptor, tmp_name = tempfile.mkstemp(dir=os.path.dirname(filename))</span>
<span class="gi">+    try:</span>
<span class="gi">+        with os.fdopen(tmp_descriptor, &#39;wb&#39;) as tmp_handler:</span>
<span class="gi">+            yield tmp_handler</span>
<span class="gi">+        os.replace(tmp_name, filename)</span>
<span class="gi">+    except BaseException:</span>
<span class="gi">+        os.remove(tmp_name)</span>
<span class="gi">+        raise</span>


<span class="w"> </span>def from_key_val_list(value):
<span class="gu">@@ -90,7 +168,13 @@ def from_key_val_list(value):</span>

<span class="w"> </span>    :rtype: OrderedDict
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(value, (str, bytes, bool, int)):</span>
<span class="gi">+        raise ValueError(&#39;cannot encode objects that are not 2-tuples&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    return OrderedDict(value)</span>


<span class="w"> </span>def to_key_val_list(value):
<span class="gu">@@ -110,7 +194,16 @@ def to_key_val_list(value):</span>

<span class="w"> </span>    :rtype: list
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(value, (str, bytes, bool, int)):</span>
<span class="gi">+        raise ValueError(&#39;cannot encode objects that are not 2-tuples&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(value, Mapping):</span>
<span class="gi">+        return list(value.items())</span>
<span class="gi">+</span>
<span class="gi">+    return value</span>


<span class="w"> </span>def parse_list_header(value):
<span class="gu">@@ -136,7 +229,7 @@ def parse_list_header(value):</span>
<span class="w"> </span>    :return: :class:`list`
<span class="w"> </span>    :rtype: list
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _parse_list_header(value)</span>


<span class="w"> </span>def parse_dict_header(value):
<span class="gu">@@ -161,7 +254,14 @@ def parse_dict_header(value):</span>
<span class="w"> </span>    :return: :class:`dict`
<span class="w"> </span>    :rtype: dict
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = {}</span>
<span class="gi">+    for item in _parse_list_header(value):</span>
<span class="gi">+        if &#39;=&#39; not in item:</span>
<span class="gi">+            result[item] = None</span>
<span class="gi">+        else:</span>
<span class="gi">+            name, value = item.split(&#39;=&#39;, 1)</span>
<span class="gi">+            result[name] = unquote_header_value(value)</span>
<span class="gi">+    return result</span>


<span class="w"> </span>def unquote_header_value(value, is_filename=False):
<span class="gu">@@ -172,7 +272,11 @@ def unquote_header_value(value, is_filename=False):</span>
<span class="w"> </span>    :param value: the header value to unquote.
<span class="w"> </span>    :rtype: str
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value and value[0] == value[-1] == &#39;&quot;&#39;:</span>
<span class="gi">+        value = value[1:-1]</span>
<span class="gi">+        if not is_filename or value[:2] != &#39;\\\\&#39;:</span>
<span class="gi">+            return value.replace(&#39;\\\\&#39;, &#39;\\&#39;).replace(&#39;\\&quot;&#39;, &#39;&quot;&#39;)</span>
<span class="gi">+    return value</span>


<span class="w"> </span>def dict_from_cookiejar(cj):
<span class="gu">@@ -181,7 +285,12 @@ def dict_from_cookiejar(cj):</span>
<span class="w"> </span>    :param cj: CookieJar object to extract cookies from.
<span class="w"> </span>    :rtype: dict
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cookie_dict = {}</span>
<span class="gi">+</span>
<span class="gi">+    for cookie in cj:</span>
<span class="gi">+        cookie_dict[cookie.name] = cookie.value</span>
<span class="gi">+</span>
<span class="gi">+    return cookie_dict</span>


<span class="w"> </span>def add_dict_to_cookiejar(cj, cookie_dict):
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>