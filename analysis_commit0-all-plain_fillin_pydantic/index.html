
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all plain fillin pydantic - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#claude-sonnet-35-fill-in-pydantic" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all plain fillin pydantic
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0-all-plain_fillin">back to Claude Sonnet 3.5 - Fill-in summary</a></p>
<h1 id="claude-sonnet-35-fill-in-pydantic"><strong>Claude Sonnet 3.5 - Fill-in</strong>: pydantic</h1>
<h2 id="failed-to-run-pytests-for-test-tests">Failed to run pytests for test <code>tests</code></h2>
<div class="highlight"><pre><span></span><code>ImportError while loading conftest &#39;/testbed/tests/conftest.py&#39;.
tests/conftest.py:17: in &lt;module&gt;
    from pydantic import GenerateSchema
pydantic/__init__.py:404: in __getattr__
    module = import_module(module_name, package=package)
pydantic/_internal/_generate_schema.py:26: in &lt;module&gt;
    from ..json_schema import JsonSchemaValue
pydantic/json_schema.py:27: in &lt;module&gt;
    from ._internal import _config, _core_metadata, _core_utils, _decorators, _internal_dataclass, _mock_val_ser, _schema_generation_shared, _typing_extra
pydantic/_internal/_core_utils.py:8: in &lt;module&gt;
    from . import _repr
pydantic/_internal/_repr.py:7: in &lt;module&gt;
    from . import _typing_extra
E     File &quot;/testbed/pydantic/_internal/_typing_extra.py&quot;, line 241
E       def is_self_type(tp: Any) -&gt;bool:
E       ^^^
E   IndentationError: expected an indented block after &#39;if&#39; statement on line 238
</code></pre></div>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/pydantic/_internal/_config.py b/pydantic/_internal/_config.py</span>
<span class="gh">index 9809c1f3..8e69c9cf 100644</span>
<span class="gd">--- a/pydantic/_internal/_config.py</span>
<span class="gi">+++ b/pydantic/_internal/_config.py</span>
<span class="gu">@@ -89,7 +89,17 @@ class ConfigWrapper:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A `ConfigWrapper` instance for `BaseModel`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        config_dict = {}</span>
<span class="gi">+        for base in reversed(bases):</span>
<span class="gi">+            if hasattr(base, &#39;__pydantic_config__&#39;):</span>
<span class="gi">+                config_dict.update(base.__pydantic_config__.config_dict)</span>
<span class="gi">+        </span>
<span class="gi">+        if &#39;Config&#39; in namespace:</span>
<span class="gi">+            config_dict.update(prepare_config(namespace[&#39;Config&#39;]))</span>
<span class="gi">+        </span>
<span class="gi">+        config_dict.update({k: v for k, v in kwargs.items() if k in config_keys})</span>
<span class="gi">+        </span>
<span class="gi">+        return cls(config_dict)</span>
<span class="w"> </span>    if not TYPE_CHECKING:

<span class="w"> </span>        def __getattr__(self, name: str) -&gt;Any:
<span class="gu">@@ -115,7 +125,20 @@ class ConfigWrapper:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A `CoreConfig` object created from config.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        config = {}</span>
<span class="gi">+        if &#39;title&#39; in self.config_dict:</span>
<span class="gi">+            config[&#39;title&#39;] = self.config_dict[&#39;title&#39;]</span>
<span class="gi">+        elif obj is not None:</span>
<span class="gi">+            config[&#39;title&#39;] = obj.__name__</span>
<span class="gi">+</span>
<span class="gi">+        for key in [&#39;strict&#39;, &#39;from_attributes&#39;, &#39;populate_by_name&#39;, &#39;str_to_lower&#39;, &#39;str_to_upper&#39;,</span>
<span class="gi">+                    &#39;str_strip_whitespace&#39;, &#39;str_min_length&#39;, &#39;str_max_length&#39;, &#39;frozen&#39;,</span>
<span class="gi">+                    &#39;extra&#39;, &#39;ser_json_timedelta&#39;, &#39;ser_json_bytes&#39;, &#39;ser_json_inf_nan&#39;,</span>
<span class="gi">+                    &#39;validate_default&#39;, &#39;hide_input_in_errors&#39;]:</span>
<span class="gi">+            if key in self.config_dict:</span>
<span class="gi">+                config[key] = self.config_dict[key]</span>
<span class="gi">+</span>
<span class="gi">+        return core_schema.CoreConfig(**config)</span>

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        c = &#39;, &#39;.join(f&#39;{k}={v!r}&#39; for k, v in self.config_dict.items())
<span class="gu">@@ -157,7 +180,18 @@ def prepare_config(config: (ConfigDict | dict[str, Any] | type[Any] | None)</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        A ConfigDict object created from config.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if config is None:</span>
<span class="gi">+        return ConfigDict()</span>
<span class="gi">+    elif isinstance(config, dict):</span>
<span class="gi">+        return ConfigDict(**config)</span>
<span class="gi">+    elif isinstance(config, type):</span>
<span class="gi">+        if hasattr(config, &#39;__pydantic_config__&#39;):</span>
<span class="gi">+            return config.__pydantic_config__.config_dict.copy()</span>
<span class="gi">+        else:</span>
<span class="gi">+            warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning, stacklevel=2)</span>
<span class="gi">+            return ConfigDict(**{k: getattr(config, k) for k in dir(config) if not k.startswith(&#39;__&#39;)})</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(f&quot;Config must be a ConfigDict, dict, class, or None, not {type(config)}&quot;)</span>


<span class="w"> </span>config_keys = set(ConfigDict.__annotations__.keys())
<span class="gu">@@ -179,4 +213,17 @@ def check_deprecated(config_dict: ConfigDict) -&gt;None:</span>
<span class="w"> </span>    Args:
<span class="w"> </span>        config_dict: The input config.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for key in config_dict:</span>
<span class="gi">+        if key in V2_REMOVED_KEYS:</span>
<span class="gi">+            warnings.warn(</span>
<span class="gi">+                f&quot;Config key &#39;{key}&#39; has been removed in V2&quot;,</span>
<span class="gi">+                DeprecationWarning,</span>
<span class="gi">+                stacklevel=2</span>
<span class="gi">+            )</span>
<span class="gi">+        elif key in V2_RENAMED_KEYS:</span>
<span class="gi">+            new_key = V2_RENAMED_KEYS[key]</span>
<span class="gi">+            warnings.warn(</span>
<span class="gi">+                f&quot;Config key &#39;{key}&#39; has been renamed to &#39;{new_key}&#39; in V2&quot;,</span>
<span class="gi">+                DeprecationWarning,</span>
<span class="gi">+                stacklevel=2</span>
<span class="gi">+            )</span>
<span class="gh">diff --git a/pydantic/_internal/_core_metadata.py b/pydantic/_internal/_core_metadata.py</span>
<span class="gh">index e9361dbe..4bccb34f 100644</span>
<span class="gd">--- a/pydantic/_internal/_core_metadata.py</span>
<span class="gi">+++ b/pydantic/_internal/_core_metadata.py</span>
<span class="gu">@@ -43,7 +43,10 @@ class CoreMetadataHandler:</span>
<span class="w"> </span>        &quot;&quot;&quot;Retrieves the metadata dict from the schema, initializing it to a dict if it is None
<span class="w"> </span>        and raises an error if it is not a dict.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        metadata = self._schema[&#39;metadata&#39;]</span>
<span class="gi">+        if not isinstance(metadata, dict):</span>
<span class="gi">+            raise TypeError(f&#39;CoreSchema metadata should be a dict; got {metadata!r}.&#39;)</span>
<span class="gi">+        return typing.cast(CoreMetadata, metadata)</span>


<span class="w"> </span>def build_metadata_dict(*, js_functions: (list[GetJsonSchemaFunction] |
<span class="gu">@@ -54,4 +57,19 @@ def build_metadata_dict(*, js_functions: (list[GetJsonSchemaFunction] |</span>
<span class="w"> </span>    &quot;&quot;&quot;Builds a dict to use as the metadata field of a CoreSchema object in a manner that is consistent
<span class="w"> </span>    with the CoreMetadataHandler class.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    metadata = CoreMetadata()</span>
<span class="gi">+    if initial_metadata:</span>
<span class="gi">+        if not isinstance(initial_metadata, dict):</span>
<span class="gi">+            raise TypeError(f&#39;initial_metadata should be a dict; got {initial_metadata!r}.&#39;)</span>
<span class="gi">+        metadata.update(initial_metadata)</span>
<span class="gi">+    </span>
<span class="gi">+    if js_functions:</span>
<span class="gi">+        metadata[&#39;pydantic_js_functions&#39;] = js_functions</span>
<span class="gi">+    if js_annotation_functions:</span>
<span class="gi">+        metadata[&#39;pydantic_js_annotation_functions&#39;] = js_annotation_functions</span>
<span class="gi">+    if js_prefer_positional_arguments is not None:</span>
<span class="gi">+        metadata[&#39;pydantic_js_prefer_positional_arguments&#39;] = js_prefer_positional_arguments</span>
<span class="gi">+    if typed_dict_cls:</span>
<span class="gi">+        metadata[&#39;pydantic_typed_dict_cls&#39;] = typed_dict_cls</span>
<span class="gi">+    </span>
<span class="gi">+    return metadata</span>
<span class="gh">diff --git a/pydantic/_internal/_core_utils.py b/pydantic/_internal/_core_utils.py</span>
<span class="gh">index 5f858e63..85d9b519 100644</span>
<span class="gd">--- a/pydantic/_internal/_core_utils.py</span>
<span class="gi">+++ b/pydantic/_internal/_core_utils.py</span>
<span class="gu">@@ -38,14 +38,25 @@ def get_type_ref(type_: type[Any], args_override: (tuple[type[Any], ...] |</span>
<span class="w"> </span>    This `args_override` argument was added for the purpose of creating valid recursive references
<span class="w"> </span>    when creating generic models without needing to create a concrete class.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if args_override is not None:</span>
<span class="gi">+        type_args = args_override</span>
<span class="gi">+    elif is_generic_alias(type_):</span>
<span class="gi">+        type_args = get_args(type_)</span>
<span class="gi">+    else:</span>
<span class="gi">+        type_args = ()</span>
<span class="gi">+    </span>
<span class="gi">+    type_name = type_.__name__</span>
<span class="gi">+    if type_args:</span>
<span class="gi">+        args_str = &#39;,&#39;.join(arg.__name__ for arg in type_args)</span>
<span class="gi">+        return f&#39;{type_name}[{args_str}]&#39;</span>
<span class="gi">+    return type_name</span>


<span class="w"> </span>def get_ref(s: core_schema.CoreSchema) -&gt;(None | str):
<span class="w"> </span>    &quot;&quot;&quot;Get the ref from the schema if it has one.
<span class="w"> </span>    This exists just for type checking to work correctly.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return s.get(&#39;ref&#39;)</span>


<span class="w"> </span>T = TypeVar(&#39;T&#39;)
<span class="gu">@@ -77,7 +88,7 @@ def walk_core_schema(schema: core_schema.CoreSchema, f: Walk</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        core_schema.CoreSchema: A processed CoreSchema.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return _dispatch(schema, f)</span>


<span class="w"> </span>def pretty_print_core_schema(schema: CoreSchema, include_metadata: bool=False
<span class="gu">@@ -89,4 +100,19 @@ def pretty_print_core_schema(schema: CoreSchema, include_metadata: bool=False</span>
<span class="w"> </span>        schema: The CoreSchema to print.
<span class="w"> </span>        include_metadata: Whether to include metadata in the output. Defaults to `False`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        from rich import print as rich_print</span>
<span class="gi">+        from rich.pretty import Pretty</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        print(&quot;Rich library is not installed. Please install it to use this function.&quot;)</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    def _process_schema(s: CoreSchema) -&gt; dict:</span>
<span class="gi">+        result = {k: v for k, v in s.items() if k != &#39;metadata&#39; or include_metadata}</span>
<span class="gi">+        for key, value in result.items():</span>
<span class="gi">+            if isinstance(value, dict) and &#39;type&#39; in value:</span>
<span class="gi">+                result[key] = _process_schema(value)</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    processed_schema = _process_schema(schema)</span>
<span class="gi">+    rich_print(Pretty(processed_schema, expand_all=True))</span>
<span class="gh">diff --git a/pydantic/_internal/_dataclasses.py b/pydantic/_internal/_dataclasses.py</span>
<span class="gh">index 35f40c50..7c67b501 100644</span>
<span class="gd">--- a/pydantic/_internal/_dataclasses.py</span>
<span class="gi">+++ b/pydantic/_internal/_dataclasses.py</span>
<span class="gu">@@ -65,7 +65,8 @@ def set_dataclass_fields(cls: type[StandardDataclass], types_namespace: (</span>
<span class="w"> </span>        types_namespace: The types namespace, defaults to `None`.
<span class="w"> </span>        config_wrapper: The config wrapper instance, defaults to `None`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    fields = collect_dataclass_fields(cls, types_namespace, config_wrapper)</span>
<span class="gi">+    cls.__pydantic_fields__ = fields</span>


<span class="w"> </span>def complete_dataclass(cls: type[Any], config_wrapper: _config.
<span class="gu">@@ -89,7 +90,28 @@ def complete_dataclass(cls: type[Any], config_wrapper: _config.</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        PydanticUndefinedAnnotation: If `raise_error` is `True` and there is an undefined annotations.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        set_dataclass_fields(cls, types_namespace, config_wrapper)</span>
<span class="gi">+        </span>
<span class="gi">+        generate_schema = GenerateSchema(config_wrapper)</span>
<span class="gi">+        core_schema = generate_schema.generate_schema(cls)</span>
<span class="gi">+        </span>
<span class="gi">+        cls.__pydantic_core_schema__ = core_schema</span>
<span class="gi">+        cls.__pydantic_validator__ = create_schema_validator(</span>
<span class="gi">+            core_schema,</span>
<span class="gi">+            cls,</span>
<span class="gi">+            config_wrapper,</span>
<span class="gi">+            CallbackGetCoreSchemaHandler(generate_schema)</span>
<span class="gi">+        )</span>
<span class="gi">+        cls.__pydantic_serializer__ = SchemaSerializer(core_schema)</span>
<span class="gi">+        </span>
<span class="gi">+        set_dataclass_mocks(cls)</span>
<span class="gi">+        cls.__pydantic_complete__ = True</span>
<span class="gi">+        return True</span>
<span class="gi">+    except PydanticUndefinedAnnotation:</span>
<span class="gi">+        if raise_errors:</span>
<span class="gi">+            raise</span>
<span class="gi">+        return False</span>


<span class="w"> </span>def is_builtin_dataclass(_cls: type[Any]) -&gt;TypeGuard[type[StandardDataclass]]:
<span class="gu">@@ -122,4 +144,13 @@ def is_builtin_dataclass(_cls: type[Any]) -&gt;TypeGuard[type[StandardDataclass]]:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        `True` if the class is a stdlib dataclass, `False` otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not dataclasses.is_dataclass(_cls):</span>
<span class="gi">+        return False</span>
<span class="gi">+    </span>
<span class="gi">+    if hasattr(_cls, &#39;__pydantic_validator__&#39;):</span>
<span class="gi">+        return False</span>
<span class="gi">+    </span>
<span class="gi">+    annotations = _typing_extra.get_class_annotations(_cls)</span>
<span class="gi">+    dataclass_fields = set(_cls.__dataclass_fields__.keys())</span>
<span class="gi">+    </span>
<span class="gi">+    return set(annotations.keys()).issubset(dataclass_fields)</span>
<span class="gh">diff --git a/pydantic/_internal/_decorators.py b/pydantic/_internal/_decorators.py</span>
<span class="gh">index cc38227b..eac12643 100644</span>
<span class="gd">--- a/pydantic/_internal/_decorators.py</span>
<span class="gi">+++ b/pydantic/_internal/_decorators.py</span>
<span class="gu">@@ -214,7 +214,9 @@ class Decorator(Generic[DecoratorInfoType]):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The new decorator instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cls_ref = get_type_ref(cls_)</span>
<span class="gi">+        func = get_attribute_from_base_dicts(cls_, cls_var_name)</span>
<span class="gi">+        return Decorator(cls_ref=cls_ref, cls_var_name=cls_var_name, func=func, shim=shim, info=info)</span>

<span class="w"> </span>    def bind_to_cls(self, cls: Any) -&gt;Decorator[DecoratorInfoType]:
<span class="w"> </span>        &quot;&quot;&quot;Bind the decorator to a class.
<span class="gu">@@ -225,7 +227,9 @@ class Decorator(Generic[DecoratorInfoType]):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The new decorator instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        cls_ref = get_type_ref(cls)</span>
<span class="gi">+        func = get_attribute_from_base_dicts(cls, self.cls_var_name)</span>
<span class="gi">+        return Decorator(cls_ref=cls_ref, cls_var_name=self.cls_var_name, func=func, shim=self.shim, info=self.info)</span>


<span class="w"> </span>def get_bases(tp: type[Any]) -&gt;tuple[type[Any], ...]:
<span class="gu">@@ -237,7 +241,9 @@ def get_bases(tp: type[Any]) -&gt;tuple[type[Any], ...]:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The base classes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if is_typeddict(tp):</span>
<span class="gi">+        return tp.__orig_bases__</span>
<span class="gi">+    return tp.__bases__</span>


<span class="w"> </span>def mro(tp: type[Any]) -&gt;tuple[type[Any], ...]:
<span class="gu">@@ -245,7 +251,28 @@ def mro(tp: type[Any]) -&gt;tuple[type[Any], ...]:</span>

<span class="w"> </span>    See https://www.python.org/download/releases/2.3/mro/
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if hasattr(tp, &#39;__mro__&#39;):</span>
<span class="gi">+        return tp.__mro__</span>
<span class="gi">+    else:</span>
<span class="gi">+        # Implement C3 linearization for types without __mro__</span>
<span class="gi">+        def merge(seqs):</span>
<span class="gi">+            res = []</span>
<span class="gi">+            i = 0</span>
<span class="gi">+            while True:</span>
<span class="gi">+                nonempty = [seq for seq in seqs if seq]</span>
<span class="gi">+                if not nonempty:</span>
<span class="gi">+                    return tuple(res)</span>
<span class="gi">+                for seq in nonempty:</span>
<span class="gi">+                    head = seq[0]</span>
<span class="gi">+                    if not any(head in s[1:] for s in nonempty):</span>
<span class="gi">+                        break</span>
<span class="gi">+                else:</span>
<span class="gi">+                    raise TypeError(&quot;Inconsistent hierarchy&quot;)</span>
<span class="gi">+                res.append(head)</span>
<span class="gi">+                for seq in nonempty:</span>
<span class="gi">+                    if seq[0] == head:</span>
<span class="gi">+                        del seq[0]</span>
<span class="gi">+        return tuple(merge([[tp]] + [list(mro(base)) for base in get_bases(tp)] + [list(get_bases(tp))]))</span>


<span class="w"> </span>_sentinel = object()
<span class="gu">@@ -271,7 +298,16 @@ def get_attribute_from_bases(tp: (type[Any] | tuple[type[Any], ...]), name: str</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        AttributeError: If the attribute is not found in any class in the MRO.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(tp, tuple):</span>
<span class="gi">+        classes = tp</span>
<span class="gi">+    else:</span>
<span class="gi">+        classes = mro(tp)</span>
<span class="gi">+    </span>
<span class="gi">+    for cls in classes:</span>
<span class="gi">+        if name in cls.__dict__:</span>
<span class="gi">+            return cls.__dict__[name]</span>
<span class="gi">+    </span>
<span class="gi">+    raise AttributeError(f&quot;&#39;{tp.__name__}&#39; object has no attribute &#39;{name}&#39;&quot;)</span>


<span class="w"> </span>def get_attribute_from_base_dicts(tp: type[Any], name: str) -&gt;Any:
<span class="gu">@@ -289,7 +325,12 @@ def get_attribute_from_base_dicts(tp: type[Any], name: str) -&gt;Any:</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        KeyError: If the attribute is not found in any class&#39;s `__dict__` in the MRO.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for cls in mro(tp):</span>
<span class="gi">+        try:</span>
<span class="gi">+            return cls.__dict__[name]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            continue</span>
<span class="gi">+    raise KeyError(f&quot;&#39;{name}&#39; not found in &#39;{tp.__name__}&#39; or its bases&quot;)</span>


<span class="w"> </span>@dataclass(**slots_true)
<span class="gu">@@ -328,7 +369,26 @@ class DecoratorInfos:</span>
<span class="w"> </span>        If we do replace any functions we put the replacement into the position
<span class="w"> </span>        the replaced function was in; that is, we maintain the order.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        decorator_infos = DecoratorInfos()</span>
<span class="gi">+        for base in reversed(mro(model_dc)):</span>
<span class="gi">+            for name, value in base.__dict__.items():</span>
<span class="gi">+                if isinstance(value, PydanticDescriptorProxy):</span>
<span class="gi">+                    decorator = Decorator.build(base, cls_var_name=name, shim=value.shim, info=value.decorator_info)</span>
<span class="gi">+                    if isinstance(value.decorator_info, ValidatorDecoratorInfo):</span>
<span class="gi">+                        decorator_infos.validators[name] = decorator</span>
<span class="gi">+                    elif isinstance(value.decorator_info, FieldValidatorDecoratorInfo):</span>
<span class="gi">+                        decorator_infos.field_validators[name] = decorator</span>
<span class="gi">+                    elif isinstance(value.decorator_info, RootValidatorDecoratorInfo):</span>
<span class="gi">+                        decorator_infos.root_validators[name] = decorator</span>
<span class="gi">+                    elif isinstance(value.decorator_info, FieldSerializerDecoratorInfo):</span>
<span class="gi">+                        decorator_infos.field_serializers[name] = decorator</span>
<span class="gi">+                    elif isinstance(value.decorator_info, ModelSerializerDecoratorInfo):</span>
<span class="gi">+                        decorator_infos.model_serializers[name] = decorator</span>
<span class="gi">+                    elif isinstance(value.decorator_info, ModelValidatorDecoratorInfo):</span>
<span class="gi">+                        decorator_infos.model_validators[name] = decorator</span>
<span class="gi">+                    elif isinstance(value.decorator_info, ComputedFieldInfo):</span>
<span class="gi">+                        decorator_infos.computed_fields[name] = decorator</span>
<span class="gi">+        return decorator_infos</span>


<span class="w"> </span>def inspect_validator(validator: Callable[..., Any], mode: FieldValidatorModes
<span class="gu">@@ -344,7 +404,25 @@ def inspect_validator(validator: Callable[..., Any], mode: FieldValidatorModes</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        Whether the validator takes an info argument.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sig = signature(validator)</span>
<span class="gi">+    params = list(sig.parameters.values())</span>
<span class="gi">+    </span>
<span class="gi">+    if mode == &#39;before&#39;:</span>
<span class="gi">+        if len(params) == 1:</span>
<span class="gi">+            return False</span>
<span class="gi">+        elif len(params) == 2 and params[1].name == &#39;info&#39;:</span>
<span class="gi">+            return True</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&quot;Invalid signature for &#39;before&#39; validator: {sig}&quot;)</span>
<span class="gi">+    elif mode == &#39;after&#39;:</span>
<span class="gi">+        if len(params) == 2:</span>
<span class="gi">+            return False</span>
<span class="gi">+        elif len(params) == 3 and params[2].name == &#39;info&#39;:</span>
<span class="gi">+            return True</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&quot;Invalid signature for &#39;after&#39; validator: {sig}&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Invalid validator mode: {mode}&quot;)</span>


<span class="w"> </span>def inspect_field_serializer(serializer: Callable[..., Any], mode: Literal[
<span class="gu">@@ -363,7 +441,25 @@ def inspect_field_serializer(serializer: Callable[..., Any], mode: Literal[</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        Tuple of (is_field_serializer, info_arg).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sig = signature(serializer)</span>
<span class="gi">+    params = list(sig.parameters.values())</span>
<span class="gi">+    </span>
<span class="gi">+    if mode == &#39;plain&#39;:</span>
<span class="gi">+        if len(params) == 1:</span>
<span class="gi">+            return True, False</span>
<span class="gi">+        elif len(params) == 2 and params[1].name == &#39;info&#39;:</span>
<span class="gi">+            return True, True</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&quot;Invalid signature for &#39;plain&#39; field serializer: {sig}&quot;)</span>
<span class="gi">+    elif mode == &#39;wrap&#39;:</span>
<span class="gi">+        if len(params) == 2:</span>
<span class="gi">+            return True, False</span>
<span class="gi">+        elif len(params) == 3 and params[2].name == &#39;info&#39;:</span>
<span class="gi">+            return True, True</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(f&quot;Invalid signature for &#39;wrap&#39; field serializer: {sig}&quot;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Invalid serializer mode: {mode}&quot;)</span>


<span class="w"> </span>def inspect_annotated_serializer(serializer: Callable[..., Any], mode:
<span class="gu">@@ -379,7 +475,15 @@ def inspect_annotated_serializer(serializer: Callable[..., Any], mode:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        info_arg
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sig = signature(serializer)</span>
<span class="gi">+    params = list(sig.parameters.values())</span>
<span class="gi">+    </span>
<span class="gi">+    if mode == &#39;plain&#39;:</span>
<span class="gi">+        return len(params) == 2 and params[1].name == &#39;info&#39;</span>
<span class="gi">+    elif mode == &#39;wrap&#39;:</span>
<span class="gi">+        return len(params) == 3 and params[2].name == &#39;info&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Invalid serializer mode: {mode}&quot;)</span>


<span class="w"> </span>def inspect_model_serializer(serializer: Callable[..., Any], mode: Literal[
<span class="gu">@@ -395,7 +499,15 @@ def inspect_model_serializer(serializer: Callable[..., Any], mode: Literal[</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        `info_arg` - whether the function expects an info argument.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sig = signature(serializer)</span>
<span class="gi">+    params = list(sig.parameters.values())</span>
<span class="gi">+    </span>
<span class="gi">+    if mode == &#39;plain&#39;:</span>
<span class="gi">+        return len(params) == 2 and params[1].name == &#39;info&#39;</span>
<span class="gi">+    elif mode == &#39;wrap&#39;:</span>
<span class="gi">+        return len(params) == 3 and params[2].name == &#39;info&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Invalid serializer mode: {mode}&quot;)</span>


<span class="w"> </span>AnyDecoratorCallable: TypeAlias = (
<span class="gu">@@ -415,7 +527,9 @@ def is_instance_method_from_sig(function: AnyDecoratorCallable) -&gt;bool:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        `True` if the function is an instance method, `False` otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sig = signature(function)</span>
<span class="gi">+    params = list(sig.parameters.values())</span>
<span class="gi">+    return len(params) &gt; 0 and params[0].name == &#39;self&#39;</span>


<span class="w"> </span>def ensure_classmethod_based_on_signature(function: AnyDecoratorCallable
<span class="gu">@@ -428,7 +542,12 @@ def ensure_classmethod_based_on_signature(function: AnyDecoratorCallable</span>
<span class="w"> </span>    Return:
<span class="w"> </span>        The `@classmethod` decorator applied function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(function, (classmethod, staticmethod)):</span>
<span class="gi">+        sig = signature(function)</span>
<span class="gi">+        params = list(sig.parameters.values())</span>
<span class="gi">+        if len(params) &gt; 0 and params[0].name == &#39;cls&#39;:</span>
<span class="gi">+            return classmethod(function)</span>
<span class="gi">+    return function</span>


<span class="w"> </span>def unwrap_wrapped_function(func: Any, *, unwrap_partial: bool=True,
<span class="gu">@@ -445,7 +564,16 @@ def unwrap_wrapped_function(func: Any, *, unwrap_partial: bool=True,</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The underlying function of the wrapped function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    while True:</span>
<span class="gi">+        if isinstance(func, property):</span>
<span class="gi">+            func = func.fget</span>
<span class="gi">+        elif unwrap_partial and isinstance(func, (partial, partialmethod)):</span>
<span class="gi">+            func = func.func</span>
<span class="gi">+        elif unwrap_class_static_method and isinstance(func, (classmethod, staticmethod)):</span>
<span class="gi">+            func = func.__func__</span>
<span class="gi">+        else:</span>
<span class="gi">+            break</span>
<span class="gi">+    return func</span>


<span class="w"> </span>def get_function_return_type(func: Any, explicit_return_type: Any,
<span class="gu">@@ -463,7 +591,11 @@ def get_function_return_type(func: Any, explicit_return_type: Any,</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The function return type.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if explicit_return_type is not None:</span>
<span class="gi">+        return explicit_return_type</span>
<span class="gi">+    </span>
<span class="gi">+    type_hints = get_function_type_hints(func, types_namespace)</span>
<span class="gi">+    return type_hints.get(&#39;return&#39;, Any)</span>


<span class="w"> </span>def count_positional_required_params(sig: Signature) -&gt;int:
<span class="gu">@@ -476,7 +608,16 @@ def count_positional_required_params(sig: Signature) -&gt;int:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The number of positional arguments of a signature.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    count = 0</span>
<span class="gi">+    for param in sig.parameters.values():</span>
<span class="gi">+        if param.kind in (Parameter.POSITIONAL_ONLY, Parameter.POSITIONAL_OR_KEYWORD):</span>
<span class="gi">+            if count == 0 or param.default is Parameter.empty:</span>
<span class="gi">+                count += 1</span>
<span class="gi">+            else:</span>
<span class="gi">+                break</span>
<span class="gi">+        else:</span>
<span class="gi">+            break</span>
<span class="gi">+    return count</span>


<span class="w"> </span>def ensure_property(f: Any) -&gt;Any:
<span class="gu">@@ -488,4 +629,6 @@ def ensure_property(f: Any) -&gt;Any:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The function, or a `property` or `cached_property` instance wrapping the function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(f, (property, cached_property)) or isdatadescriptor(f) or ismethoddescriptor(f):</span>
<span class="gi">+        return f</span>
<span class="gi">+    return property(f)</span>
<span class="gh">diff --git a/pydantic/_internal/_decorators_v1.py b/pydantic/_internal/_decorators_v1.py</span>
<span class="gh">index 4645ddd9..29cbcab2 100644</span>
<span class="gd">--- a/pydantic/_internal/_decorators_v1.py</span>
<span class="gi">+++ b/pydantic/_internal/_decorators_v1.py</span>
<span class="gu">@@ -62,7 +62,26 @@ def make_generic_v1_field_validator(validator: V1Validator</span>
<span class="w"> </span>        PydanticUserError: If the signature is not supported or the parameters are
<span class="w"> </span>            not available in Pydantic V2.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    sig = signature(validator)</span>
<span class="gi">+    params = list(sig.parameters.values())</span>
<span class="gi">+</span>
<span class="gi">+    def wrapper(value: Any, info: core_schema.ValidationInfo) -&gt; Any:</span>
<span class="gi">+        if len(params) == 1:</span>
<span class="gi">+            return validator(value)</span>
<span class="gi">+        elif len(params) == 2:</span>
<span class="gi">+            if params[1].name == &#39;values&#39;:</span>
<span class="gi">+                return validator(value, values=info.data)</span>
<span class="gi">+            elif params[1].kind == Parameter.VAR_KEYWORD:</span>
<span class="gi">+                return validator(value, **{&#39;values&#39;: info.data})</span>
<span class="gi">+        elif len(params) == 3 and params[1].name == &#39;values&#39; and params[2].kind == Parameter.VAR_KEYWORD:</span>
<span class="gi">+            return validator(value, values=info.data)</span>
<span class="gi">+        </span>
<span class="gi">+        raise PydanticUserError(</span>
<span class="gi">+            f&quot;Unsupported validator signature: {sig}&quot;,</span>
<span class="gi">+            code=&quot;unsupported-validator-signature&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>RootValidatorValues = Dict[str, Any]
<span class="gu">@@ -103,4 +122,13 @@ def make_v1_generic_root_validator(validator: V1RootValidatorFunction, pre:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        A wrapped V2 style validator.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if pre:</span>
<span class="gi">+        def before_validator(values: RootValidatorValues, info: core_schema.ValidationInfo) -&gt; RootValidatorValues:</span>
<span class="gi">+            return validator(values)</span>
<span class="gi">+        return before_validator</span>
<span class="gi">+    else:</span>
<span class="gi">+        def after_validator(fields_tuple: RootValidatorFieldsTuple, info: core_schema.ValidationInfo) -&gt; RootValidatorFieldsTuple:</span>
<span class="gi">+            values = dict(zip(info.field_names, fields_tuple))</span>
<span class="gi">+            validated_values = validator(values)</span>
<span class="gi">+            return tuple(validated_values[field] for field in info.field_names)</span>
<span class="gi">+        return after_validator</span>
<span class="gh">diff --git a/pydantic/_internal/_discriminated_union.py b/pydantic/_internal/_discriminated_union.py</span>
<span class="gh">index aa07168e..2a0a0489 100644</span>
<span class="gd">--- a/pydantic/_internal/_discriminated_union.py</span>
<span class="gi">+++ b/pydantic/_internal/_discriminated_union.py</span>
<span class="gu">@@ -46,7 +46,11 @@ def apply_discriminator(schema: core_schema.CoreSchema, discriminator: (str |</span>
<span class="w"> </span>            - If discriminator fields have different aliases.
<span class="w"> </span>            - If discriminator field not of type `Literal`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if definitions is None:</span>
<span class="gi">+        definitions = {}</span>
<span class="gi">+    </span>
<span class="gi">+    applier = _ApplyInferredDiscriminator(discriminator, definitions)</span>
<span class="gi">+    return applier.apply(schema)</span>


<span class="w"> </span>class _ApplyInferredDiscriminator:
<span class="gu">@@ -96,7 +100,19 @@ class _ApplyInferredDiscriminator:</span>
<span class="w"> </span>                - If discriminator fields have different aliases.
<span class="w"> </span>                - If discriminator field not of type `Literal`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._used:</span>
<span class="gi">+            raise RuntimeError(&#39;_ApplyInferredDiscriminator instances should not be reused&#39;)</span>
<span class="gi">+        self._used = True</span>
<span class="gi">+</span>
<span class="gi">+        new_schema = self._apply_to_root(schema)</span>
<span class="gi">+</span>
<span class="gi">+        if not self._tagged_union_choices:</span>
<span class="gi">+            raise TypeError(&#39;No valid choices found for discriminated union&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if self._is_nullable:</span>
<span class="gi">+            new_schema = core_schema.nullable_schema(new_schema)</span>
<span class="gi">+</span>
<span class="gi">+        return new_schema</span>

<span class="w"> </span>    def _apply_to_root(self, schema: core_schema.CoreSchema
<span class="w"> </span>        ) -&gt;core_schema.CoreSchema:
<span class="gu">@@ -104,7 +120,28 @@ class _ApplyInferredDiscriminator:</span>
<span class="w"> </span>        unwrapping nullable or definitions schemas, and calling the `_handle_choice`
<span class="w"> </span>        method iteratively on the choices extracted (recursively) from the possibly-wrapped union.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(schema, core_schema.NullableSchema):</span>
<span class="gi">+            self._should_be_nullable = True</span>
<span class="gi">+            return self._apply_to_root(schema[&#39;schema&#39;])</span>
<span class="gi">+        </span>
<span class="gi">+        if isinstance(schema, core_schema.DefinitionsSchema):</span>
<span class="gi">+            self.definitions.update(schema[&#39;definitions&#39;])</span>
<span class="gi">+            return self._apply_to_root(schema[&#39;schema&#39;])</span>
<span class="gi">+        </span>
<span class="gi">+        if isinstance(schema, core_schema.UnionSchema):</span>
<span class="gi">+            for choice in schema[&#39;choices&#39;]:</span>
<span class="gi">+                self._handle_choice(choice)</span>
<span class="gi">+        elif isinstance(schema, core_schema.TaggedUnionSchema):</span>
<span class="gi">+            for choice in schema[&#39;choices&#39;].values():</span>
<span class="gi">+                self._handle_choice(choice)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(f&#39;Invalid schema type for discriminated union: {type(schema)}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        return core_schema.tagged_union_schema(</span>
<span class="gi">+            choices=self._tagged_union_choices,</span>
<span class="gi">+            discriminator=self.discriminator,</span>
<span class="gi">+            discriminator_alias=self._discriminator_alias,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def _handle_choice(self, choice: core_schema.CoreSchema) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;This method handles the &quot;middle&quot; stage of recursion over the input schema.
<span class="gu">@@ -117,7 +154,20 @@ class _ApplyInferredDiscriminator:</span>
<span class="w"> </span>        * Validating that each allowed discriminator value maps to a unique choice
<span class="w"> </span>        * Updating the _tagged_union_choices mapping that will ultimately be used to build the TaggedUnionSchema.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(choice, core_schema.UnionSchema):</span>
<span class="gi">+            for sub_choice in choice[&#39;choices&#39;]:</span>
<span class="gi">+                self._handle_choice(sub_choice)</span>
<span class="gi">+        elif isinstance(choice, core_schema.TaggedUnionSchema):</span>
<span class="gi">+            if self._is_discriminator_shared(choice):</span>
<span class="gi">+                for sub_choice in choice[&#39;choices&#39;].values():</span>
<span class="gi">+                    self._handle_choice(sub_choice)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._set_unique_choice_for_values(choice, [choice[&#39;discriminator&#39;]])</span>
<span class="gi">+        elif isinstance(choice, core_schema.NoneSchema):</span>
<span class="gi">+            self._is_nullable = True</span>
<span class="gi">+        else:</span>
<span class="gi">+            values = self._infer_discriminator_values_for_choice(choice, None)</span>
<span class="gi">+            self._set_unique_choice_for_values(choice, values)</span>

<span class="w"> </span>    def _is_discriminator_shared(self, choice: core_schema.TaggedUnionSchema
<span class="w"> </span>        ) -&gt;bool:
<span class="gu">@@ -126,7 +176,7 @@ class _ApplyInferredDiscriminator:</span>
<span class="w"> </span>        determine whether this TaggedUnionSchema choice should be &quot;coalesced&quot; into the top level,
<span class="w"> </span>        or whether it should be treated as a separate (nested) choice.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return choice[&#39;discriminator&#39;] == self.discriminator</span>

<span class="w"> </span>    def _infer_discriminator_values_for_choice(self, choice: core_schema.
<span class="w"> </span>        CoreSchema, source_name: (str | None)) -&gt;list[str | int]:
<span class="gu">@@ -134,7 +184,14 @@ class _ApplyInferredDiscriminator:</span>

<span class="w"> </span>        `model_name` is accepted for the purpose of producing useful error messages.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(choice, core_schema.TypedDictSchema):</span>
<span class="gi">+            return self._infer_discriminator_values_for_typed_dict_choice(choice, source_name)</span>
<span class="gi">+        elif isinstance(choice, core_schema.ModelSchema):</span>
<span class="gi">+            return self._infer_discriminator_values_for_typed_dict_choice(choice[&#39;schema&#39;], source_name)</span>
<span class="gi">+        elif isinstance(choice, core_schema.DataclassSchema):</span>
<span class="gi">+            return self._infer_discriminator_values_for_typed_dict_choice(choice[&#39;schema&#39;], source_name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise TypeError(f&#39;Invalid choice type for discriminated union: {type(choice)}&#39;)</span>

<span class="w"> </span>    def _infer_discriminator_values_for_typed_dict_choice(self, choice:
<span class="w"> </span>        core_schema.TypedDictSchema, source_name: (str | None)=None) -&gt;list[
<span class="gu">@@ -142,18 +199,43 @@ class _ApplyInferredDiscriminator:</span>
<span class="w"> </span>        &quot;&quot;&quot;This method just extracts the _infer_discriminator_values_for_choice logic specific to TypedDictSchema
<span class="w"> </span>        for the sake of readability.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        discriminator_field = choice[&#39;fields&#39;].get(self.discriminator)</span>
<span class="gi">+        if discriminator_field is None:</span>
<span class="gi">+            raise PydanticUserError(f&quot;Model {source_name} in union doesn&#39;t have a discriminator field {self.discriminator!r}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if discriminator_field.get(&#39;alias&#39;) is not None:</span>
<span class="gi">+            if self._discriminator_alias is None:</span>
<span class="gi">+                self._discriminator_alias = discriminator_field[&#39;alias&#39;]</span>
<span class="gi">+            elif self._discriminator_alias != discriminator_field[&#39;alias&#39;]:</span>
<span class="gi">+                raise PydanticUserError(&#39;Discriminator fields have different aliases&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        return self._infer_discriminator_values_for_inner_schema(discriminator_field[&#39;schema&#39;], f&#39;{source_name}.{self.discriminator}&#39;)</span>

<span class="w"> </span>    def _infer_discriminator_values_for_inner_schema(self, schema:
<span class="w"> </span>        core_schema.CoreSchema, source: str) -&gt;list[str | int]:
<span class="w"> </span>        &quot;&quot;&quot;When inferring discriminator values for a field, we typically extract the expected values from a literal
<span class="w"> </span>        schema. This function does that, but also handles nested unions and defaults.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(schema, core_schema.LiteralSchema):</span>
<span class="gi">+            return [schema[&#39;expected&#39;]]</span>
<span class="gi">+        elif isinstance(schema, core_schema.UnionSchema):</span>
<span class="gi">+            values = []</span>
<span class="gi">+            for choice in schema[&#39;choices&#39;]:</span>
<span class="gi">+                values.extend(self._infer_discriminator_values_for_inner_schema(choice, source))</span>
<span class="gi">+            return values</span>
<span class="gi">+        elif isinstance(schema, core_schema.DefaultSchema):</span>
<span class="gi">+            return self._infer_discriminator_values_for_inner_schema(schema[&#39;schema&#39;], source)</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise PydanticUserError(f&#39;Discriminator field {source!r} must be a Literal&#39;)</span>

<span class="w"> </span>    def _set_unique_choice_for_values(self, choice: core_schema.CoreSchema,
<span class="w"> </span>        values: Sequence[str | int]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;This method updates `self.tagged_union_choices` so that all provided (discriminator) `values` map to the
<span class="w"> </span>        provided `choice`, validating that none of these values already map to another (different) choice.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for value in values:</span>
<span class="gi">+            if value in self._tagged_union_choices:</span>
<span class="gi">+                if self._tagged_union_choices[value] != choice:</span>
<span class="gi">+                    raise TypeError(f&#39;Discriminator value {value!r} mapped to multiple choices&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._tagged_union_choices[value] = choice</span>
<span class="gh">diff --git a/pydantic/_internal/_docs_extraction.py b/pydantic/_internal/_docs_extraction.py</span>
<span class="gh">index 88a14e9f..e444fa51 100644</span>
<span class="gd">--- a/pydantic/_internal/_docs_extraction.py</span>
<span class="gi">+++ b/pydantic/_internal/_docs_extraction.py</span>
<span class="gu">@@ -27,4 +27,13 @@ def extract_docstrings_from_cls(cls: type[Any], use_inspect: bool=False</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        A mapping containing attribute names and their corresponding docstring.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if use_inspect:</span>
<span class="gi">+        source = inspect.getsource(cls)</span>
<span class="gi">+    else:</span>
<span class="gi">+        source = textwrap.dedent(inspect.getmodule(cls).__dict__[cls.__name__].__doc__ or &#39;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    tree = ast.parse(source)</span>
<span class="gi">+    visitor = DocstringVisitor()</span>
<span class="gi">+    visitor.visit(tree)</span>
<span class="gi">+</span>
<span class="gi">+    return visitor.attrs</span>
<span class="gh">diff --git a/pydantic/_internal/_fields.py b/pydantic/_internal/_fields.py</span>
<span class="gh">index 7e8b6c92..e6d13947 100644</span>
<span class="gd">--- a/pydantic/_internal/_fields.py</span>
<span class="gi">+++ b/pydantic/_internal/_fields.py</span>
<span class="gu">@@ -36,7 +36,13 @@ def get_type_hints_infer_globalns(obj: Any, localns: (dict[str, Any] | None</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The object type hints.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    globalns = None</span>
<span class="gi">+    if hasattr(obj, &#39;__module__&#39;):</span>
<span class="gi">+        try:</span>
<span class="gi">+            globalns = sys.modules[obj.__module__].__dict__</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            pass</span>
<span class="gi">+    return get_type_hints(obj, globalns, localns, include_extras)</span>


<span class="w"> </span>class PydanticMetadata(Representation):
<span class="gu">@@ -53,13 +59,21 @@ def pydantic_general_metadata(**metadata: Any) -&gt;BaseMetadata:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The new `_PydanticGeneralMetadata` class.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    class _PydanticGeneralMetadata(_general_metadata_cls()):</span>
<span class="gi">+        __slots__ = tuple(metadata.keys())</span>
<span class="gi">+</span>
<span class="gi">+        def __init__(self, **kwargs):</span>
<span class="gi">+            for key, value in metadata.items():</span>
<span class="gi">+                setattr(self, key, value)</span>
<span class="gi">+</span>
<span class="gi">+    return _PydanticGeneralMetadata(**metadata)</span>


<span class="w"> </span>@lru_cache(maxsize=None)
<span class="w"> </span>def _general_metadata_cls() -&gt;type[BaseMetadata]:
<span class="w"> </span>    &quot;&quot;&quot;Do it this way to avoid importing `annotated_types` at import time.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from annotated_types import BaseMetadata</span>
<span class="gi">+    return BaseMetadata</span>


<span class="w"> </span>def collect_model_fields(cls: type[BaseModel], bases: tuple[type[Any], ...],
<span class="gu">@@ -88,7 +102,39 @@ def collect_model_fields(cls: type[BaseModel], bases: tuple[type[Any], ...],</span>
<span class="w"> </span>            - If there is a field other than `root` in `RootModel`.
<span class="w"> </span>            - If a field shadows an attribute in the parent model.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    fields: dict[str, FieldInfo] = {}</span>
<span class="gi">+    class_vars: set[str] = set()</span>
<span class="gi">+</span>
<span class="gi">+    # Collect fields from parent classes</span>
<span class="gi">+    for base in reversed(bases):</span>
<span class="gi">+        if hasattr(base, &#39;model_fields&#39;):</span>
<span class="gi">+            fields.update(base.model_fields)</span>
<span class="gi">+</span>
<span class="gi">+    # Get type hints for the current class</span>
<span class="gi">+    type_hints = get_type_hints_infer_globalns(cls, types_namespace, include_extras=True)</span>
<span class="gi">+</span>
<span class="gi">+    for name, hint in type_hints.items():</span>
<span class="gi">+        if is_classvar(hint):</span>
<span class="gi">+            class_vars.add(name)</span>
<span class="gi">+        elif not is_finalvar(hint):</span>
<span class="gi">+            field = getattr(cls, name, PydanticUndefined)</span>
<span class="gi">+            if isinstance(field, FieldInfo):</span>
<span class="gi">+                fields[name] = field</span>
<span class="gi">+            else:</span>
<span class="gi">+                fields[name] = FieldInfo(default=field)</span>
<span class="gi">+</span>
<span class="gi">+    # Check for naming conflicts</span>
<span class="gi">+    protected_namespaces = {&#39;model_&#39;, &#39;model_fields&#39;, &#39;model_config&#39;}</span>
<span class="gi">+    for field_name in fields:</span>
<span class="gi">+        if field_name in protected_namespaces:</span>
<span class="gi">+            raise NameError(f&quot;Field {field_name} conflicts with protected namespace&quot;)</span>
<span class="gi">+        if cls.__name__ == &#39;RootModel&#39; and field_name != &#39;root&#39;:</span>
<span class="gi">+            raise NameError(f&quot;RootModel can only have a &#39;root&#39; field, not {field_name}&quot;)</span>
<span class="gi">+        for base in bases:</span>
<span class="gi">+            if hasattr(base, field_name) and not isinstance(getattr(base, field_name), FieldInfo):</span>
<span class="gi">+                raise NameError(f&quot;Field {field_name} shadows an attribute in parent {base.__name__}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return fields, class_vars</span>


<span class="w"> </span>def collect_dataclass_fields(cls: type[StandardDataclass], types_namespace:
<span class="gu">@@ -105,4 +151,24 @@ def collect_dataclass_fields(cls: type[StandardDataclass], types_namespace:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The dataclass fields.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    fields: dict[str, FieldInfo] = {}</span>
<span class="gi">+    type_hints = get_type_hints_infer_globalns(cls, types_namespace, include_extras=True)</span>
<span class="gi">+</span>
<span class="gi">+    for name, hint in type_hints.items():</span>
<span class="gi">+        if not is_classvar(hint) and not is_finalvar(hint):</span>
<span class="gi">+            field = cls.__dataclass_fields__[name]</span>
<span class="gi">+            default = field.default if field.default is not dataclasses.MISSING else PydanticUndefined</span>
<span class="gi">+            default_factory = field.default_factory if field.default_factory is not dataclasses.MISSING else None</span>
<span class="gi">+            </span>
<span class="gi">+            field_info = FieldInfo(</span>
<span class="gi">+                annotation=hint,</span>
<span class="gi">+                default=default,</span>
<span class="gi">+                default_factory=default_factory,</span>
<span class="gi">+                init=field.init,</span>
<span class="gi">+                repr=field.repr,</span>
<span class="gi">+                kw_only=field.kw_only,</span>
<span class="gi">+            )</span>
<span class="gi">+            </span>
<span class="gi">+            fields[name] = field_info</span>
<span class="gi">+</span>
<span class="gi">+    return fields</span>
<span class="gh">diff --git a/pydantic/_internal/_generate_schema.py b/pydantic/_internal/_generate_schema.py</span>
<span class="gh">index c7465578..6d5048ee 100644</span>
<span class="gd">--- a/pydantic/_internal/_generate_schema.py</span>
<span class="gi">+++ b/pydantic/_internal/_generate_schema.py</span>
<span class="gu">@@ -77,7 +77,9 @@ def check_validator_fields_against_field_name(info: FieldDecoratorInfo,</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        `True` if field name is in validator fields, `False` otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(info, (ValidatorDecoratorInfo, FieldValidatorDecoratorInfo)):</span>
<span class="gi">+        return field in info.fields or &#39;*&#39; in info.fields</span>
<span class="gi">+    return True  # For other types of decorators, assume it applies to all fields</span>


<span class="w"> </span>def check_decorator_fields_exist(decorators: Iterable[AnyFieldDecorator],
<span class="gu">@@ -93,7 +95,17 @@ def check_decorator_fields_exist(decorators: Iterable[AnyFieldDecorator],</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        PydanticUserError: If one of the field names does not exist in `fields` param.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    fields_set = set(fields)</span>
<span class="gi">+    for decorator in decorators:</span>
<span class="gi">+        info = decorator.info</span>
<span class="gi">+        if isinstance(info, (ValidatorDecoratorInfo, FieldValidatorDecoratorInfo)):</span>
<span class="gi">+            if info.check_fields and &#39;*&#39; not in info.fields:</span>
<span class="gi">+                for field in info.fields:</span>
<span class="gi">+                    if field not in fields_set:</span>
<span class="gi">+                        raise PydanticUserError(</span>
<span class="gi">+                            f&quot;Decorator field &#39;{field}&#39; does not exist in {fields_set}&quot;,</span>
<span class="gi">+                            code=&#39;decorator-missing-field&#39;</span>
<span class="gi">+                        )</span>


<span class="w"> </span>def modify_model_json_schema(schema_or_field: CoreSchemaOrField, handler:
<span class="gu">@@ -110,7 +122,17 @@ def modify_model_json_schema(schema_or_field: CoreSchemaOrField, handler:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        JsonSchemaValue: The updated JSON schema.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    json_schema = handler(schema_or_field)</span>
<span class="gi">+    </span>
<span class="gi">+    if title is None:</span>
<span class="gi">+        title = cls.__name__</span>
<span class="gi">+    </span>
<span class="gi">+    json_schema[&#39;title&#39;] = title</span>
<span class="gi">+    </span>
<span class="gi">+    if cls.__doc__:</span>
<span class="gi">+        json_schema[&#39;description&#39;] = inspect.cleandoc(cls.__doc__)</span>
<span class="gi">+    </span>
<span class="gi">+    return json_schema</span>


<span class="w"> </span>JsonEncoders = Dict[Type[Any], JsonEncoder]
<span class="gu">@@ -125,7 +147,17 @@ def _add_custom_serialization_from_json_encoders(json_encoders: (</span>
<span class="w"> </span>        tp: The type to check for a matching encoder.
<span class="w"> </span>        schema: The schema to add the encoder to.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if json_encoders is None:</span>
<span class="gi">+        return schema</span>
<span class="gi">+</span>
<span class="gi">+    for encoder_type, encoder in json_encoders.items():</span>
<span class="gi">+        if isinstance(tp, encoder_type):</span>
<span class="gi">+            return core_schema.json_or_python_schema(</span>
<span class="gi">+                json_schema=core_schema.with_info_plain_validator_function(encoder),</span>
<span class="gi">+                python_schema=schema,</span>
<span class="gi">+            )</span>
<span class="gi">+    </span>
<span class="gi">+    return schema</span>


<span class="w"> </span>TypesNamespace = Union[Dict[str, Any], None]
<span class="gu">@@ -144,7 +176,7 @@ def _get_first_non_null(a: Any, b: Any) -&gt;Any:</span>
<span class="w"> </span>    Use case: serialization_alias (argument a) and alias (argument b) are both defined, and serialization_alias is &#39;&#39;.
<span class="w"> </span>    This function will return serialization_alias, which is the first argument, even though it is an empty string.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return a if a is not None else b</span>


<span class="w"> </span>class GenerateSchema:
<span class="gh">diff --git a/pydantic/_internal/_generics.py b/pydantic/_internal/_generics.py</span>
<span class="gh">index 6087db94..79339289 100644</span>
<span class="gd">--- a/pydantic/_internal/_generics.py</span>
<span class="gi">+++ b/pydantic/_internal/_generics.py</span>
<span class="gu">@@ -106,7 +106,16 @@ def create_generic_submodel(model_name: str, origin: type[BaseModel], args:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The created submodel.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    namespace = {</span>
<span class="gi">+        &#39;__module__&#39;: origin.__module__,</span>
<span class="gi">+        &#39;__qualname__&#39;: f&#39;{origin.__qualname__}[{&quot;, &quot;.join(str(arg) for arg in args)}]&#39;,</span>
<span class="gi">+        &#39;__pydantic_generic_metadata__&#39;: PydanticGenericMetadata(</span>
<span class="gi">+            origin=origin,</span>
<span class="gi">+            args=args,</span>
<span class="gi">+            parameters=params</span>
<span class="gi">+        ),</span>
<span class="gi">+    }</span>
<span class="gi">+    return types.new_class(model_name, (origin,), {}, lambda ns: ns.update(namespace))</span>


<span class="w"> </span>def _get_caller_frame_info(depth: int=2) -&gt;tuple[str | None, bool]:
<span class="gu">@@ -121,7 +130,15 @@ def _get_caller_frame_info(depth: int=2) -&gt;tuple[str | None, bool]:</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        RuntimeError: If the function is not called inside a function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        frame = sys._getframe(depth)</span>
<span class="gi">+    except ValueError as e:</span>
<span class="gi">+        raise RuntimeError(&#39;This function must be called inside another function&#39;) from e</span>
<span class="gi">+</span>
<span class="gi">+    module_name = frame.f_globals.get(&#39;__name__&#39;)</span>
<span class="gi">+    called_globally = frame.f_locals is frame.f_globals</span>
<span class="gi">+</span>
<span class="gi">+    return module_name, called_globally</span>


<span class="w"> </span>DictValues: type[Any] = {}.values().__class__
<span class="gu">@@ -133,7 +150,16 @@ def iter_contained_typevars(v: Any) -&gt;Iterator[TypeVarType]:</span>
<span class="w"> </span>    This is inspired as an alternative to directly accessing the `__parameters__` attribute of a GenericAlias,
<span class="w"> </span>    since __parameters__ of (nested) generic BaseModel subclasses won&#39;t show up in that list.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(v, TypeVar):</span>
<span class="gi">+        yield v</span>
<span class="gi">+    elif is_model_class(v) and hasattr(v, &#39;__pydantic_generic_metadata__&#39;):</span>
<span class="gi">+        yield from iter_contained_typevars(v.__pydantic_generic_metadata__[&#39;args&#39;])</span>
<span class="gi">+    elif isinstance(v, (typing_base, types.GenericAlias)):</span>
<span class="gi">+        for arg in getattr(v, &#39;__args__&#39;, ()):</span>
<span class="gi">+            yield from iter_contained_typevars(arg)</span>
<span class="gi">+    elif isinstance(v, (list, tuple, set)):</span>
<span class="gi">+        for item in v:</span>
<span class="gi">+            yield from iter_contained_typevars(item)</span>


<span class="w"> </span>def get_standard_typevars_map(cls: type[Any]) -&gt;(dict[TypeVarType, Any] | None
<span class="gu">@@ -141,7 +167,16 @@ def get_standard_typevars_map(cls: type[Any]) -&gt;(dict[TypeVarType, Any] | None</span>
<span class="w"> </span>    &quot;&quot;&quot;Package a generic type&#39;s typevars and parametrization (if present) into a dictionary compatible with the
<span class="w"> </span>    `replace_types` function. Specifically, this works with standard typing generics and typing._GenericAlias.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not hasattr(cls, &#39;__parameters__&#39;) or not hasattr(cls, &#39;__args__&#39;):</span>
<span class="gi">+        return None</span>
<span class="gi">+    </span>
<span class="gi">+    parameters = getattr(cls, &#39;__parameters__&#39;, ())</span>
<span class="gi">+    args = getattr(cls, &#39;__args__&#39;, ())</span>
<span class="gi">+    </span>
<span class="gi">+    if len(parameters) != len(args):</span>
<span class="gi">+        return None</span>
<span class="gi">+    </span>
<span class="gi">+    return dict(zip(parameters, args))</span>


<span class="w"> </span>def get_model_typevars_map(cls: type[BaseModel]) -&gt;(dict[TypeVarType, Any] |
<span class="gu">@@ -152,7 +187,17 @@ def get_model_typevars_map(cls: type[BaseModel]) -&gt;(dict[TypeVarType, Any] |</span>
<span class="w"> </span>    Since BaseModel.__class_getitem__ does not produce a typing._GenericAlias, and the BaseModel generic info is
<span class="w"> </span>    stored in the __pydantic_generic_metadata__ attribute, we need special handling here.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not hasattr(cls, &#39;__pydantic_generic_metadata__&#39;):</span>
<span class="gi">+        return None</span>
<span class="gi">+    </span>
<span class="gi">+    metadata = cls.__pydantic_generic_metadata__</span>
<span class="gi">+    parameters = metadata.get(&#39;parameters&#39;, ())</span>
<span class="gi">+    args = metadata.get(&#39;args&#39;, ())</span>
<span class="gi">+    </span>
<span class="gi">+    if len(parameters) != len(args):</span>
<span class="gi">+        return None</span>
<span class="gi">+    </span>
<span class="gi">+    return dict(zip(parameters, args))</span>


<span class="w"> </span>def replace_types(type_: Any, type_map: (Mapping[Any, Any] | None)) -&gt;Any:
<span class="gu">@@ -176,14 +221,46 @@ def replace_types(type_: Any, type_map: (Mapping[Any, Any] | None)) -&gt;Any:</span>
<span class="w"> </span>        #&gt; Tuple[int, Union[List[int], float]]
<span class="w"> </span>        ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if type_map is None:</span>
<span class="gi">+        return type_</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(type_, TypeVar):</span>
<span class="gi">+        return type_map.get(type_, type_)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(type_, (typing_base, types.GenericAlias)):</span>
<span class="gi">+        args = getattr(type_, &#39;__args__&#39;, ())</span>
<span class="gi">+        if not args:</span>
<span class="gi">+            return type_</span>
<span class="gi">+        new_args = tuple(replace_types(arg, type_map) for arg in args)</span>
<span class="gi">+        if all_identical(args, new_args):</span>
<span class="gi">+            return type_</span>
<span class="gi">+        return type_[new_args]</span>
<span class="gi">+</span>
<span class="gi">+    if is_model_class(type_) and hasattr(type_, &#39;__pydantic_generic_metadata__&#39;):</span>
<span class="gi">+        metadata = type_.__pydantic_generic_metadata__</span>
<span class="gi">+        new_args = tuple(replace_types(arg, type_map) for arg in metadata[&#39;args&#39;])</span>
<span class="gi">+        if all_identical(metadata[&#39;args&#39;], new_args):</span>
<span class="gi">+            return type_</span>
<span class="gi">+        return create_generic_submodel(type_.__name__, type_, new_args, metadata[&#39;parameters&#39;])</span>
<span class="gi">+</span>
<span class="gi">+    return type_</span>


<span class="w"> </span>def has_instance_in_type(type_: Any, isinstance_target: Any) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Checks if the type, or any of its arbitrary nested args, satisfy
<span class="w"> </span>    `isinstance(&lt;type&gt;, isinstance_target)`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(type_, isinstance_target):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    if hasattr(type_, &#39;__args__&#39;):</span>
<span class="gi">+        return any(has_instance_in_type(arg, isinstance_target) for arg in type_.__args__)</span>
<span class="gi">+</span>
<span class="gi">+    if is_model_class(type_) and hasattr(type_, &#39;__pydantic_generic_metadata__&#39;):</span>
<span class="gi">+        metadata = type_.__pydantic_generic_metadata__</span>
<span class="gi">+        return any(has_instance_in_type(arg, isinstance_target) for arg in metadata[&#39;args&#39;])</span>
<span class="gi">+</span>
<span class="gi">+    return False</span>


<span class="w"> </span>def check_parameters_count(cls: type[BaseModel], parameters: tuple[Any, ...]
<span class="gu">@@ -197,7 +274,12 @@ def check_parameters_count(cls: type[BaseModel], parameters: tuple[Any, ...]</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        TypeError: If the passed parameters count is not equal to generic model parameters count.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not hasattr(cls, &#39;__pydantic_generic_metadata__&#39;):</span>
<span class="gi">+        raise TypeError(f&#39;{cls.__name__} is not a generic model&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    expected_params = cls.__pydantic_generic_metadata__[&#39;parameters&#39;]</span>
<span class="gi">+    if len(parameters) != len(expected_params):</span>
<span class="gi">+        raise TypeError(f&#39;Expected {len(expected_params)} type arguments, got {len(parameters)}&#39;)</span>


<span class="w"> </span>_generic_recursion_cache: ContextVar[set[str] | None] = ContextVar(
<span class="gu">@@ -214,7 +296,25 @@ def generic_recursion_self_type(origin: type[BaseModel], args: tuple[Any, ...]</span>
<span class="w"> </span>    can be used while building the core schema, and will produce a schema_ref that will be valid in the
<span class="w"> </span>    final parent schema.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    cache = _generic_recursion_cache.get()</span>
<span class="gi">+    if cache is None:</span>
<span class="gi">+        cache = set()</span>
<span class="gi">+        token = _generic_recursion_cache.set(cache)</span>
<span class="gi">+    else:</span>
<span class="gi">+        token = None</span>
<span class="gi">+</span>
<span class="gi">+    key = (origin, args)</span>
<span class="gi">+    if key in cache:</span>
<span class="gi">+        yield PydanticRecursiveRef(origin.__name__)</span>
<span class="gi">+    else:</span>
<span class="gi">+        cache.add(key)</span>
<span class="gi">+        try:</span>
<span class="gi">+            yield None</span>
<span class="gi">+        finally:</span>
<span class="gi">+            cache.remove(key)</span>
<span class="gi">+</span>
<span class="gi">+    if token is not None:</span>
<span class="gi">+        _generic_recursion_cache.reset(token)</span>


<span class="w"> </span>def get_cached_generic_type_early(parent: type[BaseModel], typevar_values: Any
<span class="gh">diff --git a/pydantic/_internal/_git.py b/pydantic/_internal/_git.py</span>
<span class="gh">index c2419c23..c1c58256 100644</span>
<span class="gd">--- a/pydantic/_internal/_git.py</span>
<span class="gi">+++ b/pydantic/_internal/_git.py</span>
<span class="gu">@@ -6,14 +6,44 @@ import subprocess</span>

<span class="w"> </span>def is_git_repo(dir: str) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Is the given directory version-controlled with git?&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        subprocess.run(</span>
<span class="gi">+            [&#39;git&#39;, &#39;rev-parse&#39;, &#39;--is-inside-work-tree&#39;],</span>
<span class="gi">+            cwd=dir,</span>
<span class="gi">+            stdout=subprocess.DEVNULL,</span>
<span class="gi">+            stderr=subprocess.DEVNULL,</span>
<span class="gi">+            check=True</span>
<span class="gi">+        )</span>
<span class="gi">+        return True</span>
<span class="gi">+    except subprocess.CalledProcessError:</span>
<span class="gi">+        return False</span>


<span class="w"> </span>def have_git() -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Can we run the git executable?&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        subprocess.run(</span>
<span class="gi">+            [&#39;git&#39;, &#39;--version&#39;],</span>
<span class="gi">+            stdout=subprocess.DEVNULL,</span>
<span class="gi">+            stderr=subprocess.DEVNULL,</span>
<span class="gi">+            check=True</span>
<span class="gi">+        )</span>
<span class="gi">+        return True</span>
<span class="gi">+    except (subprocess.CalledProcessError, FileNotFoundError):</span>
<span class="gi">+        return False</span>


<span class="w"> </span>def git_revision(dir: str) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Get the SHA-1 of the HEAD of a git repository.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        result = subprocess.run(</span>
<span class="gi">+            [&#39;git&#39;, &#39;rev-parse&#39;, &#39;HEAD&#39;],</span>
<span class="gi">+            cwd=dir,</span>
<span class="gi">+            stdout=subprocess.PIPE,</span>
<span class="gi">+            stderr=subprocess.DEVNULL,</span>
<span class="gi">+            check=True,</span>
<span class="gi">+            text=True</span>
<span class="gi">+        )</span>
<span class="gi">+        return result.stdout.strip()</span>
<span class="gi">+    except subprocess.CalledProcessError:</span>
<span class="gi">+        return &#39;unknown&#39;</span>
<span class="gh">diff --git a/pydantic/_internal/_known_annotated_metadata.py b/pydantic/_internal/_known_annotated_metadata.py</span>
<span class="gh">index 4df2ee94..bbcab0c5 100644</span>
<span class="gd">--- a/pydantic/_internal/_known_annotated_metadata.py</span>
<span class="gi">+++ b/pydantic/_internal/_known_annotated_metadata.py</span>
<span class="gu">@@ -78,7 +78,16 @@ def expand_grouped_metadata(annotations: Iterable[Any]) -&gt;Iterable[Any]:</span>
<span class="w"> </span>        #&gt; [Ge(ge=4), MinLen(min_length=5)]
<span class="w"> </span>        ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from annotated_types import GroupedMetadata, Len, MinLen, MaxLen</span>
<span class="gi">+</span>
<span class="gi">+    for annotation in annotations:</span>
<span class="gi">+        if isinstance(annotation, GroupedMetadata):</span>
<span class="gi">+            yield from annotation.metadata</span>
<span class="gi">+        elif isinstance(annotation, Len):</span>
<span class="gi">+            yield MinLen(annotation.min_length)</span>
<span class="gi">+            yield MaxLen(annotation.max_length)</span>
<span class="gi">+        else:</span>
<span class="gi">+            yield annotation</span>


<span class="w"> </span>@lru_cache
<span class="gu">@@ -90,7 +99,26 @@ def _get_at_to_constraint_map() -&gt;dict[type, str]:</span>
<span class="w"> </span>    the import time of `pydantic`. We still only want to have this dictionary defined in one place,
<span class="w"> </span>    so we use this function to cache the result.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from annotated_types import (</span>
<span class="gi">+        Gt, Ge, Lt, Le, MultipleOf, MinLen, MaxLen, Len,</span>
<span class="gi">+        Predicate, Timezone, Interval, AfterDateTime, BeforeDateTime</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        Gt: &#39;gt&#39;,</span>
<span class="gi">+        Ge: &#39;ge&#39;,</span>
<span class="gi">+        Lt: &#39;lt&#39;,</span>
<span class="gi">+        Le: &#39;le&#39;,</span>
<span class="gi">+        MultipleOf: &#39;multiple_of&#39;,</span>
<span class="gi">+        MinLen: &#39;min_length&#39;,</span>
<span class="gi">+        MaxLen: &#39;max_length&#39;,</span>
<span class="gi">+        Len: &#39;length&#39;,</span>
<span class="gi">+        Predicate: &#39;predicate&#39;,</span>
<span class="gi">+        Timezone: &#39;timezone&#39;,</span>
<span class="gi">+        Interval: &#39;interval&#39;,</span>
<span class="gi">+        AfterDateTime: &#39;after_datetime&#39;,</span>
<span class="gi">+        BeforeDateTime: &#39;before_datetime&#39;,</span>
<span class="gi">+    }</span>


<span class="w"> </span>def apply_known_metadata(annotation: Any, schema: CoreSchema) -&gt;(CoreSchema |
<span class="gu">@@ -113,7 +141,31 @@ def apply_known_metadata(annotation: Any, schema: CoreSchema) -&gt;(CoreSchema |</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        PydanticCustomError: If `Predicate` fails.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from annotated_types import Predicate</span>
<span class="gi">+</span>
<span class="gi">+    at_to_constraint = _get_at_to_constraint_map()</span>
<span class="gi">+    annotation_type = type(annotation)</span>
<span class="gi">+</span>
<span class="gi">+    if annotation_type not in at_to_constraint:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    constraint = at_to_constraint[annotation_type]</span>
<span class="gi">+    new_schema = copy(schema)</span>
<span class="gi">+</span>
<span class="gi">+    if constraint == &#39;predicate&#39;:</span>
<span class="gi">+        if not callable(annotation.func):</span>
<span class="gi">+            raise PydanticCustomError(</span>
<span class="gi">+                &#39;invalid_predicate&#39;,</span>
<span class="gi">+                &#39;Invalid predicate function&#39;</span>
<span class="gi">+            )</span>
<span class="gi">+        new_schema[&#39;predicate&#39;] = annotation.func</span>
<span class="gi">+    elif constraint in CONSTRAINTS_TO_ALLOWED_SCHEMAS:</span>
<span class="gi">+        allowed_schemas = CONSTRAINTS_TO_ALLOWED_SCHEMAS[constraint]</span>
<span class="gi">+        if schema[&#39;type&#39;] not in allowed_schemas:</span>
<span class="gi">+            return None</span>
<span class="gi">+        new_schema[constraint] = getattr(annotation, constraint)</span>
<span class="gi">+</span>
<span class="gi">+    return new_schema</span>


<span class="w"> </span>def collect_known_metadata(annotations: Iterable[Any]) -&gt;tuple[dict[str,
<span class="gu">@@ -136,7 +188,23 @@ def collect_known_metadata(annotations: Iterable[Any]) -&gt;tuple[dict[str,</span>
<span class="w"> </span>        #&gt; ({&#39;gt&#39;: 1, &#39;min_length&#39;: 42}, [Ellipsis])
<span class="w"> </span>        ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    known_metadata = {}</span>
<span class="gi">+    unknown_annotations = []</span>
<span class="gi">+    at_to_constraint = _get_at_to_constraint_map()</span>
<span class="gi">+</span>
<span class="gi">+    for annotation in expand_grouped_metadata(annotations):</span>
<span class="gi">+        annotation_type = type(annotation)</span>
<span class="gi">+        if annotation_type in at_to_constraint:</span>
<span class="gi">+            constraint = at_to_constraint[annotation_type]</span>
<span class="gi">+            if constraint == &#39;length&#39;:</span>
<span class="gi">+                known_metadata[&#39;min_length&#39;] = annotation.min_length</span>
<span class="gi">+                known_metadata[&#39;max_length&#39;] = annotation.max_length</span>
<span class="gi">+            else:</span>
<span class="gi">+                known_metadata[constraint] = getattr(annotation, constraint)</span>
<span class="gi">+        else:</span>
<span class="gi">+            unknown_annotations.append(annotation)</span>
<span class="gi">+</span>
<span class="gi">+    return known_metadata, unknown_annotations</span>


<span class="w"> </span>def check_metadata(metadata: dict[str, Any], allowed: Iterable[str],
<span class="gu">@@ -152,4 +220,11 @@ def check_metadata(metadata: dict[str, Any], allowed: Iterable[str],</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        TypeError: If there is metadatas that can&#39;t be applied on source type.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    allowed_set = set(allowed)</span>
<span class="gi">+    invalid_constraints = set(metadata.keys()) - allowed_set</span>
<span class="gi">+    if invalid_constraints:</span>
<span class="gi">+        raise TypeError(</span>
<span class="gi">+            f&quot;The following constraints cannot be applied to a {source_type}: &quot;</span>
<span class="gi">+            f&quot;{&#39;, &#39;.join(invalid_constraints)}. &quot;</span>
<span class="gi">+            f&quot;Allowed constraints are: {&#39;, &#39;.join(allowed_set)}&quot;</span>
<span class="gi">+        )</span>
<span class="gh">diff --git a/pydantic/_internal/_mock_val_ser.py b/pydantic/_internal/_mock_val_ser.py</span>
<span class="gh">index ff4c6139..6a5f3b73 100644</span>
<span class="gd">--- a/pydantic/_internal/_mock_val_ser.py</span>
<span class="gi">+++ b/pydantic/_internal/_mock_val_ser.py</span>
<span class="gu">@@ -34,6 +34,16 @@ class MockCoreSchema(Mapping[str, Any]):</span>
<span class="w"> </span>    def __iter__(self) -&gt;Iterator[str]:
<span class="w"> </span>        return self._get_built().__iter__()

<span class="gi">+    def _get_built(self) -&gt; CoreSchema:</span>
<span class="gi">+        if self._built_memo is None:</span>
<span class="gi">+            if self._attempt_rebuild:</span>
<span class="gi">+                rebuilt = self._attempt_rebuild()</span>
<span class="gi">+                if rebuilt is not None:</span>
<span class="gi">+                    self._built_memo = rebuilt</span>
<span class="gi">+                    return self._built_memo</span>
<span class="gi">+            raise PydanticUserError(self._error_message, code=self._code)</span>
<span class="gi">+        return self._built_memo</span>
<span class="gi">+</span>

<span class="w"> </span>class MockValSer(Generic[ValSer]):
<span class="w"> </span>    &quot;&quot;&quot;Mocker for `pydantic_core.SchemaValidator` or `pydantic_core.SchemaSerializer` which optionally attempts to
<span class="gu">@@ -69,7 +79,17 @@ def set_model_mocks(cls: type[BaseModel], cls_name: str, undefined_name:</span>
<span class="w"> </span>        cls_name: Name of the model class, used in error messages
<span class="w"> </span>        undefined_name: Name of the undefined thing, used in error messages
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    error_message = f&quot;The model &#39;{cls_name}&#39; is not fully defined; {undefined_name} have not been imported yet&quot;</span>
<span class="gi">+    cls.__pydantic_validator__ = MockValSer(</span>
<span class="gi">+        error_message,</span>
<span class="gi">+        code=PydanticErrorCodes.model_not_fully_defined,</span>
<span class="gi">+        val_or_ser=&#39;validator&#39;</span>
<span class="gi">+    )</span>
<span class="gi">+    cls.__pydantic_serializer__ = MockValSer(</span>
<span class="gi">+        error_message,</span>
<span class="gi">+        code=PydanticErrorCodes.model_not_fully_defined,</span>
<span class="gi">+        val_or_ser=&#39;serializer&#39;</span>
<span class="gi">+    )</span>


<span class="w"> </span>def set_dataclass_mocks(cls: type[PydanticDataclass], cls_name: str,
<span class="gu">@@ -81,4 +101,14 @@ def set_dataclass_mocks(cls: type[PydanticDataclass], cls_name: str,</span>
<span class="w"> </span>        cls_name: Name of the model class, used in error messages
<span class="w"> </span>        undefined_name: Name of the undefined thing, used in error messages
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    error_message = f&quot;The dataclass &#39;{cls_name}&#39; is not fully defined; {undefined_name} have not been imported yet&quot;</span>
<span class="gi">+    cls.__pydantic_validator__ = MockValSer(</span>
<span class="gi">+        error_message,</span>
<span class="gi">+        code=PydanticErrorCodes.dataclass_not_fully_defined,</span>
<span class="gi">+        val_or_ser=&#39;validator&#39;</span>
<span class="gi">+    )</span>
<span class="gi">+    cls.__pydantic_serializer__ = MockValSer(</span>
<span class="gi">+        error_message,</span>
<span class="gi">+        code=PydanticErrorCodes.dataclass_not_fully_defined,</span>
<span class="gi">+        val_or_ser=&#39;serializer&#39;</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/pydantic/_internal/_model_construction.py b/pydantic/_internal/_model_construction.py</span>
<span class="gh">index f8876857..680a15b1 100644</span>
<span class="gd">--- a/pydantic/_internal/_model_construction.py</span>
<span class="gi">+++ b/pydantic/_internal/_model_construction.py</span>
<span class="gu">@@ -231,7 +231,12 @@ def init_private_attributes(self: BaseModel, context: Any, /) -&gt;None:</span>
<span class="w"> </span>def get_model_post_init(namespace: dict[str, Any], bases: tuple[type[Any], ...]
<span class="w"> </span>    ) -&gt;(Callable[..., Any] | None):
<span class="w"> </span>    &quot;&quot;&quot;Get the `model_post_init` method from the namespace or the class bases, or `None` if not defined.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if &#39;model_post_init&#39; in namespace:</span>
<span class="gi">+        return namespace[&#39;model_post_init&#39;]</span>
<span class="gi">+    for base in bases:</span>
<span class="gi">+        if hasattr(base, &#39;model_post_init&#39;):</span>
<span class="gi">+            return getattr(base, &#39;model_post_init&#39;)</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def inspect_namespace(namespace: dict[str, Any], ignored_types: tuple[type[
<span class="gu">@@ -257,7 +262,43 @@ def inspect_namespace(namespace: dict[str, Any], ignored_types: tuple[type[</span>
<span class="w"> </span>            - If a field does not have a type annotation.
<span class="w"> </span>            - If a field on base class was overridden by a non-annotated attribute.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from ..fields import ModelPrivateAttr</span>
<span class="gi">+    from ..errors import PydanticUserError</span>
<span class="gi">+</span>
<span class="gi">+    private_attributes: dict[str, ModelPrivateAttr] = {}</span>
<span class="gi">+    annotations = namespace.get(&#39;__annotations__&#39;, {})</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;__root__&#39; in namespace:</span>
<span class="gi">+        raise TypeError(&quot;To define a &#39;root model&#39;, use `pydantic.RootModel` rather than a field called &#39;__root__&#39;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    for name, value in namespace.items():</span>
<span class="gi">+        if name.startswith(&#39;__&#39;):</span>
<span class="gi">+            continue</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(value, ModelPrivateAttr):</span>
<span class="gi">+            if name.startswith(&#39;_&#39;):</span>
<span class="gi">+                private_attributes[name] = value</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise NameError(</span>
<span class="gi">+                    f&#39;Private attributes &quot;{name}&quot; must not be a valid field name; &#39;</span>
<span class="gi">+                    f&#39;Use sunder or dunder names, e.g. &quot;_{name}&quot; or &quot;__{name}__&quot;&#39;</span>
<span class="gi">+                )</span>
<span class="gi">+        elif not is_valid_field_name(name):</span>
<span class="gi">+            continue</span>
<span class="gi">+        elif name in base_class_fields and name not in annotations:</span>
<span class="gi">+            raise PydanticUserError(</span>
<span class="gi">+                f&#39;Field &quot;{name}&quot; defined on a base class was overridden by a non-annotated attribute. &#39;</span>
<span class="gi">+                f&#39;All fields must be annotated. &#39;</span>
<span class="gi">+                f&#39;To avoid this error, use `{name}: {type(value).__name__} = ...`&#39;,</span>
<span class="gi">+                code=&#39;model-field-overridden&#39;,</span>
<span class="gi">+            )</span>
<span class="gi">+        elif name not in annotations:</span>
<span class="gi">+            if name in base_class_vars:</span>
<span class="gi">+                continue</span>
<span class="gi">+            if not isinstance(value, ignored_types):</span>
<span class="gi">+                warnings.warn(f&#39;Field &quot;{name}&quot; has no type annotation&#39;, UserWarning, stacklevel=2)</span>
<span class="gi">+</span>
<span class="gi">+    return private_attributes</span>


<span class="w"> </span>def set_model_fields(cls: type[BaseModel], bases: tuple[type[Any], ...],
<span class="gu">@@ -270,7 +311,18 @@ def set_model_fields(cls: type[BaseModel], bases: tuple[type[Any], ...],</span>
<span class="w"> </span>        config_wrapper: The config wrapper instance.
<span class="w"> </span>        types_namespace: Optional extra namespace to look for types in.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from ..fields import FieldInfo</span>
<span class="gi">+</span>
<span class="gi">+    cls.model_fields, cls.__class_vars__ = collect_model_fields(</span>
<span class="gi">+        cls,</span>
<span class="gi">+        bases,</span>
<span class="gi">+        config_wrapper,</span>
<span class="gi">+        types_namespace,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    for field in cls.model_fields.values():</span>
<span class="gi">+        if isinstance(field, FieldInfo):</span>
<span class="gi">+            field.set_config(config_wrapper)</span>


<span class="w"> </span>def complete_model_class(cls: type[BaseModel], cls_name: str,
<span class="gu">@@ -297,12 +349,53 @@ def complete_model_class(cls: type[BaseModel], cls_name: str,</span>
<span class="w"> </span>        PydanticUndefinedAnnotation: If `PydanticUndefinedAnnotation` occurs in`__get_pydantic_core_schema__`
<span class="w"> </span>            and `raise_errors=True`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from ..errors import PydanticUndefinedAnnotation</span>
<span class="gi">+</span>
<span class="gi">+    if cls.__pydantic_complete__:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        types_namespace = types_namespace or {}</span>
<span class="gi">+        model_module = create_model_module or cls.__module__</span>
<span class="gi">+        cls.__pydantic_core_schema__ = GenerateSchema(</span>
<span class="gi">+            config_wrapper,</span>
<span class="gi">+            types_namespace,</span>
<span class="gi">+            model_module,</span>
<span class="gi">+        ).generate_schema(cls)</span>
<span class="gi">+</span>
<span class="gi">+        cls.__pydantic_validator__ = create_schema_validator(</span>
<span class="gi">+            cls.__pydantic_core_schema__,</span>
<span class="gi">+            cls,</span>
<span class="gi">+            config_wrapper.config_dict,</span>
<span class="gi">+            cls_name,</span>
<span class="gi">+        )</span>
<span class="gi">+        cls.__pydantic_serializer__ = SchemaSerializer(cls.__pydantic_core_schema__)</span>
<span class="gi">+</span>
<span class="gi">+        set_model_mocks(cls)</span>
<span class="gi">+        cls.__pydantic_complete__ = True</span>
<span class="gi">+        return True</span>
<span class="gi">+    except PydanticUndefinedAnnotation as e:</span>
<span class="gi">+        if raise_errors:</span>
<span class="gi">+            raise</span>
<span class="gi">+        warnings.warn(str(e), UserWarning)</span>
<span class="gi">+        return False</span>


<span class="w"> </span>def set_deprecated_descriptors(cls: type[BaseModel]) -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Set data descriptors on the class for deprecated fields.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for field_name, field in cls.model_fields.items():</span>
<span class="gi">+        if field.deprecated:</span>
<span class="gi">+            msg = f&#39;The field &quot;{field_name}&quot; is deprecated&#39;</span>
<span class="gi">+            if isinstance(field.deprecated, str):</span>
<span class="gi">+                msg += f&#39;, {field.deprecated}&#39;</span>
<span class="gi">+            setattr(cls, field_name, _DeprecatedFieldDescriptor(msg))</span>
<span class="gi">+</span>
<span class="gi">+    for name, decorator_info in cls.__pydantic_decorators__.computed_fields.items():</span>
<span class="gi">+        if decorator_info.info.deprecated:</span>
<span class="gi">+            msg = f&#39;The computed_field &quot;{name}&quot; is deprecated&#39;</span>
<span class="gi">+            if isinstance(decorator_info.info.deprecated, str):</span>
<span class="gi">+                msg += f&#39;, {decorator_info.info.deprecated}&#39;</span>
<span class="gi">+            setattr(cls, name, _DeprecatedFieldDescriptor(msg, decorator_info.wrapped))</span>


<span class="w"> </span>class _DeprecatedFieldDescriptor:
<span class="gu">@@ -379,10 +472,14 @@ def build_lenient_weakvaluedict(d: (dict[str, Any] | None)) -&gt;(dict[str,</span>

<span class="w"> </span>    The `unpack_lenient_weakvaluedict` function can be used to reverse this operation.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if d is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    return {k: _PydanticWeakRef(v) for k, v in d.items()}</span>


<span class="w"> </span>def unpack_lenient_weakvaluedict(d: (dict[str, Any] | None)) -&gt;(dict[str,
<span class="w"> </span>    Any] | None):
<span class="w"> </span>    &quot;&quot;&quot;Inverts the transform performed by `build_lenient_weakvaluedict`.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if d is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    return {k: v() for k, v in d.items()}</span>
<span class="gh">diff --git a/pydantic/_internal/_repr.py b/pydantic/_internal/_repr.py</span>
<span class="gh">index ad15026c..46212ae8 100644</span>
<span class="gd">--- a/pydantic/_internal/_repr.py</span>
<span class="gi">+++ b/pydantic/_internal/_repr.py</span>
<span class="gu">@@ -80,4 +80,25 @@ def display_as_type(obj: Any) -&gt;str:</span>

<span class="w"> </span>    Takes some logic from `typing._type_repr`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(obj, type):</span>
<span class="gi">+        if obj.__module__ == &#39;builtins&#39;:</span>
<span class="gi">+            return obj.__qualname__</span>
<span class="gi">+        return f&#39;{obj.__module__}.{obj.__qualname__}&#39;</span>
<span class="gi">+    </span>
<span class="gi">+    if obj is ...:</span>
<span class="gi">+        return &#39;...&#39;</span>
<span class="gi">+    </span>
<span class="gi">+    if obj is Any:</span>
<span class="gi">+        return &#39;Any&#39;</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(obj, _typing_extra.TypeAliasType):</span>
<span class="gi">+        return obj.__name__</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(obj, types.GenericAlias):</span>
<span class="gi">+        params = &#39;, &#39;.join(display_as_type(param) for param in obj.__args__)</span>
<span class="gi">+        return f&#39;{obj.__origin__.__name__}[{params}]&#39;</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(obj, _typing_extra.TypeVar):</span>
<span class="gi">+        return obj.__name__</span>
<span class="gi">+    </span>
<span class="gi">+    return repr(obj)</span>
<span class="gh">diff --git a/pydantic/_internal/_schema_generation_shared.py b/pydantic/_internal/_schema_generation_shared.py</span>
<span class="gh">index 34203092..c0845567 100644</span>
<span class="gd">--- a/pydantic/_internal/_schema_generation_shared.py</span>
<span class="gi">+++ b/pydantic/_internal/_schema_generation_shared.py</span>
<span class="gu">@@ -47,7 +47,16 @@ class GenerateJsonSchemaHandler(GetJsonSchemaHandler):</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>            LookupError: If it can&#39;t find the definition for `$ref`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(maybe_ref_json_schema, dict) and &#39;$ref&#39; in maybe_ref_json_schema:</span>
<span class="gi">+            ref = maybe_ref_json_schema[&#39;$ref&#39;]</span>
<span class="gi">+            if not ref.startswith(&#39;#/definitions/&#39;):</span>
<span class="gi">+                raise ValueError(f&quot;Invalid $ref format: {ref}&quot;)</span>
<span class="gi">+            definition_key = ref[len(&#39;#/definitions/&#39;):]</span>
<span class="gi">+            try:</span>
<span class="gi">+                return self.generate_json_schema.definitions[definition_key]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                raise LookupError(f&quot;Definition not found for $ref: {ref}&quot;)</span>
<span class="gi">+        return maybe_ref_json_schema</span>


<span class="w"> </span>class CallbackGetCoreSchemaHandler(GetCoreSchemaHandler):
<span class="gu">@@ -88,4 +97,10 @@ class CallbackGetCoreSchemaHandler(GetCoreSchemaHandler):</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>            LookupError: If it can&#39;t find the definition for reference.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(maybe_ref_schema, dict) and &#39;ref&#39; in maybe_ref_schema:</span>
<span class="gi">+            ref = maybe_ref_schema[&#39;ref&#39;]</span>
<span class="gi">+            try:</span>
<span class="gi">+                return self._generate_schema.defs.definitions[ref]</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                raise LookupError(f&quot;Definition not found for reference: {ref}&quot;)</span>
<span class="gi">+        return maybe_ref_schema</span>
<span class="gh">diff --git a/pydantic/_internal/_signature.py b/pydantic/_internal/_signature.py</span>
<span class="gh">index f5663caa..da9f9662 100644</span>
<span class="gd">--- a/pydantic/_internal/_signature.py</span>
<span class="gi">+++ b/pydantic/_internal/_signature.py</span>
<span class="gu">@@ -22,7 +22,11 @@ def _field_name_for_signature(field_name: str, field_info: FieldInfo) -&gt;str:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The correct name to use when generating a signature.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if field_info.validation_alias and isinstance(field_info.validation_alias, str) and is_valid_identifier(field_info.validation_alias):</span>
<span class="gi">+        return field_info.validation_alias</span>
<span class="gi">+    elif field_info.alias and is_valid_identifier(field_info.alias):</span>
<span class="gi">+        return field_info.alias</span>
<span class="gi">+    return field_name</span>


<span class="w"> </span>def _process_param_defaults(param: Parameter) -&gt;Parameter:
<span class="gu">@@ -34,13 +38,38 @@ def _process_param_defaults(param: Parameter) -&gt;Parameter:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        Parameter: The custom processed parameter
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(param.default, FieldInfo):</span>
<span class="gi">+        default = param.default.default</span>
<span class="gi">+        if default is PydanticUndefined:</span>
<span class="gi">+            default = Parameter.empty</span>
<span class="gi">+        return param.replace(default=default)</span>
<span class="gi">+    return param</span>


<span class="w"> </span>def _generate_signature_parameters(init: Callable[..., None], fields: dict[
<span class="w"> </span>    str, FieldInfo], config_wrapper: ConfigWrapper) -&gt;dict[str, Parameter]:
<span class="w"> </span>    &quot;&quot;&quot;Generate a mapping of parameter names to Parameter objects for a pydantic BaseModel or dataclass.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    init_signature = signature(init)</span>
<span class="gi">+    parameters = {}</span>
<span class="gi">+</span>
<span class="gi">+    for name, param in init_signature.parameters.items():</span>
<span class="gi">+        if name == &#39;self&#39;:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if name in fields:</span>
<span class="gi">+            field_info = fields[name]</span>
<span class="gi">+            param_name = _field_name_for_signature(name, field_info)</span>
<span class="gi">+            default = field_info.default if field_info.default is not PydanticUndefined else Parameter.empty</span>
<span class="gi">+            annotation = field_info.annotation if field_info.annotation is not PydanticUndefined else param.annotation</span>
<span class="gi">+            parameters[param_name] = Parameter(</span>
<span class="gi">+                param_name,</span>
<span class="gi">+                kind=param.kind,</span>
<span class="gi">+                default=default,</span>
<span class="gi">+                annotation=annotation</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            parameters[name] = param</span>
<span class="gi">+</span>
<span class="gi">+    return parameters</span>


<span class="w"> </span>def generate_pydantic_signature(init: Callable[..., None], fields: dict[str,
<span class="gu">@@ -57,4 +86,12 @@ def generate_pydantic_signature(init: Callable[..., None], fields: dict[str,</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The dataclass/BaseModel subclass signature.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parameters = _generate_signature_parameters(init, fields, config_wrapper)</span>
<span class="gi">+    </span>
<span class="gi">+    if is_dataclass:</span>
<span class="gi">+        parameters = {name: _process_param_defaults(param) for name, param in parameters.items()}</span>
<span class="gi">+    </span>
<span class="gi">+    return Signature(</span>
<span class="gi">+        parameters=list(parameters.values()),</span>
<span class="gi">+        return_annotation=Signature.empty</span>
<span class="gi">+    )</span>
<span class="gh">diff --git a/pydantic/_internal/_typing_extra.py b/pydantic/_internal/_typing_extra.py</span>
<span class="gh">index 1caf85c1..ae6213a6 100644</span>
<span class="gd">--- a/pydantic/_internal/_typing_extra.py</span>
<span class="gi">+++ b/pydantic/_internal/_typing_extra.py</span>
<span class="gu">@@ -52,14 +52,29 @@ def all_literal_values(type_: type[Any]) -&gt;list[Any]:</span>
<span class="w"> </span>    Literal can be used recursively (see https://www.python.org/dev/peps/pep-0586)
<span class="w"> </span>    e.g. `Literal[Literal[Literal[1, 2, 3], &quot;foo&quot;], 5, None]`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if get_origin(type_) in LITERAL_TYPES:</span>
<span class="gi">+        values = []</span>
<span class="gi">+        for arg in get_args(type_):</span>
<span class="gi">+            if get_origin(arg) in LITERAL_TYPES:</span>
<span class="gi">+                values.extend(all_literal_values(arg))</span>
<span class="gi">+            else:</span>
<span class="gi">+                values.append(arg)</span>
<span class="gi">+        return values</span>
<span class="gi">+    raise ValueError(f&quot;{type_} is not a Literal type&quot;)</span>


<span class="w"> </span>def is_namedtuple(type_: type[Any]) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Check if a given class is a named tuple.
<span class="w"> </span>    It can be either a `typing.NamedTuple` or `collections.namedtuple`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (</span>
<span class="gi">+        isinstance(type_, type) and</span>
<span class="gi">+        issubclass(type_, tuple) and</span>
<span class="gi">+        hasattr(type_, &#39;_fields&#39;) and</span>
<span class="gi">+        hasattr(type_, &#39;_field_defaults&#39;) and</span>
<span class="gi">+        hasattr(type_, &#39;_make&#39;) and</span>
<span class="gi">+        hasattr(type_, &#39;_replace&#39;)</span>
<span class="gi">+    )</span>


<span class="w"> </span>test_new_type = typing.NewType(&#39;test_new_type&#39;, str)
<span class="gu">@@ -70,12 +85,12 @@ def is_new_type(type_: type[Any]) -&gt;bool:</span>

<span class="w"> </span>    Can&#39;t use isinstance because it fails &lt;3.10.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return hasattr(type_, &#39;__supertype__&#39;) and callable(type_)</span>


<span class="w"> </span>def _check_finalvar(v: (type[Any] | None)) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Check if a given type is a `typing.Final` type.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return v is not None and get_origin(v) is typing.Final</span>


<span class="w"> </span>def parent_frame_namespace(*, parent_depth: int=2) -&gt;(dict[str, Any] | None):
<span class="gu">@@ -90,7 +105,12 @@ def parent_frame_namespace(*, parent_depth: int=2) -&gt;(dict[str, Any] | None):</span>
<span class="w"> </span>    dict of exactly what&#39;s in scope. Using `f_back` would work sometimes but would be very wrong and confusing in many
<span class="w"> </span>    other cases. See https://discuss.python.org/t/is-there-a-way-to-access-parent-nested-namespaces/20659.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        frame = sys._getframe(parent_depth)</span>
<span class="gi">+    except ValueError:  # pragma: no cover</span>
<span class="gi">+        return None</span>
<span class="gi">+    else:</span>
<span class="gi">+        return frame.f_locals</span>


<span class="w"> </span>def get_cls_type_hints_lenient(obj: Any, globalns: (dict[str, Any] | None)=None
<span class="gu">@@ -99,13 +119,27 @@ def get_cls_type_hints_lenient(obj: Any, globalns: (dict[str, Any] | None)=None</span>

<span class="w"> </span>    Unlike `typing.get_type_hints`, this function will not error if a forward reference is not resolvable.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    hints = {}</span>
<span class="gi">+    for base in reversed(obj.__mro__):</span>
<span class="gi">+        if base is object:</span>
<span class="gi">+            continue</span>
<span class="gi">+        base_hints = base.__dict__.get(&#39;__annotations__&#39;, {})</span>
<span class="gi">+        for name, value in base_hints.items():</span>
<span class="gi">+            if isinstance(value, str):</span>
<span class="gi">+                value = eval_type_lenient(value, globalns, {})</span>
<span class="gi">+            hints[name] = value</span>
<span class="gi">+    return hints</span>


<span class="w"> </span>def eval_type_lenient(value: Any, globalns: (dict[str, Any] | None)=None,
<span class="w"> </span>    localns: (dict[str, Any] | None)=None) -&gt;Any:
<span class="w"> </span>    &quot;&quot;&quot;Behaves like typing._eval_type, except it won&#39;t raise an error if a forward reference can&#39;t be resolved.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, str):</span>
<span class="gi">+        try:</span>
<span class="gi">+            value = eval(value, globalns, localns)</span>
<span class="gi">+        except NameError:</span>
<span class="gi">+            return value</span>
<span class="gi">+    return value</span>


<span class="w"> </span>def eval_type_backport(value: Any, globalns: (dict[str, Any] | None)=None,
<span class="gh">diff --git a/pydantic/_internal/_utils.py b/pydantic/_internal/_utils.py</span>
<span class="gh">index 5353dcfc..019c1756 100644</span>
<span class="gd">--- a/pydantic/_internal/_utils.py</span>
<span class="gi">+++ b/pydantic/_internal/_utils.py</span>
<span class="gu">@@ -32,7 +32,8 @@ def is_model_class(cls: Any) -&gt;TypeGuard[type[BaseModel]]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Returns true if cls is a _proper_ subclass of BaseModel, and provides proper type-checking,
<span class="w"> </span>    unlike raw calls to lenient_issubclass.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from ..main import BaseModel</span>
<span class="gi">+    return isinstance(cls, type) and issubclass(cls, BaseModel) and cls is not BaseModel</span>


<span class="w"> </span>def is_valid_identifier(identifier: str) -&gt;bool:
<span class="gu">@@ -40,7 +41,7 @@ def is_valid_identifier(identifier: str) -&gt;bool:</span>
<span class="w"> </span>    :param identifier: The identifier to test.
<span class="w"> </span>    :return: True if the identifier is valid.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return identifier.isidentifier() and not keyword.iskeyword(identifier)</span>


<span class="w"> </span>KeyType = TypeVar(&#39;KeyType&#39;)
<span class="gu">@@ -53,7 +54,18 @@ def unique_list(input_list: (list[T] | tuple[T, ...]), *, name_factory:</span>
<span class="w"> </span>    We update the list if another one with the same name is set
<span class="w"> </span>    (e.g. model validator overridden in subclass).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = []</span>
<span class="gi">+    seen = set()</span>
<span class="gi">+    for item in input_list:</span>
<span class="gi">+        name = name_factory(item)</span>
<span class="gi">+        if name not in seen:</span>
<span class="gi">+            seen.add(name)</span>
<span class="gi">+            result.append(item)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Update existing item with the same name</span>
<span class="gi">+            index = next(i for i, x in enumerate(result) if name_factory(x) == name)</span>
<span class="gi">+            result[index] = item</span>
<span class="gi">+    return result</span>


<span class="w"> </span>class ValueItems(_repr.Representation):
<span class="gu">@@ -72,21 +84,23 @@ class ValueItems(_repr.Representation):</span>

<span class="w"> </span>        :param item: key or index of a value
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return item in self._items and self._items[item] is False</span>

<span class="w"> </span>    def is_included(self, item: Any) -&gt;bool:
<span class="w"> </span>        &quot;&quot;&quot;Check if value is contained in self._items.

<span class="w"> </span>        :param item: key or index of value
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return item in self._items and self._items[item] is not False</span>

<span class="w"> </span>    def for_element(self, e: (int | str)) -&gt;(AbstractSetIntStr |
<span class="w"> </span>        MappingIntStrAny | None):
<span class="w"> </span>        &quot;&quot;&quot;:param e: key or index of element on value
<span class="w"> </span>        :return: raw values for element if self._items is dict and contain needed element
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(self._items, Mapping):</span>
<span class="gi">+            return self._items.get(e)</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def _normalize_indexes(self, items: MappingIntStrAny, v_length: int
<span class="w"> </span>        ) -&gt;dict[int | str, Any]:
<span class="gu">@@ -98,7 +112,18 @@ class ValueItems(_repr.Representation):</span>
<span class="w"> </span>        &gt;&gt;&gt; self._normalize_indexes({&#39;__all__&#39;: True}, 4)
<span class="w"> </span>        {0: True, 1: True, 2: True, 3: True}
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if &#39;__all__&#39; in items:</span>
<span class="gi">+            return {i: True for i in range(v_length)}</span>
<span class="gi">+        normalized = {}</span>
<span class="gi">+        for i, v in items.items():</span>
<span class="gi">+            if isinstance(i, int):</span>
<span class="gi">+                if i &lt; 0:</span>
<span class="gi">+                    i += v_length</span>
<span class="gi">+                if 0 &lt;= i &lt; v_length:</span>
<span class="gi">+                    normalized[i] = v</span>
<span class="gi">+            else:</span>
<span class="gi">+                normalized[i] = v</span>
<span class="gi">+        return normalized</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def merge(cls, base: Any, override: Any, intersect: bool=False) -&gt;Any:
<span class="gu">@@ -115,7 +140,36 @@ class ValueItems(_repr.Representation):</span>
<span class="w"> </span>        set to `False` (default) and on the intersection of keys if
<span class="w"> </span>        `intersect` is set to `True`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        base = cls._items_to_dict(base)</span>
<span class="gi">+        override = cls._items_to_dict(override)</span>
<span class="gi">+</span>
<span class="gi">+        if intersect:</span>
<span class="gi">+            keys = set(base.keys()) &amp; set(override.keys())</span>
<span class="gi">+        else:</span>
<span class="gi">+            keys = set(base.keys()) | set(override.keys())</span>
<span class="gi">+</span>
<span class="gi">+        merged = {}</span>
<span class="gi">+        for k in keys:</span>
<span class="gi">+            if k in base and k in override:</span>
<span class="gi">+                if isinstance(base[k], dict) and isinstance(override[k], dict):</span>
<span class="gi">+                    merged[k] = cls.merge(base[k], override[k], intersect)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    merged[k] = override[k]</span>
<span class="gi">+            elif k in base:</span>
<span class="gi">+                merged[k] = base[k]</span>
<span class="gi">+            else:</span>
<span class="gi">+                merged[k] = override[k]</span>
<span class="gi">+</span>
<span class="gi">+        return merged</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _items_to_dict(items: Any) -&gt;dict:</span>
<span class="gi">+        if isinstance(items, dict):</span>
<span class="gi">+            return items</span>
<span class="gi">+        elif isinstance(items, (set, frozenset)):</span>
<span class="gi">+            return {k: ... for k in items}</span>
<span class="gi">+        else:</span>
<span class="gi">+            return {}</span>

<span class="w"> </span>    def __repr_args__(self) -&gt;_repr.ReprArgs:
<span class="w"> </span>        return [(None, self._items)]
<span class="gu">@@ -146,7 +200,12 @@ def smart_deepcopy(obj: Obj) -&gt;Obj:</span>
<span class="w"> </span>    Use obj.copy() for built-in empty collections
<span class="w"> </span>    Use copy.deepcopy() for non-empty collections and unknown objects.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if type(obj) in IMMUTABLE_NON_COLLECTIONS_TYPES:</span>
<span class="gi">+        return obj</span>
<span class="gi">+    if type(obj) in BUILTIN_COLLECTIONS:</span>
<span class="gi">+        if not obj:  # Empty collection</span>
<span class="gi">+            return obj.copy()</span>
<span class="gi">+    return deepcopy(obj)</span>


<span class="w"> </span>_SENTINEL = object()
<span class="gu">@@ -162,7 +221,7 @@ def all_identical(left: typing.Iterable[Any], right: typing.Iterable[Any]</span>
<span class="w"> </span>    &gt;&gt;&gt; all_identical([a, b, [a]], [a, b, [a]])  # new list object, while &quot;equal&quot; is not &quot;identical&quot;
<span class="w"> </span>    False
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return all(l is r for l, r in zip_longest(left, right, fillvalue=_SENTINEL))</span>


<span class="w"> </span>@dataclasses.dataclass(frozen=True)
<span class="gh">diff --git a/pydantic/_internal/_validators.py b/pydantic/_internal/_validators.py</span>
<span class="gh">index 2f7d67f4..bbc80f7e 100644</span>
<span class="gd">--- a/pydantic/_internal/_validators.py</span>
<span class="gi">+++ b/pydantic/_internal/_validators.py</span>
<span class="gu">@@ -15,7 +15,7 @@ from pydantic_core._pydantic_core import PydanticKnownError</span>
<span class="w"> </span>def sequence_validator(input_value: typing.Sequence[Any], /, validator:
<span class="w"> </span>    core_schema.ValidatorFunctionWrapHandler) -&gt;typing.Sequence[Any]:
<span class="w"> </span>    &quot;&quot;&quot;Validator for `Sequence` types, isinstance(v, Sequence) has already been called.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return [validator(item) for item in input_value]</span>


<span class="w"> </span>def _import_string_logic(dotted_path: str) -&gt;Any:
<span class="gu">@@ -36,7 +36,27 @@ def _import_string_logic(dotted_path: str) -&gt;Any:</span>
<span class="w"> </span>    * the substring of `dotted_path` before the colon is not a valid module in the environment (e.g., &#39;123:Mapping&#39;)
<span class="w"> </span>    * the substring of `dotted_path` after the colon is not an attribute of the module (e.g., &#39;collections:abc123&#39;)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if dotted_path.count(&#39;:&#39;) &gt; 1:</span>
<span class="gi">+        raise ValueError(&quot;Invalid dotted path: too many colons&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if &#39;:&#39; in dotted_path:</span>
<span class="gi">+        module_path, attribute = dotted_path.split(&#39;:&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        module_path, attribute = dotted_path, None</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        module = __import__(module_path, fromlist=[&#39;__trash&#39;])</span>
<span class="gi">+        for chunk in module_path.split(&#39;.&#39;)[1:]:</span>
<span class="gi">+            module = getattr(module, chunk)</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        raise ValueError(f&quot;Unable to import module: {module_path}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if attribute:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return getattr(module, attribute)</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            raise ValueError(f&quot;Attribute {attribute} not found in module {module_path}&quot;)</span>
<span class="gi">+    return module</span>


<span class="w"> </span>PatternType = typing.TypeVar(&#39;PatternType&#39;, str, bytes)
<span class="gu">@@ -48,7 +68,13 @@ def ip_v4_network_validator(input_value: Any, /) -&gt;IPv4Network:</span>
<span class="w"> </span>    See more:
<span class="w"> </span>    https://docs.python.org/library/ipaddress.html#ipaddress.IPv4Network
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return IPv4Network(input_value)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise PydanticCustomError(</span>
<span class="gi">+            &#39;ip_v4_network&#39;,</span>
<span class="gi">+            &#39;Input is not a valid IPv4 network address&#39;</span>
<span class="gi">+        )</span>


<span class="w"> </span>def ip_v6_network_validator(input_value: Any, /) -&gt;IPv6Network:
<span class="gu">@@ -57,7 +83,13 @@ def ip_v6_network_validator(input_value: Any, /) -&gt;IPv6Network:</span>
<span class="w"> </span>    See more:
<span class="w"> </span>    https://docs.python.org/library/ipaddress.html#ipaddress.IPv6Network
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return IPv6Network(input_value)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise PydanticCustomError(</span>
<span class="gi">+            &#39;ip_v6_network&#39;,</span>
<span class="gi">+            &#39;Input is not a valid IPv6 network address&#39;</span>
<span class="gi">+        )</span>


<span class="w"> </span>_CONSTRAINT_TO_VALIDATOR_MAP: dict[str, Callable] = {&#39;gt&#39;:
<span class="gu">@@ -69,4 +101,7 @@ _CONSTRAINT_TO_VALIDATOR_MAP: dict[str, Callable] = {&#39;gt&#39;:</span>

<span class="w"> </span>def get_constraint_validator(constraint: str) -&gt;Callable:
<span class="w"> </span>    &quot;&quot;&quot;Fetch the validator function for the given constraint.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    validator = _CONSTRAINT_TO_VALIDATOR_MAP.get(constraint)</span>
<span class="gi">+    if validator is None:</span>
<span class="gi">+        raise ValueError(f&quot;Unknown constraint: {constraint}&quot;)</span>
<span class="gi">+    return validator</span>
<span class="gh">diff --git a/pydantic/_migration.py b/pydantic/_migration.py</span>
<span class="gh">index ef115aae..942a3bfa 100644</span>
<span class="gd">--- a/pydantic/_migration.py</span>
<span class="gi">+++ b/pydantic/_migration.py</span>
<span class="gu">@@ -156,7 +156,7 @@ REMOVED_IN_V2 = {&#39;pydantic:ConstrainedBytes&#39;, &#39;pydantic:ConstrainedDate&#39;,</span>
<span class="w"> </span>    &#39;pydantic:validate_model&#39;}


<span class="gd">-def getattr_migration(module: str) -&gt;Callable[[str], Any]:</span>
<span class="gi">+def getattr_migration(module: str) -&gt; Callable[[str], Any]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Implement PEP 562 for objects that were either moved or removed on the migration
<span class="w"> </span>    to V2.

<span class="gu">@@ -166,4 +166,35 @@ def getattr_migration(module: str) -&gt;Callable[[str], Any]:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        A callable that will raise an error if the object is not found.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def __getattr__(name: str) -&gt; Any:</span>
<span class="gi">+        full_name = f&quot;{module}:{name}&quot;</span>
<span class="gi">+        if full_name in MOVED_IN_V2:</span>
<span class="gi">+            new_location = MOVED_IN_V2[full_name]</span>
<span class="gi">+            new_module, new_name = new_location.split(&#39;:&#39;)</span>
<span class="gi">+            import_path = f&quot;from {new_module} import {new_name} as moved_obj&quot;</span>
<span class="gi">+            exec(import_path)</span>
<span class="gi">+            return locals()[&#39;moved_obj&#39;]</span>
<span class="gi">+        elif full_name in DEPRECATED_MOVED_IN_V2:</span>
<span class="gi">+            new_location = DEPRECATED_MOVED_IN_V2[full_name]</span>
<span class="gi">+            new_module, new_name = new_location.split(&#39;:&#39;)</span>
<span class="gi">+            import_path = f&quot;from {new_module} import {new_name} as moved_obj&quot;</span>
<span class="gi">+            exec(import_path)</span>
<span class="gi">+            import warnings</span>
<span class="gi">+            warnings.warn(f&quot;{full_name} is deprecated, use {new_location} instead&quot;, DeprecationWarning, stacklevel=2)</span>
<span class="gi">+            return locals()[&#39;moved_obj&#39;]</span>
<span class="gi">+        elif full_name in REDIRECT_TO_V1:</span>
<span class="gi">+            new_location = REDIRECT_TO_V1[full_name]</span>
<span class="gi">+            new_module, new_name = new_location.split(&#39;:&#39;)</span>
<span class="gi">+            import_path = f&quot;from {new_module} import {new_name} as moved_obj&quot;</span>
<span class="gi">+            exec(import_path)</span>
<span class="gi">+            return locals()[&#39;moved_obj&#39;]</span>
<span class="gi">+        elif full_name in REMOVED_IN_V2:</span>
<span class="gi">+            raise AttributeError(</span>
<span class="gi">+                f&quot;{full_name} was removed in Pydantic V2. &quot;</span>
<span class="gi">+                f&quot;Check the migration guide for more information: &quot;</span>
<span class="gi">+                f&quot;https://docs.pydantic.dev/latest/migration/&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise AttributeError(f&quot;module &#39;{module}&#39; has no attribute &#39;{name}&#39;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return __getattr__</span>
<span class="gh">diff --git a/pydantic/alias_generators.py b/pydantic/alias_generators.py</span>
<span class="gh">index c68d768b..1667bd0c 100644</span>
<span class="gd">--- a/pydantic/alias_generators.py</span>
<span class="gi">+++ b/pydantic/alias_generators.py</span>
<span class="gu">@@ -12,7 +12,7 @@ def to_pascal(snake: str) -&gt;str:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The PascalCase string.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return &#39;&#39;.join(word.capitalize() for word in snake.split(&#39;_&#39;))</span>


<span class="w"> </span>def to_camel(snake: str) -&gt;str:
<span class="gu">@@ -24,7 +24,8 @@ def to_camel(snake: str) -&gt;str:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The converted camelCase string.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    words = snake.split(&#39;_&#39;)</span>
<span class="gi">+    return words[0] + &#39;&#39;.join(word.capitalize() for word in words[1:])</span>


<span class="w"> </span>def to_snake(camel: str) -&gt;str:
<span class="gu">@@ -36,4 +37,10 @@ def to_snake(camel: str) -&gt;str:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The converted string in snake_case.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Handle kebab-case first</span>
<span class="gi">+    if &#39;-&#39; in camel:</span>
<span class="gi">+        return camel.replace(&#39;-&#39;, &#39;_&#39;).lower()</span>
<span class="gi">+    </span>
<span class="gi">+    # Handle PascalCase and camelCase</span>
<span class="gi">+    pattern = re.compile(r&#39;(?&lt;!^)(?=[A-Z])&#39;)</span>
<span class="gi">+    return pattern.sub(&#39;_&#39;, camel).lower()</span>
<span class="gh">diff --git a/pydantic/aliases.py b/pydantic/aliases.py</span>
<span class="gh">index a6947b0c..7141b03c 100644</span>
<span class="gd">--- a/pydantic/aliases.py</span>
<span class="gi">+++ b/pydantic/aliases.py</span>
<span class="gu">@@ -27,7 +27,7 @@ class AliasPath:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The list of aliases.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.path</span>

<span class="w"> </span>    def search_dict_for_path(self, d: dict) -&gt;Any:
<span class="w"> </span>        &quot;&quot;&quot;Searches a dictionary for the path specified by the alias.
<span class="gu">@@ -35,7 +35,13 @@ class AliasPath:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The value at the specified path, or `PydanticUndefined` if the path is not found.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        current = d</span>
<span class="gi">+        for key in self.path:</span>
<span class="gi">+            if isinstance(current, dict) and key in current:</span>
<span class="gi">+                current = current[key]</span>
<span class="gi">+            else:</span>
<span class="gi">+                return PydanticUndefined</span>
<span class="gi">+        return current</span>


<span class="w"> </span>@dataclasses.dataclass(**_internal_dataclass.slots_true)
<span class="gu">@@ -59,7 +65,10 @@ class AliasChoices:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The list of aliases.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return [</span>
<span class="gi">+            [choice] if isinstance(choice, str) else choice.convert_to_aliases()</span>
<span class="gi">+            for choice in self.choices</span>
<span class="gi">+        ]</span>


<span class="w"> </span>@dataclasses.dataclass(**_internal_dataclass.slots_true)
<span class="gu">@@ -87,7 +96,14 @@ class AliasGenerator:</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>            TypeError: If the alias generator produces an invalid type.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        generator = getattr(self, alias_kind)</span>
<span class="gi">+        if generator is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+        </span>
<span class="gi">+        alias = generator(field_name)</span>
<span class="gi">+        if not isinstance(alias, allowed_types):</span>
<span class="gi">+            raise TypeError(f&quot;{alias_kind} must be one of {allowed_types}, not {type(alias)}&quot;)</span>
<span class="gi">+        return alias</span>

<span class="w"> </span>    def generate_aliases(self, field_name: str) -&gt;tuple[str | None, str |
<span class="w"> </span>        AliasPath | AliasChoices | None, str | None]:
<span class="gu">@@ -96,4 +112,7 @@ class AliasGenerator:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A tuple of three aliases - validation, alias, and serialization.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        alias = self._generate_alias(&#39;alias&#39;, (str,), field_name)</span>
<span class="gi">+        validation_alias = self._generate_alias(&#39;validation_alias&#39;, (str, AliasPath, AliasChoices), field_name)</span>
<span class="gi">+        serialization_alias = self._generate_alias(&#39;serialization_alias&#39;, (str,), field_name)</span>
<span class="gi">+        return alias, validation_alias, serialization_alias</span>
<span class="gh">diff --git a/pydantic/annotated_handlers.py b/pydantic/annotated_handlers.py</span>
<span class="gh">index 92a4df50..3eae10c8 100644</span>
<span class="gd">--- a/pydantic/annotated_handlers.py</span>
<span class="gi">+++ b/pydantic/annotated_handlers.py</span>
<span class="gu">@@ -49,7 +49,12 @@ class GetJsonSchemaHandler:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            JsonSchemaValue: A JsonSchemaValue that has no `$ref`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(maybe_ref_json_schema, dict) and &#39;$ref&#39; in maybe_ref_json_schema:</span>
<span class="gi">+            ref = maybe_ref_json_schema[&#39;$ref&#39;]</span>
<span class="gi">+            # Here we would typically look up the reference in a schema store</span>
<span class="gi">+            # For this implementation, we&#39;ll raise a LookupError</span>
<span class="gi">+            raise LookupError(f&quot;Reference &#39;{ref}&#39; not found&quot;)</span>
<span class="gi">+        return maybe_ref_json_schema</span>


<span class="w"> </span>class GetCoreSchemaHandler:
<span class="gu">@@ -83,7 +88,7 @@ class GetCoreSchemaHandler:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            CoreSchema: The `pydantic-core` CoreSchema generated.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.__call__(source_type)</span>

<span class="w"> </span>    def resolve_ref_schema(self, maybe_ref_schema: core_schema.CoreSchema, /
<span class="w"> </span>        ) -&gt;core_schema.CoreSchema:
<span class="gu">@@ -100,13 +105,24 @@ class GetCoreSchemaHandler:</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A concrete `CoreSchema`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(maybe_ref_schema, dict) and maybe_ref_schema.get(&#39;type&#39;) == &#39;definition-ref&#39;:</span>
<span class="gi">+            ref = maybe_ref_schema.get(&#39;schema_ref&#39;)</span>
<span class="gi">+            if ref is None:</span>
<span class="gi">+                raise LookupError(&quot;Invalid definition-ref schema: missing &#39;schema_ref&#39;&quot;)</span>
<span class="gi">+            # Here we would typically look up the reference in a schema store</span>
<span class="gi">+            # For this implementation, we&#39;ll raise a LookupError</span>
<span class="gi">+            raise LookupError(f&quot;Reference &#39;{ref}&#39; not found&quot;)</span>
<span class="gi">+        return maybe_ref_schema</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def field_name(self) -&gt;(str | None):
<span class="w"> </span>        &quot;&quot;&quot;Get the name of the closest field to this validator.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # This is a placeholder implementation. In a real scenario,</span>
<span class="gi">+        # this would likely be set during the schema generation process.</span>
<span class="gi">+        return getattr(self, &#39;_field_name&#39;, None)</span>

<span class="w"> </span>    def _get_types_namespace(self) -&gt;(dict[str, Any] | None):
<span class="w"> </span>        &quot;&quot;&quot;Internal method used during type resolution for serializer annotations.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # This is a placeholder implementation. In a real scenario,</span>
<span class="gi">+        # this would return a dictionary of types used in the current context.</span>
<span class="gi">+        return getattr(self, &#39;_types_namespace&#39;, None)</span>
<span class="gh">diff --git a/pydantic/color.py b/pydantic/color.py</span>
<span class="gh">index dae7ca3d..6548a1fc 100644</span>
<span class="gd">--- a/pydantic/color.py</span>
<span class="gi">+++ b/pydantic/color.py</span>
<span class="gu">@@ -99,7 +99,7 @@ class Color(_repr.Representation):</span>

<span class="w"> </span>    def original(self) -&gt;ColorType:
<span class="w"> </span>        &quot;&quot;&quot;Original value passed to `Color`.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._original</span>

<span class="w"> </span>    def as_named(self, *, fallback: bool=False) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Returns the name of the color if it can be found in `COLORS_BY_VALUE` dictionary,
<span class="gu">@@ -115,7 +115,13 @@ class Color(_repr.Representation):</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>            ValueError: When no named color is found and fallback is `False`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rgb = self.as_rgb_tuple(alpha=False)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return COLORS_BY_VALUE[rgb]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            if fallback:</span>
<span class="gi">+                return self.as_hex()</span>
<span class="gi">+            raise ValueError(f&#39;Color {rgb} has no name&#39;)</span>

<span class="w"> </span>    def as_hex(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Returns the hexadecimal representation of the color.
<span class="gu">@@ -126,11 +132,18 @@ class Color(_repr.Representation):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The hexadecimal representation of the color.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rgba = self._rgba</span>
<span class="gi">+        if rgba.alpha is None:</span>
<span class="gi">+            return f&#39;#{rgba.r:02x}{rgba.g:02x}{rgba.b:02x}&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return f&#39;#{rgba.r:02x}{rgba.g:02x}{rgba.b:02x}{int(rgba.alpha * 255):02x}&#39;</span>

<span class="w"> </span>    def as_rgb(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Color as an `rgb(&lt;r&gt;, &lt;g&gt;, &lt;b&gt;)` or `rgba(&lt;r&gt;, &lt;g&gt;, &lt;b&gt;, &lt;a&gt;)` string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._rgba.alpha is None:</span>
<span class="gi">+            return f&#39;rgb({self._rgba.r}, {self._rgba.g}, {self._rgba.b})&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return f&#39;rgba({self._rgba.r}, {self._rgba.g}, {self._rgba.b}, {self._rgba.alpha:.2f})&#39;</span>

<span class="w"> </span>    def as_rgb_tuple(self, *, alpha: Optional[bool]=None) -&gt;ColorTuple:
<span class="w"> </span>        &quot;&quot;&quot;Returns the color as an RGB or RGBA tuple.
<span class="gu">@@ -146,11 +159,20 @@ class Color(_repr.Representation):</span>
<span class="w"> </span>            A tuple that contains the values of the red, green, and blue channels in the range 0 to 255.
<span class="w"> </span>                If alpha is included, it is in the range 0 to 1.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if alpha is True:</span>
<span class="gi">+            return (self._rgba.r, self._rgba.g, self._rgba.b, self._rgba.alpha if self._rgba.alpha is not None else 1.0)</span>
<span class="gi">+        elif alpha is False:</span>
<span class="gi">+            return (self._rgba.r, self._rgba.g, self._rgba.b)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return (self._rgba.r, self._rgba.g, self._rgba.b) if self._rgba.alpha is None else (self._rgba.r, self._rgba.g, self._rgba.b, self._rgba.alpha)</span>

<span class="w"> </span>    def as_hsl(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;Color as an `hsl(&lt;h&gt;, &lt;s&gt;, &lt;l&gt;)` or `hsl(&lt;h&gt;, &lt;s&gt;, &lt;l&gt;, &lt;a&gt;)` string.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        h, s, l = self.as_hsl_tuple(alpha=False)</span>
<span class="gi">+        if self._rgba.alpha is None:</span>
<span class="gi">+            return f&#39;hsl({h:.0f}, {s:.0%}, {l:.0%})&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            return f&#39;hsla({h:.0f}, {s:.0%}, {l:.0%}, {self._rgba.alpha:.2f})&#39;</span>

<span class="w"> </span>    def as_hsl_tuple(self, *, alpha: Optional[bool]=None) -&gt;HslColorTuple:
<span class="w"> </span>        &quot;&quot;&quot;Returns the color as an HSL or HSLA tuple.
<span class="gu">@@ -169,7 +191,16 @@ class Color(_repr.Representation):</span>
<span class="w"> </span>        Note:
<span class="w"> </span>            This is HSL as used in HTML and most other places, not HLS as used in Python&#39;s `colorsys`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        r, g, b = self._rgba.r / 255, self._rgba.g / 255, self._rgba.b / 255</span>
<span class="gi">+        h, l, s = rgb_to_hls(r, g, b)</span>
<span class="gi">+        hsl = (h * 360 % 360, s, l)</span>
<span class="gi">+        </span>
<span class="gi">+        if alpha is True:</span>
<span class="gi">+            return (*hsl, self._rgba.alpha if self._rgba.alpha is not None else 1.0)</span>
<span class="gi">+        elif alpha is False:</span>
<span class="gi">+            return hsl</span>
<span class="gi">+        else:</span>
<span class="gi">+            return hsl if self._rgba.alpha is None else (*hsl, self._rgba.alpha)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def __get_pydantic_core_schema__(cls, source: Type[Any], handler:
<span class="gu">@@ -204,7 +235,14 @@ def parse_tuple(value: Tuple[Any, ...]) -&gt;RGBA:</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        PydanticCustomError: If tuple is not valid.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(value) == 3:</span>
<span class="gi">+        r, g, b = value</span>
<span class="gi">+        return ints_to_rgba(r, g, b)</span>
<span class="gi">+    elif len(value) == 4:</span>
<span class="gi">+        r, g, b, a = value</span>
<span class="gi">+        return ints_to_rgba(r, g, b, parse_float_alpha(a))</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise PydanticCustomError(&#39;color_error&#39;, &#39;value is not a valid RGB or RGBA tuple&#39;)</span>


<span class="w"> </span>def parse_str(value: str) -&gt;RGBA:
<span class="gu">@@ -227,7 +265,32 @@ def parse_str(value: str) -&gt;RGBA:</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        ValueError: If the input string cannot be parsed to an RGBA tuple.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    value = value.strip().lower()</span>
<span class="gi">+</span>
<span class="gi">+    # Named color</span>
<span class="gi">+    if value in COLORS_BY_NAME:</span>
<span class="gi">+        return RGBA(*COLORS_BY_NAME[value], None)</span>
<span class="gi">+</span>
<span class="gi">+    # Hex color</span>
<span class="gi">+    if value.startswith((&#39;#&#39;, &#39;0x&#39;)):</span>
<span class="gi">+        value = value[2:]</span>
<span class="gi">+    if len(value) in (3, 4):</span>
<span class="gi">+        value = &#39;&#39;.join(2 * c for c in value)</span>
<span class="gi">+    if len(value) == 6:</span>
<span class="gi">+        rgb = int(value, 16)</span>
<span class="gi">+        return RGBA(rgb &gt;&gt; 16, (rgb &gt;&gt; 8) &amp; 0xFF, rgb &amp; 0xFF, None)</span>
<span class="gi">+    elif len(value) == 8:</span>
<span class="gi">+        rgba = int(value, 16)</span>
<span class="gi">+        return RGBA(rgba &gt;&gt; 24, (rgba &gt;&gt; 16) &amp; 0xFF, (rgba &gt;&gt; 8) &amp; 0xFF, (rgba &amp; 0xFF) / 255)</span>
<span class="gi">+</span>
<span class="gi">+    # RGB(A) color</span>
<span class="gi">+    match = re.match(r&#39;rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([0-9.]+))?\)&#39;, value)</span>
<span class="gi">+    if match:</span>
<span class="gi">+        r, g, b = map(int, match.group(1, 2, 3))</span>
<span class="gi">+        a = float(match.group(4)) if match.group(4) else None</span>
<span class="gi">+        return RGBA(r, g, b, a)</span>
<span class="gi">+</span>
<span class="gi">+    raise ValueError(f&#39;Could not parse color string &quot;{value}&quot;&#39;)</span>


<span class="w"> </span>def ints_to_rgba(r: Union[int, str], g: Union[int, str], b: Union[int, str],
<span class="gh">diff --git a/pydantic/config.py b/pydantic/config.py</span>
<span class="gh">index 24abaf45..2de4b72b 100644</span>
<span class="gd">--- a/pydantic/config.py</span>
<span class="gi">+++ b/pydantic/config.py</span>
<span class="gu">@@ -978,7 +978,10 @@ def with_config(config: ConfigDict) -&gt;Callable[[_TypeT], _TypeT]:</span>
<span class="w"> </span>        #&gt; {&#39;x&#39;: &#39;abc&#39;}
<span class="w"> </span>        ```
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(cls: _TypeT) -&gt; _TypeT:</span>
<span class="gi">+        setattr(cls, &#39;__pydantic_config__&#39;, config)</span>
<span class="gi">+        return cls</span>
<span class="gi">+    return decorator</span>


<span class="w"> </span>__getattr__ = getattr_migration(__name__)
<span class="gh">diff --git a/pydantic/dataclasses.py b/pydantic/dataclasses.py</span>
<span class="gh">index cb2e2160..4cba6f43 100644</span>
<span class="gd">--- a/pydantic/dataclasses.py</span>
<span class="gi">+++ b/pydantic/dataclasses.py</span>
<span class="gu">@@ -56,7 +56,26 @@ def dataclass(_cls: (type[_T] | None)=None, *, init: Literal[False]=False,</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        AssertionError: Raised if `init` is not `False` or `validate_on_init` is `False`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert init is False, &quot;The &#39;init&#39; parameter must be False for Pydantic dataclasses&quot;</span>
<span class="gi">+    assert validate_on_init is not False, &quot;The &#39;validate_on_init&#39; parameter cannot be False&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def wrap(cls: type[_T]) -&gt; type[PydanticDataclass]:</span>
<span class="gi">+        return _pydantic_dataclasses.create_pydantic_dataclass(</span>
<span class="gi">+            cls,</span>
<span class="gi">+            config=config,</span>
<span class="gi">+            repr=repr,</span>
<span class="gi">+            eq=eq,</span>
<span class="gi">+            order=order,</span>
<span class="gi">+            unsafe_hash=unsafe_hash,</span>
<span class="gi">+            frozen=frozen,</span>
<span class="gi">+            kw_only=kw_only,</span>
<span class="gi">+            slots=slots,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if _cls is None:</span>
<span class="gi">+        return wrap</span>
<span class="gi">+</span>
<span class="gi">+    return wrap(_cls)</span>


<span class="w"> </span>__getattr__ = getattr_migration(__name__)
<span class="gu">@@ -92,7 +111,22 @@ def rebuild_dataclass(cls: type[PydanticDataclass], *, force: bool=False,</span>
<span class="w"> </span>        Returns `None` if the schema is already &quot;complete&quot; and rebuilding was not required.
<span class="w"> </span>        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not force and getattr(cls, &#39;__pydantic_complete__&#39;, False):</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        _pydantic_dataclasses.rebuild_dataclass(</span>
<span class="gi">+            cls,</span>
<span class="gi">+            force=force,</span>
<span class="gi">+            raise_errors=raise_errors,</span>
<span class="gi">+            _parent_namespace_depth=_parent_namespace_depth + 1,</span>
<span class="gi">+            _types_namespace=_types_namespace,</span>
<span class="gi">+        )</span>
<span class="gi">+        return True</span>
<span class="gi">+    except Exception as e:</span>
<span class="gi">+        if raise_errors:</span>
<span class="gi">+            raise</span>
<span class="gi">+        return False</span>


<span class="w"> </span>def is_pydantic_dataclass(class_: type[Any], /) -&gt;TypeGuard[type[
<span class="gu">@@ -105,4 +139,4 @@ def is_pydantic_dataclass(class_: type[Any], /) -&gt;TypeGuard[type[</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        `True` if the class is a pydantic dataclass, `False` otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(class_, type) and hasattr(class_, &#39;__pydantic_dataclass__&#39;)</span>
<span class="gh">diff --git a/pydantic/deprecated/class_validators.py b/pydantic/deprecated/class_validators.py</span>
<span class="gh">index 5ece7422..7b9b98e5 100644</span>
<span class="gd">--- a/pydantic/deprecated/class_validators.py</span>
<span class="gi">+++ b/pydantic/deprecated/class_validators.py</span>
<span class="gu">@@ -100,7 +100,15 @@ def validator(__field: str, *fields: str, pre: bool=False, each_item: bool=</span>
<span class="w"> </span>        Callable: A decorator that can be used to decorate a
<span class="w"> </span>            function to be used as a validator.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if allow_reuse:</span>
<span class="gi">+        warn(_ALLOW_REUSE_WARNING_MESSAGE, DeprecationWarning, stacklevel=2)</span>
<span class="gi">+</span>
<span class="gi">+    def decorator(f: _V1ValidatorType) -&gt; _V1ValidatorType:</span>
<span class="gi">+        _decorators.deprecated_validator(__field, *fields, pre=pre, each_item=each_item,</span>
<span class="gi">+                                         always=always, check_fields=check_fields)(f)</span>
<span class="gi">+        return f</span>
<span class="gi">+</span>
<span class="gi">+    return decorator</span>


<span class="w"> </span>@deprecated(
<span class="gu">@@ -122,4 +130,14 @@ def root_validator(*__args, pre: bool=False, skip_on_failure: bool=False,</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        Any: A decorator that can be used to decorate a function to be used as a root_validator.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if allow_reuse:</span>
<span class="gi">+        warn(_ALLOW_REUSE_WARNING_MESSAGE, DeprecationWarning, stacklevel=2)</span>
<span class="gi">+</span>
<span class="gi">+    def decorator(f: _V1RootValidatorFunctionType) -&gt; _V1RootValidatorFunctionType:</span>
<span class="gi">+        _decorators.deprecated_root_validator(pre=pre, skip_on_failure=skip_on_failure)(f)</span>
<span class="gi">+        return f</span>
<span class="gi">+</span>
<span class="gi">+    # Support using it as `@root_validator` or `@root_validator()`</span>
<span class="gi">+    if __args and callable(__args[0]):</span>
<span class="gi">+        return decorator(__args[0])</span>
<span class="gi">+    return decorator</span>
<span class="gh">diff --git a/pydantic/deprecated/decorator.py b/pydantic/deprecated/decorator.py</span>
<span class="gh">index 6be076d9..b6043a11 100644</span>
<span class="gd">--- a/pydantic/deprecated/decorator.py</span>
<span class="gi">+++ b/pydantic/deprecated/decorator.py</span>
<span class="gu">@@ -23,7 +23,22 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>def validate_arguments(func: Optional[&#39;AnyCallableT&#39;]=None, *, config:
<span class="w"> </span>    &#39;ConfigType&#39;=None) -&gt;Any:
<span class="w"> </span>    &quot;&quot;&quot;Decorator to validate the arguments passed to a function.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(f: AnyCallableT) -&gt; AnyCallableT:</span>
<span class="gi">+        validated_func = ValidatedFunction(f, config)</span>
<span class="gi">+</span>
<span class="gi">+        @wraps(f)</span>
<span class="gi">+        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:</span>
<span class="gi">+            validated_args, validated_kwargs = validated_func.validate(*args, **kwargs)</span>
<span class="gi">+            return f(*validated_args, **validated_kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        wrapper.vd = validated_func  # type: ignore</span>
<span class="gi">+        wrapper.raw_function = f  # type: ignore</span>
<span class="gi">+        wrapper.model = validated_func.model  # type: ignore</span>
<span class="gi">+        return wrapper  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    if func:</span>
<span class="gi">+        return decorator(func)</span>
<span class="gi">+    return decorator</span>


<span class="w"> </span>ALT_V_ARGS = &#39;v__args&#39;
<span class="gu">@@ -87,3 +102,72 @@ class ValidatedFunction:</span>
<span class="w"> </span>        if not takes_kwargs:
<span class="w"> </span>            fields[self.v_kwargs_name] = Dict[Any, Any], None
<span class="w"> </span>        self.create_model(fields, takes_args, takes_kwargs, config)
<span class="gi">+</span>
<span class="gi">+    def create_model(self, fields: Dict[str, Tuple[Any, Any]], takes_args: bool, takes_kwargs: bool, config: &#39;ConfigType&#39;):</span>
<span class="gi">+        class Config:</span>
<span class="gi">+            arbitrary_types_allowed = True</span>
<span class="gi">+            extra = &#39;forbid&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if config is not None:</span>
<span class="gi">+            if not isinstance(config, dict):</span>
<span class="gi">+                config = {k: v for k, v in config.__dict__.items() if not k.startswith(&#39;__&#39;)}</span>
<span class="gi">+            Config = type(&#39;Config&#39;, (), {**Config.__dict__, **config})</span>
<span class="gi">+</span>
<span class="gi">+        class DecoratorBaseModel(BaseModel):</span>
<span class="gi">+            @field_validator(self.v_args_name, self.v_kwargs_name, mode=&#39;before&#39;)</span>
<span class="gi">+            @classmethod</span>
<span class="gi">+            def check_args_kwargs(cls, v: Any, field: &#39;ModelField&#39;) -&gt; Any:</span>
<span class="gi">+                if field.name == self.v_args_name and not takes_args and v:</span>
<span class="gi">+                    raise ValueError(&#39;Function does not take *args&#39;)</span>
<span class="gi">+                if field.name == self.v_kwargs_name and not takes_kwargs and v:</span>
<span class="gi">+                    raise ValueError(&#39;Function does not take **kwargs&#39;)</span>
<span class="gi">+                return v</span>
<span class="gi">+</span>
<span class="gi">+        self.model = create_model(</span>
<span class="gi">+            to_pascal(self.raw_function.__name__),</span>
<span class="gi">+            __config__=Config,</span>
<span class="gi">+            __base__=DecoratorBaseModel,</span>
<span class="gi">+            **fields</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def validate(self, *args: Any, **kwargs: Any) -&gt; Tuple[Tuple[Any, ...], Dict[str, Any]]:</span>
<span class="gi">+        values = self.model(**self.build_values(args, kwargs))</span>
<span class="gi">+        return self.parse_values(values)</span>
<span class="gi">+</span>
<span class="gi">+    def build_values(self, args: Tuple[Any, ...], kwargs: Dict[str, Any]) -&gt; Dict[str, Any]:</span>
<span class="gi">+        values: Dict[str, Any] = {}</span>
<span class="gi">+        v_kwargs = {}</span>
<span class="gi">+</span>
<span class="gi">+        for i, arg in enumerate(args):</span>
<span class="gi">+            name = self.arg_mapping.get(i)</span>
<span class="gi">+            if name:</span>
<span class="gi">+                values[name] = arg</span>
<span class="gi">+            else:</span>
<span class="gi">+                values.setdefault(self.v_args_name, []).append(arg)</span>
<span class="gi">+</span>
<span class="gi">+        for name, value in kwargs.items():</span>
<span class="gi">+            if name in self.model.__fields__:</span>
<span class="gi">+                if name in values:</span>
<span class="gi">+                    values.setdefault(V_DUPLICATE_KWARGS, []).append(name)</span>
<span class="gi">+                values[name] = value</span>
<span class="gi">+            else:</span>
<span class="gi">+                v_kwargs[name] = value</span>
<span class="gi">+</span>
<span class="gi">+        if v_kwargs:</span>
<span class="gi">+            values[self.v_kwargs_name] = v_kwargs</span>
<span class="gi">+</span>
<span class="gi">+        return values</span>
<span class="gi">+</span>
<span class="gi">+    def parse_values(self, values: Any) -&gt; Tuple[Tuple[Any, ...], Dict[str, Any]]:</span>
<span class="gi">+        args = []</span>
<span class="gi">+        kwargs = {}</span>
<span class="gi">+        v_args = values.__dict__.pop(self.v_args_name, ())</span>
<span class="gi">+        v_kwargs = values.__dict__.pop(self.v_kwargs_name, {})</span>
<span class="gi">+</span>
<span class="gi">+        for i, name in self.arg_mapping.items():</span>
<span class="gi">+            if name in self.positional_only_args:</span>
<span class="gi">+                args.append(values.__dict__.get(name))</span>
<span class="gi">+            else:</span>
<span class="gi">+                kwargs[name] = values.__dict__.get(name)</span>
<span class="gi">+</span>
<span class="gi">+        return tuple(args + list(v_args)), {**kwargs, **v_kwargs}</span>
<span class="gh">diff --git a/pydantic/deprecated/json.py b/pydantic/deprecated/json.py</span>
<span class="gh">index 062beef9..aa42f16f 100644</span>
<span class="gd">--- a/pydantic/deprecated/json.py</span>
<span class="gi">+++ b/pydantic/deprecated/json.py</span>
<span class="gu">@@ -33,7 +33,10 @@ def decimal_encoder(dec_value: Decimal) -&gt;Union[int, float]:</span>
<span class="w"> </span>    &gt;&gt;&gt; decimal_encoder(Decimal(&quot;1&quot;))
<span class="w"> </span>    1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if dec_value.as_tuple().exponent == 0:</span>
<span class="gi">+        return int(dec_value)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return float(dec_value)</span>


<span class="w"> </span>ENCODERS_BY_TYPE: Dict[Type[Any], Callable[[Any], Any]] = {bytes: lambda o:
<span class="gu">@@ -49,4 +52,16 @@ ENCODERS_BY_TYPE: Dict[Type[Any], Callable[[Any], Any]] = {bytes: lambda o:</span>
<span class="w"> </span>@deprecated(&#39;`timedelta_isoformat` is deprecated.&#39;, category=None)
<span class="w"> </span>def timedelta_isoformat(td: datetime.timedelta) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;ISO 8601 encoding for Python timedelta object.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    total_seconds = td.total_seconds()</span>
<span class="gi">+    hours, remainder = divmod(total_seconds, 3600)</span>
<span class="gi">+    minutes, seconds = divmod(remainder, 60)</span>
<span class="gi">+    </span>
<span class="gi">+    hours = int(hours)</span>
<span class="gi">+    minutes = int(minutes)</span>
<span class="gi">+    seconds = int(seconds)</span>
<span class="gi">+    microseconds = int((total_seconds - int(total_seconds)) * 1e6)</span>
<span class="gi">+    </span>
<span class="gi">+    if microseconds:</span>
<span class="gi">+        return f&quot;P{hours}H{minutes}M{seconds}.{microseconds:06d}S&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        return f&quot;P{hours}H{minutes}M{seconds}S&quot;</span>
<span class="gh">diff --git a/pydantic/deprecated/tools.py b/pydantic/deprecated/tools.py</span>
<span class="gh">index 8bd38299..2404d50d 100644</span>
<span class="gd">--- a/pydantic/deprecated/tools.py</span>
<span class="gi">+++ b/pydantic/deprecated/tools.py</span>
<span class="gu">@@ -20,7 +20,18 @@ def schema_of(type_: Any, *, title: (NameFactory | None)=None, by_alias:</span>
<span class="w"> </span>    bool=True, ref_template: str=DEFAULT_REF_TEMPLATE, schema_generator:
<span class="w"> </span>    type[GenerateJsonSchema]=GenerateJsonSchema) -&gt;dict[str, Any]:
<span class="w"> </span>    &quot;&quot;&quot;Generate a JSON schema (as dict) for the passed model or dynamically generated one.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        &#39;`schema_of` is deprecated. Use `pydantic.TypeAdapter.json_schema` instead.&#39;,</span>
<span class="gi">+        DeprecationWarning,</span>
<span class="gi">+        stacklevel=2,</span>
<span class="gi">+    )</span>
<span class="gi">+    type_adapter = TypeAdapter(type_)</span>
<span class="gi">+    return type_adapter.json_schema(</span>
<span class="gi">+        by_alias=by_alias,</span>
<span class="gi">+        ref_template=ref_template,</span>
<span class="gi">+        schema_generator=schema_generator,</span>
<span class="gi">+        title=title(type_) if callable(title) else title,</span>
<span class="gi">+    )</span>


<span class="w"> </span>@deprecated(
<span class="gu">@@ -31,4 +42,16 @@ def schema_json_of(type_: Any, *, title: (NameFactory | None)=None,</span>
<span class="w"> </span>    schema_generator: type[GenerateJsonSchema]=GenerateJsonSchema, **
<span class="w"> </span>    dumps_kwargs: Any) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Generate a JSON schema (as JSON) for the passed model or dynamically generated one.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        &#39;`schema_json_of` is deprecated. Use `pydantic.TypeAdapter.json_schema` instead.&#39;,</span>
<span class="gi">+        DeprecationWarning,</span>
<span class="gi">+        stacklevel=2,</span>
<span class="gi">+    )</span>
<span class="gi">+    schema = schema_of(</span>
<span class="gi">+        type_,</span>
<span class="gi">+        title=title,</span>
<span class="gi">+        by_alias=by_alias,</span>
<span class="gi">+        ref_template=ref_template,</span>
<span class="gi">+        schema_generator=schema_generator,</span>
<span class="gi">+    )</span>
<span class="gi">+    return json.dumps(schema, **dumps_kwargs)</span>
<span class="gh">diff --git a/pydantic/errors.py b/pydantic/errors.py</span>
<span class="gh">index 3a0976c3..9ba6e4b3 100644</span>
<span class="gd">--- a/pydantic/errors.py</span>
<span class="gi">+++ b/pydantic/errors.py</span>
<span class="gu">@@ -79,7 +79,15 @@ class PydanticUndefinedAnnotation(PydanticErrorMixin, NameError):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            Converted `PydanticUndefinedAnnotation` error.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        error_message = str(name_error)</span>
<span class="gi">+        match = re.search(r&quot;name &#39;(\w+)&#39; is not defined&quot;, error_message)</span>
<span class="gi">+        if match:</span>
<span class="gi">+            name = match.group(1)</span>
<span class="gi">+            message = f&quot;Annotation &#39;{name}&#39; is not defined.&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            name = &quot;unknown&quot;</span>
<span class="gi">+            message = f&quot;Undefined annotation: {error_message}&quot;</span>
<span class="gi">+        return cls(name=name, message=message)</span>


<span class="w"> </span>class PydanticImportError(PydanticErrorMixin, ImportError):
<span class="gh">diff --git a/pydantic/experimental/pipeline.py b/pydantic/experimental/pipeline.py</span>
<span class="gh">index 253728a3..5da03886 100644</span>
<span class="gd">--- a/pydantic/experimental/pipeline.py</span>
<span class="gi">+++ b/pydantic/experimental/pipeline.py</span>
<span class="gu">@@ -107,7 +107,7 @@ class _Pipeline(Generic[_InT, _OutT]):</span>
<span class="w"> </span>        If used as the first step in a pipeline, the type of the field is used.
<span class="w"> </span>        That is, the transformation is applied to after the value is parsed to the field&#39;s type.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _Pipeline(self._steps + (_Transform(func),))</span>

<span class="w"> </span>    def validate_as(self, tp: (type[_NewOutT] | EllipsisType), *, strict:
<span class="w"> </span>        bool=False) -&gt;_Pipeline[_InT, Any]:
<span class="gu">@@ -118,7 +118,9 @@ class _Pipeline(Generic[_InT, _OutT]):</span>
<span class="w"> </span>        Types are parsed in Pydantic&#39;s `lax` mode by default,
<span class="w"> </span>        but you can enable `strict` mode by passing `strict=True`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if tp is Ellipsis:</span>
<span class="gi">+            tp = _FieldTypeMarker</span>
<span class="gi">+        return _Pipeline(self._steps + (_ValidateAs(tp, strict),))</span>

<span class="w"> </span>    def validate_as_deferred(self, func: Callable[[], type[_NewOutT]]
<span class="w"> </span>        ) -&gt;_Pipeline[_InT, _NewOutT]:
<span class="gu">@@ -127,7 +129,7 @@ class _Pipeline(Generic[_InT, _OutT]):</span>

<span class="w"> </span>        This is useful when you need to reference the class in it&#39;s own type annotations.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _Pipeline(self._steps + (_ValidateAsDefer(func),))</span>

<span class="w"> </span>    def constrain(self, constraint: _ConstraintAnnotation) -&gt;Any:
<span class="w"> </span>        &quot;&quot;&quot;Constrain a value to meet a certain condition.
<span class="gu">@@ -137,73 +139,73 @@ class _Pipeline(Generic[_InT, _OutT]):</span>
<span class="w"> </span>        Most of the time you&#39;ll be calling a shortcut method like `gt`, `lt`, `len`, etc
<span class="w"> </span>        so you don&#39;t need to call this directly.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _Pipeline(self._steps + (_Constraint(constraint),))</span>

<span class="w"> </span>    def predicate(self: _Pipeline[_InT, _NewOutT], func: Callable[[_NewOutT
<span class="w"> </span>        ], bool]) -&gt;_Pipeline[_InT, _NewOutT]:
<span class="w"> </span>        &quot;&quot;&quot;Constrain a value to meet a certain predicate.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.constrain(annotated_types.Predicate(func))</span>

<span class="w"> </span>    def gt(self: _Pipeline[_InT, _NewOutGt], gt: _NewOutGt) -&gt;_Pipeline[
<span class="w"> </span>        _InT, _NewOutGt]:
<span class="w"> </span>        &quot;&quot;&quot;Constrain a value to be greater than a certain value.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.constrain(annotated_types.Gt(gt))</span>

<span class="w"> </span>    def lt(self: _Pipeline[_InT, _NewOutLt], lt: _NewOutLt) -&gt;_Pipeline[
<span class="w"> </span>        _InT, _NewOutLt]:
<span class="w"> </span>        &quot;&quot;&quot;Constrain a value to be less than a certain value.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.constrain(annotated_types.Lt(lt))</span>

<span class="w"> </span>    def ge(self: _Pipeline[_InT, _NewOutGe], ge: _NewOutGe) -&gt;_Pipeline[
<span class="w"> </span>        _InT, _NewOutGe]:
<span class="w"> </span>        &quot;&quot;&quot;Constrain a value to be greater than or equal to a certain value.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.constrain(annotated_types.Ge(ge))</span>

<span class="w"> </span>    def le(self: _Pipeline[_InT, _NewOutLe], le: _NewOutLe) -&gt;_Pipeline[
<span class="w"> </span>        _InT, _NewOutLe]:
<span class="w"> </span>        &quot;&quot;&quot;Constrain a value to be less than or equal to a certain value.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.constrain(annotated_types.Le(le))</span>

<span class="w"> </span>    def len(self: _Pipeline[_InT, _NewOutLen], min_len: int, max_len: (int |
<span class="w"> </span>        None)=None) -&gt;_Pipeline[_InT, _NewOutLen]:
<span class="w"> </span>        &quot;&quot;&quot;Constrain a value to have a certain length.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.constrain(annotated_types.Len(min_len, max_len))</span>

<span class="w"> </span>    def multiple_of(self: _Pipeline[_InT, Any], multiple_of: Any) -&gt;_Pipeline[
<span class="w"> </span>        _InT, Any]:
<span class="w"> </span>        &quot;&quot;&quot;Constrain a value to be a multiple of a certain number.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.constrain(annotated_types.MultipleOf(multiple_of))</span>

<span class="w"> </span>    def eq(self: _Pipeline[_InT, _OutT], value: _OutT) -&gt;_Pipeline[_InT, _OutT
<span class="w"> </span>        ]:
<span class="w"> </span>        &quot;&quot;&quot;Constrain a value to be equal to a certain value.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.constrain(_Eq(value))</span>

<span class="w"> </span>    def not_eq(self: _Pipeline[_InT, _OutT], value: _OutT) -&gt;_Pipeline[_InT,
<span class="w"> </span>        _OutT]:
<span class="w"> </span>        &quot;&quot;&quot;Constrain a value to not be equal to a certain value.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.constrain(_NotEq(value))</span>

<span class="w"> </span>    def in_(self: _Pipeline[_InT, _OutT], values: Container[_OutT]
<span class="w"> </span>        ) -&gt;_Pipeline[_InT, _OutT]:
<span class="w"> </span>        &quot;&quot;&quot;Constrain a value to be in a certain set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.constrain(_In(values))</span>

<span class="w"> </span>    def not_in(self: _Pipeline[_InT, _OutT], values: Container[_OutT]
<span class="w"> </span>        ) -&gt;_Pipeline[_InT, _OutT]:
<span class="w"> </span>        &quot;&quot;&quot;Constrain a value to not be in a certain set.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.constrain(_NotIn(values))</span>

<span class="w"> </span>    def otherwise(self, other: _Pipeline[_OtherIn, _OtherOut]) -&gt;_Pipeline[
<span class="w"> </span>        _InT | _OtherIn, _OutT | _OtherOut]:
<span class="w"> </span>        &quot;&quot;&quot;Combine two validation chains, returning the result of the first chain if it succeeds, and the second chain if it fails.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _Pipeline((_PipelineOr(self, other),))</span>
<span class="w"> </span>    __or__ = otherwise

<span class="w"> </span>    def then(self, other: _Pipeline[_OutT, _OtherOut]) -&gt;_Pipeline[_InT,
<span class="w"> </span>        _OtherOut]:
<span class="w"> </span>        &quot;&quot;&quot;Pipe the result of one validation chain into another.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _Pipeline((_PipelineAnd(self, other),))</span>
<span class="w"> </span>    __and__ = then

<span class="w"> </span>    def __get_pydantic_core_schema__(self, source_type: Any, handler:
<span class="gu">@@ -229,7 +231,29 @@ transform = _Pipeline[Any, Any]((_ValidateAs(_FieldTypeMarker),)).transform</span>
<span class="w"> </span>def _apply_constraint(s: (cs.CoreSchema | None), constraint:
<span class="w"> </span>    _ConstraintAnnotation) -&gt;cs.CoreSchema:
<span class="w"> </span>    &quot;&quot;&quot;Apply a single constraint to a schema.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from pydantic_core import core_schema as cs</span>
<span class="gi">+    </span>
<span class="gi">+    if s is None:</span>
<span class="gi">+        s = cs.any_schema()</span>
<span class="gi">+    </span>
<span class="gi">+    if isinstance(constraint, (annotated_types.Gt, annotated_types.Ge, annotated_types.Lt, annotated_types.Le)):</span>
<span class="gi">+        return cs.with_info_after_validator_function(s, operator.attrgetter(constraint.__class__.__name__.lower())(constraint))</span>
<span class="gi">+    elif isinstance(constraint, annotated_types.MultipleOf):</span>
<span class="gi">+        return cs.with_info_after_validator_function(s, lambda v: v % constraint.multiple_of == 0)</span>
<span class="gi">+    elif isinstance(constraint, annotated_types.Len):</span>
<span class="gi">+        return cs.with_info_after_validator_function(s, lambda v: constraint.min_length &lt;= len(v) &lt;= (constraint.max_length or float(&#39;inf&#39;)))</span>
<span class="gi">+    elif isinstance(constraint, annotated_types.Predicate):</span>
<span class="gi">+        return cs.with_info_after_validator_function(s, constraint.func)</span>
<span class="gi">+    elif isinstance(constraint, (_Eq, _NotEq)):</span>
<span class="gi">+        op = operator.eq if isinstance(constraint, _Eq) else operator.ne</span>
<span class="gi">+        return cs.with_info_after_validator_function(s, lambda v: op(v, constraint.value))</span>
<span class="gi">+    elif isinstance(constraint, (_In, _NotIn)):</span>
<span class="gi">+        op = operator.contains if isinstance(constraint, _In) else lambda c, v: v not in c</span>
<span class="gi">+        return cs.with_info_after_validator_function(s, lambda v: op(constraint.values, v))</span>
<span class="gi">+    elif isinstance(constraint, Pattern):</span>
<span class="gi">+        return cs.with_info_after_validator_function(s, lambda v: bool(constraint.match(v)))</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Unsupported constraint: {constraint}&quot;)</span>


<span class="w"> </span>class _SupportsRange(annotated_types.SupportsLe, annotated_types.SupportsGe,
<span class="gh">diff --git a/pydantic/fields.py b/pydantic/fields.py</span>
<span class="gh">index 6b34290a..2ba54aec 100644</span>
<span class="gd">--- a/pydantic/fields.py</span>
<span class="gi">+++ b/pydantic/fields.py</span>
<span class="gu">@@ -529,7 +529,27 @@ def Field(default: Any=PydanticUndefined, *, default_factory: (typing.</span>
<span class="w"> </span>        A new [`FieldInfo`][pydantic.fields.FieldInfo]. The return annotation is `Any` so `Field` can be used on
<span class="w"> </span>            type-annotated fields without causing a type error.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    field_info_kwargs = {</span>
<span class="gi">+        k: v for k, v in locals().items()</span>
<span class="gi">+        if k not in {&#39;default&#39;, &#39;default_factory&#39;, &#39;extra&#39;} and v is not _Unset</span>
<span class="gi">+    }</span>
<span class="gi">+    if extra:</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;The `extra` kwargs is deprecated. Use `json_schema_extra` instead.&#39;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+            stacklevel=2,</span>
<span class="gi">+        )</span>
<span class="gi">+        if json_schema_extra is _Unset:</span>
<span class="gi">+            field_info_kwargs[&#39;json_schema_extra&#39;] = extra</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&#39;Cannot specify both `extra` and `json_schema_extra`&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if default is not PydanticUndefined:</span>
<span class="gi">+        field_info_kwargs[&#39;default&#39;] = default</span>
<span class="gi">+    if default_factory is not _Unset:</span>
<span class="gi">+        field_info_kwargs[&#39;default_factory&#39;] = default_factory</span>
<span class="gi">+</span>
<span class="gi">+    return FieldInfo(**field_info_kwargs)</span>


<span class="w"> </span>_FIELD_ARG_NAMES = set(inspect.signature(Field).parameters)
<span class="gu">@@ -616,7 +636,13 @@ def PrivateAttr(default: Any=PydanticUndefined, *, default_factory: (typing</span>
<span class="w"> </span>    Raises:
<span class="w"> </span>        ValueError: If both `default` and `default_factory` are set.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if default is not PydanticUndefined and default_factory is not None:</span>
<span class="gi">+        raise ValueError(&#39;cannot specify both default and default_factory&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    if init is not False:</span>
<span class="gi">+        raise ValueError(&#39;init must be False for private attributes&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    return ModelPrivateAttr(default=default, default_factory=default_factory)</span>


<span class="w"> </span>@dataclasses.dataclass(**_internal_dataclass.slots_true)
<span class="gu">@@ -816,4 +842,34 @@ def computed_field(func: (PropertyT | None)=None, /, *, alias: (str | None)</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        A proxy wrapper for the property.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def wrapper(func: PropertyT) -&gt; PropertyT:</span>
<span class="gi">+        if not isinstance(func, (property, cached_property)):</span>
<span class="gi">+            func = property(func)</span>
<span class="gi">+</span>
<span class="gi">+        is_private = _wrapped_property_is_private(func)</span>
<span class="gi">+        if repr is None:</span>
<span class="gi">+            repr_value = not is_private</span>
<span class="gi">+        else:</span>
<span class="gi">+            repr_value = repr</span>
<span class="gi">+</span>
<span class="gi">+        computed_field_info = ComputedFieldInfo(</span>
<span class="gi">+            wrapped_property=func,</span>
<span class="gi">+            return_type=return_type,</span>
<span class="gi">+            alias=alias,</span>
<span class="gi">+            alias_priority=alias_priority,</span>
<span class="gi">+            title=title,</span>
<span class="gi">+            field_title_generator=field_title_generator,</span>
<span class="gi">+            description=description or func.__doc__,</span>
<span class="gi">+            deprecated=deprecated,</span>
<span class="gi">+            examples=examples,</span>
<span class="gi">+            json_schema_extra=json_schema_extra,</span>
<span class="gi">+            repr=repr_value</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        setattr(func, &#39;__computed_field__&#39;, computed_field_info)</span>
<span class="gi">+        return func</span>
<span class="gi">+</span>
<span class="gi">+    if func is None:</span>
<span class="gi">+        return wrapper</span>
<span class="gi">+    else:</span>
<span class="gi">+        return wrapper(func)</span>
<span class="gh">diff --git a/pydantic/functional_serializers.py b/pydantic/functional_serializers.py</span>
<span class="gh">index a588b3b5..ab40f04f 100644</span>
<span class="gd">--- a/pydantic/functional_serializers.py</span>
<span class="gi">+++ b/pydantic/functional_serializers.py</span>
<span class="gu">@@ -233,7 +233,24 @@ def field_serializer(*fields: str, mode: Literal[&#39;plain&#39;, &#39;wrap&#39;]=&#39;plain&#39;,</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The decorator function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(func: Callable[..., Any]) -&gt; Any:</span>
<span class="gi">+        serializer = PlainSerializer(func, return_type, when_used) if mode == &#39;plain&#39; else WrapSerializer(func, return_type, when_used)</span>
<span class="gi">+        </span>
<span class="gi">+        if check_fields is not None:</span>
<span class="gi">+            setattr(serializer, &#39;check_fields&#39;, check_fields)</span>
<span class="gi">+        </span>
<span class="gi">+        if isinstance(func, (classmethod, staticmethod)):</span>
<span class="gi">+            func.__func__.__pydantic_serializer__ = serializer</span>
<span class="gi">+            for field in fields:</span>
<span class="gi">+                func.__func__.__pydantic_serializer_fields__ = getattr(func.__func__, &#39;__pydantic_serializer_fields__&#39;, set()) | {field}</span>
<span class="gi">+        else:</span>
<span class="gi">+            func.__pydantic_serializer__ = serializer</span>
<span class="gi">+            for field in fields:</span>
<span class="gi">+                func.__pydantic_serializer_fields__ = getattr(func, &#39;__pydantic_serializer_fields__&#39;, set()) | {field}</span>
<span class="gi">+        </span>
<span class="gi">+        return func</span>
<span class="gi">+    </span>
<span class="gi">+    return decorator</span>


<span class="w"> </span>FuncType = TypeVar(&#39;FuncType&#39;, bound=Callable[..., Any])
<span class="gu">@@ -284,7 +301,20 @@ def model_serializer(f: (Callable[..., Any] | None)=None, /, *, mode:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The decorator function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(func: Callable[..., Any]) -&gt; Any:</span>
<span class="gi">+        serializer = PlainSerializer(func, return_type, when_used) if mode == &#39;plain&#39; else WrapSerializer(func, return_type, when_used)</span>
<span class="gi">+        </span>
<span class="gi">+        if isinstance(func, (classmethod, staticmethod)):</span>
<span class="gi">+            func.__func__.__pydantic_serializer__ = serializer</span>
<span class="gi">+        else:</span>
<span class="gi">+            func.__pydantic_serializer__ = serializer</span>
<span class="gi">+        </span>
<span class="gi">+        return func</span>
<span class="gi">+    </span>
<span class="gi">+    if f is None:</span>
<span class="gi">+        return decorator</span>
<span class="gi">+    else:</span>
<span class="gi">+        return decorator(f)</span>


<span class="w"> </span>AnyType = TypeVar(&#39;AnyType&#39;)
<span class="gh">diff --git a/pydantic/functional_validators.py b/pydantic/functional_validators.py</span>
<span class="gh">index 92ed2fbb..9c943b5d 100644</span>
<span class="gd">--- a/pydantic/functional_validators.py</span>
<span class="gi">+++ b/pydantic/functional_validators.py</span>
<span class="gu">@@ -317,7 +317,27 @@ def field_validator(field: str, /, *fields: str, mode: FieldValidatorModes=</span>
<span class="w"> </span>            - If the args passed to `@field_validator` as fields are not strings.
<span class="w"> </span>            - If `@field_validator` applied to instance methods.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(f: Any) -&gt; Any:</span>
<span class="gi">+        if isinstance(f, (classmethod, staticmethod)):</span>
<span class="gi">+            f = f.__func__</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(f, FunctionType):</span>
<span class="gi">+            raise PydanticUserError(&quot;@field_validator must be applied to a function&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if not all(isinstance(field, str) for field in (field, *fields)):</span>
<span class="gi">+            raise PydanticUserError(&quot;All field arguments to @field_validator must be strings&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        setattr(f, &#39;_pydantic_validator&#39;, {</span>
<span class="gi">+            &#39;fields&#39;: (field, *fields),</span>
<span class="gi">+            &#39;mode&#39;: mode,</span>
<span class="gi">+            &#39;check_fields&#39;: check_fields</span>
<span class="gi">+        })</span>
<span class="gi">+        return f</span>
<span class="gi">+</span>
<span class="gi">+    if not isinstance(field, str):</span>
<span class="gi">+        raise PydanticUserError(&quot;@field_validator must be called with at least one field name argument&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return decorator</span>


<span class="w"> </span>_ModelType = TypeVar(&#39;_ModelType&#39;)
<span class="gu">@@ -445,7 +465,16 @@ def model_validator(*, mode: Literal[&#39;wrap&#39;, &#39;before&#39;, &#39;after&#39;]) -&gt;Any:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        A decorator that can be used to decorate a function to be used as a model validator.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(f: Any) -&gt; Any:</span>
<span class="gi">+        if not isinstance(f, (FunctionType, classmethod, staticmethod)):</span>
<span class="gi">+            raise PydanticUserError(&quot;@model_validator must be applied to a function or method&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        setattr(f, &#39;_pydantic_model_validator&#39;, {</span>
<span class="gi">+            &#39;mode&#39;: mode,</span>
<span class="gi">+        })</span>
<span class="gi">+        return f</span>
<span class="gi">+</span>
<span class="gi">+    return decorator</span>


<span class="w"> </span>AnyType = TypeVar(&#39;AnyType&#39;)
<span class="gh">diff --git a/pydantic/json_schema.py b/pydantic/json_schema.py</span>
<span class="gh">index 32ba228d..91a71a9e 100644</span>
<span class="gd">--- a/pydantic/json_schema.py</span>
<span class="gi">+++ b/pydantic/json_schema.py</span>
<span class="gu">@@ -1078,7 +1078,9 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>            core_schema: The core schema to get the validations from.
<span class="w"> </span>            mapping: A mapping from core_schema attribute names to the corresponding JSON schema attribute names.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for core_key, json_key in mapping.items():</span>
<span class="gi">+            if core_key in core_schema:</span>
<span class="gi">+                json_schema[json_key] = core_schema[core_key]</span>


<span class="w"> </span>    class ValidationsMapping:
<span class="gu">@@ -1100,7 +1102,21 @@ class GenerateJsonSchema:</span>
<span class="w"> </span>    def get_json_ref_counts(self, json_schema: JsonSchemaValue) -&gt;dict[
<span class="w"> </span>        JsonRef, int]:
<span class="w"> </span>        &quot;&quot;&quot;Get all values corresponding to the key &#39;$ref&#39; anywhere in the json_schema.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        ref_counts: dict[JsonRef, int] = {}</span>
<span class="gi">+</span>
<span class="gi">+        def count_refs(schema: Any) -&gt; None:</span>
<span class="gi">+            if isinstance(schema, dict):</span>
<span class="gi">+                if &#39;$ref&#39; in schema:</span>
<span class="gi">+                    ref = JsonRef(schema[&#39;$ref&#39;])</span>
<span class="gi">+                    ref_counts[ref] = ref_counts.get(ref, 0) + 1</span>
<span class="gi">+                for value in schema.values():</span>
<span class="gi">+                    count_refs(value)</span>
<span class="gi">+            elif isinstance(schema, list):</span>
<span class="gi">+                for item in schema:</span>
<span class="gi">+                    count_refs(item)</span>
<span class="gi">+</span>
<span class="gi">+        count_refs(json_schema)</span>
<span class="gi">+        return ref_counts</span>

<span class="w"> </span>    def emit_warning(self, kind: JsonSchemaWarningKind, detail: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;This method simply emits PydanticJsonSchemaWarnings based on handling in the `warning_message` method.&quot;&quot;&quot;
<span class="gu">@@ -1242,7 +1258,20 @@ class Examples:</span>

<span class="w"> </span>def _get_all_json_refs(item: Any) -&gt;set[JsonRef]:
<span class="w"> </span>    &quot;&quot;&quot;Get all the definitions references from a JSON schema.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    refs = set()</span>
<span class="gi">+</span>
<span class="gi">+    def collect_refs(schema: Any) -&gt; None:</span>
<span class="gi">+        if isinstance(schema, dict):</span>
<span class="gi">+            if &#39;$ref&#39; in schema:</span>
<span class="gi">+                refs.add(JsonRef(schema[&#39;$ref&#39;]))</span>
<span class="gi">+            for value in schema.values():</span>
<span class="gi">+                collect_refs(value)</span>
<span class="gi">+        elif isinstance(schema, list):</span>
<span class="gi">+            for sub_item in schema:</span>
<span class="gi">+                collect_refs(sub_item)</span>
<span class="gi">+</span>
<span class="gi">+    collect_refs(item)</span>
<span class="gi">+    return refs</span>


<span class="w"> </span>AnyType = TypeVar(&#39;AnyType&#39;)
<span class="gh">diff --git a/pydantic/main.py b/pydantic/main.py</span>
<span class="gh">index 0f604ce0..98c4fbd9 100644</span>
<span class="gd">--- a/pydantic/main.py</span>
<span class="gi">+++ b/pydantic/main.py</span>
<span class="gu">@@ -137,7 +137,7 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A dictionary of extra fields, or `None` if `config.extra` is not set to `&quot;allow&quot;`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.__pydantic_extra__ if self.model_config.get(&#39;extra&#39;) == &#39;allow&#39; else None</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def model_fields_set(self) -&gt;set[str]:
<span class="gu">@@ -147,7 +147,7 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):</span>
<span class="w"> </span>            A set of strings representing the fields that have been set,
<span class="w"> </span>                i.e. that were not filled from defaults.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.__pydantic_fields_set__</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def model_construct(cls, _fields_set: (set[str] | None)=None, **values: Any
<span class="gu">@@ -171,7 +171,19 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A new instance of the `Model` class with validated data.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        m = cls.__new__(cls)</span>
<span class="gi">+        fields_values = {}</span>
<span class="gi">+        extra = {}</span>
<span class="gi">+        for name, value in values.items():</span>
<span class="gi">+            if name in cls.model_fields:</span>
<span class="gi">+                fields_values[name] = value</span>
<span class="gi">+            elif cls.model_config.get(&#39;extra&#39;) == &#39;allow&#39;:</span>
<span class="gi">+                extra[name] = value</span>
<span class="gi">+        </span>
<span class="gi">+        _object_setattr(m, &#39;__dict__&#39;, fields_values)</span>
<span class="gi">+        _object_setattr(m, &#39;__pydantic_extra__&#39;, extra or None)</span>
<span class="gi">+        _object_setattr(m, &#39;__pydantic_fields_set__&#39;, _fields_set or set(fields_values.keys()))</span>
<span class="gi">+        return m</span>

<span class="w"> </span>    def model_copy(self, *, update: (dict[str, Any] | None)=None, deep:
<span class="w"> </span>        bool=False) -&gt;Self:
<span class="gu">@@ -187,7 +199,18 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            New model instance.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if deep:</span>
<span class="gi">+            # Perform a deep copy</span>
<span class="gi">+            m = self.__deepcopy__()</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Perform a shallow copy</span>
<span class="gi">+            m = self.__copy__()</span>
<span class="gi">+</span>
<span class="gi">+        if update:</span>
<span class="gi">+            for name, value in update.items():</span>
<span class="gi">+                setattr(m, name, value)</span>
<span class="gi">+</span>
<span class="gi">+        return m</span>

<span class="w"> </span>    def model_dump(self, *, mode: (Literal[&#39;json&#39;, &#39;python&#39;] | str)=
<span class="w"> </span>        &#39;python&#39;, include: IncEx=None, exclude: IncEx=None, context: (Any |
<span class="gu">@@ -218,7 +241,20 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A dictionary representation of the model.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.__pydantic_serializer__.to_python(</span>
<span class="gi">+            self,</span>
<span class="gi">+            mode=mode,</span>
<span class="gi">+            include=include,</span>
<span class="gi">+            exclude=exclude,</span>
<span class="gi">+            context=context,</span>
<span class="gi">+            by_alias=by_alias,</span>
<span class="gi">+            exclude_unset=exclude_unset,</span>
<span class="gi">+            exclude_defaults=exclude_defaults,</span>
<span class="gi">+            exclude_none=exclude_none,</span>
<span class="gi">+            round_trip=round_trip,</span>
<span class="gi">+            warnings=warnings,</span>
<span class="gi">+            serialize_as_any=serialize_as_any,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def model_dump_json(self, *, indent: (int | None)=None, include: IncEx=
<span class="w"> </span>        None, exclude: IncEx=None, context: (Any | None)=None, by_alias:
<span class="gu">@@ -247,7 +283,20 @@ class BaseModel(metaclass=_model_construction.ModelMetaclass):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            A JSON string representation of the model.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.__pydantic_serializer__.to_json(</span>
<span class="gi">+            self,</span>
<span class="gi">+            indent=indent,</span>
<span class="gi">+            include=include,</span>
<span class="gi">+            exclude=exclude,</span>
<span class="gi">+            context=context,</span>
<span class="gi">+            by_alias=by_alias,</span>
<span class="gi">+            exclude_unset=exclude_unset,</span>
<span class="gi">+            exclude_defaults=exclude_defaults,</span>
<span class="gi">+            exclude_none=exclude_none,</span>
<span class="gi">+            round_trip=round_trip,</span>
<span class="gi">+            warnings=warnings,</span>
<span class="gi">+            serialize_as_any=serialize_as_any,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def model_json_schema(cls, by_alias: bool=True, ref_template: str=
<span class="gh">diff --git a/pydantic/mypy.py b/pydantic/mypy.py</span>
<span class="gh">index 03f2edc6..e840f7c2 100644</span>
<span class="gd">--- a/pydantic/mypy.py</span>
<span class="gi">+++ b/pydantic/mypy.py</span>
<span class="gu">@@ -58,7 +58,7 @@ def plugin(version: str) -&gt;type[Plugin]:</span>
<span class="w"> </span>    Return:
<span class="w"> </span>        The Pydantic mypy plugin type.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return PydanticPlugin</span>


<span class="w"> </span>class PydanticPlugin(Plugin):
<span class="gu">@@ -72,22 +72,30 @@ class PydanticPlugin(Plugin):</span>
<span class="w"> </span>    def get_base_class_hook(self, fullname: str) -&gt;(Callable[[
<span class="w"> </span>        ClassDefContext], bool] | None):
<span class="w"> </span>        &quot;&quot;&quot;Update Pydantic model class.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if fullname in (BASEMODEL_FULLNAME, BASESETTINGS_FULLNAME, ROOT_MODEL_FULLNAME):</span>
<span class="gi">+            return self._pydantic_model_class_maker_callback</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def get_metaclass_hook(self, fullname: str) -&gt;(Callable[[
<span class="w"> </span>        ClassDefContext], None] | None):
<span class="w"> </span>        &quot;&quot;&quot;Update Pydantic `ModelMetaclass` definition.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if fullname == MODEL_METACLASS_FULLNAME:</span>
<span class="gi">+            return self._pydantic_model_metaclass_marker_callback</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def get_function_hook(self, fullname: str) -&gt;(Callable[[FunctionContext
<span class="w"> </span>        ], Type] | None):
<span class="w"> </span>        &quot;&quot;&quot;Adjust the return type of the `Field` function.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if fullname == FIELD_FULLNAME:</span>
<span class="gi">+            return self._pydantic_field_callback</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def get_method_hook(self, fullname: str) -&gt;(Callable[[MethodContext],
<span class="w"> </span>        Type] | None):
<span class="w"> </span>        &quot;&quot;&quot;Adjust return type of `from_orm` method call.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if fullname.endswith(&#39;.from_orm&#39;):</span>
<span class="gi">+            return from_attributes_callback</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def get_class_decorator_hook(self, fullname: str) -&gt;(Callable[[
<span class="w"> </span>        ClassDefContext], None] | None):
<span class="gu">@@ -95,14 +103,16 @@ class PydanticPlugin(Plugin):</span>

<span class="w"> </span>        Mypy version 1.1.1 added support for `@dataclass_transform` decorator.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if fullname == DATACLASS_FULLNAME:</span>
<span class="gi">+            return dataclasses.dataclass_class_maker_callback</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def report_config_data(self, ctx: ReportConfigContext) -&gt;dict[str, Any]:
<span class="w"> </span>        &quot;&quot;&quot;Return all plugin config data.

<span class="w"> </span>        Used by mypy to determine if cache needs to be discarded.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._plugin_data</span>

<span class="w"> </span>    def _pydantic_model_metaclass_marker_callback(self, ctx: ClassDefContext
<span class="w"> </span>        ) -&gt;None:
<span class="gu">@@ -111,7 +121,8 @@ class PydanticPlugin(Plugin):</span>
<span class="w"> </span>        Let the plugin handle it. This behavior can be disabled
<span class="w"> </span>        if &#39;debug_dataclass_transform&#39; is set to True&#39;, for testing purposes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.plugin_config.debug_dataclass_transform:</span>
<span class="gi">+            ctx.cls.info.metadata.setdefault(METADATA_KEY, {})[&#39;dataclass_transform_spec&#39;] = None</span>

<span class="w"> </span>    def _pydantic_field_callback(self, ctx: FunctionContext) -&gt;Type:
<span class="w"> </span>        &quot;&quot;&quot;Extract the type of the `default` argument from the Field function, and use it as the return type.
<span class="gu">@@ -121,7 +132,23 @@ class PydanticPlugin(Plugin):</span>
<span class="w"> </span>        * Output an error if both are specified.
<span class="w"> </span>        * Retrieve the type of the argument which is specified, and use it as return type for the function.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        default_arg = ctx.arg_names.index(&#39;default&#39;) if &#39;default&#39; in ctx.arg_names else None</span>
<span class="gi">+        default_factory_arg = ctx.arg_names.index(&#39;default_factory&#39;) if &#39;default_factory&#39; in ctx.arg_names else None</span>
<span class="gi">+</span>
<span class="gi">+        if default_arg is not None and default_factory_arg is not None:</span>
<span class="gi">+            error_default_and_default_factory_specified(ctx.api, ctx.context)</span>
<span class="gi">+            return AnyType(TypeOfAny.from_error)</span>
<span class="gi">+</span>
<span class="gi">+        if default_arg is not None and ctx.args[default_arg] is not None:</span>
<span class="gi">+            default_type = ctx.arg_types[default_arg]</span>
<span class="gi">+            return default_type</span>
<span class="gi">+</span>
<span class="gi">+        if default_factory_arg is not None and ctx.args[default_factory_arg] is not None:</span>
<span class="gi">+            default_factory_type = ctx.arg_types[default_factory_arg]</span>
<span class="gi">+            if isinstance(default_factory_type, CallableType):</span>
<span class="gi">+                return default_factory_type.ret_type</span>
<span class="gi">+</span>
<span class="gi">+        return AnyType(TypeOfAny.implementation_artifact)</span>


<span class="w"> </span>class PydanticPluginConfig:
<span class="gu">@@ -164,12 +191,19 @@ class PydanticPluginConfig:</span>

<span class="w"> </span>    def to_data(self) -&gt;dict[str, Any]:
<span class="w"> </span>        &quot;&quot;&quot;Returns a dict of config names to their values.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {</span>
<span class="gi">+            key: getattr(self, key)</span>
<span class="gi">+            for key in self.__slots__</span>
<span class="gi">+            if hasattr(self, key)</span>
<span class="gi">+        }</span>


<span class="w"> </span>def from_attributes_callback(ctx: MethodContext) -&gt;Type:
<span class="w"> </span>    &quot;&quot;&quot;Raise an error if from_attributes is not enabled.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    model_config = ctx.type.type.metadata.get(METADATA_KEY, {}).get(&#39;config&#39;, {})</span>
<span class="gi">+    if not model_config.get(&#39;from_attributes&#39;):</span>
<span class="gi">+        error_from_attributes(ctx.type.type.name, ctx.api, ctx.context)</span>
<span class="gi">+    return ctx.default_return_type</span>


<span class="w"> </span>class PydanticModelField:
<span class="gh">diff --git a/pydantic/networks.py b/pydantic/networks.py</span>
<span class="gh">index ae44dc9a..8cd8a1e4 100644</span>
<span class="gd">--- a/pydantic/networks.py</span>
<span class="gi">+++ b/pydantic/networks.py</span>
<span class="gu">@@ -574,7 +574,24 @@ def validate_email(value: str) -&gt;tuple[str, str]:</span>
<span class="w"> </span>        * `&quot;John Doe &lt;local_part@domain.com&gt;&quot;` style &quot;pretty&quot; email addresses are processed.
<span class="w"> </span>        * Spaces are striped from the beginning and end of addresses, but no error is raised.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import_email_validator()</span>
<span class="gi">+    </span>
<span class="gi">+    if len(value) &gt; MAX_EMAIL_LENGTH:</span>
<span class="gi">+        raise PydanticCustomError(&#39;email_too_long&#39;, &#39;Email address is too long&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    # Check if it&#39;s a &quot;pretty&quot; email address</span>
<span class="gi">+    match = pretty_email_regex.match(value)</span>
<span class="gi">+    if match:</span>
<span class="gi">+        name, email = match.group(1), match.group(2)</span>
<span class="gi">+    else:</span>
<span class="gi">+        name, email = &#39;&#39;, value.strip()</span>
<span class="gi">+    </span>
<span class="gi">+    try:</span>
<span class="gi">+        email_validator.validate_email(email, check_deliverability=False)</span>
<span class="gi">+    except email_validator.EmailNotValidError as e:</span>
<span class="gi">+        raise PydanticCustomError(&#39;value_error&#39;, str(e))</span>
<span class="gi">+    </span>
<span class="gi">+    return name, email</span>


<span class="w"> </span>__getattr__ = getattr_migration(__name__)
<span class="gh">diff --git a/pydantic/plugin/_loader.py b/pydantic/plugin/_loader.py</span>
<span class="gh">index 9e984adf..4a6cf78c 100644</span>
<span class="gd">--- a/pydantic/plugin/_loader.py</span>
<span class="gi">+++ b/pydantic/plugin/_loader.py</span>
<span class="gu">@@ -10,9 +10,33 @@ _plugins: dict[str, PydanticPluginProtocol] | None = None</span>
<span class="w"> </span>_loading_plugins: bool = False


<span class="gd">-def get_plugins() -&gt;Iterable[PydanticPluginProtocol]:</span>
<span class="gi">+def get_plugins() -&gt; Iterable[PydanticPluginProtocol]:</span>
<span class="w"> </span>    &quot;&quot;&quot;Load plugins for Pydantic.

<span class="w"> </span>    Inspired by: https://github.com/pytest-dev/pluggy/blob/1.3.0/src/pluggy/_manager.py#L376-L402
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _plugins, _loading_plugins</span>
<span class="gi">+</span>
<span class="gi">+    if _plugins is not None:</span>
<span class="gi">+        yield from _plugins.values()</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    if _loading_plugins:</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    _loading_plugins = True</span>
<span class="gi">+    try:</span>
<span class="gi">+        _plugins = {}</span>
<span class="gi">+        for entry_point in importlib_metadata.entry_points(group=PYDANTIC_ENTRY_POINT_GROUP):</span>
<span class="gi">+            try:</span>
<span class="gi">+                plugin = entry_point.load()</span>
<span class="gi">+                if not isinstance(plugin, PydanticPluginProtocol):</span>
<span class="gi">+                    warnings.warn(f&quot;Plugin {entry_point.name} does not implement PydanticPluginProtocol&quot;)</span>
<span class="gi">+                    continue</span>
<span class="gi">+                _plugins[entry_point.name] = plugin</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                warnings.warn(f&quot;Error loading plugin {entry_point.name}: {e}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        yield from _plugins.values()</span>
<span class="gi">+    finally:</span>
<span class="gi">+        _loading_plugins = False</span>
<span class="gh">diff --git a/pydantic/plugin/_schema_validator.py b/pydantic/plugin/_schema_validator.py</span>
<span class="gh">index cc46fbe1..cb83e084 100644</span>
<span class="gd">--- a/pydantic/plugin/_schema_validator.py</span>
<span class="gi">+++ b/pydantic/plugin/_schema_validator.py</span>
<span class="gu">@@ -22,7 +22,14 @@ def create_schema_validator(schema: CoreSchema, schema_type: Any,</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        If plugins are installed then return `PluggableSchemaValidator`, otherwise return `SchemaValidator`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from pydantic.plugin import get_plugins</span>
<span class="gi">+</span>
<span class="gi">+    plugins = list(get_plugins())</span>
<span class="gi">+    if plugins:</span>
<span class="gi">+        schema_type_path = SchemaTypePath(schema_type_module, schema_type_name)</span>
<span class="gi">+        return PluggableSchemaValidator(schema, schema_type, schema_type_path, schema_kind, config, plugins, plugin_settings or {})</span>
<span class="gi">+    else:</span>
<span class="gi">+        return SchemaValidator(schema, config)</span>


<span class="w"> </span>class PluggableSchemaValidator:
<span class="gu">@@ -68,4 +75,7 @@ def filter_handlers(handler_cls: BaseValidateHandlerProtocol, method_name: str</span>
<span class="w"> </span>    &quot;&quot;&quot;Filter out handler methods which are not implemented by the plugin directly - e.g. are missing
<span class="w"> </span>    or are inherited from the protocol.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    method = getattr(handler_cls, method_name, None)</span>
<span class="gi">+    if method is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+    return method.__module__ != &#39;typing&#39; and method.__module__ != BaseValidateHandlerProtocol.__module__</span>
<span class="gh">diff --git a/pydantic/root_model.py b/pydantic/root_model.py</span>
<span class="gh">index 199c196d..cfaa17ce 100644</span>
<span class="gd">--- a/pydantic/root_model.py</span>
<span class="gi">+++ b/pydantic/root_model.py</span>
<span class="gu">@@ -76,7 +76,13 @@ class RootModel(BaseModel, typing.Generic[RootModelRootType], metaclass=</span>
<span class="w"> </span>        Raises:
<span class="w"> </span>            NotImplemented: If the model is not a subclass of `RootModel`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        m = cls.__new__(cls)</span>
<span class="gi">+        fields_values = {&#39;root&#39;: root}</span>
<span class="gi">+        _object_setattr(m, &#39;__dict__&#39;, fields_values)</span>
<span class="gi">+        if _fields_set is None:</span>
<span class="gi">+            _fields_set = {&#39;root&#39;}</span>
<span class="gi">+        _object_setattr(m, &#39;__pydantic_fields_set__&#39;, _fields_set)</span>
<span class="gi">+        return m</span>

<span class="w"> </span>    def __getstate__(self) -&gt;dict[Any, Any]:
<span class="w"> </span>        return {&#39;__dict__&#39;: self.__dict__, &#39;__pydantic_fields_set__&#39;: self.
<span class="gu">@@ -123,7 +129,19 @@ class RootModel(BaseModel, typing.Generic[RootModelRootType], metaclass=</span>
<span class="w"> </span>            even be something different, in the case of a custom serializer.
<span class="w"> </span>            Thus, `Any` is used here to catch all of these cases.
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            return super().model_dump(</span>
<span class="gi">+                mode=mode,</span>
<span class="gi">+                include=include,</span>
<span class="gi">+                exclude=exclude,</span>
<span class="gi">+                context=context,</span>
<span class="gi">+                by_alias=by_alias,</span>
<span class="gi">+                exclude_unset=exclude_unset,</span>
<span class="gi">+                exclude_defaults=exclude_defaults,</span>
<span class="gi">+                exclude_none=exclude_none,</span>
<span class="gi">+                round_trip=round_trip,</span>
<span class="gi">+                warnings=warnings,</span>
<span class="gi">+                serialize_as_any=serialize_as_any</span>
<span class="gi">+            )</span>

<span class="w"> </span>    def __eq__(self, other: Any) -&gt;bool:
<span class="w"> </span>        if not isinstance(other, RootModel):
<span class="gh">diff --git a/pydantic/type_adapter.py b/pydantic/type_adapter.py</span>
<span class="gh">index fc7ff2ab..d69d3b3d 100644</span>
<span class="gd">--- a/pydantic/type_adapter.py</span>
<span class="gi">+++ b/pydantic/type_adapter.py</span>
<span class="gu">@@ -66,17 +66,24 @@ def _get_schema(type_: Any, config_wrapper: _config.ConfigWrapper,</span>

<span class="w"> </span>    But at the very least this behavior is _subtly_ different from `BaseModel`&#39;s.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    local_ns = _typing_extra.get_globals_from_frame(sys._getframe(parent_depth))</span>
<span class="gi">+    return _generate_schema(type_, config_wrapper, _module_name=local_ns.get(&#39;__name__&#39;, &#39;&#39;), _parent_frame_globals=local_ns)</span>


<span class="w"> </span>def _getattr_no_parents(obj: Any, attribute: str) -&gt;Any:
<span class="w"> </span>    &quot;&quot;&quot;Returns the attribute value without attempting to look up attributes from parent types.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if hasattr(obj, &#39;__dict__&#39;):</span>
<span class="gi">+        return obj.__dict__.get(attribute)</span>
<span class="gi">+    return getattr(obj, attribute)</span>


<span class="w"> </span>def _type_has_config(type_: Any) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;Returns whether the type has config.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (</span>
<span class="gi">+        (isinstance(type_, type) and issubclass(type_, BaseModel))</span>
<span class="gi">+        or is_dataclass(type_)</span>
<span class="gi">+        or is_typeddict(type_)</span>
<span class="gi">+    )</span>


<span class="w"> </span>@final
<span class="gu">@@ -172,19 +179,25 @@ class TypeAdapter(Generic[T]):</span>
<span class="w"> </span>    @_frame_depth(2)
<span class="w"> </span>    def core_schema(self) -&gt;CoreSchema:
<span class="w"> </span>        &quot;&quot;&quot;The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._core_schema is None:</span>
<span class="gi">+            self._init_core_attrs(rebuild_mocks=True)</span>
<span class="gi">+        return self._core_schema</span>

<span class="w"> </span>    @cached_property
<span class="w"> </span>    @_frame_depth(2)
<span class="w"> </span>    def validator(self) -&gt;(SchemaValidator | PluggableSchemaValidator):
<span class="w"> </span>        &quot;&quot;&quot;The pydantic-core SchemaValidator used to validate instances of the model.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._validator is None:</span>
<span class="gi">+            self._init_core_attrs(rebuild_mocks=True)</span>
<span class="gi">+        return self._validator</span>

<span class="w"> </span>    @cached_property
<span class="w"> </span>    @_frame_depth(2)
<span class="w"> </span>    def serializer(self) -&gt;SchemaSerializer:
<span class="w"> </span>        &quot;&quot;&quot;The pydantic-core SchemaSerializer used to dump instances of the model.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if self._serializer is None:</span>
<span class="gi">+            self._init_core_attrs(rebuild_mocks=True)</span>
<span class="gi">+        return self._serializer</span>

<span class="w"> </span>    @_frame_depth(1)
<span class="w"> </span>    def validate_python(self, object: Any, /, *, strict: (bool | None)=None,
<span class="gu">@@ -205,7 +218,12 @@ class TypeAdapter(Generic[T]):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The validated object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.validator.validate_python(</span>
<span class="gi">+            object,</span>
<span class="gi">+            strict=strict,</span>
<span class="gi">+            from_attributes=from_attributes,</span>
<span class="gi">+            context=context,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @_frame_depth(1)
<span class="w"> </span>    def validate_json(self, data: (str | bytes), /, *, strict: (bool | None
<span class="gu">@@ -222,7 +240,11 @@ class TypeAdapter(Generic[T]):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The validated object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.validator.validate_json(</span>
<span class="gi">+            data,</span>
<span class="gi">+            strict=strict,</span>
<span class="gi">+            context=context,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @_frame_depth(1)
<span class="w"> </span>    def validate_strings(self, obj: Any, /, *, strict: (bool | None)=None,
<span class="gu">@@ -237,7 +259,11 @@ class TypeAdapter(Generic[T]):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The validated object.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.validator.validate_strings(</span>
<span class="gi">+            obj,</span>
<span class="gi">+            strict=strict,</span>
<span class="gi">+            context=context,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @_frame_depth(1)
<span class="w"> </span>    def get_default_value(self, *, strict: (bool | None)=None, context: (
<span class="gu">@@ -251,7 +277,10 @@ class TypeAdapter(Generic[T]):</span>
<span class="w"> </span>        Returns:
<span class="w"> </span>            The default value wrapped in a `Some` if there is one or None if not.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self.validator.get_default_value(</span>
<span class="gi">+            strict=strict,</span>
<span class="gi">+            context=context,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @_frame_depth(1)
<span class="w"> </span>    def dump_python(self, instance: T, /, *, mode: Literal[&#39;json&#39;, &#39;python&#39;
<span class="gh">diff --git a/pydantic/v1/annotated_types.py b/pydantic/v1/annotated_types.py</span>
<span class="gh">index 06d15ea9..dd0abb29 100644</span>
<span class="gd">--- a/pydantic/v1/annotated_types.py</span>
<span class="gi">+++ b/pydantic/v1/annotated_types.py</span>
<span class="gu">@@ -15,7 +15,21 @@ def create_model_from_typeddict(typeddict_cls: Type[&#39;TypedDict&#39;], **kwargs: Any</span>
<span class="w"> </span>    Since `typing.TypedDict` in Python 3.8 does not store runtime information about optional keys,
<span class="w"> </span>    we raise an error if this happens (see https://bugs.python.org/issue38834).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not is_typeddict(typeddict_cls) and not is_typeddict_special(typeddict_cls):</span>
<span class="gi">+        raise TypeError(f&#39;{typeddict_cls} is not a TypedDict&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    fields = getattr(typeddict_cls, &#39;__annotations__&#39;, {})</span>
<span class="gi">+    defaults = getattr(typeddict_cls, &#39;__total__&#39;, True)</span>
<span class="gi">+</span>
<span class="gi">+    model_fields = {}</span>
<span class="gi">+    for field_name, field_type in fields.items():</span>
<span class="gi">+        if defaults:</span>
<span class="gi">+            model_fields[field_name] = (field_type, Required)</span>
<span class="gi">+        else:</span>
<span class="gi">+            model_fields[field_name] = (field_type, ...)</span>
<span class="gi">+</span>
<span class="gi">+    model_name = typeddict_cls.__name__</span>
<span class="gi">+    return create_model(model_name, **model_fields, **kwargs)</span>


<span class="w"> </span>def create_model_from_namedtuple(namedtuple_cls: Type[&#39;NamedTuple&#39;], **
<span class="gu">@@ -26,4 +40,19 @@ def create_model_from_namedtuple(namedtuple_cls: Type[&#39;NamedTuple&#39;], **</span>
<span class="w"> </span>    but also with `collections.namedtuple`, in this case we consider all fields
<span class="w"> </span>    to have type `Any`.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not issubclass(namedtuple_cls, tuple) or not hasattr(namedtuple_cls, &#39;_fields&#39;):</span>
<span class="gi">+        raise TypeError(f&#39;{namedtuple_cls} is not a NamedTuple&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    fields = getattr(namedtuple_cls, &#39;__annotations__&#39;, {})</span>
<span class="gi">+    default_values = namedtuple_cls._field_defaults</span>
<span class="gi">+</span>
<span class="gi">+    model_fields = {}</span>
<span class="gi">+    for field_name in namedtuple_cls._fields:</span>
<span class="gi">+        field_type = fields.get(field_name, Any)</span>
<span class="gi">+        if field_name in default_values:</span>
<span class="gi">+            model_fields[field_name] = (field_type, default_values[field_name])</span>
<span class="gi">+        else:</span>
<span class="gi">+            model_fields[field_name] = (field_type, Required)</span>
<span class="gi">+</span>
<span class="gi">+    model_name = namedtuple_cls.__name__</span>
<span class="gi">+    return create_model(model_name, **model_fields, **kwargs)</span>
<span class="gh">diff --git a/pydantic/v1/class_validators.py b/pydantic/v1/class_validators.py</span>
<span class="gh">index c7c09f7c..63efa606 100644</span>
<span class="gd">--- a/pydantic/v1/class_validators.py</span>
<span class="gi">+++ b/pydantic/v1/class_validators.py</span>
<span class="gu">@@ -53,7 +53,25 @@ def validator(*fields: str, pre: bool=False, each_item: bool=False, always:</span>
<span class="w"> </span>    :param check_fields: whether to check that the fields actually exist on the model
<span class="w"> </span>    :param allow_reuse: whether to track and raise an error if another validator refers to the decorated function
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if whole is not None:</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &#39;The &quot;whole&quot; keyword argument is deprecated, use &quot;each_item&quot; instead&#39;,</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+        )</span>
<span class="gi">+        each_item = not whole</span>
<span class="gi">+</span>
<span class="gi">+    def dec(f):</span>
<span class="gi">+        f_cls = _prepare_validator(f, allow_reuse)</span>
<span class="gi">+        setattr(f_cls, VALIDATOR_CONFIG_KEY, {</span>
<span class="gi">+            &#39;fields&#39;: fields,</span>
<span class="gi">+            &#39;pre&#39;: pre,</span>
<span class="gi">+            &#39;each_item&#39;: each_item,</span>
<span class="gi">+            &#39;always&#39;: always,</span>
<span class="gi">+            &#39;check_fields&#39;: check_fields,</span>
<span class="gi">+        })</span>
<span class="gi">+        return f_cls</span>
<span class="gi">+</span>
<span class="gi">+    return dec</span>


<span class="w"> </span>def root_validator(_func: Optional[AnyCallable]=None, *, pre: bool=False,
<span class="gu">@@ -63,7 +81,18 @@ def root_validator(_func: Optional[AnyCallable]=None, *, pre: bool=False,</span>
<span class="w"> </span>    Decorate methods on a model indicating that they should be used to validate (and perhaps modify) data either
<span class="w"> </span>    before or after standard model parsing/validation is performed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def dec(f):</span>
<span class="gi">+        f_cls = _prepare_validator(f, allow_reuse)</span>
<span class="gi">+        setattr(f_cls, ROOT_VALIDATOR_CONFIG_KEY, {</span>
<span class="gi">+            &#39;pre&#39;: pre,</span>
<span class="gi">+            &#39;skip_on_failure&#39;: skip_on_failure,</span>
<span class="gi">+        })</span>
<span class="gi">+        return f_cls</span>
<span class="gi">+</span>
<span class="gi">+    if _func is None:</span>
<span class="gi">+        return dec</span>
<span class="gi">+    else:</span>
<span class="gi">+        return dec(_func)</span>


<span class="w"> </span>def _prepare_validator(function: AnyCallable, allow_reuse: bool
<span class="gu">@@ -72,7 +101,12 @@ def _prepare_validator(function: AnyCallable, allow_reuse: bool</span>
<span class="w"> </span>    Avoid validators with duplicated names since without this, validators can be overwritten silently
<span class="w"> </span>    which generally isn&#39;t the intended behaviour, don&#39;t run in ipython (see #312) or if allow_reuse is False.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not allow_reuse and not in_ipython():</span>
<span class="gi">+        function_name = function.__name__</span>
<span class="gi">+        if function_name in _FUNCS:</span>
<span class="gi">+            raise ConfigError(f&#39;duplicate validator function &quot;{function_name}&quot;&#39;)</span>
<span class="gi">+        _FUNCS.add(function_name)</span>
<span class="gi">+    return classmethod(function)</span>


<span class="w"> </span>class ValidatorGroup:
<span class="gu">@@ -92,7 +126,28 @@ def make_generic_validator(validator: AnyCallable) -&gt;&#39;ValidatorCallable&#39;:</span>
<span class="w"> </span>    It&#39;s done like this so validators don&#39;t all need **kwargs in their signature, eg. any combination of
<span class="w"> </span>    the arguments &quot;values&quot;, &quot;fields&quot; and/or &quot;config&quot; are permitted.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    signature = Signature.from_callable(validator)</span>
<span class="gi">+    param_names = list(signature.parameters.keys())</span>
<span class="gi">+    if param_names == [&#39;cls&#39;]:</span>
<span class="gi">+        return validator</span>
<span class="gi">+    </span>
<span class="gi">+    kwarg_names = set(param_names) &amp; all_kwargs</span>
<span class="gi">+    </span>
<span class="gi">+    @wraps(validator)</span>
<span class="gi">+    def wrapper(cls: Optional[ModelOrDc], v: Any, values: Dict[str, Any],</span>
<span class="gi">+                field: ModelField, config: Type[BaseConfig]) -&gt; Any:</span>
<span class="gi">+        kwargs = {}</span>
<span class="gi">+        if &#39;v&#39; in param_names:</span>
<span class="gi">+            kwargs[&#39;v&#39;] = v</span>
<span class="gi">+        if &#39;values&#39; in kwarg_names:</span>
<span class="gi">+            kwargs[&#39;values&#39;] = values</span>
<span class="gi">+        if &#39;field&#39; in kwarg_names:</span>
<span class="gi">+            kwargs[&#39;field&#39;] = field</span>
<span class="gi">+        if &#39;config&#39; in kwarg_names:</span>
<span class="gi">+            kwargs[&#39;config&#39;] = config</span>
<span class="gi">+        return validator(cls, **kwargs)</span>
<span class="gi">+    </span>
<span class="gi">+    return wrapper</span>


<span class="w"> </span>all_kwargs = {&#39;values&#39;, &#39;field&#39;, &#39;config&#39;}
<span class="gh">diff --git a/pydantic/v1/color.py b/pydantic/v1/color.py</span>
<span class="gh">index 021245ab..682b4d09 100644</span>
<span class="gd">--- a/pydantic/v1/color.py</span>
<span class="gi">+++ b/pydantic/v1/color.py</span>
<span class="gu">@@ -84,20 +84,26 @@ class Color(Representation):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Original value passed to Color
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._original</span>

<span class="w"> </span>    def as_hex(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Hex string representing the color can be 3, 4, 6 or 8 characters depending on whether the string
<span class="w"> </span>        a &quot;short&quot; representation of the color is possible and whether there&#39;s an alpha channel.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rgba = self._rgba</span>
<span class="gi">+        if rgba.alpha is None:</span>
<span class="gi">+            return f&#39;#{int(rgba.r):02x}{int(rgba.g):02x}{int(rgba.b):02x}&#39;</span>
<span class="gi">+        return f&#39;#{int(rgba.r):02x}{int(rgba.g):02x}{int(rgba.b):02x}{int(rgba.alpha * 255):02x}&#39;</span>

<span class="w"> </span>    def as_rgb(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Color as an rgb(&lt;r&gt;, &lt;g&gt;, &lt;b&gt;) or rgba(&lt;r&gt;, &lt;g&gt;, &lt;b&gt;, &lt;a&gt;) string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rgba = self._rgba</span>
<span class="gi">+        if rgba.alpha is None:</span>
<span class="gi">+            return f&#39;rgb({int(rgba.r)}, {int(rgba.g)}, {int(rgba.b)})&#39;</span>
<span class="gi">+        return f&#39;rgba({int(rgba.r)}, {int(rgba.g)}, {int(rgba.b)}, {rgba.alpha:.2f})&#39;</span>

<span class="w"> </span>    def as_rgb_tuple(self, *, alpha: Optional[bool]=None) -&gt;ColorTuple:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -109,13 +115,19 @@ class Color(Representation):</span>
<span class="w"> </span>          True - always include alpha,
<span class="w"> </span>          False - always omit alpha,
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rgba = self._rgba</span>
<span class="gi">+        if alpha is False or (alpha is None and rgba.alpha is None):</span>
<span class="gi">+            return (int(rgba.r), int(rgba.g), int(rgba.b))</span>
<span class="gi">+        return (int(rgba.r), int(rgba.g), int(rgba.b), rgba.alpha if rgba.alpha is not None else 1.0)</span>

<span class="w"> </span>    def as_hsl(self) -&gt;str:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Color as an hsl(&lt;h&gt;, &lt;s&gt;, &lt;l&gt;) or hsl(&lt;h&gt;, &lt;s&gt;, &lt;l&gt;, &lt;a&gt;) string.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        h, s, l, a = self.as_hsl_tuple(alpha=True)</span>
<span class="gi">+        if a == 1:</span>
<span class="gi">+            return f&#39;hsl({h:.0f}, {s:.0%}, {l:.0%})&#39;</span>
<span class="gi">+        return f&#39;hsla({h:.0f}, {s:.0%}, {l:.0%}, {a:.2f})&#39;</span>

<span class="w"> </span>    def as_hsl_tuple(self, *, alpha: Optional[bool]=None) -&gt;HslColorTuple:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -129,7 +141,12 @@ class Color(Representation):</span>
<span class="w"> </span>          True - always include alpha,
<span class="w"> </span>          False - always omit alpha,
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        rgba = self._rgba</span>
<span class="gi">+        h, l, s = rgb_to_hls(rgba.r / 255, rgba.g / 255, rgba.b / 255)</span>
<span class="gi">+        hsl = (h * 360 % 360, s, l)</span>
<span class="gi">+        if alpha is False or (alpha is None and rgba.alpha is None):</span>
<span class="gi">+            return hsl</span>
<span class="gi">+        return (*hsl, rgba.alpha if rgba.alpha is not None else 1.0)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:
<span class="gu">@@ -154,7 +171,13 @@ def parse_tuple(value: Tuple[Any, ...]) -&gt;RGBA:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Parse a tuple or list as a color.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if len(value) == 3:</span>
<span class="gi">+        r, g, b = value</span>
<span class="gi">+        return RGBA(parse_color_value(r), parse_color_value(g), parse_color_value(b), None)</span>
<span class="gi">+    elif len(value) == 4:</span>
<span class="gi">+        r, g, b, a = value</span>
<span class="gi">+        return RGBA(parse_color_value(r), parse_color_value(g), parse_color_value(b), parse_float_alpha(a))</span>
<span class="gi">+    raise ColorError(reason=&#39;tuple must have 3 or 4 elements&#39;)</span>


<span class="w"> </span>def parse_str(value: str) -&gt;RGBA:
<span class="gu">@@ -166,7 +189,42 @@ def parse_str(value: str) -&gt;RGBA:</span>
<span class="w"> </span>    * `rgb(&lt;r&gt;, &lt;g&gt;, &lt;b&gt;) `
<span class="w"> </span>    * `rgba(&lt;r&gt;, &lt;g&gt;, &lt;b&gt;, &lt;a&gt;)`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    value = value.lower().strip()</span>
<span class="gi">+    if value in COLORS_BY_NAME:</span>
<span class="gi">+        return RGBA(*[v / 255 for v in COLORS_BY_NAME[value]], None)</span>
<span class="gi">+</span>
<span class="gi">+    m = re.match(r_hex_short, value, re.I)</span>
<span class="gi">+    if m:</span>
<span class="gi">+        *rgb, a = m.groups()</span>
<span class="gi">+        rgb = [int(c * 2, 16) / 255 for c in rgb]</span>
<span class="gi">+        return RGBA(*rgb, parse_float_alpha(int(a * 2, 16) / 255) if a else None)</span>
<span class="gi">+</span>
<span class="gi">+    m = re.match(r_hex_long, value, re.I)</span>
<span class="gi">+    if m:</span>
<span class="gi">+        *rgb, a = m.groups()</span>
<span class="gi">+        rgb = [int(c, 16) / 255 for c in rgb]</span>
<span class="gi">+        return RGBA(*rgb, parse_float_alpha(int(a, 16) / 255) if a else None)</span>
<span class="gi">+</span>
<span class="gi">+    m = re.match(r_rgb, value, re.I)</span>
<span class="gi">+    if m:</span>
<span class="gi">+        return RGBA(*[parse_color_value(v) / 255 for v in m.groups()], None)</span>
<span class="gi">+</span>
<span class="gi">+    m = re.match(r_rgba, value, re.I)</span>
<span class="gi">+    if m:</span>
<span class="gi">+        *rgb, a = m.groups()</span>
<span class="gi">+        return RGBA(*[parse_color_value(v) / 255 for v in rgb], parse_float_alpha(a))</span>
<span class="gi">+</span>
<span class="gi">+    m = re.match(r_hsl, value, re.I)</span>
<span class="gi">+    if m:</span>
<span class="gi">+        h, h_units, s, l = m.groups()</span>
<span class="gi">+        return parse_hsl(h, h_units, s, l)</span>
<span class="gi">+</span>
<span class="gi">+    m = re.match(r_hsla, value, re.I)</span>
<span class="gi">+    if m:</span>
<span class="gi">+        h, h_units, s, l, a = m.groups()</span>
<span class="gi">+        return parse_hsl(h, h_units, s, l, parse_float_alpha(a))</span>
<span class="gi">+</span>
<span class="gi">+    raise ColorError(reason=&#39;invalid color string&#39;)</span>


<span class="w"> </span>def parse_color_value(value: Union[int, str], max_val: int=255) -&gt;float:
<span class="gu">@@ -174,14 +232,33 @@ def parse_color_value(value: Union[int, str], max_val: int=255) -&gt;float:</span>
<span class="w"> </span>    Parse a value checking it&#39;s a valid int in the range 0 to max_val and divide by max_val to give a number
<span class="w"> </span>    in the range 0 to 1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        color = float(value)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise ColorError(reason=f&#39;invalid color value: {value}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if 0 &lt;= color &lt;= max_val:</span>
<span class="gi">+        return color / max_val</span>
<span class="gi">+    raise ColorError(reason=f&#39;color value must be in the range 0 to {max_val}&#39;)</span>


<span class="w"> </span>def parse_float_alpha(value: Union[None, str, float, int]) -&gt;Optional[float]:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Parse a value checking it&#39;s a valid float in the range 0 to 1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    try:</span>
<span class="gi">+        if isinstance(value, str) and value.endswith(&#39;%&#39;):</span>
<span class="gi">+            alpha = float(value[:-1]) / 100</span>
<span class="gi">+        else:</span>
<span class="gi">+            alpha = float(value)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise ColorError(reason=f&#39;invalid alpha value: {value}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if 0 &lt;= alpha &lt;= 1:</span>
<span class="gi">+        return alpha</span>
<span class="gi">+    raise ColorError(reason=&#39;alpha value must be in the range 0 to 1&#39;)</span>


<span class="w"> </span>def parse_hsl(h: str, h_units: str, sat: str, light: str, alpha: Optional[
<span class="gu">@@ -189,7 +266,24 @@ def parse_hsl(h: str, h_units: str, sat: str, light: str, alpha: Optional[</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Parse raw hue, saturation, lightness and alpha values and convert to RGBA.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        h = float(h)</span>
<span class="gi">+        s = float(sat.rstrip(&#39;%&#39;)) / 100</span>
<span class="gi">+        l = float(light.rstrip(&#39;%&#39;)) / 100</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise ColorError(reason=&#39;invalid hsl string&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    if h_units == &#39;deg&#39;:</span>
<span class="gi">+        h = h % 360 / 360</span>
<span class="gi">+    elif h_units == &#39;rad&#39;:</span>
<span class="gi">+        h = h % rads / rads</span>
<span class="gi">+    elif h_units == &#39;turn&#39;:</span>
<span class="gi">+        h = h % 1</span>
<span class="gi">+    else:</span>
<span class="gi">+        h = h % 360 / 360</span>
<span class="gi">+</span>
<span class="gi">+    r, g, b = hls_to_rgb(h, l, s)</span>
<span class="gi">+    return RGBA(r, g, b, alpha)</span>


<span class="w"> </span>COLORS_BY_NAME = {&#39;aliceblue&#39;: (240, 248, 255), &#39;antiquewhite&#39;: (250, 235, 
<span class="gh">diff --git a/pydantic/v1/config.py b/pydantic/v1/config.py</span>
<span class="gh">index 5c249595..b18461c1 100644</span>
<span class="gd">--- a/pydantic/v1/config.py</span>
<span class="gi">+++ b/pydantic/v1/config.py</span>
<span class="gu">@@ -107,11 +107,15 @@ class BaseConfig:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Get properties of FieldInfo from the `fields` property of the config class.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        field_info = cls.fields.get(name, {})</span>
<span class="gi">+        if isinstance(field_info, str):</span>
<span class="gi">+            field_info = {&#39;alias&#39;: field_info}</span>
<span class="gi">+        return field_info</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def prepare_field(cls, field: &#39;ModelField&#39;) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Optional hook to check or modify fields during model creation.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if cls.alias_generator and not field.has_alias:</span>
<span class="gi">+            field.alias = cls.alias_generator(field.name)</span>
<span class="gh">diff --git a/pydantic/v1/dataclasses.py b/pydantic/v1/dataclasses.py</span>
<span class="gh">index 91caa9b0..4d39a6ac 100644</span>
<span class="gd">--- a/pydantic/v1/dataclasses.py</span>
<span class="gi">+++ b/pydantic/v1/dataclasses.py</span>
<span class="gu">@@ -97,7 +97,19 @@ def dataclass(_cls: Optional[Type[_T]]=None, *, init: bool=True, repr: bool</span>
<span class="w"> </span>    or a wrapper that will trigger validation around a stdlib dataclass
<span class="w"> </span>    to avoid modifying it directly
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def wrap(cls: Type[_T]) -&gt; &#39;DataclassClassOrWrapper&#39;:</span>
<span class="gi">+        if is_builtin_dataclass(cls):</span>
<span class="gi">+            if use_proxy is not False:</span>
<span class="gi">+                return DataclassProxy(cls)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return create_pydantic_model_from_dataclass(cls, config, validate_on_init)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return _process_class(cls, init, repr, eq, order, unsafe_hash, frozen,</span>
<span class="gi">+                                  config, validate_on_init, kw_only=kw_only)</span>
<span class="gi">+</span>
<span class="gi">+    if _cls is None:</span>
<span class="gi">+        return wrap</span>
<span class="gi">+    return wrap(_cls)</span>


<span class="w"> </span>class DataclassProxy:
<span class="gu">@@ -133,7 +145,33 @@ def _add_pydantic_validation_attributes(dc_cls: Type[&#39;Dataclass&#39;], config:</span>
<span class="w"> </span>    it won&#39;t even exist (code is generated on the fly by `dataclasses`)
<span class="w"> </span>    By default, we run validation after `__init__` or `__post_init__` if defined
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    dc_cls.__pydantic_model__ = create_model(dc_cls.__name__, __config__=config, __module__=dc_cls.__module__, __validators__=gather_all_validators(dc_cls), **{f.name: (f.type, f) for f in dataclasses.fields(dc_cls)})</span>
<span class="gi">+    dc_cls.__pydantic_run_validation__ = True</span>
<span class="gi">+    dc_cls.__pydantic_initialised__ = False</span>
<span class="gi">+    dc_cls.__pydantic_validate_values__ = _dataclass_validate_values</span>
<span class="gi">+    dc_cls.__pydantic_has_field_info_default__ = False</span>
<span class="gi">+    </span>
<span class="gi">+    if validate_on_init:</span>
<span class="gi">+        original_init = dc_cls.__init__</span>
<span class="gi">+        </span>
<span class="gi">+        @wraps(original_init)</span>
<span class="gi">+        def new_init(self, *args, **kwargs):</span>
<span class="gi">+            original_init(self, *args, **kwargs)</span>
<span class="gi">+            self.__pydantic_validate_values__()</span>
<span class="gi">+        </span>
<span class="gi">+        dc_cls.__init__ = new_init</span>
<span class="gi">+    </span>
<span class="gi">+    if hasattr(dc_cls, &#39;__post_init__&#39;):</span>
<span class="gi">+        original_post_init = dc_cls.__post_init__</span>
<span class="gi">+        </span>
<span class="gi">+        @wraps(original_post_init)</span>
<span class="gi">+        def new_post_init(self, *args, **kwargs):</span>
<span class="gi">+            original_post_init(self, *args, **kwargs)</span>
<span class="gi">+            self.__pydantic_validate_values__()</span>
<span class="gi">+        </span>
<span class="gi">+        dc_cls.__post_init__ = new_post_init</span>
<span class="gi">+    </span>
<span class="gi">+    dc_cls.__doc__ = dc_cls_doc</span>


<span class="w"> </span>if sys.version_info &gt;= (3, 8):
<span class="gu">@@ -161,7 +199,11 @@ def is_builtin_dataclass(_cls: Type[Any]) -&gt;bool:</span>
<span class="w"> </span>    In this case, when we first check `B`, we make an extra check and look at the annotations (&#39;y&#39;),
<span class="w"> </span>    which won&#39;t be a superset of all the dataclass fields (only the stdlib fields i.e. &#39;x&#39;)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (</span>
<span class="gi">+        dataclasses.is_dataclass(_cls) and</span>
<span class="gi">+        not hasattr(_cls, &#39;__pydantic_model__&#39;) and</span>
<span class="gi">+        getattr(_cls, &#39;__dataclass_fields__&#39;, None) == getattr(_cls, &#39;__annotations__&#39;, None)</span>
<span class="gi">+    )</span>


<span class="w"> </span>def make_dataclass_validator(dc_cls: Type[&#39;Dataclass&#39;], config: Type[
<span class="gu">@@ -171,4 +213,22 @@ def make_dataclass_validator(dc_cls: Type[&#39;Dataclass&#39;], config: Type[</span>
<span class="w"> </span>    and yield the validators
<span class="w"> </span>    It retrieves the parameters of the dataclass and forwards them to the newly created dataclass
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    validators = gather_all_validators(dc_cls)</span>
<span class="gi">+    model = create_model(</span>
<span class="gi">+        dc_cls.__name__,</span>
<span class="gi">+        __config__=config,</span>
<span class="gi">+        __module__=dc_cls.__module__,</span>
<span class="gi">+        __validators__=validators,</span>
<span class="gi">+        **{f.name: (f.type, f) for f in dataclasses.fields(dc_cls)}</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    def dataclass_validator(value: Any) -&gt; &#39;Dataclass&#39;:</span>
<span class="gi">+        if isinstance(value, dc_cls):</span>
<span class="gi">+            return value</span>
<span class="gi">+        elif not isinstance(value, dict):</span>
<span class="gi">+            raise DataclassTypeError(dc_cls)</span>
<span class="gi">+        </span>
<span class="gi">+        validated_dict, _ = validate_model(model, value)</span>
<span class="gi">+        return dc_cls(**validated_dict)</span>
<span class="gi">+</span>
<span class="gi">+    yield dataclass_validator</span>
<span class="gh">diff --git a/pydantic/v1/datetime_parse.py b/pydantic/v1/datetime_parse.py</span>
<span class="gh">index 82d98b48..e031e01e 100644</span>
<span class="gd">--- a/pydantic/v1/datetime_parse.py</span>
<span class="gi">+++ b/pydantic/v1/datetime_parse.py</span>
<span class="gu">@@ -44,7 +44,24 @@ def parse_date(value: Union[date, StrBytesIntFloat]) -&gt;date:</span>
<span class="w"> </span>    Raise ValueError if the input is well formatted but not a valid date.
<span class="w"> </span>    Raise ValueError if the input isn&#39;t well formatted.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, date):</span>
<span class="gi">+        return value</span>
<span class="gi">+    elif isinstance(value, (int, float)):</span>
<span class="gi">+        if value &gt; MAX_NUMBER:</span>
<span class="gi">+            raise ValueError(&#39;Timestamp is too large&#39;)</span>
<span class="gi">+        if value &gt; MS_WATERSHED:</span>
<span class="gi">+            # Convert from milliseconds</span>
<span class="gi">+            value /= 1000</span>
<span class="gi">+        return (EPOCH + timedelta(seconds=int(value))).date()</span>
<span class="gi">+    elif isinstance(value, str):</span>
<span class="gi">+        match = date_re.match(value)</span>
<span class="gi">+        if match:</span>
<span class="gi">+            kw = {k: int(v) for k, v in match.groupdict().items()}</span>
<span class="gi">+            return date(**kw)</span>
<span class="gi">+    elif isinstance(value, bytes):</span>
<span class="gi">+        return parse_date(value.decode())</span>
<span class="gi">+    </span>
<span class="gi">+    raise ValueError(&#39;Invalid date format&#39;)</span>


<span class="w"> </span>def parse_time(value: Union[time, StrBytesIntFloat]) -&gt;time:
<span class="gu">@@ -54,7 +71,22 @@ def parse_time(value: Union[time, StrBytesIntFloat]) -&gt;time:</span>
<span class="w"> </span>    Raise ValueError if the input is well formatted but not a valid time.
<span class="w"> </span>    Raise ValueError if the input isn&#39;t well formatted, in particular if it contains an offset.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, time):</span>
<span class="gi">+        return value</span>
<span class="gi">+    elif isinstance(value, str):</span>
<span class="gi">+        match = time_re.match(value)</span>
<span class="gi">+        if match:</span>
<span class="gi">+            kw = match.groupdict()</span>
<span class="gi">+            if kw[&#39;microsecond&#39;]:</span>
<span class="gi">+                kw[&#39;microsecond&#39;] = kw[&#39;microsecond&#39;].ljust(6, &#39;0&#39;)</span>
<span class="gi">+            kw = {k: int(v) if v else 0 for k, v in kw.items() if k != &#39;tzinfo&#39;}</span>
<span class="gi">+            if match.groupdict()[&#39;tzinfo&#39;]:</span>
<span class="gi">+                raise ValueError(&#39;Offset-aware times are not supported&#39;)</span>
<span class="gi">+            return time(**kw)</span>
<span class="gi">+    elif isinstance(value, bytes):</span>
<span class="gi">+        return parse_time(value.decode())</span>
<span class="gi">+    </span>
<span class="gi">+    raise ValueError(&#39;Invalid time format&#39;)</span>


<span class="w"> </span>def parse_datetime(value: Union[datetime, StrBytesIntFloat]) -&gt;datetime:
<span class="gu">@@ -67,7 +99,38 @@ def parse_datetime(value: Union[datetime, StrBytesIntFloat]) -&gt;datetime:</span>
<span class="w"> </span>    Raise ValueError if the input is well formatted but not a valid datetime.
<span class="w"> </span>    Raise ValueError if the input isn&#39;t well formatted.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, datetime):</span>
<span class="gi">+        return value</span>
<span class="gi">+    elif isinstance(value, (int, float)):</span>
<span class="gi">+        if value &gt; MAX_NUMBER:</span>
<span class="gi">+            raise ValueError(&#39;Timestamp is too large&#39;)</span>
<span class="gi">+        if value &gt; MS_WATERSHED:</span>
<span class="gi">+            # Convert from milliseconds</span>
<span class="gi">+            value /= 1000</span>
<span class="gi">+        return EPOCH + timedelta(seconds=int(value))</span>
<span class="gi">+    elif isinstance(value, str):</span>
<span class="gi">+        match = datetime_re.match(value)</span>
<span class="gi">+        if match:</span>
<span class="gi">+            kw = match.groupdict()</span>
<span class="gi">+            if kw[&#39;microsecond&#39;]:</span>
<span class="gi">+                kw[&#39;microsecond&#39;] = kw[&#39;microsecond&#39;].ljust(6, &#39;0&#39;)</span>
<span class="gi">+            tzinfo = kw.pop(&#39;tzinfo&#39;)</span>
<span class="gi">+            kw = {k: int(v) if v else 0 for k, v in kw.items()}</span>
<span class="gi">+            if tzinfo == &#39;Z&#39;:</span>
<span class="gi">+                tzinfo = timezone.utc</span>
<span class="gi">+            elif tzinfo:</span>
<span class="gi">+                offset_mins = int(tzinfo[-2:]) if len(tzinfo) &gt; 3 else 0</span>
<span class="gi">+                offset = 60 * int(tzinfo[1:3]) + offset_mins</span>
<span class="gi">+                if tzinfo[0] == &#39;-&#39;:</span>
<span class="gi">+                    offset = -offset</span>
<span class="gi">+                tzinfo = timezone(timedelta(minutes=offset))</span>
<span class="gi">+            else:</span>
<span class="gi">+                tzinfo = None</span>
<span class="gi">+            return datetime(tzinfo=tzinfo, **kw)</span>
<span class="gi">+    elif isinstance(value, bytes):</span>
<span class="gi">+        return parse_datetime(value.decode())</span>
<span class="gi">+    </span>
<span class="gi">+    raise ValueError(&#39;Invalid datetime format&#39;)</span>


<span class="w"> </span>def parse_duration(value: StrBytesIntFloat) -&gt;timedelta:
<span class="gu">@@ -78,4 +141,30 @@ def parse_duration(value: StrBytesIntFloat) -&gt;timedelta:</span>

<span class="w"> </span>    Also supports ISO 8601 representation.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, timedelta):</span>
<span class="gi">+        return value</span>
<span class="gi">+    elif isinstance(value, (int, float)):</span>
<span class="gi">+        return timedelta(seconds=int(value))</span>
<span class="gi">+    elif isinstance(value, str):</span>
<span class="gi">+        match = standard_duration_re.match(value)</span>
<span class="gi">+        if match:</span>
<span class="gi">+            kw = match.groupdict()</span>
<span class="gi">+            days = int(kw.pop(&#39;days&#39;, 0) or 0)</span>
<span class="gi">+            sign = -1 if kw.pop(&#39;sign&#39;, &#39;+&#39;) == &#39;-&#39; else 1</span>
<span class="gi">+            if kw.get(&#39;microseconds&#39;):</span>
<span class="gi">+                kw[&#39;microseconds&#39;] = kw[&#39;microseconds&#39;].ljust(6, &#39;0&#39;)</span>
<span class="gi">+            kw = {k: float(v) for k, v in kw.items() if v is not None}</span>
<span class="gi">+            return sign * timedelta(days=days, **kw)</span>
<span class="gi">+        </span>
<span class="gi">+        match = iso8601_duration_re.match(value)</span>
<span class="gi">+        if match:</span>
<span class="gi">+            kw = match.groupdict()</span>
<span class="gi">+            sign = -1 if kw.pop(&#39;sign&#39;) == &#39;-&#39; else 1</span>
<span class="gi">+            days = kw.pop(&#39;days&#39;, None)</span>
<span class="gi">+            if days is not None:</span>
<span class="gi">+                days = float(days)</span>
<span class="gi">+            return sign * timedelta(days=days, **{k: float(v) for k, v in kw.items() if v is not None})</span>
<span class="gi">+    elif isinstance(value, bytes):</span>
<span class="gi">+        return parse_duration(value.decode())</span>
<span class="gi">+    </span>
<span class="gi">+    raise ValueError(&#39;Invalid duration format&#39;)</span>
<span class="gh">diff --git a/pydantic/v1/decorator.py b/pydantic/v1/decorator.py</span>
<span class="gh">index 55a4b3c3..bb2715f3 100644</span>
<span class="gd">--- a/pydantic/v1/decorator.py</span>
<span class="gi">+++ b/pydantic/v1/decorator.py</span>
<span class="gu">@@ -18,7 +18,21 @@ def validate_arguments(func: Optional[&#39;AnyCallableT&#39;]=None, *, config:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Decorator to validate the arguments passed to a function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(f: &#39;AnyCallableT&#39;) -&gt; &#39;AnyCallableT&#39;:</span>
<span class="gi">+        validated_func = ValidatedFunction(f, config)</span>
<span class="gi">+</span>
<span class="gi">+        @wraps(f)</span>
<span class="gi">+        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:</span>
<span class="gi">+            return validated_func.call(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        wrapper.vd = validated_func  # type: ignore</span>
<span class="gi">+        wrapper.raw_function = f  # type: ignore</span>
<span class="gi">+        wrapper.model = validated_func.model  # type: ignore</span>
<span class="gi">+        return wrapper  # type: ignore</span>
<span class="gi">+</span>
<span class="gi">+    if func:</span>
<span class="gi">+        return decorator(func)</span>
<span class="gi">+    return decorator</span>


<span class="w"> </span>ALT_V_ARGS = &#39;v__args&#39;
<span class="gh">diff --git a/pydantic/v1/env_settings.py b/pydantic/v1/env_settings.py</span>
<span class="gh">index 8ef7409b..6e3a9515 100644</span>
<span class="gd">--- a/pydantic/v1/env_settings.py</span>
<span class="gi">+++ b/pydantic/v1/env_settings.py</span>
<span class="gu">@@ -118,7 +118,16 @@ class EnvSettingsSource:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Find out if a field is complex, and if so whether JSON errors should be ignored
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if lenient_issubclass(field.type_, BaseModel):</span>
<span class="gi">+            return True, True</span>
<span class="gi">+</span>
<span class="gi">+        if field.is_complex():</span>
<span class="gi">+            if lenient_issubclass(get_origin(field.type_), (list, set, tuple, dict)):</span>
<span class="gi">+                return True, True</span>
<span class="gi">+            if is_union(get_origin(field.type_)):</span>
<span class="gi">+                return True, False</span>
<span class="gi">+</span>
<span class="gi">+        return False, False</span>

<span class="w"> </span>    def explode_env_vars(self, field: ModelField, env_vars: Mapping[str,
<span class="w"> </span>        Optional[str]]) -&gt;Dict[str, Any]:
<span class="gu">@@ -127,7 +136,29 @@ class EnvSettingsSource:</span>

<span class="w"> </span>        This is applied to a single field, hence filtering by env_var prefix.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        result: Dict[str, Any] = {}</span>
<span class="gi">+        prefix = f&#39;{self.env_prefix_len}{field.name}{self.env_nested_delimiter or &quot;&quot;}&#39;</span>
<span class="gi">+</span>
<span class="gi">+        for env_name, env_val in env_vars.items():</span>
<span class="gi">+            if not env_name.startswith(prefix):</span>
<span class="gi">+                continue</span>
<span class="gi">+            </span>
<span class="gi">+            if self.env_nested_delimiter:</span>
<span class="gi">+                env_name = env_name[len(prefix):]</span>
<span class="gi">+                if not env_name:</span>
<span class="gi">+                    result = env_val</span>
<span class="gi">+                else:</span>
<span class="gi">+                    self._nested_set(result, env_name.split(self.env_nested_delimiter), env_val)</span>
<span class="gi">+            else:</span>
<span class="gi">+                result[env_name] = env_val</span>
<span class="gi">+</span>
<span class="gi">+        return result</span>
<span class="gi">+</span>
<span class="gi">+    def _nested_set(self, d: Dict[str, Any], keys: List[str], value: Any) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Helper method to set nested dictionary values.&quot;&quot;&quot;</span>
<span class="gi">+        for key in keys[:-1]:</span>
<span class="gi">+            d = d.setdefault(key, {})</span>
<span class="gi">+        d[keys[-1]] = value</span>

<span class="w"> </span>    def __repr__(self) -&gt;str:
<span class="w"> </span>        return (
<span class="gu">@@ -187,4 +218,11 @@ def find_case_path(dir_path: Path, file_name: str, case_sensitive: bool</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Find a file within path&#39;s directory matching filename, optionally ignoring case.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if case_sensitive:</span>
<span class="gi">+        path = dir_path / file_name</span>
<span class="gi">+        return path if path.exists() else None</span>
<span class="gi">+    else:</span>
<span class="gi">+        for path in dir_path.iterdir():</span>
<span class="gi">+            if path.name.lower() == file_name.lower():</span>
<span class="gi">+                return path</span>
<span class="gi">+    return None</span>
<span class="gh">diff --git a/pydantic/v1/errors.py b/pydantic/v1/errors.py</span>
<span class="gh">index 20d3509b..e38e2f1a 100644</span>
<span class="gd">--- a/pydantic/v1/errors.py</span>
<span class="gi">+++ b/pydantic/v1/errors.py</span>
<span class="gu">@@ -43,7 +43,7 @@ def cls_kwargs(cls: Type[&#39;PydanticErrorMixin&#39;], ctx: &#39;DictStrAny&#39;</span>
<span class="w"> </span>    Since we only use kwargs, we need a little constructor to change that.
<span class="w"> </span>    Note: the callable can&#39;t be a lambda as pickle looks in the namespace to find it
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return cls(**ctx)</span>


<span class="w"> </span>class PydanticErrorMixin:
<span class="gh">diff --git a/pydantic/v1/fields.py b/pydantic/v1/fields.py</span>
<span class="gh">index 5364c353..36fec92c 100644</span>
<span class="gd">--- a/pydantic/v1/fields.py</span>
<span class="gi">+++ b/pydantic/v1/fields.py</span>
<span class="gu">@@ -102,13 +102,19 @@ class FieldInfo(Representation):</span>

<span class="w"> </span>        :return: the constraints set on field_info
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return {</span>
<span class="gi">+            attr</span>
<span class="gi">+            for attr, default in self.__field_constraints__.items()</span>
<span class="gi">+            if getattr(self, attr) != default</span>
<span class="gi">+        }</span>

<span class="w"> </span>    def update_from_config(self, from_config: Dict[str, Any]) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        Update this FieldInfo based on a dict from get_field_info, only fields which have not been set are dated.</span>
<span class="gi">+        Update this FieldInfo based on a dict from get_field_info, only fields which have not been set are updated.</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for key, value in from_config.items():</span>
<span class="gi">+            if getattr(self, key) is None:</span>
<span class="gi">+                setattr(self, key, value)</span>


<span class="w"> </span>def Field(default: Any=Undefined, *, default_factory: Optional[
<span class="gh">diff --git a/pydantic/v1/generics.py b/pydantic/v1/generics.py</span>
<span class="gh">index 2211c779..0f262783 100644</span>
<span class="gd">--- a/pydantic/v1/generics.py</span>
<span class="gi">+++ b/pydantic/v1/generics.py</span>
<span class="gu">@@ -189,7 +189,31 @@ def replace_types(type_: Any, type_map: Mapping[Any, Any]) -&gt;Any:</span>
<span class="w"> </span>    Tuple[int, Union[List[int], float]]

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if type_ in type_map:</span>
<span class="gi">+        return type_map[type_]</span>
<span class="gi">+    </span>
<span class="gi">+    origin = get_origin(type_)</span>
<span class="gi">+    if origin is None:</span>
<span class="gi">+        return type_</span>
<span class="gi">+    </span>
<span class="gi">+    args = get_args(type_)</span>
<span class="gi">+    if not args:</span>
<span class="gi">+        return type_</span>
<span class="gi">+    </span>
<span class="gi">+    new_args = tuple(replace_types(arg, type_map) for arg in args)</span>
<span class="gi">+    if all(new_arg is arg for new_arg, arg in zip(new_args, args)):</span>
<span class="gi">+        return type_</span>
<span class="gi">+    </span>
<span class="gi">+    if origin is Union:</span>
<span class="gi">+        return Union[new_args]</span>
<span class="gi">+    if origin is Annotated:</span>
<span class="gi">+        return Annotated[new_args[0], *new_args[1:]]</span>
<span class="gi">+    if origin is ExtLiteral:</span>
<span class="gi">+        return ExtLiteral[new_args]</span>
<span class="gi">+    if sys.version_info &gt;= (3, 10) and isinstance(origin, _UnionGenericAlias):</span>
<span class="gi">+        return origin[new_args]</span>
<span class="gi">+    </span>
<span class="gi">+    return origin[new_args]</span>


<span class="w"> </span>DictValues: Type[Any] = {}.values().__class__
<span class="gu">@@ -197,7 +221,24 @@ DictValues: Type[Any] = {}.values().__class__</span>

<span class="w"> </span>def iter_contained_typevars(v: Any) -&gt;Iterator[TypeVarType]:
<span class="w"> </span>    &quot;&quot;&quot;Recursively iterate through all subtypes and type args of `v` and yield any typevars that are found.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(v, TypeVar):</span>
<span class="gi">+        yield v</span>
<span class="gi">+    elif isinstance(v, (GenericAlias, types.GenericAlias)):</span>
<span class="gi">+        yield from iter_contained_typevars(get_origin(v))</span>
<span class="gi">+        for arg in get_args(v):</span>
<span class="gi">+            yield from iter_contained_typevars(arg)</span>
<span class="gi">+    elif isinstance(v, type):</span>
<span class="gi">+        for base in v.__bases__:</span>
<span class="gi">+            yield from iter_contained_typevars(base)</span>
<span class="gi">+        if hasattr(v, &#39;__parameters__&#39;):</span>
<span class="gi">+            for param in v.__parameters__:</span>
<span class="gi">+                yield from iter_contained_typevars(param)</span>
<span class="gi">+    elif isinstance(v, (list, tuple, Dict, set)):</span>
<span class="gi">+        for item in v:</span>
<span class="gi">+            yield from iter_contained_typevars(item)</span>
<span class="gi">+    elif isinstance(v, DictValues):</span>
<span class="gi">+        for item in v:</span>
<span class="gi">+            yield from iter_contained_typevars(item)</span>


<span class="w"> </span>def get_caller_frame_info() -&gt;Tuple[Optional[str], bool]:
<span class="gu">@@ -208,7 +249,17 @@ def get_caller_frame_info() -&gt;Tuple[Optional[str], bool]:</span>

<span class="w"> </span>    :returns Tuple[module_name, called_globally]
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        previous_frame = sys._getframe(2)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        return None, False</span>
<span class="gi">+    </span>
<span class="gi">+    module_name = previous_frame.f_globals.get(&#39;__name__&#39;)</span>
<span class="gi">+    if module_name is None:</span>
<span class="gi">+        return None, False</span>
<span class="gi">+    </span>
<span class="gi">+    called_globally = previous_frame.f_locals is previous_frame.f_globals</span>
<span class="gi">+    return module_name, called_globally</span>


<span class="w"> </span>def _prepare_model_fields(created_model: Type[GenericModel], fields:
<span class="gu">@@ -217,4 +268,18 @@ def _prepare_model_fields(created_model: Type[GenericModel], fields:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Replace DeferredType fields with concrete type hints and prepare them.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for name, field in fields.items():</span>
<span class="gi">+        if not isinstance(field, DeferredType):</span>
<span class="gi">+            continue</span>
<span class="gi">+        </span>
<span class="gi">+        type_hint = instance_type_hints.get(name)</span>
<span class="gi">+        if type_hint is None:</span>
<span class="gi">+            continue</span>
<span class="gi">+        </span>
<span class="gi">+        concrete_type = replace_types(type_hint, typevars_map)</span>
<span class="gi">+        field.type_ = concrete_type</span>
<span class="gi">+        created_model.__fields__[name].type_ = concrete_type</span>
<span class="gi">+        created_model.__fields__[name].outer_type_ = concrete_type</span>
<span class="gi">+        </span>
<span class="gi">+        if isinstance(concrete_type, type) and issubclass(concrete_type, JsonWrapper):</span>
<span class="gi">+            created_model.__fields__[name].shape = concrete_type.shape</span>
<span class="gh">diff --git a/pydantic/v1/json.py b/pydantic/v1/json.py</span>
<span class="gh">index 9de1baa2..c58af4fd 100644</span>
<span class="gd">--- a/pydantic/v1/json.py</span>
<span class="gi">+++ b/pydantic/v1/json.py</span>
<span class="gu">@@ -29,7 +29,10 @@ def decimal_encoder(dec_value: Decimal) -&gt;Union[int, float]:</span>
<span class="w"> </span>    &gt;&gt;&gt; decimal_encoder(Decimal(&quot;1&quot;))
<span class="w"> </span>    1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if dec_value.as_tuple().exponent &gt;= 0:</span>
<span class="gi">+        return int(dec_value)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return float(dec_value)</span>


<span class="w"> </span>ENCODERS_BY_TYPE: Dict[Type[Any], Callable[[Any], Any]] = {bytes: lambda o:
<span class="gu">@@ -46,4 +49,19 @@ def timedelta_isoformat(td: datetime.timedelta) -&gt;str:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    ISO 8601 encoding for Python timedelta object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    total_seconds = td.total_seconds()</span>
<span class="gi">+    hours, remainder = divmod(total_seconds, 3600)</span>
<span class="gi">+    minutes, seconds = divmod(remainder, 60)</span>
<span class="gi">+    </span>
<span class="gi">+    parts = []</span>
<span class="gi">+    if td.days:</span>
<span class="gi">+        parts.append(f&quot;{td.days}D&quot;)</span>
<span class="gi">+    if hours or minutes or seconds:</span>
<span class="gi">+        parts.append(f&quot;{int(hours):02}H&quot;)</span>
<span class="gi">+        parts.append(f&quot;{int(minutes):02}M&quot;)</span>
<span class="gi">+        parts.append(f&quot;{seconds:06.3f}S&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    if not parts:</span>
<span class="gi">+        return &quot;PT0S&quot;</span>
<span class="gi">+    </span>
<span class="gi">+    return &quot;P&quot; + &quot;T&quot;.join(parts)</span>
<span class="gh">diff --git a/pydantic/v1/main.py b/pydantic/v1/main.py</span>
<span class="gh">index 48a9e5a2..dc07df4a 100644</span>
<span class="gd">--- a/pydantic/v1/main.py</span>
<span class="gi">+++ b/pydantic/v1/main.py</span>
<span class="gu">@@ -313,7 +313,16 @@ class BaseModel(Representation, metaclass=ModelMetaclass):</span>
<span class="w"> </span>        Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return dict_utils.model_dump(</span>
<span class="gi">+            self,</span>
<span class="gi">+            include=include,</span>
<span class="gi">+            exclude=exclude,</span>
<span class="gi">+            by_alias=by_alias,</span>
<span class="gi">+            skip_defaults=skip_defaults,</span>
<span class="gi">+            exclude_unset=exclude_unset,</span>
<span class="gi">+            exclude_defaults=exclude_defaults,</span>
<span class="gi">+            exclude_none=exclude_none</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def json(self, *, include: Optional[Union[&#39;AbstractSetIntStr&#39;,
<span class="w"> </span>        &#39;MappingIntStrAny&#39;]]=None, exclude: Optional[Union[
<span class="gu">@@ -327,7 +336,19 @@ class BaseModel(Representation, metaclass=ModelMetaclass):</span>

<span class="w"> </span>        `encoder` is an optional function to supply as `default` to json.dumps(), other arguments as per `json.dumps()`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return json.dumps(</span>
<span class="gi">+            self.dict(</span>
<span class="gi">+                include=include,</span>
<span class="gi">+                exclude=exclude,</span>
<span class="gi">+                by_alias=by_alias,</span>
<span class="gi">+                skip_defaults=skip_defaults,</span>
<span class="gi">+                exclude_unset=exclude_unset,</span>
<span class="gi">+                exclude_defaults=exclude_defaults,</span>
<span class="gi">+                exclude_none=exclude_none,</span>
<span class="gi">+            ),</span>
<span class="gi">+            default=encoder or self.__json_encoder__,</span>
<span class="gi">+            **dumps_kwargs</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def construct(cls: Type[&#39;Model&#39;], _fields_set: Optional[&#39;SetStr&#39;]=None,
<span class="gu">@@ -337,7 +358,21 @@ class BaseModel(Representation, metaclass=ModelMetaclass):</span>
<span class="w"> </span>        Default values are respected, but no other validation is performed.
<span class="w"> </span>        Behaves as if `Config.extra = &#39;allow&#39;` was set since it adds all passed values
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        m = cls.__new__(cls)</span>
<span class="gi">+        fields_values = {}</span>
<span class="gi">+        for name, field in cls.__fields__.items():</span>
<span class="gi">+            if name in values:</span>
<span class="gi">+                fields_values[name] = values[name]</span>
<span class="gi">+            elif field.default is not Undefined:</span>
<span class="gi">+                fields_values[name] = field.default</span>
<span class="gi">+            elif field.default_factory is not None:</span>
<span class="gi">+                fields_values[name] = field.default_factory()</span>
<span class="gi">+        fields_values.update({k: v for k, v in values.items() if k not in cls.__fields__})</span>
<span class="gi">+        object_setattr(m, &#39;__dict__&#39;, fields_values)</span>
<span class="gi">+        if _fields_set is None:</span>
<span class="gi">+            _fields_set = set(values.keys())</span>
<span class="gi">+        object_setattr(m, &#39;__fields_set__&#39;, _fields_set)</span>
<span class="gi">+        return m</span>

<span class="w"> </span>    def copy(self: &#39;Model&#39;, *, include: Optional[Union[&#39;AbstractSetIntStr&#39;,
<span class="w"> </span>        &#39;MappingIntStrAny&#39;]]=None, exclude: Optional[Union[
<span class="gu">@@ -353,7 +388,15 @@ class BaseModel(Representation, metaclass=ModelMetaclass):</span>
<span class="w"> </span>        :param deep: set to `True` to make a deep copy of the model
<span class="w"> </span>        :return: new model instance
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        values = dict_utils.model_copy(</span>
<span class="gi">+            self,</span>
<span class="gi">+            include=include,</span>
<span class="gi">+            exclude=exclude,</span>
<span class="gi">+            update=update,</span>
<span class="gi">+            deep=deep,</span>
<span class="gi">+        )</span>
<span class="gi">+        # Use construct to create a new instance of the model</span>
<span class="gi">+        return self.__class__.construct(_fields_set=self.__fields_set__.copy(), **values)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:
<span class="gu">@@ -373,7 +416,7 @@ class BaseModel(Representation, metaclass=ModelMetaclass):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Try to update ForwardRefs on fields based on this Model, globalns and localns.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        update_model_forward_refs(cls, cls.__fields__.values(), cls.__config__.json_encoders, localns)</span>

<span class="w"> </span>    def __iter__(self) -&gt;&#39;TupleGenerator&#39;:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -417,7 +460,43 @@ def create_model(__model_name: str, *, __config__: Optional[Type[BaseConfig</span>
<span class="w"> </span>        `foo=Field(datetime, default_factory=datetime.utcnow, alias=&#39;bar&#39;)` or
<span class="w"> </span>        `foo=(str, FieldInfo(title=&#39;Foo&#39;))`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if __slots__ is not None:</span>
<span class="gi">+        warnings.warn(&#39;__slots__ should not be passed to create_model&#39;, DeprecationWarning)</span>
<span class="gi">+</span>
<span class="gi">+    fields = {}</span>
<span class="gi">+    annotations = {}</span>
<span class="gi">+</span>
<span class="gi">+    for f_name, f_def in field_definitions.items():</span>
<span class="gi">+        if isinstance(f_def, tuple):</span>
<span class="gi">+            try:</span>
<span class="gi">+                f_annotation, f_value = f_def</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                raise ValueError(f&#39;field {f_name} definition should be tuple of (&lt;type&gt;, &lt;default&gt;) or (&lt;type&gt;, &lt;FieldInfo&gt;)&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            f_annotation, f_value = None, f_def</span>
<span class="gi">+</span>
<span class="gi">+        if f_annotation:</span>
<span class="gi">+            annotations[f_name] = f_annotation</span>
<span class="gi">+        fields[f_name] = f_value</span>
<span class="gi">+</span>
<span class="gi">+    namespace = {</span>
<span class="gi">+        &#39;__annotations__&#39;: annotations,</span>
<span class="gi">+        &#39;__module__&#39;: __module__,</span>
<span class="gi">+    }</span>
<span class="gi">+    if __validators__:</span>
<span class="gi">+        namespace.update(__validators__)</span>
<span class="gi">+    namespace.update(fields)</span>
<span class="gi">+</span>
<span class="gi">+    if __base__ is not None:</span>
<span class="gi">+        bases = (__base__,) if isinstance(__base__, type) else __base__</span>
<span class="gi">+    else:</span>
<span class="gi">+        bases = (BaseModel,)</span>
<span class="gi">+</span>
<span class="gi">+    if __config__ is not None:</span>
<span class="gi">+        namespace[&#39;Config&#39;] = __config__</span>
<span class="gi">+</span>
<span class="gi">+    cls = type(__model_name, bases, namespace, **(__cls_kwargs__ or {}))</span>
<span class="gi">+    return cls</span>


<span class="w"> </span>_missing = object()
<span class="gh">diff --git a/pydantic/v1/mypy.py b/pydantic/v1/mypy.py</span>
<span class="gh">index 69913f63..5a24e674 100644</span>
<span class="gd">--- a/pydantic/v1/mypy.py</span>
<span class="gi">+++ b/pydantic/v1/mypy.py</span>
<span class="gu">@@ -38,7 +38,7 @@ def plugin(version: str) -&gt;&#39;TypingType[Plugin]&#39;:</span>
<span class="w"> </span>    We might want to use this to print a warning if the mypy version being used is
<span class="w"> </span>    newer, or especially older, than we expect (or need).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return PydanticPlugin</span>


<span class="w"> </span>class PydanticPlugin(Plugin):
<span class="gu">@@ -54,14 +54,16 @@ class PydanticPlugin(Plugin):</span>

<span class="w"> </span>        Mypy version 1.1.1 added support for `@dataclass_transform` decorator.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if fullname == DATACLASS_FULLNAME:</span>
<span class="gi">+            return dataclasses.dataclass_class_maker_callback</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def report_config_data(self, ctx: ReportConfigContext) -&gt;Dict[str, Any]:
<span class="w"> </span>        &quot;&quot;&quot;Return all plugin config data.

<span class="w"> </span>        Used by mypy to determine if cache needs to be discarded.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._plugin_data</span>

<span class="w"> </span>    def _pydantic_model_metaclass_marker_callback(self, ctx: ClassDefContext
<span class="w"> </span>        ) -&gt;None:
<span class="gu">@@ -70,7 +72,8 @@ class PydanticPlugin(Plugin):</span>
<span class="w"> </span>        Let the plugin handle it. This behavior can be disabled
<span class="w"> </span>        if &#39;debug_dataclass_transform&#39; is set to True&#39;, for testing purposes.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self.plugin_config.debug_dataclass_transform:</span>
<span class="gi">+            ctx.cls.info.metadata.setdefault(METADATA_KEY, {})[&#39;dataclass_transform_spec&#39;] = None</span>

<span class="w"> </span>    def _pydantic_field_callback(self, ctx: FunctionContext) -&gt;&#39;Type&#39;:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -81,7 +84,23 @@ class PydanticPlugin(Plugin):</span>
<span class="w"> </span>        * Output an error if both are specified.
<span class="w"> </span>        * Retrieve the type of the argument which is specified, and use it as return type for the function.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        default_arg = ctx.arg_names.index(&#39;default&#39;) if &#39;default&#39; in ctx.arg_names else None</span>
<span class="gi">+        default_factory_arg = ctx.arg_names.index(&#39;default_factory&#39;) if &#39;default_factory&#39; in ctx.arg_names else None</span>
<span class="gi">+</span>
<span class="gi">+        if default_arg is not None and default_factory_arg is not None:</span>
<span class="gi">+            ctx.api.fail(&#39;Field cannot specify both default and default_factory&#39;, ctx.context)</span>
<span class="gi">+            return AnyType(TypeOfAny.from_error)</span>
<span class="gi">+</span>
<span class="gi">+        if default_arg is not None:</span>
<span class="gi">+            default_type = ctx.arg_types[default_arg][0]</span>
<span class="gi">+            return default_type</span>
<span class="gi">+        elif default_factory_arg is not None:</span>
<span class="gi">+            default_factory_type = ctx.arg_types[default_factory_arg][0]</span>
<span class="gi">+            if isinstance(default_factory_type, CallableType):</span>
<span class="gi">+                return default_factory_type.ret_type</span>
<span class="gi">+            return AnyType(TypeOfAny.from_error)</span>
<span class="gi">+</span>
<span class="gi">+        return AnyType(TypeOfAny.implementation_artifact)</span>


<span class="w"> </span>class PydanticPluginConfig:
<span class="gh">diff --git a/pydantic/v1/networks.py b/pydantic/v1/networks.py</span>
<span class="gh">index 8106fecb..c1a2e993 100644</span>
<span class="gd">--- a/pydantic/v1/networks.py</span>
<span class="gi">+++ b/pydantic/v1/networks.py</span>
<span class="gu">@@ -66,7 +66,14 @@ def multi_host_url_regex() -&gt;Pattern[str]:</span>
<span class="w"> </span>    Additionally to `url_regex` it allows to match multiple hosts.
<span class="w"> </span>    E.g. host1.db.net,host2.db.net
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    global _multi_host_url_regex_cache</span>
<span class="gi">+    if _multi_host_url_regex_cache is None:</span>
<span class="gi">+        pattern = (</span>
<span class="gi">+            f&#39;{_scheme_regex}{_user_info_regex}(?:{_host_regex}(?:,{_host_regex})*)&#39;</span>
<span class="gi">+            f&#39;{_path_regex}{_query_regex}{_fragment_regex}&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+        _multi_host_url_regex_cache = re.compile(pattern, re.IGNORECASE)</span>
<span class="gi">+    return _multi_host_url_regex_cache</span>


<span class="w"> </span>class AnyUrl(str):
<span class="gu">@@ -117,7 +124,20 @@ class AnyUrl(str):</span>
<span class="w"> </span>        Validate hosts and build the AnyUrl object. Split from `validate` so this method
<span class="w"> </span>        can be altered in `MultiHostDsn`.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parts = cls.validate_parts(parts)</span>
<span class="gi">+        return cls(</span>
<span class="gi">+            url,</span>
<span class="gi">+            scheme=parts[&#39;scheme&#39;],</span>
<span class="gi">+            user=parts.get(&#39;user&#39;),</span>
<span class="gi">+            password=parts.get(&#39;password&#39;),</span>
<span class="gi">+            host=parts.get(&#39;domain&#39;) or parts.get(&#39;ipv4&#39;) or parts.get(&#39;ipv6&#39;),</span>
<span class="gi">+            tld=parts.get(&#39;tld&#39;),</span>
<span class="gi">+            host_type=parts.get(&#39;host_type&#39;, &#39;domain&#39;),</span>
<span class="gi">+            port=parts.get(&#39;port&#39;),</span>
<span class="gi">+            path=parts.get(&#39;path&#39;),</span>
<span class="gi">+            query=parts.get(&#39;query&#39;),</span>
<span class="gi">+            fragment=parts.get(&#39;fragment&#39;)</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def validate_parts(cls, parts: &#39;Parts&#39;, validate_port: bool=True
<span class="gu">@@ -126,7 +146,22 @@ class AnyUrl(str):</span>
<span class="w"> </span>        A method used to validate parts of a URL.
<span class="w"> </span>        Could be overridden to set default values for parts if missing
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if cls.allowed_schemes and parts[&#39;scheme&#39;] not in cls.allowed_schemes:</span>
<span class="gi">+            raise errors.UrlSchemeError(allowed_schemes=cls.allowed_schemes)</span>
<span class="gi">+        </span>
<span class="gi">+        if cls.tld_required and parts.get(&#39;tld&#39;) is None:</span>
<span class="gi">+            raise errors.UrlTldError()</span>
<span class="gi">+        </span>
<span class="gi">+        if cls.user_required and not parts.get(&#39;user&#39;):</span>
<span class="gi">+            raise errors.UrlUserInfoError()</span>
<span class="gi">+        </span>
<span class="gi">+        if validate_port and parts.get(&#39;port&#39;):</span>
<span class="gi">+            try:</span>
<span class="gi">+                parts[&#39;port&#39;] = str(int(parts[&#39;port&#39;]))</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                raise errors.UrlPortError()</span>
<span class="gi">+        </span>
<span class="gi">+        return parts</span>

<span class="w"> </span>    def __repr__(self) -&gt;str:
<span class="w"> </span>        extra = &#39;, &#39;.join(f&#39;{n}={getattr(self, n)!r}&#39; for n in self.
<span class="gu">@@ -206,6 +241,10 @@ class EmailStr(str):</span>
<span class="w"> </span>        yield str_validator
<span class="w"> </span>        yield cls.validate

<span class="gi">+    @classmethod</span>
<span class="gi">+    def validate(cls, value: str) -&gt; str:</span>
<span class="gi">+        return validate_email(value)[1]</span>
<span class="gi">+</span>

<span class="w"> </span>class NameEmail(Representation):
<span class="w"> </span>    __slots__ = &#39;name&#39;, &#39;email&#39;
<span class="gu">@@ -230,6 +269,13 @@ class NameEmail(Representation):</span>
<span class="w"> </span>    def __str__(self) -&gt;str:
<span class="w"> </span>        return f&#39;{self.name} &lt;{self.email}&gt;&#39;

<span class="gi">+    @classmethod</span>
<span class="gi">+    def validate(cls, value: Union[str, &#39;NameEmail&#39;]) -&gt; &#39;NameEmail&#39;:</span>
<span class="gi">+        if isinstance(value, cls):</span>
<span class="gi">+            return value</span>
<span class="gi">+        name, email = validate_email(value)</span>
<span class="gi">+        return cls(name or &#39;&#39;, email)</span>
<span class="gi">+</span>

<span class="w"> </span>class IPvAnyAddress(_BaseAddress):
<span class="w"> </span>    __slots__ = ()
<span class="gu">@@ -281,4 +327,23 @@ def validate_email(value: Union[str]) -&gt;Tuple[str, str]:</span>
<span class="w"> </span>    * &quot;John Doe &lt;local_part@domain.com&gt;&quot; style &quot;pretty&quot; email addresses are processed
<span class="w"> </span>    * spaces are striped from the beginning and end of addresses but no error is raised
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if email_validator is None:</span>
<span class="gi">+        import_email_validator()</span>
<span class="gi">+</span>
<span class="gi">+    if len(value) &gt; MAX_EMAIL_LENGTH:</span>
<span class="gi">+        raise errors.EmailError(&#39;Email address too long&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    value = value.strip()</span>
<span class="gi">+</span>
<span class="gi">+    match = pretty_email_regex.fullmatch(value)</span>
<span class="gi">+    if match:</span>
<span class="gi">+        name, value = match.groups()</span>
<span class="gi">+    else:</span>
<span class="gi">+        name = &#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        email_validator.validate_email(value, check_deliverability=False)</span>
<span class="gi">+    except email_validator.EmailNotValidError as e:</span>
<span class="gi">+        raise errors.EmailError(str(e))</span>
<span class="gi">+</span>
<span class="gi">+    return name, value</span>
<span class="gh">diff --git a/pydantic/v1/schema.py b/pydantic/v1/schema.py</span>
<span class="gh">index 073f563a..e41e829f 100644</span>
<span class="gd">--- a/pydantic/v1/schema.py</span>
<span class="gi">+++ b/pydantic/v1/schema.py</span>
<span class="gu">@@ -48,7 +48,26 @@ def schema(models: Sequence[Union[Type[&#39;BaseModel&#39;], Type[&#39;Dataclass&#39;]]], *,</span>
<span class="w"> </span>    :return: dict with the JSON Schema with a ``definitions`` top-level key including the schema definitions for
<span class="w"> </span>      the models and sub-models passed in ``models``.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    definitions = {}</span>
<span class="gi">+    schema_dict = {</span>
<span class="gi">+        &quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;,</span>
<span class="gi">+        &quot;definitions&quot;: definitions,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    if title:</span>
<span class="gi">+        schema_dict[&quot;title&quot;] = title</span>
<span class="gi">+    if description:</span>
<span class="gi">+        schema_dict[&quot;description&quot;] = description</span>
<span class="gi">+</span>
<span class="gi">+    for model in models:</span>
<span class="gi">+        model_schema, model_definitions, _ = model_schema(</span>
<span class="gi">+            model, by_alias=by_alias, ref_prefix=ref_prefix, ref_template=ref_template</span>
<span class="gi">+        )</span>
<span class="gi">+        definitions.update(model_definitions)</span>
<span class="gi">+        model_name = model.__name__</span>
<span class="gi">+        definitions[model_name] = model_schema</span>
<span class="gi">+</span>
<span class="gi">+    return schema_dict</span>


<span class="w"> </span>def model_schema(model: Union[Type[&#39;BaseModel&#39;], Type[&#39;Dataclass&#39;]],
<span class="gu">@@ -70,7 +89,17 @@ def model_schema(model: Union[Type[&#39;BaseModel&#39;], Type[&#39;Dataclass&#39;]],</span>
<span class="w"> </span>      sibling json file in a ``/schemas`` directory use ``&quot;/schemas/${model}.json#&quot;``.
<span class="w"> </span>    :return: dict with the JSON Schema for the passed ``model``
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    model_name_map = get_model_name_map(get_flat_models_from_model(model))</span>
<span class="gi">+    model_schema, definitions, _ = model_process_schema(</span>
<span class="gi">+        model,</span>
<span class="gi">+        by_alias=by_alias,</span>
<span class="gi">+        model_name_map=model_name_map,</span>
<span class="gi">+        ref_prefix=ref_prefix,</span>
<span class="gi">+        ref_template=ref_template,</span>
<span class="gi">+    )</span>
<span class="gi">+    schema = {&quot;$schema&quot;: &quot;http://json-schema.org/draft-07/schema#&quot;, &quot;definitions&quot;: definitions}</span>
<span class="gi">+    schema.update(model_schema)</span>
<span class="gi">+    return schema</span>


<span class="w"> </span>def field_schema(field: ModelField, *, by_alias: bool=True, model_name_map:
<span class="gu">@@ -94,7 +123,26 @@ def field_schema(field: ModelField, *, by_alias: bool=True, model_name_map:</span>
<span class="w"> </span>    :param known_models: used to solve circular references
<span class="w"> </span>    :return: tuple of the schema for this field and additional definitions
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    schema_overrides = False</span>
<span class="gi">+    known_models = known_models or set()</span>
<span class="gi">+    schema, definitions, nested_models = field_type_schema(</span>
<span class="gi">+        field,</span>
<span class="gi">+        by_alias=by_alias,</span>
<span class="gi">+        model_name_map=model_name_map,</span>
<span class="gi">+        schema_overrides=schema_overrides,</span>
<span class="gi">+        ref_prefix=ref_prefix,</span>
<span class="gi">+        ref_template=ref_template,</span>
<span class="gi">+        known_models=known_models,</span>
<span class="gi">+    )</span>
<span class="gi">+    # Add field constraints</span>
<span class="gi">+    schema.update(get_field_schema_validations(field))</span>
<span class="gi">+    if field.required:</span>
<span class="gi">+        schema[&#39;title&#39;] = field.alias if by_alias else field.name</span>
<span class="gi">+    if field.default is not None and not field.required:</span>
<span class="gi">+        schema[&#39;default&#39;] = field.default</span>
<span class="gi">+    if field.description:</span>
<span class="gi">+        schema[&#39;description&#39;] = field.description</span>
<span class="gi">+    return schema, definitions, nested_models</span>


<span class="w"> </span>numeric_types = int, float, Decimal
<span class="gh">diff --git a/pydantic/v1/tools.py b/pydantic/v1/tools.py</span>
<span class="gh">index d1551536..212b5539 100644</span>
<span class="gd">--- a/pydantic/v1/tools.py</span>
<span class="gi">+++ b/pydantic/v1/tools.py</span>
<span class="gu">@@ -12,14 +12,47 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>    from pydantic.v1.typing import DictStrAny
<span class="w"> </span>T = TypeVar(&#39;T&#39;)

<span class="gi">+def parse_obj_as(type_: Type[T], obj: Any) -&gt; T:</span>
<span class="gi">+    from pydantic.v1.main import create_model</span>
<span class="gi">+</span>
<span class="gi">+    model = create_model(&#39;TempModel&#39;, __root__=(type_, ...))</span>
<span class="gi">+    return model(__root__=obj).__root__</span>
<span class="gi">+</span>
<span class="gi">+def parse_raw_as(type_: Type[T], b: StrBytes, *, content_type: str = None, encoding: str = &#39;utf8&#39;,</span>
<span class="gi">+                 proto: Protocol = None, allow_pickle: bool = False) -&gt; T:</span>
<span class="gi">+    obj = load_str_bytes(b, proto=proto, content_type=content_type, encoding=encoding, allow_pickle=allow_pickle)</span>
<span class="gi">+    return parse_obj_as(type_, obj)</span>
<span class="gi">+</span>
<span class="gi">+def parse_file_as(type_: Type[T], path: Union[str, Path], *, content_type: str = None, encoding: str = &#39;utf8&#39;,</span>
<span class="gi">+                  proto: Protocol = None, allow_pickle: bool = False) -&gt; T:</span>
<span class="gi">+    obj = load_file(path, proto=proto, content_type=content_type, encoding=encoding, allow_pickle=allow_pickle)</span>
<span class="gi">+    return parse_obj_as(type_, obj)</span>
<span class="gi">+</span>

<span class="w"> </span>def schema_of(type_: Any, *, title: Optional[NameFactory]=None, **
<span class="w"> </span>    schema_kwargs: Any) -&gt;&#39;DictStrAny&#39;:
<span class="w"> </span>    &quot;&quot;&quot;Generate a JSON schema (as dict) for the passed model or dynamically generated one&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    from pydantic.v1.main import create_model</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(type_, type) and issubclass(type_, Protocol):</span>
<span class="gi">+        raise TypeError(&quot;Cannot generate schema for Protocol class&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    model = create_model(&#39;TempModel&#39;, __root__=(type_, ...))</span>
<span class="gi">+    schema = model.schema(**schema_kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    if title is not None:</span>
<span class="gi">+        if callable(title):</span>
<span class="gi">+            schema[&#39;title&#39;] = title(type_)</span>
<span class="gi">+        else:</span>
<span class="gi">+            schema[&#39;title&#39;] = title</span>
<span class="gi">+    elif &#39;title&#39; not in schema:</span>
<span class="gi">+        schema[&#39;title&#39;] = display_as_type(type_)</span>
<span class="gi">+</span>
<span class="gi">+    return schema</span>


<span class="w"> </span>def schema_json_of(type_: Any, *, title: Optional[NameFactory]=None, **
<span class="w"> </span>    schema_json_kwargs: Any) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Generate a JSON schema (as JSON) for the passed model or dynamically generated one&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    schema = schema_of(type_, title=title)</span>
<span class="gi">+    return json.dumps(schema, **schema_json_kwargs)</span>
<span class="gh">diff --git a/pydantic/v1/types.py b/pydantic/v1/types.py</span>
<span class="gh">index 5c45c9e0..6450d121 100644</span>
<span class="gd">--- a/pydantic/v1/types.py</span>
<span class="gi">+++ b/pydantic/v1/types.py</span>
<span class="gu">@@ -82,7 +82,9 @@ else:</span>
<span class="w"> </span>            &quot;&quot;&quot;
<span class="w"> </span>            Ensure that we only allow bools.
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            if isinstance(value, bool):</span>
<span class="gi">+                return value</span>
<span class="gi">+            raise ValueError(&#39;value is not a valid boolean&#39;)</span>


<span class="w"> </span>class ConstrainedInt(int, metaclass=ConstrainedNumberMeta):
<span class="gu">@@ -473,6 +475,25 @@ class SecretStr(SecretField):</span>
<span class="w"> </span>    @classmethod
<span class="w"> </span>    def __get_validators__(cls) -&gt;&#39;CallableGenerator&#39;:
<span class="w"> </span>        yield cls.validate
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def validate(cls, v: Union[int, float, str]) -&gt; &#39;ByteSize&#39;:</span>
<span class="gi">+        if isinstance(v, (int, float)):</span>
<span class="gi">+            return cls(v)</span>
<span class="gi">+        elif isinstance(v, str):</span>
<span class="gi">+            match = byte_string_re.match(v)</span>
<span class="gi">+            if not match:</span>
<span class="gi">+                raise ValueError(&#39;Invalid byte string format&#39;)</span>
<span class="gi">+            num, unit = match.groups()</span>
<span class="gi">+            num = float(num)</span>
<span class="gi">+            if not unit:</span>
<span class="gi">+                unit = &#39;b&#39;</span>
<span class="gi">+            multiplier = BYTE_SIZES.get(unit.lower())</span>
<span class="gi">+            if not multiplier:</span>
<span class="gi">+                raise ValueError(f&#39;Invalid byte unit: {unit}&#39;)</span>
<span class="gi">+            return cls(int(num * multiplier))</span>
<span class="gi">+        else:</span>
<span class="gi">+            raise ValueError(&#39;Value must be int, float or string&#39;)</span>
<span class="w"> </span>        yield constr_length_validator

<span class="w"> </span>    def __init__(self, value: str):
<span class="gu">@@ -550,7 +571,16 @@ class PaymentCardNumber(str):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Based on: https://en.wikipedia.org/wiki/Luhn_algorithm
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        digits = [int(d) for d in card_number if d.isdigit()]</span>
<span class="gi">+        checksum = 0</span>
<span class="gi">+        odd_digits = digits[-1::-2]</span>
<span class="gi">+        even_digits = digits[-2::-2]</span>
<span class="gi">+        checksum += sum(odd_digits)</span>
<span class="gi">+        for digit in even_digits:</span>
<span class="gi">+            checksum += sum(divmod(digit * 2, 10))</span>
<span class="gi">+        if checksum % 10 == 0:</span>
<span class="gi">+            return card_number</span>
<span class="gi">+        raise ValueError(&#39;Invalid card number (failed Luhn check)&#39;)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def validate_length_for_brand(cls, card_number: &#39;PaymentCardNumber&#39;
<span class="gu">@@ -559,7 +589,14 @@ class PaymentCardNumber(str):</span>
<span class="w"> </span>        Validate length based on BIN for major brands:
<span class="w"> </span>        https://en.wikipedia.org/wiki/Payment_card_number#Issuer_identification_number_(IIN)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        length = len(card_number)</span>
<span class="gi">+        if card_number.brand == PaymentCardBrand.amex and length == 15:</span>
<span class="gi">+            return card_number</span>
<span class="gi">+        elif card_number.brand in (PaymentCardBrand.mastercard, PaymentCardBrand.visa) and length in (16, 19):</span>
<span class="gi">+            return card_number</span>
<span class="gi">+        elif card_number.brand == PaymentCardBrand.other and 12 &lt;= length &lt;= 19:</span>
<span class="gi">+            return card_number</span>
<span class="gi">+        raise ValueError(f&#39;Invalid length for {card_number.brand} card&#39;)</span>


<span class="w"> </span>BYTE_SIZES = {&#39;b&#39;: 1, &#39;kb&#39;: 10 ** 3, &#39;mb&#39;: 10 ** 6, &#39;gb&#39;: 10 ** 9, &#39;tb&#39;: 10 **
<span class="gh">diff --git a/pydantic/v1/typing.py b/pydantic/v1/typing.py</span>
<span class="gh">index 72034371..2581329e 100644</span>
<span class="gd">--- a/pydantic/v1/typing.py</span>
<span class="gi">+++ b/pydantic/v1/typing.py</span>
<span class="gu">@@ -38,7 +38,10 @@ else:</span>
<span class="w"> </span>        It should be useless once https://github.com/cython/cython/issues/3537 is
<span class="w"> </span>        solved and https://github.com/pydantic/pydantic/pull/1753 is merged.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        origin = _typing_get_origin(tp)</span>
<span class="gi">+        if origin is None and isinstance(tp, type):</span>
<span class="gi">+            return tp</span>
<span class="gi">+        return origin</span>
<span class="w"> </span>if sys.version_info &lt; (3, 8):
<span class="w"> </span>    from typing import _GenericAlias

<span class="gu">@@ -48,7 +51,12 @@ if sys.version_info &lt; (3, 8):</span>
<span class="w"> </span>        Mostly compatible with the python 3.8 `typing` module version
<span class="w"> </span>        and able to handle almost all use cases.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(t, _GenericAlias):</span>
<span class="gi">+            res = t.__args__</span>
<span class="gi">+            if get_origin(t) is Callable and res[0] is not Ellipsis:</span>
<span class="gi">+                res = (list(res[:-1]), res[-1])</span>
<span class="gi">+            return res</span>
<span class="gi">+        return ()</span>
<span class="w"> </span>else:
<span class="w"> </span>    from typing import get_args as _typing_get_args

<span class="gu">@@ -59,7 +67,10 @@ else:</span>
<span class="w"> </span>        In order to still support `Dict` for example and consider it as `Dict[Any, Any]`,
<span class="w"> </span>        we retrieve the `_nparams` value that tells us how many parameters it needs.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        args = _typing_get_args(tp)</span>
<span class="gi">+        if not args and isinstance(tp, typing._GenericAlias) and hasattr(tp, &#39;_nparams&#39;):</span>
<span class="gi">+            return (Any,) * tp._nparams</span>
<span class="gi">+        return args</span>

<span class="w"> </span>    def get_args(tp: Type[Any]) -&gt;Tuple[Any, ...]:
<span class="w"> </span>        &quot;&quot;&quot;Get type arguments with all substitutions performed.
<span class="gu">@@ -72,7 +83,9 @@ else:</span>
<span class="w"> </span>            get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int])
<span class="w"> </span>            get_args(Callable[[], T][int]) == ([], int)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(tp, WithArgsTypes):</span>
<span class="gi">+            return _generic_get_args(tp)</span>
<span class="gi">+        return _typing_get_args(tp)</span>
<span class="w"> </span>if sys.version_info &lt; (3, 9):

<span class="w"> </span>    def convert_generics(tp: Type[Any]) -&gt;Type[Any]:
<span class="gu">@@ -82,7 +95,7 @@ if sys.version_info &lt; (3, 9):</span>
<span class="w"> </span>        Examples::
<span class="w"> </span>            typing.List[&#39;Hero&#39;] == typing.List[ForwardRef(&#39;Hero&#39;)]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return tp</span>
<span class="w"> </span>else:
<span class="w"> </span>    from typing import _UnionGenericAlias
<span class="w"> </span>    from typing_extensions import _AnnotatedAlias
<span class="gu">@@ -97,7 +110,13 @@ else:</span>
<span class="w"> </span>            convert_generics(typing.Dict[&#39;Hero&#39;, &#39;Team&#39;]) == typing.Dict[ForwardRef(&#39;Hero&#39;), ForwardRef(&#39;Team&#39;)]
<span class="w"> </span>            convert_generics(list[str | &#39;Hero&#39;] | int) == list[str | ForwardRef(&#39;Hero&#39;)] | int
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(tp, str):</span>
<span class="gi">+            return ForwardRef(tp)</span>
<span class="gi">+        if isinstance(tp, (_UnionGenericAlias, TypesUnionType)):</span>
<span class="gi">+            return tp.__class__(*[convert_generics(a) for a in tp.__args__])</span>
<span class="gi">+        if isinstance(tp, (_AnnotatedAlias, TypingGenericAlias)):</span>
<span class="gi">+            return tp.__class__(tp.__origin__, *[convert_generics(a) for a in tp.__args__])</span>
<span class="gi">+        return tp</span>
<span class="w"> </span>if sys.version_info &lt; (3, 10):
<span class="w"> </span>    WithArgsTypes = TypingGenericAlias,
<span class="w"> </span>else:
<span class="gu">@@ -147,7 +166,23 @@ def resolve_annotations(raw_annotations: Dict[str, Type[Any]], module_name:</span>

<span class="w"> </span>    Resolve string or ForwardRef annotations into type objects if possible.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    resolved_annotations = {}</span>
<span class="gi">+    for name, value in raw_annotations.items():</span>
<span class="gi">+        if isinstance(value, str):</span>
<span class="gi">+            try:</span>
<span class="gi">+                value = ForwardRef(value)</span>
<span class="gi">+            except TypeError:</span>
<span class="gi">+                # TypeErrors can be raised when using Literal[&#39;string-literal&#39;]</span>
<span class="gi">+                # String literals as strings are not supported in 3.7</span>
<span class="gi">+                pass</span>
<span class="gi">+        if isinstance(value, ForwardRef):</span>
<span class="gi">+            try:</span>
<span class="gi">+                value = _eval_type(value, globals(), locals())</span>
<span class="gi">+            except NameError:</span>
<span class="gi">+                # Fall back to ForwardRef if the type cannot be evaluated</span>
<span class="gi">+                pass</span>
<span class="gi">+        resolved_annotations[name] = value</span>
<span class="gi">+    return resolved_annotations</span>


<span class="w"> </span>def all_literal_values(type_: Type[Any]) -&gt;Tuple[Any, ...]:
<span class="gu">@@ -156,7 +191,20 @@ def all_literal_values(type_: Type[Any]) -&gt;Tuple[Any, ...]:</span>
<span class="w"> </span>    Literal can be used recursively (see https://www.python.org/dev/peps/pep-0586)
<span class="w"> </span>    e.g. `Literal[Literal[Literal[1, 2, 3], &quot;foo&quot;], 5, None]`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if hasattr(type_, &#39;__values__&#39;):</span>
<span class="gi">+        values = type_.__values__</span>
<span class="gi">+    elif hasattr(type_, &#39;__args__&#39;):</span>
<span class="gi">+        values = type_.__args__</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&#39;Cannot extract literal values from {type_}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    literal_values = []</span>
<span class="gi">+    for value in values:</span>
<span class="gi">+        if hasattr(value, &#39;__values__&#39;) or hasattr(value, &#39;__args__&#39;):</span>
<span class="gi">+            literal_values.extend(all_literal_values(value))</span>
<span class="gi">+        else:</span>
<span class="gi">+            literal_values.append(value)</span>
<span class="gi">+    return tuple(literal_values)</span>


<span class="w"> </span>def is_namedtuple(type_: Type[Any]) -&gt;bool:
<span class="gu">@@ -164,7 +212,13 @@ def is_namedtuple(type_: Type[Any]) -&gt;bool:</span>
<span class="w"> </span>    Check if a given class is a named tuple.
<span class="w"> </span>    It can be either a `typing.NamedTuple` or `collections.namedtuple`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (</span>
<span class="gi">+        isinstance(type_, type) and</span>
<span class="gi">+        issubclass(type_, tuple) and</span>
<span class="gi">+        hasattr(type_, &#39;_fields&#39;) and</span>
<span class="gi">+        hasattr(type_, &#39;_field_defaults&#39;) and</span>
<span class="gi">+        hasattr(type_, &#39;_asdict&#39;)</span>
<span class="gi">+    )</span>


<span class="w"> </span>def is_typeddict(type_: Type[Any]) -&gt;bool:
<span class="gu">@@ -172,14 +226,14 @@ def is_typeddict(type_: Type[Any]) -&gt;bool:</span>
<span class="w"> </span>    Check if a given class is a typed dict (from `typing` or `typing_extensions`)
<span class="w"> </span>    In 3.10, there will be a public method (https://docs.python.org/3.10/library/typing.html#typing.is_typeddict)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return hasattr(type_, &#39;__annotations__&#39;) and hasattr(type_, &#39;__total__&#39;)</span>


<span class="w"> </span>def is_typeddict_special(type_: Any) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Check if type is a TypedDict special form (Required or NotRequired).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return type_ in (TypedDictRequired, TypedDictNotRequired)</span>


<span class="w"> </span>test_type = NewType(&#39;test_type&#39;, str)
<span class="gu">@@ -189,14 +243,14 @@ def is_new_type(type_: Type[Any]) -&gt;bool:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Check whether type_ was created using typing.NewType
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return hasattr(type_, &#39;__supertype__&#39;)</span>


<span class="w"> </span>def _check_finalvar(v: Optional[Type[Any]]) -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Check if a given type is a `typing.Final` type.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return isinstance(v, Final) or (isinstance(v, type) and issubclass(v, Final))</span>


<span class="w"> </span>def update_field_forward_refs(field: &#39;ModelField&#39;, globalns: Any, localns: Any
<span class="gu">@@ -204,7 +258,12 @@ def update_field_forward_refs(field: &#39;ModelField&#39;, globalns: Any, localns: Any</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Try to update ForwardRefs on fields based on this ModelField, globalns and localns.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if field.type_.__class__ == ForwardRef:</span>
<span class="gi">+        field.type_ = field.type_._evaluate(globalns, localns)</span>
<span class="gi">+        field.prepare()</span>
<span class="gi">+    if field.sub_fields:</span>
<span class="gi">+        for sub_field in field.sub_fields:</span>
<span class="gi">+            update_field_forward_refs(sub_field, globalns=globalns, localns=localns)</span>


<span class="w"> </span>def update_model_forward_refs(model: Type[Any], fields: Iterable[
<span class="gu">@@ -214,7 +273,25 @@ def update_model_forward_refs(model: Type[Any], fields: Iterable[</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Try to update model fields ForwardRefs based on model and localns.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def _update_forward_refs(typ: Any) -&gt;None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            typ.update_forward_refs(**localns)</span>
<span class="gi">+        except exc_to_suppress:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    _update_forward_refs(model)</span>
<span class="gi">+    for field in fields:</span>
<span class="gi">+        try:</span>
<span class="gi">+            update_field_forward_refs(field, globalns=model.__module__, localns=localns)</span>
<span class="gi">+        except exc_to_suppress:</span>
<span class="gi">+            pass</span>
<span class="gi">+</span>
<span class="gi">+    for key, value in json_encoders.items():</span>
<span class="gi">+        if isinstance(key, ForwardRef):</span>
<span class="gi">+            try:</span>
<span class="gi">+                json_encoders[key._evaluate(model.__module__, localns)] = value</span>
<span class="gi">+            except exc_to_suppress:</span>
<span class="gi">+                continue</span>


<span class="w"> </span>def get_class(type_: Type[Any]) -&gt;Union[None, bool, Type[Any]]:
<span class="gu">@@ -222,7 +299,13 @@ def get_class(type_: Type[Any]) -&gt;Union[None, bool, Type[Any]]:</span>
<span class="w"> </span>    Tries to get the class of a Type[T] annotation. Returns True if Type is used
<span class="w"> </span>    without brackets. Otherwise returns None.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if type_ is Type:</span>
<span class="gi">+        return True</span>
<span class="gi">+    if hasattr(type_, &#39;__origin__&#39;) and type_.__origin__ is Type:</span>
<span class="gi">+        if not type_.__args__:</span>
<span class="gi">+            return True</span>
<span class="gi">+        return type_.__args__[0]</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def get_sub_types(tp: Any) -&gt;List[Any]:
<span class="gu">@@ -230,4 +313,9 @@ def get_sub_types(tp: Any) -&gt;List[Any]:</span>
<span class="w"> </span>    Return all the types that are allowed by type `tp`
<span class="w"> </span>    `tp` can be a `Union` of allowed types or an `Annotated` type
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if is_union(tp):</span>
<span class="gi">+        return list(get_args(tp))</span>
<span class="gi">+    elif get_origin(tp) is Annotated:</span>
<span class="gi">+        return [get_args(tp)[0]]</span>
<span class="gi">+    else:</span>
<span class="gi">+        return [tp]</span>
<span class="gh">diff --git a/pydantic/v1/utils.py b/pydantic/v1/utils.py</span>
<span class="gh">index effb78d4..3efe0942 100644</span>
<span class="gd">--- a/pydantic/v1/utils.py</span>
<span class="gi">+++ b/pydantic/v1/utils.py</span>
<span class="gu">@@ -42,14 +42,26 @@ def import_string(dotted_path: str) -&gt;Any:</span>
<span class="w"> </span>    Stolen approximately from django. Import a dotted module path and return the attribute/class designated by the
<span class="w"> </span>    last name in the path. Raise ImportError if the import fails.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        module_path, class_name = dotted_path.rsplit(&#39;.&#39;, 1)</span>
<span class="gi">+    except ValueError as err:</span>
<span class="gi">+        raise ImportError(&quot;%s doesn&#39;t look like a module path&quot; % dotted_path) from err</span>
<span class="gi">+</span>
<span class="gi">+    module = __import__(module_path, fromlist=[class_name])</span>
<span class="gi">+    try:</span>
<span class="gi">+        return getattr(module, class_name)</span>
<span class="gi">+    except AttributeError as err:</span>
<span class="gi">+        raise ImportError(&#39;Module &quot;%s&quot; does not define a &quot;%s&quot; attribute/class&#39; % (module_path, class_name)) from err</span>


<span class="w"> </span>def truncate(v: Union[str], *, max_len: int=80) -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Truncate a value and add a unicode ellipsis (three dots) to the end if it was too long
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    s = str(v)</span>
<span class="gi">+    if len(s) &lt;= max_len:</span>
<span class="gi">+        return s</span>
<span class="gi">+    return s[:max_len - 1].rstrip() + &#39;…&#39;</span>


<span class="w"> </span>def validate_field_name(bases: List[Type[&#39;BaseModel&#39;]], field_name: str
<span class="gu">@@ -57,14 +69,22 @@ def validate_field_name(bases: List[Type[&#39;BaseModel&#39;]], field_name: str</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Ensure that the field&#39;s name does not shadow an existing attribute of the model.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    for base in bases:</span>
<span class="gi">+        if getattr(base, field_name, None):</span>
<span class="gi">+            raise NameError(</span>
<span class="gi">+                f&#39;Field name &quot;{field_name}&quot; shadows an attribute in parent &quot;{base.__name__}&quot;&#39;</span>
<span class="gi">+            )</span>


<span class="w"> </span>def in_ipython() -&gt;bool:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Check whether we&#39;re in an ipython environment, including jupyter notebooks.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        from IPython import get_ipython</span>
<span class="gi">+        return get_ipython() is not None</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        return False</span>


<span class="w"> </span>def is_valid_identifier(identifier: str) -&gt;bool:
<span class="gu">@@ -73,7 +93,7 @@ def is_valid_identifier(identifier: str) -&gt;bool:</span>
<span class="w"> </span>    :param identifier: The identifier to test.
<span class="w"> </span>    :return: True if the identifier is valid.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return identifier.isidentifier() and not keyword.iskeyword(identifier)</span>


<span class="w"> </span>KeyType = TypeVar(&#39;KeyType&#39;)
<span class="gh">diff --git a/pydantic/v1/validators.py b/pydantic/v1/validators.py</span>
<span class="gh">index fd53f500..81cfd234 100644</span>
<span class="gd">--- a/pydantic/v1/validators.py</span>
<span class="gi">+++ b/pydantic/v1/validators.py</span>
<span class="gu">@@ -35,7 +35,9 @@ def constant_validator(v: &#39;Any&#39;, field: &#39;ModelField&#39;) -&gt;&#39;Any&#39;:</span>
<span class="w"> </span>    of the field. This is to support the keyword of the same name in JSON
<span class="w"> </span>    Schema.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if v != field.default:</span>
<span class="gi">+        raise errors.ConstError(field=field)</span>
<span class="gi">+    return v</span>


<span class="w"> </span>def ip_v4_network_validator(v: Any) -&gt;IPv4Network:
<span class="gu">@@ -45,7 +47,10 @@ def ip_v4_network_validator(v: Any) -&gt;IPv4Network:</span>
<span class="w"> </span>    See more:
<span class="w"> </span>    https://docs.python.org/library/ipaddress.html#ipaddress.IPv4Network
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return IPv4Network(v)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise errors.IPvAnyNetworkError()</span>


<span class="w"> </span>def ip_v6_network_validator(v: Any) -&gt;IPv6Network:
<span class="gu">@@ -55,7 +60,10 @@ def ip_v6_network_validator(v: Any) -&gt;IPv6Network:</span>
<span class="w"> </span>    See more:
<span class="w"> </span>    https://docs.python.org/library/ipaddress.html#ipaddress.IPv6Network
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        return IPv6Network(v)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise errors.IPvAnyNetworkError()</span>


<span class="w"> </span>def callable_validator(v: Any) -&gt;AnyCallable:
<span class="gu">@@ -64,7 +72,9 @@ def callable_validator(v: Any) -&gt;AnyCallable:</span>

<span class="w"> </span>    Note: complete matching of argument type hints and return types is not performed
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not callable(v):</span>
<span class="gi">+        raise errors.CallableError(value=v)</span>
<span class="gi">+    return v</span>


<span class="w"> </span>T = TypeVar(&#39;T&#39;)
<span class="gh">diff --git a/pydantic/validate_call_decorator.py b/pydantic/validate_call_decorator.py</span>
<span class="gh">index 5eb2596a..dd2486a3 100644</span>
<span class="gd">--- a/pydantic/validate_call_decorator.py</span>
<span class="gi">+++ b/pydantic/validate_call_decorator.py</span>
<span class="gu">@@ -26,4 +26,19 @@ def validate_call(func: (AnyCallableT | None)=None, /, *, config: (</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        The decorated function.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def decorator(f: AnyCallableT) -&gt; AnyCallableT:</span>
<span class="gi">+        @functools.wraps(f)</span>
<span class="gi">+        def wrapper(*args: Any, **kwargs: Any) -&gt; Any:</span>
<span class="gi">+            validated_args, validated_kwargs = _validate_call.validate_arguments(</span>
<span class="gi">+                f, args, kwargs, config</span>
<span class="gi">+            )</span>
<span class="gi">+            result = f(*validated_args, **validated_kwargs)</span>
<span class="gi">+            if validate_return:</span>
<span class="gi">+                return _validate_call.validate_return(f, result, config)</span>
<span class="gi">+            return result</span>
<span class="gi">+        return _typing_extra.cast(AnyCallableT, wrapper)</span>
<span class="gi">+</span>
<span class="gi">+    if func is None:</span>
<span class="gi">+        return decorator</span>
<span class="gi">+    else:</span>
<span class="gi">+        return decorator(func)</span>
<span class="gh">diff --git a/pydantic/version.py b/pydantic/version.py</span>
<span class="gh">index d63da2ae..19419595 100644</span>
<span class="gd">--- a/pydantic/version.py</span>
<span class="gi">+++ b/pydantic/version.py</span>
<span class="gu">@@ -10,12 +10,21 @@ def version_short() -&gt;str:</span>

<span class="w"> </span>    It returns &#39;2.1&#39; if Pydantic version is &#39;2.1.1&#39;.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return &#39;.&#39;.join(VERSION.split(&#39;.&#39;)[:2])</span>


<span class="w"> </span>def version_info() -&gt;str:
<span class="w"> </span>    &quot;&quot;&quot;Return complete version information for Pydantic and its dependencies.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import sys</span>
<span class="gi">+    import platform</span>
<span class="gi">+    </span>
<span class="gi">+    info = [</span>
<span class="gi">+        f&#39;pydantic version: {VERSION}&#39;,</span>
<span class="gi">+        f&#39;python version: {platform.python_version()}&#39;,</span>
<span class="gi">+        f&#39;platform: {platform.platform()}&#39;,</span>
<span class="gi">+        f&#39;implementation: {platform.python_implementation()}&#39;,</span>
<span class="gi">+    ]</span>
<span class="gi">+    return &#39;\n&#39;.join(info)</span>


<span class="w"> </span>def parse_mypy_version(version: str) -&gt;tuple[int, ...]:
<span class="gu">@@ -30,4 +39,6 @@ def parse_mypy_version(version: str) -&gt;tuple[int, ...]:</span>
<span class="w"> </span>    Returns:
<span class="w"> </span>        A tuple of ints. e.g. (0, 930).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Split the version string and take only the part before &#39;+&#39;</span>
<span class="gi">+    version_parts = version.split(&#39;+&#39;)[0].split(&#39;.&#39;)</span>
<span class="gi">+    return tuple(int(part) for part in version_parts)</span>
<span class="gh">diff --git a/pydantic/warnings.py b/pydantic/warnings.py</span>
<span class="gh">index 0d1b0a6a..cb5e9795 100644</span>
<span class="gd">--- a/pydantic/warnings.py</span>
<span class="gi">+++ b/pydantic/warnings.py</span>
<span class="gu">@@ -50,7 +50,7 @@ class PydanticDeprecatedSince26(PydanticDeprecationWarning):</span>
<span class="w"> </span>    &quot;&quot;&quot;A specific `PydanticDeprecationWarning` subclass defining functionality deprecated since Pydantic 2.6.&quot;&quot;&quot;

<span class="w"> </span>    def __init__(self, message: str, *args: object) -&gt;None:
<span class="gd">-        super().__init__(message, *args, since=(2, 0), expected_removal=(3, 0))</span>
<span class="gi">+        super().__init__(message, *args, since=(2, 6), expected_removal=(3, 0))</span>


<span class="w"> </span>class GenericBeforeBaseModelWarning(Warning):
<span class="gh">diff --git a/tests/test_networks.py b/tests/test_networks.py</span>
<span class="gh">index dafa82c1..b3d15060 100644</span>
<span class="gd">--- a/tests/test_networks.py</span>
<span class="gi">+++ b/tests/test_networks.py</span>
<span class="gu">@@ -959,6 +959,46 @@ def test_email_validator_not_installed():</span>
<span class="w"> </span>        validate_email(&#39;s@muelcolvin.com&#39;)


<span class="gi">+@pytest.mark.skipif(not email_validator, reason=&#39;email_validator not installed&#39;)</span>
<span class="gi">+def test_validate_email():</span>
<span class="gi">+    assert validate_email(&#39;simple@example.com&#39;) == (&#39;simple&#39;, &#39;simple@example.com&#39;)</span>
<span class="gi">+    assert validate_email(&#39;very.common@example.com&#39;) == (&#39;very.common&#39;, &#39;very.common@example.com&#39;)</span>
<span class="gi">+    assert validate_email(&#39;disposable.style.email.with+symbol@example.com&#39;) == (&#39;disposable.style.email.with+symbol&#39;, &#39;disposable.style.email.with+symbol@example.com&#39;)</span>
<span class="gi">+    assert validate_email(&#39;other.email-with-hyphen@example.com&#39;) == (&#39;other.email-with-hyphen&#39;, &#39;other.email-with-hyphen@example.com&#39;)</span>
<span class="gi">+    assert validate_email(&#39;fully-qualified-domain@example.com&#39;) == (&#39;fully-qualified-domain&#39;, &#39;fully-qualified-domain@example.com&#39;)</span>
<span class="gi">+    assert validate_email(&#39;user.name+tag+sorting@example.com&#39;) == (&#39;user.name+tag+sorting&#39;, &#39;user.name+tag+sorting@example.com&#39;)</span>
<span class="gi">+    assert validate_email(&#39;x@example.com&#39;) == (&#39;x&#39;, &#39;x@example.com&#39;)</span>
<span class="gi">+    assert validate_email(&#39;example-indeed@strange-example.com&#39;) == (&#39;example-indeed&#39;, &#39;example-indeed@strange-example.com&#39;)</span>
<span class="gi">+    assert validate_email(&#39;example@s.example&#39;) == (&#39;example&#39;, &#39;example@s.example&#39;)</span>
<span class="gi">+    assert validate_email(&#39;&quot; &quot;@example.org&#39;) == (&#39;&quot; &quot;&#39;, &#39;&quot; &quot;@example.org&#39;)</span>
<span class="gi">+    assert validate_email(&#39;&quot;john..doe&quot;@example.org&#39;) == (&#39;&quot;john..doe&quot;&#39;, &#39;&quot;john..doe&quot;@example.org&#39;)</span>
<span class="gi">+    assert validate_email(&#39;mailhost!username@example.org&#39;) == (&#39;mailhost!username&#39;, &#39;mailhost!username@example.org&#39;)</span>
<span class="gi">+    assert validate_email(&#39;user%example.com@example.org&#39;) == (&#39;user%example.com&#39;, &#39;user%example.com@example.org&#39;)</span>
<span class="gi">+    assert validate_email(&#39;user-@example.org&#39;) == (&#39;user-&#39;, &#39;user-@example.org&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@pytest.mark.skipif(not email_validator, reason=&#39;email_validator not installed&#39;)</span>
<span class="gi">+def test_validate_email_with_name():</span>
<span class="gi">+    assert validate_email(&#39;John Doe &lt;johndoe@example.com&gt;&#39;) == (&#39;John Doe&#39;, &#39;johndoe@example.com&#39;)</span>
<span class="gi">+    assert validate_email(&#39;&quot;John Doe&quot; &lt;johndoe@example.com&gt;&#39;) == (&#39;John Doe&#39;, &#39;johndoe@example.com&#39;)</span>
<span class="gi">+    assert validate_email(&#39;John &quot;Johnny&quot; Doe &lt;johndoe@example.com&gt;&#39;) == (&#39;John &quot;Johnny&quot; Doe&#39;, &#39;johndoe@example.com&#39;)</span>
<span class="gi">+</span>
<span class="gi">+@pytest.mark.skipif(not email_validator, reason=&#39;email_validator not installed&#39;)</span>
<span class="gi">+def test_validate_email_errors():</span>
<span class="gi">+    with pytest.raises(PydanticCustomError, match=&#39;value is not a valid email address: The email address contains invalid characters before the @-sign&#39;):</span>
<span class="gi">+        validate_email(&#39;Abc.example.com&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    with pytest.raises(PydanticCustomError, match=&#39;value is not a valid email address: An email address must have an @-sign&#39;):</span>
<span class="gi">+        validate_email(&#39;A@b@c@example.com&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    with pytest.raises(PydanticCustomError, match=&#39;value is not a valid email address: The part after the @-sign is not valid&#39;):</span>
<span class="gi">+        validate_email(&#39;a&quot;b(c)d,e:f;g&lt;h&gt;i[j\k]l@example.com&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    with pytest.raises(PydanticCustomError, match=&#39;value is not a valid email address: There must be something before the @-sign&#39;):</span>
<span class="gi">+        validate_email(&#39;@example.com&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    with pytest.raises(PydanticCustomError, match=&#39;Email address is too long&#39;):</span>
<span class="gi">+        validate_email(&#39;a&#39; * 2000 + &#39;@example.com&#39;)</span>
<span class="gi">+</span>
<span class="w"> </span>@pytest.mark.skipif(not email_validator, reason=&#39;email_validator not installed&#39;)
<span class="w"> </span>def test_name_email():
<span class="w"> </span>    class Model(BaseModel):
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>