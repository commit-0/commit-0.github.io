
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all reference requests - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#reference-gold-requests" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all reference requests
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_requestspytestrequeststest_response_iter_lines_reentrant" class="md-nav__link">
    <span class="md-ellipsis">
      test_requests.py::TestRequests::test_response_iter_lines_reentrant
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0_all_reference">back to Reference (Gold) summary</a></p>
<h1 id="reference-gold-requests"><strong>Reference (Gold)</strong>: requests</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">590</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">15</td>
</tr>
<tr>
<td style="text-align: left;">xfailed</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">606</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">606</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_requestspytestrequeststest_response_iter_lines_reentrant">test_requests.py::TestRequests::test_response_iter_lines_reentrant</h3>
<details><summary> <pre>test_requests.py::TestRequests::test_response_iter_lines_reentrant</pre></summary><pre>
self = <tests.test_requests.TestRequests object at 0x7f535eb17fb0>
httpbin = <function prepare_url.<locals>.inner at 0x7f535da3cea0>

    @pytest.mark.xfail
    def test_response_iter_lines_reentrant(self, httpbin):
        """Response.iter_lines() is not reentrant safe"""
        r = requests.get(httpbin("stream/4"), stream=True)
        assert r.status_code == 200

        next(r.iter_lines())
>       assert len(list(r.iter_lines())) == 3
E       assert 2 == 3
E        +  where 2 = len([b'"http://127.0.0.1:51300/stream/4", "args": {}, "headers": {"Host": "127.0.0.1:51300", "User-Agent": "python-request..."Accept-Encoding": "gzip, deflate, br", "Accept": "*/*", "Connection": "keep-alive"}, "origin": "127.0.0.1", "id": 3}'])
E        +    where [b'"http://127.0.0.1:51300/stream/4", "args": {}, "headers": {"Host": "127.0.0.1:51300", "User-Agent": "python-request..."Accept-Encoding": "gzip, deflate, br", "Accept": "*/*", "Connection": "keep-alive"}, "origin": "127.0.0.1", "id": 3}'] = list(<generator object Response.iter_lines at 0x7f535d8fbc40>)
E        +      where <generator object Response.iter_lines at 0x7f535d8fbc40> = iter_lines()
E        +        where iter_lines = <Response [200]>.iter_lines

tests/test_requests.py:2112: AssertionError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/src/requests/__version__.py b/src/requests/__version__.py</span>
<span class="gh">index e2c6c146..2c105aca 100644</span>
<span class="gd">--- a/src/requests/__version__.py</span>
<span class="gi">+++ b/src/requests/__version__.py</span>
<span class="gu">@@ -1,10 +1,14 @@</span>
<span class="gd">-__title__ = &#39;requests&#39;</span>
<span class="gd">-__description__ = &#39;Python HTTP for Humans.&#39;</span>
<span class="gd">-__url__ = &#39;https://requests.readthedocs.io&#39;</span>
<span class="gd">-__version__ = &#39;2.32.3&#39;</span>
<span class="gd">-__build__ = 143875</span>
<span class="gd">-__author__ = &#39;Kenneth Reitz&#39;</span>
<span class="gd">-__author_email__ = &#39;me@kennethreitz.org&#39;</span>
<span class="gd">-__license__ = &#39;Apache-2.0&#39;</span>
<span class="gd">-__copyright__ = &#39;Copyright Kenneth Reitz&#39;</span>
<span class="gd">-__cake__ = &#39;‚ú® üç∞ ‚ú®&#39;</span>
<span class="gi">+# .-. .-. .-. . . .-. .-. .-. .-.</span>
<span class="gi">+# |(  |-  |.| | | |-  `-.  |  `-.</span>
<span class="gi">+# &#39; &#39; `-&#39; `-`.`-&#39; `-&#39; `-&#39;  &#39;  `-&#39;</span>
<span class="gi">+</span>
<span class="gi">+__title__ = &quot;requests&quot;</span>
<span class="gi">+__description__ = &quot;Python HTTP for Humans.&quot;</span>
<span class="gi">+__url__ = &quot;https://requests.readthedocs.io&quot;</span>
<span class="gi">+__version__ = &quot;2.32.3&quot;</span>
<span class="gi">+__build__ = 0x023203</span>
<span class="gi">+__author__ = &quot;Kenneth Reitz&quot;</span>
<span class="gi">+__author_email__ = &quot;me@kennethreitz.org&quot;</span>
<span class="gi">+__license__ = &quot;Apache-2.0&quot;</span>
<span class="gi">+__copyright__ = &quot;Copyright Kenneth Reitz&quot;</span>
<span class="gi">+__cake__ = &quot;\u2728 \U0001f370 \u2728&quot;</span>
<span class="gh">diff --git a/src/requests/_internal_utils.py b/src/requests/_internal_utils.py</span>
<span class="gh">index 4342cd14..f2cf635e 100644</span>
<span class="gd">--- a/src/requests/_internal_utils.py</span>
<span class="gi">+++ b/src/requests/_internal_utils.py</span>
<span class="gu">@@ -6,24 +6,33 @@ Provides utility functions that are consumed internally by Requests</span>
<span class="w"> </span>which depend on extremely few external helpers (such as compat)
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>import re
<span class="gi">+</span>
<span class="w"> </span>from .compat import builtin_str
<span class="gd">-_VALID_HEADER_NAME_RE_BYTE = re.compile(b&#39;^[^:\\s][^:\\r\\n]*$&#39;)</span>
<span class="gd">-_VALID_HEADER_NAME_RE_STR = re.compile(&#39;^[^:\\s][^:\\r\\n]*$&#39;)</span>
<span class="gd">-_VALID_HEADER_VALUE_RE_BYTE = re.compile(b&#39;^\\S[^\\r\\n]*$|^$&#39;)</span>
<span class="gd">-_VALID_HEADER_VALUE_RE_STR = re.compile(&#39;^\\S[^\\r\\n]*$|^$&#39;)</span>
<span class="gd">-_HEADER_VALIDATORS_STR = _VALID_HEADER_NAME_RE_STR, _VALID_HEADER_VALUE_RE_STR</span>
<span class="gd">-_HEADER_VALIDATORS_BYTE = (_VALID_HEADER_NAME_RE_BYTE,</span>
<span class="gd">-    _VALID_HEADER_VALUE_RE_BYTE)</span>
<span class="gd">-HEADER_VALIDATORS = {bytes: _HEADER_VALIDATORS_BYTE, str:</span>
<span class="gd">-    _HEADER_VALIDATORS_STR}</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gd">-def to_native_string(string, encoding=&#39;ascii&#39;):</span>
<span class="gi">+</span>
<span class="gi">+_VALID_HEADER_NAME_RE_BYTE = re.compile(rb&quot;^[^:\s][^:\r\n]*$&quot;)</span>
<span class="gi">+_VALID_HEADER_NAME_RE_STR = re.compile(r&quot;^[^:\s][^:\r\n]*$&quot;)</span>
<span class="gi">+_VALID_HEADER_VALUE_RE_BYTE = re.compile(rb&quot;^\S[^\r\n]*$|^$&quot;)</span>
<span class="gi">+_VALID_HEADER_VALUE_RE_STR = re.compile(r&quot;^\S[^\r\n]*$|^$&quot;)</span>
<span class="gi">+</span>
<span class="gi">+_HEADER_VALIDATORS_STR = (_VALID_HEADER_NAME_RE_STR, _VALID_HEADER_VALUE_RE_STR)</span>
<span class="gi">+_HEADER_VALIDATORS_BYTE = (_VALID_HEADER_NAME_RE_BYTE, _VALID_HEADER_VALUE_RE_BYTE)</span>
<span class="gi">+HEADER_VALIDATORS = {</span>
<span class="gi">+    bytes: _HEADER_VALIDATORS_BYTE,</span>
<span class="gi">+    str: _HEADER_VALIDATORS_STR,</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def to_native_string(string, encoding=&quot;ascii&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;Given a string object, regardless of type, returns a representation of
<span class="w"> </span>    that string in the native string type, encoding and decoding where
<span class="w"> </span>    necessary. This assumes ASCII unless told otherwise.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(string, builtin_str):</span>
<span class="gi">+        out = string</span>
<span class="gi">+    else:</span>
<span class="gi">+        out = string.decode(encoding)</span>
<span class="gi">+</span>
<span class="gi">+    return out</span>


<span class="w"> </span>def unicode_is_ascii(u_string):
<span class="gu">@@ -33,4 +42,9 @@ def unicode_is_ascii(u_string):</span>
<span class="w"> </span>        and not Python 2 `str`.
<span class="w"> </span>    :rtype: bool
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    assert isinstance(u_string, str)</span>
<span class="gi">+    try:</span>
<span class="gi">+        u_string.encode(&quot;ascii&quot;)</span>
<span class="gi">+        return True</span>
<span class="gi">+    except UnicodeEncodeError:</span>
<span class="gi">+        return False</span>
<span class="gh">diff --git a/src/requests/adapters.py b/src/requests/adapters.py</span>
<span class="gh">index 57d9ddf8..9a58b160 100644</span>
<span class="gd">--- a/src/requests/adapters.py</span>
<span class="gi">+++ b/src/requests/adapters.py</span>
<span class="gu">@@ -5,14 +5,21 @@ requests.adapters</span>
<span class="w"> </span>This module contains the transport adapters that Requests uses to define
<span class="w"> </span>and maintain connections.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import os.path
<span class="gd">-import socket</span>
<span class="gi">+import socket  # noqa: F401</span>
<span class="w"> </span>import typing
<span class="w"> </span>import warnings
<span class="gi">+</span>
<span class="w"> </span>from urllib3.exceptions import ClosedPoolError, ConnectTimeoutError
<span class="w"> </span>from urllib3.exceptions import HTTPError as _HTTPError
<span class="w"> </span>from urllib3.exceptions import InvalidHeader as _InvalidHeader
<span class="gd">-from urllib3.exceptions import LocationValueError, MaxRetryError, NewConnectionError, ProtocolError</span>
<span class="gi">+from urllib3.exceptions import (</span>
<span class="gi">+    LocationValueError,</span>
<span class="gi">+    MaxRetryError,</span>
<span class="gi">+    NewConnectionError,</span>
<span class="gi">+    ProtocolError,</span>
<span class="gi">+)</span>
<span class="w"> </span>from urllib3.exceptions import ProxyError as _ProxyError
<span class="w"> </span>from urllib3.exceptions import ReadTimeoutError, ResponseError
<span class="w"> </span>from urllib3.exceptions import SSLError as _SSLError
<span class="gu">@@ -21,39 +28,121 @@ from urllib3.util import Timeout as TimeoutSauce</span>
<span class="w"> </span>from urllib3.util import parse_url
<span class="w"> </span>from urllib3.util.retry import Retry
<span class="w"> </span>from urllib3.util.ssl_ import create_urllib3_context
<span class="gi">+</span>
<span class="w"> </span>from .auth import _basic_auth_str
<span class="w"> </span>from .compat import basestring, urlparse
<span class="w"> </span>from .cookies import extract_cookies_to_jar
<span class="gd">-from .exceptions import ConnectionError, ConnectTimeout, InvalidHeader, InvalidProxyURL, InvalidSchema, InvalidURL, ProxyError, ReadTimeout, RetryError, SSLError</span>
<span class="gi">+from .exceptions import (</span>
<span class="gi">+    ConnectionError,</span>
<span class="gi">+    ConnectTimeout,</span>
<span class="gi">+    InvalidHeader,</span>
<span class="gi">+    InvalidProxyURL,</span>
<span class="gi">+    InvalidSchema,</span>
<span class="gi">+    InvalidURL,</span>
<span class="gi">+    ProxyError,</span>
<span class="gi">+    ReadTimeout,</span>
<span class="gi">+    RetryError,</span>
<span class="gi">+    SSLError,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .models import Response
<span class="w"> </span>from .structures import CaseInsensitiveDict
<span class="gd">-from .utils import DEFAULT_CA_BUNDLE_PATH, extract_zipped_paths, get_auth_from_url, get_encoding_from_headers, prepend_scheme_if_needed, select_proxy, urldefragauth</span>
<span class="gi">+from .utils import (</span>
<span class="gi">+    DEFAULT_CA_BUNDLE_PATH,</span>
<span class="gi">+    extract_zipped_paths,</span>
<span class="gi">+    get_auth_from_url,</span>
<span class="gi">+    get_encoding_from_headers,</span>
<span class="gi">+    prepend_scheme_if_needed,</span>
<span class="gi">+    select_proxy,</span>
<span class="gi">+    urldefragauth,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    from urllib3.contrib.socks import SOCKSProxyManager
<span class="w"> </span>except ImportError:
<span class="gi">+</span>
<span class="gi">+    def SOCKSProxyManager(*args, **kwargs):</span>
<span class="gi">+        raise InvalidSchema(&quot;Missing dependencies for SOCKS support.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="w"> </span>    from .models import PreparedRequest
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>DEFAULT_POOLBLOCK = False
<span class="w"> </span>DEFAULT_POOLSIZE = 10
<span class="w"> </span>DEFAULT_RETRIES = 0
<span class="w"> </span>DEFAULT_POOL_TIMEOUT = None
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="gd">-    import ssl</span>
<span class="gi">+    import ssl  # noqa: F401</span>
<span class="gi">+</span>
<span class="w"> </span>    _preloaded_ssl_context = create_urllib3_context()
<span class="gd">-    _preloaded_ssl_context.load_verify_locations(extract_zipped_paths(</span>
<span class="gd">-        DEFAULT_CA_BUNDLE_PATH))</span>
<span class="gi">+    _preloaded_ssl_context.load_verify_locations(</span>
<span class="gi">+        extract_zipped_paths(DEFAULT_CA_BUNDLE_PATH)</span>
<span class="gi">+    )</span>
<span class="w"> </span>except ImportError:
<span class="gi">+    # Bypass default SSLContext creation when Python</span>
<span class="gi">+    # interpreter isn&#39;t built with the ssl module.</span>
<span class="w"> </span>    _preloaded_ssl_context = None


<span class="gi">+def _urllib3_request_context(</span>
<span class="gi">+    request: &quot;PreparedRequest&quot;,</span>
<span class="gi">+    verify: &quot;bool | str | None&quot;,</span>
<span class="gi">+    client_cert: &quot;typing.Tuple[str, str] | str | None&quot;,</span>
<span class="gi">+    poolmanager: &quot;PoolManager&quot;,</span>
<span class="gi">+) -&gt; &quot;(typing.Dict[str, typing.Any], typing.Dict[str, typing.Any])&quot;:</span>
<span class="gi">+    host_params = {}</span>
<span class="gi">+    pool_kwargs = {}</span>
<span class="gi">+    parsed_request_url = urlparse(request.url)</span>
<span class="gi">+    scheme = parsed_request_url.scheme.lower()</span>
<span class="gi">+    port = parsed_request_url.port</span>
<span class="gi">+</span>
<span class="gi">+    # Determine if we have and should use our default SSLContext</span>
<span class="gi">+    # to optimize performance on standard requests.</span>
<span class="gi">+    poolmanager_kwargs = getattr(poolmanager, &quot;connection_pool_kw&quot;, {})</span>
<span class="gi">+    has_poolmanager_ssl_context = poolmanager_kwargs.get(&quot;ssl_context&quot;)</span>
<span class="gi">+    should_use_default_ssl_context = (</span>
<span class="gi">+        _preloaded_ssl_context is not None and not has_poolmanager_ssl_context</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    cert_reqs = &quot;CERT_REQUIRED&quot;</span>
<span class="gi">+    if verify is False:</span>
<span class="gi">+        cert_reqs = &quot;CERT_NONE&quot;</span>
<span class="gi">+    elif verify is True and should_use_default_ssl_context:</span>
<span class="gi">+        pool_kwargs[&quot;ssl_context&quot;] = _preloaded_ssl_context</span>
<span class="gi">+    elif isinstance(verify, str):</span>
<span class="gi">+        if not os.path.isdir(verify):</span>
<span class="gi">+            pool_kwargs[&quot;ca_certs&quot;] = verify</span>
<span class="gi">+        else:</span>
<span class="gi">+            pool_kwargs[&quot;ca_cert_dir&quot;] = verify</span>
<span class="gi">+    pool_kwargs[&quot;cert_reqs&quot;] = cert_reqs</span>
<span class="gi">+    if client_cert is not None:</span>
<span class="gi">+        if isinstance(client_cert, tuple) and len(client_cert) == 2:</span>
<span class="gi">+            pool_kwargs[&quot;cert_file&quot;] = client_cert[0]</span>
<span class="gi">+            pool_kwargs[&quot;key_file&quot;] = client_cert[1]</span>
<span class="gi">+        else:</span>
<span class="gi">+            # According to our docs, we allow users to specify just the client</span>
<span class="gi">+            # cert path</span>
<span class="gi">+            pool_kwargs[&quot;cert_file&quot;] = client_cert</span>
<span class="gi">+    host_params = {</span>
<span class="gi">+        &quot;scheme&quot;: scheme,</span>
<span class="gi">+        &quot;host&quot;: parsed_request_url.hostname,</span>
<span class="gi">+        &quot;port&quot;: port,</span>
<span class="gi">+    }</span>
<span class="gi">+    return host_params, pool_kwargs</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class BaseAdapter:
<span class="w"> </span>    &quot;&quot;&quot;The Base Transport Adapter&quot;&quot;&quot;

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        super().__init__()

<span class="gd">-    def send(self, request, stream=False, timeout=None, verify=True, cert=</span>
<span class="gd">-        None, proxies=None):</span>
<span class="gi">+    def send(</span>
<span class="gi">+        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.

<span class="w"> </span>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
<span class="gu">@@ -68,11 +157,11 @@ class BaseAdapter:</span>
<span class="w"> </span>        :param cert: (optional) Any user-provided SSL certificate to be trusted.
<span class="w"> </span>        :param proxies: (optional) The proxies dictionary to apply to the request.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;Cleans up adapter specific items.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError</span>


<span class="w"> </span>class HTTPAdapter(BaseAdapter):
<span class="gu">@@ -101,37 +190,56 @@ class HTTPAdapter(BaseAdapter):</span>
<span class="w"> </span>      &gt;&gt;&gt; a = requests.adapters.HTTPAdapter(max_retries=3)
<span class="w"> </span>      &gt;&gt;&gt; s.mount(&#39;http://&#39;, a)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __attrs__ = [&#39;max_retries&#39;, &#39;config&#39;, &#39;_pool_connections&#39;,</span>
<span class="gd">-        &#39;_pool_maxsize&#39;, &#39;_pool_block&#39;]</span>

<span class="gd">-    def __init__(self, pool_connections=DEFAULT_POOLSIZE, pool_maxsize=</span>
<span class="gd">-        DEFAULT_POOLSIZE, max_retries=DEFAULT_RETRIES, pool_block=</span>
<span class="gd">-        DEFAULT_POOLBLOCK):</span>
<span class="gi">+    __attrs__ = [</span>
<span class="gi">+        &quot;max_retries&quot;,</span>
<span class="gi">+        &quot;config&quot;,</span>
<span class="gi">+        &quot;_pool_connections&quot;,</span>
<span class="gi">+        &quot;_pool_maxsize&quot;,</span>
<span class="gi">+        &quot;_pool_block&quot;,</span>
<span class="gi">+    ]</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        pool_connections=DEFAULT_POOLSIZE,</span>
<span class="gi">+        pool_maxsize=DEFAULT_POOLSIZE,</span>
<span class="gi">+        max_retries=DEFAULT_RETRIES,</span>
<span class="gi">+        pool_block=DEFAULT_POOLBLOCK,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        if max_retries == DEFAULT_RETRIES:
<span class="w"> </span>            self.max_retries = Retry(0, read=False)
<span class="w"> </span>        else:
<span class="w"> </span>            self.max_retries = Retry.from_int(max_retries)
<span class="w"> </span>        self.config = {}
<span class="w"> </span>        self.proxy_manager = {}
<span class="gi">+</span>
<span class="w"> </span>        super().__init__()
<span class="gi">+</span>
<span class="w"> </span>        self._pool_connections = pool_connections
<span class="w"> </span>        self._pool_maxsize = pool_maxsize
<span class="w"> </span>        self._pool_block = pool_block
<span class="gi">+</span>
<span class="w"> </span>        self.init_poolmanager(pool_connections, pool_maxsize, block=pool_block)

<span class="w"> </span>    def __getstate__(self):
<span class="w"> </span>        return {attr: getattr(self, attr, None) for attr in self.__attrs__}

<span class="w"> </span>    def __setstate__(self, state):
<span class="gi">+        # Can&#39;t handle by adding &#39;proxy_manager&#39; to self.__attrs__ because</span>
<span class="gi">+        # self.poolmanager uses a lambda function, which isn&#39;t pickleable.</span>
<span class="w"> </span>        self.proxy_manager = {}
<span class="w"> </span>        self.config = {}
<span class="gi">+</span>
<span class="w"> </span>        for attr, value in state.items():
<span class="w"> </span>            setattr(self, attr, value)
<span class="gd">-        self.init_poolmanager(self._pool_connections, self._pool_maxsize,</span>
<span class="gd">-            block=self._pool_block)</span>

<span class="gd">-    def init_poolmanager(self, connections, maxsize, block=</span>
<span class="gd">-        DEFAULT_POOLBLOCK, **pool_kwargs):</span>
<span class="gi">+        self.init_poolmanager(</span>
<span class="gi">+            self._pool_connections, self._pool_maxsize, block=self._pool_block</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def init_poolmanager(</span>
<span class="gi">+        self, connections, maxsize, block=DEFAULT_POOLBLOCK, **pool_kwargs</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Initializes a urllib3 PoolManager.

<span class="w"> </span>        This method should not be called from user code, and is only
<span class="gu">@@ -143,7 +251,17 @@ class HTTPAdapter(BaseAdapter):</span>
<span class="w"> </span>        :param block: Block when no free connections are available.
<span class="w"> </span>        :param pool_kwargs: Extra keyword arguments used to initialize the Pool Manager.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # save these values for pickling</span>
<span class="gi">+        self._pool_connections = connections</span>
<span class="gi">+        self._pool_maxsize = maxsize</span>
<span class="gi">+        self._pool_block = block</span>
<span class="gi">+</span>
<span class="gi">+        self.poolmanager = PoolManager(</span>
<span class="gi">+            num_pools=connections,</span>
<span class="gi">+            maxsize=maxsize,</span>
<span class="gi">+            block=block,</span>
<span class="gi">+            **pool_kwargs,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def proxy_manager_for(self, proxy, **proxy_kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Return urllib3 ProxyManager for the given proxy.
<span class="gu">@@ -157,7 +275,31 @@ class HTTPAdapter(BaseAdapter):</span>
<span class="w"> </span>        :returns: ProxyManager
<span class="w"> </span>        :rtype: urllib3.ProxyManager
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if proxy in self.proxy_manager:</span>
<span class="gi">+            manager = self.proxy_manager[proxy]</span>
<span class="gi">+        elif proxy.lower().startswith(&quot;socks&quot;):</span>
<span class="gi">+            username, password = get_auth_from_url(proxy)</span>
<span class="gi">+            manager = self.proxy_manager[proxy] = SOCKSProxyManager(</span>
<span class="gi">+                proxy,</span>
<span class="gi">+                username=username,</span>
<span class="gi">+                password=password,</span>
<span class="gi">+                num_pools=self._pool_connections,</span>
<span class="gi">+                maxsize=self._pool_maxsize,</span>
<span class="gi">+                block=self._pool_block,</span>
<span class="gi">+                **proxy_kwargs,</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            proxy_headers = self.proxy_headers(proxy)</span>
<span class="gi">+            manager = self.proxy_manager[proxy] = proxy_from_url(</span>
<span class="gi">+                proxy,</span>
<span class="gi">+                proxy_headers=proxy_headers,</span>
<span class="gi">+                num_pools=self._pool_connections,</span>
<span class="gi">+                maxsize=self._pool_maxsize,</span>
<span class="gi">+                block=self._pool_block,</span>
<span class="gi">+                **proxy_kwargs,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return manager</span>

<span class="w"> </span>    def cert_verify(self, conn, url, verify, cert):
<span class="w"> </span>        &quot;&quot;&quot;Verify a SSL certificate. This method should not be called from user
<span class="gu">@@ -171,7 +313,48 @@ class HTTPAdapter(BaseAdapter):</span>
<span class="w"> </span>            to a CA bundle to use
<span class="w"> </span>        :param cert: The SSL certificate to verify.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if url.lower().startswith(&quot;https&quot;) and verify:</span>
<span class="gi">+            conn.cert_reqs = &quot;CERT_REQUIRED&quot;</span>
<span class="gi">+</span>
<span class="gi">+            # Only load the CA certificates if &#39;verify&#39; is a string indicating the CA bundle to use.</span>
<span class="gi">+            # Otherwise, if verify is a boolean, we don&#39;t load anything since</span>
<span class="gi">+            # the connection will be using a context with the default certificates already loaded,</span>
<span class="gi">+            # and this avoids a call to the slow load_verify_locations()</span>
<span class="gi">+            if verify is not True:</span>
<span class="gi">+                # `verify` must be a str with a path then</span>
<span class="gi">+                cert_loc = verify</span>
<span class="gi">+</span>
<span class="gi">+                if not os.path.exists(cert_loc):</span>
<span class="gi">+                    raise OSError(</span>
<span class="gi">+                        f&quot;Could not find a suitable TLS CA certificate bundle, &quot;</span>
<span class="gi">+                        f&quot;invalid path: {cert_loc}&quot;</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+                if not os.path.isdir(cert_loc):</span>
<span class="gi">+                    conn.ca_certs = cert_loc</span>
<span class="gi">+                else:</span>
<span class="gi">+                    conn.ca_cert_dir = cert_loc</span>
<span class="gi">+        else:</span>
<span class="gi">+            conn.cert_reqs = &quot;CERT_NONE&quot;</span>
<span class="gi">+            conn.ca_certs = None</span>
<span class="gi">+            conn.ca_cert_dir = None</span>
<span class="gi">+</span>
<span class="gi">+        if cert:</span>
<span class="gi">+            if not isinstance(cert, basestring):</span>
<span class="gi">+                conn.cert_file = cert[0]</span>
<span class="gi">+                conn.key_file = cert[1]</span>
<span class="gi">+            else:</span>
<span class="gi">+                conn.cert_file = cert</span>
<span class="gi">+                conn.key_file = None</span>
<span class="gi">+            if conn.cert_file and not os.path.exists(conn.cert_file):</span>
<span class="gi">+                raise OSError(</span>
<span class="gi">+                    f&quot;Could not find the TLS certificate file, &quot;</span>
<span class="gi">+                    f&quot;invalid path: {conn.cert_file}&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            if conn.key_file and not os.path.exists(conn.key_file):</span>
<span class="gi">+                raise OSError(</span>
<span class="gi">+                    f&quot;Could not find the TLS key file, invalid path: {conn.key_file}&quot;</span>
<span class="gi">+                )</span>

<span class="w"> </span>    def build_response(self, req, resp):
<span class="w"> </span>        &quot;&quot;&quot;Builds a :class:`Response &lt;requests.Response&gt;` object from a urllib3
<span class="gu">@@ -183,7 +366,32 @@ class HTTPAdapter(BaseAdapter):</span>
<span class="w"> </span>        :param resp: The urllib3 response object.
<span class="w"> </span>        :rtype: requests.Response
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        response = Response()</span>
<span class="gi">+</span>
<span class="gi">+        # Fallback to None if there&#39;s no status_code, for whatever reason.</span>
<span class="gi">+        response.status_code = getattr(resp, &quot;status&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+        # Make headers case-insensitive.</span>
<span class="gi">+        response.headers = CaseInsensitiveDict(getattr(resp, &quot;headers&quot;, {}))</span>
<span class="gi">+</span>
<span class="gi">+        # Set encoding.</span>
<span class="gi">+        response.encoding = get_encoding_from_headers(response.headers)</span>
<span class="gi">+        response.raw = resp</span>
<span class="gi">+        response.reason = response.raw.reason</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(req.url, bytes):</span>
<span class="gi">+            response.url = req.url.decode(&quot;utf-8&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            response.url = req.url</span>
<span class="gi">+</span>
<span class="gi">+        # Add new cookies from the server.</span>
<span class="gi">+        extract_cookies_to_jar(response.cookies, req, resp)</span>
<span class="gi">+</span>
<span class="gi">+        # Give the Response some context.</span>
<span class="gi">+        response.request = req</span>
<span class="gi">+        response.connection = self</span>
<span class="gi">+</span>
<span class="gi">+        return response</span>

<span class="w"> </span>    def build_connection_pool_key_attributes(self, request, verify, cert=None):
<span class="w"> </span>        &quot;&quot;&quot;Build the PoolKey attributes used by urllib3 to return a connection.
<span class="gu">@@ -233,10 +441,9 @@ class HTTPAdapter(BaseAdapter):</span>
<span class="w"> </span>            portion of the Pool Key including scheme, hostname, and port. The
<span class="w"> </span>            second is a dictionary of SSLContext related parameters.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return _urllib3_request_context(request, verify, cert, self.poolmanager)</span>

<span class="gd">-    def get_connection_with_tls_context(self, request, verify, proxies=None,</span>
<span class="gd">-        cert=None):</span>
<span class="gi">+    def get_connection_with_tls_context(self, request, verify, proxies=None, cert=None):</span>
<span class="w"> </span>        &quot;&quot;&quot;Returns a urllib3 connection for the given request and TLS settings.
<span class="w"> </span>        This should not be called from user code, and is only exposed for use
<span class="w"> </span>        when subclassing the :class:`HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;`.
<span class="gu">@@ -256,7 +463,34 @@ class HTTPAdapter(BaseAdapter):</span>
<span class="w"> </span>        :rtype:
<span class="w"> </span>            urllib3.ConnectionPool
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        proxy = select_proxy(request.url, proxies)</span>
<span class="gi">+        try:</span>
<span class="gi">+            host_params, pool_kwargs = self.build_connection_pool_key_attributes(</span>
<span class="gi">+                request,</span>
<span class="gi">+                verify,</span>
<span class="gi">+                cert,</span>
<span class="gi">+            )</span>
<span class="gi">+        except ValueError as e:</span>
<span class="gi">+            raise InvalidURL(e, request=request)</span>
<span class="gi">+        if proxy:</span>
<span class="gi">+            proxy = prepend_scheme_if_needed(proxy, &quot;http&quot;)</span>
<span class="gi">+            proxy_url = parse_url(proxy)</span>
<span class="gi">+            if not proxy_url.host:</span>
<span class="gi">+                raise InvalidProxyURL(</span>
<span class="gi">+                    &quot;Please check proxy URL. It is malformed &quot;</span>
<span class="gi">+                    &quot;and could be missing the host.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            proxy_manager = self.proxy_manager_for(proxy)</span>
<span class="gi">+            conn = proxy_manager.connection_from_host(</span>
<span class="gi">+                **host_params, pool_kwargs=pool_kwargs</span>
<span class="gi">+            )</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Only scheme should be lower case</span>
<span class="gi">+            conn = self.poolmanager.connection_from_host(</span>
<span class="gi">+                **host_params, pool_kwargs=pool_kwargs</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return conn</span>

<span class="w"> </span>    def get_connection(self, url, proxies=None):
<span class="w"> </span>        &quot;&quot;&quot;DEPRECATED: Users should move to `get_connection_with_tls_context`
<span class="gu">@@ -270,7 +504,34 @@ class HTTPAdapter(BaseAdapter):</span>
<span class="w"> </span>        :param proxies: (optional) A Requests-style dictionary of proxies used on this request.
<span class="w"> </span>        :rtype: urllib3.ConnectionPool
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            (</span>
<span class="gi">+                &quot;`get_connection` has been deprecated in favor of &quot;</span>
<span class="gi">+                &quot;`get_connection_with_tls_context`. Custom HTTPAdapter subclasses &quot;</span>
<span class="gi">+                &quot;will need to migrate for Requests&gt;=2.32.2. Please see &quot;</span>
<span class="gi">+                &quot;https://github.com/psf/requests/pull/6710 for more details.&quot;</span>
<span class="gi">+            ),</span>
<span class="gi">+            DeprecationWarning,</span>
<span class="gi">+        )</span>
<span class="gi">+        proxy = select_proxy(url, proxies)</span>
<span class="gi">+</span>
<span class="gi">+        if proxy:</span>
<span class="gi">+            proxy = prepend_scheme_if_needed(proxy, &quot;http&quot;)</span>
<span class="gi">+            proxy_url = parse_url(proxy)</span>
<span class="gi">+            if not proxy_url.host:</span>
<span class="gi">+                raise InvalidProxyURL(</span>
<span class="gi">+                    &quot;Please check proxy URL. It is malformed &quot;</span>
<span class="gi">+                    &quot;and could be missing the host.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+            proxy_manager = self.proxy_manager_for(proxy)</span>
<span class="gi">+            conn = proxy_manager.connection_from_url(url)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Only scheme should be lower case</span>
<span class="gi">+            parsed = urlparse(url)</span>
<span class="gi">+            url = parsed.geturl()</span>
<span class="gi">+            conn = self.poolmanager.connection_from_url(url)</span>
<span class="gi">+</span>
<span class="gi">+        return conn</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;Disposes of any internal state.
<span class="gu">@@ -278,7 +539,9 @@ class HTTPAdapter(BaseAdapter):</span>
<span class="w"> </span>        Currently, this closes the PoolManager and any active ProxyManager,
<span class="w"> </span>        which closes any pooled connections.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.poolmanager.clear()</span>
<span class="gi">+        for proxy in self.proxy_manager.values():</span>
<span class="gi">+            proxy.clear()</span>

<span class="w"> </span>    def request_url(self, request, proxies):
<span class="w"> </span>        &quot;&quot;&quot;Obtain the url to use when making the final request.
<span class="gu">@@ -294,7 +557,23 @@ class HTTPAdapter(BaseAdapter):</span>
<span class="w"> </span>        :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs.
<span class="w"> </span>        :rtype: str
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        proxy = select_proxy(request.url, proxies)</span>
<span class="gi">+        scheme = urlparse(request.url).scheme</span>
<span class="gi">+</span>
<span class="gi">+        is_proxied_http_request = proxy and scheme != &quot;https&quot;</span>
<span class="gi">+        using_socks_proxy = False</span>
<span class="gi">+        if proxy:</span>
<span class="gi">+            proxy_scheme = urlparse(proxy).scheme.lower()</span>
<span class="gi">+            using_socks_proxy = proxy_scheme.startswith(&quot;socks&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        url = request.path_url</span>
<span class="gi">+        if url.startswith(&quot;//&quot;):  # Don&#39;t confuse urllib3</span>
<span class="gi">+            url = f&quot;/{url.lstrip(&#39;/&#39;)}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if is_proxied_http_request and not using_socks_proxy:</span>
<span class="gi">+            url = urldefragauth(request.url)</span>
<span class="gi">+</span>
<span class="gi">+        return url</span>

<span class="w"> </span>    def add_headers(self, request, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Add any headers needed by the connection. As of v2.0 this does
<span class="gu">@@ -323,10 +602,17 @@ class HTTPAdapter(BaseAdapter):</span>
<span class="w"> </span>        :param proxy: The url of the proxy being used for this request.
<span class="w"> </span>        :rtype: dict
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        headers = {}</span>
<span class="gi">+        username, password = get_auth_from_url(proxy)</span>
<span class="gi">+</span>
<span class="gi">+        if username:</span>
<span class="gi">+            headers[&quot;Proxy-Authorization&quot;] = _basic_auth_str(username, password)</span>
<span class="gi">+</span>
<span class="gi">+        return headers</span>

<span class="gd">-    def send(self, request, stream=False, timeout=None, verify=True, cert=</span>
<span class="gd">-        None, proxies=None):</span>
<span class="gi">+    def send(</span>
<span class="gi">+        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Sends PreparedRequest object. Returns Response object.

<span class="w"> </span>        :param request: The :class:`PreparedRequest &lt;PreparedRequest&gt;` being sent.
<span class="gu">@@ -342,4 +628,92 @@ class HTTPAdapter(BaseAdapter):</span>
<span class="w"> </span>        :param proxies: (optional) The proxies dictionary to apply to the request.
<span class="w"> </span>        :rtype: requests.Response
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            conn = self.get_connection_with_tls_context(</span>
<span class="gi">+                request, verify, proxies=proxies, cert=cert</span>
<span class="gi">+            )</span>
<span class="gi">+        except LocationValueError as e:</span>
<span class="gi">+            raise InvalidURL(e, request=request)</span>
<span class="gi">+</span>
<span class="gi">+        self.cert_verify(conn, request.url, verify, cert)</span>
<span class="gi">+        url = self.request_url(request, proxies)</span>
<span class="gi">+        self.add_headers(</span>
<span class="gi">+            request,</span>
<span class="gi">+            stream=stream,</span>
<span class="gi">+            timeout=timeout,</span>
<span class="gi">+            verify=verify,</span>
<span class="gi">+            cert=cert,</span>
<span class="gi">+            proxies=proxies,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        chunked = not (request.body is None or &quot;Content-Length&quot; in request.headers)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(timeout, tuple):</span>
<span class="gi">+            try:</span>
<span class="gi">+                connect, read = timeout</span>
<span class="gi">+                timeout = TimeoutSauce(connect=connect, read=read)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                raise ValueError(</span>
<span class="gi">+                    f&quot;Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, &quot;</span>
<span class="gi">+                    f&quot;or a single float to set both timeouts to the same value.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+        elif isinstance(timeout, TimeoutSauce):</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            timeout = TimeoutSauce(connect=timeout, read=timeout)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            resp = conn.urlopen(</span>
<span class="gi">+                method=request.method,</span>
<span class="gi">+                url=url,</span>
<span class="gi">+                body=request.body,</span>
<span class="gi">+                headers=request.headers,</span>
<span class="gi">+                redirect=False,</span>
<span class="gi">+                assert_same_host=False,</span>
<span class="gi">+                preload_content=False,</span>
<span class="gi">+                decode_content=False,</span>
<span class="gi">+                retries=self.max_retries,</span>
<span class="gi">+                timeout=timeout,</span>
<span class="gi">+                chunked=chunked,</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        except (ProtocolError, OSError) as err:</span>
<span class="gi">+            raise ConnectionError(err, request=request)</span>
<span class="gi">+</span>
<span class="gi">+        except MaxRetryError as e:</span>
<span class="gi">+            if isinstance(e.reason, ConnectTimeoutError):</span>
<span class="gi">+                # TODO: Remove this in 3.0.0: see #2811</span>
<span class="gi">+                if not isinstance(e.reason, NewConnectionError):</span>
<span class="gi">+                    raise ConnectTimeout(e, request=request)</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(e.reason, ResponseError):</span>
<span class="gi">+                raise RetryError(e, request=request)</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(e.reason, _ProxyError):</span>
<span class="gi">+                raise ProxyError(e, request=request)</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(e.reason, _SSLError):</span>
<span class="gi">+                # This branch is for urllib3 v1.22 and later.</span>
<span class="gi">+                raise SSLError(e, request=request)</span>
<span class="gi">+</span>
<span class="gi">+            raise ConnectionError(e, request=request)</span>
<span class="gi">+</span>
<span class="gi">+        except ClosedPoolError as e:</span>
<span class="gi">+            raise ConnectionError(e, request=request)</span>
<span class="gi">+</span>
<span class="gi">+        except _ProxyError as e:</span>
<span class="gi">+            raise ProxyError(e)</span>
<span class="gi">+</span>
<span class="gi">+        except (_SSLError, _HTTPError) as e:</span>
<span class="gi">+            if isinstance(e, _SSLError):</span>
<span class="gi">+                # This branch is for urllib3 versions earlier than v1.22</span>
<span class="gi">+                raise SSLError(e, request=request)</span>
<span class="gi">+            elif isinstance(e, ReadTimeoutError):</span>
<span class="gi">+                raise ReadTimeout(e, request=request)</span>
<span class="gi">+            elif isinstance(e, _InvalidHeader):</span>
<span class="gi">+                raise InvalidHeader(e, request=request)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise</span>
<span class="gi">+</span>
<span class="gi">+        return self.build_response(request, resp)</span>
<span class="gh">diff --git a/src/requests/api.py b/src/requests/api.py</span>
<span class="gh">index 73f1b784..59607445 100644</span>
<span class="gd">--- a/src/requests/api.py</span>
<span class="gi">+++ b/src/requests/api.py</span>
<span class="gu">@@ -7,6 +7,7 @@ This module implements the Requests API.</span>
<span class="w"> </span>:copyright: (c) 2012 by Kenneth Reitz.
<span class="w"> </span>:license: Apache2, see LICENSE for more details.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from . import sessions


<span class="gu">@@ -50,94 +51,107 @@ def request(method, url, **kwargs):</span>
<span class="w"> </span>      &gt;&gt;&gt; req
<span class="w"> </span>      &lt;Response [200]&gt;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    # By using the &#39;with&#39; statement we are sure the session is closed, thus we</span>
<span class="gi">+    # avoid leaving sockets open which can trigger a ResourceWarning in some</span>
<span class="gi">+    # cases, and look like a memory leak in others.</span>
<span class="gi">+    with sessions.Session() as session:</span>
<span class="gi">+        return session.request(method=method, url=url, **kwargs)</span>


<span class="w"> </span>def get(url, params=None, **kwargs):
<span class="gd">-    &quot;&quot;&quot;Sends a GET request.</span>
<span class="gi">+    r&quot;&quot;&quot;Sends a GET request.</span>

<span class="w"> </span>    :param url: URL for the new :class:`Request` object.
<span class="w"> </span>    :param params: (optional) Dictionary, list of tuples or bytes to send
<span class="w"> </span>        in the query string for the :class:`Request`.
<span class="gd">-    :param \\*\\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="gi">+    :param \*\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="w"> </span>    :return: :class:`Response &lt;Response&gt;` object
<span class="w"> </span>    :rtype: requests.Response
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return request(&quot;get&quot;, url, params=params, **kwargs)</span>


<span class="w"> </span>def options(url, **kwargs):
<span class="gd">-    &quot;&quot;&quot;Sends an OPTIONS request.</span>
<span class="gi">+    r&quot;&quot;&quot;Sends an OPTIONS request.</span>

<span class="w"> </span>    :param url: URL for the new :class:`Request` object.
<span class="gd">-    :param \\*\\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="gi">+    :param \*\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="w"> </span>    :return: :class:`Response &lt;Response&gt;` object
<span class="w"> </span>    :rtype: requests.Response
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return request(&quot;options&quot;, url, **kwargs)</span>


<span class="w"> </span>def head(url, **kwargs):
<span class="gd">-    &quot;&quot;&quot;Sends a HEAD request.</span>
<span class="gi">+    r&quot;&quot;&quot;Sends a HEAD request.</span>

<span class="w"> </span>    :param url: URL for the new :class:`Request` object.
<span class="gd">-    :param \\*\\*kwargs: Optional arguments that ``request`` takes. If</span>
<span class="gi">+    :param \*\*kwargs: Optional arguments that ``request`` takes. If</span>
<span class="w"> </span>        `allow_redirects` is not provided, it will be set to `False` (as
<span class="w"> </span>        opposed to the default :meth:`request` behavior).
<span class="w"> </span>    :return: :class:`Response &lt;Response&gt;` object
<span class="w"> </span>    :rtype: requests.Response
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    kwargs.setdefault(&quot;allow_redirects&quot;, False)</span>
<span class="gi">+    return request(&quot;head&quot;, url, **kwargs)</span>


<span class="w"> </span>def post(url, data=None, json=None, **kwargs):
<span class="gd">-    &quot;&quot;&quot;Sends a POST request.</span>
<span class="gi">+    r&quot;&quot;&quot;Sends a POST request.</span>

<span class="w"> </span>    :param url: URL for the new :class:`Request` object.
<span class="w"> </span>    :param data: (optional) Dictionary, list of tuples, bytes, or file-like
<span class="w"> </span>        object to send in the body of the :class:`Request`.
<span class="w"> </span>    :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.
<span class="gd">-    :param \\*\\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="gi">+    :param \*\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="w"> </span>    :return: :class:`Response &lt;Response&gt;` object
<span class="w"> </span>    :rtype: requests.Response
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return request(&quot;post&quot;, url, data=data, json=json, **kwargs)</span>


<span class="w"> </span>def put(url, data=None, **kwargs):
<span class="gd">-    &quot;&quot;&quot;Sends a PUT request.</span>
<span class="gi">+    r&quot;&quot;&quot;Sends a PUT request.</span>

<span class="w"> </span>    :param url: URL for the new :class:`Request` object.
<span class="w"> </span>    :param data: (optional) Dictionary, list of tuples, bytes, or file-like
<span class="w"> </span>        object to send in the body of the :class:`Request`.
<span class="w"> </span>    :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.
<span class="gd">-    :param \\*\\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="gi">+    :param \*\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="w"> </span>    :return: :class:`Response &lt;Response&gt;` object
<span class="w"> </span>    :rtype: requests.Response
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return request(&quot;put&quot;, url, data=data, **kwargs)</span>


<span class="w"> </span>def patch(url, data=None, **kwargs):
<span class="gd">-    &quot;&quot;&quot;Sends a PATCH request.</span>
<span class="gi">+    r&quot;&quot;&quot;Sends a PATCH request.</span>

<span class="w"> </span>    :param url: URL for the new :class:`Request` object.
<span class="w"> </span>    :param data: (optional) Dictionary, list of tuples, bytes, or file-like
<span class="w"> </span>        object to send in the body of the :class:`Request`.
<span class="w"> </span>    :param json: (optional) A JSON serializable Python object to send in the body of the :class:`Request`.
<span class="gd">-    :param \\*\\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="gi">+    :param \*\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="w"> </span>    :return: :class:`Response &lt;Response&gt;` object
<span class="w"> </span>    :rtype: requests.Response
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return request(&quot;patch&quot;, url, data=data, **kwargs)</span>


<span class="w"> </span>def delete(url, **kwargs):
<span class="gd">-    &quot;&quot;&quot;Sends a DELETE request.</span>
<span class="gi">+    r&quot;&quot;&quot;Sends a DELETE request.</span>

<span class="w"> </span>    :param url: URL for the new :class:`Request` object.
<span class="gd">-    :param \\*\\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="gi">+    :param \*\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="w"> </span>    :return: :class:`Response &lt;Response&gt;` object
<span class="w"> </span>    :rtype: requests.Response
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return request(&quot;delete&quot;, url, **kwargs)</span>
<span class="gh">diff --git a/src/requests/auth.py b/src/requests/auth.py</span>
<span class="gh">index f08aecf6..4a7ce6dc 100644</span>
<span class="gd">--- a/src/requests/auth.py</span>
<span class="gi">+++ b/src/requests/auth.py</span>
<span class="gu">@@ -4,6 +4,7 @@ requests.auth</span>

<span class="w"> </span>This module contains the authentication handlers for Requests.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import hashlib
<span class="w"> </span>import os
<span class="w"> </span>import re
<span class="gu">@@ -11,24 +12,65 @@ import threading</span>
<span class="w"> </span>import time
<span class="w"> </span>import warnings
<span class="w"> </span>from base64 import b64encode
<span class="gi">+</span>
<span class="w"> </span>from ._internal_utils import to_native_string
<span class="w"> </span>from .compat import basestring, str, urlparse
<span class="w"> </span>from .cookies import extract_cookies_to_jar
<span class="w"> </span>from .utils import parse_dict_header
<span class="gd">-CONTENT_TYPE_FORM_URLENCODED = &#39;application/x-www-form-urlencoded&#39;</span>
<span class="gd">-CONTENT_TYPE_MULTI_PART = &#39;multipart/form-data&#39;</span>
<span class="gi">+</span>
<span class="gi">+CONTENT_TYPE_FORM_URLENCODED = &quot;application/x-www-form-urlencoded&quot;</span>
<span class="gi">+CONTENT_TYPE_MULTI_PART = &quot;multipart/form-data&quot;</span>


<span class="w"> </span>def _basic_auth_str(username, password):
<span class="w"> </span>    &quot;&quot;&quot;Returns a Basic Auth string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    # &quot;I want us to put a big-ol&#39; comment on top of it that</span>
<span class="gi">+    # says that this behaviour is dumb but we need to preserve</span>
<span class="gi">+    # it because people are relying on it.&quot;</span>
<span class="gi">+    #    - Lukasa</span>
<span class="gi">+    #</span>
<span class="gi">+    # These are here solely to maintain backwards compatibility</span>
<span class="gi">+    # for things like ints. This will be removed in 3.0.0.</span>
<span class="gi">+    if not isinstance(username, basestring):</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;Non-string usernames will no longer be supported in Requests &quot;</span>
<span class="gi">+            &quot;3.0.0. Please convert the object you&#39;ve passed in ({!r}) to &quot;</span>
<span class="gi">+            &quot;a string or bytes object in the near future to avoid &quot;</span>
<span class="gi">+            &quot;problems.&quot;.format(username),</span>
<span class="gi">+            category=DeprecationWarning,</span>
<span class="gi">+        )</span>
<span class="gi">+        username = str(username)</span>
<span class="gi">+</span>
<span class="gi">+    if not isinstance(password, basestring):</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;Non-string passwords will no longer be supported in Requests &quot;</span>
<span class="gi">+            &quot;3.0.0. Please convert the object you&#39;ve passed in ({!r}) to &quot;</span>
<span class="gi">+            &quot;a string or bytes object in the near future to avoid &quot;</span>
<span class="gi">+            &quot;problems.&quot;.format(type(password)),</span>
<span class="gi">+            category=DeprecationWarning,</span>
<span class="gi">+        )</span>
<span class="gi">+        password = str(password)</span>
<span class="gi">+    # -- End Removal --</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(username, str):</span>
<span class="gi">+        username = username.encode(&quot;latin1&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(password, str):</span>
<span class="gi">+        password = password.encode(&quot;latin1&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    authstr = &quot;Basic &quot; + to_native_string(</span>
<span class="gi">+        b64encode(b&quot;:&quot;.join((username, password))).strip()</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    return authstr</span>


<span class="w"> </span>class AuthBase:
<span class="w"> </span>    &quot;&quot;&quot;Base class that all auth implementations derive from&quot;&quot;&quot;

<span class="w"> </span>    def __call__(self, r):
<span class="gd">-        raise NotImplementedError(&#39;Auth hooks must be callable.&#39;)</span>
<span class="gi">+        raise NotImplementedError(&quot;Auth hooks must be callable.&quot;)</span>


<span class="w"> </span>class HTTPBasicAuth(AuthBase):
<span class="gu">@@ -39,15 +81,18 @@ class HTTPBasicAuth(AuthBase):</span>
<span class="w"> </span>        self.password = password

<span class="w"> </span>    def __eq__(self, other):
<span class="gd">-        return all([self.username == getattr(other, &#39;username&#39;, None), self</span>
<span class="gd">-            .password == getattr(other, &#39;password&#39;, None)])</span>
<span class="gi">+        return all(</span>
<span class="gi">+            [</span>
<span class="gi">+                self.username == getattr(other, &quot;username&quot;, None),</span>
<span class="gi">+                self.password == getattr(other, &quot;password&quot;, None),</span>
<span class="gi">+            ]</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __ne__(self, other):
<span class="w"> </span>        return not self == other

<span class="w"> </span>    def __call__(self, r):
<span class="gd">-        r.headers[&#39;Authorization&#39;] = _basic_auth_str(self.username, self.</span>
<span class="gd">-            password)</span>
<span class="gi">+        r.headers[&quot;Authorization&quot;] = _basic_auth_str(self.username, self.password)</span>
<span class="w"> </span>        return r


<span class="gu">@@ -55,8 +100,7 @@ class HTTPProxyAuth(HTTPBasicAuth):</span>
<span class="w"> </span>    &quot;&quot;&quot;Attaches HTTP Proxy Authentication to a given Request object.&quot;&quot;&quot;

<span class="w"> </span>    def __call__(self, r):
<span class="gd">-        r.headers[&#39;Proxy-Authorization&#39;] = _basic_auth_str(self.username,</span>
<span class="gd">-            self.password)</span>
<span class="gi">+        r.headers[&quot;Proxy-Authorization&quot;] = _basic_auth_str(self.username, self.password)</span>
<span class="w"> </span>        return r


<span class="gu">@@ -66,17 +110,133 @@ class HTTPDigestAuth(AuthBase):</span>
<span class="w"> </span>    def __init__(self, username, password):
<span class="w"> </span>        self.username = username
<span class="w"> </span>        self.password = password
<span class="gi">+        # Keep state in per-thread local storage</span>
<span class="w"> </span>        self._thread_local = threading.local()

<span class="gi">+    def init_per_thread_state(self):</span>
<span class="gi">+        # Ensure state is initialized just once per-thread</span>
<span class="gi">+        if not hasattr(self._thread_local, &quot;init&quot;):</span>
<span class="gi">+            self._thread_local.init = True</span>
<span class="gi">+            self._thread_local.last_nonce = &quot;&quot;</span>
<span class="gi">+            self._thread_local.nonce_count = 0</span>
<span class="gi">+            self._thread_local.chal = {}</span>
<span class="gi">+            self._thread_local.pos = None</span>
<span class="gi">+            self._thread_local.num_401_calls = None</span>
<span class="gi">+</span>
<span class="w"> </span>    def build_digest_header(self, method, url):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        :rtype: str
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        realm = self._thread_local.chal[&quot;realm&quot;]</span>
<span class="gi">+        nonce = self._thread_local.chal[&quot;nonce&quot;]</span>
<span class="gi">+        qop = self._thread_local.chal.get(&quot;qop&quot;)</span>
<span class="gi">+        algorithm = self._thread_local.chal.get(&quot;algorithm&quot;)</span>
<span class="gi">+        opaque = self._thread_local.chal.get(&quot;opaque&quot;)</span>
<span class="gi">+        hash_utf8 = None</span>
<span class="gi">+</span>
<span class="gi">+        if algorithm is None:</span>
<span class="gi">+            _algorithm = &quot;MD5&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            _algorithm = algorithm.upper()</span>
<span class="gi">+        # lambdas assume digest modules are imported at the top level</span>
<span class="gi">+        if _algorithm == &quot;MD5&quot; or _algorithm == &quot;MD5-SESS&quot;:</span>
<span class="gi">+</span>
<span class="gi">+            def md5_utf8(x):</span>
<span class="gi">+                if isinstance(x, str):</span>
<span class="gi">+                    x = x.encode(&quot;utf-8&quot;)</span>
<span class="gi">+                return hashlib.md5(x).hexdigest()</span>
<span class="gi">+</span>
<span class="gi">+            hash_utf8 = md5_utf8</span>
<span class="gi">+        elif _algorithm == &quot;SHA&quot;:</span>
<span class="gi">+</span>
<span class="gi">+            def sha_utf8(x):</span>
<span class="gi">+                if isinstance(x, str):</span>
<span class="gi">+                    x = x.encode(&quot;utf-8&quot;)</span>
<span class="gi">+                return hashlib.sha1(x).hexdigest()</span>
<span class="gi">+</span>
<span class="gi">+            hash_utf8 = sha_utf8</span>
<span class="gi">+        elif _algorithm == &quot;SHA-256&quot;:</span>
<span class="gi">+</span>
<span class="gi">+            def sha256_utf8(x):</span>
<span class="gi">+                if isinstance(x, str):</span>
<span class="gi">+                    x = x.encode(&quot;utf-8&quot;)</span>
<span class="gi">+                return hashlib.sha256(x).hexdigest()</span>
<span class="gi">+</span>
<span class="gi">+            hash_utf8 = sha256_utf8</span>
<span class="gi">+        elif _algorithm == &quot;SHA-512&quot;:</span>
<span class="gi">+</span>
<span class="gi">+            def sha512_utf8(x):</span>
<span class="gi">+                if isinstance(x, str):</span>
<span class="gi">+                    x = x.encode(&quot;utf-8&quot;)</span>
<span class="gi">+                return hashlib.sha512(x).hexdigest()</span>
<span class="gi">+</span>
<span class="gi">+            hash_utf8 = sha512_utf8</span>
<span class="gi">+</span>
<span class="gi">+        KD = lambda s, d: hash_utf8(f&quot;{s}:{d}&quot;)  # noqa:E731</span>
<span class="gi">+</span>
<span class="gi">+        if hash_utf8 is None:</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        # XXX not implemented yet</span>
<span class="gi">+        entdig = None</span>
<span class="gi">+        p_parsed = urlparse(url)</span>
<span class="gi">+        #: path is request-uri defined in RFC 2616 which should not be empty</span>
<span class="gi">+        path = p_parsed.path or &quot;/&quot;</span>
<span class="gi">+        if p_parsed.query:</span>
<span class="gi">+            path += f&quot;?{p_parsed.query}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        A1 = f&quot;{self.username}:{realm}:{self.password}&quot;</span>
<span class="gi">+        A2 = f&quot;{method}:{path}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        HA1 = hash_utf8(A1)</span>
<span class="gi">+        HA2 = hash_utf8(A2)</span>
<span class="gi">+</span>
<span class="gi">+        if nonce == self._thread_local.last_nonce:</span>
<span class="gi">+            self._thread_local.nonce_count += 1</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._thread_local.nonce_count = 1</span>
<span class="gi">+        ncvalue = f&quot;{self._thread_local.nonce_count:08x}&quot;</span>
<span class="gi">+        s = str(self._thread_local.nonce_count).encode(&quot;utf-8&quot;)</span>
<span class="gi">+        s += nonce.encode(&quot;utf-8&quot;)</span>
<span class="gi">+        s += time.ctime().encode(&quot;utf-8&quot;)</span>
<span class="gi">+        s += os.urandom(8)</span>
<span class="gi">+</span>
<span class="gi">+        cnonce = hashlib.sha1(s).hexdigest()[:16]</span>
<span class="gi">+        if _algorithm == &quot;MD5-SESS&quot;:</span>
<span class="gi">+            HA1 = hash_utf8(f&quot;{HA1}:{nonce}:{cnonce}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if not qop:</span>
<span class="gi">+            respdig = KD(HA1, f&quot;{nonce}:{HA2}&quot;)</span>
<span class="gi">+        elif qop == &quot;auth&quot; or &quot;auth&quot; in qop.split(&quot;,&quot;):</span>
<span class="gi">+            noncebit = f&quot;{nonce}:{ncvalue}:{cnonce}:auth:{HA2}&quot;</span>
<span class="gi">+            respdig = KD(HA1, noncebit)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # XXX handle auth-int.</span>
<span class="gi">+            return None</span>
<span class="gi">+</span>
<span class="gi">+        self._thread_local.last_nonce = nonce</span>
<span class="gi">+</span>
<span class="gi">+        # XXX should the partial digests be encoded too?</span>
<span class="gi">+        base = (</span>
<span class="gi">+            f&#39;username=&quot;{self.username}&quot;, realm=&quot;{realm}&quot;, nonce=&quot;{nonce}&quot;, &#39;</span>
<span class="gi">+            f&#39;uri=&quot;{path}&quot;, response=&quot;{respdig}&quot;&#39;</span>
<span class="gi">+        )</span>
<span class="gi">+        if opaque:</span>
<span class="gi">+            base += f&#39;, opaque=&quot;{opaque}&quot;&#39;</span>
<span class="gi">+        if algorithm:</span>
<span class="gi">+            base += f&#39;, algorithm=&quot;{algorithm}&quot;&#39;</span>
<span class="gi">+        if entdig:</span>
<span class="gi">+            base += f&#39;, digest=&quot;{entdig}&quot;&#39;</span>
<span class="gi">+        if qop:</span>
<span class="gi">+            base += f&#39;, qop=&quot;auth&quot;, nc={ncvalue}, cnonce=&quot;{cnonce}&quot;&#39;</span>
<span class="gi">+</span>
<span class="gi">+        return f&quot;Digest {base}&quot;</span>

<span class="w"> </span>    def handle_redirect(self, r, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Reset num_401_calls counter on redirects.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if r.is_redirect:</span>
<span class="gi">+            self._thread_local.num_401_calls = 1</span>

<span class="w"> </span>    def handle_401(self, r, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -84,25 +244,71 @@ class HTTPDigestAuth(AuthBase):</span>

<span class="w"> </span>        :rtype: requests.Response
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # If response is not 4xx, do not auth</span>
<span class="gi">+        # See https://github.com/psf/requests/issues/3772</span>
<span class="gi">+        if not 400 &lt;= r.status_code &lt; 500:</span>
<span class="gi">+            self._thread_local.num_401_calls = 1</span>
<span class="gi">+            return r</span>
<span class="gi">+</span>
<span class="gi">+        if self._thread_local.pos is not None:</span>
<span class="gi">+            # Rewind the file position indicator of the body to where</span>
<span class="gi">+            # it was to resend the request.</span>
<span class="gi">+            r.request.body.seek(self._thread_local.pos)</span>
<span class="gi">+        s_auth = r.headers.get(&quot;www-authenticate&quot;, &quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;digest&quot; in s_auth.lower() and self._thread_local.num_401_calls &lt; 2:</span>
<span class="gi">+            self._thread_local.num_401_calls += 1</span>
<span class="gi">+            pat = re.compile(r&quot;digest &quot;, flags=re.IGNORECASE)</span>
<span class="gi">+            self._thread_local.chal = parse_dict_header(pat.sub(&quot;&quot;, s_auth, count=1))</span>
<span class="gi">+</span>
<span class="gi">+            # Consume content and release the original connection</span>
<span class="gi">+            # to allow our new request to reuse the same one.</span>
<span class="gi">+            r.content</span>
<span class="gi">+            r.close()</span>
<span class="gi">+            prep = r.request.copy()</span>
<span class="gi">+            extract_cookies_to_jar(prep._cookies, r.request, r.raw)</span>
<span class="gi">+            prep.prepare_cookies(prep._cookies)</span>
<span class="gi">+</span>
<span class="gi">+            prep.headers[&quot;Authorization&quot;] = self.build_digest_header(</span>
<span class="gi">+                prep.method, prep.url</span>
<span class="gi">+            )</span>
<span class="gi">+            _r = r.connection.send(prep, **kwargs)</span>
<span class="gi">+            _r.history.append(r)</span>
<span class="gi">+            _r.request = prep</span>
<span class="gi">+</span>
<span class="gi">+            return _r</span>
<span class="gi">+</span>
<span class="gi">+        self._thread_local.num_401_calls = 1</span>
<span class="gi">+        return r</span>

<span class="w"> </span>    def __call__(self, r):
<span class="gi">+        # Initialize per-thread state, if needed</span>
<span class="w"> </span>        self.init_per_thread_state()
<span class="gi">+        # If we have a saved nonce, skip the 401</span>
<span class="w"> </span>        if self._thread_local.last_nonce:
<span class="gd">-            r.headers[&#39;Authorization&#39;] = self.build_digest_header(r.method,</span>
<span class="gd">-                r.url)</span>
<span class="gi">+            r.headers[&quot;Authorization&quot;] = self.build_digest_header(r.method, r.url)</span>
<span class="w"> </span>        try:
<span class="w"> </span>            self._thread_local.pos = r.body.tell()
<span class="w"> </span>        except AttributeError:
<span class="gi">+            # In the case of HTTPDigestAuth being reused and the body of</span>
<span class="gi">+            # the previous request was a file-like object, pos has the</span>
<span class="gi">+            # file position of the previous body. Ensure it&#39;s set to</span>
<span class="gi">+            # None.</span>
<span class="w"> </span>            self._thread_local.pos = None
<span class="gd">-        r.register_hook(&#39;response&#39;, self.handle_401)</span>
<span class="gd">-        r.register_hook(&#39;response&#39;, self.handle_redirect)</span>
<span class="gi">+        r.register_hook(&quot;response&quot;, self.handle_401)</span>
<span class="gi">+        r.register_hook(&quot;response&quot;, self.handle_redirect)</span>
<span class="w"> </span>        self._thread_local.num_401_calls = 1
<span class="gi">+</span>
<span class="w"> </span>        return r

<span class="w"> </span>    def __eq__(self, other):
<span class="gd">-        return all([self.username == getattr(other, &#39;username&#39;, None), self</span>
<span class="gd">-            .password == getattr(other, &#39;password&#39;, None)])</span>
<span class="gi">+        return all(</span>
<span class="gi">+            [</span>
<span class="gi">+                self.username == getattr(other, &quot;username&quot;, None),</span>
<span class="gi">+                self.password == getattr(other, &quot;password&quot;, None),</span>
<span class="gi">+            ]</span>
<span class="gi">+        )</span>

<span class="w"> </span>    def __ne__(self, other):
<span class="w"> </span>        return not self == other
<span class="gh">diff --git a/src/requests/certs.py b/src/requests/certs.py</span>
<span class="gh">index e6ec0c8d..be422c3e 100644</span>
<span class="gd">--- a/src/requests/certs.py</span>
<span class="gi">+++ b/src/requests/certs.py</span>
<span class="gu">@@ -1,3 +1,5 @@</span>
<span class="gi">+#!/usr/bin/env python</span>
<span class="gi">+</span>
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>requests.certs
<span class="w"> </span>~~~~~~~~~~~~~~
<span class="gu">@@ -10,5 +12,6 @@ environment, you can change the definition of where() to return a separately</span>
<span class="w"> </span>packaged CA bundle.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from certifi import where
<span class="gd">-if __name__ == &#39;__main__&#39;:</span>
<span class="gi">+</span>
<span class="gi">+if __name__ == &quot;__main__&quot;:</span>
<span class="w"> </span>    print(where())
<span class="gh">diff --git a/src/requests/compat.py b/src/requests/compat.py</span>
<span class="gh">index d4d04060..095de1b6 100644</span>
<span class="gd">--- a/src/requests/compat.py</span>
<span class="gi">+++ b/src/requests/compat.py</span>
<span class="gu">@@ -6,39 +6,89 @@ This module previously handled import compatibility issues</span>
<span class="w"> </span>between Python 2 and Python 3. It remains for backwards
<span class="w"> </span>compatibility until the next major version.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import importlib
<span class="w"> </span>import sys

<span class="gi">+# -------------------</span>
<span class="gi">+# Character Detection</span>
<span class="gi">+# -------------------</span>
<span class="gi">+</span>

<span class="w"> </span>def _resolve_char_detection():
<span class="w"> </span>    &quot;&quot;&quot;Find supported character detection libraries.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    chardet = None</span>
<span class="gi">+    for lib in (&quot;chardet&quot;, &quot;charset_normalizer&quot;):</span>
<span class="gi">+        if chardet is None:</span>
<span class="gi">+            try:</span>
<span class="gi">+                chardet = importlib.import_module(lib)</span>
<span class="gi">+            except ImportError:</span>
<span class="gi">+                pass</span>
<span class="gi">+    return chardet</span>


<span class="w"> </span>chardet = _resolve_char_detection()
<span class="gi">+</span>
<span class="gi">+# -------</span>
<span class="gi">+# Pythons</span>
<span class="gi">+# -------</span>
<span class="gi">+</span>
<span class="gi">+# Syntax sugar.</span>
<span class="w"> </span>_ver = sys.version_info
<span class="gi">+</span>
<span class="gi">+#: Python 2.x?</span>
<span class="w"> </span>is_py2 = _ver[0] == 2
<span class="gi">+</span>
<span class="gi">+#: Python 3.x?</span>
<span class="w"> </span>is_py3 = _ver[0] == 3
<span class="gi">+</span>
<span class="gi">+# json/simplejson module import resolution</span>
<span class="w"> </span>has_simplejson = False
<span class="w"> </span>try:
<span class="w"> </span>    import simplejson as json
<span class="gi">+</span>
<span class="w"> </span>    has_simplejson = True
<span class="w"> </span>except ImportError:
<span class="w"> </span>    import json
<span class="gi">+</span>
<span class="w"> </span>if has_simplejson:
<span class="w"> </span>    from simplejson import JSONDecodeError
<span class="w"> </span>else:
<span class="w"> </span>    from json import JSONDecodeError
<span class="gi">+</span>
<span class="gi">+# Keep OrderedDict for backwards compatibility.</span>
<span class="w"> </span>from collections import OrderedDict
<span class="w"> </span>from collections.abc import Callable, Mapping, MutableMapping
<span class="w"> </span>from http import cookiejar as cookielib
<span class="w"> </span>from http.cookies import Morsel
<span class="w"> </span>from io import StringIO
<span class="gd">-from urllib.parse import quote, quote_plus, unquote, unquote_plus, urldefrag, urlencode, urljoin, urlparse, urlsplit, urlunparse</span>
<span class="gd">-from urllib.request import getproxies, getproxies_environment, parse_http_list, proxy_bypass, proxy_bypass_environment</span>
<span class="gi">+</span>
<span class="gi">+# --------------</span>
<span class="gi">+# Legacy Imports</span>
<span class="gi">+# --------------</span>
<span class="gi">+from urllib.parse import (</span>
<span class="gi">+    quote,</span>
<span class="gi">+    quote_plus,</span>
<span class="gi">+    unquote,</span>
<span class="gi">+    unquote_plus,</span>
<span class="gi">+    urldefrag,</span>
<span class="gi">+    urlencode,</span>
<span class="gi">+    urljoin,</span>
<span class="gi">+    urlparse,</span>
<span class="gi">+    urlsplit,</span>
<span class="gi">+    urlunparse,</span>
<span class="gi">+)</span>
<span class="gi">+from urllib.request import (</span>
<span class="gi">+    getproxies,</span>
<span class="gi">+    getproxies_environment,</span>
<span class="gi">+    parse_http_list,</span>
<span class="gi">+    proxy_bypass,</span>
<span class="gi">+    proxy_bypass_environment,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>builtin_str = str
<span class="w"> </span>str = str
<span class="w"> </span>bytes = bytes
<span class="gd">-basestring = str, bytes</span>
<span class="gd">-numeric_types = int, float</span>
<span class="gd">-integer_types = int,</span>
<span class="gi">+basestring = (str, bytes)</span>
<span class="gi">+numeric_types = (int, float)</span>
<span class="gi">+integer_types = (int,)</span>
<span class="gh">diff --git a/src/requests/cookies.py b/src/requests/cookies.py</span>
<span class="gh">index 6392b7bc..f69d0cda 100644</span>
<span class="gd">--- a/src/requests/cookies.py</span>
<span class="gi">+++ b/src/requests/cookies.py</span>
<span class="gu">@@ -6,11 +6,14 @@ Compatibility code to be able to use `http.cookiejar.CookieJar` with requests.</span>

<span class="w"> </span>requests.utils imports from here, so be careful with imports.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import calendar
<span class="w"> </span>import copy
<span class="w"> </span>import time
<span class="gi">+</span>
<span class="w"> </span>from ._internal_utils import to_native_string
<span class="w"> </span>from .compat import Morsel, MutableMapping, cookielib, urlparse, urlunparse
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    import threading
<span class="w"> </span>except ImportError:
<span class="gu">@@ -34,9 +37,67 @@ class MockRequest:</span>
<span class="w"> </span>        self._new_headers = {}
<span class="w"> </span>        self.type = urlparse(self._r.url).scheme

<span class="gi">+    def get_type(self):</span>
<span class="gi">+        return self.type</span>
<span class="gi">+</span>
<span class="gi">+    def get_host(self):</span>
<span class="gi">+        return urlparse(self._r.url).netloc</span>
<span class="gi">+</span>
<span class="gi">+    def get_origin_req_host(self):</span>
<span class="gi">+        return self.get_host()</span>
<span class="gi">+</span>
<span class="gi">+    def get_full_url(self):</span>
<span class="gi">+        # Only return the response&#39;s URL if the user hadn&#39;t set the Host</span>
<span class="gi">+        # header</span>
<span class="gi">+        if not self._r.headers.get(&quot;Host&quot;):</span>
<span class="gi">+            return self._r.url</span>
<span class="gi">+        # If they did set it, retrieve it and reconstruct the expected domain</span>
<span class="gi">+        host = to_native_string(self._r.headers[&quot;Host&quot;], encoding=&quot;utf-8&quot;)</span>
<span class="gi">+        parsed = urlparse(self._r.url)</span>
<span class="gi">+        # Reconstruct the URL as we expect it</span>
<span class="gi">+        return urlunparse(</span>
<span class="gi">+            [</span>
<span class="gi">+                parsed.scheme,</span>
<span class="gi">+                host,</span>
<span class="gi">+                parsed.path,</span>
<span class="gi">+                parsed.params,</span>
<span class="gi">+                parsed.query,</span>
<span class="gi">+                parsed.fragment,</span>
<span class="gi">+            ]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def is_unverifiable(self):</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    def has_header(self, name):</span>
<span class="gi">+        return name in self._r.headers or name in self._new_headers</span>
<span class="gi">+</span>
<span class="gi">+    def get_header(self, name, default=None):</span>
<span class="gi">+        return self._r.headers.get(name, self._new_headers.get(name, default))</span>
<span class="gi">+</span>
<span class="w"> </span>    def add_header(self, key, val):
<span class="w"> </span>        &quot;&quot;&quot;cookiejar has no legitimate use for this method; add it back if you find one.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        raise NotImplementedError(</span>
<span class="gi">+            &quot;Cookie headers should be added with add_unredirected_header()&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    def add_unredirected_header(self, name, value):</span>
<span class="gi">+        self._new_headers[name] = value</span>
<span class="gi">+</span>
<span class="gi">+    def get_new_headers(self):</span>
<span class="gi">+        return self._new_headers</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def unverifiable(self):</span>
<span class="gi">+        return self.is_unverifiable()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def origin_req_host(self):</span>
<span class="gi">+        return self.get_origin_req_host()</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def host(self):</span>
<span class="gi">+        return self.get_host()</span>


<span class="w"> </span>class MockResponse:
<span class="gu">@@ -53,6 +114,12 @@ class MockResponse:</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        self._headers = headers

<span class="gi">+    def info(self):</span>
<span class="gi">+        return self._headers</span>
<span class="gi">+</span>
<span class="gi">+    def getheaders(self, name):</span>
<span class="gi">+        self._headers.getheaders(name)</span>
<span class="gi">+</span>

<span class="w"> </span>def extract_cookies_to_jar(jar, request, response):
<span class="w"> </span>    &quot;&quot;&quot;Extract the cookies from the response into a CookieJar.
<span class="gu">@@ -61,7 +128,13 @@ def extract_cookies_to_jar(jar, request, response):</span>
<span class="w"> </span>    :param request: our own requests.Request object
<span class="w"> </span>    :param response: urllib3.HTTPResponse object
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not (hasattr(response, &quot;_original_response&quot;) and response._original_response):</span>
<span class="gi">+        return</span>
<span class="gi">+    # the _original_response field is the wrapped httplib.HTTPResponse object,</span>
<span class="gi">+    req = MockRequest(request)</span>
<span class="gi">+    # pull out the HTTPMessage with the headers and put it in the mock:</span>
<span class="gi">+    res = MockResponse(response._original_response.msg)</span>
<span class="gi">+    jar.extract_cookies(res, req)</span>


<span class="w"> </span>def get_cookie_header(jar, request):
<span class="gu">@@ -70,7 +143,9 @@ def get_cookie_header(jar, request):</span>

<span class="w"> </span>    :rtype: str
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    r = MockRequest(request)</span>
<span class="gi">+    jar.add_cookie_header(r)</span>
<span class="gi">+    return r.get_new_headers().get(&quot;Cookie&quot;)</span>


<span class="w"> </span>def remove_cookie_by_name(cookiejar, name, domain=None, path=None):
<span class="gu">@@ -78,7 +153,18 @@ def remove_cookie_by_name(cookiejar, name, domain=None, path=None):</span>

<span class="w"> </span>    Wraps CookieJar.clear(), is O(n).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    clearables = []</span>
<span class="gi">+    for cookie in cookiejar:</span>
<span class="gi">+        if cookie.name != name:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if domain is not None and domain != cookie.domain:</span>
<span class="gi">+            continue</span>
<span class="gi">+        if path is not None and path != cookie.path:</span>
<span class="gi">+            continue</span>
<span class="gi">+        clearables.append((cookie.domain, cookie.path, cookie.name))</span>
<span class="gi">+</span>
<span class="gi">+    for domain, path, name in clearables:</span>
<span class="gi">+        cookiejar.clear(domain, path, name)</span>


<span class="w"> </span>class CookieConflictError(RuntimeError):
<span class="gu">@@ -112,14 +198,29 @@ class RequestsCookieJar(cookielib.CookieJar, MutableMapping):</span>

<span class="w"> </span>        .. warning:: operation is O(n), not O(1).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self._find_no_duplicates(name, domain, path)</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            return default</span>

<span class="w"> </span>    def set(self, name, value, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Dict-like set() that also supports optional domain and path args in
<span class="w"> </span>        order to resolve naming collisions from using one cookie jar over
<span class="w"> </span>        multiple domains.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # support client code that unsets cookies by assignment of a None value:</span>
<span class="gi">+        if value is None:</span>
<span class="gi">+            remove_cookie_by_name(</span>
<span class="gi">+                self, name, domain=kwargs.get(&quot;domain&quot;), path=kwargs.get(&quot;path&quot;)</span>
<span class="gi">+            )</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(value, Morsel):</span>
<span class="gi">+            c = morsel_to_cookie(value)</span>
<span class="gi">+        else:</span>
<span class="gi">+            c = create_cookie(name, value, **kwargs)</span>
<span class="gi">+        self.set_cookie(c)</span>
<span class="gi">+        return c</span>

<span class="w"> </span>    def iterkeys(self):
<span class="w"> </span>        &quot;&quot;&quot;Dict-like iterkeys() that returns an iterator of names of cookies
<span class="gu">@@ -127,7 +228,8 @@ class RequestsCookieJar(cookielib.CookieJar, MutableMapping):</span>

<span class="w"> </span>        .. seealso:: itervalues() and iteritems().
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for cookie in iter(self):</span>
<span class="gi">+            yield cookie.name</span>

<span class="w"> </span>    def keys(self):
<span class="w"> </span>        &quot;&quot;&quot;Dict-like keys() that returns a list of names of cookies from the
<span class="gu">@@ -135,7 +237,7 @@ class RequestsCookieJar(cookielib.CookieJar, MutableMapping):</span>

<span class="w"> </span>        .. seealso:: values() and items().
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return list(self.iterkeys())</span>

<span class="w"> </span>    def itervalues(self):
<span class="w"> </span>        &quot;&quot;&quot;Dict-like itervalues() that returns an iterator of values of cookies
<span class="gu">@@ -143,7 +245,8 @@ class RequestsCookieJar(cookielib.CookieJar, MutableMapping):</span>

<span class="w"> </span>        .. seealso:: iterkeys() and iteritems().
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for cookie in iter(self):</span>
<span class="gi">+            yield cookie.value</span>

<span class="w"> </span>    def values(self):
<span class="w"> </span>        &quot;&quot;&quot;Dict-like values() that returns a list of values of cookies from the
<span class="gu">@@ -151,7 +254,7 @@ class RequestsCookieJar(cookielib.CookieJar, MutableMapping):</span>

<span class="w"> </span>        .. seealso:: keys() and items().
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return list(self.itervalues())</span>

<span class="w"> </span>    def iteritems(self):
<span class="w"> </span>        &quot;&quot;&quot;Dict-like iteritems() that returns an iterator of name-value tuples
<span class="gu">@@ -159,7 +262,8 @@ class RequestsCookieJar(cookielib.CookieJar, MutableMapping):</span>

<span class="w"> </span>        .. seealso:: iterkeys() and itervalues().
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for cookie in iter(self):</span>
<span class="gi">+            yield cookie.name, cookie.value</span>

<span class="w"> </span>    def items(self):
<span class="w"> </span>        &quot;&quot;&quot;Dict-like items() that returns a list of name-value tuples from the
<span class="gu">@@ -168,15 +272,23 @@ class RequestsCookieJar(cookielib.CookieJar, MutableMapping):</span>

<span class="w"> </span>        .. seealso:: keys() and values().
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return list(self.iteritems())</span>

<span class="w"> </span>    def list_domains(self):
<span class="w"> </span>        &quot;&quot;&quot;Utility method to list all the domains in the jar.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        domains = []</span>
<span class="gi">+        for cookie in iter(self):</span>
<span class="gi">+            if cookie.domain not in domains:</span>
<span class="gi">+                domains.append(cookie.domain)</span>
<span class="gi">+        return domains</span>

<span class="w"> </span>    def list_paths(self):
<span class="w"> </span>        &quot;&quot;&quot;Utility method to list all the paths in the jar.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        paths = []</span>
<span class="gi">+        for cookie in iter(self):</span>
<span class="gi">+            if cookie.path not in paths:</span>
<span class="gi">+                paths.append(cookie.path)</span>
<span class="gi">+        return paths</span>

<span class="w"> </span>    def multiple_domains(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if there are multiple domains in the jar.
<span class="gu">@@ -184,7 +296,12 @@ class RequestsCookieJar(cookielib.CookieJar, MutableMapping):</span>

<span class="w"> </span>        :rtype: bool
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        domains = []</span>
<span class="gi">+        for cookie in iter(self):</span>
<span class="gi">+            if cookie.domain is not None and cookie.domain in domains:</span>
<span class="gi">+                return True</span>
<span class="gi">+            domains.append(cookie.domain)</span>
<span class="gi">+        return False  # there is only one domain in jar</span>

<span class="w"> </span>    def get_dict(self, domain=None, path=None):
<span class="w"> </span>        &quot;&quot;&quot;Takes as an argument an optional domain and path and returns a plain
<span class="gu">@@ -193,7 +310,13 @@ class RequestsCookieJar(cookielib.CookieJar, MutableMapping):</span>

<span class="w"> </span>        :rtype: dict
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        dictionary = {}</span>
<span class="gi">+        for cookie in iter(self):</span>
<span class="gi">+            if (domain is None or cookie.domain == domain) and (</span>
<span class="gi">+                path is None or cookie.path == path</span>
<span class="gi">+            ):</span>
<span class="gi">+                dictionary[cookie.name] = cookie.value</span>
<span class="gi">+        return dictionary</span>

<span class="w"> </span>    def __contains__(self, name):
<span class="w"> </span>        try:
<span class="gu">@@ -223,9 +346,22 @@ class RequestsCookieJar(cookielib.CookieJar, MutableMapping):</span>
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        remove_cookie_by_name(self, name)

<span class="gi">+    def set_cookie(self, cookie, *args, **kwargs):</span>
<span class="gi">+        if (</span>
<span class="gi">+            hasattr(cookie.value, &quot;startswith&quot;)</span>
<span class="gi">+            and cookie.value.startswith(&#39;&quot;&#39;)</span>
<span class="gi">+            and cookie.value.endswith(&#39;&quot;&#39;)</span>
<span class="gi">+        ):</span>
<span class="gi">+            cookie.value = cookie.value.replace(&#39;\\&quot;&#39;, &quot;&quot;)</span>
<span class="gi">+        return super().set_cookie(cookie, *args, **kwargs)</span>
<span class="gi">+</span>
<span class="w"> </span>    def update(self, other):
<span class="w"> </span>        &quot;&quot;&quot;Updates this jar with cookies from another CookieJar or dict-like&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(other, cookielib.CookieJar):</span>
<span class="gi">+            for cookie in other:</span>
<span class="gi">+                self.set_cookie(copy.copy(cookie))</span>
<span class="gi">+        else:</span>
<span class="gi">+            super().update(other)</span>

<span class="w"> </span>    def _find(self, name, domain=None, path=None):
<span class="w"> </span>        &quot;&quot;&quot;Requests uses this method internally to get cookie values.
<span class="gu">@@ -239,7 +375,13 @@ class RequestsCookieJar(cookielib.CookieJar, MutableMapping):</span>
<span class="w"> </span>        :param path: (optional) string containing path of cookie
<span class="w"> </span>        :return: cookie.value
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for cookie in iter(self):</span>
<span class="gi">+            if cookie.name == name:</span>
<span class="gi">+                if domain is None or cookie.domain == domain:</span>
<span class="gi">+                    if path is None or cookie.path == path:</span>
<span class="gi">+                        return cookie.value</span>
<span class="gi">+</span>
<span class="gi">+        raise KeyError(f&quot;name={name!r}, domain={domain!r}, path={path!r}&quot;)</span>

<span class="w"> </span>    def _find_no_duplicates(self, name, domain=None, path=None):
<span class="w"> </span>        &quot;&quot;&quot;Both ``__get_item__`` and ``get`` call this function: it&#39;s never
<span class="gu">@@ -253,27 +395,61 @@ class RequestsCookieJar(cookielib.CookieJar, MutableMapping):</span>
<span class="w"> </span>            that match name and optionally domain and path
<span class="w"> </span>        :return: cookie.value
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        toReturn = None</span>
<span class="gi">+        for cookie in iter(self):</span>
<span class="gi">+            if cookie.name == name:</span>
<span class="gi">+                if domain is None or cookie.domain == domain:</span>
<span class="gi">+                    if path is None or cookie.path == path:</span>
<span class="gi">+                        if toReturn is not None:</span>
<span class="gi">+                            # if there are multiple cookies that meet passed in criteria</span>
<span class="gi">+                            raise CookieConflictError(</span>
<span class="gi">+                                f&quot;There are multiple cookies with name, {name!r}&quot;</span>
<span class="gi">+                            )</span>
<span class="gi">+                        # we will eventually return this as long as no cookie conflict</span>
<span class="gi">+                        toReturn = cookie.value</span>
<span class="gi">+</span>
<span class="gi">+        if toReturn:</span>
<span class="gi">+            return toReturn</span>
<span class="gi">+        raise KeyError(f&quot;name={name!r}, domain={domain!r}, path={path!r}&quot;)</span>

<span class="w"> </span>    def __getstate__(self):
<span class="w"> </span>        &quot;&quot;&quot;Unlike a normal CookieJar, this class is pickleable.&quot;&quot;&quot;
<span class="w"> </span>        state = self.__dict__.copy()
<span class="gd">-        state.pop(&#39;_cookies_lock&#39;)</span>
<span class="gi">+        # remove the unpickleable RLock object</span>
<span class="gi">+        state.pop(&quot;_cookies_lock&quot;)</span>
<span class="w"> </span>        return state

<span class="w"> </span>    def __setstate__(self, state):
<span class="w"> </span>        &quot;&quot;&quot;Unlike a normal CookieJar, this class is pickleable.&quot;&quot;&quot;
<span class="w"> </span>        self.__dict__.update(state)
<span class="gd">-        if &#39;_cookies_lock&#39; not in self.__dict__:</span>
<span class="gi">+        if &quot;_cookies_lock&quot; not in self.__dict__:</span>
<span class="w"> </span>            self._cookies_lock = threading.RLock()

<span class="w"> </span>    def copy(self):
<span class="w"> </span>        &quot;&quot;&quot;Return a copy of this RequestsCookieJar.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        new_cj = RequestsCookieJar()</span>
<span class="gi">+        new_cj.set_policy(self.get_policy())</span>
<span class="gi">+        new_cj.update(self)</span>
<span class="gi">+        return new_cj</span>

<span class="w"> </span>    def get_policy(self):
<span class="w"> </span>        &quot;&quot;&quot;Return the CookiePolicy instance used.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._policy</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _copy_cookie_jar(jar):</span>
<span class="gi">+    if jar is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    if hasattr(jar, &quot;copy&quot;):</span>
<span class="gi">+        # We&#39;re dealing with an instance of RequestsCookieJar</span>
<span class="gi">+        return jar.copy()</span>
<span class="gi">+    # We&#39;re dealing with a generic CookieJar instance</span>
<span class="gi">+    new_jar = copy.copy(jar)</span>
<span class="gi">+    new_jar.clear()</span>
<span class="gi">+    for cookie in jar:</span>
<span class="gi">+        new_jar.set_cookie(copy.copy(cookie))</span>
<span class="gi">+    return new_jar</span>


<span class="w"> </span>def create_cookie(name, value, **kwargs):
<span class="gu">@@ -282,12 +458,64 @@ def create_cookie(name, value, **kwargs):</span>
<span class="w"> </span>    By default, the pair of `name` and `value` will be set for the domain &#39;&#39;
<span class="w"> </span>    and sent on every request (this is sometimes called a &quot;supercookie&quot;).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = {</span>
<span class="gi">+        &quot;version&quot;: 0,</span>
<span class="gi">+        &quot;name&quot;: name,</span>
<span class="gi">+        &quot;value&quot;: value,</span>
<span class="gi">+        &quot;port&quot;: None,</span>
<span class="gi">+        &quot;domain&quot;: &quot;&quot;,</span>
<span class="gi">+        &quot;path&quot;: &quot;/&quot;,</span>
<span class="gi">+        &quot;secure&quot;: False,</span>
<span class="gi">+        &quot;expires&quot;: None,</span>
<span class="gi">+        &quot;discard&quot;: True,</span>
<span class="gi">+        &quot;comment&quot;: None,</span>
<span class="gi">+        &quot;comment_url&quot;: None,</span>
<span class="gi">+        &quot;rest&quot;: {&quot;HttpOnly&quot;: None},</span>
<span class="gi">+        &quot;rfc2109&quot;: False,</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    badargs = set(kwargs) - set(result)</span>
<span class="gi">+    if badargs:</span>
<span class="gi">+        raise TypeError(</span>
<span class="gi">+            f&quot;create_cookie() got unexpected keyword arguments: {list(badargs)}&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    result.update(kwargs)</span>
<span class="gi">+    result[&quot;port_specified&quot;] = bool(result[&quot;port&quot;])</span>
<span class="gi">+    result[&quot;domain_specified&quot;] = bool(result[&quot;domain&quot;])</span>
<span class="gi">+    result[&quot;domain_initial_dot&quot;] = result[&quot;domain&quot;].startswith(&quot;.&quot;)</span>
<span class="gi">+    result[&quot;path_specified&quot;] = bool(result[&quot;path&quot;])</span>
<span class="gi">+</span>
<span class="gi">+    return cookielib.Cookie(**result)</span>


<span class="w"> </span>def morsel_to_cookie(morsel):
<span class="w"> </span>    &quot;&quot;&quot;Convert a Morsel object into a Cookie containing the one k/v pair.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    expires = None</span>
<span class="gi">+    if morsel[&quot;max-age&quot;]:</span>
<span class="gi">+        try:</span>
<span class="gi">+            expires = int(time.time() + int(morsel[&quot;max-age&quot;]))</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise TypeError(f&quot;max-age: {morsel[&#39;max-age&#39;]} must be integer&quot;)</span>
<span class="gi">+    elif morsel[&quot;expires&quot;]:</span>
<span class="gi">+        time_template = &quot;%a, %d-%b-%Y %H:%M:%S GMT&quot;</span>
<span class="gi">+        expires = calendar.timegm(time.strptime(morsel[&quot;expires&quot;], time_template))</span>
<span class="gi">+    return create_cookie(</span>
<span class="gi">+        comment=morsel[&quot;comment&quot;],</span>
<span class="gi">+        comment_url=bool(morsel[&quot;comment&quot;]),</span>
<span class="gi">+        discard=False,</span>
<span class="gi">+        domain=morsel[&quot;domain&quot;],</span>
<span class="gi">+        expires=expires,</span>
<span class="gi">+        name=morsel.key,</span>
<span class="gi">+        path=morsel[&quot;path&quot;],</span>
<span class="gi">+        port=None,</span>
<span class="gi">+        rest={&quot;HttpOnly&quot;: morsel[&quot;httponly&quot;]},</span>
<span class="gi">+        rfc2109=False,</span>
<span class="gi">+        secure=bool(morsel[&quot;secure&quot;]),</span>
<span class="gi">+        value=morsel.value,</span>
<span class="gi">+        version=morsel[&quot;version&quot;] or 0,</span>
<span class="gi">+    )</span>


<span class="w"> </span>def cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True):
<span class="gu">@@ -299,7 +527,16 @@ def cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True):</span>
<span class="w"> </span>        already in the jar with new ones.
<span class="w"> </span>    :rtype: CookieJar
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if cookiejar is None:</span>
<span class="gi">+        cookiejar = RequestsCookieJar()</span>
<span class="gi">+</span>
<span class="gi">+    if cookie_dict is not None:</span>
<span class="gi">+        names_from_jar = [cookie.name for cookie in cookiejar]</span>
<span class="gi">+        for name in cookie_dict:</span>
<span class="gi">+            if overwrite or (name not in names_from_jar):</span>
<span class="gi">+                cookiejar.set_cookie(create_cookie(name, cookie_dict[name]))</span>
<span class="gi">+</span>
<span class="gi">+    return cookiejar</span>


<span class="w"> </span>def merge_cookies(cookiejar, cookies):
<span class="gu">@@ -309,4 +546,16 @@ def merge_cookies(cookiejar, cookies):</span>
<span class="w"> </span>    :param cookies: Dictionary or CookieJar object to be added.
<span class="w"> </span>    :rtype: CookieJar
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(cookiejar, cookielib.CookieJar):</span>
<span class="gi">+        raise ValueError(&quot;You can only merge into CookieJar&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(cookies, dict):</span>
<span class="gi">+        cookiejar = cookiejar_from_dict(cookies, cookiejar=cookiejar, overwrite=False)</span>
<span class="gi">+    elif isinstance(cookies, cookielib.CookieJar):</span>
<span class="gi">+        try:</span>
<span class="gi">+            cookiejar.update(cookies)</span>
<span class="gi">+        except AttributeError:</span>
<span class="gi">+            for cookie_in_jar in cookies:</span>
<span class="gi">+                cookiejar.set_cookie(cookie_in_jar)</span>
<span class="gi">+</span>
<span class="gi">+    return cookiejar</span>
<span class="gh">diff --git a/src/requests/exceptions.py b/src/requests/exceptions.py</span>
<span class="gh">index 9480a02a..83986b48 100644</span>
<span class="gd">--- a/src/requests/exceptions.py</span>
<span class="gi">+++ b/src/requests/exceptions.py</span>
<span class="gu">@@ -5,6 +5,7 @@ requests.exceptions</span>
<span class="w"> </span>This module contains the set of Requests&#39; exceptions.
<span class="w"> </span>&quot;&quot;&quot;
<span class="w"> </span>from urllib3.exceptions import HTTPError as BaseHTTPError
<span class="gi">+</span>
<span class="w"> </span>from .compat import JSONDecodeError as CompatJSONDecodeError


<span class="gu">@@ -15,11 +16,10 @@ class RequestException(IOError):</span>

<span class="w"> </span>    def __init__(self, *args, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Initialize RequestException with `request` and `response` objects.&quot;&quot;&quot;
<span class="gd">-        response = kwargs.pop(&#39;response&#39;, None)</span>
<span class="gi">+        response = kwargs.pop(&quot;response&quot;, None)</span>
<span class="w"> </span>        self.response = response
<span class="gd">-        self.request = kwargs.pop(&#39;request&#39;, None)</span>
<span class="gd">-        if response is not None and not self.request and hasattr(response,</span>
<span class="gd">-            &#39;request&#39;):</span>
<span class="gi">+        self.request = kwargs.pop(&quot;request&quot;, None)</span>
<span class="gi">+        if response is not None and not self.request and hasattr(response, &quot;request&quot;):</span>
<span class="w"> </span>            self.request = self.response.request
<span class="w"> </span>        super().__init__(*args, **kwargs)

<span class="gu">@@ -136,6 +136,9 @@ class UnrewindableBodyError(RequestException):</span>
<span class="w"> </span>    &quot;&quot;&quot;Requests encountered an error when trying to rewind a body.&quot;&quot;&quot;


<span class="gi">+# Warnings</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>class RequestsWarning(Warning):
<span class="w"> </span>    &quot;&quot;&quot;Base warning for Requests.&quot;&quot;&quot;

<span class="gh">diff --git a/src/requests/help.py b/src/requests/help.py</span>
<span class="gh">index 8057ee09..8fbcd656 100644</span>
<span class="gd">--- a/src/requests/help.py</span>
<span class="gi">+++ b/src/requests/help.py</span>
<span class="gu">@@ -1,19 +1,25 @@</span>
<span class="w"> </span>&quot;&quot;&quot;Module containing bug report helper(s).&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import json
<span class="w"> </span>import platform
<span class="w"> </span>import ssl
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="w"> </span>import idna
<span class="w"> </span>import urllib3
<span class="gi">+</span>
<span class="w"> </span>from . import __version__ as requests_version
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    import charset_normalizer
<span class="w"> </span>except ImportError:
<span class="w"> </span>    charset_normalizer = None
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    import chardet
<span class="w"> </span>except ImportError:
<span class="w"> </span>    chardet = None
<span class="gi">+</span>
<span class="w"> </span>try:
<span class="w"> </span>    from urllib3.contrib import pyopenssl
<span class="w"> </span>except ImportError:
<span class="gu">@@ -36,18 +42,93 @@ def _implementation():</span>
<span class="w"> </span>    doesn&#39;t work for Jython or IronPython. Future investigation should be done
<span class="w"> </span>    to work out the correct shape of the code for those platforms.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    implementation = platform.python_implementation()</span>
<span class="gi">+</span>
<span class="gi">+    if implementation == &quot;CPython&quot;:</span>
<span class="gi">+        implementation_version = platform.python_version()</span>
<span class="gi">+    elif implementation == &quot;PyPy&quot;:</span>
<span class="gi">+        implementation_version = &quot;{}.{}.{}&quot;.format(</span>
<span class="gi">+            sys.pypy_version_info.major,</span>
<span class="gi">+            sys.pypy_version_info.minor,</span>
<span class="gi">+            sys.pypy_version_info.micro,</span>
<span class="gi">+        )</span>
<span class="gi">+        if sys.pypy_version_info.releaselevel != &quot;final&quot;:</span>
<span class="gi">+            implementation_version = &quot;&quot;.join(</span>
<span class="gi">+                [implementation_version, sys.pypy_version_info.releaselevel]</span>
<span class="gi">+            )</span>
<span class="gi">+    elif implementation == &quot;Jython&quot;:</span>
<span class="gi">+        implementation_version = platform.python_version()  # Complete Guess</span>
<span class="gi">+    elif implementation == &quot;IronPython&quot;:</span>
<span class="gi">+        implementation_version = platform.python_version()  # Complete Guess</span>
<span class="gi">+    else:</span>
<span class="gi">+        implementation_version = &quot;Unknown&quot;</span>
<span class="gi">+</span>
<span class="gi">+    return {&quot;name&quot;: implementation, &quot;version&quot;: implementation_version}</span>


<span class="w"> </span>def info():
<span class="w"> </span>    &quot;&quot;&quot;Generate information for a bug report.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        platform_info = {</span>
<span class="gi">+            &quot;system&quot;: platform.system(),</span>
<span class="gi">+            &quot;release&quot;: platform.release(),</span>
<span class="gi">+        }</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        platform_info = {</span>
<span class="gi">+            &quot;system&quot;: &quot;Unknown&quot;,</span>
<span class="gi">+            &quot;release&quot;: &quot;Unknown&quot;,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    implementation_info = _implementation()</span>
<span class="gi">+    urllib3_info = {&quot;version&quot;: urllib3.__version__}</span>
<span class="gi">+    charset_normalizer_info = {&quot;version&quot;: None}</span>
<span class="gi">+    chardet_info = {&quot;version&quot;: None}</span>
<span class="gi">+    if charset_normalizer:</span>
<span class="gi">+        charset_normalizer_info = {&quot;version&quot;: charset_normalizer.__version__}</span>
<span class="gi">+    if chardet:</span>
<span class="gi">+        chardet_info = {&quot;version&quot;: chardet.__version__}</span>
<span class="gi">+</span>
<span class="gi">+    pyopenssl_info = {</span>
<span class="gi">+        &quot;version&quot;: None,</span>
<span class="gi">+        &quot;openssl_version&quot;: &quot;&quot;,</span>
<span class="gi">+    }</span>
<span class="gi">+    if OpenSSL:</span>
<span class="gi">+        pyopenssl_info = {</span>
<span class="gi">+            &quot;version&quot;: OpenSSL.__version__,</span>
<span class="gi">+            &quot;openssl_version&quot;: f&quot;{OpenSSL.SSL.OPENSSL_VERSION_NUMBER:x}&quot;,</span>
<span class="gi">+        }</span>
<span class="gi">+    cryptography_info = {</span>
<span class="gi">+        &quot;version&quot;: getattr(cryptography, &quot;__version__&quot;, &quot;&quot;),</span>
<span class="gi">+    }</span>
<span class="gi">+    idna_info = {</span>
<span class="gi">+        &quot;version&quot;: getattr(idna, &quot;__version__&quot;, &quot;&quot;),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    system_ssl = ssl.OPENSSL_VERSION_NUMBER</span>
<span class="gi">+    system_ssl_info = {&quot;version&quot;: f&quot;{system_ssl:x}&quot; if system_ssl is not None else &quot;&quot;}</span>
<span class="gi">+</span>
<span class="gi">+    return {</span>
<span class="gi">+        &quot;platform&quot;: platform_info,</span>
<span class="gi">+        &quot;implementation&quot;: implementation_info,</span>
<span class="gi">+        &quot;system_ssl&quot;: system_ssl_info,</span>
<span class="gi">+        &quot;using_pyopenssl&quot;: pyopenssl is not None,</span>
<span class="gi">+        &quot;using_charset_normalizer&quot;: chardet is None,</span>
<span class="gi">+        &quot;pyOpenSSL&quot;: pyopenssl_info,</span>
<span class="gi">+        &quot;urllib3&quot;: urllib3_info,</span>
<span class="gi">+        &quot;chardet&quot;: chardet_info,</span>
<span class="gi">+        &quot;charset_normalizer&quot;: charset_normalizer_info,</span>
<span class="gi">+        &quot;cryptography&quot;: cryptography_info,</span>
<span class="gi">+        &quot;idna&quot;: idna_info,</span>
<span class="gi">+        &quot;requests&quot;: {</span>
<span class="gi">+            &quot;version&quot;: requests_version,</span>
<span class="gi">+        },</span>
<span class="gi">+    }</span>


<span class="w"> </span>def main():
<span class="w"> </span>    &quot;&quot;&quot;Pretty-print the bug information as JSON.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    print(json.dumps(info(), sort_keys=True, indent=2))</span>


<span class="gd">-if __name__ == &#39;__main__&#39;:</span>
<span class="gi">+if __name__ == &quot;__main__&quot;:</span>
<span class="w"> </span>    main()
<span class="gh">diff --git a/src/requests/hooks.py b/src/requests/hooks.py</span>
<span class="gh">index 8dfca96f..d181ba2e 100644</span>
<span class="gd">--- a/src/requests/hooks.py</span>
<span class="gi">+++ b/src/requests/hooks.py</span>
<span class="gu">@@ -9,9 +9,25 @@ Available hooks:</span>
<span class="w"> </span>``response``:
<span class="w"> </span>    The response generated from a Request.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gd">-HOOKS = [&#39;response&#39;]</span>
<span class="gi">+HOOKS = [&quot;response&quot;]</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def default_hooks():</span>
<span class="gi">+    return {event: [] for event in HOOKS}</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# TODO: response is the only one</span>


<span class="w"> </span>def dispatch_hook(key, hooks, hook_data, **kwargs):
<span class="w"> </span>    &quot;&quot;&quot;Dispatches a hook dictionary on a given piece of data.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    hooks = hooks or {}</span>
<span class="gi">+    hooks = hooks.get(key)</span>
<span class="gi">+    if hooks:</span>
<span class="gi">+        if hasattr(hooks, &quot;__call__&quot;):</span>
<span class="gi">+            hooks = [hooks]</span>
<span class="gi">+        for hook in hooks:</span>
<span class="gi">+            _hook_data = hook(hook_data, **kwargs)</span>
<span class="gi">+            if _hook_data is not None:</span>
<span class="gi">+                hook_data = _hook_data</span>
<span class="gi">+    return hook_data</span>
<span class="gh">diff --git a/src/requests/models.py b/src/requests/models.py</span>
<span class="gh">index 9006e78e..8f56ca7d 100644</span>
<span class="gd">--- a/src/requests/models.py</span>
<span class="gi">+++ b/src/requests/models.py</span>
<span class="gu">@@ -4,20 +4,48 @@ requests.models</span>

<span class="w"> </span>This module contains the primary objects that power Requests.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import datetime
<span class="gd">-import encodings.idna</span>
<span class="gi">+</span>
<span class="gi">+# Import encoding now, to avoid implicit import later.</span>
<span class="gi">+# Implicit import within threads may cause LookupError when standard library is in a ZIP,</span>
<span class="gi">+# such as in Embedded Python. See https://github.com/psf/requests/issues/3578.</span>
<span class="gi">+import encodings.idna  # noqa: F401</span>
<span class="w"> </span>from io import UnsupportedOperation
<span class="gd">-from urllib3.exceptions import DecodeError, LocationParseError, ProtocolError, ReadTimeoutError, SSLError</span>
<span class="gi">+</span>
<span class="gi">+from urllib3.exceptions import (</span>
<span class="gi">+    DecodeError,</span>
<span class="gi">+    LocationParseError,</span>
<span class="gi">+    ProtocolError,</span>
<span class="gi">+    ReadTimeoutError,</span>
<span class="gi">+    SSLError,</span>
<span class="gi">+)</span>
<span class="w"> </span>from urllib3.fields import RequestField
<span class="w"> </span>from urllib3.filepost import encode_multipart_formdata
<span class="w"> </span>from urllib3.util import parse_url
<span class="gi">+</span>
<span class="w"> </span>from ._internal_utils import to_native_string, unicode_is_ascii
<span class="w"> </span>from .auth import HTTPBasicAuth
<span class="gd">-from .compat import Callable, JSONDecodeError, Mapping, basestring, builtin_str, chardet, cookielib</span>
<span class="gi">+from .compat import (</span>
<span class="gi">+    Callable,</span>
<span class="gi">+    JSONDecodeError,</span>
<span class="gi">+    Mapping,</span>
<span class="gi">+    basestring,</span>
<span class="gi">+    builtin_str,</span>
<span class="gi">+    chardet,</span>
<span class="gi">+    cookielib,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .compat import json as complexjson
<span class="w"> </span>from .compat import urlencode, urlsplit, urlunparse
<span class="w"> </span>from .cookies import _copy_cookie_jar, cookiejar_from_dict, get_cookie_header
<span class="gd">-from .exceptions import ChunkedEncodingError, ConnectionError, ContentDecodingError, HTTPError, InvalidJSONError, InvalidURL</span>
<span class="gi">+from .exceptions import (</span>
<span class="gi">+    ChunkedEncodingError,</span>
<span class="gi">+    ConnectionError,</span>
<span class="gi">+    ContentDecodingError,</span>
<span class="gi">+    HTTPError,</span>
<span class="gi">+    InvalidJSONError,</span>
<span class="gi">+    InvalidURL,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .exceptions import JSONDecodeError as RequestsJSONDecodeError
<span class="w"> </span>from .exceptions import MissingSchema
<span class="w"> </span>from .exceptions import SSLError as RequestsSSLError
<span class="gu">@@ -25,20 +53,55 @@ from .exceptions import StreamConsumedError</span>
<span class="w"> </span>from .hooks import default_hooks
<span class="w"> </span>from .status_codes import codes
<span class="w"> </span>from .structures import CaseInsensitiveDict
<span class="gd">-from .utils import check_header_validity, get_auth_from_url, guess_filename, guess_json_utf, iter_slices, parse_header_links, requote_uri, stream_decode_response_unicode, super_len, to_key_val_list</span>
<span class="gd">-REDIRECT_STATI = (codes.moved, codes.found, codes.other, codes.</span>
<span class="gd">-    temporary_redirect, codes.permanent_redirect)</span>
<span class="gi">+from .utils import (</span>
<span class="gi">+    check_header_validity,</span>
<span class="gi">+    get_auth_from_url,</span>
<span class="gi">+    guess_filename,</span>
<span class="gi">+    guess_json_utf,</span>
<span class="gi">+    iter_slices,</span>
<span class="gi">+    parse_header_links,</span>
<span class="gi">+    requote_uri,</span>
<span class="gi">+    stream_decode_response_unicode,</span>
<span class="gi">+    super_len,</span>
<span class="gi">+    to_key_val_list,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+#: The set of HTTP status codes that indicate an automatically</span>
<span class="gi">+#: processable redirect.</span>
<span class="gi">+REDIRECT_STATI = (</span>
<span class="gi">+    codes.moved,  # 301</span>
<span class="gi">+    codes.found,  # 302</span>
<span class="gi">+    codes.other,  # 303</span>
<span class="gi">+    codes.temporary_redirect,  # 307</span>
<span class="gi">+    codes.permanent_redirect,  # 308</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="w"> </span>DEFAULT_REDIRECT_LIMIT = 30
<span class="w"> </span>CONTENT_CHUNK_SIZE = 10 * 1024
<span class="w"> </span>ITER_CHUNK_SIZE = 512


<span class="w"> </span>class RequestEncodingMixin:
<span class="gd">-</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def path_url(self):
<span class="w"> </span>        &quot;&quot;&quot;Build the path URL to use.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        url = []</span>
<span class="gi">+</span>
<span class="gi">+        p = urlsplit(self.url)</span>
<span class="gi">+</span>
<span class="gi">+        path = p.path</span>
<span class="gi">+        if not path:</span>
<span class="gi">+            path = &quot;/&quot;</span>
<span class="gi">+</span>
<span class="gi">+        url.append(path)</span>
<span class="gi">+</span>
<span class="gi">+        query = p.query</span>
<span class="gi">+        if query:</span>
<span class="gi">+            url.append(&quot;?&quot;)</span>
<span class="gi">+            url.append(query)</span>
<span class="gi">+</span>
<span class="gi">+        return &quot;&quot;.join(url)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _encode_params(data):
<span class="gu">@@ -48,7 +111,27 @@ class RequestEncodingMixin:</span>
<span class="w"> </span>        2-tuples. Order is retained if data is a list of 2-tuples but arbitrary
<span class="w"> </span>        if parameters are supplied as a dict.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(data, (str, bytes)):</span>
<span class="gi">+            return data</span>
<span class="gi">+        elif hasattr(data, &quot;read&quot;):</span>
<span class="gi">+            return data</span>
<span class="gi">+        elif hasattr(data, &quot;__iter__&quot;):</span>
<span class="gi">+            result = []</span>
<span class="gi">+            for k, vs in to_key_val_list(data):</span>
<span class="gi">+                if isinstance(vs, basestring) or not hasattr(vs, &quot;__iter__&quot;):</span>
<span class="gi">+                    vs = [vs]</span>
<span class="gi">+                for v in vs:</span>
<span class="gi">+                    if v is not None:</span>
<span class="gi">+                        result.append(</span>
<span class="gi">+                            (</span>
<span class="gi">+                                k.encode(&quot;utf-8&quot;) if isinstance(k, str) else k,</span>
<span class="gi">+                                v.encode(&quot;utf-8&quot;) if isinstance(v, str) else v,</span>
<span class="gi">+                            )</span>
<span class="gi">+                        )</span>
<span class="gi">+            return urlencode(result, doseq=True)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return data</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _encode_files(files, data):
<span class="gu">@@ -60,20 +143,88 @@ class RequestEncodingMixin:</span>
<span class="w"> </span>        The tuples may be 2-tuples (filename, fileobj), 3-tuples (filename, fileobj, contentype)
<span class="w"> </span>        or 4-tuples (filename, fileobj, contentype, custom_headers).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not files:</span>
<span class="gi">+            raise ValueError(&quot;Files must be provided.&quot;)</span>
<span class="gi">+        elif isinstance(data, basestring):</span>
<span class="gi">+            raise ValueError(&quot;Data must not be a string.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        new_fields = []</span>
<span class="gi">+        fields = to_key_val_list(data or {})</span>
<span class="gi">+        files = to_key_val_list(files or {})</span>
<span class="gi">+</span>
<span class="gi">+        for field, val in fields:</span>
<span class="gi">+            if isinstance(val, basestring) or not hasattr(val, &quot;__iter__&quot;):</span>
<span class="gi">+                val = [val]</span>
<span class="gi">+            for v in val:</span>
<span class="gi">+                if v is not None:</span>
<span class="gi">+                    # Don&#39;t call str() on bytestrings: in Py3 it all goes wrong.</span>
<span class="gi">+                    if not isinstance(v, bytes):</span>
<span class="gi">+                        v = str(v)</span>
<span class="gi">+</span>
<span class="gi">+                    new_fields.append(</span>
<span class="gi">+                        (</span>
<span class="gi">+                            field.decode(&quot;utf-8&quot;)</span>
<span class="gi">+                            if isinstance(field, bytes)</span>
<span class="gi">+                            else field,</span>
<span class="gi">+                            v.encode(&quot;utf-8&quot;) if isinstance(v, str) else v,</span>
<span class="gi">+                        )</span>
<span class="gi">+                    )</span>
<span class="gi">+</span>
<span class="gi">+        for k, v in files:</span>
<span class="gi">+            # support for explicit filename</span>
<span class="gi">+            ft = None</span>
<span class="gi">+            fh = None</span>
<span class="gi">+            if isinstance(v, (tuple, list)):</span>
<span class="gi">+                if len(v) == 2:</span>
<span class="gi">+                    fn, fp = v</span>
<span class="gi">+                elif len(v) == 3:</span>
<span class="gi">+                    fn, fp, ft = v</span>
<span class="gi">+                else:</span>
<span class="gi">+                    fn, fp, ft, fh = v</span>
<span class="gi">+            else:</span>
<span class="gi">+                fn = guess_filename(v) or k</span>
<span class="gi">+                fp = v</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(fp, (str, bytes, bytearray)):</span>
<span class="gi">+                fdata = fp</span>
<span class="gi">+            elif hasattr(fp, &quot;read&quot;):</span>
<span class="gi">+                fdata = fp.read()</span>
<span class="gi">+            elif fp is None:</span>
<span class="gi">+                continue</span>
<span class="gi">+            else:</span>
<span class="gi">+                fdata = fp</span>
<span class="gi">+</span>
<span class="gi">+            rf = RequestField(name=k, data=fdata, filename=fn, headers=fh)</span>
<span class="gi">+            rf.make_multipart(content_type=ft)</span>
<span class="gi">+            new_fields.append(rf)</span>
<span class="gi">+</span>
<span class="gi">+        body, content_type = encode_multipart_formdata(new_fields)</span>
<span class="gi">+</span>
<span class="gi">+        return body, content_type</span>


<span class="w"> </span>class RequestHooksMixin:
<span class="gd">-</span>
<span class="w"> </span>    def register_hook(self, event, hook):
<span class="w"> </span>        &quot;&quot;&quot;Properly register a hook.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if event not in self.hooks:</span>
<span class="gi">+            raise ValueError(f&#39;Unsupported event specified, with event name &quot;{event}&quot;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(hook, Callable):</span>
<span class="gi">+            self.hooks[event].append(hook)</span>
<span class="gi">+        elif hasattr(hook, &quot;__iter__&quot;):</span>
<span class="gi">+            self.hooks[event].extend(h for h in hook if isinstance(h, Callable))</span>

<span class="w"> </span>    def deregister_hook(self, event, hook):
<span class="w"> </span>        &quot;&quot;&quot;Deregister a previously registered hook.
<span class="w"> </span>        Returns True if the hook existed, False if not.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.hooks[event].remove(hook)</span>
<span class="gi">+            return True</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            return False</span>


<span class="w"> </span>class Request(RequestHooksMixin):
<span class="gu">@@ -104,17 +255,30 @@ class Request(RequestHooksMixin):</span>
<span class="w"> </span>      &lt;PreparedRequest [GET]&gt;
<span class="w"> </span>    &quot;&quot;&quot;

<span class="gd">-    def __init__(self, method=None, url=None, headers=None, files=None,</span>
<span class="gd">-        data=None, params=None, auth=None, cookies=None, hooks=None, json=None</span>
<span class="gd">-        ):</span>
<span class="gi">+    def __init__(</span>
<span class="gi">+        self,</span>
<span class="gi">+        method=None,</span>
<span class="gi">+        url=None,</span>
<span class="gi">+        headers=None,</span>
<span class="gi">+        files=None,</span>
<span class="gi">+        data=None,</span>
<span class="gi">+        params=None,</span>
<span class="gi">+        auth=None,</span>
<span class="gi">+        cookies=None,</span>
<span class="gi">+        hooks=None,</span>
<span class="gi">+        json=None,</span>
<span class="gi">+    ):</span>
<span class="gi">+        # Default empty dicts for dict params.</span>
<span class="w"> </span>        data = [] if data is None else data
<span class="w"> </span>        files = [] if files is None else files
<span class="w"> </span>        headers = {} if headers is None else headers
<span class="w"> </span>        params = {} if params is None else params
<span class="w"> </span>        hooks = {} if hooks is None else hooks
<span class="gi">+</span>
<span class="w"> </span>        self.hooks = default_hooks()
<span class="w"> </span>        for k, v in list(hooks.items()):
<span class="w"> </span>            self.register_hook(event=k, hook=v)
<span class="gi">+</span>
<span class="w"> </span>        self.method = method
<span class="w"> </span>        self.url = url
<span class="w"> </span>        self.headers = headers
<span class="gu">@@ -126,11 +290,24 @@ class Request(RequestHooksMixin):</span>
<span class="w"> </span>        self.cookies = cookies

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;&lt;Request [{self.method}]&gt;&#39;</span>
<span class="gi">+        return f&quot;&lt;Request [{self.method}]&gt;&quot;</span>

<span class="w"> </span>    def prepare(self):
<span class="w"> </span>        &quot;&quot;&quot;Constructs a :class:`PreparedRequest &lt;PreparedRequest&gt;` for transmission and returns it.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        p = PreparedRequest()</span>
<span class="gi">+        p.prepare(</span>
<span class="gi">+            method=self.method,</span>
<span class="gi">+            url=self.url,</span>
<span class="gi">+            headers=self.headers,</span>
<span class="gi">+            files=self.files,</span>
<span class="gi">+            data=self.data,</span>
<span class="gi">+            json=self.json,</span>
<span class="gi">+            params=self.params,</span>
<span class="gi">+            auth=self.auth,</span>
<span class="gi">+            cookies=self.cookies,</span>
<span class="gi">+            hooks=self.hooks,</span>
<span class="gi">+        )</span>
<span class="gi">+        return p</span>


<span class="w"> </span>class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):
<span class="gu">@@ -155,45 +332,280 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):</span>
<span class="w"> </span>    &quot;&quot;&quot;

<span class="w"> </span>    def __init__(self):
<span class="gi">+        #: HTTP verb to send to the server.</span>
<span class="w"> </span>        self.method = None
<span class="gi">+        #: HTTP URL to send the request to.</span>
<span class="w"> </span>        self.url = None
<span class="gi">+        #: dictionary of HTTP headers.</span>
<span class="w"> </span>        self.headers = None
<span class="gi">+        # The `CookieJar` used to create the Cookie header will be stored here</span>
<span class="gi">+        # after prepare_cookies is called</span>
<span class="w"> </span>        self._cookies = None
<span class="gi">+        #: request body to send to the server.</span>
<span class="w"> </span>        self.body = None
<span class="gi">+        #: dictionary of callback hooks, for internal usage.</span>
<span class="w"> </span>        self.hooks = default_hooks()
<span class="gi">+        #: integer denoting starting position of a readable file-like body.</span>
<span class="w"> </span>        self._body_position = None

<span class="gd">-    def prepare(self, method=None, url=None, headers=None, files=None, data</span>
<span class="gd">-        =None, params=None, auth=None, cookies=None, hooks=None, json=None):</span>
<span class="gi">+    def prepare(</span>
<span class="gi">+        self,</span>
<span class="gi">+        method=None,</span>
<span class="gi">+        url=None,</span>
<span class="gi">+        headers=None,</span>
<span class="gi">+        files=None,</span>
<span class="gi">+        data=None,</span>
<span class="gi">+        params=None,</span>
<span class="gi">+        auth=None,</span>
<span class="gi">+        cookies=None,</span>
<span class="gi">+        hooks=None,</span>
<span class="gi">+        json=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Prepares the entire request with the given parameters.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        self.prepare_method(method)</span>
<span class="gi">+        self.prepare_url(url, params)</span>
<span class="gi">+        self.prepare_headers(headers)</span>
<span class="gi">+        self.prepare_cookies(cookies)</span>
<span class="gi">+        self.prepare_body(data, files, json)</span>
<span class="gi">+        self.prepare_auth(auth, url)</span>
<span class="gi">+</span>
<span class="gi">+        # Note that prepare_auth must be last to enable authentication schemes</span>
<span class="gi">+        # such as OAuth to work on a fully prepared request.</span>
<span class="gi">+</span>
<span class="gi">+        # This MUST go after prepare_auth. Authenticators could add a hook</span>
<span class="gi">+        self.prepare_hooks(hooks)</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;&lt;PreparedRequest [{self.method}]&gt;&#39;</span>
<span class="gi">+        return f&quot;&lt;PreparedRequest [{self.method}]&gt;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def copy(self):</span>
<span class="gi">+        p = PreparedRequest()</span>
<span class="gi">+        p.method = self.method</span>
<span class="gi">+        p.url = self.url</span>
<span class="gi">+        p.headers = self.headers.copy() if self.headers is not None else None</span>
<span class="gi">+        p._cookies = _copy_cookie_jar(self._cookies)</span>
<span class="gi">+        p.body = self.body</span>
<span class="gi">+        p.hooks = self.hooks</span>
<span class="gi">+        p._body_position = self._body_position</span>
<span class="gi">+        return p</span>

<span class="w"> </span>    def prepare_method(self, method):
<span class="w"> </span>        &quot;&quot;&quot;Prepares the given HTTP method.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.method = method</span>
<span class="gi">+        if self.method is not None:</span>
<span class="gi">+            self.method = to_native_string(self.method.upper())</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def _get_idna_encoded_host(host):</span>
<span class="gi">+        import idna</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            host = idna.encode(host, uts46=True).decode(&quot;utf-8&quot;)</span>
<span class="gi">+        except idna.IDNAError:</span>
<span class="gi">+            raise UnicodeError</span>
<span class="gi">+        return host</span>

<span class="w"> </span>    def prepare_url(self, url, params):
<span class="w"> </span>        &quot;&quot;&quot;Prepares the given HTTP URL.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        #: Accept objects that have string representations.</span>
<span class="gi">+        #: We&#39;re unable to blindly call unicode/str functions</span>
<span class="gi">+        #: as this will include the bytestring indicator (b&#39;&#39;)</span>
<span class="gi">+        #: on python 3.x.</span>
<span class="gi">+        #: https://github.com/psf/requests/pull/2238</span>
<span class="gi">+        if isinstance(url, bytes):</span>
<span class="gi">+            url = url.decode(&quot;utf8&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            url = str(url)</span>
<span class="gi">+</span>
<span class="gi">+        # Remove leading whitespaces from url</span>
<span class="gi">+        url = url.lstrip()</span>
<span class="gi">+</span>
<span class="gi">+        # Don&#39;t do any URL preparation for non-HTTP schemes like `mailto`,</span>
<span class="gi">+        # `data` etc to work around exceptions from `url_parse`, which</span>
<span class="gi">+        # handles RFC 3986 only.</span>
<span class="gi">+        if &quot;:&quot; in url and not url.lower().startswith(&quot;http&quot;):</span>
<span class="gi">+            self.url = url</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Support for unicode domain names and paths.</span>
<span class="gi">+        try:</span>
<span class="gi">+            scheme, auth, host, port, path, query, fragment = parse_url(url)</span>
<span class="gi">+        except LocationParseError as e:</span>
<span class="gi">+            raise InvalidURL(*e.args)</span>
<span class="gi">+</span>
<span class="gi">+        if not scheme:</span>
<span class="gi">+            raise MissingSchema(</span>
<span class="gi">+                f&quot;Invalid URL {url!r}: No scheme supplied. &quot;</span>
<span class="gi">+                f&quot;Perhaps you meant https://{url}?&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if not host:</span>
<span class="gi">+            raise InvalidURL(f&quot;Invalid URL {url!r}: No host supplied&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # In general, we want to try IDNA encoding the hostname if the string contains</span>
<span class="gi">+        # non-ASCII characters. This allows users to automatically get the correct IDNA</span>
<span class="gi">+        # behaviour. For strings containing only ASCII characters, we need to also verify</span>
<span class="gi">+        # it doesn&#39;t start with a wildcard (*), before allowing the unencoded hostname.</span>
<span class="gi">+        if not unicode_is_ascii(host):</span>
<span class="gi">+            try:</span>
<span class="gi">+                host = self._get_idna_encoded_host(host)</span>
<span class="gi">+            except UnicodeError:</span>
<span class="gi">+                raise InvalidURL(&quot;URL has an invalid label.&quot;)</span>
<span class="gi">+        elif host.startswith((&quot;*&quot;, &quot;.&quot;)):</span>
<span class="gi">+            raise InvalidURL(&quot;URL has an invalid label.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Carefully reconstruct the network location</span>
<span class="gi">+        netloc = auth or &quot;&quot;</span>
<span class="gi">+        if netloc:</span>
<span class="gi">+            netloc += &quot;@&quot;</span>
<span class="gi">+        netloc += host</span>
<span class="gi">+        if port:</span>
<span class="gi">+            netloc += f&quot;:{port}&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Bare domains aren&#39;t valid URLs.</span>
<span class="gi">+        if not path:</span>
<span class="gi">+            path = &quot;/&quot;</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(params, (str, bytes)):</span>
<span class="gi">+            params = to_native_string(params)</span>
<span class="gi">+</span>
<span class="gi">+        enc_params = self._encode_params(params)</span>
<span class="gi">+        if enc_params:</span>
<span class="gi">+            if query:</span>
<span class="gi">+                query = f&quot;{query}&amp;{enc_params}&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                query = enc_params</span>
<span class="gi">+</span>
<span class="gi">+        url = requote_uri(urlunparse([scheme, netloc, path, None, query, fragment]))</span>
<span class="gi">+        self.url = url</span>

<span class="w"> </span>    def prepare_headers(self, headers):
<span class="w"> </span>        &quot;&quot;&quot;Prepares the given HTTP headers.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        self.headers = CaseInsensitiveDict()</span>
<span class="gi">+        if headers:</span>
<span class="gi">+            for header in headers.items():</span>
<span class="gi">+                # Raise exception on invalid header value.</span>
<span class="gi">+                check_header_validity(header)</span>
<span class="gi">+                name, value = header</span>
<span class="gi">+                self.headers[to_native_string(name)] = value</span>

<span class="w"> </span>    def prepare_body(self, data, files, json=None):
<span class="w"> </span>        &quot;&quot;&quot;Prepares the given HTTP body data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # Check if file, fo, generator, iterator.</span>
<span class="gi">+        # If not, run through normal process.</span>
<span class="gi">+</span>
<span class="gi">+        # Nottin&#39; on you.</span>
<span class="gi">+        body = None</span>
<span class="gi">+        content_type = None</span>
<span class="gi">+</span>
<span class="gi">+        if not data and json is not None:</span>
<span class="gi">+            # urllib3 requires a bytes-like body. Python 2&#39;s json.dumps</span>
<span class="gi">+            # provides this natively, but Python 3 gives a Unicode string.</span>
<span class="gi">+            content_type = &quot;application/json&quot;</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                body = complexjson.dumps(json, allow_nan=False)</span>
<span class="gi">+            except ValueError as ve:</span>
<span class="gi">+                raise InvalidJSONError(ve, request=self)</span>
<span class="gi">+</span>
<span class="gi">+            if not isinstance(body, bytes):</span>
<span class="gi">+                body = body.encode(&quot;utf-8&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        is_stream = all(</span>
<span class="gi">+            [</span>
<span class="gi">+                hasattr(data, &quot;__iter__&quot;),</span>
<span class="gi">+                not isinstance(data, (basestring, list, tuple, Mapping)),</span>
<span class="gi">+            ]</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        if is_stream:</span>
<span class="gi">+            try:</span>
<span class="gi">+                length = super_len(data)</span>
<span class="gi">+            except (TypeError, AttributeError, UnsupportedOperation):</span>
<span class="gi">+                length = None</span>
<span class="gi">+</span>
<span class="gi">+            body = data</span>
<span class="gi">+</span>
<span class="gi">+            if getattr(body, &quot;tell&quot;, None) is not None:</span>
<span class="gi">+                # Record the current file position before reading.</span>
<span class="gi">+                # This will allow us to rewind a file in the event</span>
<span class="gi">+                # of a redirect.</span>
<span class="gi">+                try:</span>
<span class="gi">+                    self._body_position = body.tell()</span>
<span class="gi">+                except OSError:</span>
<span class="gi">+                    # This differentiates from None, allowing us to catch</span>
<span class="gi">+                    # a failed `tell()` later when trying to rewind the body</span>
<span class="gi">+                    self._body_position = object()</span>
<span class="gi">+</span>
<span class="gi">+            if files:</span>
<span class="gi">+                raise NotImplementedError(</span>
<span class="gi">+                    &quot;Streamed bodies and files are mutually exclusive.&quot;</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            if length:</span>
<span class="gi">+                self.headers[&quot;Content-Length&quot;] = builtin_str(length)</span>
<span class="gi">+            else:</span>
<span class="gi">+                self.headers[&quot;Transfer-Encoding&quot;] = &quot;chunked&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Multi-part file uploads.</span>
<span class="gi">+            if files:</span>
<span class="gi">+                (body, content_type) = self._encode_files(files, data)</span>
<span class="gi">+            else:</span>
<span class="gi">+                if data:</span>
<span class="gi">+                    body = self._encode_params(data)</span>
<span class="gi">+                    if isinstance(data, basestring) or hasattr(data, &quot;read&quot;):</span>
<span class="gi">+                        content_type = None</span>
<span class="gi">+                    else:</span>
<span class="gi">+                        content_type = &quot;application/x-www-form-urlencoded&quot;</span>
<span class="gi">+</span>
<span class="gi">+            self.prepare_content_length(body)</span>
<span class="gi">+</span>
<span class="gi">+            # Add content-type if it wasn&#39;t explicitly provided.</span>
<span class="gi">+            if content_type and (&quot;content-type&quot; not in self.headers):</span>
<span class="gi">+                self.headers[&quot;Content-Type&quot;] = content_type</span>
<span class="gi">+</span>
<span class="gi">+        self.body = body</span>

<span class="w"> </span>    def prepare_content_length(self, body):
<span class="w"> </span>        &quot;&quot;&quot;Prepare Content-Length header based on request method and body&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if body is not None:</span>
<span class="gi">+            length = super_len(body)</span>
<span class="gi">+            if length:</span>
<span class="gi">+                # If length exists, set it. Otherwise, we fallback</span>
<span class="gi">+                # to Transfer-Encoding: chunked.</span>
<span class="gi">+                self.headers[&quot;Content-Length&quot;] = builtin_str(length)</span>
<span class="gi">+        elif (</span>
<span class="gi">+            self.method not in (&quot;GET&quot;, &quot;HEAD&quot;)</span>
<span class="gi">+            and self.headers.get(&quot;Content-Length&quot;) is None</span>
<span class="gi">+        ):</span>
<span class="gi">+            # Set Content-Length to 0 for methods that can have a body</span>
<span class="gi">+            # but don&#39;t provide one. (i.e. not GET or HEAD)</span>
<span class="gi">+            self.headers[&quot;Content-Length&quot;] = &quot;0&quot;</span>

<span class="gd">-    def prepare_auth(self, auth, url=&#39;&#39;):</span>
<span class="gi">+    def prepare_auth(self, auth, url=&quot;&quot;):</span>
<span class="w"> </span>        &quot;&quot;&quot;Prepares the given HTTP auth data.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # If no Auth is explicitly provided, extract it from the URL first.</span>
<span class="gi">+        if auth is None:</span>
<span class="gi">+            url_auth = get_auth_from_url(self.url)</span>
<span class="gi">+            auth = url_auth if any(url_auth) else None</span>
<span class="gi">+</span>
<span class="gi">+        if auth:</span>
<span class="gi">+            if isinstance(auth, tuple) and len(auth) == 2:</span>
<span class="gi">+                # special-case basic HTTP auth</span>
<span class="gi">+                auth = HTTPBasicAuth(*auth)</span>
<span class="gi">+</span>
<span class="gi">+            # Allow auth to make its changes.</span>
<span class="gi">+            r = auth(self)</span>
<span class="gi">+</span>
<span class="gi">+            # Update self to reflect the auth changes.</span>
<span class="gi">+            self.__dict__.update(r.__dict__)</span>
<span class="gi">+</span>
<span class="gi">+            # Recompute Content-Length</span>
<span class="gi">+            self.prepare_content_length(self.body)</span>

<span class="w"> </span>    def prepare_cookies(self, cookies):
<span class="w"> </span>        &quot;&quot;&quot;Prepares the given HTTP cookie data.
<span class="gu">@@ -206,33 +618,88 @@ class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):</span>
<span class="w"> </span>        to ``prepare_cookies`` will have no actual effect, unless the &quot;Cookie&quot;
<span class="w"> </span>        header is removed beforehand.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if isinstance(cookies, cookielib.CookieJar):</span>
<span class="gi">+            self._cookies = cookies</span>
<span class="gi">+        else:</span>
<span class="gi">+            self._cookies = cookiejar_from_dict(cookies)</span>
<span class="gi">+</span>
<span class="gi">+        cookie_header = get_cookie_header(self._cookies, self)</span>
<span class="gi">+        if cookie_header is not None:</span>
<span class="gi">+            self.headers[&quot;Cookie&quot;] = cookie_header</span>

<span class="w"> </span>    def prepare_hooks(self, hooks):
<span class="w"> </span>        &quot;&quot;&quot;Prepares the given hooks.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # hooks can be passed as None to the prepare method and to this</span>
<span class="gi">+        # method. To prevent iterating over None, simply use an empty list</span>
<span class="gi">+        # if hooks is False-y</span>
<span class="gi">+        hooks = hooks or []</span>
<span class="gi">+        for event in hooks:</span>
<span class="gi">+            self.register_hook(event, hooks[event])</span>


<span class="w"> </span>class Response:
<span class="w"> </span>    &quot;&quot;&quot;The :class:`Response &lt;Response&gt;` object, which contains a
<span class="w"> </span>    server&#39;s response to an HTTP request.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __attrs__ = [&#39;_content&#39;, &#39;status_code&#39;, &#39;headers&#39;, &#39;url&#39;, &#39;history&#39;,</span>
<span class="gd">-        &#39;encoding&#39;, &#39;reason&#39;, &#39;cookies&#39;, &#39;elapsed&#39;, &#39;request&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    __attrs__ = [</span>
<span class="gi">+        &quot;_content&quot;,</span>
<span class="gi">+        &quot;status_code&quot;,</span>
<span class="gi">+        &quot;headers&quot;,</span>
<span class="gi">+        &quot;url&quot;,</span>
<span class="gi">+        &quot;history&quot;,</span>
<span class="gi">+        &quot;encoding&quot;,</span>
<span class="gi">+        &quot;reason&quot;,</span>
<span class="gi">+        &quot;cookies&quot;,</span>
<span class="gi">+        &quot;elapsed&quot;,</span>
<span class="gi">+        &quot;request&quot;,</span>
<span class="gi">+    ]</span>

<span class="w"> </span>    def __init__(self):
<span class="w"> </span>        self._content = False
<span class="w"> </span>        self._content_consumed = False
<span class="w"> </span>        self._next = None
<span class="gi">+</span>
<span class="gi">+        #: Integer Code of responded HTTP Status, e.g. 404 or 200.</span>
<span class="w"> </span>        self.status_code = None
<span class="gi">+</span>
<span class="gi">+        #: Case-insensitive Dictionary of Response Headers.</span>
<span class="gi">+        #: For example, ``headers[&#39;content-encoding&#39;]`` will return the</span>
<span class="gi">+        #: value of a ``&#39;Content-Encoding&#39;`` response header.</span>
<span class="w"> </span>        self.headers = CaseInsensitiveDict()
<span class="gi">+</span>
<span class="gi">+        #: File-like object representation of response (for advanced usage).</span>
<span class="gi">+        #: Use of ``raw`` requires that ``stream=True`` be set on the request.</span>
<span class="gi">+        #: This requirement does not apply for use internally to Requests.</span>
<span class="w"> </span>        self.raw = None
<span class="gi">+</span>
<span class="gi">+        #: Final URL location of Response.</span>
<span class="w"> </span>        self.url = None
<span class="gi">+</span>
<span class="gi">+        #: Encoding to decode with when accessing r.text.</span>
<span class="w"> </span>        self.encoding = None
<span class="gi">+</span>
<span class="gi">+        #: A list of :class:`Response &lt;Response&gt;` objects from</span>
<span class="gi">+        #: the history of the Request. Any redirect responses will end</span>
<span class="gi">+        #: up here. The list is sorted from the oldest to the most recent request.</span>
<span class="w"> </span>        self.history = []
<span class="gi">+</span>
<span class="gi">+        #: Textual reason of responded HTTP Status, e.g. &quot;Not Found&quot; or &quot;OK&quot;.</span>
<span class="w"> </span>        self.reason = None
<span class="gi">+</span>
<span class="gi">+        #: A CookieJar of Cookies the server sent back.</span>
<span class="w"> </span>        self.cookies = cookiejar_from_dict({})
<span class="gi">+</span>
<span class="gi">+        #: The amount of time elapsed between sending the request</span>
<span class="gi">+        #: and the arrival of the response (as a timedelta).</span>
<span class="gi">+        #: This property specifically measures the time taken between sending</span>
<span class="gi">+        #: the first byte of the request and finishing parsing the headers. It</span>
<span class="gi">+        #: is therefore unaffected by consuming the response content or the</span>
<span class="gi">+        #: value of the ``stream`` keyword argument.</span>
<span class="w"> </span>        self.elapsed = datetime.timedelta(0)
<span class="gi">+</span>
<span class="gi">+        #: The :class:`PreparedRequest &lt;PreparedRequest&gt;` object to which this</span>
<span class="gi">+        #: is a response.</span>
<span class="w"> </span>        self.request = None

<span class="w"> </span>    def __enter__(self):
<span class="gu">@@ -242,18 +709,23 @@ class Response:</span>
<span class="w"> </span>        self.close()

<span class="w"> </span>    def __getstate__(self):
<span class="gi">+        # Consume everything; accessing the content attribute makes</span>
<span class="gi">+        # sure the content has been fully read.</span>
<span class="w"> </span>        if not self._content_consumed:
<span class="w"> </span>            self.content
<span class="gi">+</span>
<span class="w"> </span>        return {attr: getattr(self, attr, None) for attr in self.__attrs__}

<span class="w"> </span>    def __setstate__(self, state):
<span class="w"> </span>        for name, value in state.items():
<span class="w"> </span>            setattr(self, name, value)
<span class="gd">-        setattr(self, &#39;_content_consumed&#39;, True)</span>
<span class="gd">-        setattr(self, &#39;raw&#39;, None)</span>
<span class="gi">+</span>
<span class="gi">+        # pickled objects do not have .raw</span>
<span class="gi">+        setattr(self, &quot;_content_consumed&quot;, True)</span>
<span class="gi">+        setattr(self, &quot;raw&quot;, None)</span>

<span class="w"> </span>    def __repr__(self):
<span class="gd">-        return f&#39;&lt;Response [{self.status_code}]&gt;&#39;</span>
<span class="gi">+        return f&quot;&lt;Response [{self.status_code}]&gt;&quot;</span>

<span class="w"> </span>    def __bool__(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns True if :attr:`status_code` is less than 400.
<span class="gu">@@ -288,29 +760,41 @@ class Response:</span>
<span class="w"> </span>        the status code is between 200 and 400, this will return True. This
<span class="w"> </span>        is **not** a check to see if the response code is ``200 OK``.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            self.raise_for_status()</span>
<span class="gi">+        except HTTPError:</span>
<span class="gi">+            return False</span>
<span class="gi">+        return True</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def is_redirect(self):
<span class="w"> </span>        &quot;&quot;&quot;True if this Response is a well-formed HTTP redirect that could have
<span class="w"> </span>        been processed automatically (by :meth:`Session.resolve_redirects`).
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return &quot;location&quot; in self.headers and self.status_code in REDIRECT_STATI</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def is_permanent_redirect(self):
<span class="w"> </span>        &quot;&quot;&quot;True if this Response one of the permanent versions of redirect.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return &quot;location&quot; in self.headers and self.status_code in (</span>
<span class="gi">+            codes.moved_permanently,</span>
<span class="gi">+            codes.permanent_redirect,</span>
<span class="gi">+        )</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def next(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns a PreparedRequest for the next request in a redirect chain, if there is one.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._next</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def apparent_encoding(self):
<span class="w"> </span>        &quot;&quot;&quot;The apparent encoding, provided by the charset_normalizer or chardet libraries.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if chardet is not None:</span>
<span class="gi">+            return chardet.detect(self.content)[&quot;encoding&quot;]</span>
<span class="gi">+        else:</span>
<span class="gi">+            # If no character detection library is available, we&#39;ll fall back</span>
<span class="gi">+            # to a standard Python utf-8 str.</span>
<span class="gi">+            return &quot;utf-8&quot;</span>

<span class="w"> </span>    def iter_content(self, chunk_size=1, decode_unicode=False):
<span class="w"> </span>        &quot;&quot;&quot;Iterates over the response data.  When stream=True is set on the
<span class="gu">@@ -328,22 +812,99 @@ class Response:</span>
<span class="w"> </span>        If decode_unicode is True, content will be decoded using the best
<span class="w"> </span>        available encoding based on the response.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>

<span class="gd">-    def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=False,</span>
<span class="gd">-        delimiter=None):</span>
<span class="gi">+        def generate():</span>
<span class="gi">+            # Special case for urllib3.</span>
<span class="gi">+            if hasattr(self.raw, &quot;stream&quot;):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    yield from self.raw.stream(chunk_size, decode_content=True)</span>
<span class="gi">+                except ProtocolError as e:</span>
<span class="gi">+                    raise ChunkedEncodingError(e)</span>
<span class="gi">+                except DecodeError as e:</span>
<span class="gi">+                    raise ContentDecodingError(e)</span>
<span class="gi">+                except ReadTimeoutError as e:</span>
<span class="gi">+                    raise ConnectionError(e)</span>
<span class="gi">+                except SSLError as e:</span>
<span class="gi">+                    raise RequestsSSLError(e)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Standard file-like object.</span>
<span class="gi">+                while True:</span>
<span class="gi">+                    chunk = self.raw.read(chunk_size)</span>
<span class="gi">+                    if not chunk:</span>
<span class="gi">+                        break</span>
<span class="gi">+                    yield chunk</span>
<span class="gi">+</span>
<span class="gi">+            self._content_consumed = True</span>
<span class="gi">+</span>
<span class="gi">+        if self._content_consumed and isinstance(self._content, bool):</span>
<span class="gi">+            raise StreamConsumedError()</span>
<span class="gi">+        elif chunk_size is not None and not isinstance(chunk_size, int):</span>
<span class="gi">+            raise TypeError(</span>
<span class="gi">+                f&quot;chunk_size must be an int, it is instead a {type(chunk_size)}.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+        # simulate reading small chunks of the content</span>
<span class="gi">+        reused_chunks = iter_slices(self._content, chunk_size)</span>
<span class="gi">+</span>
<span class="gi">+        stream_chunks = generate()</span>
<span class="gi">+</span>
<span class="gi">+        chunks = reused_chunks if self._content_consumed else stream_chunks</span>
<span class="gi">+</span>
<span class="gi">+        if decode_unicode:</span>
<span class="gi">+            chunks = stream_decode_response_unicode(chunks, self)</span>
<span class="gi">+</span>
<span class="gi">+        return chunks</span>
<span class="gi">+</span>
<span class="gi">+    def iter_lines(</span>
<span class="gi">+        self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=False, delimiter=None</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Iterates over the response data, one line at a time.  When
<span class="w"> </span>        stream=True is set on the request, this avoids reading the
<span class="w"> </span>        content at once into memory for large responses.

<span class="w"> </span>        .. note:: This method is not reentrant safe.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        pending = None</span>
<span class="gi">+</span>
<span class="gi">+        for chunk in self.iter_content(</span>
<span class="gi">+            chunk_size=chunk_size, decode_unicode=decode_unicode</span>
<span class="gi">+        ):</span>
<span class="gi">+            if pending is not None:</span>
<span class="gi">+                chunk = pending + chunk</span>
<span class="gi">+</span>
<span class="gi">+            if delimiter:</span>
<span class="gi">+                lines = chunk.split(delimiter)</span>
<span class="gi">+            else:</span>
<span class="gi">+                lines = chunk.splitlines()</span>
<span class="gi">+</span>
<span class="gi">+            if lines and lines[-1] and chunk and lines[-1][-1] == chunk[-1]:</span>
<span class="gi">+                pending = lines.pop()</span>
<span class="gi">+            else:</span>
<span class="gi">+                pending = None</span>
<span class="gi">+</span>
<span class="gi">+            yield from lines</span>
<span class="gi">+</span>
<span class="gi">+        if pending is not None:</span>
<span class="gi">+            yield pending</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def content(self):
<span class="w"> </span>        &quot;&quot;&quot;Content of the response, in bytes.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if self._content is False:</span>
<span class="gi">+            # Read the contents.</span>
<span class="gi">+            if self._content_consumed:</span>
<span class="gi">+                raise RuntimeError(&quot;The content for this response was already consumed&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            if self.status_code == 0 or self.raw is None:</span>
<span class="gi">+                self._content = None</span>
<span class="gi">+            else:</span>
<span class="gi">+                self._content = b&quot;&quot;.join(self.iter_content(CONTENT_CHUNK_SIZE)) or b&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        self._content_consumed = True</span>
<span class="gi">+        # don&#39;t need to release the connection; that&#39;s been handled by urllib3</span>
<span class="gi">+        # since we exhausted the data.</span>
<span class="gi">+        return self._content</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def text(self):
<span class="gu">@@ -357,25 +918,110 @@ class Response:</span>
<span class="w"> </span>        non-HTTP knowledge to make a better guess at the encoding, you should
<span class="w"> </span>        set ``r.encoding`` appropriately before accessing this property.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        # Try charset from content-type</span>
<span class="gi">+        content = None</span>
<span class="gi">+        encoding = self.encoding</span>
<span class="gi">+</span>
<span class="gi">+        if not self.content:</span>
<span class="gi">+            return &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Fallback to auto-detected encoding.</span>
<span class="gi">+        if self.encoding is None:</span>
<span class="gi">+            encoding = self.apparent_encoding</span>
<span class="gi">+</span>
<span class="gi">+        # Decode unicode from given encoding.</span>
<span class="gi">+        try:</span>
<span class="gi">+            content = str(self.content, encoding, errors=&quot;replace&quot;)</span>
<span class="gi">+        except (LookupError, TypeError):</span>
<span class="gi">+            # A LookupError is raised if the encoding was not found which could</span>
<span class="gi">+            # indicate a misspelling or similar mistake.</span>
<span class="gi">+            #</span>
<span class="gi">+            # A TypeError can be raised if encoding is None</span>
<span class="gi">+            #</span>
<span class="gi">+            # So we try blindly encoding.</span>
<span class="gi">+            content = str(self.content, errors=&quot;replace&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        return content</span>

<span class="w"> </span>    def json(self, **kwargs):
<span class="gd">-        &quot;&quot;&quot;Returns the json-encoded content of a response, if any.</span>
<span class="gi">+        r&quot;&quot;&quot;Returns the json-encoded content of a response, if any.</span>

<span class="gd">-        :param \\*\\*kwargs: Optional arguments that ``json.loads`` takes.</span>
<span class="gi">+        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.</span>
<span class="w"> </span>        :raises requests.exceptions.JSONDecodeError: If the response body does not
<span class="w"> </span>            contain valid json.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        if not self.encoding and self.content and len(self.content) &gt; 3:</span>
<span class="gi">+            # No encoding set. JSON RFC 4627 section 3 states we should expect</span>
<span class="gi">+            # UTF-8, -16 or -32. Detect which one to use; If the detection or</span>
<span class="gi">+            # decoding fails, fall back to `self.text` (using charset_normalizer to make</span>
<span class="gi">+            # a best guess).</span>
<span class="gi">+            encoding = guess_json_utf(self.content)</span>
<span class="gi">+            if encoding is not None:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return complexjson.loads(self.content.decode(encoding), **kwargs)</span>
<span class="gi">+                except UnicodeDecodeError:</span>
<span class="gi">+                    # Wrong UTF codec detected; usually because it&#39;s not UTF-8</span>
<span class="gi">+                    # but some other 8-bit codec.  This is an RFC violation,</span>
<span class="gi">+                    # and the server didn&#39;t bother to tell us what codec *was*</span>
<span class="gi">+                    # used.</span>
<span class="gi">+                    pass</span>
<span class="gi">+                except JSONDecodeError as e:</span>
<span class="gi">+                    raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return complexjson.loads(self.text, **kwargs)</span>
<span class="gi">+        except JSONDecodeError as e:</span>
<span class="gi">+            # Catch JSON-related errors and raise as requests.JSONDecodeError</span>
<span class="gi">+            # This aliases json.JSONDecodeError and simplejson.JSONDecodeError</span>
<span class="gi">+            raise RequestsJSONDecodeError(e.msg, e.doc, e.pos)</span>

<span class="w"> </span>    @property
<span class="w"> </span>    def links(self):
<span class="w"> </span>        &quot;&quot;&quot;Returns the parsed header links of the response, if any.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        header = self.headers.get(&quot;link&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        resolved_links = {}</span>
<span class="gi">+</span>
<span class="gi">+        if header:</span>
<span class="gi">+            links = parse_header_links(header)</span>
<span class="gi">+</span>
<span class="gi">+            for link in links:</span>
<span class="gi">+                key = link.get(&quot;rel&quot;) or link.get(&quot;url&quot;)</span>
<span class="gi">+                resolved_links[key] = link</span>
<span class="gi">+</span>
<span class="gi">+        return resolved_links</span>

<span class="w"> </span>    def raise_for_status(self):
<span class="w"> </span>        &quot;&quot;&quot;Raises :class:`HTTPError`, if one occurred.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        http_error_msg = &quot;&quot;</span>
<span class="gi">+        if isinstance(self.reason, bytes):</span>
<span class="gi">+            # We attempt to decode utf-8 first because some servers</span>
<span class="gi">+            # choose to localize their reason strings. If the string</span>
<span class="gi">+            # isn&#39;t utf-8, we fall back to iso-8859-1 for all other</span>
<span class="gi">+            # encodings. (See PR #3538)</span>
<span class="gi">+            try:</span>
<span class="gi">+                reason = self.reason.decode(&quot;utf-8&quot;)</span>
<span class="gi">+            except UnicodeDecodeError:</span>
<span class="gi">+                reason = self.reason.decode(&quot;iso-8859-1&quot;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            reason = self.reason</span>
<span class="gi">+</span>
<span class="gi">+        if 400 &lt;= self.status_code &lt; 500:</span>
<span class="gi">+            http_error_msg = (</span>
<span class="gi">+                f&quot;{self.status_code} Client Error: {reason} for url: {self.url}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        elif 500 &lt;= self.status_code &lt; 600:</span>
<span class="gi">+            http_error_msg = (</span>
<span class="gi">+                f&quot;{self.status_code} Server Error: {reason} for url: {self.url}&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if http_error_msg:</span>
<span class="gi">+            raise HTTPError(http_error_msg, response=self)</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;Releases the connection back to the pool. Once this method has been
<span class="gu">@@ -383,4 +1029,9 @@ class Response:</span>

<span class="w"> </span>        *Note: Should not normally need to be called explicitly.*
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not self._content_consumed:</span>
<span class="gi">+            self.raw.close()</span>
<span class="gi">+</span>
<span class="gi">+        release_conn = getattr(self.raw, &quot;release_conn&quot;, None)</span>
<span class="gi">+        if release_conn is not None:</span>
<span class="gi">+            release_conn()</span>
<span class="gh">diff --git a/src/requests/packages.py b/src/requests/packages.py</span>
<span class="gh">index 959abfb2..5ab3d8e2 100644</span>
<span class="gd">--- a/src/requests/packages.py</span>
<span class="gi">+++ b/src/requests/packages.py</span>
<span class="gu">@@ -1,15 +1,23 @@</span>
<span class="w"> </span>import sys
<span class="gi">+</span>
<span class="w"> </span>from .compat import chardet
<span class="gd">-for package in (&#39;urllib3&#39;, &#39;idna&#39;):</span>
<span class="gi">+</span>
<span class="gi">+# This code exists for backwards compatibility reasons.</span>
<span class="gi">+# I don&#39;t like it either. Just look the other way. :)</span>
<span class="gi">+</span>
<span class="gi">+for package in (&quot;urllib3&quot;, &quot;idna&quot;):</span>
<span class="w"> </span>    locals()[package] = __import__(package)
<span class="gi">+    # This traversal is apparently necessary such that the identities are</span>
<span class="gi">+    # preserved (requests.packages.urllib3.* is urllib3.*)</span>
<span class="w"> </span>    for mod in list(sys.modules):
<span class="gd">-        if mod == package or mod.startswith(f&#39;{package}.&#39;):</span>
<span class="gd">-            sys.modules[f&#39;requests.packages.{mod}&#39;] = sys.modules[mod]</span>
<span class="gi">+        if mod == package or mod.startswith(f&quot;{package}.&quot;):</span>
<span class="gi">+            sys.modules[f&quot;requests.packages.{mod}&quot;] = sys.modules[mod]</span>
<span class="gi">+</span>
<span class="w"> </span>if chardet is not None:
<span class="w"> </span>    target = chardet.__name__
<span class="w"> </span>    for mod in list(sys.modules):
<span class="gd">-        if mod == target or mod.startswith(f&#39;{target}.&#39;):</span>
<span class="gi">+        if mod == target or mod.startswith(f&quot;{target}.&quot;):</span>
<span class="w"> </span>            imported_mod = sys.modules[mod]
<span class="gd">-            sys.modules[f&#39;requests.packages.{mod}&#39;] = imported_mod</span>
<span class="gd">-            mod = mod.replace(target, &#39;chardet&#39;)</span>
<span class="gd">-            sys.modules[f&#39;requests.packages.{mod}&#39;] = imported_mod</span>
<span class="gi">+            sys.modules[f&quot;requests.packages.{mod}&quot;] = imported_mod</span>
<span class="gi">+            mod = mod.replace(target, &quot;chardet&quot;)</span>
<span class="gi">+            sys.modules[f&quot;requests.packages.{mod}&quot;] = imported_mod</span>
<span class="gh">diff --git a/src/requests/sessions.py b/src/requests/sessions.py</span>
<span class="gh">index b286e93c..b387bc36 100644</span>
<span class="gd">--- a/src/requests/sessions.py</span>
<span class="gi">+++ b/src/requests/sessions.py</span>
<span class="gu">@@ -10,18 +10,49 @@ import sys</span>
<span class="w"> </span>import time
<span class="w"> </span>from collections import OrderedDict
<span class="w"> </span>from datetime import timedelta
<span class="gi">+</span>
<span class="w"> </span>from ._internal_utils import to_native_string
<span class="w"> </span>from .adapters import HTTPAdapter
<span class="w"> </span>from .auth import _basic_auth_str
<span class="w"> </span>from .compat import Mapping, cookielib, urljoin, urlparse
<span class="gd">-from .cookies import RequestsCookieJar, cookiejar_from_dict, extract_cookies_to_jar, merge_cookies</span>
<span class="gd">-from .exceptions import ChunkedEncodingError, ContentDecodingError, InvalidSchema, TooManyRedirects</span>
<span class="gi">+from .cookies import (</span>
<span class="gi">+    RequestsCookieJar,</span>
<span class="gi">+    cookiejar_from_dict,</span>
<span class="gi">+    extract_cookies_to_jar,</span>
<span class="gi">+    merge_cookies,</span>
<span class="gi">+)</span>
<span class="gi">+from .exceptions import (</span>
<span class="gi">+    ChunkedEncodingError,</span>
<span class="gi">+    ContentDecodingError,</span>
<span class="gi">+    InvalidSchema,</span>
<span class="gi">+    TooManyRedirects,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .hooks import default_hooks, dispatch_hook
<span class="gd">-from .models import DEFAULT_REDIRECT_LIMIT, REDIRECT_STATI, PreparedRequest, Request</span>
<span class="gi">+</span>
<span class="gi">+# formerly defined here, reexposed here for backward compatibility</span>
<span class="gi">+from .models import (  # noqa: F401</span>
<span class="gi">+    DEFAULT_REDIRECT_LIMIT,</span>
<span class="gi">+    REDIRECT_STATI,</span>
<span class="gi">+    PreparedRequest,</span>
<span class="gi">+    Request,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .status_codes import codes
<span class="w"> </span>from .structures import CaseInsensitiveDict
<span class="gd">-from .utils import DEFAULT_PORTS, default_headers, get_auth_from_url, get_environ_proxies, get_netrc_auth, requote_uri, resolve_proxies, rewind_body, should_bypass_proxies, to_key_val_list</span>
<span class="gd">-if sys.platform == &#39;win32&#39;:</span>
<span class="gi">+from .utils import (  # noqa: F401</span>
<span class="gi">+    DEFAULT_PORTS,</span>
<span class="gi">+    default_headers,</span>
<span class="gi">+    get_auth_from_url,</span>
<span class="gi">+    get_environ_proxies,</span>
<span class="gi">+    get_netrc_auth,</span>
<span class="gi">+    requote_uri,</span>
<span class="gi">+    resolve_proxies,</span>
<span class="gi">+    rewind_body,</span>
<span class="gi">+    should_bypass_proxies,</span>
<span class="gi">+    to_key_val_list,</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+# Preferred clock, based on which one is more accurate on a given system.</span>
<span class="gi">+if sys.platform == &quot;win32&quot;:</span>
<span class="w"> </span>    preferred_clock = time.perf_counter
<span class="w"> </span>else:
<span class="w"> </span>    preferred_clock = time.time
<span class="gu">@@ -32,7 +63,29 @@ def merge_setting(request_setting, session_setting, dict_class=OrderedDict):</span>
<span class="w"> </span>    the explicit setting on that request, and the setting in the session. If a
<span class="w"> </span>    setting is a dictionary, they will be merged together using `dict_class`
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if session_setting is None:</span>
<span class="gi">+        return request_setting</span>
<span class="gi">+</span>
<span class="gi">+    if request_setting is None:</span>
<span class="gi">+        return session_setting</span>
<span class="gi">+</span>
<span class="gi">+    # Bypass if not a dictionary (e.g. verify)</span>
<span class="gi">+    if not (</span>
<span class="gi">+        isinstance(session_setting, Mapping) and isinstance(request_setting, Mapping)</span>
<span class="gi">+    ):</span>
<span class="gi">+        return request_setting</span>
<span class="gi">+</span>
<span class="gi">+    merged_setting = dict_class(to_key_val_list(session_setting))</span>
<span class="gi">+    merged_setting.update(to_key_val_list(request_setting))</span>
<span class="gi">+</span>
<span class="gi">+    # Remove keys that are set to None. Extract keys first to avoid altering</span>
<span class="gi">+    # the dictionary during iteration.</span>
<span class="gi">+    none_keys = [k for (k, v) in merged_setting.items() if v is None]</span>
<span class="gi">+    for key in none_keys:</span>
<span class="gi">+        del merged_setting[key]</span>
<span class="gi">+</span>
<span class="gi">+    return merged_setting</span>


<span class="w"> </span>def merge_hooks(request_hooks, session_hooks, dict_class=OrderedDict):
<span class="gu">@@ -41,31 +94,210 @@ def merge_hooks(request_hooks, session_hooks, dict_class=OrderedDict):</span>
<span class="w"> </span>    This is necessary because when request_hooks == {&#39;response&#39;: []}, the
<span class="w"> </span>    merge breaks Session hooks entirely.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if session_hooks is None or session_hooks.get(&quot;response&quot;) == []:</span>
<span class="gi">+        return request_hooks</span>

<span class="gi">+    if request_hooks is None or request_hooks.get(&quot;response&quot;) == []:</span>
<span class="gi">+        return session_hooks</span>

<span class="gd">-class SessionRedirectMixin:</span>
<span class="gi">+    return merge_setting(request_hooks, session_hooks, dict_class)</span>

<span class="gi">+</span>
<span class="gi">+class SessionRedirectMixin:</span>
<span class="w"> </span>    def get_redirect_target(self, resp):
<span class="w"> </span>        &quot;&quot;&quot;Receives a Response. Returns a redirect URI or ``None``&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Due to the nature of how requests processes redirects this method will</span>
<span class="gi">+        # be called at least once upon the original response and at least twice</span>
<span class="gi">+        # on each subsequent redirect response (if any).</span>
<span class="gi">+        # If a custom mixin is used to handle this logic, it may be advantageous</span>
<span class="gi">+        # to cache the redirect location onto the response object as a private</span>
<span class="gi">+        # attribute.</span>
<span class="gi">+        if resp.is_redirect:</span>
<span class="gi">+            location = resp.headers[&quot;location&quot;]</span>
<span class="gi">+            # Currently the underlying http module on py3 decode headers</span>
<span class="gi">+            # in latin1, but empirical evidence suggests that latin1 is very</span>
<span class="gi">+            # rarely used with non-ASCII characters in HTTP headers.</span>
<span class="gi">+            # It is more likely to get UTF8 header rather than latin1.</span>
<span class="gi">+            # This causes incorrect handling of UTF8 encoded location headers.</span>
<span class="gi">+            # To solve this, we re-encode the location in latin1.</span>
<span class="gi">+            location = location.encode(&quot;latin1&quot;)</span>
<span class="gi">+            return to_native_string(location, &quot;utf8&quot;)</span>
<span class="gi">+        return None</span>

<span class="w"> </span>    def should_strip_auth(self, old_url, new_url):
<span class="w"> </span>        &quot;&quot;&quot;Decide whether Authorization header should be removed when redirecting&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def resolve_redirects(self, resp, req, stream=False, timeout=None,</span>
<span class="gd">-        verify=True, cert=None, proxies=None, yield_requests=False, **</span>
<span class="gd">-        adapter_kwargs):</span>
<span class="gi">+        old_parsed = urlparse(old_url)</span>
<span class="gi">+        new_parsed = urlparse(new_url)</span>
<span class="gi">+        if old_parsed.hostname != new_parsed.hostname:</span>
<span class="gi">+            return True</span>
<span class="gi">+        # Special case: allow http -&gt; https redirect when using the standard</span>
<span class="gi">+        # ports. This isn&#39;t specified by RFC 7235, but is kept to avoid</span>
<span class="gi">+        # breaking backwards compatibility with older versions of requests</span>
<span class="gi">+        # that allowed any redirects on the same host.</span>
<span class="gi">+        if (</span>
<span class="gi">+            old_parsed.scheme == &quot;http&quot;</span>
<span class="gi">+            and old_parsed.port in (80, None)</span>
<span class="gi">+            and new_parsed.scheme == &quot;https&quot;</span>
<span class="gi">+            and new_parsed.port in (443, None)</span>
<span class="gi">+        ):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # Handle default port usage corresponding to scheme.</span>
<span class="gi">+        changed_port = old_parsed.port != new_parsed.port</span>
<span class="gi">+        changed_scheme = old_parsed.scheme != new_parsed.scheme</span>
<span class="gi">+        default_port = (DEFAULT_PORTS.get(old_parsed.scheme, None), None)</span>
<span class="gi">+        if (</span>
<span class="gi">+            not changed_scheme</span>
<span class="gi">+            and old_parsed.port in default_port</span>
<span class="gi">+            and new_parsed.port in default_port</span>
<span class="gi">+        ):</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # Standard case: root URI must match</span>
<span class="gi">+        return changed_port or changed_scheme</span>
<span class="gi">+</span>
<span class="gi">+    def resolve_redirects(</span>
<span class="gi">+        self,</span>
<span class="gi">+        resp,</span>
<span class="gi">+        req,</span>
<span class="gi">+        stream=False,</span>
<span class="gi">+        timeout=None,</span>
<span class="gi">+        verify=True,</span>
<span class="gi">+        cert=None,</span>
<span class="gi">+        proxies=None,</span>
<span class="gi">+        yield_requests=False,</span>
<span class="gi">+        **adapter_kwargs,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Receives a Response. Returns a generator of Responses or Requests.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        hist = []  # keep track of history</span>
<span class="gi">+</span>
<span class="gi">+        url = self.get_redirect_target(resp)</span>
<span class="gi">+        previous_fragment = urlparse(req.url).fragment</span>
<span class="gi">+        while url:</span>
<span class="gi">+            prepared_request = req.copy()</span>
<span class="gi">+</span>
<span class="gi">+            # Update history and keep track of redirects.</span>
<span class="gi">+            # resp.history must ignore the original request in this loop</span>
<span class="gi">+            hist.append(resp)</span>
<span class="gi">+            resp.history = hist[1:]</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                resp.content  # Consume socket so it can be released</span>
<span class="gi">+            except (ChunkedEncodingError, ContentDecodingError, RuntimeError):</span>
<span class="gi">+                resp.raw.read(decode_content=False)</span>
<span class="gi">+</span>
<span class="gi">+            if len(resp.history) &gt;= self.max_redirects:</span>
<span class="gi">+                raise TooManyRedirects(</span>
<span class="gi">+                    f&quot;Exceeded {self.max_redirects} redirects.&quot;, response=resp</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+            # Release the connection back into the pool.</span>
<span class="gi">+            resp.close()</span>
<span class="gi">+</span>
<span class="gi">+            # Handle redirection without scheme (see: RFC 1808 Section 4)</span>
<span class="gi">+            if url.startswith(&quot;//&quot;):</span>
<span class="gi">+                parsed_rurl = urlparse(resp.url)</span>
<span class="gi">+                url = &quot;:&quot;.join([to_native_string(parsed_rurl.scheme), url])</span>
<span class="gi">+</span>
<span class="gi">+            # Normalize url case and attach previous fragment if needed (RFC 7231 7.1.2)</span>
<span class="gi">+            parsed = urlparse(url)</span>
<span class="gi">+            if parsed.fragment == &quot;&quot; and previous_fragment:</span>
<span class="gi">+                parsed = parsed._replace(fragment=previous_fragment)</span>
<span class="gi">+            elif parsed.fragment:</span>
<span class="gi">+                previous_fragment = parsed.fragment</span>
<span class="gi">+            url = parsed.geturl()</span>
<span class="gi">+</span>
<span class="gi">+            # Facilitate relative &#39;location&#39; headers, as allowed by RFC 7231.</span>
<span class="gi">+            # (e.g. &#39;/path/to/resource&#39; instead of &#39;http://domain.tld/path/to/resource&#39;)</span>
<span class="gi">+            # Compliant with RFC3986, we percent encode the url.</span>
<span class="gi">+            if not parsed.netloc:</span>
<span class="gi">+                url = urljoin(resp.url, requote_uri(url))</span>
<span class="gi">+            else:</span>
<span class="gi">+                url = requote_uri(url)</span>
<span class="gi">+</span>
<span class="gi">+            prepared_request.url = to_native_string(url)</span>
<span class="gi">+</span>
<span class="gi">+            self.rebuild_method(prepared_request, resp)</span>
<span class="gi">+</span>
<span class="gi">+            # https://github.com/psf/requests/issues/1084</span>
<span class="gi">+            if resp.status_code not in (</span>
<span class="gi">+                codes.temporary_redirect,</span>
<span class="gi">+                codes.permanent_redirect,</span>
<span class="gi">+            ):</span>
<span class="gi">+                # https://github.com/psf/requests/issues/3490</span>
<span class="gi">+                purged_headers = (&quot;Content-Length&quot;, &quot;Content-Type&quot;, &quot;Transfer-Encoding&quot;)</span>
<span class="gi">+                for header in purged_headers:</span>
<span class="gi">+                    prepared_request.headers.pop(header, None)</span>
<span class="gi">+                prepared_request.body = None</span>
<span class="gi">+</span>
<span class="gi">+            headers = prepared_request.headers</span>
<span class="gi">+            headers.pop(&quot;Cookie&quot;, None)</span>
<span class="gi">+</span>
<span class="gi">+            # Extract any cookies sent on the response to the cookiejar</span>
<span class="gi">+            # in the new request. Because we&#39;ve mutated our copied prepared</span>
<span class="gi">+            # request, use the old one that we haven&#39;t yet touched.</span>
<span class="gi">+            extract_cookies_to_jar(prepared_request._cookies, req, resp.raw)</span>
<span class="gi">+            merge_cookies(prepared_request._cookies, self.cookies)</span>
<span class="gi">+            prepared_request.prepare_cookies(prepared_request._cookies)</span>
<span class="gi">+</span>
<span class="gi">+            # Rebuild auth and proxy information.</span>
<span class="gi">+            proxies = self.rebuild_proxies(prepared_request, proxies)</span>
<span class="gi">+            self.rebuild_auth(prepared_request, resp)</span>
<span class="gi">+</span>
<span class="gi">+            # A failed tell() sets `_body_position` to `object()`. This non-None</span>
<span class="gi">+            # value ensures `rewindable` will be True, allowing us to raise an</span>
<span class="gi">+            # UnrewindableBodyError, instead of hanging the connection.</span>
<span class="gi">+            rewindable = prepared_request._body_position is not None and (</span>
<span class="gi">+                &quot;Content-Length&quot; in headers or &quot;Transfer-Encoding&quot; in headers</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+            # Attempt to rewind consumed file-like object.</span>
<span class="gi">+            if rewindable:</span>
<span class="gi">+                rewind_body(prepared_request)</span>
<span class="gi">+</span>
<span class="gi">+            # Override the original request.</span>
<span class="gi">+            req = prepared_request</span>
<span class="gi">+</span>
<span class="gi">+            if yield_requests:</span>
<span class="gi">+                yield req</span>
<span class="gi">+            else:</span>
<span class="gi">+                resp = self.send(</span>
<span class="gi">+                    req,</span>
<span class="gi">+                    stream=stream,</span>
<span class="gi">+                    timeout=timeout,</span>
<span class="gi">+                    verify=verify,</span>
<span class="gi">+                    cert=cert,</span>
<span class="gi">+                    proxies=proxies,</span>
<span class="gi">+                    allow_redirects=False,</span>
<span class="gi">+                    **adapter_kwargs,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+                extract_cookies_to_jar(self.cookies, prepared_request, resp.raw)</span>
<span class="gi">+</span>
<span class="gi">+                # extract redirect url, if any, for the next loop</span>
<span class="gi">+                url = self.get_redirect_target(resp)</span>
<span class="gi">+                yield resp</span>

<span class="w"> </span>    def rebuild_auth(self, prepared_request, response):
<span class="w"> </span>        &quot;&quot;&quot;When being redirected we may want to strip authentication from the
<span class="w"> </span>        request to avoid leaking credentials. This method intelligently removes
<span class="w"> </span>        and reapplies authentication where possible to avoid credential loss.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        headers = prepared_request.headers</span>
<span class="gi">+        url = prepared_request.url</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;Authorization&quot; in headers and self.should_strip_auth(</span>
<span class="gi">+            response.request.url, url</span>
<span class="gi">+        ):</span>
<span class="gi">+            # If we get redirected to a new host, we should strip out any</span>
<span class="gi">+            # authentication headers.</span>
<span class="gi">+            del headers[&quot;Authorization&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        # .netrc might have more auth for us on our new host.</span>
<span class="gi">+        new_auth = get_netrc_auth(url) if self.trust_env else None</span>
<span class="gi">+        if new_auth is not None:</span>
<span class="gi">+            prepared_request.prepare_auth(new_auth)</span>

<span class="w"> </span>    def rebuild_proxies(self, prepared_request, proxies):
<span class="w"> </span>        &quot;&quot;&quot;This method re-evaluates the proxy configuration by considering the
<span class="gu">@@ -79,13 +311,46 @@ class SessionRedirectMixin:</span>

<span class="w"> </span>        :rtype: dict
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        headers = prepared_request.headers</span>
<span class="gi">+        scheme = urlparse(prepared_request.url).scheme</span>
<span class="gi">+        new_proxies = resolve_proxies(prepared_request, proxies, self.trust_env)</span>
<span class="gi">+</span>
<span class="gi">+        if &quot;Proxy-Authorization&quot; in headers:</span>
<span class="gi">+            del headers[&quot;Proxy-Authorization&quot;]</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            username, password = get_auth_from_url(new_proxies[scheme])</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            username, password = None, None</span>
<span class="gi">+</span>
<span class="gi">+        # urllib3 handles proxy authorization for us in the standard adapter.</span>
<span class="gi">+        # Avoid appending this to TLS tunneled requests where it may be leaked.</span>
<span class="gi">+        if not scheme.startswith(&quot;https&quot;) and username and password:</span>
<span class="gi">+            headers[&quot;Proxy-Authorization&quot;] = _basic_auth_str(username, password)</span>
<span class="gi">+</span>
<span class="gi">+        return new_proxies</span>

<span class="w"> </span>    def rebuild_method(self, prepared_request, response):
<span class="w"> </span>        &quot;&quot;&quot;When being redirected we may want to change the method of the request
<span class="w"> </span>        based on certain specs or browser behavior.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        method = prepared_request.method</span>
<span class="gi">+</span>
<span class="gi">+        # https://tools.ietf.org/html/rfc7231#section-6.4.4</span>
<span class="gi">+        if response.status_code == codes.see_other and method != &quot;HEAD&quot;:</span>
<span class="gi">+            method = &quot;GET&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Do what the browsers do, despite standards...</span>
<span class="gi">+        # First, turn 302s into GETs.</span>
<span class="gi">+        if response.status_code == codes.found and method != &quot;HEAD&quot;:</span>
<span class="gi">+            method = &quot;GET&quot;</span>
<span class="gi">+</span>
<span class="gi">+        # Second, if a POST is responded to with a 301, turn it into a GET.</span>
<span class="gi">+        # This bizarre behaviour is explained in Issue 1704.</span>
<span class="gi">+        if response.status_code == codes.moved and method == &quot;POST&quot;:</span>
<span class="gi">+            method = &quot;GET&quot;</span>
<span class="gi">+</span>
<span class="gi">+        prepared_request.method = method</span>


<span class="w"> </span>class Session(SessionRedirectMixin):
<span class="gu">@@ -106,24 +371,82 @@ class Session(SessionRedirectMixin):</span>
<span class="w"> </span>      ...     s.get(&#39;https://httpbin.org/get&#39;)
<span class="w"> </span>      &lt;Response [200]&gt;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    __attrs__ = [&#39;headers&#39;, &#39;cookies&#39;, &#39;auth&#39;, &#39;proxies&#39;, &#39;hooks&#39;, &#39;params&#39;,</span>
<span class="gd">-        &#39;verify&#39;, &#39;cert&#39;, &#39;adapters&#39;, &#39;stream&#39;, &#39;trust_env&#39;, &#39;max_redirects&#39;]</span>
<span class="gi">+</span>
<span class="gi">+    __attrs__ = [</span>
<span class="gi">+        &quot;headers&quot;,</span>
<span class="gi">+        &quot;cookies&quot;,</span>
<span class="gi">+        &quot;auth&quot;,</span>
<span class="gi">+        &quot;proxies&quot;,</span>
<span class="gi">+        &quot;hooks&quot;,</span>
<span class="gi">+        &quot;params&quot;,</span>
<span class="gi">+        &quot;verify&quot;,</span>
<span class="gi">+        &quot;cert&quot;,</span>
<span class="gi">+        &quot;adapters&quot;,</span>
<span class="gi">+        &quot;stream&quot;,</span>
<span class="gi">+        &quot;trust_env&quot;,</span>
<span class="gi">+        &quot;max_redirects&quot;,</span>
<span class="gi">+    ]</span>

<span class="w"> </span>    def __init__(self):
<span class="gi">+        #: A case-insensitive dictionary of headers to be sent on each</span>
<span class="gi">+        #: :class:`Request &lt;Request&gt;` sent from this</span>
<span class="gi">+        #: :class:`Session &lt;Session&gt;`.</span>
<span class="w"> </span>        self.headers = default_headers()
<span class="gi">+</span>
<span class="gi">+        #: Default Authentication tuple or object to attach to</span>
<span class="gi">+        #: :class:`Request &lt;Request&gt;`.</span>
<span class="w"> </span>        self.auth = None
<span class="gi">+</span>
<span class="gi">+        #: Dictionary mapping protocol or protocol and host to the URL of the proxy</span>
<span class="gi">+        #: (e.g. {&#39;http&#39;: &#39;foo.bar:3128&#39;, &#39;http://host.name&#39;: &#39;foo.bar:4012&#39;}) to</span>
<span class="gi">+        #: be used on each :class:`Request &lt;Request&gt;`.</span>
<span class="w"> </span>        self.proxies = {}
<span class="gi">+</span>
<span class="gi">+        #: Event-handling hooks.</span>
<span class="w"> </span>        self.hooks = default_hooks()
<span class="gi">+</span>
<span class="gi">+        #: Dictionary of querystring data to attach to each</span>
<span class="gi">+        #: :class:`Request &lt;Request&gt;`. The dictionary values may be lists for</span>
<span class="gi">+        #: representing multivalued query parameters.</span>
<span class="w"> </span>        self.params = {}
<span class="gi">+</span>
<span class="gi">+        #: Stream response content default.</span>
<span class="w"> </span>        self.stream = False
<span class="gi">+</span>
<span class="gi">+        #: SSL Verification default.</span>
<span class="gi">+        #: Defaults to `True`, requiring requests to verify the TLS certificate at the</span>
<span class="gi">+        #: remote end.</span>
<span class="gi">+        #: If verify is set to `False`, requests will accept any TLS certificate</span>
<span class="gi">+        #: presented by the server, and will ignore hostname mismatches and/or</span>
<span class="gi">+        #: expired certificates, which will make your application vulnerable to</span>
<span class="gi">+        #: man-in-the-middle (MitM) attacks.</span>
<span class="gi">+        #: Only set this to `False` for testing.</span>
<span class="w"> </span>        self.verify = True
<span class="gi">+</span>
<span class="gi">+        #: SSL client certificate default, if String, path to ssl client</span>
<span class="gi">+        #: cert file (.pem). If Tuple, (&#39;cert&#39;, &#39;key&#39;) pair.</span>
<span class="w"> </span>        self.cert = None
<span class="gi">+</span>
<span class="gi">+        #: Maximum number of redirects allowed. If the request exceeds this</span>
<span class="gi">+        #: limit, a :class:`TooManyRedirects` exception is raised.</span>
<span class="gi">+        #: This defaults to requests.models.DEFAULT_REDIRECT_LIMIT, which is</span>
<span class="gi">+        #: 30.</span>
<span class="w"> </span>        self.max_redirects = DEFAULT_REDIRECT_LIMIT
<span class="gi">+</span>
<span class="gi">+        #: Trust environment settings for proxy configuration, default</span>
<span class="gi">+        #: authentication and similar.</span>
<span class="w"> </span>        self.trust_env = True
<span class="gi">+</span>
<span class="gi">+        #: A CookieJar containing all currently outstanding cookies set on this</span>
<span class="gi">+        #: session. By default it is a</span>
<span class="gi">+        #: :class:`RequestsCookieJar &lt;requests.cookies.RequestsCookieJar&gt;`, but</span>
<span class="gi">+        #: may be any other ``cookielib.CookieJar`` compatible object.</span>
<span class="w"> </span>        self.cookies = cookiejar_from_dict({})
<span class="gi">+</span>
<span class="gi">+        # Default connection adapters.</span>
<span class="w"> </span>        self.adapters = OrderedDict()
<span class="gd">-        self.mount(&#39;https://&#39;, HTTPAdapter())</span>
<span class="gd">-        self.mount(&#39;http://&#39;, HTTPAdapter())</span>
<span class="gi">+        self.mount(&quot;https://&quot;, HTTPAdapter())</span>
<span class="gi">+        self.mount(&quot;http://&quot;, HTTPAdapter())</span>

<span class="w"> </span>    def __enter__(self):
<span class="w"> </span>        return self
<span class="gu">@@ -141,12 +464,58 @@ class Session(SessionRedirectMixin):</span>
<span class="w"> </span>            session&#39;s settings.
<span class="w"> </span>        :rtype: requests.PreparedRequest
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gd">-</span>
<span class="gd">-    def request(self, method, url, params=None, data=None, headers=None,</span>
<span class="gd">-        cookies=None, files=None, auth=None, timeout=None, allow_redirects=</span>
<span class="gd">-        True, proxies=None, hooks=None, stream=None, verify=None, cert=None,</span>
<span class="gd">-        json=None):</span>
<span class="gi">+        cookies = request.cookies or {}</span>
<span class="gi">+</span>
<span class="gi">+        # Bootstrap CookieJar.</span>
<span class="gi">+        if not isinstance(cookies, cookielib.CookieJar):</span>
<span class="gi">+            cookies = cookiejar_from_dict(cookies)</span>
<span class="gi">+</span>
<span class="gi">+        # Merge with session cookies</span>
<span class="gi">+        merged_cookies = merge_cookies(</span>
<span class="gi">+            merge_cookies(RequestsCookieJar(), self.cookies), cookies</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Set environment&#39;s basic authentication if not explicitly set.</span>
<span class="gi">+        auth = request.auth</span>
<span class="gi">+        if self.trust_env and not auth and not self.auth:</span>
<span class="gi">+            auth = get_netrc_auth(request.url)</span>
<span class="gi">+</span>
<span class="gi">+        p = PreparedRequest()</span>
<span class="gi">+        p.prepare(</span>
<span class="gi">+            method=request.method.upper(),</span>
<span class="gi">+            url=request.url,</span>
<span class="gi">+            files=request.files,</span>
<span class="gi">+            data=request.data,</span>
<span class="gi">+            json=request.json,</span>
<span class="gi">+            headers=merge_setting(</span>
<span class="gi">+                request.headers, self.headers, dict_class=CaseInsensitiveDict</span>
<span class="gi">+            ),</span>
<span class="gi">+            params=merge_setting(request.params, self.params),</span>
<span class="gi">+            auth=merge_setting(auth, self.auth),</span>
<span class="gi">+            cookies=merged_cookies,</span>
<span class="gi">+            hooks=merge_hooks(request.hooks, self.hooks),</span>
<span class="gi">+        )</span>
<span class="gi">+        return p</span>
<span class="gi">+</span>
<span class="gi">+    def request(</span>
<span class="gi">+        self,</span>
<span class="gi">+        method,</span>
<span class="gi">+        url,</span>
<span class="gi">+        params=None,</span>
<span class="gi">+        data=None,</span>
<span class="gi">+        headers=None,</span>
<span class="gi">+        cookies=None,</span>
<span class="gi">+        files=None,</span>
<span class="gi">+        auth=None,</span>
<span class="gi">+        timeout=None,</span>
<span class="gi">+        allow_redirects=True,</span>
<span class="gi">+        proxies=None,</span>
<span class="gi">+        hooks=None,</span>
<span class="gi">+        stream=None,</span>
<span class="gi">+        verify=None,</span>
<span class="gi">+        cert=None,</span>
<span class="gi">+        json=None,</span>
<span class="gi">+    ):</span>
<span class="w"> </span>        &quot;&quot;&quot;Constructs a :class:`Request &lt;Request&gt;`, prepares it and sends it.
<span class="w"> </span>        Returns :class:`Response &lt;Response&gt;` object.

<span class="gu">@@ -190,84 +559,193 @@ class Session(SessionRedirectMixin):</span>
<span class="w"> </span>            If Tuple, (&#39;cert&#39;, &#39;key&#39;) pair.
<span class="w"> </span>        :rtype: requests.Response
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Create the Request.</span>
<span class="gi">+        req = Request(</span>
<span class="gi">+            method=method.upper(),</span>
<span class="gi">+            url=url,</span>
<span class="gi">+            headers=headers,</span>
<span class="gi">+            files=files,</span>
<span class="gi">+            data=data or {},</span>
<span class="gi">+            json=json,</span>
<span class="gi">+            params=params or {},</span>
<span class="gi">+            auth=auth,</span>
<span class="gi">+            cookies=cookies,</span>
<span class="gi">+            hooks=hooks,</span>
<span class="gi">+        )</span>
<span class="gi">+        prep = self.prepare_request(req)</span>
<span class="gi">+</span>
<span class="gi">+        proxies = proxies or {}</span>
<span class="gi">+</span>
<span class="gi">+        settings = self.merge_environment_settings(</span>
<span class="gi">+            prep.url, proxies, stream, verify, cert</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+        # Send the request.</span>
<span class="gi">+        send_kwargs = {</span>
<span class="gi">+            &quot;timeout&quot;: timeout,</span>
<span class="gi">+            &quot;allow_redirects&quot;: allow_redirects,</span>
<span class="gi">+        }</span>
<span class="gi">+        send_kwargs.update(settings)</span>
<span class="gi">+        resp = self.send(prep, **send_kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        return resp</span>

<span class="w"> </span>    def get(self, url, **kwargs):
<span class="gd">-        &quot;&quot;&quot;Sends a GET request. Returns :class:`Response` object.</span>
<span class="gi">+        r&quot;&quot;&quot;Sends a GET request. Returns :class:`Response` object.</span>

<span class="w"> </span>        :param url: URL for the new :class:`Request` object.
<span class="gd">-        :param \\*\\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="gi">+        :param \*\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="w"> </span>        :rtype: requests.Response
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        kwargs.setdefault(&quot;allow_redirects&quot;, True)</span>
<span class="gi">+        return self.request(&quot;GET&quot;, url, **kwargs)</span>

<span class="w"> </span>    def options(self, url, **kwargs):
<span class="gd">-        &quot;&quot;&quot;Sends a OPTIONS request. Returns :class:`Response` object.</span>
<span class="gi">+        r&quot;&quot;&quot;Sends a OPTIONS request. Returns :class:`Response` object.</span>

<span class="w"> </span>        :param url: URL for the new :class:`Request` object.
<span class="gd">-        :param \\*\\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="gi">+        :param \*\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="w"> </span>        :rtype: requests.Response
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        kwargs.setdefault(&quot;allow_redirects&quot;, True)</span>
<span class="gi">+        return self.request(&quot;OPTIONS&quot;, url, **kwargs)</span>

<span class="w"> </span>    def head(self, url, **kwargs):
<span class="gd">-        &quot;&quot;&quot;Sends a HEAD request. Returns :class:`Response` object.</span>
<span class="gi">+        r&quot;&quot;&quot;Sends a HEAD request. Returns :class:`Response` object.</span>

<span class="w"> </span>        :param url: URL for the new :class:`Request` object.
<span class="gd">-        :param \\*\\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="gi">+        :param \*\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="w"> </span>        :rtype: requests.Response
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        kwargs.setdefault(&quot;allow_redirects&quot;, False)</span>
<span class="gi">+        return self.request(&quot;HEAD&quot;, url, **kwargs)</span>

<span class="w"> </span>    def post(self, url, data=None, json=None, **kwargs):
<span class="gd">-        &quot;&quot;&quot;Sends a POST request. Returns :class:`Response` object.</span>
<span class="gi">+        r&quot;&quot;&quot;Sends a POST request. Returns :class:`Response` object.</span>

<span class="w"> </span>        :param url: URL for the new :class:`Request` object.
<span class="w"> </span>        :param data: (optional) Dictionary, list of tuples, bytes, or file-like
<span class="w"> </span>            object to send in the body of the :class:`Request`.
<span class="w"> </span>        :param json: (optional) json to send in the body of the :class:`Request`.
<span class="gd">-        :param \\*\\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="gi">+        :param \*\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="w"> </span>        :rtype: requests.Response
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        return self.request(&quot;POST&quot;, url, data=data, json=json, **kwargs)</span>

<span class="w"> </span>    def put(self, url, data=None, **kwargs):
<span class="gd">-        &quot;&quot;&quot;Sends a PUT request. Returns :class:`Response` object.</span>
<span class="gi">+        r&quot;&quot;&quot;Sends a PUT request. Returns :class:`Response` object.</span>

<span class="w"> </span>        :param url: URL for the new :class:`Request` object.
<span class="w"> </span>        :param data: (optional) Dictionary, list of tuples, bytes, or file-like
<span class="w"> </span>            object to send in the body of the :class:`Request`.
<span class="gd">-        :param \\*\\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="gi">+        :param \*\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="w"> </span>        :rtype: requests.Response
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        return self.request(&quot;PUT&quot;, url, data=data, **kwargs)</span>

<span class="w"> </span>    def patch(self, url, data=None, **kwargs):
<span class="gd">-        &quot;&quot;&quot;Sends a PATCH request. Returns :class:`Response` object.</span>
<span class="gi">+        r&quot;&quot;&quot;Sends a PATCH request. Returns :class:`Response` object.</span>

<span class="w"> </span>        :param url: URL for the new :class:`Request` object.
<span class="w"> </span>        :param data: (optional) Dictionary, list of tuples, bytes, or file-like
<span class="w"> </span>            object to send in the body of the :class:`Request`.
<span class="gd">-        :param \\*\\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="gi">+        :param \*\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="w"> </span>        :rtype: requests.Response
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        return self.request(&quot;PATCH&quot;, url, data=data, **kwargs)</span>

<span class="w"> </span>    def delete(self, url, **kwargs):
<span class="gd">-        &quot;&quot;&quot;Sends a DELETE request. Returns :class:`Response` object.</span>
<span class="gi">+        r&quot;&quot;&quot;Sends a DELETE request. Returns :class:`Response` object.</span>

<span class="w"> </span>        :param url: URL for the new :class:`Request` object.
<span class="gd">-        :param \\*\\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="gi">+        :param \*\*kwargs: Optional arguments that ``request`` takes.</span>
<span class="w"> </span>        :rtype: requests.Response
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+</span>
<span class="gi">+        return self.request(&quot;DELETE&quot;, url, **kwargs)</span>

<span class="w"> </span>    def send(self, request, **kwargs):
<span class="w"> </span>        &quot;&quot;&quot;Send a given PreparedRequest.

<span class="w"> </span>        :rtype: requests.Response
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Set defaults that the hooks can utilize to ensure they always have</span>
<span class="gi">+        # the correct parameters to reproduce the previous request.</span>
<span class="gi">+        kwargs.setdefault(&quot;stream&quot;, self.stream)</span>
<span class="gi">+        kwargs.setdefault(&quot;verify&quot;, self.verify)</span>
<span class="gi">+        kwargs.setdefault(&quot;cert&quot;, self.cert)</span>
<span class="gi">+        if &quot;proxies&quot; not in kwargs:</span>
<span class="gi">+            kwargs[&quot;proxies&quot;] = resolve_proxies(request, self.proxies, self.trust_env)</span>
<span class="gi">+</span>
<span class="gi">+        # It&#39;s possible that users might accidentally send a Request object.</span>
<span class="gi">+        # Guard against that specific failure case.</span>
<span class="gi">+        if isinstance(request, Request):</span>
<span class="gi">+            raise ValueError(&quot;You can only send PreparedRequests.&quot;)</span>
<span class="gi">+</span>
<span class="gi">+        # Set up variables needed for resolve_redirects and dispatching of hooks</span>
<span class="gi">+        allow_redirects = kwargs.pop(&quot;allow_redirects&quot;, True)</span>
<span class="gi">+        stream = kwargs.get(&quot;stream&quot;)</span>
<span class="gi">+        hooks = request.hooks</span>
<span class="gi">+</span>
<span class="gi">+        # Get the appropriate adapter to use</span>
<span class="gi">+        adapter = self.get_adapter(url=request.url)</span>
<span class="gi">+</span>
<span class="gi">+        # Start time (approximately) of the request</span>
<span class="gi">+        start = preferred_clock()</span>
<span class="gi">+</span>
<span class="gi">+        # Send the request</span>
<span class="gi">+        r = adapter.send(request, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        # Total elapsed time of the request (approximately)</span>
<span class="gi">+        elapsed = preferred_clock() - start</span>
<span class="gi">+        r.elapsed = timedelta(seconds=elapsed)</span>
<span class="gi">+</span>
<span class="gi">+        # Response manipulation hooks</span>
<span class="gi">+        r = dispatch_hook(&quot;response&quot;, hooks, r, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+        # Persist cookies</span>
<span class="gi">+        if r.history:</span>
<span class="gi">+            # If the hooks create history then we want those cookies too</span>
<span class="gi">+            for resp in r.history:</span>
<span class="gi">+                extract_cookies_to_jar(self.cookies, resp.request, resp.raw)</span>
<span class="gi">+</span>
<span class="gi">+        extract_cookies_to_jar(self.cookies, request, r.raw)</span>
<span class="gi">+</span>
<span class="gi">+        # Resolve redirects if allowed.</span>
<span class="gi">+        if allow_redirects:</span>
<span class="gi">+            # Redirect resolving generator.</span>
<span class="gi">+            gen = self.resolve_redirects(r, request, **kwargs)</span>
<span class="gi">+            history = [resp for resp in gen]</span>
<span class="gi">+        else:</span>
<span class="gi">+            history = []</span>
<span class="gi">+</span>
<span class="gi">+        # Shuffle things around if there&#39;s history.</span>
<span class="gi">+        if history:</span>
<span class="gi">+            # Insert the first (original) request at the start</span>
<span class="gi">+            history.insert(0, r)</span>
<span class="gi">+            # Get the last request made</span>
<span class="gi">+            r = history.pop()</span>
<span class="gi">+            r.history = history</span>
<span class="gi">+</span>
<span class="gi">+        # If redirects aren&#39;t being followed, store the response on the Request for Response.next().</span>
<span class="gi">+        if not allow_redirects:</span>
<span class="gi">+            try:</span>
<span class="gi">+                r._next = next(</span>
<span class="gi">+                    self.resolve_redirects(r, request, yield_requests=True, **kwargs)</span>
<span class="gi">+                )</span>
<span class="gi">+            except StopIteration:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+        if not stream:</span>
<span class="gi">+            r.content</span>
<span class="gi">+</span>
<span class="gi">+        return r</span>

<span class="w"> </span>    def merge_environment_settings(self, url, proxies, stream, verify, cert):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -275,7 +753,30 @@ class Session(SessionRedirectMixin):</span>

<span class="w"> </span>        :rtype: dict
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        # Gather clues from the surrounding environment.</span>
<span class="gi">+        if self.trust_env:</span>
<span class="gi">+            # Set environment&#39;s proxies.</span>
<span class="gi">+            no_proxy = proxies.get(&quot;no_proxy&quot;) if proxies is not None else None</span>
<span class="gi">+            env_proxies = get_environ_proxies(url, no_proxy=no_proxy)</span>
<span class="gi">+            for k, v in env_proxies.items():</span>
<span class="gi">+                proxies.setdefault(k, v)</span>
<span class="gi">+</span>
<span class="gi">+            # Look for requests environment configuration</span>
<span class="gi">+            # and be compatible with cURL.</span>
<span class="gi">+            if verify is True or verify is None:</span>
<span class="gi">+                verify = (</span>
<span class="gi">+                    os.environ.get(&quot;REQUESTS_CA_BUNDLE&quot;)</span>
<span class="gi">+                    or os.environ.get(&quot;CURL_CA_BUNDLE&quot;)</span>
<span class="gi">+                    or verify</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+        # Merge all the kwargs.</span>
<span class="gi">+        proxies = merge_setting(proxies, self.proxies)</span>
<span class="gi">+        stream = merge_setting(stream, self.stream)</span>
<span class="gi">+        verify = merge_setting(verify, self.verify)</span>
<span class="gi">+        cert = merge_setting(cert, self.cert)</span>
<span class="gi">+</span>
<span class="gi">+        return {&quot;proxies&quot;: proxies, &quot;stream&quot;: stream, &quot;verify&quot;: verify, &quot;cert&quot;: cert}</span>

<span class="w"> </span>    def get_adapter(self, url):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -283,18 +784,28 @@ class Session(SessionRedirectMixin):</span>

<span class="w"> </span>        :rtype: requests.adapters.BaseAdapter
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for prefix, adapter in self.adapters.items():</span>
<span class="gi">+            if url.lower().startswith(prefix.lower()):</span>
<span class="gi">+                return adapter</span>
<span class="gi">+</span>
<span class="gi">+        # Nothing matches :-/</span>
<span class="gi">+        raise InvalidSchema(f&quot;No connection adapters were found for {url!r}&quot;)</span>

<span class="w"> </span>    def close(self):
<span class="w"> </span>        &quot;&quot;&quot;Closes all adapters and as such the session&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        for v in self.adapters.values():</span>
<span class="gi">+            v.close()</span>

<span class="w"> </span>    def mount(self, prefix, adapter):
<span class="w"> </span>        &quot;&quot;&quot;Registers a connection adapter to a prefix.

<span class="w"> </span>        Adapters are sorted in descending order by prefix length.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        self.adapters[prefix] = adapter</span>
<span class="gi">+        keys_to_move = [k for k in self.adapters if len(k) &lt; len(prefix)]</span>
<span class="gi">+</span>
<span class="gi">+        for key in keys_to_move:</span>
<span class="gi">+            self.adapters[key] = self.adapters.pop(key)</span>

<span class="w"> </span>    def __getstate__(self):
<span class="w"> </span>        state = {attr: getattr(self, attr, None) for attr in self.__attrs__}
<span class="gu">@@ -317,4 +828,4 @@ def session():</span>

<span class="w"> </span>    :rtype: Session
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return Session()</span>
<span class="gh">diff --git a/src/requests/status_codes.py b/src/requests/status_codes.py</span>
<span class="gh">index 9ae0edc1..c7945a2f 100644</span>
<span class="gd">--- a/src/requests/status_codes.py</span>
<span class="gi">+++ b/src/requests/status_codes.py</span>
<span class="gu">@@ -1,4 +1,4 @@</span>
<span class="gd">-&quot;&quot;&quot;</span>
<span class="gi">+r&quot;&quot;&quot;</span>
<span class="w"> </span>The ``codes`` object defines a mapping from common names for HTTP statuses
<span class="w"> </span>to their numerical codes, accessible either as attributes or as dictionary
<span class="w"> </span>items.
<span class="gu">@@ -10,58 +10,119 @@ Example::</span>
<span class="w"> </span>    307
<span class="w"> </span>    &gt;&gt;&gt; requests.codes.teapot
<span class="w"> </span>    418
<span class="gd">-    &gt;&gt;&gt; requests.codes[&#39;\\o/&#39;]</span>
<span class="gi">+    &gt;&gt;&gt; requests.codes[&#39;\o/&#39;]</span>
<span class="w"> </span>    200

<span class="w"> </span>Some codes have multiple names, and both upper- and lower-case versions of
<span class="w"> </span>the names are allowed. For example, ``codes.ok``, ``codes.OK``, and
<span class="w"> </span>``codes.okay`` all correspond to the HTTP status code 200.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from .structures import LookupDict
<span class="gd">-_codes = {(100): (&#39;continue&#39;,), (101): (&#39;switching_protocols&#39;,), (102): (</span>
<span class="gd">-    &#39;processing&#39;, &#39;early-hints&#39;), (103): (&#39;checkpoint&#39;,), (122): (</span>
<span class="gd">-    &#39;uri_too_long&#39;, &#39;request_uri_too_long&#39;), (200): (&#39;ok&#39;, &#39;okay&#39;, &#39;all_ok&#39;,</span>
<span class="gd">-    &#39;all_okay&#39;, &#39;all_good&#39;, &#39;\\o/&#39;, &#39;‚úì&#39;), (201): (&#39;created&#39;,), (202): (</span>
<span class="gd">-    &#39;accepted&#39;,), (203): (&#39;non_authoritative_info&#39;,</span>
<span class="gd">-    &#39;non_authoritative_information&#39;), (204): (&#39;no_content&#39;,), (205): (</span>
<span class="gd">-    &#39;reset_content&#39;, &#39;reset&#39;), (206): (&#39;partial_content&#39;, &#39;partial&#39;), (207):</span>
<span class="gd">-    (&#39;multi_status&#39;, &#39;multiple_status&#39;, &#39;multi_stati&#39;, &#39;multiple_stati&#39;), (</span>
<span class="gd">-    208): (&#39;already_reported&#39;,), (226): (&#39;im_used&#39;,), (300): (</span>
<span class="gd">-    &#39;multiple_choices&#39;,), (301): (&#39;moved_permanently&#39;, &#39;moved&#39;, &#39;\\o-&#39;), (</span>
<span class="gd">-    302): (&#39;found&#39;,), (303): (&#39;see_other&#39;, &#39;other&#39;), (304): (&#39;not_modified&#39;</span>
<span class="gd">-    ,), (305): (&#39;use_proxy&#39;,), (306): (&#39;switch_proxy&#39;,), (307): (</span>
<span class="gd">-    &#39;temporary_redirect&#39;, &#39;temporary_moved&#39;, &#39;temporary&#39;), (308): (</span>
<span class="gd">-    &#39;permanent_redirect&#39;, &#39;resume_incomplete&#39;, &#39;resume&#39;), (400): (</span>
<span class="gd">-    &#39;bad_request&#39;, &#39;bad&#39;), (401): (&#39;unauthorized&#39;,), (402): (</span>
<span class="gd">-    &#39;payment_required&#39;, &#39;payment&#39;), (403): (&#39;forbidden&#39;,), (404): (</span>
<span class="gd">-    &#39;not_found&#39;, &#39;-o-&#39;), (405): (&#39;method_not_allowed&#39;, &#39;not_allowed&#39;), (406</span>
<span class="gd">-    ): (&#39;not_acceptable&#39;,), (407): (&#39;proxy_authentication_required&#39;,</span>
<span class="gd">-    &#39;proxy_auth&#39;, &#39;proxy_authentication&#39;), (408): (&#39;request_timeout&#39;,</span>
<span class="gd">-    &#39;timeout&#39;), (409): (&#39;conflict&#39;,), (410): (&#39;gone&#39;,), (411): (</span>
<span class="gd">-    &#39;length_required&#39;,), (412): (&#39;precondition_failed&#39;, &#39;precondition&#39;), (</span>
<span class="gd">-    413): (&#39;request_entity_too_large&#39;, &#39;content_too_large&#39;), (414): (</span>
<span class="gd">-    &#39;request_uri_too_large&#39;, &#39;uri_too_long&#39;), (415): (</span>
<span class="gd">-    &#39;unsupported_media_type&#39;, &#39;unsupported_media&#39;, &#39;media_type&#39;), (416): (</span>
<span class="gd">-    &#39;requested_range_not_satisfiable&#39;, &#39;requested_range&#39;,</span>
<span class="gd">-    &#39;range_not_satisfiable&#39;), (417): (&#39;expectation_failed&#39;,), (418): (</span>
<span class="gd">-    &#39;im_a_teapot&#39;, &#39;teapot&#39;, &#39;i_am_a_teapot&#39;), (421): (</span>
<span class="gd">-    &#39;misdirected_request&#39;,), (422): (&#39;unprocessable_entity&#39;,</span>
<span class="gd">-    &#39;unprocessable&#39;, &#39;unprocessable_content&#39;), (423): (&#39;locked&#39;,), (424): (</span>
<span class="gd">-    &#39;failed_dependency&#39;, &#39;dependency&#39;), (425): (&#39;unordered_collection&#39;,</span>
<span class="gd">-    &#39;unordered&#39;, &#39;too_early&#39;), (426): (&#39;upgrade_required&#39;, &#39;upgrade&#39;), (428</span>
<span class="gd">-    ): (&#39;precondition_required&#39;, &#39;precondition&#39;), (429): (</span>
<span class="gd">-    &#39;too_many_requests&#39;, &#39;too_many&#39;), (431): (&#39;header_fields_too_large&#39;,</span>
<span class="gd">-    &#39;fields_too_large&#39;), (444): (&#39;no_response&#39;, &#39;none&#39;), (449): (</span>
<span class="gd">-    &#39;retry_with&#39;, &#39;retry&#39;), (450): (&#39;blocked_by_windows_parental_controls&#39;,</span>
<span class="gd">-    &#39;parental_controls&#39;), (451): (&#39;unavailable_for_legal_reasons&#39;,</span>
<span class="gd">-    &#39;legal_reasons&#39;), (499): (&#39;client_closed_request&#39;,), (500): (</span>
<span class="gd">-    &#39;internal_server_error&#39;, &#39;server_error&#39;, &#39;/o\\&#39;, &#39;‚úó&#39;), (501): (</span>
<span class="gd">-    &#39;not_implemented&#39;,), (502): (&#39;bad_gateway&#39;,), (503): (</span>
<span class="gd">-    &#39;service_unavailable&#39;, &#39;unavailable&#39;), (504): (&#39;gateway_timeout&#39;,), (</span>
<span class="gd">-    505): (&#39;http_version_not_supported&#39;, &#39;http_version&#39;), (506): (</span>
<span class="gd">-    &#39;variant_also_negotiates&#39;,), (507): (&#39;insufficient_storage&#39;,), (509): (</span>
<span class="gd">-    &#39;bandwidth_limit_exceeded&#39;, &#39;bandwidth&#39;), (510): (&#39;not_extended&#39;,), (</span>
<span class="gd">-    511): (&#39;network_authentication_required&#39;, &#39;network_auth&#39;,</span>
<span class="gd">-    &#39;network_authentication&#39;)}</span>
<span class="gd">-codes = LookupDict(name=&#39;status_codes&#39;)</span>
<span class="gi">+</span>
<span class="gi">+_codes = {</span>
<span class="gi">+    # Informational.</span>
<span class="gi">+    100: (&quot;continue&quot;,),</span>
<span class="gi">+    101: (&quot;switching_protocols&quot;,),</span>
<span class="gi">+    102: (&quot;processing&quot;, &quot;early-hints&quot;),</span>
<span class="gi">+    103: (&quot;checkpoint&quot;,),</span>
<span class="gi">+    122: (&quot;uri_too_long&quot;, &quot;request_uri_too_long&quot;),</span>
<span class="gi">+    200: (&quot;ok&quot;, &quot;okay&quot;, &quot;all_ok&quot;, &quot;all_okay&quot;, &quot;all_good&quot;, &quot;\\o/&quot;, &quot;‚úì&quot;),</span>
<span class="gi">+    201: (&quot;created&quot;,),</span>
<span class="gi">+    202: (&quot;accepted&quot;,),</span>
<span class="gi">+    203: (&quot;non_authoritative_info&quot;, &quot;non_authoritative_information&quot;),</span>
<span class="gi">+    204: (&quot;no_content&quot;,),</span>
<span class="gi">+    205: (&quot;reset_content&quot;, &quot;reset&quot;),</span>
<span class="gi">+    206: (&quot;partial_content&quot;, &quot;partial&quot;),</span>
<span class="gi">+    207: (&quot;multi_status&quot;, &quot;multiple_status&quot;, &quot;multi_stati&quot;, &quot;multiple_stati&quot;),</span>
<span class="gi">+    208: (&quot;already_reported&quot;,),</span>
<span class="gi">+    226: (&quot;im_used&quot;,),</span>
<span class="gi">+    # Redirection.</span>
<span class="gi">+    300: (&quot;multiple_choices&quot;,),</span>
<span class="gi">+    301: (&quot;moved_permanently&quot;, &quot;moved&quot;, &quot;\\o-&quot;),</span>
<span class="gi">+    302: (&quot;found&quot;,),</span>
<span class="gi">+    303: (&quot;see_other&quot;, &quot;other&quot;),</span>
<span class="gi">+    304: (&quot;not_modified&quot;,),</span>
<span class="gi">+    305: (&quot;use_proxy&quot;,),</span>
<span class="gi">+    306: (&quot;switch_proxy&quot;,),</span>
<span class="gi">+    307: (&quot;temporary_redirect&quot;, &quot;temporary_moved&quot;, &quot;temporary&quot;),</span>
<span class="gi">+    308: (</span>
<span class="gi">+        &quot;permanent_redirect&quot;,</span>
<span class="gi">+        &quot;resume_incomplete&quot;,</span>
<span class="gi">+        &quot;resume&quot;,</span>
<span class="gi">+    ),  # &quot;resume&quot; and &quot;resume_incomplete&quot; to be removed in 3.0</span>
<span class="gi">+    # Client Error.</span>
<span class="gi">+    400: (&quot;bad_request&quot;, &quot;bad&quot;),</span>
<span class="gi">+    401: (&quot;unauthorized&quot;,),</span>
<span class="gi">+    402: (&quot;payment_required&quot;, &quot;payment&quot;),</span>
<span class="gi">+    403: (&quot;forbidden&quot;,),</span>
<span class="gi">+    404: (&quot;not_found&quot;, &quot;-o-&quot;),</span>
<span class="gi">+    405: (&quot;method_not_allowed&quot;, &quot;not_allowed&quot;),</span>
<span class="gi">+    406: (&quot;not_acceptable&quot;,),</span>
<span class="gi">+    407: (&quot;proxy_authentication_required&quot;, &quot;proxy_auth&quot;, &quot;proxy_authentication&quot;),</span>
<span class="gi">+    408: (&quot;request_timeout&quot;, &quot;timeout&quot;),</span>
<span class="gi">+    409: (&quot;conflict&quot;,),</span>
<span class="gi">+    410: (&quot;gone&quot;,),</span>
<span class="gi">+    411: (&quot;length_required&quot;,),</span>
<span class="gi">+    412: (&quot;precondition_failed&quot;, &quot;precondition&quot;),</span>
<span class="gi">+    413: (&quot;request_entity_too_large&quot;, &quot;content_too_large&quot;),</span>
<span class="gi">+    414: (&quot;request_uri_too_large&quot;, &quot;uri_too_long&quot;),</span>
<span class="gi">+    415: (&quot;unsupported_media_type&quot;, &quot;unsupported_media&quot;, &quot;media_type&quot;),</span>
<span class="gi">+    416: (</span>
<span class="gi">+        &quot;requested_range_not_satisfiable&quot;,</span>
<span class="gi">+        &quot;requested_range&quot;,</span>
<span class="gi">+        &quot;range_not_satisfiable&quot;,</span>
<span class="gi">+    ),</span>
<span class="gi">+    417: (&quot;expectation_failed&quot;,),</span>
<span class="gi">+    418: (&quot;im_a_teapot&quot;, &quot;teapot&quot;, &quot;i_am_a_teapot&quot;),</span>
<span class="gi">+    421: (&quot;misdirected_request&quot;,),</span>
<span class="gi">+    422: (&quot;unprocessable_entity&quot;, &quot;unprocessable&quot;, &quot;unprocessable_content&quot;),</span>
<span class="gi">+    423: (&quot;locked&quot;,),</span>
<span class="gi">+    424: (&quot;failed_dependency&quot;, &quot;dependency&quot;),</span>
<span class="gi">+    425: (&quot;unordered_collection&quot;, &quot;unordered&quot;, &quot;too_early&quot;),</span>
<span class="gi">+    426: (&quot;upgrade_required&quot;, &quot;upgrade&quot;),</span>
<span class="gi">+    428: (&quot;precondition_required&quot;, &quot;precondition&quot;),</span>
<span class="gi">+    429: (&quot;too_many_requests&quot;, &quot;too_many&quot;),</span>
<span class="gi">+    431: (&quot;header_fields_too_large&quot;, &quot;fields_too_large&quot;),</span>
<span class="gi">+    444: (&quot;no_response&quot;, &quot;none&quot;),</span>
<span class="gi">+    449: (&quot;retry_with&quot;, &quot;retry&quot;),</span>
<span class="gi">+    450: (&quot;blocked_by_windows_parental_controls&quot;, &quot;parental_controls&quot;),</span>
<span class="gi">+    451: (&quot;unavailable_for_legal_reasons&quot;, &quot;legal_reasons&quot;),</span>
<span class="gi">+    499: (&quot;client_closed_request&quot;,),</span>
<span class="gi">+    # Server Error.</span>
<span class="gi">+    500: (&quot;internal_server_error&quot;, &quot;server_error&quot;, &quot;/o\\&quot;, &quot;‚úó&quot;),</span>
<span class="gi">+    501: (&quot;not_implemented&quot;,),</span>
<span class="gi">+    502: (&quot;bad_gateway&quot;,),</span>
<span class="gi">+    503: (&quot;service_unavailable&quot;, &quot;unavailable&quot;),</span>
<span class="gi">+    504: (&quot;gateway_timeout&quot;,),</span>
<span class="gi">+    505: (&quot;http_version_not_supported&quot;, &quot;http_version&quot;),</span>
<span class="gi">+    506: (&quot;variant_also_negotiates&quot;,),</span>
<span class="gi">+    507: (&quot;insufficient_storage&quot;,),</span>
<span class="gi">+    509: (&quot;bandwidth_limit_exceeded&quot;, &quot;bandwidth&quot;),</span>
<span class="gi">+    510: (&quot;not_extended&quot;,),</span>
<span class="gi">+    511: (&quot;network_authentication_required&quot;, &quot;network_auth&quot;, &quot;network_authentication&quot;),</span>
<span class="gi">+}</span>
<span class="gi">+</span>
<span class="gi">+codes = LookupDict(name=&quot;status_codes&quot;)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _init():</span>
<span class="gi">+    for code, titles in _codes.items():</span>
<span class="gi">+        for title in titles:</span>
<span class="gi">+            setattr(codes, title, code)</span>
<span class="gi">+            if not title.startswith((&quot;\\&quot;, &quot;/&quot;)):</span>
<span class="gi">+                setattr(codes, title.upper(), code)</span>
<span class="gi">+</span>
<span class="gi">+    def doc(code):</span>
<span class="gi">+        names = &quot;, &quot;.join(f&quot;``{n}``&quot; for n in _codes[code])</span>
<span class="gi">+        return &quot;* %d: %s&quot; % (code, names)</span>
<span class="gi">+</span>
<span class="gi">+    global __doc__</span>
<span class="gi">+    __doc__ = (</span>
<span class="gi">+        __doc__ + &quot;\n&quot; + &quot;\n&quot;.join(doc(code) for code in sorted(_codes))</span>
<span class="gi">+        if __doc__ is not None</span>
<span class="gi">+        else None</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="w"> </span>_init()
<span class="gh">diff --git a/src/requests/structures.py b/src/requests/structures.py</span>
<span class="gh">index b389ca26..188e13e4 100644</span>
<span class="gd">--- a/src/requests/structures.py</span>
<span class="gi">+++ b/src/requests/structures.py</span>
<span class="gu">@@ -4,7 +4,9 @@ requests.structures</span>

<span class="w"> </span>Data structures that power Requests.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>from collections import OrderedDict
<span class="gi">+</span>
<span class="w"> </span>from .compat import Mapping, MutableMapping


<span class="gu">@@ -42,7 +44,9 @@ class CaseInsensitiveDict(MutableMapping):</span>
<span class="w"> </span>        self.update(data, **kwargs)

<span class="w"> </span>    def __setitem__(self, key, value):
<span class="gd">-        self._store[key.lower()] = key, value</span>
<span class="gi">+        # Use the lowercased key for lookups, but store the actual</span>
<span class="gi">+        # key alongside the value.</span>
<span class="gi">+        self._store[key.lower()] = (key, value)</span>

<span class="w"> </span>    def __getitem__(self, key):
<span class="w"> </span>        return self._store[key.lower()][1]
<span class="gu">@@ -58,15 +62,20 @@ class CaseInsensitiveDict(MutableMapping):</span>

<span class="w"> </span>    def lower_items(self):
<span class="w"> </span>        &quot;&quot;&quot;Like iteritems(), but with all lowercase keys.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return ((lowerkey, keyval[1]) for (lowerkey, keyval) in self._store.items())</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        if isinstance(other, Mapping):
<span class="w"> </span>            other = CaseInsensitiveDict(other)
<span class="w"> </span>        else:
<span class="w"> </span>            return NotImplemented
<span class="gi">+        # Compare insensitively</span>
<span class="w"> </span>        return dict(self.lower_items()) == dict(other.lower_items())

<span class="gi">+    # Copy is required</span>
<span class="gi">+    def copy(self):</span>
<span class="gi">+        return CaseInsensitiveDict(self._store.values())</span>
<span class="gi">+</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return str(dict(self.items()))

<span class="gu">@@ -82,4 +91,9 @@ class LookupDict(dict):</span>
<span class="w"> </span>        return f&quot;&lt;lookup &#39;{self.name}&#39;&gt;&quot;

<span class="w"> </span>    def __getitem__(self, key):
<span class="gi">+        # We allow fall-through here, so values default to None</span>
<span class="gi">+</span>
<span class="w"> </span>        return self.__dict__.get(key, None)
<span class="gi">+</span>
<span class="gi">+    def get(self, key, default=None):</span>
<span class="gi">+        return self.__dict__.get(key, default)</span>
<span class="gh">diff --git a/src/requests/utils.py b/src/requests/utils.py</span>
<span class="gh">index 504e22fc..ae6c42f6 100644</span>
<span class="gd">--- a/src/requests/utils.py</span>
<span class="gi">+++ b/src/requests/utils.py</span>
<span class="gu">@@ -5,6 +5,7 @@ requests.utils</span>
<span class="w"> </span>This module provides utility functions that are used within Requests
<span class="w"> </span>that are also useful for external consumption.
<span class="w"> </span>&quot;&quot;&quot;
<span class="gi">+</span>
<span class="w"> </span>import codecs
<span class="w"> </span>import contextlib
<span class="w"> </span>import io
<span class="gu">@@ -17,45 +18,251 @@ import tempfile</span>
<span class="w"> </span>import warnings
<span class="w"> </span>import zipfile
<span class="w"> </span>from collections import OrderedDict
<span class="gi">+</span>
<span class="w"> </span>from urllib3.util import make_headers, parse_url
<span class="gi">+</span>
<span class="w"> </span>from . import certs
<span class="w"> </span>from .__version__ import __version__
<span class="gd">-from ._internal_utils import _HEADER_VALIDATORS_BYTE, _HEADER_VALIDATORS_STR, HEADER_VALIDATORS, to_native_string</span>
<span class="gd">-from .compat import Mapping, basestring, bytes, getproxies, getproxies_environment, integer_types</span>
<span class="gi">+</span>
<span class="gi">+# to_native_string is unused here, but imported here for backwards compatibility</span>
<span class="gi">+from ._internal_utils import (  # noqa: F401</span>
<span class="gi">+    _HEADER_VALIDATORS_BYTE,</span>
<span class="gi">+    _HEADER_VALIDATORS_STR,</span>
<span class="gi">+    HEADER_VALIDATORS,</span>
<span class="gi">+    to_native_string,</span>
<span class="gi">+)</span>
<span class="gi">+from .compat import (</span>
<span class="gi">+    Mapping,</span>
<span class="gi">+    basestring,</span>
<span class="gi">+    bytes,</span>
<span class="gi">+    getproxies,</span>
<span class="gi">+    getproxies_environment,</span>
<span class="gi">+    integer_types,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .compat import parse_http_list as _parse_list_header
<span class="gd">-from .compat import proxy_bypass, proxy_bypass_environment, quote, str, unquote, urlparse, urlunparse</span>
<span class="gi">+from .compat import (</span>
<span class="gi">+    proxy_bypass,</span>
<span class="gi">+    proxy_bypass_environment,</span>
<span class="gi">+    quote,</span>
<span class="gi">+    str,</span>
<span class="gi">+    unquote,</span>
<span class="gi">+    urlparse,</span>
<span class="gi">+    urlunparse,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .cookies import cookiejar_from_dict
<span class="gd">-from .exceptions import FileModeWarning, InvalidHeader, InvalidURL, UnrewindableBodyError</span>
<span class="gi">+from .exceptions import (</span>
<span class="gi">+    FileModeWarning,</span>
<span class="gi">+    InvalidHeader,</span>
<span class="gi">+    InvalidURL,</span>
<span class="gi">+    UnrewindableBodyError,</span>
<span class="gi">+)</span>
<span class="w"> </span>from .structures import CaseInsensitiveDict
<span class="gd">-NETRC_FILES = &#39;.netrc&#39;, &#39;_netrc&#39;</span>
<span class="gi">+</span>
<span class="gi">+NETRC_FILES = (&quot;.netrc&quot;, &quot;_netrc&quot;)</span>
<span class="gi">+</span>
<span class="w"> </span>DEFAULT_CA_BUNDLE_PATH = certs.where()
<span class="gd">-DEFAULT_PORTS = {&#39;http&#39;: 80, &#39;https&#39;: 443}</span>
<span class="gd">-DEFAULT_ACCEPT_ENCODING = &#39;, &#39;.join(re.split(&#39;,\\s*&#39;, make_headers(</span>
<span class="gd">-    accept_encoding=True)[&#39;accept-encoding&#39;]))</span>
<span class="gd">-if sys.platform == &#39;win32&#39;:</span>

<span class="gd">-    def proxy_bypass(host):</span>
<span class="gi">+DEFAULT_PORTS = {&quot;http&quot;: 80, &quot;https&quot;: 443}</span>
<span class="gi">+</span>
<span class="gi">+# Ensure that &#39;, &#39; is used to preserve previous delimiter behavior.</span>
<span class="gi">+DEFAULT_ACCEPT_ENCODING = &quot;, &quot;.join(</span>
<span class="gi">+    re.split(r&quot;,\s*&quot;, make_headers(accept_encoding=True)[&quot;accept-encoding&quot;])</span>
<span class="gi">+)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+if sys.platform == &quot;win32&quot;:</span>
<span class="gi">+    # provide a proxy_bypass version on Windows without DNS lookups</span>
<span class="gi">+</span>
<span class="gi">+    def proxy_bypass_registry(host):</span>
<span class="gi">+        try:</span>
<span class="gi">+            import winreg</span>
<span class="gi">+        except ImportError:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            internetSettings = winreg.OpenKey(</span>
<span class="gi">+                winreg.HKEY_CURRENT_USER,</span>
<span class="gi">+                r&quot;Software\Microsoft\Windows\CurrentVersion\Internet Settings&quot;,</span>
<span class="gi">+            )</span>
<span class="gi">+            # ProxyEnable could be REG_SZ or REG_DWORD, normalizing it</span>
<span class="gi">+            proxyEnable = int(winreg.QueryValueEx(internetSettings, &quot;ProxyEnable&quot;)[0])</span>
<span class="gi">+            # ProxyOverride is almost always a string</span>
<span class="gi">+            proxyOverride = winreg.QueryValueEx(internetSettings, &quot;ProxyOverride&quot;)[0]</span>
<span class="gi">+        except (OSError, ValueError):</span>
<span class="gi">+            return False</span>
<span class="gi">+        if not proxyEnable or not proxyOverride:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        # make a check value list from the registry entry: replace the</span>
<span class="gi">+        # &#39;&lt;local&gt;&#39; string by the localhost entry and the corresponding</span>
<span class="gi">+        # canonical entry.</span>
<span class="gi">+        proxyOverride = proxyOverride.split(&quot;;&quot;)</span>
<span class="gi">+        # filter out empty strings to avoid re.match return true in the following code.</span>
<span class="gi">+        proxyOverride = filter(None, proxyOverride)</span>
<span class="gi">+        # now check if we match one of the registry values.</span>
<span class="gi">+        for test in proxyOverride:</span>
<span class="gi">+            if test == &quot;&lt;local&gt;&quot;:</span>
<span class="gi">+                if &quot;.&quot; not in host:</span>
<span class="gi">+                    return True</span>
<span class="gi">+            test = test.replace(&quot;.&quot;, r&quot;\.&quot;)  # mask dots</span>
<span class="gi">+            test = test.replace(&quot;*&quot;, r&quot;.*&quot;)  # change glob sequence</span>
<span class="gi">+            test = test.replace(&quot;?&quot;, r&quot;.&quot;)  # change glob char</span>
<span class="gi">+            if re.match(test, host, re.I):</span>
<span class="gi">+                return True</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    def proxy_bypass(host):  # noqa</span>
<span class="w"> </span>        &quot;&quot;&quot;Return True, if the host should be bypassed.

<span class="w"> </span>        Checks proxy settings gathered from the environment, if specified,
<span class="w"> </span>        or the registry.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if getproxies_environment():</span>
<span class="gi">+            return proxy_bypass_environment(host)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return proxy_bypass_registry(host)</span>


<span class="w"> </span>def dict_to_sequence(d):
<span class="w"> </span>    &quot;&quot;&quot;Returns an internal sequence dictionary update.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if hasattr(d, &quot;items&quot;):</span>
<span class="gi">+        d = d.items()</span>
<span class="gi">+</span>
<span class="gi">+    return d</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def super_len(o):</span>
<span class="gi">+    total_length = None</span>
<span class="gi">+    current_position = 0</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(o, str):</span>
<span class="gi">+        o = o.encode(&quot;utf-8&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if hasattr(o, &quot;__len__&quot;):</span>
<span class="gi">+        total_length = len(o)</span>
<span class="gi">+</span>
<span class="gi">+    elif hasattr(o, &quot;len&quot;):</span>
<span class="gi">+        total_length = o.len</span>
<span class="gi">+</span>
<span class="gi">+    elif hasattr(o, &quot;fileno&quot;):</span>
<span class="gi">+        try:</span>
<span class="gi">+            fileno = o.fileno()</span>
<span class="gi">+        except (io.UnsupportedOperation, AttributeError):</span>
<span class="gi">+            # AttributeError is a surprising exception, seeing as how we&#39;ve just checked</span>
<span class="gi">+            # that `hasattr(o, &#39;fileno&#39;)`.  It happens for objects obtained via</span>
<span class="gi">+            # `Tarfile.extractfile()`, per issue 5229.</span>
<span class="gi">+            pass</span>
<span class="gi">+        else:</span>
<span class="gi">+            total_length = os.fstat(fileno).st_size</span>
<span class="gi">+</span>
<span class="gi">+            # Having used fstat to determine the file length, we need to</span>
<span class="gi">+            # confirm that this file was opened up in binary mode.</span>
<span class="gi">+            if &quot;b&quot; not in o.mode:</span>
<span class="gi">+                warnings.warn(</span>
<span class="gi">+                    (</span>
<span class="gi">+                        &quot;Requests has determined the content-length for this &quot;</span>
<span class="gi">+                        &quot;request using the binary size of the file: however, the &quot;</span>
<span class="gi">+                        &quot;file has been opened in text mode (i.e. without the &#39;b&#39; &quot;</span>
<span class="gi">+                        &quot;flag in the mode). This may lead to an incorrect &quot;</span>
<span class="gi">+                        &quot;content-length. In Requests 3.0, support will be removed &quot;</span>
<span class="gi">+                        &quot;for files in text mode.&quot;</span>
<span class="gi">+                    ),</span>
<span class="gi">+                    FileModeWarning,</span>
<span class="gi">+                )</span>
<span class="gi">+</span>
<span class="gi">+    if hasattr(o, &quot;tell&quot;):</span>
<span class="gi">+        try:</span>
<span class="gi">+            current_position = o.tell()</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            # This can happen in some weird situations, such as when the file</span>
<span class="gi">+            # is actually a special file descriptor like stdin. In this</span>
<span class="gi">+            # instance, we don&#39;t know what the length is, so set it to zero and</span>
<span class="gi">+            # let requests chunk it instead.</span>
<span class="gi">+            if total_length is not None:</span>
<span class="gi">+                current_position = total_length</span>
<span class="gi">+        else:</span>
<span class="gi">+            if hasattr(o, &quot;seek&quot;) and total_length is None:</span>
<span class="gi">+                # StringIO and BytesIO have seek but no usable fileno</span>
<span class="gi">+                try:</span>
<span class="gi">+                    # seek to end of file</span>
<span class="gi">+                    o.seek(0, 2)</span>
<span class="gi">+                    total_length = o.tell()</span>
<span class="gi">+</span>
<span class="gi">+                    # seek back to current position to support</span>
<span class="gi">+                    # partially read file-like objects</span>
<span class="gi">+                    o.seek(current_position or 0)</span>
<span class="gi">+                except OSError:</span>
<span class="gi">+                    total_length = 0</span>
<span class="gi">+</span>
<span class="gi">+    if total_length is None:</span>
<span class="gi">+        total_length = 0</span>
<span class="gi">+</span>
<span class="gi">+    return max(0, total_length - current_position)</span>


<span class="w"> </span>def get_netrc_auth(url, raise_errors=False):
<span class="w"> </span>    &quot;&quot;&quot;Returns the Requests tuple auth for a given url from netrc.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    netrc_file = os.environ.get(&quot;NETRC&quot;)</span>
<span class="gi">+    if netrc_file is not None:</span>
<span class="gi">+        netrc_locations = (netrc_file,)</span>
<span class="gi">+    else:</span>
<span class="gi">+        netrc_locations = (f&quot;~/{f}&quot; for f in NETRC_FILES)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        from netrc import NetrcParseError, netrc</span>
<span class="gi">+</span>
<span class="gi">+        netrc_path = None</span>
<span class="gi">+</span>
<span class="gi">+        for f in netrc_locations:</span>
<span class="gi">+            try:</span>
<span class="gi">+                loc = os.path.expanduser(f)</span>
<span class="gi">+            except KeyError:</span>
<span class="gi">+                # os.path.expanduser can fail when $HOME is undefined and</span>
<span class="gi">+                # getpwuid fails. See https://bugs.python.org/issue20164 &amp;</span>
<span class="gi">+                # https://github.com/psf/requests/issues/1846</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+            if os.path.exists(loc):</span>
<span class="gi">+                netrc_path = loc</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+        # Abort early if there isn&#39;t one.</span>
<span class="gi">+        if netrc_path is None:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        ri = urlparse(url)</span>
<span class="gi">+</span>
<span class="gi">+        # Strip port numbers from netloc. This weird `if...encode`` dance is</span>
<span class="gi">+        # used for Python 3.2, which doesn&#39;t support unicode literals.</span>
<span class="gi">+        splitstr = b&quot;:&quot;</span>
<span class="gi">+        if isinstance(url, str):</span>
<span class="gi">+            splitstr = splitstr.decode(&quot;ascii&quot;)</span>
<span class="gi">+        host = ri.netloc.split(splitstr)[0]</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            _netrc = netrc(netrc_path).authenticators(host)</span>
<span class="gi">+            if _netrc:</span>
<span class="gi">+                # Return with login / password</span>
<span class="gi">+                login_i = 0 if _netrc[0] else 1</span>
<span class="gi">+                return (_netrc[login_i], _netrc[2])</span>
<span class="gi">+        except (NetrcParseError, OSError):</span>
<span class="gi">+            # If there was a parsing error or a permissions issue reading the file,</span>
<span class="gi">+            # we&#39;ll just skip netrc auth unless explicitly asked to raise errors.</span>
<span class="gi">+            if raise_errors:</span>
<span class="gi">+                raise</span>
<span class="gi">+</span>
<span class="gi">+    # App Engine hackiness.</span>
<span class="gi">+    except (ImportError, AttributeError):</span>
<span class="gi">+        pass</span>


<span class="w"> </span>def guess_filename(obj):
<span class="w"> </span>    &quot;&quot;&quot;Tries to guess the filename of the given object.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    name = getattr(obj, &quot;name&quot;, None)</span>
<span class="gi">+    if name and isinstance(name, basestring) and name[0] != &quot;&lt;&quot; and name[-1] != &quot;&gt;&quot;:</span>
<span class="gi">+        return os.path.basename(name)</span>


<span class="w"> </span>def extract_zipped_paths(path):
<span class="gu">@@ -63,13 +270,49 @@ def extract_zipped_paths(path):</span>
<span class="w"> </span>    archive with the location of an extracted copy of the target, or else
<span class="w"> </span>    just return the provided path unchanged.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if os.path.exists(path):</span>
<span class="gi">+        # this is already a valid path, no need to do anything further</span>
<span class="gi">+        return path</span>
<span class="gi">+</span>
<span class="gi">+    # find the first valid part of the provided path and treat that as a zip archive</span>
<span class="gi">+    # assume the rest of the path is the name of a member in the archive</span>
<span class="gi">+    archive, member = os.path.split(path)</span>
<span class="gi">+    while archive and not os.path.exists(archive):</span>
<span class="gi">+        archive, prefix = os.path.split(archive)</span>
<span class="gi">+        if not prefix:</span>
<span class="gi">+            # If we don&#39;t check for an empty prefix after the split (in other words, archive remains unchanged after the split),</span>
<span class="gi">+            # we _can_ end up in an infinite loop on a rare corner case affecting a small number of users</span>
<span class="gi">+            break</span>
<span class="gi">+        member = &quot;/&quot;.join([prefix, member])</span>
<span class="gi">+</span>
<span class="gi">+    if not zipfile.is_zipfile(archive):</span>
<span class="gi">+        return path</span>
<span class="gi">+</span>
<span class="gi">+    zip_file = zipfile.ZipFile(archive)</span>
<span class="gi">+    if member not in zip_file.namelist():</span>
<span class="gi">+        return path</span>
<span class="gi">+</span>
<span class="gi">+    # we have a valid zip archive and a valid member of that archive</span>
<span class="gi">+    tmp = tempfile.gettempdir()</span>
<span class="gi">+    extracted_path = os.path.join(tmp, member.split(&quot;/&quot;)[-1])</span>
<span class="gi">+    if not os.path.exists(extracted_path):</span>
<span class="gi">+        # use read + write to avoid the creating nested folders, we only want the file, avoids mkdir racing condition</span>
<span class="gi">+        with atomic_open(extracted_path) as file_handler:</span>
<span class="gi">+            file_handler.write(zip_file.read(member))</span>
<span class="gi">+    return extracted_path</span>


<span class="w"> </span>@contextlib.contextmanager
<span class="w"> </span>def atomic_open(filename):
<span class="w"> </span>    &quot;&quot;&quot;Write a file to the disk in an atomic fashion&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    tmp_descriptor, tmp_name = tempfile.mkstemp(dir=os.path.dirname(filename))</span>
<span class="gi">+    try:</span>
<span class="gi">+        with os.fdopen(tmp_descriptor, &quot;wb&quot;) as tmp_handler:</span>
<span class="gi">+            yield tmp_handler</span>
<span class="gi">+        os.replace(tmp_name, filename)</span>
<span class="gi">+    except BaseException:</span>
<span class="gi">+        os.remove(tmp_name)</span>
<span class="gi">+        raise</span>


<span class="w"> </span>def from_key_val_list(value):
<span class="gu">@@ -90,7 +333,13 @@ def from_key_val_list(value):</span>

<span class="w"> </span>    :rtype: OrderedDict
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(value, (str, bytes, bool, int)):</span>
<span class="gi">+        raise ValueError(&quot;cannot encode objects that are not 2-tuples&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return OrderedDict(value)</span>


<span class="w"> </span>def to_key_val_list(value):
<span class="gu">@@ -110,9 +359,19 @@ def to_key_val_list(value):</span>

<span class="w"> </span>    :rtype: list
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(value, (str, bytes, bool, int)):</span>
<span class="gi">+        raise ValueError(&quot;cannot encode objects that are not 2-tuples&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(value, Mapping):</span>
<span class="gi">+        value = value.items()</span>

<span class="gi">+    return list(value)</span>

<span class="gi">+</span>
<span class="gi">+# From mitsuhiko/werkzeug (used with permission).</span>
<span class="w"> </span>def parse_list_header(value):
<span class="w"> </span>    &quot;&quot;&quot;Parse lists as described by RFC 2068 Section 2.

<span class="gu">@@ -136,9 +395,15 @@ def parse_list_header(value):</span>
<span class="w"> </span>    :return: :class:`list`
<span class="w"> </span>    :rtype: list
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = []</span>
<span class="gi">+    for item in _parse_list_header(value):</span>
<span class="gi">+        if item[:1] == item[-1:] == &#39;&quot;&#39;:</span>
<span class="gi">+            item = unquote_header_value(item[1:-1])</span>
<span class="gi">+        result.append(item)</span>
<span class="gi">+    return result</span>


<span class="gi">+# From mitsuhiko/werkzeug (used with permission).</span>
<span class="w"> </span>def parse_dict_header(value):
<span class="w"> </span>    &quot;&quot;&quot;Parse lists of key, value pairs as described by RFC 2068 Section 2 and
<span class="w"> </span>    convert them into a python dict:
<span class="gu">@@ -161,18 +426,42 @@ def parse_dict_header(value):</span>
<span class="w"> </span>    :return: :class:`dict`
<span class="w"> </span>    :rtype: dict
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+    result = {}</span>
<span class="gi">+    for item in _parse_list_header(value):</span>
<span class="gi">+        if &quot;=&quot; not in item:</span>
<span class="gi">+            result[item] = None</span>
<span class="gi">+            continue</span>
<span class="gi">+        name, value = item.split(&quot;=&quot;, 1)</span>
<span class="gi">+        if value[:1] == value[-1:] == &#39;&quot;&#39;:</span>
<span class="gi">+            value = unquote_header_value(value[1:-1])</span>
<span class="gi">+        result[name] = value</span>
<span class="gi">+    return result</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# From mitsuhiko/werkzeug (used with permission).</span>
<span class="w"> </span>def unquote_header_value(value, is_filename=False):
<span class="gd">-    &quot;&quot;&quot;Unquotes a header value.  (Reversal of :func:`quote_header_value`).</span>
<span class="gi">+    r&quot;&quot;&quot;Unquotes a header value.  (Reversal of :func:`quote_header_value`).</span>
<span class="w"> </span>    This does not use the real unquoting but what browsers are actually
<span class="w"> </span>    using for quoting.

<span class="w"> </span>    :param value: the header value to unquote.
<span class="w"> </span>    :rtype: str
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if value and value[0] == value[-1] == &#39;&quot;&#39;:</span>
<span class="gi">+        # this is not the real unquoting, but fixing this so that the</span>
<span class="gi">+        # RFC is met will result in bugs with internet explorer and</span>
<span class="gi">+        # probably some other browsers as well.  IE for example is</span>
<span class="gi">+        # uploading files with &quot;C:\foo\bar.txt&quot; as filename</span>
<span class="gi">+        value = value[1:-1]</span>
<span class="gi">+</span>
<span class="gi">+        # if this is a filename and the starting characters look like</span>
<span class="gi">+        # a UNC path, then just return the value without quotes.  Using the</span>
<span class="gi">+        # replace sequence below on a UNC path has the effect of turning</span>
<span class="gi">+        # the leading double slash into a single slash and then</span>
<span class="gi">+        # _fix_ie_filename() doesn&#39;t work correctly.  See #458.</span>
<span class="gi">+        if not is_filename or value[:2] != &quot;\\\\&quot;:</span>
<span class="gi">+            return value.replace(&quot;\\\\&quot;, &quot;\\&quot;).replace(&#39;\\&quot;&#39;, &#39;&quot;&#39;)</span>
<span class="gi">+    return value</span>


<span class="w"> </span>def dict_from_cookiejar(cj):
<span class="gu">@@ -181,7 +470,9 @@ def dict_from_cookiejar(cj):</span>
<span class="w"> </span>    :param cj: CookieJar object to extract cookies from.
<span class="w"> </span>    :rtype: dict
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    cookie_dict = {cookie.name: cookie.value for cookie in cj}</span>
<span class="gi">+    return cookie_dict</span>


<span class="w"> </span>def add_dict_to_cookiejar(cj, cookie_dict):
<span class="gu">@@ -191,7 +482,8 @@ def add_dict_to_cookiejar(cj, cookie_dict):</span>
<span class="w"> </span>    :param cookie_dict: Dict of key/values to insert into CookieJar.
<span class="w"> </span>    :rtype: CookieJar
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    return cookiejar_from_dict(cookie_dict, cj)</span>


<span class="w"> </span>def get_encodings_from_content(content):
<span class="gu">@@ -199,7 +491,24 @@ def get_encodings_from_content(content):</span>

<span class="w"> </span>    :param content: bytestring to extract encodings from.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;In requests 3.0, get_encodings_from_content will be removed. For &quot;</span>
<span class="gi">+            &quot;more information, please see the discussion on issue #2266. (This&quot;</span>
<span class="gi">+            &quot; warning should only appear once.)&quot;</span>
<span class="gi">+        ),</span>
<span class="gi">+        DeprecationWarning,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    charset_re = re.compile(r&#39;&lt;meta.*?charset=[&quot;\&#39;]*(.+?)[&quot;\&#39;&gt;]&#39;, flags=re.I)</span>
<span class="gi">+    pragma_re = re.compile(r&#39;&lt;meta.*?content=[&quot;\&#39;]*;?charset=(.+?)[&quot;\&#39;&gt;]&#39;, flags=re.I)</span>
<span class="gi">+    xml_re = re.compile(r&#39;^&lt;\?xml.*?encoding=[&quot;\&#39;]*(.+?)[&quot;\&#39;&gt;]&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    return (</span>
<span class="gi">+        charset_re.findall(content)</span>
<span class="gi">+        + pragma_re.findall(content)</span>
<span class="gi">+        + xml_re.findall(content)</span>
<span class="gi">+    )</span>


<span class="w"> </span>def _parse_content_type_header(header):
<span class="gu">@@ -209,7 +518,22 @@ def _parse_content_type_header(header):</span>
<span class="w"> </span>    :return: tuple containing content type and dictionary of
<span class="w"> </span>         parameters
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    tokens = header.split(&quot;;&quot;)</span>
<span class="gi">+    content_type, params = tokens[0].strip(), tokens[1:]</span>
<span class="gi">+    params_dict = {}</span>
<span class="gi">+    items_to_strip = &quot;\&quot;&#39; &quot;</span>
<span class="gi">+</span>
<span class="gi">+    for param in params:</span>
<span class="gi">+        param = param.strip()</span>
<span class="gi">+        if param:</span>
<span class="gi">+            key, value = param, True</span>
<span class="gi">+            index_of_equals = param.find(&quot;=&quot;)</span>
<span class="gi">+            if index_of_equals != -1:</span>
<span class="gi">+                key = param[:index_of_equals].strip(items_to_strip)</span>
<span class="gi">+                value = param[index_of_equals + 1 :].strip(items_to_strip)</span>
<span class="gi">+            params_dict[key.lower()] = value</span>
<span class="gi">+    return content_type, params_dict</span>


<span class="w"> </span>def get_encoding_from_headers(headers):
<span class="gu">@@ -218,17 +542,50 @@ def get_encoding_from_headers(headers):</span>
<span class="w"> </span>    :param headers: dictionary to extract encoding from.
<span class="w"> </span>    :rtype: str
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    content_type = headers.get(&quot;content-type&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if not content_type:</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    content_type, params = _parse_content_type_header(content_type)</span>
<span class="gi">+</span>
<span class="gi">+    if &quot;charset&quot; in params:</span>
<span class="gi">+        return params[&quot;charset&quot;].strip(&quot;&#39;\&quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if &quot;text&quot; in content_type:</span>
<span class="gi">+        return &quot;ISO-8859-1&quot;</span>
<span class="gi">+</span>
<span class="gi">+    if &quot;application/json&quot; in content_type:</span>
<span class="gi">+        # Assume UTF-8 based on RFC 4627: https://www.ietf.org/rfc/rfc4627.txt since the charset was unset</span>
<span class="gi">+        return &quot;utf-8&quot;</span>


<span class="w"> </span>def stream_decode_response_unicode(iterator, r):
<span class="w"> </span>    &quot;&quot;&quot;Stream decodes an iterator.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    if r.encoding is None:</span>
<span class="gi">+        yield from iterator</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    decoder = codecs.getincrementaldecoder(r.encoding)(errors=&quot;replace&quot;)</span>
<span class="gi">+    for chunk in iterator:</span>
<span class="gi">+        rv = decoder.decode(chunk)</span>
<span class="gi">+        if rv:</span>
<span class="gi">+            yield rv</span>
<span class="gi">+    rv = decoder.decode(b&quot;&quot;, final=True)</span>
<span class="gi">+    if rv:</span>
<span class="gi">+        yield rv</span>


<span class="w"> </span>def iter_slices(string, slice_length):
<span class="w"> </span>    &quot;&quot;&quot;Iterate over slices of a string.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    pos = 0</span>
<span class="gi">+    if slice_length is None or slice_length &lt;= 0:</span>
<span class="gi">+        slice_length = len(string)</span>
<span class="gi">+    while pos &lt; len(string):</span>
<span class="gi">+        yield string[pos : pos + slice_length]</span>
<span class="gi">+        pos += slice_length</span>


<span class="w"> </span>def get_unicode_from_response(r):
<span class="gu">@@ -243,11 +600,37 @@ def get_unicode_from_response(r):</span>

<span class="w"> </span>    :rtype: str
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gd">-</span>
<span class="gd">-</span>
<span class="gi">+    warnings.warn(</span>
<span class="gi">+        (</span>
<span class="gi">+            &quot;In requests 3.0, get_unicode_from_response will be removed. For &quot;</span>
<span class="gi">+            &quot;more information, please see the discussion on issue #2266. (This&quot;</span>
<span class="gi">+            &quot; warning should only appear once.)&quot;</span>
<span class="gi">+        ),</span>
<span class="gi">+        DeprecationWarning,</span>
<span class="gi">+    )</span>
<span class="gi">+</span>
<span class="gi">+    tried_encodings = []</span>
<span class="gi">+</span>
<span class="gi">+    # Try charset from content-type</span>
<span class="gi">+    encoding = get_encoding_from_headers(r.headers)</span>
<span class="gi">+</span>
<span class="gi">+    if encoding:</span>
<span class="gi">+        try:</span>
<span class="gi">+            return str(r.content, encoding)</span>
<span class="gi">+        except UnicodeError:</span>
<span class="gi">+            tried_encodings.append(encoding)</span>
<span class="gi">+</span>
<span class="gi">+    # Fall back:</span>
<span class="gi">+    try:</span>
<span class="gi">+        return str(r.content, encoding, errors=&quot;replace&quot;)</span>
<span class="gi">+    except TypeError:</span>
<span class="gi">+        return r.content</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# The unreserved URI characters (RFC 3986)</span>
<span class="w"> </span>UNRESERVED_SET = frozenset(
<span class="gd">-    &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&#39; + &#39;0123456789-._~&#39;)</span>
<span class="gi">+    &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot; + &quot;0123456789-._~&quot;</span>
<span class="gi">+)</span>


<span class="w"> </span>def unquote_unreserved(uri):
<span class="gu">@@ -256,7 +639,22 @@ def unquote_unreserved(uri):</span>

<span class="w"> </span>    :rtype: str
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parts = uri.split(&quot;%&quot;)</span>
<span class="gi">+    for i in range(1, len(parts)):</span>
<span class="gi">+        h = parts[i][0:2]</span>
<span class="gi">+        if len(h) == 2 and h.isalnum():</span>
<span class="gi">+            try:</span>
<span class="gi">+                c = chr(int(h, 16))</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                raise InvalidURL(f&quot;Invalid percent-escape sequence: &#39;{h}&#39;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+            if c in UNRESERVED_SET:</span>
<span class="gi">+                parts[i] = c + parts[i][2:]</span>
<span class="gi">+            else:</span>
<span class="gi">+                parts[i] = f&quot;%{parts[i]}&quot;</span>
<span class="gi">+        else:</span>
<span class="gi">+            parts[i] = f&quot;%{parts[i]}&quot;</span>
<span class="gi">+    return &quot;&quot;.join(parts)</span>


<span class="w"> </span>def requote_uri(uri):
<span class="gu">@@ -267,7 +665,18 @@ def requote_uri(uri):</span>

<span class="w"> </span>    :rtype: str
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    safe_with_percent = &quot;!#$%&amp;&#39;()*+,/:;=?@[]~&quot;</span>
<span class="gi">+    safe_without_percent = &quot;!#$&amp;&#39;()*+,/:;=?@[]~&quot;</span>
<span class="gi">+    try:</span>
<span class="gi">+        # Unquote only the unreserved characters</span>
<span class="gi">+        # Then quote only illegal characters (do not quote reserved,</span>
<span class="gi">+        # unreserved, or &#39;%&#39;)</span>
<span class="gi">+        return quote(unquote_unreserved(uri), safe=safe_with_percent)</span>
<span class="gi">+    except InvalidURL:</span>
<span class="gi">+        # We couldn&#39;t unquote the given URI, so let&#39;s try quoting it, but</span>
<span class="gi">+        # there may be unquoted &#39;%&#39;s in the URI. We need to make sure they&#39;re</span>
<span class="gi">+        # properly quoted so they do not cause issues elsewhere.</span>
<span class="gi">+        return quote(uri, safe=safe_without_percent)</span>


<span class="w"> </span>def address_in_network(ip, net):
<span class="gu">@@ -278,7 +687,11 @@ def address_in_network(ip, net):</span>

<span class="w"> </span>    :rtype: bool
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    ipaddr = struct.unpack(&quot;=L&quot;, socket.inet_aton(ip))[0]</span>
<span class="gi">+    netaddr, bits = net.split(&quot;/&quot;)</span>
<span class="gi">+    netmask = struct.unpack(&quot;=L&quot;, socket.inet_aton(dotted_netmask(int(bits))))[0]</span>
<span class="gi">+    network = struct.unpack(&quot;=L&quot;, socket.inet_aton(netaddr))[0] &amp; netmask</span>
<span class="gi">+    return (ipaddr &amp; netmask) == (network &amp; netmask)</span>


<span class="w"> </span>def dotted_netmask(mask):
<span class="gu">@@ -288,14 +701,19 @@ def dotted_netmask(mask):</span>

<span class="w"> </span>    :rtype: str
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    bits = 0xFFFFFFFF ^ (1 &lt;&lt; 32 - mask) - 1</span>
<span class="gi">+    return socket.inet_ntoa(struct.pack(&quot;&gt;I&quot;, bits))</span>


<span class="w"> </span>def is_ipv4_address(string_ip):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    :rtype: bool
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        socket.inet_aton(string_ip)</span>
<span class="gi">+    except OSError:</span>
<span class="gi">+        return False</span>
<span class="gi">+    return True</span>


<span class="w"> </span>def is_valid_cidr(string_network):
<span class="gu">@@ -304,7 +722,22 @@ def is_valid_cidr(string_network):</span>

<span class="w"> </span>    :rtype: bool
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if string_network.count(&quot;/&quot;) == 1:</span>
<span class="gi">+        try:</span>
<span class="gi">+            mask = int(string_network.split(&quot;/&quot;)[1])</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        if mask &lt; 1 or mask &gt; 32:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            socket.inet_aton(string_network.split(&quot;/&quot;)[0])</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            return False</span>
<span class="gi">+    else:</span>
<span class="gi">+        return False</span>
<span class="gi">+    return True</span>


<span class="w"> </span>@contextlib.contextmanager
<span class="gu">@@ -315,7 +748,18 @@ def set_environ(env_name, value):</span>
<span class="w"> </span>    the environment variable &#39;env_name&#39;.

<span class="w"> </span>    If &#39;value&#39; is None, do nothing&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    value_changed = value is not None</span>
<span class="gi">+    if value_changed:</span>
<span class="gi">+        old_value = os.environ.get(env_name)</span>
<span class="gi">+        os.environ[env_name] = value</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    finally:</span>
<span class="gi">+        if value_changed:</span>
<span class="gi">+            if old_value is None:</span>
<span class="gi">+                del os.environ[env_name]</span>
<span class="gi">+            else:</span>
<span class="gi">+                os.environ[env_name] = old_value</span>


<span class="w"> </span>def should_bypass_proxies(url, no_proxy):
<span class="gu">@@ -324,7 +768,59 @@ def should_bypass_proxies(url, no_proxy):</span>

<span class="w"> </span>    :rtype: bool
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+</span>
<span class="gi">+    # Prioritize lowercase environment variables over uppercase</span>
<span class="gi">+    # to keep a consistent behaviour with other http projects (curl, wget).</span>
<span class="gi">+    def get_proxy(key):</span>
<span class="gi">+        return os.environ.get(key) or os.environ.get(key.upper())</span>
<span class="gi">+</span>
<span class="gi">+    # First check whether no_proxy is defined. If it is, check that the URL</span>
<span class="gi">+    # we&#39;re getting isn&#39;t in the no_proxy list.</span>
<span class="gi">+    no_proxy_arg = no_proxy</span>
<span class="gi">+    if no_proxy is None:</span>
<span class="gi">+        no_proxy = get_proxy(&quot;no_proxy&quot;)</span>
<span class="gi">+    parsed = urlparse(url)</span>
<span class="gi">+</span>
<span class="gi">+    if parsed.hostname is None:</span>
<span class="gi">+        # URLs don&#39;t always have hostnames, e.g. file:/// urls.</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    if no_proxy:</span>
<span class="gi">+        # We need to check whether we match here. We need to see if we match</span>
<span class="gi">+        # the end of the hostname, both with and without the port.</span>
<span class="gi">+        no_proxy = (host for host in no_proxy.replace(&quot; &quot;, &quot;&quot;).split(&quot;,&quot;) if host)</span>
<span class="gi">+</span>
<span class="gi">+        if is_ipv4_address(parsed.hostname):</span>
<span class="gi">+            for proxy_ip in no_proxy:</span>
<span class="gi">+                if is_valid_cidr(proxy_ip):</span>
<span class="gi">+                    if address_in_network(parsed.hostname, proxy_ip):</span>
<span class="gi">+                        return True</span>
<span class="gi">+                elif parsed.hostname == proxy_ip:</span>
<span class="gi">+                    # If no_proxy ip was defined in plain IP notation instead of cidr notation &amp;</span>
<span class="gi">+                    # matches the IP of the index</span>
<span class="gi">+                    return True</span>
<span class="gi">+        else:</span>
<span class="gi">+            host_with_port = parsed.hostname</span>
<span class="gi">+            if parsed.port:</span>
<span class="gi">+                host_with_port += f&quot;:{parsed.port}&quot;</span>
<span class="gi">+</span>
<span class="gi">+            for host in no_proxy:</span>
<span class="gi">+                if parsed.hostname.endswith(host) or host_with_port.endswith(host):</span>
<span class="gi">+                    # The URL does match something in no_proxy, so we don&#39;t want</span>
<span class="gi">+                    # to apply the proxies on this URL.</span>
<span class="gi">+                    return True</span>
<span class="gi">+</span>
<span class="gi">+    with set_environ(&quot;no_proxy&quot;, no_proxy_arg):</span>
<span class="gi">+        # parsed.hostname can be `None` in cases such as a file URI.</span>
<span class="gi">+        try:</span>
<span class="gi">+            bypass = proxy_bypass(parsed.hostname)</span>
<span class="gi">+        except (TypeError, socket.gaierror):</span>
<span class="gi">+            bypass = False</span>
<span class="gi">+</span>
<span class="gi">+    if bypass:</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    return False</span>


<span class="w"> </span>def get_environ_proxies(url, no_proxy=None):
<span class="gu">@@ -333,7 +829,10 @@ def get_environ_proxies(url, no_proxy=None):</span>

<span class="w"> </span>    :rtype: dict
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if should_bypass_proxies(url, no_proxy=no_proxy):</span>
<span class="gi">+        return {}</span>
<span class="gi">+    else:</span>
<span class="gi">+        return getproxies()</span>


<span class="w"> </span>def select_proxy(url, proxies):
<span class="gu">@@ -342,7 +841,24 @@ def select_proxy(url, proxies):</span>
<span class="w"> </span>    :param url: The url being for the request
<span class="w"> </span>    :param proxies: A dictionary of schemes or schemes and hosts to proxy URLs
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    proxies = proxies or {}</span>
<span class="gi">+    urlparts = urlparse(url)</span>
<span class="gi">+    if urlparts.hostname is None:</span>
<span class="gi">+        return proxies.get(urlparts.scheme, proxies.get(&quot;all&quot;))</span>
<span class="gi">+</span>
<span class="gi">+    proxy_keys = [</span>
<span class="gi">+        urlparts.scheme + &quot;://&quot; + urlparts.hostname,</span>
<span class="gi">+        urlparts.scheme,</span>
<span class="gi">+        &quot;all://&quot; + urlparts.hostname,</span>
<span class="gi">+        &quot;all&quot;,</span>
<span class="gi">+    ]</span>
<span class="gi">+    proxy = None</span>
<span class="gi">+    for proxy_key in proxy_keys:</span>
<span class="gi">+        if proxy_key in proxies:</span>
<span class="gi">+            proxy = proxies[proxy_key]</span>
<span class="gi">+            break</span>
<span class="gi">+</span>
<span class="gi">+    return proxy</span>


<span class="w"> </span>def resolve_proxies(request, proxies, trust_env=True):
<span class="gu">@@ -356,23 +872,43 @@ def resolve_proxies(request, proxies, trust_env=True):</span>

<span class="w"> </span>    :rtype: dict
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    proxies = proxies if proxies is not None else {}</span>
<span class="gi">+    url = request.url</span>
<span class="gi">+    scheme = urlparse(url).scheme</span>
<span class="gi">+    no_proxy = proxies.get(&quot;no_proxy&quot;)</span>
<span class="gi">+    new_proxies = proxies.copy()</span>

<span class="gi">+    if trust_env and not should_bypass_proxies(url, no_proxy=no_proxy):</span>
<span class="gi">+        environ_proxies = get_environ_proxies(url, no_proxy=no_proxy)</span>

<span class="gd">-def default_user_agent(name=&#39;python-requests&#39;):</span>
<span class="gi">+        proxy = environ_proxies.get(scheme, environ_proxies.get(&quot;all&quot;))</span>
<span class="gi">+</span>
<span class="gi">+        if proxy:</span>
<span class="gi">+            new_proxies.setdefault(scheme, proxy)</span>
<span class="gi">+    return new_proxies</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def default_user_agent(name=&quot;python-requests&quot;):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Return a string representing the default user agent.

<span class="w"> </span>    :rtype: str
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return f&quot;{name}/{__version__}&quot;</span>


<span class="w"> </span>def default_headers():
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    :rtype: requests.structures.CaseInsensitiveDict
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return CaseInsensitiveDict(</span>
<span class="gi">+        {</span>
<span class="gi">+            &quot;User-Agent&quot;: default_user_agent(),</span>
<span class="gi">+            &quot;Accept-Encoding&quot;: DEFAULT_ACCEPT_ENCODING,</span>
<span class="gi">+            &quot;Accept&quot;: &quot;*/*&quot;,</span>
<span class="gi">+            &quot;Connection&quot;: &quot;keep-alive&quot;,</span>
<span class="gi">+        }</span>
<span class="gi">+    )</span>


<span class="w"> </span>def parse_header_links(value):
<span class="gu">@@ -382,10 +918,38 @@ def parse_header_links(value):</span>

<span class="w"> </span>    :rtype: list
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>

<span class="gi">+    links = []</span>
<span class="gi">+</span>
<span class="gi">+    replace_chars = &quot; &#39;\&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    value = value.strip(replace_chars)</span>
<span class="gi">+    if not value:</span>
<span class="gi">+        return links</span>
<span class="gi">+</span>
<span class="gi">+    for val in re.split(&quot;, *&lt;&quot;, value):</span>
<span class="gi">+        try:</span>
<span class="gi">+            url, params = val.split(&quot;;&quot;, 1)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            url, params = val, &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+        link = {&quot;url&quot;: url.strip(&quot;&lt;&gt; &#39;\&quot;&quot;)}</span>

<span class="gd">-_null = &#39;\x00&#39;.encode(&#39;ascii&#39;)</span>
<span class="gi">+        for param in params.split(&quot;;&quot;):</span>
<span class="gi">+            try:</span>
<span class="gi">+                key, value = param.split(&quot;=&quot;)</span>
<span class="gi">+            except ValueError:</span>
<span class="gi">+                break</span>
<span class="gi">+</span>
<span class="gi">+            link[key.strip(replace_chars)] = value.strip(replace_chars)</span>
<span class="gi">+</span>
<span class="gi">+        links.append(link)</span>
<span class="gi">+</span>
<span class="gi">+    return links</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+# Null bytes; no need to recreate these on each call to guess_json_utf</span>
<span class="gi">+_null = &quot;\x00&quot;.encode(&quot;ascii&quot;)  # encoding to ASCII for Python 3</span>
<span class="w"> </span>_null2 = _null * 2
<span class="w"> </span>_null3 = _null * 3

<span class="gu">@@ -394,7 +958,32 @@ def guess_json_utf(data):</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    :rtype: str
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # JSON always starts with two ASCII characters, so detection is as</span>
<span class="gi">+    # easy as counting the nulls and from their location and count</span>
<span class="gi">+    # determine the encoding. Also detect a BOM, if present.</span>
<span class="gi">+    sample = data[:4]</span>
<span class="gi">+    if sample in (codecs.BOM_UTF32_LE, codecs.BOM_UTF32_BE):</span>
<span class="gi">+        return &quot;utf-32&quot;  # BOM included</span>
<span class="gi">+    if sample[:3] == codecs.BOM_UTF8:</span>
<span class="gi">+        return &quot;utf-8-sig&quot;  # BOM included, MS style (discouraged)</span>
<span class="gi">+    if sample[:2] in (codecs.BOM_UTF16_LE, codecs.BOM_UTF16_BE):</span>
<span class="gi">+        return &quot;utf-16&quot;  # BOM included</span>
<span class="gi">+    nullcount = sample.count(_null)</span>
<span class="gi">+    if nullcount == 0:</span>
<span class="gi">+        return &quot;utf-8&quot;</span>
<span class="gi">+    if nullcount == 2:</span>
<span class="gi">+        if sample[::2] == _null2:  # 1st and 3rd are null</span>
<span class="gi">+            return &quot;utf-16-be&quot;</span>
<span class="gi">+        if sample[1::2] == _null2:  # 2nd and 4th are null</span>
<span class="gi">+            return &quot;utf-16-le&quot;</span>
<span class="gi">+        # Did not detect 2 valid UTF-16 ascii-range characters</span>
<span class="gi">+    if nullcount == 3:</span>
<span class="gi">+        if sample[:3] == _null3:</span>
<span class="gi">+            return &quot;utf-32-be&quot;</span>
<span class="gi">+        if sample[1:] == _null3:</span>
<span class="gi">+            return &quot;utf-32-le&quot;</span>
<span class="gi">+        # Did not detect a valid UTF-32 ascii-range character</span>
<span class="gi">+    return None</span>


<span class="w"> </span>def prepend_scheme_if_needed(url, new_scheme):
<span class="gu">@@ -403,7 +992,27 @@ def prepend_scheme_if_needed(url, new_scheme):</span>

<span class="w"> </span>    :rtype: str
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parsed = parse_url(url)</span>
<span class="gi">+    scheme, auth, host, port, path, query, fragment = parsed</span>
<span class="gi">+</span>
<span class="gi">+    # A defect in urlparse determines that there isn&#39;t a netloc present in some</span>
<span class="gi">+    # urls. We previously assumed parsing was overly cautious, and swapped the</span>
<span class="gi">+    # netloc and path. Due to a lack of tests on the original defect, this is</span>
<span class="gi">+    # maintained with parse_url for backwards compatibility.</span>
<span class="gi">+    netloc = parsed.netloc</span>
<span class="gi">+    if not netloc:</span>
<span class="gi">+        netloc, path = path, netloc</span>
<span class="gi">+</span>
<span class="gi">+    if auth:</span>
<span class="gi">+        # parse_url doesn&#39;t provide the netloc with auth</span>
<span class="gi">+        # so we&#39;ll add it ourselves.</span>
<span class="gi">+        netloc = &quot;@&quot;.join([auth, netloc])</span>
<span class="gi">+    if scheme is None:</span>
<span class="gi">+        scheme = new_scheme</span>
<span class="gi">+    if path is None:</span>
<span class="gi">+        path = &quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    return urlunparse((scheme, netloc, path, &quot;&quot;, query, fragment))</span>


<span class="w"> </span>def get_auth_from_url(url):
<span class="gu">@@ -412,7 +1021,14 @@ def get_auth_from_url(url):</span>

<span class="w"> </span>    :rtype: (str,str)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parsed = urlparse(url)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        auth = (unquote(parsed.username), unquote(parsed.password))</span>
<span class="gi">+    except (AttributeError, TypeError):</span>
<span class="gi">+        auth = (&quot;&quot;, &quot;&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return auth</span>


<span class="w"> </span>def check_header_validity(header):
<span class="gu">@@ -421,7 +1037,28 @@ def check_header_validity(header):</span>

<span class="w"> </span>    :param header: tuple, in the format (name, value).
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    name, value = header</span>
<span class="gi">+    _validate_header_part(header, name, 0)</span>
<span class="gi">+    _validate_header_part(header, value, 1)</span>
<span class="gi">+</span>
<span class="gi">+</span>
<span class="gi">+def _validate_header_part(header, header_part, header_validator_index):</span>
<span class="gi">+    if isinstance(header_part, str):</span>
<span class="gi">+        validator = _HEADER_VALIDATORS_STR[header_validator_index]</span>
<span class="gi">+    elif isinstance(header_part, bytes):</span>
<span class="gi">+        validator = _HEADER_VALIDATORS_BYTE[header_validator_index]</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise InvalidHeader(</span>
<span class="gi">+            f&quot;Header part ({header_part!r}) from {header} &quot;</span>
<span class="gi">+            f&quot;must be of type str or bytes, not {type(header_part)}&quot;</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+    if not validator.match(header_part):</span>
<span class="gi">+        header_kind = &quot;name&quot; if header_validator_index == 0 else &quot;value&quot;</span>
<span class="gi">+        raise InvalidHeader(</span>
<span class="gi">+            f&quot;Invalid leading whitespace, reserved character(s), or return &quot;</span>
<span class="gi">+            f&quot;character(s) in header {header_kind}: {header_part!r}&quot;</span>
<span class="gi">+        )</span>


<span class="w"> </span>def urldefragauth(url):
<span class="gu">@@ -430,11 +1067,30 @@ def urldefragauth(url):</span>

<span class="w"> </span>    :rtype: str
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    scheme, netloc, path, params, query, fragment = urlparse(url)</span>
<span class="gi">+</span>
<span class="gi">+    # see func:`prepend_scheme_if_needed`</span>
<span class="gi">+    if not netloc:</span>
<span class="gi">+        netloc, path = path, netloc</span>
<span class="gi">+</span>
<span class="gi">+    netloc = netloc.rsplit(&quot;@&quot;, 1)[-1]</span>
<span class="gi">+</span>
<span class="gi">+    return urlunparse((scheme, netloc, path, params, query, &quot;&quot;))</span>


<span class="w"> </span>def rewind_body(prepared_request):
<span class="w"> </span>    &quot;&quot;&quot;Move file pointer back to its recorded starting position
<span class="w"> </span>    so it can be read again on redirect.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    body_seek = getattr(prepared_request.body, &quot;seek&quot;, None)</span>
<span class="gi">+    if body_seek is not None and isinstance(</span>
<span class="gi">+        prepared_request._body_position, integer_types</span>
<span class="gi">+    ):</span>
<span class="gi">+        try:</span>
<span class="gi">+            body_seek(prepared_request._body_position)</span>
<span class="gi">+        except OSError:</span>
<span class="gi">+            raise UnrewindableBodyError(</span>
<span class="gi">+                &quot;An error occurred when rewinding request body for redirect.&quot;</span>
<span class="gi">+            )</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise UnrewindableBodyError(&quot;Unable to rewind request body for redirect.&quot;)</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>