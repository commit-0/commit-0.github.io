
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis openhands commit0 openhands xarray - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#openhands-xarray" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis openhands commit0 openhands xarray
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#failed-to-run-pytests-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed to run pytests for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_openhands-commit0_openhands">back to OpenHands summary</a></p>
<h1 id="openhands-xarray"><strong>OpenHands</strong>: xarray</h1>
<h2 id="failed-to-run-pytests-for-test-tests">Failed to run pytests for test <code>tests</code></h2>
<div class="highlight"><pre><span></span><code>ImportError while loading conftest &#39;/testbed/xarray/tests/conftest.py&#39;.
xarray/__init__.py:3: in &lt;module&gt;
    from xarray import groupers, testing, tutorial
xarray/groupers.py:13: in &lt;module&gt;
    from xarray.coding.cftime_offsets import _new_to_legacy_freq
xarray/coding/cftime_offsets.py:11: in &lt;module&gt;
    from xarray.coding.cftimeindex import CFTimeIndex, _parse_iso8601_with_reso
xarray/coding/cftimeindex.py:11: in &lt;module&gt;
    from xarray.coding.times import _STANDARD_CALENDARS, cftime_to_nptime, infer_calendar_name
xarray/coding/times.py:11: in &lt;module&gt;
    from xarray.coding.variables import SerializationWarning, VariableCoder, lazy_elemwise_func, pop_to, safe_setitem, unpack_for_decoding, unpack_for_encoding
xarray/coding/variables.py:10: in &lt;module&gt;
    from xarray.core.variable import Variable
xarray/core/variable.py:16: in &lt;module&gt;
    from xarray.core import common, dtypes, duck_array_ops, indexing, nputils, ops, utils
xarray/core/common.py:10: in &lt;module&gt;
    from xarray.core import dtypes, duck_array_ops, formatting, formatting_html, ops
xarray/core/formatting.py:222: in &lt;module&gt;
    diff_data_vars_repr = functools.partial(_diff_mapping_repr, title=&#39;Data variables&#39;, summarizer=summarize_variable)
E   NameError: name &#39;_diff_mapping_repr&#39; is not defined
</code></pre></div>
<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/xarray/coding/cftimeindex.py b/xarray/coding/cftimeindex.py</span>
<span class="gh">index 1ac35797..4c65fada 100644</span>
<span class="gd">--- a/xarray/coding/cftimeindex.py</span>
<span class="gi">+++ b/xarray/coding/cftimeindex.py</span>
<span class="gu">@@ -110,13 +110,13 @@ class CFTimeIndex(pd.Index):</span>
<span class="w"> </span>        else:
<span class="w"> </span>            front_str = format_times(self.values[:REPR_ELLIPSIS_SHOW_ITEMS_FRONT_END], display_width, offset=offset, first_row_offset=0, last_row_end=&#39;,&#39;)
<span class="w"> </span>            end_str = format_times(self.values[-REPR_ELLIPSIS_SHOW_ITEMS_FRONT_END:], display_width, offset=offset, first_row_offset=offset)
<span class="gd">-            datastr = &#39;\n&#39;.join([front_str, f&#39;{&#39; &#39; * offset}...&#39;, end_str])</span>
<span class="gi">+            datastr = &#39;\n&#39;.join([front_str, f&#39;{&quot; &quot; * offset}...&#39;, end_str])</span>
<span class="w"> </span>        attrs_str = format_attrs(self)
<span class="w"> </span>        full_repr_str = f&#39;{klass_name}([{datastr}], {attrs_str})&#39;
<span class="w"> </span>        if len(full_repr_str) &gt; display_width:
<span class="w"> </span>            if len(attrs_str) &gt;= display_width - offset:
<span class="gd">-                attrs_str = attrs_str.replace(&#39;,&#39;, f&#39;,\n{&#39; &#39; * (offset - 2)}&#39;)</span>
<span class="gd">-            full_repr_str = f&#39;{klass_name}([{datastr}],\n{&#39; &#39; * (offset - 1)}{attrs_str})&#39;</span>
<span class="gi">+                attrs_str = attrs_str.replace(&#39;,&#39;, f&#39;,\n{&quot; &quot; * (offset - 2)}&#39;)</span>
<span class="gi">+            full_repr_str = f&#39;{klass_name}([{datastr}],\n{&quot; &quot; * (offset - 1)}{attrs_str})&#39;</span>
<span class="w"> </span>        return full_repr_str

<span class="w"> </span>    def _partial_date_slice(self, resolution, parsed):
<span class="gh">diff --git a/xarray/core/datatree_render.py b/xarray/core/datatree_render.py</span>
<span class="gh">index f36fccdc..33a04e18 100644</span>
<span class="gd">--- a/xarray/core/datatree_render.py</span>
<span class="gi">+++ b/xarray/core/datatree_render.py</span>
<span class="gu">@@ -8,9 +8,23 @@ type hints.</span>
<span class="w"> </span>from __future__ import annotations
<span class="w"> </span>from collections import namedtuple
<span class="w"> </span>from collections.abc import Iterable, Iterator
<span class="gd">-from typing import TYPE_CHECKING</span>
<span class="gi">+from typing import TYPE_CHECKING, TypeVar</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from xarray.core.datatree import DataTree
<span class="gi">+</span>
<span class="gi">+T = TypeVar(&#39;T&#39;)</span>
<span class="gi">+</span>
<span class="gi">+def _last_iter(iterable: Iterable[T]) -&gt; Iterator[tuple[T, bool]]:</span>
<span class="gi">+    &quot;&quot;&quot;Iterate and generate a tuple with a flag for the last item.&quot;&quot;&quot;</span>
<span class="gi">+    iterator = iter(iterable)</span>
<span class="gi">+    try:</span>
<span class="gi">+        last = next(iterator)</span>
<span class="gi">+    except StopIteration:</span>
<span class="gi">+        return</span>
<span class="gi">+    for item in iterator:</span>
<span class="gi">+        yield last, False</span>
<span class="gi">+        last = item</span>
<span class="gi">+    yield last, True</span>
<span class="w"> </span>Row = namedtuple(&#39;Row&#39;, (&#39;pre&#39;, &#39;fill&#39;, &#39;node&#39;))

<span class="w"> </span>class AbstractStyle:
<span class="gu">@@ -32,7 +46,7 @@ class AbstractStyle:</span>
<span class="w"> </span>    @property
<span class="w"> </span>    def empty(self) -&gt; str:
<span class="w"> </span>        &quot;&quot;&quot;Empty string as placeholder.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return &#39; &#39; * len(self.vertical)</span>

<span class="w"> </span>    def __repr__(self) -&gt; str:
<span class="w"> </span>        return f&#39;{self.__class__.__name__}()&#39;
<span class="gu">@@ -146,6 +160,30 @@ class RenderDataTree:</span>
<span class="w"> </span>        self.childiter = childiter
<span class="w"> </span>        self.maxlevel = maxlevel

<span class="gi">+    def __next(self, node: DataTree, continues: tuple[bool, ...]) -&gt; Iterator[Row]:</span>
<span class="gi">+        &quot;&quot;&quot;Iterate over tree with level information.&quot;&quot;&quot;</span>
<span class="gi">+        # Prepare level</span>
<span class="gi">+        level = len(continues)</span>
<span class="gi">+        if self.maxlevel is not None and level &gt; self.maxlevel:</span>
<span class="gi">+            return</span>
<span class="gi">+</span>
<span class="gi">+        # Prepare prefix</span>
<span class="gi">+        if level == 0:</span>
<span class="gi">+            pre = &#39;&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            pre = &#39;&#39;.join(self.style.vertical if cont else self.style.empty for cont in continues[:-1])</span>
<span class="gi">+            pre += self.style.cont if continues[-1] else self.style.end</span>
<span class="gi">+</span>
<span class="gi">+        # Yield current node</span>
<span class="gi">+        yield Row(pre, pre.replace(self.style.cont, self.style.vertical), node)</span>
<span class="gi">+</span>
<span class="gi">+        # Recurse for children</span>
<span class="gi">+        children = list(node.children.values())</span>
<span class="gi">+        if children:</span>
<span class="gi">+            children = self.childiter(children)</span>
<span class="gi">+            for child, is_last in _last_iter(children):</span>
<span class="gi">+                yield from self.__next(child, continues + (not is_last,))</span>
<span class="gi">+</span>
<span class="w"> </span>    def __iter__(self) -&gt; Iterator[Row]:
<span class="w"> </span>        return self.__next(self.node, tuple())

<span class="gu">@@ -155,7 +193,7 @@ class RenderDataTree:</span>
<span class="w"> </span>    def __repr__(self) -&gt; str:
<span class="w"> </span>        classname = self.__class__.__name__
<span class="w"> </span>        args = [repr(self.node), f&#39;style={repr(self.style)}&#39;, f&#39;childiter={repr(self.childiter)}&#39;]
<span class="gd">-        return f&#39;{classname}({&#39;, &#39;.join(args)})&#39;</span>
<span class="gi">+        return f&quot;{classname}({&#39;, &#39;.join(args)})&quot;</span>

<span class="w"> </span>    def by_attr(self, attrname: str=&#39;name&#39;) -&gt; str:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -189,4 +227,7 @@ class RenderDataTree:</span>
<span class="w"> </span>            └── sub1C
<span class="w"> </span>                └── sub1Ca
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
\ No newline at end of file
<span class="gi">+        lines = []</span>
<span class="gi">+        for pre, _, node in self:</span>
<span class="gi">+            lines.append(f&quot;{pre}{getattr(node, attrname)}&quot;)</span>
<span class="gi">+        return &#39;\n&#39;.join(lines)</span>
\ No newline at end of file
<span class="gh">diff --git a/xarray/core/duck_array_ops.py b/xarray/core/duck_array_ops.py</span>
<span class="gh">index 6db6fdb5..97c6bf61 100644</span>
<span class="gd">--- a/xarray/core/duck_array_ops.py</span>
<span class="gi">+++ b/xarray/core/duck_array_ops.py</span>
<span class="gu">@@ -33,7 +33,48 @@ dask_available = module_available(&#39;dask&#39;)</span>

<span class="w"> </span>def _dask_or_eager_func(name, eager_module=np, dask_module=&#39;dask.array&#39;):
<span class="w"> </span>    &quot;&quot;&quot;Create a function that dispatches to dask for dask array inputs.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def wrapper(*args, **kwargs):</span>
<span class="gi">+        if any(is_duck_dask_array(arg) for arg in args):</span>
<span class="gi">+            try:</span>
<span class="gi">+                module = import_module(dask_module)</span>
<span class="gi">+            except ImportError:</span>
<span class="gi">+                raise ImportError(f&quot;Cannot use {name} with dask arrays without installing dask.&quot;)</span>
<span class="gi">+            func = getattr(module, name)</span>
<span class="gi">+        else:</span>
<span class="gi">+            func = getattr(eager_module, name)</span>
<span class="gi">+        return func(*args, **kwargs)</span>
<span class="gi">+    return wrapper</span>
<span class="gi">+</span>
<span class="gi">+def _create_nan_agg_method(name: str, coerce_strings: bool=False, invariant_0d: bool=False):</span>
<span class="gi">+    &quot;&quot;&quot;Create a function that dispatches to bottleneck, numbagg, or numpy based on OPTIONS.&quot;&quot;&quot;</span>
<span class="gi">+    def method(values, axis=None, skipna=None, **kwargs):</span>
<span class="gi">+        # For strings, skip bottleneck or numbagg and use the numpy or dask version</span>
<span class="gi">+        if coerce_strings and values.dtype.kind in {&#39;U&#39;, &#39;S&#39;, &#39;O&#39;}:</span>
<span class="gi">+            if skipna or (skipna is None and values.dtype.kind == &#39;O&#39;):</span>
<span class="gi">+                values = getattr(np, name)(values, axis=axis, **kwargs)</span>
<span class="gi">+            else:</span>
<span class="gi">+                values = getattr(np, name)(values, axis=axis, **kwargs)</span>
<span class="gi">+            return values</span>
<span class="gi">+</span>
<span class="gi">+        if skipna or (skipna is None and values.dtype.kind not in {&#39;b&#39;, &#39;i&#39;, &#39;u&#39;}):</span>
<span class="gi">+            if is_duck_dask_array(values):</span>
<span class="gi">+                module = import_module(&#39;dask.array&#39;)</span>
<span class="gi">+                func = getattr(module, f&#39;nan{name}&#39;)</span>
<span class="gi">+                return func(values, axis=axis, **kwargs)</span>
<span class="gi">+            else:</span>
<span class="gi">+                func = getattr(nputils, f&#39;nan{name}&#39;)</span>
<span class="gi">+                return func(values, axis=axis, **kwargs)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if is_duck_dask_array(values):</span>
<span class="gi">+                module = import_module(&#39;dask.array&#39;)</span>
<span class="gi">+                func = getattr(module, name)</span>
<span class="gi">+                return func(values, axis=axis, **kwargs)</span>
<span class="gi">+            else:</span>
<span class="gi">+                return getattr(np, name)(values, axis=axis, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    method.numeric_only = False</span>
<span class="gi">+    method.available_min_count = False</span>
<span class="gi">+    return method</span>
<span class="w"> </span>pandas_isnull = _dask_or_eager_func(&#39;isnull&#39;, eager_module=pd, dask_module=&#39;dask.array&#39;)
<span class="w"> </span>around.__doc__ = str.replace(around.__doc__ or &#39;&#39;, &#39;array([0.,  2.])&#39;, &#39;array([0., 2.])&#39;)
<span class="w"> </span>around.__doc__ = str.replace(around.__doc__ or &#39;&#39;, &#39;array([0.,  2.])&#39;, &#39;array([0., 2.])&#39;)
<span class="gu">@@ -44,7 +85,20 @@ masked_invalid = _dask_or_eager_func(&#39;masked_invalid&#39;, eager_module=np.ma, dask_</span>

<span class="w"> </span>def as_shared_dtype(scalars_or_arrays, xp=None):
<span class="w"> </span>    &quot;&quot;&quot;Cast a arrays to a shared dtype using xarray&#39;s type promotion rules.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not scalars_or_arrays:</span>
<span class="gi">+        return []</span>
<span class="gi">+    </span>
<span class="gi">+    if xp is None:</span>
<span class="gi">+        xp = np</span>
<span class="gi">+    </span>
<span class="gi">+    # Convert all inputs to arrays</span>
<span class="gi">+    arrays = [xp.asarray(x) for x in scalars_or_arrays]</span>
<span class="gi">+    </span>
<span class="gi">+    # Get the target dtype using type promotion rules</span>
<span class="gi">+    target_dtype = dtypes.result_type(*arrays)</span>
<span class="gi">+    </span>
<span class="gi">+    # Cast all arrays to the target dtype</span>
<span class="gi">+    return [xp.asarray(arr, dtype=target_dtype) for arr in arrays]</span>

<span class="w"> </span>def lazy_array_equiv(arr1, arr2):
<span class="w"> </span>    &quot;&quot;&quot;Like array_equal, but doesn&#39;t actually compare values.
<span class="gu">@@ -53,37 +107,134 @@ def lazy_array_equiv(arr1, arr2):</span>
<span class="w"> </span>    Returns None when equality cannot determined: one or both of arr1, arr2 are numpy arrays;
<span class="w"> </span>    or their dask tokens are not equal
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if arr1 is arr2:</span>
<span class="gi">+        return True</span>
<span class="gi">+    </span>
<span class="gi">+    if arr1 is None or arr2 is None:</span>
<span class="gi">+        return arr1 is None and arr2 is None</span>
<span class="gi">+    </span>
<span class="gi">+    if not is_duck_array(arr1) or not is_duck_array(arr2):</span>
<span class="gi">+        return None</span>
<span class="gi">+    </span>
<span class="gi">+    if arr1.shape != arr2.shape:</span>
<span class="gi">+        return False</span>
<span class="gi">+    </span>
<span class="gi">+    if is_duck_dask_array(arr1) and is_duck_dask_array(arr2):</span>
<span class="gi">+        from dask.base import tokenize</span>
<span class="gi">+        return tokenize(arr1) == tokenize(arr2)</span>
<span class="gi">+    </span>
<span class="gi">+    return None</span>

<span class="w"> </span>def allclose_or_equiv(arr1, arr2, rtol=1e-05, atol=1e-08):
<span class="w"> </span>    &quot;&quot;&quot;Like np.allclose, but also allows values to be NaN in both arrays&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    arr1, arr2 = as_shared_dtype([arr1, arr2])</span>
<span class="gi">+    </span>
<span class="gi">+    if arr1.shape != arr2.shape:</span>
<span class="gi">+        return False</span>
<span class="gi">+    </span>
<span class="gi">+    if is_duck_dask_array(arr1) or is_duck_dask_array(arr2):</span>
<span class="gi">+        import dask.array as da</span>
<span class="gi">+        arr1 = da.asarray(arr1)</span>
<span class="gi">+        arr2 = da.asarray(arr2)</span>
<span class="gi">+        </span>
<span class="gi">+        # Check if arrays are equal (including NaN)</span>
<span class="gi">+        equal_nan = da.isnan(arr1) &amp; da.isnan(arr2)</span>
<span class="gi">+        close = da.isclose(arr1, arr2, rtol=rtol, atol=atol, equal_nan=True)</span>
<span class="gi">+        return bool(da.all(equal_nan | close).compute())</span>
<span class="gi">+    </span>
<span class="gi">+    # Check if arrays are equal (including NaN)</span>
<span class="gi">+    equal_nan = np.isnan(arr1) &amp; np.isnan(arr2)</span>
<span class="gi">+    close = np.isclose(arr1, arr2, rtol=rtol, atol=atol, equal_nan=True)</span>
<span class="gi">+    return bool(np.all(equal_nan | close))</span>

<span class="w"> </span>def array_equiv(arr1, arr2):
<span class="w"> </span>    &quot;&quot;&quot;Like np.array_equal, but also allows values to be NaN in both arrays&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    arr1, arr2 = as_shared_dtype([arr1, arr2])</span>
<span class="gi">+    </span>
<span class="gi">+    if arr1.shape != arr2.shape:</span>
<span class="gi">+        return False</span>
<span class="gi">+    </span>
<span class="gi">+    if is_duck_dask_array(arr1) or is_duck_dask_array(arr2):</span>
<span class="gi">+        import dask.array as da</span>
<span class="gi">+        arr1 = da.asarray(arr1)</span>
<span class="gi">+        arr2 = da.asarray(arr2)</span>
<span class="gi">+        </span>
<span class="gi">+        # Check if arrays are equal (including NaN)</span>
<span class="gi">+        equal_nan = da.isnan(arr1) &amp; da.isnan(arr2)</span>
<span class="gi">+        equal = arr1 == arr2</span>
<span class="gi">+        return bool(da.all(equal_nan | equal).compute())</span>
<span class="gi">+    </span>
<span class="gi">+    # Check if arrays are equal (including NaN)</span>
<span class="gi">+    equal_nan = np.isnan(arr1) &amp; np.isnan(arr2)</span>
<span class="gi">+    equal = arr1 == arr2</span>
<span class="gi">+    return bool(np.all(equal_nan | equal))</span>

<span class="w"> </span>def array_notnull_equiv(arr1, arr2):
<span class="w"> </span>    &quot;&quot;&quot;Like np.array_equal, but also allows values to be NaN in either or both
<span class="w"> </span>    arrays
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    arr1, arr2 = as_shared_dtype([arr1, arr2])</span>
<span class="gi">+    </span>
<span class="gi">+    if arr1.shape != arr2.shape:</span>
<span class="gi">+        return False</span>
<span class="gi">+    </span>
<span class="gi">+    if is_duck_dask_array(arr1) or is_duck_dask_array(arr2):</span>
<span class="gi">+        import dask.array as da</span>
<span class="gi">+        arr1 = da.asarray(arr1)</span>
<span class="gi">+        arr2 = da.asarray(arr2)</span>
<span class="gi">+        </span>
<span class="gi">+        # Check if arrays are equal where neither is NaN</span>
<span class="gi">+        valid = ~(da.isnan(arr1) | da.isnan(arr2))</span>
<span class="gi">+        equal = arr1 == arr2</span>
<span class="gi">+        return bool(da.all(~valid | equal).compute())</span>
<span class="gi">+    </span>
<span class="gi">+    # Check if arrays are equal where neither is NaN</span>
<span class="gi">+    valid = ~(np.isnan(arr1) | np.isnan(arr2))</span>
<span class="gi">+    equal = arr1 == arr2</span>
<span class="gi">+    return bool(np.all(~valid | equal))</span>

<span class="w"> </span>def count(data, axis=None):
<span class="w"> </span>    &quot;&quot;&quot;Count the number of non-NA in this array along the given axis or axes&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if is_duck_dask_array(data):</span>
<span class="gi">+        import dask.array as da</span>
<span class="gi">+        return da.count_nonzero(~da.isnan(data), axis=axis)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return np.count_nonzero(~np.isnan(data), axis=axis)</span>

<span class="w"> </span>def where(condition, x, y):
<span class="w"> </span>    &quot;&quot;&quot;Three argument where() with better dtype promotion rules.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if is_duck_dask_array(condition) or is_duck_dask_array(x) or is_duck_dask_array(y):</span>
<span class="gi">+        import dask.array as da</span>
<span class="gi">+        return da.where(condition, x, y)</span>
<span class="gi">+    else:</span>
<span class="gi">+        x, y = as_shared_dtype([x, y])</span>
<span class="gi">+        return np.where(condition, x, y)</span>

<span class="w"> </span>def concatenate(arrays, axis=0):
<span class="w"> </span>    &quot;&quot;&quot;concatenate() with better dtype promotion rules.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not arrays:</span>
<span class="gi">+        return np.array([], dtype=object)</span>
<span class="gi">+    </span>
<span class="gi">+    if any(is_duck_dask_array(arr) for arr in arrays):</span>
<span class="gi">+        import dask.array as da</span>
<span class="gi">+        arrays = [da.asarray(arr) for arr in arrays]</span>
<span class="gi">+        return da.concatenate(arrays, axis=axis)</span>
<span class="gi">+    else:</span>
<span class="gi">+        arrays = as_shared_dtype(arrays)</span>
<span class="gi">+        return _concatenate(arrays, axis=axis)</span>

<span class="w"> </span>def stack(arrays, axis=0):
<span class="w"> </span>    &quot;&quot;&quot;stack() with better dtype promotion rules.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not arrays:</span>
<span class="gi">+        return np.array([], dtype=object)</span>
<span class="gi">+    </span>
<span class="gi">+    if any(is_duck_dask_array(arr) for arr in arrays):</span>
<span class="gi">+        import dask.array as da</span>
<span class="gi">+        arrays = [da.asarray(arr) for arr in arrays]</span>
<span class="gi">+        return da.stack(arrays, axis=axis)</span>
<span class="gi">+    else:</span>
<span class="gi">+        arrays = as_shared_dtype(arrays)</span>
<span class="gi">+        return np.stack(arrays, axis=axis)</span>
<span class="w"> </span>argmax = _create_nan_agg_method(&#39;argmax&#39;, coerce_strings=True)
<span class="w"> </span>argmin = _create_nan_agg_method(&#39;argmin&#39;, coerce_strings=True)
<span class="w"> </span>max = _create_nan_agg_method(&#39;max&#39;, coerce_strings=True, invariant_0d=True)
<span class="gu">@@ -115,7 +266,19 @@ def _datetime_nanmin(array):</span>
<span class="w"> </span>    - numpy nanmin() don&#39;t work on datetime64 (all versions at the moment of writing)
<span class="w"> </span>    - dask min() does not work on datetime64 (all versions at the moment of writing)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if is_duck_dask_array(array):</span>
<span class="gi">+        import dask.array as da</span>
<span class="gi">+        mask = ~da.isnat(array)</span>
<span class="gi">+        valid = array[mask]</span>
<span class="gi">+        if valid.size == 0:</span>
<span class="gi">+            return np.datetime64(&#39;NaT&#39;)</span>
<span class="gi">+        return da.min(valid).compute()</span>
<span class="gi">+    else:</span>
<span class="gi">+        mask = ~isnat(array)</span>
<span class="gi">+        valid = array[mask]</span>
<span class="gi">+        if valid.size == 0:</span>
<span class="gi">+            return np.datetime64(&#39;NaT&#39;)</span>
<span class="gi">+        return valid.min()</span>

<span class="w"> </span>def datetime_to_numeric(array, offset=None, datetime_unit=None, dtype=float):
<span class="w"> </span>    &quot;&quot;&quot;Convert an array containing datetime-like data to numerical values.
<span class="gu">@@ -142,7 +305,22 @@ def datetime_to_numeric(array, offset=None, datetime_unit=None, dtype=float):</span>
<span class="w"> </span>    though some calendars would allow for them (e.g. no_leap). This is because there
<span class="w"> </span>    is no `cftime.timedelta` object.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if offset is None:</span>
<span class="gi">+        offset = _datetime_nanmin(array)</span>
<span class="gi">+    </span>
<span class="gi">+    if is_duck_dask_array(array):</span>
<span class="gi">+        import dask.array as da</span>
<span class="gi">+        result = da.subtract(array, offset)</span>
<span class="gi">+    else:</span>
<span class="gi">+        result = array - offset</span>
<span class="gi">+    </span>
<span class="gi">+    if datetime_unit is not None:</span>
<span class="gi">+        if isinstance(result, np.ndarray):</span>
<span class="gi">+            result = np_timedelta64_to_float(result, datetime_unit)</span>
<span class="gi">+        else:</span>
<span class="gi">+            result = timedelta_to_numeric(result, datetime_unit)</span>
<span class="gi">+    </span>
<span class="gi">+    return result.astype(dtype)</span>

<span class="w"> </span>def timedelta_to_numeric(value, datetime_unit=&#39;ns&#39;, dtype=float):
<span class="w"> </span>    &quot;&quot;&quot;Convert a timedelta-like object to numerical values.
<span class="gu">@@ -158,7 +336,17 @@ def timedelta_to_numeric(value, datetime_unit=&#39;ns&#39;, dtype=float):</span>
<span class="w"> </span>        The output data type.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(value, np.ndarray):</span>
<span class="gi">+        if np.issubdtype(value.dtype, np.timedelta64):</span>
<span class="gi">+            return np_timedelta64_to_float(value, datetime_unit)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return value.astype(dtype)</span>
<span class="gi">+    elif isinstance(value, pd.Timedelta):</span>
<span class="gi">+        return pd_timedelta_to_float(value, datetime_unit)</span>
<span class="gi">+    elif isinstance(value, timedelta):</span>
<span class="gi">+        return py_timedelta_to_float(value, datetime_unit)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return value</span>

<span class="w"> </span>def np_timedelta64_to_float(array, datetime_unit):
<span class="w"> </span>    &quot;&quot;&quot;Convert numpy.timedelta64 to float.
<span class="gu">@@ -168,7 +356,26 @@ def np_timedelta64_to_float(array, datetime_unit):</span>
<span class="w"> </span>    The array is first converted to microseconds, which is less likely to
<span class="w"> </span>    cause overflow errors.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Convert to microseconds first to avoid overflow errors</span>
<span class="gi">+    microseconds = array.astype(&#39;timedelta64[us]&#39;).astype(float)</span>
<span class="gi">+    </span>
<span class="gi">+    # Convert from microseconds to target unit</span>
<span class="gi">+    if datetime_unit == &#39;us&#39;:</span>
<span class="gi">+        return microseconds</span>
<span class="gi">+    elif datetime_unit == &#39;ns&#39;:</span>
<span class="gi">+        return microseconds * 1000</span>
<span class="gi">+    elif datetime_unit == &#39;ms&#39;:</span>
<span class="gi">+        return microseconds / 1000</span>
<span class="gi">+    elif datetime_unit == &#39;s&#39;:</span>
<span class="gi">+        return microseconds / 1_000_000</span>
<span class="gi">+    elif datetime_unit == &#39;m&#39;:</span>
<span class="gi">+        return microseconds / (60 * 1_000_000)</span>
<span class="gi">+    elif datetime_unit == &#39;h&#39;:</span>
<span class="gi">+        return microseconds / (3600 * 1_000_000)</span>
<span class="gi">+    elif datetime_unit == &#39;D&#39;:</span>
<span class="gi">+        return microseconds / (86400 * 1_000_000)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Unsupported datetime unit: {datetime_unit}&quot;)</span>

<span class="w"> </span>def pd_timedelta_to_float(value, datetime_unit):
<span class="w"> </span>    &quot;&quot;&quot;Convert pandas.Timedelta to float.
<span class="gu">@@ -178,40 +385,159 @@ def pd_timedelta_to_float(value, datetime_unit):</span>
<span class="w"> </span>    Built on the assumption that pandas timedelta values are in nanoseconds,
<span class="w"> </span>    which is also the numpy default resolution.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Convert to nanoseconds first</span>
<span class="gi">+    nanoseconds = float(value.value)</span>
<span class="gi">+    </span>
<span class="gi">+    # Convert from nanoseconds to target unit</span>
<span class="gi">+    if datetime_unit == &#39;ns&#39;:</span>
<span class="gi">+        return nanoseconds</span>
<span class="gi">+    elif datetime_unit == &#39;us&#39;:</span>
<span class="gi">+        return nanoseconds / 1000</span>
<span class="gi">+    elif datetime_unit == &#39;ms&#39;:</span>
<span class="gi">+        return nanoseconds / 1_000_000</span>
<span class="gi">+    elif datetime_unit == &#39;s&#39;:</span>
<span class="gi">+        return nanoseconds / 1_000_000_000</span>
<span class="gi">+    elif datetime_unit == &#39;m&#39;:</span>
<span class="gi">+        return nanoseconds / (60 * 1_000_000_000)</span>
<span class="gi">+    elif datetime_unit == &#39;h&#39;:</span>
<span class="gi">+        return nanoseconds / (3600 * 1_000_000_000)</span>
<span class="gi">+    elif datetime_unit == &#39;D&#39;:</span>
<span class="gi">+        return nanoseconds / (86400 * 1_000_000_000)</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Unsupported datetime unit: {datetime_unit}&quot;)</span>

<span class="w"> </span>def py_timedelta_to_float(array, datetime_unit):
<span class="w"> </span>    &quot;&quot;&quot;Convert a timedelta object to a float, possibly at a loss of resolution.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Convert to total seconds first</span>
<span class="gi">+    total_seconds = array.total_seconds()</span>
<span class="gi">+    </span>
<span class="gi">+    # Convert from seconds to target unit</span>
<span class="gi">+    if datetime_unit == &#39;s&#39;:</span>
<span class="gi">+        return total_seconds</span>
<span class="gi">+    elif datetime_unit == &#39;ns&#39;:</span>
<span class="gi">+        return total_seconds * 1_000_000_000</span>
<span class="gi">+    elif datetime_unit == &#39;us&#39;:</span>
<span class="gi">+        return total_seconds * 1_000_000</span>
<span class="gi">+    elif datetime_unit == &#39;ms&#39;:</span>
<span class="gi">+        return total_seconds * 1000</span>
<span class="gi">+    elif datetime_unit == &#39;m&#39;:</span>
<span class="gi">+        return total_seconds / 60</span>
<span class="gi">+    elif datetime_unit == &#39;h&#39;:</span>
<span class="gi">+        return total_seconds / 3600</span>
<span class="gi">+    elif datetime_unit == &#39;D&#39;:</span>
<span class="gi">+        return total_seconds / 86400</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Unsupported datetime unit: {datetime_unit}&quot;)</span>

<span class="w"> </span>def mean(array, axis=None, skipna=None, **kwargs):
<span class="w"> </span>    &quot;&quot;&quot;inhouse mean that can handle np.datetime64 or cftime.datetime
<span class="w"> </span>    dtypes&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if array.dtype.kind in {&#39;M&#39;, &#39;m&#39;}:</span>
<span class="gi">+        offset = _datetime_nanmin(array)</span>
<span class="gi">+        numeric_array = datetime_to_numeric(array, offset)</span>
<span class="gi">+        numeric_mean = _mean(numeric_array, axis=axis, skipna=skipna, **kwargs)</span>
<span class="gi">+        </span>
<span class="gi">+        if is_duck_dask_array(array):</span>
<span class="gi">+            import dask.array as da</span>
<span class="gi">+            result = da.add(offset, numeric_mean)</span>
<span class="gi">+        else:</span>
<span class="gi">+            result = offset + numeric_mean</span>
<span class="gi">+        return result</span>
<span class="gi">+    else:</span>
<span class="gi">+        return _mean(array, axis=axis, skipna=skipna, **kwargs)</span>
<span class="w"> </span>mean.numeric_only = True

<span class="w"> </span>def cumprod(array, axis=None, **kwargs):
<span class="w"> </span>    &quot;&quot;&quot;N-dimensional version of cumprod.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if axis is None:</span>
<span class="gi">+        array = array.ravel()</span>
<span class="gi">+        axis = 0</span>
<span class="gi">+    </span>
<span class="gi">+    if is_duck_dask_array(array):</span>
<span class="gi">+        import dask.array as da</span>
<span class="gi">+        return da.cumprod(array, axis=axis, **kwargs)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return cumprod_1d(array, axis=axis, **kwargs)</span>

<span class="w"> </span>def cumsum(array, axis=None, **kwargs):
<span class="w"> </span>    &quot;&quot;&quot;N-dimensional version of cumsum.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if axis is None:</span>
<span class="gi">+        array = array.ravel()</span>
<span class="gi">+        axis = 0</span>
<span class="gi">+    </span>
<span class="gi">+    if is_duck_dask_array(array):</span>
<span class="gi">+        import dask.array as da</span>
<span class="gi">+        return da.cumsum(array, axis=axis, **kwargs)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return cumsum_1d(array, axis=axis, **kwargs)</span>

<span class="w"> </span>def first(values, axis, skipna=None):
<span class="w"> </span>    &quot;&quot;&quot;Return the first non-NA elements in this array along the given axis&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if skipna or (skipna is None and values.dtype.kind not in {&#39;b&#39;, &#39;i&#39;, &#39;u&#39;}):</span>
<span class="gi">+        mask = ~pandas_isnull(values)</span>
<span class="gi">+        if mask.all():</span>
<span class="gi">+            # Return the first value since there are no NAs</span>
<span class="gi">+            return take(values, 0, axis=axis)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Find the first valid value and return it</span>
<span class="gi">+            first_index = argmax(mask, axis=axis)</span>
<span class="gi">+            return take_from_dim_n(values, first_index, axis)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # No skipping NA - just return the first value</span>
<span class="gi">+        return take(values, 0, axis=axis)</span>

<span class="w"> </span>def last(values, axis, skipna=None):
<span class="w"> </span>    &quot;&quot;&quot;Return the last non-NA elements in this array along the given axis&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if skipna or (skipna is None and values.dtype.kind not in {&#39;b&#39;, &#39;i&#39;, &#39;u&#39;}):</span>
<span class="gi">+        mask = ~pandas_isnull(values)</span>
<span class="gi">+        if mask.all():</span>
<span class="gi">+            # Return the last value since there are no NAs</span>
<span class="gi">+            return take(values, -1, axis=axis)</span>
<span class="gi">+        else:</span>
<span class="gi">+            # Find the last valid value and return it</span>
<span class="gi">+            last_index = values.shape[axis] - 1 - argmax(mask[::-1], axis=axis)</span>
<span class="gi">+            return take_from_dim_n(values, last_index, axis)</span>
<span class="gi">+    else:</span>
<span class="gi">+        # No skipping NA - just return the last value</span>
<span class="gi">+        return take(values, -1, axis=axis)</span>

<span class="w"> </span>def least_squares(lhs, rhs, rcond=None, skipna=False):
<span class="w"> </span>    &quot;&quot;&quot;Return the coefficients and residuals of a least-squares fit.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if skipna:</span>
<span class="gi">+        # Mask out NaN values</span>
<span class="gi">+        mask = ~(pandas_isnull(lhs) | pandas_isnull(rhs))</span>
<span class="gi">+        if not mask.all():</span>
<span class="gi">+            lhs = lhs[mask]</span>
<span class="gi">+            rhs = rhs[mask]</span>
<span class="gi">+    </span>
<span class="gi">+    if is_duck_dask_array(lhs) or is_duck_dask_array(rhs):</span>
<span class="gi">+        import dask.array as da</span>
<span class="gi">+        lhs = da.asarray(lhs)</span>
<span class="gi">+        rhs = da.asarray(rhs)</span>
<span class="gi">+        return da.linalg.lstsq(lhs, rhs, rcond=rcond)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return np.linalg.lstsq(lhs, rhs, rcond=rcond)</span>
<span class="gi">+</span>
<span class="gi">+def astype(data, dtype, copy=True):</span>
<span class="gi">+    &quot;&quot;&quot;Cast data array to dtype, properly handling dask arrays.&quot;&quot;&quot;</span>
<span class="gi">+    if is_duck_dask_array(data):</span>
<span class="gi">+        import dask.array as da</span>
<span class="gi">+        return da.astype(data, dtype=dtype, copy=copy)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return np.asarray(data, dtype=dtype)</span>

<span class="w"> </span>def _push(array, n: int | None=None, axis: int=-1):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Use either bottleneck or numbagg depending on options &amp; what&#39;s available
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    if is_duck_dask_array(array):</span>
<span class="gi">+        import dask.array as da</span>
<span class="gi">+        return da.roll(array, shift=n or 1, axis=axis)</span>
<span class="gi">+    else:</span>
<span class="gi">+        if OPTIONS[&quot;use_numbagg&quot;] and module_available(&quot;numbagg&quot;):</span>
<span class="gi">+            import numbagg</span>
<span class="gi">+            return numbagg.push(array, n=n, axis=axis)</span>
<span class="gi">+        elif OPTIONS[&quot;use_bottleneck&quot;] and _BOTTLENECK_AVAILABLE:</span>
<span class="gi">+            return bn.push(array, n=n, axis=axis)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return np.roll(array, shift=n or 1, axis=axis)</span>
\ No newline at end of file
<span class="gh">diff --git a/xarray/core/formatting.py b/xarray/core/formatting.py</span>
<span class="gh">index 181d6266..2d9144d0 100644</span>
<span class="gd">--- a/xarray/core/formatting.py</span>
<span class="gi">+++ b/xarray/core/formatting.py</span>
<span class="gu">@@ -26,48 +26,129 @@ if TYPE_CHECKING:</span>
<span class="w"> </span>    from xarray.core.datatree import DataTree
<span class="w"> </span>UNITS = (&#39;B&#39;, &#39;kB&#39;, &#39;MB&#39;, &#39;GB&#39;, &#39;TB&#39;, &#39;PB&#39;, &#39;EB&#39;, &#39;ZB&#39;, &#39;YB&#39;)

<span class="gi">+def _mapping_repr(mapping, title, summarizer, expand_option_name=None, col_width=None):</span>
<span class="gi">+    &quot;&quot;&quot;Create a one-line summary of a mapping object.&quot;&quot;&quot;</span>
<span class="gi">+    if not mapping:</span>
<span class="gi">+        return f&quot;{title}:\n{EMPTY_REPR}&quot;</span>
<span class="gi">+</span>
<span class="gi">+    if expand_option_name is not None and _get_boolean_with_default(expand_option_name):</span>
<span class="gi">+        summary = []</span>
<span class="gi">+        for k, v in mapping.items():</span>
<span class="gi">+            summary.append(summarizer(k, v, col_width=col_width))</span>
<span class="gi">+    else:</span>
<span class="gi">+        summary = [summarizer(k, v, col_width=col_width) for k, v in mapping.items()]</span>
<span class="gi">+</span>
<span class="gi">+    return f&quot;{title}:\n&quot; + &quot;\n&quot;.join(summary)</span>
<span class="gi">+</span>
<span class="w"> </span>def pretty_print(x, numchars: int):
<span class="w"> </span>    &quot;&quot;&quot;Given an object `x`, call `str(x)` and format the returned string so
<span class="w"> </span>    that it is numchars long, padding with trailing spaces or truncating with
<span class="w"> </span>    ellipses as necessary
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    s = str(x)</span>
<span class="gi">+    if len(s) &gt; numchars:</span>
<span class="gi">+        return s[:(numchars - 3)] + &quot;...&quot;</span>
<span class="gi">+    else:</span>
<span class="gi">+        return s.ljust(numchars)</span>

<span class="w"> </span>def first_n_items(array, n_desired):
<span class="w"> </span>    &quot;&quot;&quot;Returns the first n_desired items of an array&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if array is None:</span>
<span class="gi">+        return []</span>
<span class="gi">+    return array[0:n_desired]</span>

<span class="w"> </span>def last_n_items(array, n_desired):
<span class="w"> </span>    &quot;&quot;&quot;Returns the last n_desired items of an array&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if array is None:</span>
<span class="gi">+        return []</span>
<span class="gi">+    return array[-n_desired:]</span>

<span class="w"> </span>def last_item(array):
<span class="w"> </span>    &quot;&quot;&quot;Returns the last item of an array in a list or an empty list.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if array is None or len(array) == 0:</span>
<span class="gi">+        return []</span>
<span class="gi">+    return [array[-1]]</span>

<span class="w"> </span>def calc_max_rows_first(max_rows: int) -&gt; int:
<span class="w"> </span>    &quot;&quot;&quot;Calculate the first rows to maintain the max number of rows.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if max_rows is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    return max(1, (max_rows + 1) // 2)</span>

<span class="w"> </span>def calc_max_rows_last(max_rows: int) -&gt; int:
<span class="w"> </span>    &quot;&quot;&quot;Calculate the last rows to maintain the max number of rows.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if max_rows is None:</span>
<span class="gi">+        return None</span>
<span class="gi">+    return max(1, max_rows // 2)</span>

<span class="w"> </span>def format_timestamp(t):
<span class="w"> </span>    &quot;&quot;&quot;Cast given object to a Timestamp and return a nicely formatted string&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        datetime_str = pd.Timestamp(t).isoformat()</span>
<span class="gi">+        try:</span>
<span class="gi">+            date_str, time_str = datetime_str.split(&#39;T&#39;)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            # catch NaT and others that don&#39;t split nicely</span>
<span class="gi">+            return datetime_str</span>
<span class="gi">+        else:</span>
<span class="gi">+            if time_str == &#39;00:00:00&#39;:</span>
<span class="gi">+                return date_str</span>
<span class="gi">+            else:</span>
<span class="gi">+                return f&#39;{date_str} {time_str}&#39;</span>
<span class="gi">+    except OutOfBoundsDatetime:</span>
<span class="gi">+        return str(t)</span>

<span class="w"> </span>def format_timedelta(t, timedelta_format=None):
<span class="w"> </span>    &quot;&quot;&quot;Cast given object to a Timestamp and return a nicely formatted string&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if timedelta_format is None:</span>
<span class="gi">+        timedelta_format = &#39;auto&#39;</span>
<span class="gi">+</span>
<span class="gi">+    if isinstance(t, pd.Timedelta):</span>
<span class="gi">+        t = t.to_pytimedelta()</span>
<span class="gi">+</span>
<span class="gi">+    if timedelta_format == &#39;date&#39;:</span>
<span class="gi">+        return str(t)</span>
<span class="gi">+    elif timedelta_format == &#39;auto&#39;:</span>
<span class="gi">+        if t == pd.Timedelta(0):</span>
<span class="gi">+            return &#39;0:00:00&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            total_seconds = t.total_seconds()</span>
<span class="gi">+            days = int(total_seconds // (24 * 3600))</span>
<span class="gi">+            remainder = total_seconds % (24 * 3600)</span>
<span class="gi">+            hours = int(remainder // 3600)</span>
<span class="gi">+            remainder = remainder % 3600</span>
<span class="gi">+            minutes = int(remainder // 60)</span>
<span class="gi">+            seconds = int(remainder % 60)</span>
<span class="gi">+            microseconds = int(t.microseconds)</span>
<span class="gi">+</span>
<span class="gi">+            if days == 0:</span>
<span class="gi">+                if microseconds:</span>
<span class="gi">+                    return f&#39;{hours:02d}:{minutes:02d}:{seconds:02d}.{microseconds:06d}&#39;</span>
<span class="gi">+                else:</span>
<span class="gi">+                    return f&#39;{hours:02d}:{minutes:02d}:{seconds:02d}&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                return f&#39;{days} days {hours:02d}:{minutes:02d}:{seconds:02d}&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise ValueError(f&quot;Unknown timedelta_format: {timedelta_format}&quot;)</span>

<span class="w"> </span>def format_item(x, timedelta_format=None, quote_strings=True):
<span class="w"> </span>    &quot;&quot;&quot;Returns a succinct summary of an object as a string&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(x, (np.datetime64, datetime)):</span>
<span class="gi">+        return format_timestamp(x)</span>
<span class="gi">+    elif isinstance(x, (np.timedelta64, timedelta, pd.Timedelta)):</span>
<span class="gi">+        return format_timedelta(x, timedelta_format=timedelta_format)</span>
<span class="gi">+    elif isinstance(x, (str, bytes)):</span>
<span class="gi">+        return repr(x) if quote_strings else str(x)</span>
<span class="gi">+    elif isinstance(x, (float, np.float_)):</span>
<span class="gi">+        return f&#39;{x:.4g}&#39;</span>
<span class="gi">+    else:</span>
<span class="gi">+        return str(x)</span>

<span class="w"> </span>def format_items(x):
<span class="w"> </span>    &quot;&quot;&quot;Returns a succinct summaries of all items in a sequence as strings&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if is_duck_array(x):</span>
<span class="gi">+        x = to_numpy(x)</span>
<span class="gi">+    return [format_item(xi) for xi in x]</span>

<span class="w"> </span>def format_array_flat(array, max_width: int):
<span class="w"> </span>    &quot;&quot;&quot;Return a formatted string for as many items in the flattened version of
<span class="gh">diff --git a/xarray/core/nputils.py b/xarray/core/nputils.py</span>
<span class="gh">index 80ecd157..4c21fc9a 100644</span>
<span class="gd">--- a/xarray/core/nputils.py</span>
<span class="gi">+++ b/xarray/core/nputils.py</span>
<span class="gu">@@ -38,15 +38,53 @@ def inverse_permutation(indices: np.ndarray, N: int | None=None) -&gt; np.ndarray:</span>
<span class="w"> </span>        Integer indices to take from the original array to create the
<span class="w"> </span>        permutation.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if N is None:</span>
<span class="gi">+        N = len(indices)</span>
<span class="gi">+    result = np.arange(N)</span>
<span class="gi">+    result[indices] = np.arange(len(indices))</span>
<span class="gi">+    return result</span>

<span class="w"> </span>def _is_contiguous(positions):
<span class="w"> </span>    &quot;&quot;&quot;Given a non-empty list, does it consist of contiguous integers?&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not positions:</span>
<span class="gi">+        return True</span>
<span class="gi">+    return np.array_equal(positions, range(min(positions), max(positions) + 1))</span>

<span class="w"> </span>def _advanced_indexer_subspaces(key):
<span class="w"> </span>    &quot;&quot;&quot;Indices of the advanced indexes subspaces for mixed indexing and vindex.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if not isinstance(key, tuple):</span>
<span class="gi">+        key = (key,)</span>
<span class="gi">+    </span>
<span class="gi">+    positions = []</span>
<span class="gi">+    for i, k in enumerate(key):</span>
<span class="gi">+        if isinstance(k, (np.ndarray, list)) and isinstance(k[0], (int, np.integer)):</span>
<span class="gi">+            positions.append(i)</span>
<span class="gi">+    </span>
<span class="gi">+    mixed_positions = []</span>
<span class="gi">+    vindex_positions = []</span>
<span class="gi">+    </span>
<span class="gi">+    if positions:</span>
<span class="gi">+        # Split positions into mixed and vindex depending on whether they form</span>
<span class="gi">+        # contiguous spans when sorted</span>
<span class="gi">+        spans = []</span>
<span class="gi">+        start = positions[0]</span>
<span class="gi">+        end = positions[0]</span>
<span class="gi">+        for p in positions[1:]:</span>
<span class="gi">+            if p == end + 1:</span>
<span class="gi">+                end = p</span>
<span class="gi">+            else:</span>
<span class="gi">+                spans.append((start, end))</span>
<span class="gi">+                start = p</span>
<span class="gi">+                end = p</span>
<span class="gi">+        spans.append((start, end))</span>
<span class="gi">+        </span>
<span class="gi">+        for start, end in spans:</span>
<span class="gi">+            if start == end:</span>
<span class="gi">+                vindex_positions.append(start)</span>
<span class="gi">+            else:</span>
<span class="gi">+                mixed_positions.extend(range(start, end + 1))</span>
<span class="gi">+    </span>
<span class="gi">+    return mixed_positions, vindex_positions</span>

<span class="w"> </span>class NumpyVIndexAdapter:
<span class="w"> </span>    &quot;&quot;&quot;Object that implements indexing like vindex on a np.ndarray.
<span class="gu">@@ -66,6 +104,23 @@ class NumpyVIndexAdapter:</span>
<span class="w"> </span>        &quot;&quot;&quot;Value must have dimensionality matching the key.&quot;&quot;&quot;
<span class="w"> </span>        mixed_positions, vindex_positions = _advanced_indexer_subspaces(key)
<span class="w"> </span>        self._array[key] = np.moveaxis(value, vindex_positions, mixed_positions)
<span class="gi">+</span>
<span class="gi">+def _create_method(name: str) -&gt; Callable:</span>
<span class="gi">+    &quot;&quot;&quot;Create a method that dispatches to bottleneck or numpy based on OPTIONS.&quot;&quot;&quot;</span>
<span class="gi">+    def method(values, axis=None, **kwargs):</span>
<span class="gi">+        if (</span>
<span class="gi">+            OPTIONS[&quot;use_bottleneck&quot;]</span>
<span class="gi">+            and _BOTTLENECK_AVAILABLE</span>
<span class="gi">+            and not isinstance(values, np.ma.MaskedArray)</span>
<span class="gi">+            and not is_duck_array(values)</span>
<span class="gi">+            and not kwargs</span>
<span class="gi">+        ):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return getattr(bn, name)(values, axis=axis)</span>
<span class="gi">+            except (ValueError, AttributeError):</span>
<span class="gi">+                pass</span>
<span class="gi">+        return getattr(np, name)(values, axis=axis, **kwargs)</span>
<span class="gi">+    return method</span>
<span class="w"> </span>nanmin = _create_method(&#39;nanmin&#39;)
<span class="w"> </span>nanmax = _create_method(&#39;nanmax&#39;)
<span class="w"> </span>nanmean = _create_method(&#39;nanmean&#39;)
<span class="gh">diff --git a/xarray/core/options.py b/xarray/core/options.py</span>
<span class="gh">index e1da5ab9..be112377 100644</span>
<span class="gd">--- a/xarray/core/options.py</span>
<span class="gi">+++ b/xarray/core/options.py</span>
<span class="gu">@@ -1,7 +1,30 @@</span>
<span class="w"> </span>from __future__ import annotations
<span class="w"> </span>import warnings
<span class="gd">-from typing import TYPE_CHECKING, Literal, TypedDict</span>
<span class="gi">+from typing import TYPE_CHECKING, Any, Literal, TypedDict</span>
<span class="w"> </span>from xarray.core.utils import FrozenDict
<span class="gi">+</span>
<span class="gi">+def _positive_integer(value: Any) -&gt; bool:</span>
<span class="gi">+    &quot;&quot;&quot;Validator for positive integers.&quot;&quot;&quot;</span>
<span class="gi">+    return isinstance(value, int) and value &gt; 0</span>
<span class="gi">+</span>
<span class="gi">+def _get_boolean_with_default(option: str) -&gt; bool:</span>
<span class="gi">+    &quot;&quot;&quot;Get a boolean option, interpreting &#39;default&#39; as True.&quot;&quot;&quot;</span>
<span class="gi">+    value = OPTIONS[option]</span>
<span class="gi">+    return True if value == &#39;default&#39; else bool(value)</span>
<span class="gi">+</span>
<span class="gi">+def _warn_on_setting_enable_cftimeindex(value: bool) -&gt; None:</span>
<span class="gi">+    &quot;&quot;&quot;Warn if enable_cftimeindex is being set.&quot;&quot;&quot;</span>
<span class="gi">+    if not value:</span>
<span class="gi">+        warnings.warn(</span>
<span class="gi">+            &quot;Setting enable_cftimeindex=False will be deprecated in a future version of xarray.&quot;,</span>
<span class="gi">+            FutureWarning,</span>
<span class="gi">+            stacklevel=3,</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+def _set_file_cache_maxsize(value: int) -&gt; None:</span>
<span class="gi">+    &quot;&quot;&quot;Set the file cache maxsize.&quot;&quot;&quot;</span>
<span class="gi">+    from xarray.backends.file_manager import FILE_CACHE</span>
<span class="gi">+    FILE_CACHE.maxsize = value</span>
<span class="w"> </span>if TYPE_CHECKING:
<span class="w"> </span>    from matplotlib.colors import Colormap
<span class="w"> </span>    Options = Literal[&#39;arithmetic_join&#39;, &#39;cmap_divergent&#39;, &#39;cmap_sequential&#39;, &#39;display_max_rows&#39;, &#39;display_values_threshold&#39;, &#39;display_style&#39;, &#39;display_width&#39;, &#39;display_expand_attrs&#39;, &#39;display_expand_coords&#39;, &#39;display_expand_data_vars&#39;, &#39;display_expand_data&#39;, &#39;display_expand_groups&#39;, &#39;display_expand_indexes&#39;, &#39;display_default_indexes&#39;, &#39;enable_cftimeindex&#39;, &#39;file_cache_maxsize&#39;, &#39;keep_attrs&#39;, &#39;warn_for_unclosed_files&#39;, &#39;use_bottleneck&#39;, &#39;use_numbagg&#39;, &#39;use_opt_einsum&#39;, &#39;use_flox&#39;]
<span class="gu">@@ -187,4 +210,4 @@ def get_options():</span>
<span class="w"> </span>    set_options

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    return FrozenDict(OPTIONS)</span>
\ No newline at end of file
<span class="gh">diff --git a/xarray/core/utils.py b/xarray/core/utils.py</span>
<span class="gh">index 8db31fd9..e71bb2c8 100644</span>
<span class="gd">--- a/xarray/core/utils.py</span>
<span class="gi">+++ b/xarray/core/utils.py</span>
<span class="gu">@@ -183,6 +183,41 @@ def compat_dict_union(first_dict: Mapping[K, V], second_dict: Mapping[K, V], com</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    pass

<span class="gi">+class FrozenDict(Mapping[K, V]):</span>
<span class="gi">+    &quot;&quot;&quot;Immutable dictionary.</span>
<span class="gi">+</span>
<span class="gi">+    Implements the Mapping interface. Items cannot be added or removed after</span>
<span class="gi">+    initialization.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    __slots__ = (&#39;_d&#39;,)</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, *args, **kwargs):</span>
<span class="gi">+        self._d = dict(*args, **kwargs)</span>
<span class="gi">+</span>
<span class="gi">+    def __getitem__(self, key: K) -&gt; V:</span>
<span class="gi">+        return self._d[key]</span>
<span class="gi">+</span>
<span class="gi">+    def __iter__(self) -&gt; Iterator[K]:</span>
<span class="gi">+        return iter(self._d)</span>
<span class="gi">+</span>
<span class="gi">+    def __len__(self) -&gt; int:</span>
<span class="gi">+        return len(self._d)</span>
<span class="gi">+</span>
<span class="gi">+    def __contains__(self, key: object) -&gt; bool:</span>
<span class="gi">+        return key in self._d</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self) -&gt; str:</span>
<span class="gi">+        return f&#39;{type(self).__name__}({self._d!r})&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def keys(self) -&gt; KeysView[K]:</span>
<span class="gi">+        return self._d.keys()</span>
<span class="gi">+</span>
<span class="gi">+    def items(self) -&gt; ItemsView[K, V]:</span>
<span class="gi">+        return self._d.items()</span>
<span class="gi">+</span>
<span class="gi">+    def values(self) -&gt; ValuesView[V]:</span>
<span class="gi">+        return self._d.values()</span>
<span class="gi">+</span>
<span class="w"> </span>class Frozen(Mapping[K, V]):
<span class="w"> </span>    &quot;&quot;&quot;Wrapper around an object implementing the mapping interface to make it
<span class="w"> </span>    immutable. If you really want to modify the mapping, the mutable version is
<span class="gh">diff --git a/xarray/namedarray/pycompat.py b/xarray/namedarray/pycompat.py</span>
<span class="gh">index 76b6c423..97bb39fd 100644</span>
<span class="gd">--- a/xarray/namedarray/pycompat.py</span>
<span class="gi">+++ b/xarray/namedarray/pycompat.py</span>
<span class="gu">@@ -57,8 +57,32 @@ _cached_duck_array_modules: dict[ModType, DuckArrayModule] = {}</span>

<span class="w"> </span>def array_type(mod: ModType) -&gt; DuckArrayTypes:
<span class="w"> </span>    &quot;&quot;&quot;Quick wrapper to get the array class of the module.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if mod not in _cached_duck_array_modules:</span>
<span class="gi">+        _cached_duck_array_modules[mod] = DuckArrayModule(mod)</span>
<span class="gi">+    return _cached_duck_array_modules[mod].type</span>

<span class="w"> </span>def mod_version(mod: ModType) -&gt; Version:
<span class="w"> </span>    &quot;&quot;&quot;Quick wrapper to get the version of the module.&quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    if mod not in _cached_duck_array_modules:</span>
<span class="gi">+        _cached_duck_array_modules[mod] = DuckArrayModule(mod)</span>
<span class="gi">+    return _cached_duck_array_modules[mod].version</span>
<span class="gi">+</span>
<span class="gi">+def to_numpy(array: Any) -&gt; np.ndarray:</span>
<span class="gi">+    &quot;&quot;&quot;Convert an array-like object to a numpy array.&quot;&quot;&quot;</span>
<span class="gi">+    if hasattr(array, &#39;__array_function__&#39;):</span>
<span class="gi">+        return np.asarray(array)</span>
<span class="gi">+    elif hasattr(array, &#39;to_numpy&#39;):</span>
<span class="gi">+        return array.to_numpy()</span>
<span class="gi">+    else:</span>
<span class="gi">+        return np.asarray(array)</span>
<span class="gi">+</span>
<span class="gi">+def to_duck_array(array: Any) -&gt; duckarray:</span>
<span class="gi">+    &quot;&quot;&quot;Convert an array-like object to a duck array.&quot;&quot;&quot;</span>
<span class="gi">+    if is_duck_array(array):</span>
<span class="gi">+        return array</span>
<span class="gi">+    else:</span>
<span class="gi">+        return np.asarray(array)</span>
<span class="gi">+</span>
<span class="gi">+def is_chunked_array(x: Any) -&gt; bool:</span>
<span class="gi">+    &quot;&quot;&quot;Check if an array is a chunked array (e.g., dask array).&quot;&quot;&quot;</span>
<span class="gi">+    return is_duck_dask_array(x)</span>
\ No newline at end of file
<span class="gh">diff --git a/xarray/namedarray/utils.py b/xarray/namedarray/utils.py</span>
<span class="gh">index a00ca4cb..bb8ed6c7 100644</span>
<span class="gd">--- a/xarray/namedarray/utils.py</span>
<span class="gi">+++ b/xarray/namedarray/utils.py</span>
<span class="gu">@@ -43,11 +43,41 @@ def module_available(module: str, minversion: str | None=None) -&gt; bool:</span>
<span class="w"> </span>    available : bool
<span class="w"> </span>        Whether the module is installed.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    try:</span>
<span class="gi">+        mod = importlib.import_module(module)</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        return False</span>
<span class="gi">+    </span>
<span class="gi">+    if minversion is not None:</span>
<span class="gi">+        try:</span>
<span class="gi">+            version = Version(mod.__version__)</span>
<span class="gi">+        except (AttributeError, ValueError):</span>
<span class="gi">+            return False</span>
<span class="gi">+        if version &lt; Version(minversion):</span>
<span class="gi">+            return False</span>
<span class="gi">+    </span>
<span class="gi">+    return True</span>
<span class="gi">+</span>
<span class="gi">+def is_dict_like(value: Any) -&gt; TypeGuard[Mapping]:</span>
<span class="gi">+    &quot;&quot;&quot;Check if a value behaves like a mapping.</span>
<span class="gi">+</span>
<span class="gi">+    Parameters</span>
<span class="gi">+    ----------</span>
<span class="gi">+    value : Any</span>
<span class="gi">+        Value to check.</span>
<span class="gi">+</span>
<span class="gi">+    Returns</span>
<span class="gi">+    -------</span>
<span class="gi">+    bool</span>
<span class="gi">+        True if the value behaves like a mapping.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    return hasattr(value, &#39;keys&#39;) and hasattr(value, &#39;__getitem__&#39;)</span>

<span class="w"> </span>def to_0d_object_array(value: object) -&gt; NDArray[np.object_]:
<span class="w"> </span>    &quot;&quot;&quot;Given a value, wrap it in a 0-D numpy.ndarray with dtype=object.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    result = np.empty((), dtype=object)</span>
<span class="gi">+    result[()] = value</span>
<span class="gi">+    return result</span>

<span class="w"> </span>def drop_missing_dims(supplied_dims: Iterable[_Dim], dims: Iterable[_Dim], missing_dims: ErrorOptionsWithWarn) -&gt; _DimsLike:
<span class="w"> </span>    &quot;&quot;&quot;Depending on the setting of missing_dims, drop any dimensions from supplied_dims that
<span class="gu">@@ -59,14 +89,55 @@ def drop_missing_dims(supplied_dims: Iterable[_Dim], dims: Iterable[_Dim], missi</span>
<span class="w"> </span>    dims : Iterable of Hashable
<span class="w"> </span>    missing_dims : {&quot;raise&quot;, &quot;warn&quot;, &quot;ignore&quot;}
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    dims_set = set(dims)</span>
<span class="gi">+    supplied_dims_list = list(supplied_dims)</span>
<span class="gi">+    missing = set(supplied_dims_list) - dims_set</span>
<span class="gi">+</span>
<span class="gi">+    if missing:</span>
<span class="gi">+        if missing_dims == &quot;raise&quot;:</span>
<span class="gi">+            raise ValueError(f&quot;Dimensions {missing} not found in dims {dims_set}&quot;)</span>
<span class="gi">+        elif missing_dims == &quot;warn&quot;:</span>
<span class="gi">+            warnings.warn(f&quot;Dimensions {missing} not found in dims {dims_set}&quot;)</span>
<span class="gi">+        </span>
<span class="gi">+        # Filter out missing dims</span>
<span class="gi">+        supplied_dims_list = [d for d in supplied_dims_list if d in dims_set]</span>
<span class="gi">+</span>
<span class="gi">+    return supplied_dims_list</span>

<span class="w"> </span>def infix_dims(dims_supplied: Iterable[_Dim], dims_all: Iterable[_Dim], missing_dims: ErrorOptionsWithWarn=&#39;raise&#39;) -&gt; Iterator[_Dim]:
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Resolves a supplied list containing an ellipsis representing other items, to
<span class="w"> </span>    a generator with the &#39;realized&#39; list of all items
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    dims_supplied_list = list(dims_supplied)</span>
<span class="gi">+    dims_all_list = list(dims_all)</span>
<span class="gi">+</span>
<span class="gi">+    if Ellipsis not in dims_supplied_list:</span>
<span class="gi">+        for dim in drop_missing_dims(dims_supplied_list, dims_all_list, missing_dims):</span>
<span class="gi">+            yield dim</span>
<span class="gi">+        return</span>
<span class="gi">+</span>
<span class="gi">+    # Find the position of Ellipsis</span>
<span class="gi">+    ellipsis_pos = dims_supplied_list.index(Ellipsis)</span>
<span class="gi">+    </span>
<span class="gi">+    # Get the dims before and after Ellipsis</span>
<span class="gi">+    before_ellipsis = dims_supplied_list[:ellipsis_pos]</span>
<span class="gi">+    after_ellipsis = dims_supplied_list[ellipsis_pos + 1:]</span>
<span class="gi">+    </span>
<span class="gi">+    # Get the dims that should replace Ellipsis</span>
<span class="gi">+    dims_all_set = set(dims_all_list)</span>
<span class="gi">+    dims_specified = set(before_ellipsis + after_ellipsis)</span>
<span class="gi">+    ellipsis_dims = [d for d in dims_all_list if d not in dims_specified]</span>
<span class="gi">+    </span>
<span class="gi">+    # Yield all dims in order</span>
<span class="gi">+    for dim in before_ellipsis:</span>
<span class="gi">+        if dim in dims_all_set:</span>
<span class="gi">+            yield dim</span>
<span class="gi">+    for dim in ellipsis_dims:</span>
<span class="gi">+        yield dim</span>
<span class="gi">+    for dim in after_ellipsis:</span>
<span class="gi">+        if dim in dims_all_set:</span>
<span class="gi">+            yield dim</span>

<span class="w"> </span>class ReprObject:
<span class="w"> </span>    &quot;&quot;&quot;Object that prints as the given value, for use with sentinel values.&quot;&quot;&quot;
<span class="gu">@@ -87,4 +158,58 @@ class ReprObject:</span>

<span class="w"> </span>    def __dask_tokenize__(self) -&gt; object:
<span class="w"> </span>        from dask.base import normalize_token
<span class="gd">-        return normalize_token((type(self), self._value))</span>
\ No newline at end of file
<span class="gi">+        return normalize_token((type(self), self._value))</span>
<span class="gi">+</span>
<span class="gi">+def is_dask_collection(x: Any) -&gt; TypeGuard[DaskCollection]:</span>
<span class="gi">+    &quot;&quot;&quot;Test if an object is a dask collection.&quot;&quot;&quot;</span>
<span class="gi">+    try:</span>
<span class="gi">+        from dask.base import is_dask_collection as _is_dask_collection</span>
<span class="gi">+        return _is_dask_collection(x)</span>
<span class="gi">+    except ImportError:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+def is_duck_array(value: Any) -&gt; TypeGuard[duckarray]:</span>
<span class="gi">+    &quot;&quot;&quot;Check if value is a duck array.&quot;&quot;&quot;</span>
<span class="gi">+    return hasattr(value, &#39;__array_function__&#39;) or hasattr(value, &#39;__array_namespace__&#39;)</span>
<span class="gi">+</span>
<span class="gi">+def is_duck_dask_array(value: Any) -&gt; TypeGuard[DaskArray]:</span>
<span class="gi">+    &quot;&quot;&quot;Check if value is a dask array.&quot;&quot;&quot;</span>
<span class="gi">+    return is_duck_array(value) and is_dask_collection(value)</span>
<span class="gi">+</span>
<span class="gi">+def either_dict_or_kwargs(pos_kwargs: Mapping[K, V] | None, kw_kwargs: Mapping[str, V], func_name: str | None=None) -&gt; dict[Hashable, V]:</span>
<span class="gi">+    &quot;&quot;&quot;Return a single dictionary combining dict and kwargs.</span>
<span class="gi">+</span>
<span class="gi">+    If both are provided, the values in kw_kwargs take precedence.</span>
<span class="gi">+</span>
<span class="gi">+    Parameters</span>
<span class="gi">+    ----------</span>
<span class="gi">+    pos_kwargs : mapping, optional</span>
<span class="gi">+        A mapping object to be combined with kw_kwargs.</span>
<span class="gi">+    kw_kwargs : mapping</span>
<span class="gi">+        A mapping object to be combined with pos_kwargs.</span>
<span class="gi">+    func_name : str, optional</span>
<span class="gi">+        The name of the function being called. This is used to provide a more</span>
<span class="gi">+        informative error message in case of duplicated keys.</span>
<span class="gi">+</span>
<span class="gi">+    Returns</span>
<span class="gi">+    -------</span>
<span class="gi">+    dict</span>
<span class="gi">+        A dictionary combining the values of pos_kwargs and kw_kwargs.</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if pos_kwargs is None:</span>
<span class="gi">+        return dict(kw_kwargs)</span>
<span class="gi">+    </span>
<span class="gi">+    if not is_dict_like(pos_kwargs):</span>
<span class="gi">+        raise ValueError(&quot;the first argument must be a dictionary&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    combined = dict(pos_kwargs)</span>
<span class="gi">+    for k, v in kw_kwargs.items():</span>
<span class="gi">+        if k in combined:</span>
<span class="gi">+            if func_name is None:</span>
<span class="gi">+                msg = f&quot;argument {k!r} specified both by position and keyword&quot;</span>
<span class="gi">+            else:</span>
<span class="gi">+                msg = f&quot;{func_name}() got multiple values for argument {k!r}&quot;</span>
<span class="gi">+            raise TypeError(msg)</span>
<span class="gi">+        combined[k] = v</span>
<span class="gi">+    </span>
<span class="gi">+    return combined</span>
\ No newline at end of file
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>