
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis openhands commit0 openhands voluptuous - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#openhands-voluptuous" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis openhands commit0 openhands voluptuous
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#testsmdtestsmd" class="md-nav__link">
    <span class="md-ellipsis">
      tests.md::tests.md
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_extra_with_required" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_extra_with_required
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_iterate_candidates" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_iterate_candidates
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_in" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_in
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_in_unsortable_container" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_in_unsortable_container
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_not_in" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_not_in
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_not_in_unsortable_container" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_not_in_unsortable_container
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_contains" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_contains
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_remove" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_remove
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_remove_with_error" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_remove_with_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_literal" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_literal
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_email_validation" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_email_validation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_email_validation_with_none" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_email_validation_with_none
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_email_validation_with_empty_string" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_email_validation_with_empty_string
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_email_validation_without_host" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_email_validation_without_host
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_email_validation_with_bad_datajohnvoluptuouscom" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_email_validation_with_bad_data[john@voluptuous.com&gt;]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_email_validation_with_bad_datajohnvoluptuousorg" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_email_validation_with_bad_data[john!@voluptuous.org!@($*!]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_fqdn_url_validation" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_fqdn_url_validation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_fqdn_url_validation_with_bad_datawithout-domain-name" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_fqdn_url_validation_with_bad_data[without domain name]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_fqdn_url_validation_with_bad_datanone" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_fqdn_url_validation_with_bad_data[None]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_fqdn_url_validation_with_bad_dataempty-string" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_fqdn_url_validation_with_bad_data[empty string]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_fqdn_url_validation_with_bad_dataempty-host" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_fqdn_url_validation_with_bad_data[empty host]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_url_validation" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_url_validation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_url_validation_with_bad_datanone" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_url_validation_with_bad_data[None]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_url_validation_with_bad_dataempty-string" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_url_validation_with_bad_data[empty string]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_url_validation_with_bad_dataempty-host" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_url_validation_with_bad_data[empty host]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_subschema_extension" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_subschema_extension
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_repr" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_repr
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_list_validation_messages" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_list_validation_messages
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_nested_multiple_validation_errors" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_nested_multiple_validation_errors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_humanize_error" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_humanize_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_fix_157" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_fix_157
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_maybe_accepts_msg" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_maybe_accepts_msg
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_maybe_returns_default_error" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_maybe_returns_default_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_schema_empty_list" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_schema_empty_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_schema_empty_dict_key" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_schema_empty_dict_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_schema_decorator_match_with_args" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_schema_decorator_match_with_args
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_schema_decorator_unmatch_with_args" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_schema_decorator_unmatch_with_args
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_schema_decorator_match_with_kwargs" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_schema_decorator_match_with_kwargs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_schema_decorator_unmatch_with_kwargs" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_schema_decorator_unmatch_with_kwargs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_schema_decorator_match_return_with_args" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_schema_decorator_match_return_with_args
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_schema_decorator_unmatch_return_with_args" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_schema_decorator_unmatch_return_with_args
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_schema_decorator_match_return_with_kwargs" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_schema_decorator_match_return_with_kwargs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_schema_decorator_unmatch_return_with_kwargs" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_schema_decorator_unmatch_return_with_kwargs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_schema_decorator_return_only_match" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_schema_decorator_return_only_match
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_schema_decorator_return_only_unmatch" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_schema_decorator_return_only_unmatch
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_schema_decorator_partial_match_called_with_args" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_schema_decorator_partial_match_called_with_args
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_schema_decorator_partial_unmatch_called_with_args" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_schema_decorator_partial_unmatch_called_with_args
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_schema_decorator_partial_match_called_with_kwargs" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_schema_decorator_partial_match_called_with_kwargs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_schema_decorator_partial_unmatch_called_with_kwargs" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_schema_decorator_partial_unmatch_called_with_kwargs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_number_validation_with_string" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_number_validation_with_string
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_number_validation_with_invalid_precision_invalid_scale" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_number_validation_with_invalid_precision_invalid_scale
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_number_validation_with_valid_precision_scale_yield_decimal_true" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_number_validation_with_valid_precision_scale_yield_decimal_true
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_number_when_precision_scale_none_yield_decimal_true" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_number_when_precision_scale_none_yield_decimal_true
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_number_when_precision_none_n_valid_scale_case1_yield_decimal_true" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_number_when_precision_none_n_valid_scale_case1_yield_decimal_true
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_number_when_precision_none_n_valid_scale_case2_yield_decimal_true" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_number_when_precision_none_n_valid_scale_case2_yield_decimal_true
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_number_when_precision_none_n_invalid_scale_yield_decimal_true" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_number_when_precision_none_n_invalid_scale_yield_decimal_true
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_number_when_valid_precision_n_scale_none_yield_decimal_true" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_number_when_valid_precision_n_scale_none_yield_decimal_true
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_number_when_invalid_precision_n_scale_none_yield_decimal_true" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_number_when_invalid_precision_n_scale_none_yield_decimal_true
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_number_validation_with_valid_precision_scale_yield_decimal_false" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_number_validation_with_valid_precision_scale_yield_decimal_false
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_ordered_dict" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_ordered_dict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_schema_infer_list" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_schema_infer_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_schema_infer_scalar" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_schema_infer_scalar
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_isdir" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_IsDir
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_isfile" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_IsFile
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_pathexists" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_PathExists
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_someof_min_validation" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_SomeOf_min_validation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_someof_max_validation" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_SomeOf_max_validation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_self_validation" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_self_validation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_any_error_has_path" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_any_error_has_path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_all_error_has_path" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_all_error_has_path
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_path_with_string" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_path_with_string
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_path_with_list_index" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_path_with_list_index
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_path_with_tuple_index" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_path_with_tuple_index
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_path_with_integer_dict_key" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_path_with_integer_dict_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_path_with_float_dict_key" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_path_with_float_dict_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_path_with_tuple_dict_key" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_path_with_tuple_dict_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_path_with_arbitrary_hashable_dict_key" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_path_with_arbitrary_hashable_dict_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_self_any" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_self_any
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_self_all" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_self_all
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_set_of_integers" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_set_of_integers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_frozenset_of_integers" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_frozenset_of_integers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_set_of_integers_and_strings" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_set_of_integers_and_strings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_frozenset_of_integers_and_strings" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_frozenset_of_integers_and_strings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_any_required" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_any_required
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_any_required_with_subschema" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_any_required_with_subschema
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_inclusive" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_inclusive
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_inclusive_defaults" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_inclusive_defaults
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_exclusive" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_exclusive
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_any_with_discriminant" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_any_with_discriminant
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_key1" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_key1
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_key2" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_key2
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_object" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_object
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#testspytest_exception" class="md-nav__link">
    <span class="md-ellipsis">
      tests.py::test_exception
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_openhands-commit0_openhands">back to OpenHands summary</a></p>
<h1 id="openhands-voluptuous"><strong>OpenHands</strong>: voluptuous</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">94</td>
</tr>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">55</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">149</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">149</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="testsmdtestsmd">tests.md::tests.md</h3>
<details><summary> <pre>tests.md::tests.md</pre></summary><pre>
010 
011 It should show the exact index and container type, in this case a list
012 value:
013 
014     >>> try:
015     ...   schema(['one', 'two'])
016     ...   raise AssertionError('MultipleInvalid not raised')
017     ... except MultipleInvalid as e:
018     ...   exc = e
019     >>> str(exc) == 'expected a dictionary @ data[1]'
Expected:
    True
Got:
    False

/testbed/voluptuous/tests/tests.md:19: DocTestFailure
</pre>
</details>
<h3 id="testspytest_extra_with_required">tests.py::test_extra_with_required</h3>
<details><summary> <pre>tests.py::test_extra_with_required</pre></summary><pre>
def test_extra_with_required():
        """Verify that Required does not break Extra."""
        schema = Schema({Required('toaster'): str, Extra: object})
>       r = schema({'toaster': 'blue', 'another_valid_key': 'another_valid_value'})

voluptuous/tests/tests.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = []
data = {'another_valid_key': 'another_valid_value', 'toaster': 'blue'}

    def validate_dict(path, data):
        if not isinstance(data, dict):
            raise er.DictInvalid('expected a dictionary')

        out = {}
        errors = []
        seen_keys = set()

        # First validate all the required keys
        for key in required_keys:
            if key not in data:
                errors.append(er.RequiredFieldInvalid(key.msg or 'required key not provided', path + [key]))
                continue

            try:
                out[key] = self._compile(value_schema[key])(path + [key], data[key])
            except er.Invalid as e:
                errors.append(e)
            seen_keys.add(key)

        # Now validate the rest of the keys
        for key, value in data.items():
            if key in seen_keys:
                continue

            found_valid_key = False
            found_key_schema = None

            # Try to find a matching key schema
            for skey, svalue in value_schema.items():
                if skey == key:
                    found_key_schema = svalue
                    found_valid_key = True
                    break
                if isinstance(skey, type) and isinstance(key, skey):
                    found_key_schema = svalue
                    found_valid_key = True
                    key = skey(key)
                    break

            if not found_valid_key:
                if self.extra == PREVENT_EXTRA:
                    errors.append(er.Invalid('extra keys not allowed', path + [key]))
                elif self.extra == ALLOW_EXTRA:
                    out[key] = value
                continue

            try:
                out[key] = self._compile(found_key_schema)(path + [key], value)
            except er.Invalid as e:
                errors.append(e)

        if errors:
>           raise er.MultipleInvalid(errors)
E           voluptuous.error.MultipleInvalid: extra keys not allowed @ data['another_valid_key']

voluptuous/schema_builder.py:215: MultipleInvalid
</pre>
</details>
<h3 id="testspytest_iterate_candidates">tests.py::test_iterate_candidates</h3>
<details><summary> <pre>tests.py::test_iterate_candidates</pre></summary><pre>
def test_iterate_candidates():
        """Verify that the order for iterating over mapping candidates is right."""
        schema = {
            "toaster": str,
            Extra: object,
        }
        # toaster should be first.
        from voluptuous.schema_builder import _iterate_mapping_candidates

>       assert _iterate_mapping_candidates(schema)[0][0] == 'toaster'
E       AssertionError: assert <function Extra at 0x7fcf5d6d1900> == 'toaster'

voluptuous/tests/tests.py:66: AssertionError
</pre>
</details>
<h3 id="testspytest_in">tests.py::test_in</h3>
<details><summary> <pre>tests.py::test_in</pre></summary><pre>
def test_in():
        """Verify that In works."""
        schema = Schema({"color": In(frozenset(["red", "blue", "yellow"]))})
        schema({"color": "blue"})
        with pytest.raises(
            MultipleInvalid,
            match=r"value must be one of \['blue', 'red', 'yellow'\] for dictionary value @ data\['color'\]",
        ) as ctx:
>           schema({"color": "orange"})

voluptuous/tests/tests.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = [], data = {'color': 'orange'}

    def validate_dict(path, data):
        if not isinstance(data, dict):
            raise er.DictInvalid('expected a dictionary')

        out = {}
        errors = []
        seen_keys = set()

        # First validate all the required keys
        for key in required_keys:
            if key not in data:
                errors.append(er.RequiredFieldInvalid(key.msg or 'required key not provided', path + [key]))
                continue

            try:
                out[key] = self._compile(value_schema[key])(path + [key], data[key])
            except er.Invalid as e:
                errors.append(e)
            seen_keys.add(key)

        # Now validate the rest of the keys
        for key, value in data.items():
            if key in seen_keys:
                continue

            found_valid_key = False
            found_key_schema = None

            # Try to find a matching key schema
            for skey, svalue in value_schema.items():
                if skey == key:
                    found_key_schema = svalue
                    found_valid_key = True
                    break
                if isinstance(skey, type) and isinstance(key, skey):
                    found_key_schema = svalue
                    found_valid_key = True
                    key = skey(key)
                    break

            if not found_valid_key:
                if self.extra == PREVENT_EXTRA:
                    errors.append(er.Invalid('extra keys not allowed', path + [key]))
                elif self.extra == ALLOW_EXTRA:
                    out[key] = value
                continue

            try:
                out[key] = self._compile(found_key_schema)(path + [key], value)
            except er.Invalid as e:
                errors.append(e)

        if errors:
>           raise er.MultipleInvalid(errors)
E           voluptuous.error.MultipleInvalid: value must be one of ['blue', 'red', 'yellow'] @ data['color']

voluptuous/schema_builder.py:215: MultipleInvalid

During handling of the above exception, another exception occurred:

    def test_in():
        """Verify that In works."""
        schema = Schema({"color": In(frozenset(["red", "blue", "yellow"]))})
        schema({"color": "blue"})
>       with pytest.raises(
            MultipleInvalid,
            match=r"value must be one of \['blue', 'red', 'yellow'\] for dictionary value @ data\['color'\]",
        ) as ctx:
E       AssertionError: Regex pattern did not match.
E        Regex: "value must be one of \\['blue', 'red', 'yellow'\\] for dictionary value @ data\\['color'\\]"
E        Input: "value must be one of ['blue', 'red', 'yellow'] @ data['color']"

voluptuous/tests/tests.py:73: AssertionError
</pre>
</details>
<h3 id="testspytest_in_unsortable_container">tests.py::test_in_unsortable_container</h3>
<details><summary> <pre>tests.py::test_in_unsortable_container</pre></summary><pre>
def test_in_unsortable_container():
        """Verify that In works with unsortable container."""
        schema = Schema({"type": In((int, str, float))})
        schema({"type": float})
        with pytest.raises(
            MultipleInvalid,
            match=(
                r"value must be one of \[<class 'float'>, <class 'int'>, <class 'str'>\] for dictionary value "
                r"@ data\['type'\]"
            ),
        ) as ctx:
>           schema({"type": 42})

voluptuous/tests/tests.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = [], data = {'type': 42}

    def validate_dict(path, data):
        if not isinstance(data, dict):
            raise er.DictInvalid('expected a dictionary')

        out = {}
        errors = []
        seen_keys = set()

        # First validate all the required keys
        for key in required_keys:
            if key not in data:
                errors.append(er.RequiredFieldInvalid(key.msg or 'required key not provided', path + [key]))
                continue

            try:
                out[key] = self._compile(value_schema[key])(path + [key], data[key])
            except er.Invalid as e:
                errors.append(e)
            seen_keys.add(key)

        # Now validate the rest of the keys
        for key, value in data.items():
            if key in seen_keys:
                continue

            found_valid_key = False
            found_key_schema = None

            # Try to find a matching key schema
            for skey, svalue in value_schema.items():
                if skey == key:
                    found_key_schema = svalue
                    found_valid_key = True
                    break
                if isinstance(skey, type) and isinstance(key, skey):
                    found_key_schema = svalue
                    found_valid_key = True
                    key = skey(key)
                    break

            if not found_valid_key:
                if self.extra == PREVENT_EXTRA:
                    errors.append(er.Invalid('extra keys not allowed', path + [key]))
                elif self.extra == ALLOW_EXTRA:
                    out[key] = value
                continue

            try:
                out[key] = self._compile(found_key_schema)(path + [key], value)
            except er.Invalid as e:
                errors.append(e)

        if errors:
>           raise er.MultipleInvalid(errors)
E           voluptuous.error.MultipleInvalid: value must be one of [<class 'float'>, <class 'int'>, <class 'str'>] @ data['type']

voluptuous/schema_builder.py:215: MultipleInvalid

During handling of the above exception, another exception occurred:

    def test_in_unsortable_container():
        """Verify that In works with unsortable container."""
        schema = Schema({"type": In((int, str, float))})
        schema({"type": float})
>       with pytest.raises(
            MultipleInvalid,
            match=(
                r"value must be one of \[<class 'float'>, <class 'int'>, <class 'str'>\] for dictionary value "
                r"@ data\['type'\]"
            ),
        ) as ctx:
E       AssertionError: Regex pattern did not match.
E        Regex: "value must be one of \\[<class 'float'>, <class 'int'>, <class 'str'>\\] for dictionary value @ data\\['type'\\]"
E        Input: "value must be one of [<class 'float'>, <class 'int'>, <class 'str'>] @ data['type']"

voluptuous/tests/tests.py:86: AssertionError
</pre>
</details>
<h3 id="testspytest_not_in">tests.py::test_not_in</h3>
<details><summary> <pre>tests.py::test_not_in</pre></summary><pre>
def test_not_in():
        """Verify that NotIn works."""
        schema = Schema({"color": NotIn(frozenset(["red", "blue", "yellow"]))})
        schema({"color": "orange"})
        with pytest.raises(
            MultipleInvalid,
            match=(
                r"value must not be one of \['blue', 'red', 'yellow'\] for dictionary "
                r"value @ data\['color'\]"
            ),
        ) as ctx:
>           schema({"color": "blue"})

voluptuous/tests/tests.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = [], data = {'color': 'blue'}

    def validate_dict(path, data):
        if not isinstance(data, dict):
            raise er.DictInvalid('expected a dictionary')

        out = {}
        errors = []
        seen_keys = set()

        # First validate all the required keys
        for key in required_keys:
            if key not in data:
                errors.append(er.RequiredFieldInvalid(key.msg or 'required key not provided', path + [key]))
                continue

            try:
                out[key] = self._compile(value_schema[key])(path + [key], data[key])
            except er.Invalid as e:
                errors.append(e)
            seen_keys.add(key)

        # Now validate the rest of the keys
        for key, value in data.items():
            if key in seen_keys:
                continue

            found_valid_key = False
            found_key_schema = None

            # Try to find a matching key schema
            for skey, svalue in value_schema.items():
                if skey == key:
                    found_key_schema = svalue
                    found_valid_key = True
                    break
                if isinstance(skey, type) and isinstance(key, skey):
                    found_key_schema = svalue
                    found_valid_key = True
                    key = skey(key)
                    break

            if not found_valid_key:
                if self.extra == PREVENT_EXTRA:
                    errors.append(er.Invalid('extra keys not allowed', path + [key]))
                elif self.extra == ALLOW_EXTRA:
                    out[key] = value
                continue

            try:
                out[key] = self._compile(found_key_schema)(path + [key], value)
            except er.Invalid as e:
                errors.append(e)

        if errors:
>           raise er.MultipleInvalid(errors)
E           voluptuous.error.MultipleInvalid: value must not be one of ['blue', 'red', 'yellow'] @ data['color']

voluptuous/schema_builder.py:215: MultipleInvalid

During handling of the above exception, another exception occurred:

    def test_not_in():
        """Verify that NotIn works."""
        schema = Schema({"color": NotIn(frozenset(["red", "blue", "yellow"]))})
        schema({"color": "orange"})
>       with pytest.raises(
            MultipleInvalid,
            match=(
                r"value must not be one of \['blue', 'red', 'yellow'\] for dictionary "
                r"value @ data\['color'\]"
            ),
        ) as ctx:
E       AssertionError: Regex pattern did not match.
E        Regex: "value must not be one of \\['blue', 'red', 'yellow'\\] for dictionary value @ data\\['color'\\]"
E        Input: "value must not be one of ['blue', 'red', 'yellow'] @ data['color']"

voluptuous/tests/tests.py:102: AssertionError
</pre>
</details>
<h3 id="testspytest_not_in_unsortable_container">tests.py::test_not_in_unsortable_container</h3>
<details><summary> <pre>tests.py::test_not_in_unsortable_container</pre></summary><pre>
def test_not_in_unsortable_container():
        """Verify that NotIn works with unsortable container."""
        schema = Schema({"type": NotIn((int, str, float))})
        schema({"type": 42})
        with pytest.raises(
            MultipleInvalid,
            match=(
                r"value must not be one of \[<class 'float'>, <class 'int'>, "
                r"<class 'str'>\] for dictionary value @ data\['type'\]"
            ),
        ) as ctx:
>           schema({"type": str})

voluptuous/tests/tests.py:125: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = [], data = {'type': <class 'str'>}

    def validate_dict(path, data):
        if not isinstance(data, dict):
            raise er.DictInvalid('expected a dictionary')

        out = {}
        errors = []
        seen_keys = set()

        # First validate all the required keys
        for key in required_keys:
            if key not in data:
                errors.append(er.RequiredFieldInvalid(key.msg or 'required key not provided', path + [key]))
                continue

            try:
                out[key] = self._compile(value_schema[key])(path + [key], data[key])
            except er.Invalid as e:
                errors.append(e)
            seen_keys.add(key)

        # Now validate the rest of the keys
        for key, value in data.items():
            if key in seen_keys:
                continue

            found_valid_key = False
            found_key_schema = None

            # Try to find a matching key schema
            for skey, svalue in value_schema.items():
                if skey == key:
                    found_key_schema = svalue
                    found_valid_key = True
                    break
                if isinstance(skey, type) and isinstance(key, skey):
                    found_key_schema = svalue
                    found_valid_key = True
                    key = skey(key)
                    break

            if not found_valid_key:
                if self.extra == PREVENT_EXTRA:
                    errors.append(er.Invalid('extra keys not allowed', path + [key]))
                elif self.extra == ALLOW_EXTRA:
                    out[key] = value
                continue

            try:
                out[key] = self._compile(found_key_schema)(path + [key], value)
            except er.Invalid as e:
                errors.append(e)

        if errors:
>           raise er.MultipleInvalid(errors)
E           voluptuous.error.MultipleInvalid: value must not be one of [<class 'float'>, <class 'int'>, <class 'str'>] @ data['type']

voluptuous/schema_builder.py:215: MultipleInvalid

During handling of the above exception, another exception occurred:

    def test_not_in_unsortable_container():
        """Verify that NotIn works with unsortable container."""
        schema = Schema({"type": NotIn((int, str, float))})
        schema({"type": 42})
>       with pytest.raises(
            MultipleInvalid,
            match=(
                r"value must not be one of \[<class 'float'>, <class 'int'>, "
                r"<class 'str'>\] for dictionary value @ data\['type'\]"
            ),
        ) as ctx:
E       AssertionError: Regex pattern did not match.
E        Regex: "value must not be one of \\[<class 'float'>, <class 'int'>, <class 'str'>\\] for dictionary value @ data\\['type'\\]"
E        Input: "value must not be one of [<class 'float'>, <class 'int'>, <class 'str'>] @ data['type']"

voluptuous/tests/tests.py:118: AssertionError
</pre>
</details>
<h3 id="testspytest_contains">tests.py::test_contains</h3>
<details><summary> <pre>tests.py::test_contains</pre></summary><pre>
def test_contains():
        """Verify contains validation method."""
        schema = Schema({'color': Contains('red')})
        schema({'color': ['blue', 'red', 'yellow']})
        with pytest.raises(
            MultipleInvalid,
            match=r"value is not allowed for dictionary value @ data\['color'\]",
        ) as ctx:
>           schema({'color': ['blue', 'yellow']})

voluptuous/tests/tests.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = [], data = {'color': ['blue', 'yellow']}

    def validate_dict(path, data):
        if not isinstance(data, dict):
            raise er.DictInvalid('expected a dictionary')

        out = {}
        errors = []
        seen_keys = set()

        # First validate all the required keys
        for key in required_keys:
            if key not in data:
                errors.append(er.RequiredFieldInvalid(key.msg or 'required key not provided', path + [key]))
                continue

            try:
                out[key] = self._compile(value_schema[key])(path + [key], data[key])
            except er.Invalid as e:
                errors.append(e)
            seen_keys.add(key)

        # Now validate the rest of the keys
        for key, value in data.items():
            if key in seen_keys:
                continue

            found_valid_key = False
            found_key_schema = None

            # Try to find a matching key schema
            for skey, svalue in value_schema.items():
                if skey == key:
                    found_key_schema = svalue
                    found_valid_key = True
                    break
                if isinstance(skey, type) and isinstance(key, skey):
                    found_key_schema = svalue
                    found_valid_key = True
                    key = skey(key)
                    break

            if not found_valid_key:
                if self.extra == PREVENT_EXTRA:
                    errors.append(er.Invalid('extra keys not allowed', path + [key]))
                elif self.extra == ALLOW_EXTRA:
                    out[key] = value
                continue

            try:
                out[key] = self._compile(found_key_schema)(path + [key], value)
            except er.Invalid as e:
                errors.append(e)

        if errors:
>           raise er.MultipleInvalid(errors)
E           voluptuous.error.MultipleInvalid: value is not allowed @ data['color']

voluptuous/schema_builder.py:215: MultipleInvalid

During handling of the above exception, another exception occurred:

    def test_contains():
        """Verify contains validation method."""
        schema = Schema({'color': Contains('red')})
        schema({'color': ['blue', 'red', 'yellow']})
>       with pytest.raises(
            MultipleInvalid,
            match=r"value is not allowed for dictionary value @ data\['color'\]",
        ) as ctx:
E       AssertionError: Regex pattern did not match.
E        Regex: "value is not allowed for dictionary value @ data\\['color'\\]"
E        Input: "value is not allowed @ data['color']"

voluptuous/tests/tests.py:134: AssertionError
</pre>
</details>
<h3 id="testspytest_remove">tests.py::test_remove</h3>
<details><summary> <pre>tests.py::test_remove</pre></summary><pre>
def test_remove():
        """Verify that Remove works."""
        # remove dict keys
        schema = Schema({"weight": int, Remove("color"): str, Remove("amount"): int})
        out_ = schema({"weight": 10, "color": "red", "amount": 1})
>       assert "color" not in out_ and "amount" not in out_
E       AssertionError: assert ('color' not in {'amount': 1, 'color': 'red', 'weight': 10})

voluptuous/tests/tests.py:148: AssertionError
</pre>
</details>
<h3 id="testspytest_remove_with_error">tests.py::test_remove_with_error</h3>
<details><summary> <pre>tests.py::test_remove_with_error</pre></summary><pre>
def test_remove_with_error():
        def starts_with_dot(key: str) -> str:
            """Check if key starts with dot."""
            if not key.startswith("."):
                raise Invalid("Key does not start with .")
            return key

        def does_not_start_with_dot(key: str) -> str:
            """Check if key does not start with dot."""
            if key.startswith("."):
                raise Invalid("Key starts with .")
            return key

        schema = Schema(
            {
                Remove(All(str, starts_with_dot)): object,
                does_not_start_with_dot: Any(None),
            }
        )
>       out_ = schema({".remove": None, "ok": None})

voluptuous/tests/tests.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = [], data = {'.remove': None, 'ok': None}

    def validate_dict(path, data):
        if not isinstance(data, dict):
            raise er.DictInvalid('expected a dictionary')

        out = {}
        errors = []
        seen_keys = set()

        # First validate all the required keys
        for key in required_keys:
            if key not in data:
                errors.append(er.RequiredFieldInvalid(key.msg or 'required key not provided', path + [key]))
                continue

            try:
                out[key] = self._compile(value_schema[key])(path + [key], data[key])
            except er.Invalid as e:
                errors.append(e)
            seen_keys.add(key)

        # Now validate the rest of the keys
        for key, value in data.items():
            if key in seen_keys:
                continue

            found_valid_key = False
            found_key_schema = None

            # Try to find a matching key schema
            for skey, svalue in value_schema.items():
                if skey == key:
                    found_key_schema = svalue
                    found_valid_key = True
                    break
                if isinstance(skey, type) and isinstance(key, skey):
                    found_key_schema = svalue
                    found_valid_key = True
                    key = skey(key)
                    break

            if not found_valid_key:
                if self.extra == PREVENT_EXTRA:
                    errors.append(er.Invalid('extra keys not allowed', path + [key]))
                elif self.extra == ALLOW_EXTRA:
                    out[key] = value
                continue

            try:
                out[key] = self._compile(found_key_schema)(path + [key], value)
            except er.Invalid as e:
                errors.append(e)

        if errors:
>           raise er.MultipleInvalid(errors)
E           voluptuous.error.MultipleInvalid: extra keys not allowed @ data['.remove']

voluptuous/schema_builder.py:215: MultipleInvalid
</pre>
</details>
<h3 id="testspytest_literal">tests.py::test_literal</h3>
<details><summary> <pre>tests.py::test_literal</pre></summary><pre>
self = <Schema([{'a': 1}, {'b': 1}], extra=PREVENT_EXTRA, required=False) object at 0x7fcf5e257640>
data = [{'c': 1}]

    def __call__(self, data):
        """Validate data against this schema."""
        try:
>           return self._compiled([], data)

voluptuous/schema_builder.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = [], data = [{'c': 1}]

    def validate_sequence(path, data):
        if not isinstance(data, seq_type):
            raise er.SequenceTypeInvalid('expected a {}'.format(seq_type.__name__))

        # Empty sequence
        if not schema and data:
            raise er.Invalid('not a valid value')

        result = []
        for i, value in enumerate(data):
            valid = False
            for validator in schema:
                try:
                    result.append(self._compile(validator)([i] + path, value))
                    valid = True
                    break
                except er.Invalid:
                    pass
            if not valid:
>               raise er.Invalid('not a valid value for sequence item')
E               voluptuous.error.Invalid: not a valid value for sequence item

voluptuous/schema_builder.py:474: Invalid

During handling of the above exception, another exception occurred:

    def test_literal():
        """Test with Literal"""

        schema = Schema([Literal({"a": 1}), Literal({"b": 1})])
        schema([{"a": 1}])
        schema([{"b": 1}])
        schema([{"a": 1}, {"b": 1}])

        with pytest.raises(
            MultipleInvalid, match=r"\{'c': 1\} not match for \{'b': 1\} @ data\[0\]"
        ) as ctx:
>           schema([{"c": 1}])

voluptuous/tests/tests.py:218: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Schema([{'a': 1}, {'b': 1}], extra=PREVENT_EXTRA, required=False) object at 0x7fcf5e257640>
data = [{'c': 1}]

    def __call__(self, data):
        """Validate data against this schema."""
        try:
            return self._compiled([], data)
        except er.MultipleInvalid:
            raise
        except er.Invalid as e:
>           raise er.MultipleInvalid([e])
E           voluptuous.error.MultipleInvalid: not a valid value for sequence item

voluptuous/schema_builder.py:295: MultipleInvalid

During handling of the above exception, another exception occurred:

    def test_literal():
        """Test with Literal"""

        schema = Schema([Literal({"a": 1}), Literal({"b": 1})])
        schema([{"a": 1}])
        schema([{"b": 1}])
        schema([{"a": 1}, {"b": 1}])

>       with pytest.raises(
            MultipleInvalid, match=r"\{'c': 1\} not match for \{'b': 1\} @ data\[0\]"
        ) as ctx:
E       AssertionError: Regex pattern did not match.
E        Regex: "\\{'c': 1\\} not match for \\{'b': 1\\} @ data\\[0\\]"
E        Input: 'not a valid value for sequence item'

voluptuous/tests/tests.py:215: AssertionError
</pre>
</details>
<h3 id="testspytest_email_validation">tests.py::test_email_validation</h3>
<details><summary> <pre>tests.py::test_email_validation</pre></summary><pre>
def test_email_validation():
        """Test with valid email address"""
>       schema = Schema({"email": Email()})
E       TypeError: Email() missing 1 required positional argument: 'v'

voluptuous/tests/tests.py:246: TypeError
</pre>
</details>
<h3 id="testspytest_email_validation_with_none">tests.py::test_email_validation_with_none</h3>
<details><summary> <pre>tests.py::test_email_validation_with_none</pre></summary><pre>
def test_email_validation_with_none():
        """Test with invalid None email address"""
>       schema = Schema({"email": Email()})
E       TypeError: Email() missing 1 required positional argument: 'v'

voluptuous/tests/tests.py:254: TypeError
</pre>
</details>
<h3 id="testspytest_email_validation_with_empty_string">tests.py::test_email_validation_with_empty_string</h3>
<details><summary> <pre>tests.py::test_email_validation_with_empty_string</pre></summary><pre>
def test_email_validation_with_empty_string():
        """Test with empty string email address"""
>       schema = Schema({"email": Email()})
E       TypeError: Email() missing 1 required positional argument: 'v'

voluptuous/tests/tests.py:266: TypeError
</pre>
</details>
<h3 id="testspytest_email_validation_without_host">tests.py::test_email_validation_without_host</h3>
<details><summary> <pre>tests.py::test_email_validation_without_host</pre></summary><pre>
def test_email_validation_without_host():
        """Test with empty host name in email address"""
>       schema = Schema({"email": Email()})
E       TypeError: Email() missing 1 required positional argument: 'v'

voluptuous/tests/tests.py:278: TypeError
</pre>
</details>
<h3 id="testspytest_email_validation_with_bad_datajohnvoluptuouscom">tests.py::test_email_validation_with_bad_data[john@voluptuous.com&gt;]</h3>
<details><summary> <pre>tests.py::test_email_validation_with_bad_data[john@voluptuous.com>]</pre></summary><pre>
input_value = 'john@voluptuous.com>'

    @pytest.mark.parametrize(
        'input_value', ['john@voluptuous.com>', 'john!@voluptuous.org!@($*!']
    )
    def test_email_validation_with_bad_data(input_value: str):
        """Test with bad data in email address"""
>       schema = Schema({"email": Email()})
E       TypeError: Email() missing 1 required positional argument: 'v'

voluptuous/tests/tests.py:293: TypeError
</pre>
</details>
<h3 id="testspytest_email_validation_with_bad_datajohnvoluptuousorg">tests.py::test_email_validation_with_bad_data[john!@voluptuous.org!@($*!]</h3>
<details><summary> <pre>tests.py::test_email_validation_with_bad_data[john!@voluptuous.org!@($*!]</pre></summary><pre>
input_value = 'john!@voluptuous.org!@($*!'

    @pytest.mark.parametrize(
        'input_value', ['john@voluptuous.com>', 'john!@voluptuous.org!@($*!']
    )
    def test_email_validation_with_bad_data(input_value: str):
        """Test with bad data in email address"""
>       schema = Schema({"email": Email()})
E       TypeError: Email() missing 1 required positional argument: 'v'

voluptuous/tests/tests.py:293: TypeError
</pre>
</details>
<h3 id="testspytest_fqdn_url_validation">tests.py::test_fqdn_url_validation</h3>
<details><summary> <pre>tests.py::test_fqdn_url_validation</pre></summary><pre>
def test_fqdn_url_validation():
        """Test with valid fully qualified domain name URL"""
>       schema = Schema({"url": FqdnUrl()})
E       TypeError: FqdnUrl() missing 1 required positional argument: 'v'

voluptuous/tests/tests.py:305: TypeError
</pre>
</details>
<h3 id="testspytest_fqdn_url_validation_with_bad_datawithout-domain-name">tests.py::test_fqdn_url_validation_with_bad_data[without domain name]</h3>
<details><summary> <pre>tests.py::test_fqdn_url_validation_with_bad_data[without domain name]</pre></summary><pre>
input_value = 'http://localhost/'

    @pytest.mark.parametrize(
        'input_value',
        [
            pytest.param("http://localhost/", id="without domain name"),
            pytest.param(None, id="None"),
            pytest.param("", id="empty string"),
            pytest.param("http://", id="empty host"),
        ],
    )
    def test_fqdn_url_validation_with_bad_data(input_value):
>       schema = Schema({"url": FqdnUrl()})
E       TypeError: FqdnUrl() missing 1 required positional argument: 'v'

voluptuous/tests/tests.py:321: TypeError
</pre>
</details>
<h3 id="testspytest_fqdn_url_validation_with_bad_datanone">tests.py::test_fqdn_url_validation_with_bad_data[None]</h3>
<details><summary> <pre>tests.py::test_fqdn_url_validation_with_bad_data[None]</pre></summary><pre>
input_value = None

    @pytest.mark.parametrize(
        'input_value',
        [
            pytest.param("http://localhost/", id="without domain name"),
            pytest.param(None, id="None"),
            pytest.param("", id="empty string"),
            pytest.param("http://", id="empty host"),
        ],
    )
    def test_fqdn_url_validation_with_bad_data(input_value):
>       schema = Schema({"url": FqdnUrl()})
E       TypeError: FqdnUrl() missing 1 required positional argument: 'v'

voluptuous/tests/tests.py:321: TypeError
</pre>
</details>
<h3 id="testspytest_fqdn_url_validation_with_bad_dataempty-string">tests.py::test_fqdn_url_validation_with_bad_data[empty string]</h3>
<details><summary> <pre>tests.py::test_fqdn_url_validation_with_bad_data[empty string]</pre></summary><pre>
input_value = ''

    @pytest.mark.parametrize(
        'input_value',
        [
            pytest.param("http://localhost/", id="without domain name"),
            pytest.param(None, id="None"),
            pytest.param("", id="empty string"),
            pytest.param("http://", id="empty host"),
        ],
    )
    def test_fqdn_url_validation_with_bad_data(input_value):
>       schema = Schema({"url": FqdnUrl()})
E       TypeError: FqdnUrl() missing 1 required positional argument: 'v'

voluptuous/tests/tests.py:321: TypeError
</pre>
</details>
<h3 id="testspytest_fqdn_url_validation_with_bad_dataempty-host">tests.py::test_fqdn_url_validation_with_bad_data[empty host]</h3>
<details><summary> <pre>tests.py::test_fqdn_url_validation_with_bad_data[empty host]</pre></summary><pre>
input_value = 'http://'

    @pytest.mark.parametrize(
        'input_value',
        [
            pytest.param("http://localhost/", id="without domain name"),
            pytest.param(None, id="None"),
            pytest.param("", id="empty string"),
            pytest.param("http://", id="empty host"),
        ],
    )
    def test_fqdn_url_validation_with_bad_data(input_value):
>       schema = Schema({"url": FqdnUrl()})
E       TypeError: FqdnUrl() missing 1 required positional argument: 'v'

voluptuous/tests/tests.py:321: TypeError
</pre>
</details>
<h3 id="testspytest_url_validation">tests.py::test_url_validation</h3>
<details><summary> <pre>tests.py::test_url_validation</pre></summary><pre>
def test_url_validation():
        """Test with valid URL"""
>       schema = Schema({"url": Url()})
E       TypeError: Url() missing 1 required positional argument: 'v'

voluptuous/tests/tests.py:333: TypeError
</pre>
</details>
<h3 id="testspytest_url_validation_with_bad_datanone">tests.py::test_url_validation_with_bad_data[None]</h3>
<details><summary> <pre>tests.py::test_url_validation_with_bad_data[None]</pre></summary><pre>
input_value = None

    @pytest.mark.parametrize(
        'input_value',
        [
            pytest.param(None, id="None"),
            pytest.param("", id="empty string"),
            pytest.param("http://", id="empty host"),
        ],
    )
    def test_url_validation_with_bad_data(input_value):
>       schema = Schema({"url": Url()})
E       TypeError: Url() missing 1 required positional argument: 'v'

voluptuous/tests/tests.py:348: TypeError
</pre>
</details>
<h3 id="testspytest_url_validation_with_bad_dataempty-string">tests.py::test_url_validation_with_bad_data[empty string]</h3>
<details><summary> <pre>tests.py::test_url_validation_with_bad_data[empty string]</pre></summary><pre>
input_value = ''

    @pytest.mark.parametrize(
        'input_value',
        [
            pytest.param(None, id="None"),
            pytest.param("", id="empty string"),
            pytest.param("http://", id="empty host"),
        ],
    )
    def test_url_validation_with_bad_data(input_value):
>       schema = Schema({"url": Url()})
E       TypeError: Url() missing 1 required positional argument: 'v'

voluptuous/tests/tests.py:348: TypeError
</pre>
</details>
<h3 id="testspytest_url_validation_with_bad_dataempty-host">tests.py::test_url_validation_with_bad_data[empty host]</h3>
<details><summary> <pre>tests.py::test_url_validation_with_bad_data[empty host]</pre></summary><pre>
input_value = 'http://'

    @pytest.mark.parametrize(
        'input_value',
        [
            pytest.param(None, id="None"),
            pytest.param("", id="empty string"),
            pytest.param("http://", id="empty host"),
        ],
    )
    def test_url_validation_with_bad_data(input_value):
>       schema = Schema({"url": Url()})
E       TypeError: Url() missing 1 required positional argument: 'v'

voluptuous/tests/tests.py:348: TypeError
</pre>
</details>
<h3 id="testspytest_subschema_extension">tests.py::test_subschema_extension</h3>
<details><summary> <pre>tests.py::test_subschema_extension</pre></summary><pre>
def test_subschema_extension():
        """Verify that Schema.extend adds and replaces keys in a subschema"""
        base = Schema({'a': {'b': int, 'c': float}})
        extension = {'d': str, 'a': {'b': str, 'e': int}}
        extended = base.extend(extension)

        assert base.schema == {'a': {'b': int, 'c': float}}
        assert extension == {'d': str, 'a': {'b': str, 'e': int}}
>       assert extended.schema == {'a': {'b': str, 'c': float, 'e': int}, 'd': str}
E       AssertionError: assert {'a': {'b': <...<class 'str'>} == {'a': {'b': <...<class 'str'>}
E         
E         Omitting 1 identical items, use -vv to show
E         Differing items:
E         {'a': {'b': <class 'str'>, 'e': <class 'int'>}} != {'a': {'b': <class 'str'>, 'c': <class 'float'>, 'e': <class 'int'>}}
E         
E         Full diff:
E           {...
E         
E         ...Full output truncated (7 lines hidden), use '-vv' to show

voluptuous/tests/tests.py:428: AssertionError
</pre>
</details>
<h3 id="testspytest_repr">tests.py::test_repr</h3>
<details><summary> <pre>tests.py::test_repr</pre></summary><pre>
def test_repr():
        """Verify that __repr__ returns valid Python expressions"""
        match = Match('a pattern', msg='message')
        replace = Replace('you', 'I', msg='you and I')
        range_ = Range(
            min=0, max=42, min_included=False, max_included=False, msg='number not in range'
        )
        coerce_ = Coerce(int, msg="moo")
        all_ = All('10', Coerce(int), msg='all msg')
        maybe_int = Maybe(int)

        assert repr(match) == "Match('a pattern', msg='message')"
        assert repr(replace) == "Replace('you', 'I', msg='you and I')"
        assert (
            repr(range_)
            == "Range(min=0, max=42, min_included=False, max_included=False, msg='number not in range')"
        )
        assert repr(coerce_) == "Coerce(int, msg='moo')"
        assert repr(all_) == "All('10', Coerce(int, msg=None), msg='all msg')"
>       assert repr(maybe_int) == "Any(None, %s, msg=None)" % str(int)
E       assert '<function Ma...7fcf5d014310>' == "Any(None, <c...'>, msg=None)"
E         
E         - Any(None, <class 'int'>, msg=None)
E         + <function Maybe.<locals>.validate_or_none at 0x7fcf5d014310>

voluptuous/tests/tests.py:526: AssertionError
</pre>
</details>
<h3 id="testspytest_list_validation_messages">tests.py::test_list_validation_messages</h3>
<details><summary> <pre>tests.py::test_list_validation_messages</pre></summary><pre>
def test_list_validation_messages():
        """Make sure useful error messages are available"""

        def is_even(value):
            if value % 2:
                raise Invalid('%i is not even' % value)
            return value

        schema = Schema(dict(even_numbers=[All(int, is_even)]))

        with pytest.raises(
            MultipleInvalid, match=r"3 is not even @ data\['even_numbers'\]\[0\]"
        ) as ctx:
>           schema(dict(even_numbers=[3]))

voluptuous/tests/tests.py:542: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
voluptuous/schema_builder.py:210: in validate_dict
    out[key] = self._compile(found_key_schema)(path + [key], value)
voluptuous/schema_builder.py:468: in validate_sequence
    result.append(self._compile(validator)([i] + path, value))
voluptuous/validators.py:208: in _run
    return self._exec(self._compiled, data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = All(<class 'int'>, <function test_list_validation_messages.<locals>.is_even at 0x7fcf5d77f640>, msg=None)
validators = [<function _compile_scalar.<locals>.validate_instance at 0x7fcf5cedc040>, <function _compile_scalar.<locals>.validate_callable at 0x7fcf5cedd6c0>]
v = 3

    def _exec(self, validators, v):
        value = v
        errors = []
        for validator in validators:
            try:
>               value = validator(value)
E               TypeError: _compile_scalar.<locals>.validate_instance() missing 1 required positional argument: 'data'

voluptuous/validators.py:352: TypeError
</pre>
</details>
<h3 id="testspytest_nested_multiple_validation_errors">tests.py::test_nested_multiple_validation_errors</h3>
<details><summary> <pre>tests.py::test_nested_multiple_validation_errors</pre></summary><pre>
def test_nested_multiple_validation_errors():
        """Make sure useful error messages are available"""

        def is_even(value):
            if value % 2:
                raise Invalid('%i is not even' % value)
            return value

        schema = Schema(dict(even_numbers=All([All(int, is_even)], Length(min=1))))

        with pytest.raises(
            MultipleInvalid, match=r"3 is not even @ data\['even_numbers'\]\[0\]"
        ) as ctx:
>           schema(dict(even_numbers=[3]))

voluptuous/tests/tests.py:562: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
voluptuous/schema_builder.py:210: in validate_dict
    out[key] = self._compile(found_key_schema)(path + [key], value)
voluptuous/validators.py:208: in _run
    return self._exec(self._compiled, data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = All([All(<class 'int'>, <function test_nested_multiple_validation_errors.<locals>.is_even at 0x7fcf5cedc8b0>, msg=None)], Length(min=1, max=None), msg=None)
validators = [<function Schema._compile_sequence.<locals>.validate_sequence at 0x7fcf5d016560>, <function _compile_scalar.<locals>.validate_callable at 0x7fcf5d0165f0>]
v = [3]

    def _exec(self, validators, v):
        value = v
        errors = []
        for validator in validators:
            try:
>               value = validator(value)
E               TypeError: Schema._compile_sequence.<locals>.validate_sequence() missing 1 required positional argument: 'data'

voluptuous/validators.py:352: TypeError
</pre>
</details>
<h3 id="testspytest_humanize_error">tests.py::test_humanize_error</h3>
<details><summary> <pre>tests.py::test_humanize_error</pre></summary><pre>
def test_humanize_error():
        data = {'a': 'not an int', 'b': [123]}
        schema = Schema({'a': int, 'b': [str]})
        with pytest.raises(MultipleInvalid) as ctx:
            schema(data)
        assert len(ctx.value.errors) == 2
>       assert humanize_error(data, ctx.value) == (
            "expected int for dictionary value @ data['a']. Got 'not an int'\nexpected str @ data['b'][0]. Got 123"
        )

voluptuous/tests/tests.py:575: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/humanize.py:13: in humanize_error
    return '\n'.join(sorted(
voluptuous/humanize.py:14: in <genexpr>
    humanize_error(data, sub_error, max_sub_error_length)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

data = {'a': 'not an int', 'b': [123]}
validation_error = TypeInvalid("expected int for  @ data['a']")
max_sub_error_length = 500

    def humanize_error(data, validation_error: Invalid, max_sub_error_length: int=MAX_VALIDATION_ERROR_ITEM_LENGTH) -> str:
        """Provide a more helpful + complete validation error message than that provided automatically
        Invalid and MultipleInvalid do not include the offending value in error messages,
        and MultipleInvalid.__str__ only provides the first error.
        """
        if isinstance(validation_error, MultipleInvalid):
            return '\n'.join(sorted(
                humanize_error(data, sub_error, max_sub_error_length)
                for sub_error in validation_error.errors
            ))

        path = validation_error.path
        value = data

        # Walk the path to find the value
        for step in path:
            if isinstance(value, (list, tuple)):
                value = value[step]
            else:
                value = value.get(step, 'N/A')

        # Truncate value if too long
        str_value = str(value)
        if len(str_value) > max_sub_error_length:
            str_value = str_value[:max_sub_error_length] + '...'

        # Build the error message
        path_str = ' @ data[%s]' % ']['.join(repr(p) for p in path) if path else ''
        error_type = ' for ' + validation_error.error_type if validation_error.error_type else ''

        return '%s%s (got %r)%s' % (
>           validation_error.error_message,
            error_type,
            str_value,
            path_str
        )
E       AttributeError: 'TypeInvalid' object has no attribute 'error_message'. Did you mean: '_error_message'?

voluptuous/humanize.py:38: AttributeError
</pre>
</details>
<h3 id="testspytest_fix_157">tests.py::test_fix_157</h3>
<details><summary> <pre>tests.py::test_fix_157</pre></summary><pre>
def test_fix_157():
        s = Schema(All([Any('one', 'two', 'three')]), Length(min=1))
>       assert ['one'] == s(['one'])

voluptuous/tests/tests.py:582: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
voluptuous/validators.py:208: in _run
    return self._exec(self._compiled, data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = All([Any('one', 'two', 'three', msg=None)], msg=None)
validators = [<function Schema._compile_sequence.<locals>.validate_sequence at 0x7fcf5d016950>]
v = ['one']

    def _exec(self, validators, v):
        value = v
        errors = []
        for validator in validators:
            try:
>               value = validator(value)
E               TypeError: Schema._compile_sequence.<locals>.validate_sequence() missing 1 required positional argument: 'data'

voluptuous/validators.py:352: TypeError
</pre>
</details>
<h3 id="testspytest_maybe_accepts_msg">tests.py::test_maybe_accepts_msg</h3>
<details><summary> <pre>tests.py::test_maybe_accepts_msg</pre></summary><pre>
self = <Schema(<class 'int'>, extra=PREVENT_EXTRA, required=False) object at 0x7fcf5e5d8be0>
data = []

    def __call__(self, data):
        """Validate data against this schema."""
        try:
>           return self._compiled([], data)

voluptuous/schema_builder.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = [], data = []

    def validate_instance(path, data):
        if isinstance(data, schema):
            return data
        else:
            msg = 'expected {} for {}'.format(schema.__name__, _path_string(path))
>           raise er.TypeInvalid(msg)
E           voluptuous.error.TypeInvalid: expected int for

voluptuous/schema_builder.py:592: TypeInvalid

During handling of the above exception, another exception occurred:

    def test_maybe_accepts_msg():
        s = Schema(Maybe(int, msg='int or None expected'))
        with raises(MultipleInvalid, 'int or None expected'):
>           assert s([])

voluptuous/tests/tests.py:755: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
voluptuous/schema_builder.py:598: in validate_callable
    return schema(data)
voluptuous/validators.py:581: in validate_or_none
    return schema(v)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Schema(<class 'int'>, extra=PREVENT_EXTRA, required=False) object at 0x7fcf5e5d8be0>
data = []

    def __call__(self, data):
        """Validate data against this schema."""
        try:
            return self._compiled([], data)
        except er.MultipleInvalid:
            raise
        except er.Invalid as e:
>           raise er.MultipleInvalid([e])
E           voluptuous.error.MultipleInvalid: expected int for

voluptuous/schema_builder.py:295: MultipleInvalid

During handling of the above exception, another exception occurred:

    def test_maybe_accepts_msg():
        s = Schema(Maybe(int, msg='int or None expected'))
>       with raises(MultipleInvalid, 'int or None expected'):

voluptuous/tests/tests.py:754: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:153: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

exc = <class 'voluptuous.error.MultipleInvalid'>, msg = 'int or None expected'

    @contextmanager
    def raises(exc, msg=None):
        """Assert that a certain exception is raised.

        >>> with raises(Invalid):
        ...   Schema(int, required=True)('abc')
        """
        try:
            yield
        except exc as e:
            if msg is not None and str(e) != msg:
>               raise AssertionError(
                    "Expected %r but got %r" % (msg, str(e))
                )
E               AssertionError: Expected 'int or None expected' but got 'expected int for '

voluptuous/schema_builder.py:45: AssertionError
</pre>
</details>
<h3 id="testspytest_maybe_returns_default_error">tests.py::test_maybe_returns_default_error</h3>
<details><summary> <pre>tests.py::test_maybe_returns_default_error</pre></summary><pre>
self = <Schema(Range(min=1, max=2, min_included=True, max_included=True, msg=None), extra=PREVENT_EXTRA, required=False) object at 0x7fcf5ce9e290>
data = 3

    def __call__(self, data):
        """Validate data against this schema."""
        try:
>           return self._compiled([], data)

voluptuous/schema_builder.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:598: in validate_callable
    return schema(data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Range(min=1, max=2, min_included=True, max_included=True, msg=None)
v = 3

    def __call__(self, v):
        try:
            if self.min_included:
                if self.min is not None and (not v >= self.min):
                    raise RangeInvalid(self.msg or 'value must be at least %s' % self.min)
            elif self.min is not None and (not v > self.min):
                raise RangeInvalid(self.msg or 'value must be higher than %s' % self.min)
            if self.max_included:
                if self.max is not None and (not v <= self.max):
>                   raise RangeInvalid(self.msg or 'value must be at most %s' % self.max)
E                   voluptuous.error.RangeInvalid: value must be at most 2

voluptuous/validators.py:622: RangeInvalid

During handling of the above exception, another exception occurred:

    def test_maybe_returns_default_error():
        schema = Schema(Maybe(Range(1, 2)))

        # The following should be valid
        schema(None)
        schema(1)
        schema(2)

        try:
            # Should trigger a MultipleInvalid exception
>           schema(3)

voluptuous/tests/tests.py:768: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
voluptuous/schema_builder.py:598: in validate_callable
    return schema(data)
voluptuous/validators.py:581: in validate_or_none
    return schema(v)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Schema(Range(min=1, max=2, min_included=True, max_included=True, msg=None), extra=PREVENT_EXTRA, required=False) object at 0x7fcf5ce9e290>
data = 3

    def __call__(self, data):
        """Validate data against this schema."""
        try:
            return self._compiled([], data)
        except er.MultipleInvalid:
            raise
        except er.Invalid as e:
>           raise er.MultipleInvalid([e])
E           voluptuous.error.MultipleInvalid: value must be at most 2

voluptuous/schema_builder.py:295: MultipleInvalid

During handling of the above exception, another exception occurred:

    def test_maybe_returns_default_error():
        schema = Schema(Maybe(Range(1, 2)))

        # The following should be valid
        schema(None)
        schema(1)
        schema(2)

        try:
            # Should trigger a MultipleInvalid exception
            schema(3)
        except MultipleInvalid as e:
>           assert str(e) == "not a valid value"
E           AssertionError: assert 'value must be at most 2' == 'not a valid value'
E             
E             - not a valid value
E             + value must be at most 2

voluptuous/tests/tests.py:770: AssertionError
</pre>
</details>
<h3 id="testspytest_schema_empty_list">tests.py::test_schema_empty_list</h3>
<details><summary> <pre>tests.py::test_schema_empty_list</pre></summary><pre>
self = <Schema([], extra=PREVENT_EXTRA, required=False) object at 0x7fcf5e5db460>
data = [123]

    def __call__(self, data):
        """Validate data against this schema."""
        try:
>           return self._compiled([], data)

voluptuous/schema_builder.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = [], data = [123]

    def validate_sequence(path, data):
        if not isinstance(data, seq_type):
            raise er.SequenceTypeInvalid('expected a {}'.format(seq_type.__name__))

        # Empty sequence
        if not schema and data:
>           raise er.Invalid('not a valid value')
E           voluptuous.error.Invalid: not a valid value

voluptuous/schema_builder.py:461: Invalid

During handling of the above exception, another exception occurred:

    def test_schema_empty_list():
        s = Schema([])
        s([])

        try:
>           s([123])

voluptuous/tests/tests.py:780: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Schema([], extra=PREVENT_EXTRA, required=False) object at 0x7fcf5e5db460>
data = [123]

    def __call__(self, data):
        """Validate data against this schema."""
        try:
            return self._compiled([], data)
        except er.MultipleInvalid:
            raise
        except er.Invalid as e:
>           raise er.MultipleInvalid([e])
E           voluptuous.error.MultipleInvalid: not a valid value

voluptuous/schema_builder.py:295: MultipleInvalid

During handling of the above exception, another exception occurred:

    def test_schema_empty_list():
        s = Schema([])
        s([])

        try:
            s([123])
        except MultipleInvalid as e:
>           assert str(e) == "not a valid value @ data[123]"
E           AssertionError: assert 'not a valid value' == 'not a valid ...e @ data[123]'
E             
E             - not a valid value @ data[123]
E             + not a valid value

voluptuous/tests/tests.py:782: AssertionError
</pre>
</details>
<h3 id="testspytest_schema_empty_dict_key">tests.py::test_schema_empty_dict_key</h3>
<details><summary> <pre>tests.py::test_schema_empty_dict_key</pre></summary><pre>
def test_schema_empty_dict_key():
        """https://github.com/alecthomas/voluptuous/pull/434"""
        s = Schema({'var': []})
        s({'var': []})

        try:
>           s({'var': [123]})

voluptuous/tests/tests.py:819: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = [], data = {'var': [123]}

    def validate_dict(path, data):
        if not isinstance(data, dict):
            raise er.DictInvalid('expected a dictionary')

        out = {}
        errors = []
        seen_keys = set()

        # First validate all the required keys
        for key in required_keys:
            if key not in data:
                errors.append(er.RequiredFieldInvalid(key.msg or 'required key not provided', path + [key]))
                continue

            try:
                out[key] = self._compile(value_schema[key])(path + [key], data[key])
            except er.Invalid as e:
                errors.append(e)
            seen_keys.add(key)

        # Now validate the rest of the keys
        for key, value in data.items():
            if key in seen_keys:
                continue

            found_valid_key = False
            found_key_schema = None

            # Try to find a matching key schema
            for skey, svalue in value_schema.items():
                if skey == key:
                    found_key_schema = svalue
                    found_valid_key = True
                    break
                if isinstance(skey, type) and isinstance(key, skey):
                    found_key_schema = svalue
                    found_valid_key = True
                    key = skey(key)
                    break

            if not found_valid_key:
                if self.extra == PREVENT_EXTRA:
                    errors.append(er.Invalid('extra keys not allowed', path + [key]))
                elif self.extra == ALLOW_EXTRA:
                    out[key] = value
                continue

            try:
                out[key] = self._compile(found_key_schema)(path + [key], value)
            except er.Invalid as e:
                errors.append(e)

        if errors:
>           raise er.MultipleInvalid(errors)
E           voluptuous.error.MultipleInvalid: not a valid value

voluptuous/schema_builder.py:215: MultipleInvalid

During handling of the above exception, another exception occurred:

    def test_schema_empty_dict_key():
        """https://github.com/alecthomas/voluptuous/pull/434"""
        s = Schema({'var': []})
        s({'var': []})

        try:
            s({'var': [123]})
        except MultipleInvalid as e:
>           assert str(e) == "not a valid value for dictionary value @ data['var']"
E           assert 'not a valid value' == "not a valid ...@ data['var']"
E             
E             - not a valid value for dictionary value @ data['var']
E             + not a valid value

voluptuous/tests/tests.py:821: AssertionError
</pre>
</details>
<h3 id="testspytest_schema_decorator_match_with_args">tests.py::test_schema_decorator_match_with_args</h3>
<details><summary> <pre>tests.py::test_schema_decorator_match_with_args</pre></summary><pre>
def test_schema_decorator_match_with_args():
        @validate(int)
>       def fn(arg):
E       TypeError: 'NoneType' object is not callable

voluptuous/tests/tests.py:828: TypeError
</pre>
</details>
<h3 id="testspytest_schema_decorator_unmatch_with_args">tests.py::test_schema_decorator_unmatch_with_args</h3>
<details><summary> <pre>tests.py::test_schema_decorator_unmatch_with_args</pre></summary><pre>
def test_schema_decorator_unmatch_with_args():
        @validate(int)
>       def fn(arg):
E       TypeError: 'NoneType' object is not callable

voluptuous/tests/tests.py:836: TypeError
</pre>
</details>
<h3 id="testspytest_schema_decorator_match_with_kwargs">tests.py::test_schema_decorator_match_with_kwargs</h3>
<details><summary> <pre>tests.py::test_schema_decorator_match_with_kwargs</pre></summary><pre>
def test_schema_decorator_match_with_kwargs():
        @validate(arg=int)
>       def fn(arg):
E       TypeError: 'NoneType' object is not callable

voluptuous/tests/tests.py:844: TypeError
</pre>
</details>
<h3 id="testspytest_schema_decorator_unmatch_with_kwargs">tests.py::test_schema_decorator_unmatch_with_kwargs</h3>
<details><summary> <pre>tests.py::test_schema_decorator_unmatch_with_kwargs</pre></summary><pre>
def test_schema_decorator_unmatch_with_kwargs():
        @validate(arg=int)
>       def fn(arg):
E       TypeError: 'NoneType' object is not callable

voluptuous/tests/tests.py:852: TypeError
</pre>
</details>
<h3 id="testspytest_schema_decorator_match_return_with_args">tests.py::test_schema_decorator_match_return_with_args</h3>
<details><summary> <pre>tests.py::test_schema_decorator_match_return_with_args</pre></summary><pre>
def test_schema_decorator_match_return_with_args():
        @validate(int, __return__=int)
>       def fn(arg):
E       TypeError: 'NoneType' object is not callable

voluptuous/tests/tests.py:860: TypeError
</pre>
</details>
<h3 id="testspytest_schema_decorator_unmatch_return_with_args">tests.py::test_schema_decorator_unmatch_return_with_args</h3>
<details><summary> <pre>tests.py::test_schema_decorator_unmatch_return_with_args</pre></summary><pre>
def test_schema_decorator_unmatch_return_with_args():
        @validate(int, __return__=int)
>       def fn(arg):
E       TypeError: 'NoneType' object is not callable

voluptuous/tests/tests.py:868: TypeError
</pre>
</details>
<h3 id="testspytest_schema_decorator_match_return_with_kwargs">tests.py::test_schema_decorator_match_return_with_kwargs</h3>
<details><summary> <pre>tests.py::test_schema_decorator_match_return_with_kwargs</pre></summary><pre>
def test_schema_decorator_match_return_with_kwargs():
        @validate(arg=int, __return__=int)
>       def fn(arg):
E       TypeError: 'NoneType' object is not callable

voluptuous/tests/tests.py:876: TypeError
</pre>
</details>
<h3 id="testspytest_schema_decorator_unmatch_return_with_kwargs">tests.py::test_schema_decorator_unmatch_return_with_kwargs</h3>
<details><summary> <pre>tests.py::test_schema_decorator_unmatch_return_with_kwargs</pre></summary><pre>
def test_schema_decorator_unmatch_return_with_kwargs():
        @validate(arg=int, __return__=int)
>       def fn(arg):
E       TypeError: 'NoneType' object is not callable

voluptuous/tests/tests.py:884: TypeError
</pre>
</details>
<h3 id="testspytest_schema_decorator_return_only_match">tests.py::test_schema_decorator_return_only_match</h3>
<details><summary> <pre>tests.py::test_schema_decorator_return_only_match</pre></summary><pre>
def test_schema_decorator_return_only_match():
        @validate(__return__=int)
>       def fn(arg):
E       TypeError: 'NoneType' object is not callable

voluptuous/tests/tests.py:892: TypeError
</pre>
</details>
<h3 id="testspytest_schema_decorator_return_only_unmatch">tests.py::test_schema_decorator_return_only_unmatch</h3>
<details><summary> <pre>tests.py::test_schema_decorator_return_only_unmatch</pre></summary><pre>
def test_schema_decorator_return_only_unmatch():
        @validate(__return__=int)
>       def fn(arg):
E       TypeError: 'NoneType' object is not callable

voluptuous/tests/tests.py:900: TypeError
</pre>
</details>
<h3 id="testspytest_schema_decorator_partial_match_called_with_args">tests.py::test_schema_decorator_partial_match_called_with_args</h3>
<details><summary> <pre>tests.py::test_schema_decorator_partial_match_called_with_args</pre></summary><pre>
def test_schema_decorator_partial_match_called_with_args():
        @validate(arg1=int)
>       def fn(arg1, arg2):
E       TypeError: 'NoneType' object is not callable

voluptuous/tests/tests.py:908: TypeError
</pre>
</details>
<h3 id="testspytest_schema_decorator_partial_unmatch_called_with_args">tests.py::test_schema_decorator_partial_unmatch_called_with_args</h3>
<details><summary> <pre>tests.py::test_schema_decorator_partial_unmatch_called_with_args</pre></summary><pre>
def test_schema_decorator_partial_unmatch_called_with_args():
        @validate(arg1=int)
>       def fn(arg1, arg2):
E       TypeError: 'NoneType' object is not callable

voluptuous/tests/tests.py:916: TypeError
</pre>
</details>
<h3 id="testspytest_schema_decorator_partial_match_called_with_kwargs">tests.py::test_schema_decorator_partial_match_called_with_kwargs</h3>
<details><summary> <pre>tests.py::test_schema_decorator_partial_match_called_with_kwargs</pre></summary><pre>
def test_schema_decorator_partial_match_called_with_kwargs():
        @validate(arg2=int)
>       def fn(arg1, arg2):
E       TypeError: 'NoneType' object is not callable

voluptuous/tests/tests.py:924: TypeError
</pre>
</details>
<h3 id="testspytest_schema_decorator_partial_unmatch_called_with_kwargs">tests.py::test_schema_decorator_partial_unmatch_called_with_kwargs</h3>
<details><summary> <pre>tests.py::test_schema_decorator_partial_unmatch_called_with_kwargs</pre></summary><pre>
def test_schema_decorator_partial_unmatch_called_with_kwargs():
        @validate(arg2=int)
>       def fn(arg1, arg2):
E       TypeError: 'NoneType' object is not callable

voluptuous/tests/tests.py:932: TypeError
</pre>
</details>
<h3 id="testspytest_number_validation_with_string">tests.py::test_number_validation_with_string</h3>
<details><summary> <pre>tests.py::test_number_validation_with_string</pre></summary><pre>
def test_number_validation_with_string():
        """Test with Number with string"""
        schema = Schema({"number": Number(precision=6, scale=2)})
        try:
>           schema({"number": 'teststr'})

voluptuous/tests/tests.py:942: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
voluptuous/schema_builder.py:210: in validate_dict
    out[key] = self._compile(found_key_schema)(path + [key], value)
voluptuous/schema_builder.py:598: in validate_callable
    return schema(data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Number(precision=6, scale=2, msg=None), v = 'teststr'

    def __call__(self, v):
        """
        :param v: is a number enclosed with string
        :return: Decimal number
        """
>       precision, scale, decimal_num = self._get_precision_scale(v)
E       TypeError: cannot unpack non-iterable NoneType object

voluptuous/validators.py:969: TypeError
</pre>
</details>
<h3 id="testspytest_number_validation_with_invalid_precision_invalid_scale">tests.py::test_number_validation_with_invalid_precision_invalid_scale</h3>
<details><summary> <pre>tests.py::test_number_validation_with_invalid_precision_invalid_scale</pre></summary><pre>
def test_number_validation_with_invalid_precision_invalid_scale():
        """Test with Number with invalid precision and scale"""
        schema = Schema({"number": Number(precision=6, scale=2)})
        try:
>           schema({"number": '123456.712'})

voluptuous/tests/tests.py:956: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
voluptuous/schema_builder.py:210: in validate_dict
    out[key] = self._compile(found_key_schema)(path + [key], value)
voluptuous/schema_builder.py:598: in validate_callable
    return schema(data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Number(precision=6, scale=2, msg=None), v = '123456.712'

    def __call__(self, v):
        """
        :param v: is a number enclosed with string
        :return: Decimal number
        """
>       precision, scale, decimal_num = self._get_precision_scale(v)
E       TypeError: cannot unpack non-iterable NoneType object

voluptuous/validators.py:969: TypeError
</pre>
</details>
<h3 id="testspytest_number_validation_with_valid_precision_scale_yield_decimal_true">tests.py::test_number_validation_with_valid_precision_scale_yield_decimal_true</h3>
<details><summary> <pre>tests.py::test_number_validation_with_valid_precision_scale_yield_decimal_true</pre></summary><pre>
def test_number_validation_with_valid_precision_scale_yield_decimal_true():
        """Test with Number with valid precision and scale"""
        schema = Schema({"number": Number(precision=6, scale=2, yield_decimal=True)})
>       out_ = schema({"number": '1234.00'})

voluptuous/tests/tests.py:969: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
voluptuous/schema_builder.py:210: in validate_dict
    out[key] = self._compile(found_key_schema)(path + [key], value)
voluptuous/schema_builder.py:598: in validate_callable
    return schema(data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Number(precision=6, scale=2, msg=None), v = '1234.00'

    def __call__(self, v):
        """
        :param v: is a number enclosed with string
        :return: Decimal number
        """
>       precision, scale, decimal_num = self._get_precision_scale(v)
E       TypeError: cannot unpack non-iterable NoneType object

voluptuous/validators.py:969: TypeError
</pre>
</details>
<h3 id="testspytest_number_when_precision_scale_none_yield_decimal_true">tests.py::test_number_when_precision_scale_none_yield_decimal_true</h3>
<details><summary> <pre>tests.py::test_number_when_precision_scale_none_yield_decimal_true</pre></summary><pre>
def test_number_when_precision_scale_none_yield_decimal_true():
        """Test with Number with no precision and scale"""
        schema = Schema({"number": Number(yield_decimal=True)})
>       out_ = schema({"number": '12345678901234'})

voluptuous/tests/tests.py:976: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
voluptuous/schema_builder.py:210: in validate_dict
    out[key] = self._compile(found_key_schema)(path + [key], value)
voluptuous/schema_builder.py:598: in validate_callable
    return schema(data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Number(precision=None, scale=None, msg=None), v = '12345678901234'

    def __call__(self, v):
        """
        :param v: is a number enclosed with string
        :return: Decimal number
        """
>       precision, scale, decimal_num = self._get_precision_scale(v)
E       TypeError: cannot unpack non-iterable NoneType object

voluptuous/validators.py:969: TypeError
</pre>
</details>
<h3 id="testspytest_number_when_precision_none_n_valid_scale_case1_yield_decimal_true">tests.py::test_number_when_precision_none_n_valid_scale_case1_yield_decimal_true</h3>
<details><summary> <pre>tests.py::test_number_when_precision_none_n_valid_scale_case1_yield_decimal_true</pre></summary><pre>
def test_number_when_precision_none_n_valid_scale_case1_yield_decimal_true():
        """Test with Number with no precision and valid scale case 1"""
        schema = Schema({"number": Number(scale=2, yield_decimal=True)})
>       out_ = schema({"number": '123456789.34'})

voluptuous/tests/tests.py:983: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
voluptuous/schema_builder.py:210: in validate_dict
    out[key] = self._compile(found_key_schema)(path + [key], value)
voluptuous/schema_builder.py:598: in validate_callable
    return schema(data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Number(precision=None, scale=2, msg=None), v = '123456789.34'

    def __call__(self, v):
        """
        :param v: is a number enclosed with string
        :return: Decimal number
        """
>       precision, scale, decimal_num = self._get_precision_scale(v)
E       TypeError: cannot unpack non-iterable NoneType object

voluptuous/validators.py:969: TypeError
</pre>
</details>
<h3 id="testspytest_number_when_precision_none_n_valid_scale_case2_yield_decimal_true">tests.py::test_number_when_precision_none_n_valid_scale_case2_yield_decimal_true</h3>
<details><summary> <pre>tests.py::test_number_when_precision_none_n_valid_scale_case2_yield_decimal_true</pre></summary><pre>
def test_number_when_precision_none_n_valid_scale_case2_yield_decimal_true():
        """Test with Number with no precision and valid scale case 2 with zero in decimal part"""
        schema = Schema({"number": Number(scale=2, yield_decimal=True)})
>       out_ = schema({"number": '123456789012.00'})

voluptuous/tests/tests.py:990: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
voluptuous/schema_builder.py:210: in validate_dict
    out[key] = self._compile(found_key_schema)(path + [key], value)
voluptuous/schema_builder.py:598: in validate_callable
    return schema(data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Number(precision=None, scale=2, msg=None), v = '123456789012.00'

    def __call__(self, v):
        """
        :param v: is a number enclosed with string
        :return: Decimal number
        """
>       precision, scale, decimal_num = self._get_precision_scale(v)
E       TypeError: cannot unpack non-iterable NoneType object

voluptuous/validators.py:969: TypeError
</pre>
</details>
<h3 id="testspytest_number_when_precision_none_n_invalid_scale_yield_decimal_true">tests.py::test_number_when_precision_none_n_invalid_scale_yield_decimal_true</h3>
<details><summary> <pre>tests.py::test_number_when_precision_none_n_invalid_scale_yield_decimal_true</pre></summary><pre>
def test_number_when_precision_none_n_invalid_scale_yield_decimal_true():
        """Test with Number with no precision and invalid scale"""
        schema = Schema({"number": Number(scale=2, yield_decimal=True)})
        try:
>           schema({"number": '12345678901.234'})

voluptuous/tests/tests.py:998: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
voluptuous/schema_builder.py:210: in validate_dict
    out[key] = self._compile(found_key_schema)(path + [key], value)
voluptuous/schema_builder.py:598: in validate_callable
    return schema(data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Number(precision=None, scale=2, msg=None), v = '12345678901.234'

    def __call__(self, v):
        """
        :param v: is a number enclosed with string
        :return: Decimal number
        """
>       precision, scale, decimal_num = self._get_precision_scale(v)
E       TypeError: cannot unpack non-iterable NoneType object

voluptuous/validators.py:969: TypeError
</pre>
</details>
<h3 id="testspytest_number_when_valid_precision_n_scale_none_yield_decimal_true">tests.py::test_number_when_valid_precision_n_scale_none_yield_decimal_true</h3>
<details><summary> <pre>tests.py::test_number_when_valid_precision_n_scale_none_yield_decimal_true</pre></summary><pre>
def test_number_when_valid_precision_n_scale_none_yield_decimal_true():
        """Test with Number with no precision and valid scale"""
        schema = Schema({"number": Number(precision=14, yield_decimal=True)})
>       out_ = schema({"number": '1234567.8901234'})

voluptuous/tests/tests.py:1010: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
voluptuous/schema_builder.py:210: in validate_dict
    out[key] = self._compile(found_key_schema)(path + [key], value)
voluptuous/schema_builder.py:598: in validate_callable
    return schema(data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Number(precision=14, scale=None, msg=None), v = '1234567.8901234'

    def __call__(self, v):
        """
        :param v: is a number enclosed with string
        :return: Decimal number
        """
>       precision, scale, decimal_num = self._get_precision_scale(v)
E       TypeError: cannot unpack non-iterable NoneType object

voluptuous/validators.py:969: TypeError
</pre>
</details>
<h3 id="testspytest_number_when_invalid_precision_n_scale_none_yield_decimal_true">tests.py::test_number_when_invalid_precision_n_scale_none_yield_decimal_true</h3>
<details><summary> <pre>tests.py::test_number_when_invalid_precision_n_scale_none_yield_decimal_true</pre></summary><pre>
def test_number_when_invalid_precision_n_scale_none_yield_decimal_true():
        """Test with Number with no precision and invalid scale"""
        schema = Schema({"number": Number(precision=14, yield_decimal=True)})
        try:
>           schema({"number": '12345674.8901234'})

voluptuous/tests/tests.py:1018: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
voluptuous/schema_builder.py:210: in validate_dict
    out[key] = self._compile(found_key_schema)(path + [key], value)
voluptuous/schema_builder.py:598: in validate_callable
    return schema(data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Number(precision=14, scale=None, msg=None), v = '12345674.8901234'

    def __call__(self, v):
        """
        :param v: is a number enclosed with string
        :return: Decimal number
        """
>       precision, scale, decimal_num = self._get_precision_scale(v)
E       TypeError: cannot unpack non-iterable NoneType object

voluptuous/validators.py:969: TypeError
</pre>
</details>
<h3 id="testspytest_number_validation_with_valid_precision_scale_yield_decimal_false">tests.py::test_number_validation_with_valid_precision_scale_yield_decimal_false</h3>
<details><summary> <pre>tests.py::test_number_validation_with_valid_precision_scale_yield_decimal_false</pre></summary><pre>
def test_number_validation_with_valid_precision_scale_yield_decimal_false():
        """Test with Number with valid precision, scale and no yield_decimal"""
        schema = Schema({"number": Number(precision=6, scale=2, yield_decimal=False)})
>       out_ = schema({"number": '1234.00'})

voluptuous/tests/tests.py:1031: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
voluptuous/schema_builder.py:210: in validate_dict
    out[key] = self._compile(found_key_schema)(path + [key], value)
voluptuous/schema_builder.py:598: in validate_callable
    return schema(data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Number(precision=6, scale=2, msg=None), v = '1234.00'

    def __call__(self, v):
        """
        :param v: is a number enclosed with string
        :return: Decimal number
        """
>       precision, scale, decimal_num = self._get_precision_scale(v)
E       TypeError: cannot unpack non-iterable NoneType object

voluptuous/validators.py:969: TypeError
</pre>
</details>
<h3 id="testspytest_ordered_dict">tests.py::test_ordered_dict</h3>
<details><summary> <pre>tests.py::test_ordered_dict</pre></summary><pre>
def test_ordered_dict():
        if not hasattr(collections, 'OrderedDict'):
            # collections.OrderedDict was added in Python2.7; only run if present
            return
        schema = Schema({Number(): Number()})  # x, y pairs (for interpolation or something)
        data = collections.OrderedDict(
            [
                (5.0, 3.7),
                (24.0, 8.7),
                (43.0, 1.5),
                (62.0, 2.1),
                (71.5, 6.7),
                (90.5, 4.1),
                (109.0, 3.9),
            ]
        )
>       out = schema(data)

voluptuous/tests/tests.py:1080: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = []
data = OrderedDict([(5.0, 3.7), (24.0, 8.7), (43.0, 1.5), (62.0, 2.1), (71.5, 6.7), (90.5, 4.1), (109.0, 3.9)])

    def validate_dict(path, data):
        if not isinstance(data, dict):
            raise er.DictInvalid('expected a dictionary')

        out = {}
        errors = []
        seen_keys = set()

        # First validate all the required keys
        for key in required_keys:
            if key not in data:
                errors.append(er.RequiredFieldInvalid(key.msg or 'required key not provided', path + [key]))
                continue

            try:
                out[key] = self._compile(value_schema[key])(path + [key], data[key])
            except er.Invalid as e:
                errors.append(e)
            seen_keys.add(key)

        # Now validate the rest of the keys
        for key, value in data.items():
            if key in seen_keys:
                continue

            found_valid_key = False
            found_key_schema = None

            # Try to find a matching key schema
            for skey, svalue in value_schema.items():
                if skey == key:
                    found_key_schema = svalue
                    found_valid_key = True
                    break
                if isinstance(skey, type) and isinstance(key, skey):
                    found_key_schema = svalue
                    found_valid_key = True
                    key = skey(key)
                    break

            if not found_valid_key:
                if self.extra == PREVENT_EXTRA:
                    errors.append(er.Invalid('extra keys not allowed', path + [key]))
                elif self.extra == ALLOW_EXTRA:
                    out[key] = value
                continue

            try:
                out[key] = self._compile(found_key_schema)(path + [key], value)
            except er.Invalid as e:
                errors.append(e)

        if errors:
>           raise er.MultipleInvalid(errors)
E           voluptuous.error.MultipleInvalid: extra keys not allowed @ data[5.0]

voluptuous/schema_builder.py:215: MultipleInvalid
</pre>
</details>
<h3 id="testspytest_schema_infer_list">tests.py::test_schema_infer_list</h3>
<details><summary> <pre>tests.py::test_schema_infer_list</pre></summary><pre>
def test_schema_infer_list():
        schema = Schema.infer({'list': ['foo', True, 42, 3.14]})

>       assert schema == Schema({Required('list'): [str, bool, int, float]})
E       AssertionError: assert <Schema({'list': <class 'list'>}, extra=PREVENT_EXTRA, required=False) object at 0x7fcf5cf2b190> == <Schema({'list': [<class 'str'>, <class 'bool'>, <class 'int'>, <class 'float'>]}, extra=PREVENT_EXTRA, required=False) object at 0x7fcf5cf2a620>
E        +  where <Schema({'list': [<class 'str'>, <class 'bool'>, <class 'int'>, <class 'float'>]}, extra=PREVENT_EXTRA, required=False) object at 0x7fcf5cf2a620> = Schema({'list': [<class 'str'>, <class 'bool'>, <class 'int'>, <class 'float'>]})

voluptuous/tests/tests.py:1124: AssertionError
</pre>
</details>
<h3 id="testspytest_schema_infer_scalar">tests.py::test_schema_infer_scalar</h3>
<details><summary> <pre>tests.py::test_schema_infer_scalar</pre></summary><pre>
def test_schema_infer_scalar():
        assert Schema.infer('foo') == Schema(str)
        assert Schema.infer(True) == Schema(bool)
        assert Schema.infer(42) == Schema(int)
        assert Schema.infer(3.14) == Schema(float)
>       assert Schema.infer({}) == Schema(dict)
E       AssertionError: assert <Schema({}, extra=PREVENT_EXTRA, required=False) object at 0x7fcf5df3e0b0> == <Schema(<class 'dict'>, extra=PREVENT_EXTRA, required=False) object at 0x7fcf5df3cdc0>
E        +  where <Schema({}, extra=PREVENT_EXTRA, required=False) object at 0x7fcf5df3e0b0> = infer({})
E        +    where infer = Schema.infer
E        +  and   <Schema(<class 'dict'>, extra=PREVENT_EXTRA, required=False) object at 0x7fcf5df3cdc0> = Schema(dict)

voluptuous/tests/tests.py:1132: AssertionError
</pre>
</details>
<h3 id="testspytest_isdir">tests.py::test_IsDir</h3>
<details><summary> <pre>tests.py::test_IsDir</pre></summary><pre>
def test_IsDir():
>       schema = Schema(IsDir())
E       TypeError: truth.<locals>.validator() missing 1 required positional argument: 'v'

voluptuous/tests/tests.py:1200: TypeError
</pre>
</details>
<h3 id="testspytest_isfile">tests.py::test_IsFile</h3>
<details><summary> <pre>tests.py::test_IsFile</pre></summary><pre>
def test_IsFile():
>       schema = Schema(IsFile())
E       TypeError: truth.<locals>.validator() missing 1 required positional argument: 'v'

voluptuous/tests/tests.py:1206: TypeError
</pre>
</details>
<h3 id="testspytest_pathexists">tests.py::test_PathExists</h3>
<details><summary> <pre>tests.py::test_PathExists</pre></summary><pre>
def test_PathExists():
>       schema = Schema(PathExists())
E       TypeError: truth.<locals>.validator() missing 1 required positional argument: 'v'

voluptuous/tests/tests.py:1212: TypeError
</pre>
</details>
<h3 id="testspytest_someof_min_validation">tests.py::test_SomeOf_min_validation</h3>
<details><summary> <pre>tests.py::test_SomeOf_min_validation</pre></summary><pre>
def test_SomeOf_min_validation():
        validator = All(
            Length(min=8),
            SomeOf(
                min_valid=3,
                validators=[
                    Match(r'.*[A-Z]', 'no uppercase letters'),
                    Match(r'.*[a-z]', 'no lowercase letters'),
                    Match(r'.*[0-9]', 'no numbers'),
                    Match(r'.*[$@$!%*#?&^:;/<,>|{}()\-\'._+=]', 'no symbols'),
                ],
            ),
        )

>       validator('ffe532A1!')

voluptuous/tests/tests.py:1248: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/validators.py:211: in __call__
    return self._exec((Schema(val) for val in self.validators), v)
voluptuous/validators.py:352: in _exec
    value = validator(value)
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
voluptuous/validators.py:208: in _run
    return self._exec(self._compiled, data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SomeOf(min_valid=3, validators=[Match('.*[A-Z]', msg='no uppercase letters'), Match('.*[a-z]', msg='no lowercase lette...h('.*[0-9]', msg='no numbers'), Match(".*[$@$!%*#?&^:;/<,>|{}()\\-\\'._+=]", msg='no symbols')], max_valid=4, msg=None)
validators = [<function _compile_scalar.<locals>.validate_callable at 0x7fcf5d014310>, <function _compile_scalar.<locals>.validate_...<locals>.validate_callable at 0x7fcf5d0176d0>, <function _compile_scalar.<locals>.validate_callable at 0x7fcf5d017a30>]
v = 'ffe532A1!'

    def _exec(self, validators, v):
        """Execute the validators against the value."""
>       raise NotImplementedError
E       NotImplementedError

voluptuous/validators.py:218: NotImplementedError
</pre>
</details>
<h3 id="testspytest_someof_max_validation">tests.py::test_SomeOf_max_validation</h3>
<details><summary> <pre>tests.py::test_SomeOf_max_validation</pre></summary><pre>
def test_SomeOf_max_validation():
        validator = SomeOf(
            max_valid=2,
            validators=[
                Match(r'.*[A-Z]', 'no uppercase letters'),
                Match(r'.*[a-z]', 'no lowercase letters'),
                Match(r'.*[0-9]', 'no numbers'),
            ],
            msg='max validation test failed',
        )

>       validator('Aa')

voluptuous/tests/tests.py:1270: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/validators.py:211: in __call__
    return self._exec((Schema(val) for val in self.validators), v)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = SomeOf(min_valid=0, validators=[Match('.*[A-Z]', msg='no uppercase letters'), Match('.*[a-z]', msg='no lowercase letters'), Match('.*[0-9]', msg='no numbers')], max_valid=2, msg='max validation test failed')
validators = <generator object _WithSubValidators.__call__.<locals>.<genexpr> at 0x7fcf5cfa1e70>
v = 'Aa'

    def _exec(self, validators, v):
        """Execute the validators against the value."""
>       raise NotImplementedError
E       NotImplementedError

voluptuous/validators.py:218: NotImplementedError
</pre>
</details>
<h3 id="testspytest_self_validation">tests.py::test_self_validation</h3>
<details><summary> <pre>tests.py::test_self_validation</pre></summary><pre>
def test_self_validation():
        schema = Schema({"number": int, "follow": Self})
        with raises(MultipleInvalid):
            schema({"number": "abc"})

        with raises(MultipleInvalid):
            schema({"follow": {"number": '123456.712'}})

>       schema({"follow": {"number": 123456}})

voluptuous/tests/tests.py:1283: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = [], data = {'follow': {'number': 123456}}

    def validate_dict(path, data):
        if not isinstance(data, dict):
            raise er.DictInvalid('expected a dictionary')

        out = {}
        errors = []
        seen_keys = set()

        # First validate all the required keys
        for key in required_keys:
            if key not in data:
                errors.append(er.RequiredFieldInvalid(key.msg or 'required key not provided', path + [key]))
                continue

            try:
                out[key] = self._compile(value_schema[key])(path + [key], data[key])
            except er.Invalid as e:
                errors.append(e)
            seen_keys.add(key)

        # Now validate the rest of the keys
        for key, value in data.items():
            if key in seen_keys:
                continue

            found_valid_key = False
            found_key_schema = None

            # Try to find a matching key schema
            for skey, svalue in value_schema.items():
                if skey == key:
                    found_key_schema = svalue
                    found_valid_key = True
                    break
                if isinstance(skey, type) and isinstance(key, skey):
                    found_key_schema = svalue
                    found_valid_key = True
                    key = skey(key)
                    break

            if not found_valid_key:
                if self.extra == PREVENT_EXTRA:
                    errors.append(er.Invalid('extra keys not allowed', path + [key]))
                elif self.extra == ALLOW_EXTRA:
                    out[key] = value
                continue

            try:
                out[key] = self._compile(found_key_schema)(path + [key], value)
            except er.Invalid as e:
                errors.append(e)

        if errors:
>           raise er.MultipleInvalid(errors)
E           voluptuous.error.MultipleInvalid: expected Self for  @ data['follow']

voluptuous/schema_builder.py:215: MultipleInvalid
</pre>
</details>
<h3 id="testspytest_any_error_has_path">tests.py::test_any_error_has_path</h3>
<details><summary> <pre>tests.py::test_any_error_has_path</pre></summary><pre>
def test_any_error_has_path():
        """https://github.com/alecthomas/voluptuous/issues/347"""
        s = Schema({Optional('q'): int, Required('q2'): Any(int, msg='toto')})

        with pytest.raises(MultipleInvalid) as ctx:
>           s({'q': 'str', 'q2': 'tata'})

voluptuous/tests/tests.py:1292: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
voluptuous/schema_builder.py:177: in validate_dict
    out[key] = self._compile(value_schema[key])(path + [key], data[key])
voluptuous/validators.py:208: in _run
    return self._exec(self._compiled, data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Any(<class 'int'>, msg='toto')
validators = [<function _compile_scalar.<locals>.validate_instance at 0x7fcf5d015870>]
v = 'tata'

    def _exec(self, validators, v):
        errors = []
        for validator in validators:
            try:
>               return validator(v)
E               TypeError: _compile_scalar.<locals>.validate_instance() missing 1 required positional argument: 'data'

voluptuous/validators.py:249: TypeError
</pre>
</details>
<h3 id="testspytest_all_error_has_path">tests.py::test_all_error_has_path</h3>
<details><summary> <pre>tests.py::test_all_error_has_path</pre></summary><pre>
def test_all_error_has_path():
        """https://github.com/alecthomas/voluptuous/issues/347"""
        s = Schema(
            {
                Optional('q'): int,
                Required('q2'): All([str, Length(min=10)], msg='toto'),
            }
        )
        with pytest.raises(MultipleInvalid) as ctx:
>           s({'q': 'str', 'q2': 12})

voluptuous/tests/tests.py:1308: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
voluptuous/schema_builder.py:177: in validate_dict
    out[key] = self._compile(value_schema[key])(path + [key], data[key])
voluptuous/validators.py:208: in _run
    return self._exec(self._compiled, data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = All([<class 'str'>, Length(min=10, max=None)], msg='toto')
validators = [<function Schema._compile_sequence.<locals>.validate_sequence at 0x7fcf5d017a30>]
v = 12

    def _exec(self, validators, v):
        value = v
        errors = []
        for validator in validators:
            try:
>               value = validator(value)
E               TypeError: Schema._compile_sequence.<locals>.validate_sequence() missing 1 required positional argument: 'data'

voluptuous/validators.py:352: TypeError
</pre>
</details>
<h3 id="testspytest_path_with_string">tests.py::test_path_with_string</h3>
<details><summary> <pre>tests.py::test_path_with_string</pre></summary><pre>
def test_path_with_string():
        """Most common dict use with strings as keys"""
        s = Schema({'string_key': int})

        with pytest.raises(MultipleInvalid) as ctx:
            s({'string_key': 'str'})
>       assert ctx.value.errors[0].path == ['string_key']
E       AssertionError: assert [] == ['string_key']
E         
E         Right contains one more item: 'string_key'
E         
E         Full diff:
E         + []
E         - [
E         -     'string_key',
E         - ]

voluptuous/tests/tests.py:1343: AssertionError
</pre>
</details>
<h3 id="testspytest_path_with_list_index">tests.py::test_path_with_list_index</h3>
<details><summary> <pre>tests.py::test_path_with_list_index</pre></summary><pre>
def test_path_with_list_index():
        """Position of the offending list index included in path as int"""
        s = Schema({'string_key': [int]})

        with pytest.raises(MultipleInvalid) as ctx:
            s({'string_key': [123, 'should be int']})
>       assert ctx.value.errors[0].path == ['string_key', 1]
E       AssertionError: assert [] == ['string_key', 1]
E         
E         Right contains 2 more items, first extra item: 'string_key'
E         
E         Full diff:
E         + []
E         - [
E         -     'string_key',
E         -     1,
E         - ]

voluptuous/tests/tests.py:1352: AssertionError
</pre>
</details>
<h3 id="testspytest_path_with_tuple_index">tests.py::test_path_with_tuple_index</h3>
<details><summary> <pre>tests.py::test_path_with_tuple_index</pre></summary><pre>
def test_path_with_tuple_index():
        """Position of the offending tuple index included in path as int"""
        s = Schema({'string_key': (int,)})

        with pytest.raises(MultipleInvalid) as ctx:
            s({'string_key': (123, 'should be int')})
>       assert ctx.value.errors[0].path == ['string_key', 1]
E       AssertionError: assert [] == ['string_key', 1]
E         
E         Right contains 2 more items, first extra item: 'string_key'
E         
E         Full diff:
E         + []
E         - [
E         -     'string_key',
E         -     1,
E         - ]

voluptuous/tests/tests.py:1361: AssertionError
</pre>
</details>
<h3 id="testspytest_path_with_integer_dict_key">tests.py::test_path_with_integer_dict_key</h3>
<details><summary> <pre>tests.py::test_path_with_integer_dict_key</pre></summary><pre>
def test_path_with_integer_dict_key():
        """Not obvious case with dict having not strings, but integers as keys"""
        s = Schema({1337: int})

        with pytest.raises(MultipleInvalid) as ctx:
            s({1337: 'should be int'})
>       assert ctx.value.errors[0].path == [1337]
E       assert [] == [1337]
E         
E         Right contains one more item: 1337
E         
E         Full diff:
E         + []
E         - [
E         -     1337,
E         - ]

voluptuous/tests/tests.py:1370: AssertionError
</pre>
</details>
<h3 id="testspytest_path_with_float_dict_key">tests.py::test_path_with_float_dict_key</h3>
<details><summary> <pre>tests.py::test_path_with_float_dict_key</pre></summary><pre>
def test_path_with_float_dict_key():
        """Not obvious case with dict having not strings, but floats as keys"""
        s = Schema({13.37: int})

        with pytest.raises(MultipleInvalid) as ctx:
            s({13.37: 'should be int'})
>       assert ctx.value.errors[0].path == [13.37]
E       assert [] == [13.37]
E         
E         Right contains one more item: 13.37
E         
E         Full diff:
E         + []
E         - [
E         -     13.37,
E         - ]

voluptuous/tests/tests.py:1379: AssertionError
</pre>
</details>
<h3 id="testspytest_path_with_tuple_dict_key">tests.py::test_path_with_tuple_dict_key</h3>
<details><summary> <pre>tests.py::test_path_with_tuple_dict_key</pre></summary><pre>
def test_path_with_tuple_dict_key():
        """Not obvious case with dict having not strings, but tuples as keys"""
        s = Schema({('fancy', 'key'): int})

        with pytest.raises(MultipleInvalid) as ctx:
            s({('fancy', 'key'): 'should be int'})
>       assert ctx.value.errors[0].path == [('fancy', 'key')]
E       AssertionError: assert [] == [('fancy', 'key')]
E         
E         Right contains one more item: ('fancy', 'key')
E         
E         Full diff:
E         + []
E         - [
E         -     (...
E         
E         ...Full output truncated (4 lines hidden), use '-vv' to show

voluptuous/tests/tests.py:1388: AssertionError
</pre>
</details>
<h3 id="testspytest_path_with_arbitrary_hashable_dict_key">tests.py::test_path_with_arbitrary_hashable_dict_key</h3>
<details><summary> <pre>tests.py::test_path_with_arbitrary_hashable_dict_key</pre></summary><pre>
def test_path_with_arbitrary_hashable_dict_key():
        """Not obvious case with dict having not strings, but arbitrary hashable objects as keys"""

        class HashableObjectWhichWillBeKeyInDict:
            def __hash__(self):
                return 1337  # dummy hash, used only for illustration

        s = Schema({HashableObjectWhichWillBeKeyInDict: [int]})

        hashable_obj_provided_in_input = HashableObjectWhichWillBeKeyInDict()

        with pytest.raises(MultipleInvalid) as ctx:
>           s({hashable_obj_provided_in_input: [0, 1, 'should be int']})

voluptuous/tests/tests.py:1403: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = []
data = {<voluptuous.tests.tests.test_path_with_arbitrary_hashable_dict_key.<locals>.HashableObjectWhichWillBeKeyInDict object at 0x7fcf5d6060e0>: [0, 1, 'should be int']}

    def validate_dict(path, data):
        if not isinstance(data, dict):
            raise er.DictInvalid('expected a dictionary')

        out = {}
        errors = []
        seen_keys = set()

        # First validate all the required keys
        for key in required_keys:
            if key not in data:
                errors.append(er.RequiredFieldInvalid(key.msg or 'required key not provided', path + [key]))
                continue

            try:
                out[key] = self._compile(value_schema[key])(path + [key], data[key])
            except er.Invalid as e:
                errors.append(e)
            seen_keys.add(key)

        # Now validate the rest of the keys
        for key, value in data.items():
            if key in seen_keys:
                continue

            found_valid_key = False
            found_key_schema = None

            # Try to find a matching key schema
            for skey, svalue in value_schema.items():
                if skey == key:
                    found_key_schema = svalue
                    found_valid_key = True
                    break
                if isinstance(skey, type) and isinstance(key, skey):
                    found_key_schema = svalue
                    found_valid_key = True
>                   key = skey(key)
E                   TypeError: HashableObjectWhichWillBeKeyInDict() takes no arguments

voluptuous/schema_builder.py:199: TypeError
</pre>
</details>
<h3 id="testspytest_self_any">tests.py::test_self_any</h3>
<details><summary> <pre>tests.py::test_self_any</pre></summary><pre>
def test_self_any():
        schema = Schema({"number": int, "follow": Any(Self, "stop")})
        with pytest.raises(MultipleInvalid) as ctx:
            schema({"number": "abc"})
        assert len(ctx.value.errors) == 1
        assert isinstance(ctx.value.errors[0], TypeInvalid)

        with raises(MultipleInvalid):
>           schema({"follow": {"number": '123456.712'}})

voluptuous/tests/tests.py:1415: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
voluptuous/schema_builder.py:210: in validate_dict
    out[key] = self._compile(found_key_schema)(path + [key], value)
voluptuous/validators.py:208: in _run
    return self._exec(self._compiled, data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Any(<class 'voluptuous.schema_builder.Self'>, 'stop', msg=None)
validators = [<function _compile_scalar.<locals>.validate_instance at 0x7fcf5d016680>, <function _compile_scalar.<locals>.validate_value at 0x7fcf5d017eb0>]
v = {'number': '123456.712'}

    def _exec(self, validators, v):
        errors = []
        for validator in validators:
            try:
>               return validator(v)
E               TypeError: _compile_scalar.<locals>.validate_instance() missing 1 required positional argument: 'data'

voluptuous/validators.py:249: TypeError
</pre>
</details>
<h3 id="testspytest_self_all">tests.py::test_self_all</h3>
<details><summary> <pre>tests.py::test_self_all</pre></summary><pre>
def test_self_all():
        schema = Schema(
            {
                "number": int,
                "follow": All(Self, Schema({"extra_number": int}, extra=ALLOW_EXTRA)),
            },
            extra=ALLOW_EXTRA,
        )
        with pytest.raises(MultipleInvalid) as ctx:
            schema({"number": "abc"})
        assert len(ctx.value.errors) == 1
        assert isinstance(ctx.value.errors[0], TypeInvalid)

        with pytest.raises(MultipleInvalid) as ctx:
>           schema({"follow": {"number": '123456.712'}})

voluptuous/tests/tests.py:1436: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
voluptuous/schema_builder.py:210: in validate_dict
    out[key] = self._compile(found_key_schema)(path + [key], value)
voluptuous/validators.py:208: in _run
    return self._exec(self._compiled, data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = All(<class 'voluptuous.schema_builder.Self'>, <Schema({'extra_number': <class 'int'>}, extra=ALLOW_EXTRA, required=False) object at 0x7fcf5e5a8430>, msg=None)
validators = [<function _compile_scalar.<locals>.validate_instance at 0x7fcf5d017a30>, <function _compile_scalar.<locals>.validate_callable at 0x7fcf5d017370>]
v = {'number': '123456.712'}

    def _exec(self, validators, v):
        value = v
        errors = []
        for validator in validators:
            try:
>               value = validator(value)
E               TypeError: _compile_scalar.<locals>.validate_instance() missing 1 required positional argument: 'data'

voluptuous/validators.py:352: TypeError
</pre>
</details>
<h3 id="testspytest_set_of_integers">tests.py::test_set_of_integers</h3>
<details><summary> <pre>tests.py::test_set_of_integers</pre></summary><pre>
self = <Schema({<class 'int'>}, extra=PREVENT_EXTRA, required=False) object at 0x7fcf5d1bee00>
data = {'abc'}

    def __call__(self, data):
        """Validate data against this schema."""
        try:
>           return self._compiled([], data)

voluptuous/schema_builder.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = [], data = {'abc'}

    def validate_sequence(path, data):
        if not isinstance(data, seq_type):
            raise er.SequenceTypeInvalid('expected a {}'.format(seq_type.__name__))

        # Empty sequence
        if not schema and data:
            raise er.Invalid('not a valid value')

        result = []
        for i, value in enumerate(data):
            valid = False
            for validator in schema:
                try:
                    result.append(self._compile(validator)([i] + path, value))
                    valid = True
                    break
                except er.Invalid:
                    pass
            if not valid:
>               raise er.Invalid('not a valid value for sequence item')
E               voluptuous.error.Invalid: not a valid value for sequence item

voluptuous/schema_builder.py:474: Invalid

During handling of the above exception, another exception occurred:

    def test_set_of_integers():
        schema = Schema({int})
        with raises(Invalid, 'expected a set'):
            schema(42)
        with raises(Invalid, 'expected a set'):
            schema(frozenset([42]))

        schema(set())
        schema(set([42]))
        schema(set([42, 43, 44]))
        with pytest.raises(MultipleInvalid, match="invalid value in set") as ctx:
>           schema(set(['abc']))

voluptuous/tests/tests.py:1473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Schema({<class 'int'>}, extra=PREVENT_EXTRA, required=False) object at 0x7fcf5d1bee00>
data = {'abc'}

    def __call__(self, data):
        """Validate data against this schema."""
        try:
            return self._compiled([], data)
        except er.MultipleInvalid:
            raise
        except er.Invalid as e:
>           raise er.MultipleInvalid([e])
E           voluptuous.error.MultipleInvalid: not a valid value for sequence item

voluptuous/schema_builder.py:295: MultipleInvalid

During handling of the above exception, another exception occurred:

    def test_set_of_integers():
        schema = Schema({int})
        with raises(Invalid, 'expected a set'):
            schema(42)
        with raises(Invalid, 'expected a set'):
            schema(frozenset([42]))

        schema(set())
        schema(set([42]))
        schema(set([42, 43, 44]))
>       with pytest.raises(MultipleInvalid, match="invalid value in set") as ctx:
E       AssertionError: Regex pattern did not match.
E        Regex: 'invalid value in set'
E        Input: 'not a valid value for sequence item'

voluptuous/tests/tests.py:1472: AssertionError
</pre>
</details>
<h3 id="testspytest_frozenset_of_integers">tests.py::test_frozenset_of_integers</h3>
<details><summary> <pre>tests.py::test_frozenset_of_integers</pre></summary><pre>
self = <Schema(frozenset({<class 'int'>}), extra=PREVENT_EXTRA, required=False) object at 0x7fcf5e347970>
data = 42

    def __call__(self, data):
        """Validate data against this schema."""
        try:
>           return self._compiled([], data)

voluptuous/schema_builder.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = [], data = 42

    def validate_value(path, data):
        if data != schema:
>           raise er.ScalarInvalid('not a valid value')
E           voluptuous.error.ScalarInvalid: not a valid value

voluptuous/schema_builder.py:608: ScalarInvalid

During handling of the above exception, another exception occurred:

    def test_frozenset_of_integers():
        schema = Schema(frozenset([int]))
        with raises(Invalid, 'expected a frozenset'):
>           schema(42)

voluptuous/tests/tests.py:1480: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Schema(frozenset({<class 'int'>}), extra=PREVENT_EXTRA, required=False) object at 0x7fcf5e347970>
data = 42

    def __call__(self, data):
        """Validate data against this schema."""
        try:
            return self._compiled([], data)
        except er.MultipleInvalid:
            raise
        except er.Invalid as e:
>           raise er.MultipleInvalid([e])
E           voluptuous.error.MultipleInvalid: not a valid value

voluptuous/schema_builder.py:295: MultipleInvalid

During handling of the above exception, another exception occurred:

    def test_frozenset_of_integers():
        schema = Schema(frozenset([int]))
>       with raises(Invalid, 'expected a frozenset'):

voluptuous/tests/tests.py:1479: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:153: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

exc = <class 'voluptuous.error.Invalid'>, msg = 'expected a frozenset'

    @contextmanager
    def raises(exc, msg=None):
        """Assert that a certain exception is raised.

        >>> with raises(Invalid):
        ...   Schema(int, required=True)('abc')
        """
        try:
            yield
        except exc as e:
            if msg is not None and str(e) != msg:
>               raise AssertionError(
                    "Expected %r but got %r" % (msg, str(e))
                )
E               AssertionError: Expected 'expected a frozenset' but got 'not a valid value'

voluptuous/schema_builder.py:45: AssertionError
</pre>
</details>
<h3 id="testspytest_set_of_integers_and_strings">tests.py::test_set_of_integers_and_strings</h3>
<details><summary> <pre>tests.py::test_set_of_integers_and_strings</pre></summary><pre>
self = <Schema({<class 'int'>, <class 'str'>}, extra=PREVENT_EXTRA, required=False) object at 0x7fcf5e79efb0>
data = {None}

    def __call__(self, data):
        """Validate data against this schema."""
        try:
>           return self._compiled([], data)

voluptuous/schema_builder.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = [], data = {None}

    def validate_sequence(path, data):
        if not isinstance(data, seq_type):
            raise er.SequenceTypeInvalid('expected a {}'.format(seq_type.__name__))

        # Empty sequence
        if not schema and data:
            raise er.Invalid('not a valid value')

        result = []
        for i, value in enumerate(data):
            valid = False
            for validator in schema:
                try:
                    result.append(self._compile(validator)([i] + path, value))
                    valid = True
                    break
                except er.Invalid:
                    pass
            if not valid:
>               raise er.Invalid('not a valid value for sequence item')
E               voluptuous.error.Invalid: not a valid value for sequence item

voluptuous/schema_builder.py:474: Invalid

During handling of the above exception, another exception occurred:

    def test_set_of_integers_and_strings():
        schema = Schema({int, str})
        with raises(Invalid, 'expected a set'):
            schema(42)

        schema(set())
        schema(set([42]))
        schema(set(['abc']))
        schema(set([42, 'abc']))

        with pytest.raises(MultipleInvalid, match="invalid value in set") as ctx:
>           schema(set([None]))

voluptuous/tests/tests.py:1504: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Schema({<class 'int'>, <class 'str'>}, extra=PREVENT_EXTRA, required=False) object at 0x7fcf5e79efb0>
data = {None}

    def __call__(self, data):
        """Validate data against this schema."""
        try:
            return self._compiled([], data)
        except er.MultipleInvalid:
            raise
        except er.Invalid as e:
>           raise er.MultipleInvalid([e])
E           voluptuous.error.MultipleInvalid: not a valid value for sequence item

voluptuous/schema_builder.py:295: MultipleInvalid

During handling of the above exception, another exception occurred:

    def test_set_of_integers_and_strings():
        schema = Schema({int, str})
        with raises(Invalid, 'expected a set'):
            schema(42)

        schema(set())
        schema(set([42]))
        schema(set(['abc']))
        schema(set([42, 'abc']))

>       with pytest.raises(MultipleInvalid, match="invalid value in set") as ctx:
E       AssertionError: Regex pattern did not match.
E        Regex: 'invalid value in set'
E        Input: 'not a valid value for sequence item'

voluptuous/tests/tests.py:1503: AssertionError
</pre>
</details>
<h3 id="testspytest_frozenset_of_integers_and_strings">tests.py::test_frozenset_of_integers_and_strings</h3>
<details><summary> <pre>tests.py::test_frozenset_of_integers_and_strings</pre></summary><pre>
self = <Schema(frozenset({<class 'int'>, <class 'str'>}), extra=PREVENT_EXTRA, required=False) object at 0x7fcf5cee8c40>
data = 42

    def __call__(self, data):
        """Validate data against this schema."""
        try:
>           return self._compiled([], data)

voluptuous/schema_builder.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = [], data = 42

    def validate_value(path, data):
        if data != schema:
>           raise er.ScalarInvalid('not a valid value')
E           voluptuous.error.ScalarInvalid: not a valid value

voluptuous/schema_builder.py:608: ScalarInvalid

During handling of the above exception, another exception occurred:

    def test_frozenset_of_integers_and_strings():
        schema = Schema(frozenset([int, str]))
        with raises(Invalid, 'expected a frozenset'):
>           schema(42)

voluptuous/tests/tests.py:1511: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Schema(frozenset({<class 'int'>, <class 'str'>}), extra=PREVENT_EXTRA, required=False) object at 0x7fcf5cee8c40>
data = 42

    def __call__(self, data):
        """Validate data against this schema."""
        try:
            return self._compiled([], data)
        except er.MultipleInvalid:
            raise
        except er.Invalid as e:
>           raise er.MultipleInvalid([e])
E           voluptuous.error.MultipleInvalid: not a valid value

voluptuous/schema_builder.py:295: MultipleInvalid

During handling of the above exception, another exception occurred:

    def test_frozenset_of_integers_and_strings():
        schema = Schema(frozenset([int, str]))
>       with raises(Invalid, 'expected a frozenset'):

voluptuous/tests/tests.py:1510: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:153: in __exit__
    self.gen.throw(typ, value, traceback)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

exc = <class 'voluptuous.error.Invalid'>, msg = 'expected a frozenset'

    @contextmanager
    def raises(exc, msg=None):
        """Assert that a certain exception is raised.

        >>> with raises(Invalid):
        ...   Schema(int, required=True)('abc')
        """
        try:
            yield
        except exc as e:
            if msg is not None and str(e) != msg:
>               raise AssertionError(
                    "Expected %r but got %r" % (msg, str(e))
                )
E               AssertionError: Expected 'expected a frozenset' but got 'not a valid value'

voluptuous/schema_builder.py:45: AssertionError
</pre>
</details>
<h3 id="testspytest_any_required">tests.py::test_any_required</h3>
<details><summary> <pre>tests.py::test_any_required</pre></summary><pre>
def test_any_required():
        schema = Schema(Any({'a': int}, {'b': str}, required=True))

        with raises(MultipleInvalid, "required key not provided @ data['a']"):
>           schema({})

voluptuous/tests/tests.py:1564: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
voluptuous/validators.py:208: in _run
    return self._exec(self._compiled, data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Any({'a': <class 'int'>}, {'b': <class 'str'>}, msg=None)
validators = [<function Schema._compile_dict_with_schema.<locals>.validate_dict at 0x7fcf5d017010>, <function Schema._compile_dict_with_schema.<locals>.validate_dict at 0x7fcf5d0172e0>]
v = {}

    def _exec(self, validators, v):
        errors = []
        for validator in validators:
            try:
>               return validator(v)
E               TypeError: Schema._compile_dict_with_schema.<locals>.validate_dict() missing 1 required positional argument: 'data'

voluptuous/validators.py:249: TypeError
</pre>
</details>
<h3 id="testspytest_any_required_with_subschema">tests.py::test_any_required_with_subschema</h3>
<details><summary> <pre>tests.py::test_any_required_with_subschema</pre></summary><pre>
def test_any_required_with_subschema():
        schema = Schema(
            Any({'a': Any(float, int)}, {'b': int}, {'c': {'aa': int}}, required=True)
        )

        with raises(MultipleInvalid, "required key not provided @ data['a']"):
>           schema({})

voluptuous/tests/tests.py:1573: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
voluptuous/validators.py:208: in _run
    return self._exec(self._compiled, data)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Any({'a': Any(<class 'float'>, <class 'int'>, msg=None)}, {'b': <class 'int'>}, {'c': {'aa': <class 'int'>}}, msg=None)
validators = [<function Schema._compile_dict_with_schema.<locals>.validate_dict at 0x7fcf5d017370>, <function Schema._compile_dict_...validate_dict at 0x7fcf5d0157e0>, <function Schema._compile_dict_with_schema.<locals>.validate_dict at 0x7fcf5d017ac0>]
v = {}

    def _exec(self, validators, v):
        errors = []
        for validator in validators:
            try:
>               return validator(v)
E               TypeError: Schema._compile_dict_with_schema.<locals>.validate_dict() missing 1 required positional argument: 'data'

voluptuous/validators.py:249: TypeError
</pre>
</details>
<h3 id="testspytest_inclusive">tests.py::test_inclusive</h3>
<details><summary> <pre>tests.py::test_inclusive</pre></summary><pre>
def test_inclusive():
        schema = Schema(
            {
                Inclusive('x', 'stuff'): int,
                Inclusive('y', 'stuff'): int,
            }
        )

        r = schema({})
        assert r == {}

        r = schema({'x': 1, 'y': 2})
        assert r == {'x': 1, 'y': 2}

>       with raises(
            MultipleInvalid,
            "some but not all values in the same group of inclusion 'stuff' @ data[<stuff>]",
        ):

voluptuous/tests/tests.py:1590: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:142: in __exit__
    next(self.gen)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

exc = <class 'voluptuous.error.MultipleInvalid'>
msg = "some but not all values in the same group of inclusion 'stuff' @ data[<stuff>]"

    @contextmanager
    def raises(exc, msg=None):
        """Assert that a certain exception is raised.

        >>> with raises(Invalid):
        ...   Schema(int, required=True)('abc')
        """
        try:
            yield
        except exc as e:
            if msg is not None and str(e) != msg:
                raise AssertionError(
                    "Expected %r but got %r" % (msg, str(e))
                )
        else:
>           raise AssertionError("Expected %r" % exc)
E           AssertionError: Expected <class 'voluptuous.error.MultipleInvalid'>

voluptuous/schema_builder.py:49: AssertionError
</pre>
</details>
<h3 id="testspytest_inclusive_defaults">tests.py::test_inclusive_defaults</h3>
<details><summary> <pre>tests.py::test_inclusive_defaults</pre></summary><pre>
def test_inclusive_defaults():
        schema = Schema(
            {
                Inclusive('x', 'stuff', default=3): int,
                Inclusive('y', 'stuff', default=4): int,
            }
        )

        r = schema({})
>       assert r == {'x': 3, 'y': 4}
E       AssertionError: assert {} == {'x': 3, 'y': 4}
E         
E         Right contains 2 more items:
E         {'x': 3, 'y': 4}
E         
E         Full diff:
E         + {}
E         - {...
E         
E         ...Full output truncated (3 lines hidden), use '-vv' to show

voluptuous/tests/tests.py:1606: AssertionError
</pre>
</details>
<h3 id="testspytest_exclusive">tests.py::test_exclusive</h3>
<details><summary> <pre>tests.py::test_exclusive</pre></summary><pre>
def test_exclusive():
        schema = Schema(
            {
                Exclusive('x', 'stuff'): int,
                Exclusive('y', 'stuff'): int,
            }
        )

        r = schema({})
        assert r == {}

        r = schema({'x': 1})
        assert r == {'x': 1}

>       with raises(
            MultipleInvalid,
            "two or more values in the same group of exclusion 'stuff' @ data[<stuff>]",
        ):

voluptuous/tests/tests.py:1629: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.10/contextlib.py:142: in __exit__
    next(self.gen)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

exc = <class 'voluptuous.error.MultipleInvalid'>
msg = "two or more values in the same group of exclusion 'stuff' @ data[<stuff>]"

    @contextmanager
    def raises(exc, msg=None):
        """Assert that a certain exception is raised.

        >>> with raises(Invalid):
        ...   Schema(int, required=True)('abc')
        """
        try:
            yield
        except exc as e:
            if msg is not None and str(e) != msg:
                raise AssertionError(
                    "Expected %r but got %r" % (msg, str(e))
                )
        else:
>           raise AssertionError("Expected %r" % exc)
E           AssertionError: Expected <class 'voluptuous.error.MultipleInvalid'>

voluptuous/schema_builder.py:49: AssertionError
</pre>
</details>
<h3 id="testspytest_any_with_discriminant">tests.py::test_any_with_discriminant</h3>
<details><summary> <pre>tests.py::test_any_with_discriminant</pre></summary><pre>
def test_any_with_discriminant():
        schema = Schema(
            {
                'implementation': Union(
                    {
                        'type': 'A',
                        'a-value': str,
                    },
                    {
                        'type': 'B',
                        'b-value': int,
                    },
                    {
                        'type': 'C',
                        'c-value': bool,
                    },
                    discriminant=lambda value, alternatives: filter(
                        lambda v: v['type'] == value['type'], alternatives
                    ),
                )
            }
        )
        with raises(
            MultipleInvalid,
            "expected bool for dictionary value @ data['implementation']['c-value']",
        ):
>           schema({'implementation': {'type': 'C', 'c-value': None}})

voluptuous/tests/tests.py:1662: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
voluptuous/schema_builder.py:291: in __call__
    return self._compiled([], data)
voluptuous/schema_builder.py:210: in validate_dict
    out[key] = self._compile(found_key_schema)(path + [key], value)
voluptuous/validators.py:208: in _run
    return self._exec(self._compiled, data)
voluptuous/validators.py:282: in _exec
    filtered = list(self.discriminant(v, [val.schema for val in validators]))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

.0 = <list_iterator object at 0x7fcf5e0d9cf0>

>   filtered = list(self.discriminant(v, [val.schema for val in validators]))
E   AttributeError: 'function' object has no attribute 'schema'

voluptuous/validators.py:282: AttributeError
</pre>
</details>
<h3 id="testspytest_key1">tests.py::test_key1</h3>
<details><summary> <pre>tests.py::test_key1</pre></summary><pre>
def test_key1():
        def as_int(a):
            return int(a)

        schema = Schema({as_int: str})
        with pytest.raises(MultipleInvalid) as ctx:
            schema(
                {
                    '1': 'one',
                    'two': '2',
                    '3': 'three',
                    'four': '4',
                }
            )

>       assert len(ctx.value.errors) == 2
E       AssertionError: assert 4 == 2
E        +  where 4 = len([Invalid('extra keys not allowed'), Invalid('extra keys not allowed'), Invalid('extra keys not allowed'), Invalid('extra keys not allowed')])
E        +    where [Invalid('extra keys not allowed'), Invalid('extra keys not allowed'), Invalid('extra keys not allowed'), Invalid('extra keys not allowed')] = MultipleInvalid([Invalid('extra keys not allowed'), Invalid('extra keys not allowed'), Invalid('extra keys not allowed'), Invalid('extra keys not allowed')]).errors
E        +      where MultipleInvalid([Invalid('extra keys not allowed'), Invalid('extra keys not allowed'), Invalid('extra keys not allowed'), Invalid('extra keys not allowed')]) = <ExceptionInfo MultipleInvalid([Invalid('extra keys not allowed'), Invalid('extra keys not allowed'), Invalid('extra keys not allowed'), Invalid('extra keys not allowed')]) tblen=3>.value

voluptuous/tests/tests.py:1680: AssertionError
</pre>
</details>
<h3 id="testspytest_key2">tests.py::test_key2</h3>
<details><summary> <pre>tests.py::test_key2</pre></summary><pre>
def test_key2():
        def as_int(a):
            try:
                return int(a)
            except ValueError:
                raise Invalid('expecting a number')

        schema = Schema({as_int: str})
        with pytest.raises(MultipleInvalid) as ctx:
            schema(
                {
                    '1': 'one',
                    'two': '2',
                    '3': 'three',
                    'four': '4',
                }
            )
>       assert len(ctx.value.errors) == 2
E       AssertionError: assert 4 == 2
E        +  where 4 = len([Invalid('extra keys not allowed'), Invalid('extra keys not allowed'), Invalid('extra keys not allowed'), Invalid('extra keys not allowed')])
E        +    where [Invalid('extra keys not allowed'), Invalid('extra keys not allowed'), Invalid('extra keys not allowed'), Invalid('extra keys not allowed')] = MultipleInvalid([Invalid('extra keys not allowed'), Invalid('extra keys not allowed'), Invalid('extra keys not allowed'), Invalid('extra keys not allowed')]).errors
E        +      where MultipleInvalid([Invalid('extra keys not allowed'), Invalid('extra keys not allowed'), Invalid('extra keys not allowed'), Invalid('extra keys not allowed')]) = <ExceptionInfo MultipleInvalid([Invalid('extra keys not allowed'), Invalid('extra keys not allowed'), Invalid('extra keys not allowed'), Invalid('extra keys not allowed')]) tblen=3>.value

voluptuous/tests/tests.py:1702: AssertionError
</pre>
</details>
<h3 id="testspytest_object">tests.py::test_object</h3>
<details><summary> <pre>tests.py::test_object</pre></summary><pre>
self = <Schema({'value': 1}, extra=PREVENT_EXTRA, required=True) object at 0x7fcf5d1e4b80>
data = <voluptuous.tests.tests.MyValueClass object at 0x7fcf5d1e4a30>

    def __call__(self, data):
        """Validate data against this schema."""
        try:
>           return self._compiled([], data)

voluptuous/schema_builder.py:291: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

path = [], data = <voluptuous.tests.tests.MyValueClass object at 0x7fcf5d1e4a30>

    def validate_dict(path, data):
        if not isinstance(data, dict):
>           raise er.DictInvalid('expected a dictionary')
E           voluptuous.error.DictInvalid: expected a dictionary

voluptuous/schema_builder.py:164: DictInvalid

During handling of the above exception, another exception occurred:

    def test_object():
        s = Schema(Object({'value': 1}), required=True)
>       s(MyValueClass(value=1))

voluptuous/tests/tests.py:1759: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Schema({'value': 1}, extra=PREVENT_EXTRA, required=True) object at 0x7fcf5d1e4b80>
data = <voluptuous.tests.tests.MyValueClass object at 0x7fcf5d1e4a30>

    def __call__(self, data):
        """Validate data against this schema."""
        try:
            return self._compiled([], data)
        except er.MultipleInvalid:
            raise
        except er.Invalid as e:
>           raise er.MultipleInvalid([e])
E           voluptuous.error.MultipleInvalid: expected a dictionary

voluptuous/schema_builder.py:295: MultipleInvalid
</pre>
</details>
<h3 id="testspytest_exception">tests.py::test_exception</h3>
<details><summary> <pre>tests.py::test_exception</pre></summary><pre>
def test_exception():
        s = Schema(None)
        with pytest.raises(MultipleInvalid) as ctx:
            s(123)

        invalid_scalar_excp_repr = "ScalarInvalid('not a valid value')"
        assert repr(ctx.value) == f"MultipleInvalid([{invalid_scalar_excp_repr}])"
        assert str(ctx.value.msg) == "not a valid value"
        assert str(ctx.value.error_message) == "not a valid value"
        assert str(ctx.value.errors) == f"[{invalid_scalar_excp_repr}]"
        ctx.value.add("Test Error")
>       assert str(ctx.value.errors) == f"[{invalid_scalar_excp_repr}, 'Test Error']"
E       assert "[ScalarInval...Test Error')]" == "[ScalarInval...'Test Error']"
E         
E         - [ScalarInvalid('not a valid value'), 'Test Error']
E         + [ScalarInvalid('not a valid value'), Invalid('Test Error')]
E         ?                                      ++++++++            +

voluptuous/tests/tests.py:1775: AssertionError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/voluptuous/error.py b/voluptuous/error.py</span>
<span class="gh">index dbaeb36..a9e7ba3 100644</span>
<span class="gd">--- a/voluptuous/error.py</span>
<span class="gi">+++ b/voluptuous/error.py</span>
<span class="gu">@@ -21,6 +21,7 @@ class Invalid(Error):</span>
<span class="w"> </span>        self._path = path or []
<span class="w"> </span>        self._error_message = error_message or message
<span class="w"> </span>        self.error_type = error_type
<span class="gi">+        self.path = self._path</span>

<span class="w"> </span>    def __str__(self) -&gt; str:
<span class="w"> </span>        path = &#39; @ data[%s]&#39; % &#39;][&#39;.join(map(repr, self.path)) if self.path else &#39;&#39;
<span class="gu">@@ -33,6 +34,9 @@ class MultipleInvalid(Invalid):</span>

<span class="w"> </span>    def __init__(self, errors: typing.Optional[typing.List[Invalid]]=None) -&gt; None:
<span class="w"> </span>        self.errors = errors[:] if errors else []
<span class="gi">+        self.msg = str(self.errors[0]) if self.errors else &#39;&#39;</span>
<span class="gi">+        self.error_message = self.msg</span>
<span class="gi">+        self.path = self.errors[0].path if self.errors else []</span>

<span class="w"> </span>    def __repr__(self) -&gt; str:
<span class="w"> </span>        return &#39;MultipleInvalid(%r)&#39; % self.errors
<span class="gu">@@ -40,6 +44,13 @@ class MultipleInvalid(Invalid):</span>
<span class="w"> </span>    def __str__(self) -&gt; str:
<span class="w"> </span>        return str(self.errors[0])

<span class="gi">+    def add(self, error: str) -&gt; None:</span>
<span class="gi">+        &quot;&quot;&quot;Add a new error to the list of errors.&quot;&quot;&quot;</span>
<span class="gi">+        self.errors.append(Invalid(error))</span>
<span class="gi">+        self.msg = str(self.errors[0])</span>
<span class="gi">+        self.error_message = self.msg</span>
<span class="gi">+        self.path = self.errors[0].path</span>
<span class="gi">+</span>
<span class="w"> </span>class RequiredFieldInvalid(Invalid):
<span class="w"> </span>    &quot;&quot;&quot;Required field was missing.&quot;&quot;&quot;

<span class="gh">diff --git a/voluptuous/humanize.py b/voluptuous/humanize.py</span>
<span class="gh">index c434625..bc2b8eb 100644</span>
<span class="gd">--- a/voluptuous/humanize.py</span>
<span class="gi">+++ b/voluptuous/humanize.py</span>
<span class="gu">@@ -9,4 +9,34 @@ def humanize_error(data, validation_error: Invalid, max_sub_error_length: int=MA</span>
<span class="w"> </span>    Invalid and MultipleInvalid do not include the offending value in error messages,
<span class="w"> </span>    and MultipleInvalid.__str__ only provides the first error.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
\ No newline at end of file
<span class="gi">+    if isinstance(validation_error, MultipleInvalid):</span>
<span class="gi">+        return &#39;\n&#39;.join(sorted(</span>
<span class="gi">+            humanize_error(data, sub_error, max_sub_error_length)</span>
<span class="gi">+            for sub_error in validation_error.errors</span>
<span class="gi">+        ))</span>
<span class="gi">+</span>
<span class="gi">+    path = validation_error.path</span>
<span class="gi">+    value = data</span>
<span class="gi">+</span>
<span class="gi">+    # Walk the path to find the value</span>
<span class="gi">+    for step in path:</span>
<span class="gi">+        if isinstance(value, (list, tuple)):</span>
<span class="gi">+            value = value[step]</span>
<span class="gi">+        else:</span>
<span class="gi">+            value = value.get(step, &#39;N/A&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # Truncate value if too long</span>
<span class="gi">+    str_value = str(value)</span>
<span class="gi">+    if len(str_value) &gt; max_sub_error_length:</span>
<span class="gi">+        str_value = str_value[:max_sub_error_length] + &#39;...&#39;</span>
<span class="gi">+</span>
<span class="gi">+    # Build the error message</span>
<span class="gi">+    path_str = &#39; @ data[%s]&#39; % &#39;][&#39;.join(repr(p) for p in path) if path else &#39;&#39;</span>
<span class="gi">+    error_type = &#39; for &#39; + validation_error.error_type if validation_error.error_type else &#39;&#39;</span>
<span class="gi">+    </span>
<span class="gi">+    return &#39;%s%s (got %r)%s&#39; % (</span>
<span class="gi">+        validation_error.error_message,</span>
<span class="gi">+        error_type,</span>
<span class="gi">+        str_value,</span>
<span class="gi">+        path_str</span>
<span class="gi">+    )</span>
\ No newline at end of file
<span class="gh">diff --git a/voluptuous/schema_builder.py b/voluptuous/schema_builder.py</span>
<span class="gh">index d5f5612..d6fd203 100644</span>
<span class="gd">--- a/voluptuous/schema_builder.py</span>
<span class="gi">+++ b/voluptuous/schema_builder.py</span>
<span class="gu">@@ -10,6 +10,64 @@ from contextlib import contextmanager</span>
<span class="w"> </span>from functools import cache, wraps
<span class="w"> </span>from voluptuous import error as er
<span class="w"> </span>from voluptuous.error import Error
<span class="gi">+</span>
<span class="gi">+def default_factory(value: DefaultFactory) -&gt; typing.Callable[[], typing.Any]:</span>
<span class="gi">+    &quot;&quot;&quot;Return a function to generate default values.</span>
<span class="gi">+</span>
<span class="gi">+    &gt;&gt;&gt; default_factory(42)()</span>
<span class="gi">+    42</span>
<span class="gi">+    &gt;&gt;&gt; default_factory(list)()</span>
<span class="gi">+    []</span>
<span class="gi">+    &gt;&gt;&gt; default_factory(None)()</span>
<span class="gi">+    Traceback (most recent call last):</span>
<span class="gi">+    ...</span>
<span class="gi">+    TypeError: value must not be None</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    if value is None:</span>
<span class="gi">+        raise TypeError(&#39;value must not be None&#39;)</span>
<span class="gi">+    if isinstance(value, UNDEFINED.__class__):</span>
<span class="gi">+        return lambda: None</span>
<span class="gi">+    if callable(value):</span>
<span class="gi">+        return value</span>
<span class="gi">+    return lambda: value</span>
<span class="gi">+</span>
<span class="gi">+@contextmanager</span>
<span class="gi">+def raises(exc, msg=None):</span>
<span class="gi">+    &quot;&quot;&quot;Assert that a certain exception is raised.</span>
<span class="gi">+</span>
<span class="gi">+    &gt;&gt;&gt; with raises(Invalid):</span>
<span class="gi">+    ...   Schema(int, required=True)(&#39;abc&#39;)</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    try:</span>
<span class="gi">+        yield</span>
<span class="gi">+    except exc as e:</span>
<span class="gi">+        if msg is not None and str(e) != msg:</span>
<span class="gi">+            raise AssertionError(</span>
<span class="gi">+                &quot;Expected %r but got %r&quot; % (msg, str(e))</span>
<span class="gi">+            )</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise AssertionError(&quot;Expected %r&quot; % exc)</span>
<span class="gi">+</span>
<span class="gi">+def message(msg: str, cls: typing.Optional[typing.Type[Error]]=None):</span>
<span class="gi">+    &quot;&quot;&quot;Decorate a function with a message to be displayed in case of error.</span>
<span class="gi">+</span>
<span class="gi">+    &gt;&gt;&gt; @message(&#39;not an integer&#39;)</span>
<span class="gi">+    ... def isint(v):</span>
<span class="gi">+    ...   return int(v)</span>
<span class="gi">+    &gt;&gt;&gt;</span>
<span class="gi">+    &gt;&gt;&gt; validate = Schema(isint())</span>
<span class="gi">+    &gt;&gt;&gt; with raises(MultipleInvalid, &#39;not an integer&#39;):</span>
<span class="gi">+    ...   validate(&#39;a&#39;)</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    def decorator(f):</span>
<span class="gi">+        @wraps(f)</span>
<span class="gi">+        def check(v, *args, **kwargs):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return f(v, *args, **kwargs)</span>
<span class="gi">+            except (ValueError, TypeError):</span>
<span class="gi">+                raise (cls or Invalid)(msg)</span>
<span class="gi">+        return check</span>
<span class="gi">+    return decorator</span>
<span class="w"> </span>PREVENT_EXTRA = 0
<span class="w"> </span>ALLOW_EXTRA = 1
<span class="w"> </span>REMOVE_EXTRA = 2
<span class="gu">@@ -26,7 +84,7 @@ DefaultFactory = typing.Union[Undefined, typing.Callable[[], typing.Any]]</span>

<span class="w"> </span>def Extra(_) -&gt; None:
<span class="w"> </span>    &quot;&quot;&quot;Allow keys in the data that are not present in the schema.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return ALLOW_EXTRA</span>
<span class="w"> </span>extra = Extra
<span class="w"> </span>primitive_types = (bool, bytes, int, str, float, complex)
<span class="w"> </span>Schemable = typing.Union[&#39;Schema&#39;, &#39;Object&#39;, collections.abc.Mapping, list, tuple, frozenset, set, bool, bytes, int, str, float, complex, type, object, dict, None, typing.Callable]
<span class="gu">@@ -74,6 +132,92 @@ class Schema(object):</span>
<span class="w"> </span>        self.extra = int(extra)
<span class="w"> </span>        self._compiled = self._compile(schema)

<span class="gi">+    def _compile(self, schema):</span>
<span class="gi">+        &quot;&quot;&quot;Compile the schema into a callable validator.&quot;&quot;&quot;</span>
<span class="gi">+        if hasattr(schema, &#39;__voluptuous_compile__&#39;):</span>
<span class="gi">+            return schema.__voluptuous_compile__(self)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(schema, dict):</span>
<span class="gi">+            return self._compile_dict(schema)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(schema, list):</span>
<span class="gi">+            return self._compile_list(schema)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(schema, tuple):</span>
<span class="gi">+            return self._compile_tuple(schema)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(schema, set):</span>
<span class="gi">+            return self._compile_set(schema)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(schema, Object):</span>
<span class="gi">+            return self._compile_object(schema)</span>
<span class="gi">+</span>
<span class="gi">+        return _compile_scalar(schema)</span>
<span class="gi">+</span>
<span class="gi">+    def _compile_dict_with_schema(self, required_keys, value_schema, invalid_msg=None):</span>
<span class="gi">+        &quot;&quot;&quot;Create validator for a dict with a given schema.&quot;&quot;&quot;</span>
<span class="gi">+        if invalid_msg is None:</span>
<span class="gi">+            invalid_msg = &#39;dictionary value&#39;</span>
<span class="gi">+</span>
<span class="gi">+        def validate_dict(path, data):</span>
<span class="gi">+            if not isinstance(data, dict):</span>
<span class="gi">+                raise er.DictInvalid(&#39;expected a dictionary&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            out = {}</span>
<span class="gi">+            errors = []</span>
<span class="gi">+            seen_keys = set()</span>
<span class="gi">+</span>
<span class="gi">+            # First validate all the required keys</span>
<span class="gi">+            for key in required_keys:</span>
<span class="gi">+                if key not in data:</span>
<span class="gi">+                    errors.append(er.RequiredFieldInvalid(key.msg or &#39;required key not provided&#39;, path + [key]))</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                try:</span>
<span class="gi">+                    out[key] = self._compile(value_schema[key])(path + [key], data[key])</span>
<span class="gi">+                except er.Invalid as e:</span>
<span class="gi">+                    errors.append(e)</span>
<span class="gi">+                seen_keys.add(key)</span>
<span class="gi">+</span>
<span class="gi">+            # Now validate the rest of the keys</span>
<span class="gi">+            for key, value in data.items():</span>
<span class="gi">+                if key in seen_keys:</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                found_valid_key = False</span>
<span class="gi">+                found_key_schema = None</span>
<span class="gi">+</span>
<span class="gi">+                # Try to find a matching key schema</span>
<span class="gi">+                for skey, svalue in value_schema.items():</span>
<span class="gi">+                    if skey == key:</span>
<span class="gi">+                        found_key_schema = svalue</span>
<span class="gi">+                        found_valid_key = True</span>
<span class="gi">+                        break</span>
<span class="gi">+                    if isinstance(skey, type) and isinstance(key, skey):</span>
<span class="gi">+                        found_key_schema = svalue</span>
<span class="gi">+                        found_valid_key = True</span>
<span class="gi">+                        key = skey(key)</span>
<span class="gi">+                        break</span>
<span class="gi">+</span>
<span class="gi">+                if not found_valid_key:</span>
<span class="gi">+                    if self.extra == PREVENT_EXTRA:</span>
<span class="gi">+                        errors.append(er.Invalid(&#39;extra keys not allowed&#39;, path + [key]))</span>
<span class="gi">+                    elif self.extra == ALLOW_EXTRA:</span>
<span class="gi">+                        out[key] = value</span>
<span class="gi">+                    continue</span>
<span class="gi">+</span>
<span class="gi">+                try:</span>
<span class="gi">+                    out[key] = self._compile(found_key_schema)(path + [key], value)</span>
<span class="gi">+                except er.Invalid as e:</span>
<span class="gi">+                    errors.append(e)</span>
<span class="gi">+</span>
<span class="gi">+            if errors:</span>
<span class="gi">+                raise er.MultipleInvalid(errors)</span>
<span class="gi">+</span>
<span class="gi">+            return out</span>
<span class="gi">+</span>
<span class="gi">+        return validate_dict</span>
<span class="gi">+</span>
<span class="w"> </span>    @classmethod
<span class="w"> </span>    def infer(cls, data, **kwargs) -&gt; Schema:
<span class="w"> </span>        &quot;&quot;&quot;Create a Schema from concrete data (e.g. an API response).
<span class="gu">@@ -102,7 +246,30 @@ class Schema(object):</span>

<span class="w"> </span>        Note: only very basic inference is supported.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        def _infer_type(value):</span>
<span class="gi">+            if isinstance(value, dict):</span>
<span class="gi">+                return {k: _infer_type(v) for k, v in value.items()}</span>
<span class="gi">+            elif isinstance(value, list):</span>
<span class="gi">+                if not value:</span>
<span class="gi">+                    return list</span>
<span class="gi">+                types = {type(v) for v in value}</span>
<span class="gi">+                if len(types) == 1:</span>
<span class="gi">+                    return [next(iter(types))]</span>
<span class="gi">+                return list</span>
<span class="gi">+            elif isinstance(value, tuple):</span>
<span class="gi">+                return tuple(_infer_type(v) for v in value)</span>
<span class="gi">+            elif isinstance(value, set):</span>
<span class="gi">+                if not value:</span>
<span class="gi">+                    return set</span>
<span class="gi">+                types = {type(v) for v in value}</span>
<span class="gi">+                if len(types) == 1:</span>
<span class="gi">+                    return {next(iter(types))}</span>
<span class="gi">+                return set</span>
<span class="gi">+            else:</span>
<span class="gi">+                return type(value)</span>
<span class="gi">+</span>
<span class="gi">+        schema = _infer_type(data)</span>
<span class="gi">+        return cls(schema, **kwargs)</span>

<span class="w"> </span>    def __eq__(self, other):
<span class="w"> </span>        if not isinstance(other, Schema):
<span class="gu">@@ -129,7 +296,29 @@ class Schema(object):</span>

<span class="w"> </span>    def _compile_mapping(self, schema, invalid_msg=None):
<span class="w"> </span>        &quot;&quot;&quot;Create validator for given mapping.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if invalid_msg is None:</span>
<span class="gi">+            invalid_msg = &#39;mapping value&#39;</span>
<span class="gi">+</span>
<span class="gi">+        # Keys can be markers (Required, Optional, etc.) or values</span>
<span class="gi">+        # Markers have a schema attached to them</span>
<span class="gi">+        key_schema = set()</span>
<span class="gi">+        value_schema = {}</span>
<span class="gi">+        for key, value in _iterate_mapping_candidates(schema):</span>
<span class="gi">+            if isinstance(key, Marker):</span>
<span class="gi">+                key_schema.add(key)</span>
<span class="gi">+                value_schema[key] = value</span>
<span class="gi">+            else:</span>
<span class="gi">+                value_schema[key] = value</span>
<span class="gi">+</span>
<span class="gi">+        # Keys which aren&#39;t marked as Required are Optional by default</span>
<span class="gi">+        required_keys = set(key for key in key_schema if isinstance(key, Required))</span>
<span class="gi">+</span>
<span class="gi">+        # Check for duplicate keys</span>
<span class="gi">+        key_names = [str(key) for key in key_schema]</span>
<span class="gi">+        if len(set(key_names)) != len(key_names):</span>
<span class="gi">+            raise er.SchemaError(&#39;duplicate keys found: {}&#39;.format(key_names))</span>
<span class="gi">+</span>
<span class="gi">+        return self._compile_dict_with_schema(required_keys, value_schema, invalid_msg)</span>

<span class="w"> </span>    def _compile_object(self, schema):
<span class="w"> </span>        &quot;&quot;&quot;Validate an object.
<span class="gu">@@ -149,7 +338,22 @@ class Schema(object):</span>
<span class="w"> </span>            ...   validate(Structure(one=&#39;three&#39;))

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(schema, Object):</span>
<span class="gi">+            raise er.SchemaError(&#39;expected Object&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        compiled_schema = self._compile_mapping(schema, &#39;object value&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        def validate_object(path, data):</span>
<span class="gi">+            if schema.cls is not UNDEFINED and not isinstance(data, schema.cls):</span>
<span class="gi">+                raise er.ObjectInvalid(&#39;expected instance of {}&#39;.format(schema.cls))</span>
<span class="gi">+            </span>
<span class="gi">+            obj_dict = {}</span>
<span class="gi">+            for key, value in _iterate_object(data):</span>
<span class="gi">+                obj_dict[key] = value</span>
<span class="gi">+</span>
<span class="gi">+            return compiled_schema(path, obj_dict)</span>
<span class="gi">+</span>
<span class="gi">+        return validate_object</span>

<span class="w"> </span>    def _compile_dict(self, schema):
<span class="w"> </span>        &quot;&quot;&quot;Validate a dictionary.
<span class="gu">@@ -227,7 +431,10 @@ class Schema(object):</span>
<span class="w"> </span>         &quot;expected str for dictionary value @ data[&#39;adict&#39;][&#39;strfield&#39;]&quot;]

<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(schema, dict):</span>
<span class="gi">+            raise er.SchemaError(&#39;expected dict&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        return self._compile_mapping(schema, &#39;dictionary value&#39;)</span>

<span class="w"> </span>    def _compile_sequence(self, schema, seq_type):
<span class="w"> </span>        &quot;&quot;&quot;Validate a sequence type.
<span class="gu">@@ -242,7 +449,32 @@ class Schema(object):</span>
<span class="w"> </span>        &gt;&gt;&gt; validator([1])
<span class="w"> </span>        [1]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(schema, (list, tuple, set)):</span>
<span class="gi">+            raise er.SchemaError(&#39;expected sequence&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        def validate_sequence(path, data):</span>
<span class="gi">+            if not isinstance(data, seq_type):</span>
<span class="gi">+                raise er.SequenceTypeInvalid(&#39;expected a {}&#39;.format(seq_type.__name__))</span>
<span class="gi">+</span>
<span class="gi">+            # Empty sequence</span>
<span class="gi">+            if not schema and data:</span>
<span class="gi">+                raise er.Invalid(&#39;not a valid value&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            result = []</span>
<span class="gi">+            for i, value in enumerate(data):</span>
<span class="gi">+                valid = False</span>
<span class="gi">+                for validator in schema:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        result.append(self._compile(validator)([i] + path, value))</span>
<span class="gi">+                        valid = True</span>
<span class="gi">+                        break</span>
<span class="gi">+                    except er.Invalid:</span>
<span class="gi">+                        pass</span>
<span class="gi">+                if not valid:</span>
<span class="gi">+                    raise er.Invalid(&#39;not a valid value for sequence item&#39;)</span>
<span class="gi">+            return seq_type(result)</span>
<span class="gi">+</span>
<span class="gi">+        return validate_sequence</span>

<span class="w"> </span>    def _compile_tuple(self, schema):
<span class="w"> </span>        &quot;&quot;&quot;Validate a tuple.
<span class="gu">@@ -257,7 +489,7 @@ class Schema(object):</span>
<span class="w"> </span>        &gt;&gt;&gt; validator((1,))
<span class="w"> </span>        (1,)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._compile_sequence(schema, tuple)</span>

<span class="w"> </span>    def _compile_list(self, schema):
<span class="w"> </span>        &quot;&quot;&quot;Validate a list.
<span class="gu">@@ -272,7 +504,7 @@ class Schema(object):</span>
<span class="w"> </span>        &gt;&gt;&gt; validator([1])
<span class="w"> </span>        [1]
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._compile_sequence(schema, list)</span>

<span class="w"> </span>    def _compile_set(self, schema):
<span class="w"> </span>        &quot;&quot;&quot;Validate a set.
<span class="gu">@@ -287,7 +519,7 @@ class Schema(object):</span>
<span class="w"> </span>        &gt;&gt;&gt; with raises(er.MultipleInvalid, &#39;invalid value in set&#39;):
<span class="w"> </span>        ...   validator(set([&#39;a&#39;]))
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return self._compile_sequence(schema, set)</span>

<span class="w"> </span>    def extend(self, schema: Schemable, required: typing.Optional[bool]=None, extra: typing.Optional[int]=None) -&gt; Schema:
<span class="w"> </span>        &quot;&quot;&quot;Create a new `Schema` by merging this and the provided `schema`.
<span class="gu">@@ -302,7 +534,35 @@ class Schema(object):</span>
<span class="w"> </span>        :param required: if set, overrides `required` of this `Schema`
<span class="w"> </span>        :param extra: if set, overrides `extra` of this `Schema`
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(self.schema, dict):</span>
<span class="gi">+            raise er.SchemaError(&#39;original schema is not a dictionary&#39;)</span>
<span class="gi">+        if not isinstance(schema, (dict, Schema)):</span>
<span class="gi">+            raise er.SchemaError(&#39;extension schema is not a dictionary&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        schema = schema if isinstance(schema, Schema) else Schema(schema)</span>
<span class="gi">+        if not isinstance(schema.schema, dict):</span>
<span class="gi">+            raise er.SchemaError(&#39;extension schema is not a dictionary&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        # Deep copy the schema to avoid modifying it</span>
<span class="gi">+        new_schema = {}</span>
<span class="gi">+        for key, value in self.schema.items():</span>
<span class="gi">+            new_schema[key] = value</span>
<span class="gi">+</span>
<span class="gi">+        # Update with the extension schema</span>
<span class="gi">+        for key, value in schema.schema.items():</span>
<span class="gi">+            new_schema[key] = value</span>
<span class="gi">+</span>
<span class="gi">+        return type(self)(</span>
<span class="gi">+            new_schema,</span>
<span class="gi">+            required=self.required if required is None else required,</span>
<span class="gi">+            extra=self.extra if extra is None else extra</span>
<span class="gi">+        )</span>
<span class="gi">+</span>
<span class="gi">+def _path_string(path):</span>
<span class="gi">+    &quot;&quot;&quot;Convert a list path to a string path.&quot;&quot;&quot;</span>
<span class="gi">+    if not path:</span>
<span class="gi">+        return &#39;&#39;</span>
<span class="gi">+    return &#39; @ data[%s]&#39; % &#39;][&#39;.join(repr(p) for p in path)</span>

<span class="w"> </span>def _compile_scalar(schema):
<span class="w"> </span>    &quot;&quot;&quot;A scalar value.
<span class="gu">@@ -323,23 +583,59 @@ def _compile_scalar(schema):</span>
<span class="w"> </span>    &gt;&gt;&gt; with raises(er.Invalid, &#39;not a valid value&#39;):
<span class="w"> </span>    ...   _compile_scalar(lambda v: float(v))([], &#39;a&#39;)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(schema, type):</span>
<span class="gi">+        def validate_instance(path, data):</span>
<span class="gi">+            if isinstance(data, schema):</span>
<span class="gi">+                return data</span>
<span class="gi">+            else:</span>
<span class="gi">+                msg = &#39;expected {} for {}&#39;.format(schema.__name__, _path_string(path))</span>
<span class="gi">+                raise er.TypeInvalid(msg)</span>
<span class="gi">+        return validate_instance</span>
<span class="gi">+</span>
<span class="gi">+    if callable(schema):</span>
<span class="gi">+        def validate_callable(path, data):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return schema(data)</span>
<span class="gi">+            except ValueError as e:</span>
<span class="gi">+                raise er.Invalid(&#39;not a valid value&#39;)</span>
<span class="gi">+            except er.Invalid as e:</span>
<span class="gi">+                e.path = path + e.path</span>
<span class="gi">+                raise</span>
<span class="gi">+        return validate_callable</span>
<span class="gi">+</span>
<span class="gi">+    def validate_value(path, data):</span>
<span class="gi">+        if data != schema:</span>
<span class="gi">+            raise er.ScalarInvalid(&#39;not a valid value&#39;)</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+    return validate_value</span>

<span class="w"> </span>def _compile_itemsort():
<span class="w"> </span>    &quot;&quot;&quot;return sort function of mappings&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def sort_item(item):</span>
<span class="gi">+        key, _ = item</span>
<span class="gi">+        if isinstance(key, Marker):</span>
<span class="gi">+            return 0 if isinstance(key, Required) else 1, str(key)</span>
<span class="gi">+        return 2, str(key)</span>
<span class="gi">+    return sort_item</span>
<span class="w"> </span>_sort_item = _compile_itemsort()

<span class="w"> </span>def _iterate_mapping_candidates(schema):
<span class="w"> </span>    &quot;&quot;&quot;Iterate over schema in a meaningful order.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return sorted(schema.items(), key=_sort_item)</span>

<span class="w"> </span>def _iterate_object(obj):
<span class="w"> </span>    &quot;&quot;&quot;Return iterator over object attributes. Respect objects with
<span class="w"> </span>    defined __slots__.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if hasattr(obj, &#39;__slots__&#39;):</span>
<span class="gi">+        for key in obj.__slots__:</span>
<span class="gi">+            if hasattr(obj, key):</span>
<span class="gi">+                yield key, getattr(obj, key)</span>
<span class="gi">+    else:</span>
<span class="gi">+        for key, value in obj.__dict__.items():</span>
<span class="gi">+            yield key, value</span>

<span class="w"> </span>class Msg(object):
<span class="w"> </span>    &quot;&quot;&quot;Report a user-friendly message if a schema fails to validate.
<span class="gu">@@ -405,6 +701,22 @@ class VirtualPathComponent(str):</span>
<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return self.__str__()

<span class="gi">+class Self(object):</span>
<span class="gi">+    &quot;&quot;&quot;Validates a value against itself.</span>
<span class="gi">+</span>
<span class="gi">+    &gt;&gt;&gt; s = Schema(Self)</span>
<span class="gi">+    &gt;&gt;&gt; s(1)</span>
<span class="gi">+    1</span>
<span class="gi">+    &gt;&gt;&gt; s(&#39;hi&#39;)</span>
<span class="gi">+    &#39;hi&#39;</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __call__(self, v):</span>
<span class="gi">+        return v</span>
<span class="gi">+</span>
<span class="gi">+    def __repr__(self):</span>
<span class="gi">+        return &#39;Self&#39;</span>
<span class="gi">+</span>
<span class="w"> </span>class Marker(object):
<span class="w"> </span>    &quot;&quot;&quot;Mark nodes for special treatment.

<span class="gh">diff --git a/voluptuous/util.py b/voluptuous/util.py</span>
<span class="gh">index d2d5a8d..a9e5616 100644</span>
<span class="gd">--- a/voluptuous/util.py</span>
<span class="gi">+++ b/voluptuous/util.py</span>
<span class="gu">@@ -1,5 +1,5 @@</span>
<span class="w"> </span>import typing
<span class="gd">-from voluptuous import validators</span>
<span class="gi">+from voluptuous.validators import Any</span>
<span class="w"> </span>from voluptuous.error import Invalid, LiteralInvalid, TypeInvalid
<span class="w"> </span>from voluptuous.schema_builder import DefaultFactory
<span class="w"> </span>from voluptuous.schema_builder import Schema, default_factory, raises
<span class="gu">@@ -12,7 +12,7 @@ def Lower(v: str) -&gt; str:</span>
<span class="w"> </span>    &gt;&gt;&gt; s(&#39;HI&#39;)
<span class="w"> </span>    &#39;hi&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return str(v).lower()</span>

<span class="w"> </span>def Upper(v: str) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Transform a string to upper case.
<span class="gu">@@ -21,7 +21,7 @@ def Upper(v: str) -&gt; str:</span>
<span class="w"> </span>    &gt;&gt;&gt; s(&#39;hi&#39;)
<span class="w"> </span>    &#39;HI&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return str(v).upper()</span>

<span class="w"> </span>def Capitalize(v: str) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Capitalise a string.
<span class="gu">@@ -30,7 +30,7 @@ def Capitalize(v: str) -&gt; str:</span>
<span class="w"> </span>    &gt;&gt;&gt; s(&#39;hello world&#39;)
<span class="w"> </span>    &#39;Hello world&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return str(v).capitalize()</span>

<span class="w"> </span>def Title(v: str) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Title case a string.
<span class="gu">@@ -39,7 +39,7 @@ def Title(v: str) -&gt; str:</span>
<span class="w"> </span>    &gt;&gt;&gt; s(&#39;hello world&#39;)
<span class="w"> </span>    &#39;Hello World&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return str(v).title()</span>

<span class="w"> </span>def Strip(v: str) -&gt; str:
<span class="w"> </span>    &quot;&quot;&quot;Strip whitespace from a string.
<span class="gu">@@ -48,7 +48,7 @@ def Strip(v: str) -&gt; str:</span>
<span class="w"> </span>    &gt;&gt;&gt; s(&#39;  hello world  &#39;)
<span class="w"> </span>    &#39;hello world&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return str(v).strip()</span>

<span class="w"> </span>class DefaultTo(object):
<span class="w"> </span>    &quot;&quot;&quot;Sets a value to default_value if none provided.
<span class="gu">@@ -76,7 +76,7 @@ class DefaultTo(object):</span>
<span class="w"> </span>class SetTo(object):
<span class="w"> </span>    &quot;&quot;&quot;Set a value, ignoring any previous value.

<span class="gd">-    &gt;&gt;&gt; s = Schema(validators.Any(int, SetTo(42)))</span>
<span class="gi">+    &gt;&gt;&gt; s = Schema(Any(int, SetTo(42)))</span>
<span class="w"> </span>    &gt;&gt;&gt; s(2)
<span class="w"> </span>    2
<span class="w"> </span>    &gt;&gt;&gt; s(&quot;foo&quot;)
<span class="gh">diff --git a/voluptuous/validators.py b/voluptuous/validators.py</span>
<span class="gh">index 22f6981..fb1a055 100644</span>
<span class="gd">--- a/voluptuous/validators.py</span>
<span class="gi">+++ b/voluptuous/validators.py</span>
<span class="gu">@@ -7,7 +7,28 @@ import typing</span>
<span class="w"> </span>from decimal import Decimal, InvalidOperation
<span class="w"> </span>from functools import wraps
<span class="w"> </span>from voluptuous.error import AllInvalid, AnyInvalid, BooleanInvalid, CoerceInvalid, ContainsInvalid, DateInvalid, DatetimeInvalid, DirInvalid, EmailInvalid, ExactSequenceInvalid, FalseInvalid, FileInvalid, InInvalid, Invalid, LengthInvalid, MatchInvalid, MultipleInvalid, NotEnoughValid, NotInInvalid, PathInvalid, RangeInvalid, TooManyValid, TrueInvalid, TypeInvalid, UrlInvalid
<span class="gd">-from voluptuous.schema_builder import Schema, Schemable, message, raises</span>
<span class="gi">+from voluptuous.schema_builder import Schema, Schemable, raises</span>
<span class="gi">+</span>
<span class="gi">+def message(msg: str, cls: typing.Optional[typing.Type[Invalid]]=None):</span>
<span class="gi">+    &quot;&quot;&quot;Decorate a function with a message to be displayed in case of error.</span>
<span class="gi">+</span>
<span class="gi">+    &gt;&gt;&gt; @message(&#39;not an integer&#39;)</span>
<span class="gi">+    ... def isint(v):</span>
<span class="gi">+    ...   return int(v)</span>
<span class="gi">+    &gt;&gt;&gt;</span>
<span class="gi">+    &gt;&gt;&gt; validate = Schema(isint())</span>
<span class="gi">+    &gt;&gt;&gt; with raises(MultipleInvalid, &#39;not an integer&#39;):</span>
<span class="gi">+    ...   validate(&#39;a&#39;)</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+    def decorator(f):</span>
<span class="gi">+        @wraps(f)</span>
<span class="gi">+        def check(v, *args, **kwargs):</span>
<span class="gi">+            try:</span>
<span class="gi">+                return f(v, *args, **kwargs)</span>
<span class="gi">+            except (ValueError, TypeError):</span>
<span class="gi">+                raise (cls or Invalid)(msg)</span>
<span class="gi">+        return check</span>
<span class="gi">+    return decorator</span>
<span class="w"> </span>if typing.TYPE_CHECKING:
<span class="w"> </span>    from _typeshed import SupportsAllComparisons
<span class="w"> </span>Enum: typing.Union[type, None]
<span class="gu">@@ -36,7 +57,13 @@ def truth(f: typing.Callable) -&gt; typing.Callable:</span>
<span class="w"> </span>    &gt;&gt;&gt; with raises(MultipleInvalid, &#39;not a valid value&#39;):
<span class="w"> </span>    ...   validate(&#39;/notavaliddir&#39;)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def validator(path, data):</span>
<span class="gi">+        t = f(data)</span>
<span class="gi">+        if not t:</span>
<span class="gi">+            raise Invalid(&#39;not a valid value&#39;, path)</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+    return validator</span>

<span class="w"> </span>class Coerce(object):
<span class="w"> </span>    &quot;&quot;&quot;Coerce a value to a type.
<span class="gu">@@ -77,7 +104,6 @@ class Coerce(object):</span>
<span class="w"> </span>        return &#39;Coerce(%s, msg=%r)&#39; % (self.type_name, self.msg)

<span class="w"> </span>@message(&#39;value was not true&#39;, cls=TrueInvalid)
<span class="gd">-@truth</span>
<span class="w"> </span>def IsTrue(v):
<span class="w"> </span>    &quot;&quot;&quot;Assert that a value is true, in the Python sense.

<span class="gu">@@ -100,7 +126,7 @@ def IsTrue(v):</span>
<span class="w"> </span>    ... except MultipleInvalid as e:
<span class="w"> </span>    ...   assert isinstance(e.errors[0], TrueInvalid)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return bool(v)</span>

<span class="w"> </span>@message(&#39;value was not false&#39;, cls=FalseInvalid)
<span class="w"> </span>def IsFalse(v):
<span class="gu">@@ -119,7 +145,7 @@ def IsFalse(v):</span>
<span class="w"> </span>    ... except MultipleInvalid as e:
<span class="w"> </span>    ...   assert isinstance(e.errors[0], FalseInvalid)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return not bool(v)</span>

<span class="w"> </span>@message(&#39;expected boolean&#39;, cls=BooleanInvalid)
<span class="w"> </span>def Boolean(v):
<span class="gu">@@ -142,7 +168,16 @@ def Boolean(v):</span>
<span class="w"> </span>    ... except MultipleInvalid as e:
<span class="w"> </span>    ...   assert isinstance(e.errors[0], BooleanInvalid)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(v, bool):</span>
<span class="gi">+        return v</span>
<span class="gi">+    if isinstance(v, str):</span>
<span class="gi">+        v = v.lower().strip()</span>
<span class="gi">+        if v in (&#39;true&#39;, &#39;1&#39;, &#39;yes&#39;, &#39;on&#39;, &#39;enable&#39;):</span>
<span class="gi">+            return True</span>
<span class="gi">+        if v in (&#39;false&#39;, &#39;0&#39;, &#39;no&#39;, &#39;off&#39;, &#39;disable&#39;):</span>
<span class="gi">+            return False</span>
<span class="gi">+        raise BooleanInvalid(&#39;expected boolean&#39;)</span>
<span class="gi">+    return bool(v)</span>

<span class="w"> </span>class _WithSubValidators(object):
<span class="w"> </span>    &quot;&quot;&quot;Base class for validators that use sub-validators.
<span class="gu">@@ -168,12 +203,20 @@ class _WithSubValidators(object):</span>
<span class="w"> </span>        schema.required = old_required
<span class="w"> </span>        return self._run

<span class="gi">+    def _run(self, path, data):</span>
<span class="gi">+        &quot;&quot;&quot;Run the compiled validators.&quot;&quot;&quot;</span>
<span class="gi">+        return self._exec(self._compiled, data)</span>
<span class="gi">+</span>
<span class="w"> </span>    def __call__(self, v):
<span class="w"> </span>        return self._exec((Schema(val) for val in self.validators), v)

<span class="w"> </span>    def __repr__(self):
<span class="w"> </span>        return &#39;%s(%s, msg=%r)&#39; % (self.__class__.__name__, &#39;, &#39;.join((repr(v) for v in self.validators)), self.msg)

<span class="gi">+    def _exec(self, validators, v):</span>
<span class="gi">+        &quot;&quot;&quot;Execute the validators against the value.&quot;&quot;&quot;</span>
<span class="gi">+        raise NotImplementedError</span>
<span class="gi">+</span>
<span class="w"> </span>class Any(_WithSubValidators):
<span class="w"> </span>    &quot;&quot;&quot;Use the first validated value.

<span class="gu">@@ -198,6 +241,17 @@ class Any(_WithSubValidators):</span>
<span class="w"> </span>    &gt;&gt;&gt; with raises(MultipleInvalid, &quot;Expected 1 2 or 3&quot;):
<span class="w"> </span>    ...   validate(4)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    def _exec(self, validators, v):</span>
<span class="gi">+        errors = []</span>
<span class="gi">+        for validator in validators:</span>
<span class="gi">+            try:</span>
<span class="gi">+                return validator(v)</span>
<span class="gi">+            except Invalid as e:</span>
<span class="gi">+                errors.append(e)</span>
<span class="gi">+        if len(errors) == 1:</span>
<span class="gi">+            raise errors[0]</span>
<span class="gi">+        raise AnyInvalid(self.msg or &#39;no valid value found&#39;)</span>
<span class="w"> </span>Or = Any

<span class="w"> </span>class Union(_WithSubValidators):
<span class="gu">@@ -220,8 +274,63 @@ class Union(_WithSubValidators):</span>

<span class="w"> </span>    Without the discriminant, the exception would be &quot;extra keys not allowed @ data[&#39;b_val&#39;]&quot;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    def _exec(self, validators, v):</span>
<span class="gi">+        if self.discriminant is None:</span>
<span class="gi">+            return Any._exec(self, validators, v)</span>
<span class="gi">+        </span>
<span class="gi">+        filtered = list(self.discriminant(v, [val.schema for val in validators]))</span>
<span class="gi">+        if not filtered:</span>
<span class="gi">+            raise AnyInvalid(self.msg or &#39;no valid value found&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        errors = []</span>
<span class="gi">+        for validator in validators:</span>
<span class="gi">+            if validator.schema in filtered:</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return validator(v)</span>
<span class="gi">+                except Invalid as e:</span>
<span class="gi">+                    errors.append(e)</span>
<span class="gi">+        if len(errors) == 1:</span>
<span class="gi">+            raise errors[0]</span>
<span class="gi">+        raise AnyInvalid(self.msg or &#39;no valid value found&#39;)</span>
<span class="w"> </span>Switch = Union

<span class="gi">+class SomeOf(_WithSubValidators):</span>
<span class="gi">+    &quot;&quot;&quot;Value must pass some of the validators.</span>
<span class="gi">+</span>
<span class="gi">+    :param min_valid: Minimum number of valid values</span>
<span class="gi">+    :param max_valid: Maximum number of valid values</span>
<span class="gi">+    :param msg: Message to deliver to user if validation fails.</span>
<span class="gi">+    :param kwargs: All other keyword arguments are passed to the sub-schema constructors.</span>
<span class="gi">+</span>
<span class="gi">+    &gt;&gt;&gt; validate = Schema(SomeOf(min_valid=1, validators=[1, 2, 3]))</span>
<span class="gi">+    &gt;&gt;&gt; validate(1)</span>
<span class="gi">+    1</span>
<span class="gi">+    &gt;&gt;&gt; with raises(MultipleInvalid, &quot;value did not pass enough validations&quot;):</span>
<span class="gi">+    ...   validate(4)</span>
<span class="gi">+    &quot;&quot;&quot;</span>
<span class="gi">+</span>
<span class="gi">+    def __init__(self, min_valid=None, max_valid=None, *validators, msg=None, required=False, discriminant=None, **kwargs) -&gt; None:</span>
<span class="gi">+        super().__init__(*validators, msg=msg, required=required, discriminant=discriminant, **kwargs)</span>
<span class="gi">+        self.min_valid = min_valid</span>
<span class="gi">+        self.max_valid = max_valid</span>
<span class="gi">+</span>
<span class="gi">+    def _exec(self, validators, v):</span>
<span class="gi">+        valid = []</span>
<span class="gi">+        errors = []</span>
<span class="gi">+        for validator in validators:</span>
<span class="gi">+            try:</span>
<span class="gi">+                valid.append(validator([], v))</span>
<span class="gi">+            except Invalid as e:</span>
<span class="gi">+                errors.append(e)</span>
<span class="gi">+</span>
<span class="gi">+        if self.min_valid is not None and len(valid) &lt; self.min_valid:</span>
<span class="gi">+            raise NotEnoughValid(self.msg or &#39;value did not pass enough validations&#39;)</span>
<span class="gi">+        if self.max_valid is not None and len(valid) &gt; self.max_valid:</span>
<span class="gi">+            raise TooManyValid(self.msg or &#39;value passed too many validations&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        return valid[0] if valid else None</span>
<span class="gi">+</span>
<span class="w"> </span>class All(_WithSubValidators):
<span class="w"> </span>    &quot;&quot;&quot;Value must pass all validators.

<span class="gu">@@ -234,6 +343,20 @@ class All(_WithSubValidators):</span>
<span class="w"> </span>    &gt;&gt;&gt; validate(&#39;10&#39;)
<span class="w"> </span>    10
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+</span>
<span class="gi">+    def _exec(self, validators, v):</span>
<span class="gi">+        value = v</span>
<span class="gi">+        errors = []</span>
<span class="gi">+        for validator in validators:</span>
<span class="gi">+            try:</span>
<span class="gi">+                value = validator(value)</span>
<span class="gi">+            except Invalid as e:</span>
<span class="gi">+                errors.append(e)</span>
<span class="gi">+        if errors:</span>
<span class="gi">+            if len(errors) == 1:</span>
<span class="gi">+                raise errors[0]</span>
<span class="gi">+            raise AllInvalid(self.msg or &#39;value did not pass all validators&#39;)</span>
<span class="gi">+        return value</span>
<span class="w"> </span>And = All

<span class="w"> </span>class Match(object):
<span class="gu">@@ -296,7 +419,7 @@ class Replace(object):</span>
<span class="w"> </span>        return &#39;Replace(%r, %r, msg=%r)&#39; % (self.pattern.pattern, self.substitution, self.msg)

<span class="w"> </span>@message(&#39;expected an email address&#39;, cls=EmailInvalid)
<span class="gd">-def Email(v):</span>
<span class="gi">+def Email(v=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Verify that the value is an email address or not.

<span class="w"> </span>    &gt;&gt;&gt; s = Schema(Email())
<span class="gu">@@ -309,10 +432,32 @@ def Email(v):</span>
<span class="w"> </span>    &gt;&gt;&gt; s(&#39;t@x.com&#39;)
<span class="w"> </span>    &#39;t@x.com&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def validate_email(path, data):</span>
<span class="gi">+        if not isinstance(data, str):</span>
<span class="gi">+            raise EmailInvalid(&#39;expected an email address&#39;, path)</span>
<span class="gi">+        </span>
<span class="gi">+        if not data or &#39;@&#39; not in data:</span>
<span class="gi">+            raise EmailInvalid(&#39;expected an email address&#39;, path)</span>
<span class="gi">+        </span>
<span class="gi">+        user_part, domain_part = data.rsplit(&#39;@&#39;, 1)</span>
<span class="gi">+        </span>
<span class="gi">+        if not user_part or not domain_part:</span>
<span class="gi">+            raise EmailInvalid(&#39;expected an email address&#39;, path)</span>
<span class="gi">+        </span>
<span class="gi">+        if not USER_REGEX.match(user_part):</span>
<span class="gi">+            raise EmailInvalid(&#39;expected an email address&#39;, path)</span>
<span class="gi">+        </span>
<span class="gi">+        if not DOMAIN_REGEX.match(domain_part):</span>
<span class="gi">+            raise EmailInvalid(&#39;expected an email address&#39;, path)</span>
<span class="gi">+        </span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+    if v is None:</span>
<span class="gi">+        return validate_email</span>
<span class="gi">+    return validate_email([], v)</span>

<span class="w"> </span>@message(&#39;expected a fully qualified domain name URL&#39;, cls=UrlInvalid)
<span class="gd">-def FqdnUrl(v):</span>
<span class="gi">+def FqdnUrl(v=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Verify that the value is a fully qualified domain name URL.

<span class="w"> </span>    &gt;&gt;&gt; s = Schema(FqdnUrl())
<span class="gu">@@ -321,10 +466,29 @@ def FqdnUrl(v):</span>
<span class="w"> </span>    &gt;&gt;&gt; s(&#39;http://w3.org&#39;)
<span class="w"> </span>    &#39;http://w3.org&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def validate_fqdn_url(path, data):</span>
<span class="gi">+        if not isinstance(data, str):</span>
<span class="gi">+            raise UrlInvalid(&#39;expected a fully qualified domain name URL&#39;, path)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            parsed = urlparse.urlparse(data)</span>
<span class="gi">+            if not parsed.scheme or not parsed.netloc:</span>
<span class="gi">+                raise UrlInvalid(&#39;expected a fully qualified domain name URL&#39;, path)</span>
<span class="gi">+            if parsed.netloc == &#39;localhost&#39;:</span>
<span class="gi">+                raise UrlInvalid(&#39;expected a fully qualified domain name URL&#39;, path)</span>
<span class="gi">+            if not DOMAIN_REGEX.match(parsed.netloc):</span>
<span class="gi">+                raise UrlInvalid(&#39;expected a fully qualified domain name URL&#39;, path)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            raise UrlInvalid(&#39;expected a fully qualified domain name URL&#39;, path)</span>
<span class="gi">+</span>
<span class="gi">+        return data</span>
<span class="gi">+</span>
<span class="gi">+    if v is None:</span>
<span class="gi">+        return validate_fqdn_url</span>
<span class="gi">+    return validate_fqdn_url([], v)</span>

<span class="w"> </span>@message(&#39;expected a URL&#39;, cls=UrlInvalid)
<span class="gd">-def Url(v):</span>
<span class="gi">+def Url(v=None):</span>
<span class="w"> </span>    &quot;&quot;&quot;Verify that the value is a URL.

<span class="w"> </span>    &gt;&gt;&gt; s = Schema(Url())
<span class="gu">@@ -333,7 +497,22 @@ def Url(v):</span>
<span class="w"> </span>    &gt;&gt;&gt; s(&#39;http://w3.org&#39;)
<span class="w"> </span>    &#39;http://w3.org&#39;
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def validate_url(v):</span>
<span class="gi">+        if not isinstance(v, str):</span>
<span class="gi">+            raise UrlInvalid(&#39;expected a URL&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            parsed = urlparse.urlparse(v)</span>
<span class="gi">+            if not parsed.scheme or not parsed.netloc:</span>
<span class="gi">+                raise UrlInvalid(&#39;expected a URL&#39;)</span>
<span class="gi">+        except Exception:</span>
<span class="gi">+            raise UrlInvalid(&#39;expected a URL&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        return v</span>
<span class="gi">+</span>
<span class="gi">+    if v is None:</span>
<span class="gi">+        return validate_url</span>
<span class="gi">+    return validate_url(v)</span>

<span class="w"> </span>@message(&#39;Not a file&#39;, cls=FileInvalid)
<span class="w"> </span>@truth
<span class="gu">@@ -347,7 +526,9 @@ def IsFile(v):</span>
<span class="w"> </span>    &gt;&gt;&gt; with raises(FileInvalid, &#39;Not a file&#39;):
<span class="w"> </span>    ...   IsFile()(None)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if v is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+    return os.path.isfile(str(v))</span>

<span class="w"> </span>@message(&#39;Not a directory&#39;, cls=DirInvalid)
<span class="w"> </span>@truth
<span class="gu">@@ -359,7 +540,9 @@ def IsDir(v):</span>
<span class="w"> </span>    &gt;&gt;&gt; with raises(DirInvalid, &#39;Not a directory&#39;):
<span class="w"> </span>    ...   IsDir()(None)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if v is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+    return os.path.isdir(str(v))</span>

<span class="w"> </span>@message(&#39;path does not exist&#39;, cls=PathInvalid)
<span class="w"> </span>@truth
<span class="gu">@@ -373,7 +556,9 @@ def PathExists(v):</span>
<span class="w"> </span>    &gt;&gt;&gt; with raises(PathInvalid, &#39;Not a Path&#39;):
<span class="w"> </span>    ...   PathExists()(None)
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if v is None:</span>
<span class="gi">+        return False</span>
<span class="gi">+    return os.path.exists(str(v))</span>

<span class="w"> </span>def Maybe(validator: Schemable, msg: typing.Optional[str]=None):
<span class="w"> </span>    &quot;&quot;&quot;Validate that the object matches given validator or is None.
<span class="gu">@@ -388,7 +573,14 @@ def Maybe(validator: Schemable, msg: typing.Optional[str]=None):</span>
<span class="w"> </span>    ...  s(&quot;string&quot;)

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    schema = Schema(validator)</span>
<span class="gi">+</span>
<span class="gi">+    def validate_or_none(v):</span>
<span class="gi">+        if v is None:</span>
<span class="gi">+            return v</span>
<span class="gi">+        return schema(v)</span>
<span class="gi">+</span>
<span class="gi">+    return validate_or_none</span>

<span class="w"> </span>class Range(object):
<span class="w"> </span>    &quot;&quot;&quot;Limit a value to a range.
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
        <script src="../javascripts/tablesort.number.js"></script>
      
    
  </body>
</html>