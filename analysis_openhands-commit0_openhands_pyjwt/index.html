
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis openhands commit0 openhands pyjwt - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#openhands-pyjwt" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis openhands commit0 openhands pyjwt
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_advisorypytestadvisorytest_ghsa_ffqj_6fqr_9h24" class="md-nav__link">
    <span class="md-ellipsis">
      test_advisory.py::TestAdvisory::test_ghsa_ffqj_6fqr_9h24
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_algorithmspytestalgorithmstest_ec_jwk_public_and_private_keys_should_parse_and_verify" class="md-nav__link">
    <span class="md-ellipsis">
      test_algorithms.py::TestAlgorithms::test_ec_jwk_public_and_private_keys_should_parse_and_verify
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_algorithmspytestalgorithmstest_ec_jwk_fails_on_invalid_json" class="md-nav__link">
    <span class="md-ellipsis">
      test_algorithms.py::TestAlgorithms::test_ec_jwk_fails_on_invalid_json
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_algorithmspytestalgorithmstest_ec_to_jwk_raises_exception_on_invalid_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_algorithms.py::TestAlgorithms::test_ec_to_jwk_raises_exception_on_invalid_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_algorithmspytestalgorithmstest_ec_to_jwk_with_valid_curvesfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_algorithms.py::TestAlgorithms::test_ec_to_jwk_with_valid_curves[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_algorithmspytestalgorithmstest_ec_to_jwk_with_valid_curvestrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_algorithms.py::TestAlgorithms::test_ec_to_jwk_with_valid_curves[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_algorithmspytestalgorithmstest_ec_to_jwk_with_invalid_curve" class="md-nav__link">
    <span class="md-ellipsis">
      test_algorithms.py::TestAlgorithms::test_ec_to_jwk_with_invalid_curve
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_algorithmspytestalgorithmstest_rsa_jwk_private_key_with_other_primes_is_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_algorithms.py::TestAlgorithms::test_rsa_jwk_private_key_with_other_primes_is_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_algorithmspytestalgorithmstest_rsa_jwk_private_key_with_missing_values_is_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_algorithms.py::TestAlgorithms::test_rsa_jwk_private_key_with_missing_values_is_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_algorithmspytestalgorithmstest_rsa_jwk_private_key_can_recover_prime_factors" class="md-nav__link">
    <span class="md-ellipsis">
      test_algorithms.py::TestAlgorithms::test_rsa_jwk_private_key_can_recover_prime_factors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_algorithmspytestalgorithmstest_rsa_jwk_private_key_with_missing_required_values_is_invalid" class="md-nav__link">
    <span class="md-ellipsis">
      test_algorithms.py::TestAlgorithms::test_rsa_jwk_private_key_with_missing_required_values_is_invalid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_algorithmspytestalgorithmstest_rsa_jwk_raises_exception_if_not_a_valid_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_algorithms.py::TestAlgorithms::test_rsa_jwk_raises_exception_if_not_a_valid_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_algorithmspytestalgorithmstest_rsa_to_jwk_returns_correct_values_for_public_keyfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_algorithms.py::TestAlgorithms::test_rsa_to_jwk_returns_correct_values_for_public_key[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_algorithmspytestalgorithmstest_rsa_to_jwk_returns_correct_values_for_public_keytrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_algorithms.py::TestAlgorithms::test_rsa_to_jwk_returns_correct_values_for_public_key[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_algorithmspytestalgorithmstest_rsa_to_jwk_returns_correct_values_for_private_keyfalse" class="md-nav__link">
    <span class="md-ellipsis">
      test_algorithms.py::TestAlgorithms::test_rsa_to_jwk_returns_correct_values_for_private_key[False]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_algorithmspytestalgorithmstest_rsa_to_jwk_returns_correct_values_for_private_keytrue" class="md-nav__link">
    <span class="md-ellipsis">
      test_algorithms.py::TestAlgorithms::test_rsa_to_jwk_returns_correct_values_for_private_key[True]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_algorithmspytestalgorithmstest_rsa_to_jwk_raises_exception_on_invalid_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_algorithms.py::TestAlgorithms::test_rsa_to_jwk_raises_exception_on_invalid_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_algorithmspytestalgorithmstest_ec_should_throw_exception_on_wrong_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_algorithms.py::TestAlgorithms::test_ec_should_throw_exception_on_wrong_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_algorithmspytestokpalgorithmstest_okp_ed25519_should_reject_non_string_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_algorithms.py::TestOKPAlgorithms::test_okp_ed25519_should_reject_non_string_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_algorithmspytestokpalgorithmstest_okp_ed25519_jwk_fails_on_invalid_json" class="md-nav__link">
    <span class="md-ellipsis">
      test_algorithms.py::TestOKPAlgorithms::test_okp_ed25519_jwk_fails_on_invalid_json
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_algorithmspytestokpalgorithmstest_okp_to_jwk_raises_exception_on_invalid_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_algorithms.py::TestOKPAlgorithms::test_okp_to_jwk_raises_exception_on_invalid_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_algorithmspytestokpalgorithmstest_okp_ed448_jwk_fails_on_invalid_json" class="md-nav__link">
    <span class="md-ellipsis">
      test_algorithms.py::TestOKPAlgorithms::test_okp_ed448_jwk_fails_on_invalid_json
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwkpytestpyjwktest_should_load_key_ec_secp256k1_from_dict" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwk.py::TestPyJWK::test_should_load_key_ec_secp256k1_from_dict
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwspytestjwstest_non_object_options_dont_persist" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jws.py::TestJWS::test_non_object_options_dont_persist
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwspytestjwstest_decode_missing_segments_throws_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jws.py::TestJWS::test_decode_missing_segments_throws_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwspytestjwstest_encode_algorithm_param_should_be_case_sensitive" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jws.py::TestJWS::test_encode_algorithm_param_should_be_case_sensitive
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwspytestjwstest_encode_with_headers_alg_none" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jws.py::TestJWS::test_encode_with_headers_alg_none
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwspytestjwstest_encode_with_headers_alg_es256" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jws.py::TestJWS::test_encode_with_headers_alg_es256
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwspytestjwstest_encode_with_alg_hs256_and_headers_alg_es256" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jws.py::TestJWS::test_encode_with_alg_hs256_and_headers_alg_es256
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwspytestjwstest_bad_secret" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jws.py::TestJWS::test_bad_secret
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwspytestjwstest_decode_with_optional_algorithms" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jws.py::TestJWS::test_decode_with_optional_algorithms
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwspytestjwstest_load_no_verification" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jws.py::TestJWS::test_load_no_verification
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwspytestjwstest_no_secret" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jws.py::TestJWS::test_no_secret
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwspytestjwstest_verify_signature_with_no_secret" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jws.py::TestJWS::test_verify_signature_with_no_secret
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwspytestjwstest_verify_signature_with_no_algo_header_throws_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jws.py::TestJWS::test_verify_signature_with_no_algo_header_throws_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwspytestjwstest_invalid_crypto_alg" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jws.py::TestJWS::test_invalid_crypto_alg
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwspytestjwstest_unicode_secret" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jws.py::TestJWS::test_unicode_secret
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwspytestjwstest_nonascii_secret" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jws.py::TestJWS::test_nonascii_secret
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwspytestjwstest_bytes_secret" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jws.py::TestJWS::test_bytes_secret
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwspytestjwstest_get_unverified_header_fails_on_bad_header_types" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jws.py::TestJWS::test_get_unverified_header_fails_on_bad_header_types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwspytestjwstest_encode_decode_ecdsa_related_algorithmses256k" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jws.py::TestJWS::test_encode_decode_ecdsa_related_algorithms[ES256K]
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwspytestjwstest_ecdsa_related_algorithms" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jws.py::TestJWS::test_ecdsa_related_algorithms
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwspytestjwstest_encode_fails_on_invalid_kid_types" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jws.py::TestJWS::test_encode_fails_on_invalid_kid_types
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwspytestjwstest_encode_detached_content_with_b64_header" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jws.py::TestJWS::test_encode_detached_content_with_b64_header
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwspytestjwstest_decode_detached_content_without_proper_argument" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jws.py::TestJWS::test_decode_detached_content_without_proper_argument
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_with_invalid_audience_param_throws_exception" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_with_invalid_audience_param_throws_exception
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_raises_exception_if_exp_is_not_int" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_raises_exception_if_exp_is_not_int
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_raises_exception_if_iat_is_not_int" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_raises_exception_if_iat_is_not_int
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_raises_exception_if_iat_is_greater_than_now" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_raises_exception_if_iat_is_greater_than_now
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_works_if_iat_is_str_of_a_number" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_works_if_iat_is_str_of_a_number
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_raises_exception_if_nbf_is_not_int" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_raises_exception_if_nbf_is_not_int
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_encode_datetime" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_encode_datetime
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_with_expiration" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_with_expiration
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_with_notbefore" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_with_notbefore
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_skip_expiration_verification" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_skip_expiration_verification
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_skip_notbefore_verification" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_skip_notbefore_verification
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_with_expiration_with_leeway" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_with_expiration_with_leeway
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_with_notbefore_with_leeway" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_with_notbefore_with_leeway
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_check_audience_when_valid" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_check_audience_when_valid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_check_audience_list_when_valid" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_check_audience_list_when_valid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_check_audience_none_specified" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_check_audience_none_specified
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_raise_exception_invalid_audience_list" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_raise_exception_invalid_audience_list
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_check_audience_in_array_when_valid" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_check_audience_in_array_when_valid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_raise_exception_invalid_audience" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_raise_exception_invalid_audience
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_raise_exception_audience_as_bytes" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_raise_exception_audience_as_bytes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_raise_exception_invalid_audience_in_array" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_raise_exception_invalid_audience_in_array
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_raise_exception_token_without_issuer" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_raise_exception_token_without_issuer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_raise_exception_token_without_audience" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_raise_exception_token_without_audience
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_raise_exception_token_with_aud_none_and_without_audience" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_raise_exception_token_with_aud_none_and_without_audience
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_check_issuer_when_valid" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_check_issuer_when_valid
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_raise_exception_invalid_issuer" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_raise_exception_invalid_issuer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_skip_check_audience" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_skip_check_audience
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_skip_check_exp" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_skip_check_exp
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_should_raise_error_if_exp_required_but_not_present" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_should_raise_error_if_exp_required_but_not_present
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_should_raise_error_if_iat_required_but_not_present" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_should_raise_error_if_iat_required_but_not_present
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_should_raise_error_if_nbf_required_but_not_present" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_should_raise_error_if_nbf_required_but_not_present
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_skip_check_iat" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_skip_check_iat
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_skip_check_nbf" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_skip_check_nbf
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_custom_json_encoder" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_custom_json_encoder
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_with_verify_exp_option" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_with_verify_exp_option
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_with_verify_exp_option_and_signature_off" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_with_verify_exp_option_and_signature_off
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_with_optional_algorithms" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_with_optional_algorithms
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_no_algorithms_verify_signature_false" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_no_algorithms_verify_signature_false
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_legacy_verify_warning" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_legacy_verify_warning
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_no_options_mutation" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_no_options_mutation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_warns_on_unsupported_kwarg" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_warns_on_unsupported_kwarg
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_complete_warns_on_unsupported_kwarg" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_complete_warns_on_unsupported_kwarg
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_strict_aud_forbids_list_audience" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_strict_aud_forbids_list_audience
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_strict_aud_forbids_list_claim" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_strict_aud_forbids_list_claim
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_strict_aud_does_not_match" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_strict_aud_does_not_match
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_api_jwtpytestjwttest_decode_strict_ok" class="md-nav__link">
    <span class="md-ellipsis">
      test_api_jwt.py::TestJWT::test_decode_strict_ok
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_jwks_clientpytestpyjwkclienttest_get_signing_keys_raises_if_none_found" class="md-nav__link">
    <span class="md-ellipsis">
      test_jwks_client.py::TestPyJWKClient::test_get_signing_keys_raises_if_none_found
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_jwks_clientpytestpyjwkclienttest_get_signing_key_from_jwt" class="md-nav__link">
    <span class="md-ellipsis">
      test_jwks_client.py::TestPyJWKClient::test_get_signing_key_from_jwt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_jwks_clientpytestpyjwkclienttest_failed_request_should_raise_connection_error" class="md-nav__link">
    <span class="md-ellipsis">
      test_jwks_client.py::TestPyJWKClient::test_failed_request_should_raise_connection_error
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_jwks_clientpytestpyjwkclienttest_get_jwt_set_refresh_cache" class="md-nav__link">
    <span class="md-ellipsis">
      test_jwks_client.py::TestPyJWKClient::test_get_jwt_set_refresh_cache
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_jwks_clientpytestpyjwkclienttest_get_jwt_set_timeout" class="md-nav__link">
    <span class="md-ellipsis">
      test_jwks_client.py::TestPyJWKClient::test_get_jwt_set_timeout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_utilspytest_to_base64url_uint-1-" class="md-nav__link">
    <span class="md-ellipsis">
      test_utils.py::test_to_base64url_uint[-1-]
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_openhands-commit0_openhands">back to OpenHands summary</a></p>
<h1 id="openhands-pyjwt"><strong>OpenHands</strong>: pyjwt</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">96</td>
</tr>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">163</td>
</tr>
<tr>
<td style="text-align: left;">skipped</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: left;">xfailed</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">262</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">262</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_advisorypytestadvisorytest_ghsa_ffqj_6fqr_9h24">test_advisory.py::TestAdvisory::test_ghsa_ffqj_6fqr_9h24</h3>
<details><summary> <pre>test_advisory.py::TestAdvisory::test_ghsa_ffqj_6fqr_9h24</pre></summary><pre>
self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0ZXN0IjoxMjM0fQ.6ulDpqSlbHmQ8bZXhZRLFko9SwcHrghCwh8d-exJEE4'
key = b'ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIPL1I9oiq+B8crkmuV4YViiUnhdLjCp3hvy1bNGuGfNL'
algorithms = ['none', 'HS256', 'HS384', 'HS512', 'RS256', 'RS384', ...]
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0ZXN0IjoxMjM0fQ'
crypto_segment = b'6ulDpqSlbHmQ8bZXhZRLFko9SwcHrghCwh8d-exJEE4'

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
            raise InvalidAlgorithmError('The specified alg value is not allowed')

        if alg == 'none':
            if merged_options['verify_signature']:
                raise DecodeError('Algorithm "none" not allowed')
            if key not in [None, '', 'none']:
                raise InvalidKeyError('When alg = "none", key must be empty or "none"')
            if signature != b'':
                raise InvalidSignatureError('Signature verification failed')
            return {
                'header': header,
                'payload': payload,
                'signature': signature
            }

        try:
            alg_obj = self._algorithms[alg]
        except KeyError:
            raise InvalidAlgorithmError('Algorithm not supported')

        if merged_options['verify_signature']:
            try:
                if key is None:
                    raise InvalidKeyError('Key is required when algorithm is not "none"')
>               key = alg_obj.prepare_key(key)

jwt/api_jws.py:302: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.algorithms.HMACAlgorithm object at 0x7eda898e58b0>
key = b'ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIPL1I9oiq+B8crkmuV4YViiUnhdLjCp3hvy1bNGuGfNL'

    def prepare_key(self, key: Union[str, bytes]) -> bytes:
        if not isinstance(key, (str, bytes)):
            raise TypeError('Expected a string value')
        key = force_bytes(key)
        if is_pem_format(key) or is_ssh_key(key):
>           raise InvalidKeyError('The specified key is an asymmetric key or x509 certificate and should not be used as an HMAC secret.')
E           jwt.exceptions.InvalidKeyError: The specified key is an asymmetric key or x509 certificate and should not be used as an HMAC secret.

jwt/algorithms.py:168: InvalidKeyError

During handling of the above exception, another exception occurred:

self = <tests.test_advisory.TestAdvisory object at 0x7eda89911be0>

    @crypto_required
    def test_ghsa_ffqj_6fqr_9h24(self):
        # Generate ed25519 private key
        # private_key = ed25519.Ed25519PrivateKey.generate()

        # Get private key bytes as they would be stored in a file
        # priv_key_bytes = private_key.private_bytes(
        #     encoding=serialization.Encoding.PEM,
        #     format=serialization.PrivateFormat.PKCS8,
        #     encryption_algorithm=serialization.NoEncryption(),
        # )

        # Get public key bytes as they would be stored in a file
        # pub_key_bytes = private_key.public_key().public_bytes(
        #     encoding=serialization.Encoding.OpenSSH,
        #     format=serialization.PublicFormat.OpenSSH,
        # )

        # Making a good jwt token that should work by signing it
        # with the private key
        # encoded_good = jwt.encode({"test": 1234}, priv_key_bytes, algorithm="EdDSA")
        encoded_good = "eyJ0eXAiOiJKV1QiLCJhbGciOiJFZERTQSJ9.eyJ0ZXN0IjoxMjM0fQ.M5y1EEavZkHSlj9i8yi9nXKKyPBSAUhDRTOYZi3zZY11tZItDaR3qwAye8pc74_lZY3Ogt9KPNFbVOSGnUBHDg"

        # Using HMAC with the public key to trick the receiver to think that the
        # public key is a HMAC secret
        encoded_bad = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0ZXN0IjoxMjM0fQ.6ulDpqSlbHmQ8bZXhZRLFko9SwcHrghCwh8d-exJEE4"

        algorithm_names = list(get_default_algorithms())

        # Both of the jwt tokens are validated as valid
        jwt.decode(
            encoded_good,
            pub_key_bytes,
            algorithms=algorithm_names,
        )

        with pytest.raises(InvalidKeyError):
>           jwt.decode(
                encoded_bad,
                pub_key_bytes,
                algorithms=algorithm_names,
            )

tests/test_advisory.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0ZXN0IjoxMjM0fQ.6ulDpqSlbHmQ8bZXhZRLFko9SwcHrghCwh8d-exJEE4'
key = b'ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIPL1I9oiq+B8crkmuV4YViiUnhdLjCp3hvy1bNGuGfNL'
algorithms = ['none', 'HS256', 'HS384', 'HS512', 'RS256', 'RS384', ...]
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0ZXN0IjoxMjM0fQ'
crypto_segment = b'6ulDpqSlbHmQ8bZXhZRLFko9SwcHrghCwh8d-exJEE4'

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
            raise InvalidAlgorithmError('The specified alg value is not allowed')

        if alg == 'none':
            if merged_options['verify_signature']:
                raise DecodeError('Algorithm "none" not allowed')
            if key not in [None, '', 'none']:
                raise InvalidKeyError('When alg = "none", key must be empty or "none"')
            if signature != b'':
                raise InvalidSignatureError('Signature verification failed')
            return {
                'header': header,
                'payload': payload,
                'signature': signature
            }

        try:
            alg_obj = self._algorithms[alg]
        except KeyError:
            raise InvalidAlgorithmError('Algorithm not supported')

        if merged_options['verify_signature']:
            try:
                if key is None:
                    raise InvalidKeyError('Key is required when algorithm is not "none"')
                key = alg_obj.prepare_key(key)
>           except InvalidKeyError:
E           NameError: name 'InvalidKeyError' is not defined

jwt/api_jws.py:303: NameError
</pre>
</details>
<h3 id="test_algorithmspytestalgorithmstest_ec_jwk_public_and_private_keys_should_parse_and_verify">test_algorithms.py::TestAlgorithms::test_ec_jwk_public_and_private_keys_should_parse_and_verify</h3>
<details><summary> <pre>test_algorithms.py::TestAlgorithms::test_ec_jwk_public_and_private_keys_should_parse_and_verify</pre></summary><pre>
self = <tests.test_algorithms.TestAlgorithms object at 0x7eda89755040>

    @crypto_required
    def test_ec_jwk_public_and_private_keys_should_parse_and_verify(self):
        tests = {
            "P-256": ECAlgorithm.SHA256,
            "P-384": ECAlgorithm.SHA384,
            "P-521": ECAlgorithm.SHA512,
            "secp256k1": ECAlgorithm.SHA256,
        }
        for curve, hash in tests.items():
            algo = ECAlgorithm(hash)

            with open(key_path(f"jwk_ec_pub_{curve}.json")) as keyfile:
>               pub_key = cast(EllipticCurvePublicKey, algo.from_jwk(keyfile.read()))

tests/test_algorithms.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

jwk = {'crv': 'secp256k1', 'kid': 'bilbo.baggins.256k@hobbiton.example', 'kty': 'EC', 'x': 'MLnVyPDPQpNm0KaaO4iEh0i8JItHXJE0NcIe8GK1SYs', ...}

    @staticmethod
    def from_jwk(jwk: Union[str, JWKDict]) -> Union[EllipticCurvePrivateKey, EllipticCurvePublicKey]:
        if isinstance(jwk, str):
            jwk = json.loads(jwk)
        if not isinstance(jwk, dict):
            raise InvalidKeyError('Key must be a dict or a string')
        if jwk.get('kty') != 'EC':
            raise InvalidKeyError('Not an EC key')

>       curve = {
            'P-256K': SECP256K1,
            'P-256': SECP256R1,
            'P-384': SECP384R1,
            'P-521': SECP521R1
        }[jwk['crv']]()
E       KeyError: 'secp256k1'

jwt/algorithms.py:421: KeyError
</pre>
</details>
<h3 id="test_algorithmspytestalgorithmstest_ec_jwk_fails_on_invalid_json">test_algorithms.py::TestAlgorithms::test_ec_jwk_fails_on_invalid_json</h3>
<details><summary> <pre>test_algorithms.py::TestAlgorithms::test_ec_jwk_fails_on_invalid_json</pre></summary><pre>
self = <tests.test_algorithms.TestAlgorithms object at 0x7eda89754d10>

    @crypto_required
    def test_ec_jwk_fails_on_invalid_json(self):
        algo = ECAlgorithm(ECAlgorithm.SHA512)

        valid_points = {
            "P-256": {
                "x": "PTTjIY84aLtaZCxLTrG_d8I0G6YKCV7lg8M4xkKfwQ4",
                "y": "ank6KA34vv24HZLXlChVs85NEGlpg2sbqNmR_BcgyJU",
            },
            "P-384": {
                "x": "IDC-5s6FERlbC4Nc_4JhKW8sd51AhixtMdNUtPxhRFP323QY6cwWeIA3leyZhz-J",
                "y": "eovmN9ocANS8IJxDAGSuC1FehTq5ZFLJU7XSPg36zHpv4H2byKGEcCBiwT4sFJsy",
            },
            "P-521": {
                "x": "AHKZLLOsCOzz5cY97ewNUajB957y-C-U88c3v13nmGZx6sYl_oJXu9A5RkTKqjqvjyekWF-7ytDyRXYgCF5cj0Kt",
                "y": "AdymlHvOiLxXkEhayXQnNCvDX4h9htZaCJN34kfmC6pV5OhQHiraVySsUdaQkAgDPrwQrJmbnX9cwlGfP-HqHZR1",
            },
            "secp256k1": {
                "x": "MLnVyPDPQpNm0KaaO4iEh0i8JItHXJE0NcIe8GK1SYs",
                "y": "7r8d-xF7QAgT5kSRdly6M8xeg4Jz83Gs_CQPQRH65QI",
            },
        }

        # Invalid JSON
        with pytest.raises(InvalidKeyError):
>           algo.from_jwk("<this isn't json>")

tests/test_algorithms.py:207: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/algorithms.py:415: in from_jwk
    jwk = json.loads(jwk)
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/__init__.py:346: in loads
    return _default_decoder.decode(s)
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7eda89d2fa10>
s = "<this isn't json>", idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.

        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.

        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/decoder.py:355: JSONDecodeError
</pre>
</details>
<h3 id="test_algorithmspytestalgorithmstest_ec_to_jwk_raises_exception_on_invalid_key">test_algorithms.py::TestAlgorithms::test_ec_to_jwk_raises_exception_on_invalid_key</h3>
<details><summary> <pre>test_algorithms.py::TestAlgorithms::test_ec_to_jwk_raises_exception_on_invalid_key</pre></summary><pre>
self = <tests.test_algorithms.TestAlgorithms object at 0x7eda89627b90>

    @crypto_required
    def test_ec_to_jwk_raises_exception_on_invalid_key(self):
        algo = ECAlgorithm(ECAlgorithm.SHA256)

        with pytest.raises(InvalidKeyError):
>           algo.to_jwk({"not": "a valid key"})  # type: ignore[call-overload]

tests/test_algorithms.py:317: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

key_obj = {'not': 'a valid key'}, as_dict = False

    @staticmethod
    def to_jwk(key_obj: Union[EllipticCurvePrivateKey, EllipticCurvePublicKey], as_dict: bool = False) -> Union[str, JWKDict]:
        if isinstance(key_obj, EllipticCurvePrivateKey):
            numbers = key_obj.private_numbers()
            jwk = {
                'kty': 'EC',
                'crv': {
                    SECP256K1: 'P-256K',
                    SECP256R1: 'P-256',
                    SECP384R1: 'P-384',
                    SECP521R1: 'P-521'
                }[type(numbers.public_numbers.curve)],
                'x': to_base64url_uint(numbers.public_numbers.x).decode('ascii'),
                'y': to_base64url_uint(numbers.public_numbers.y).decode('ascii'),
                'd': to_base64url_uint(numbers.private_value).decode('ascii')
            }
        else:
>           numbers = key_obj.public_numbers()
E           AttributeError: 'dict' object has no attribute 'public_numbers'

jwt/algorithms.py:395: AttributeError
</pre>
</details>
<h3 id="test_algorithmspytestalgorithmstest_ec_to_jwk_with_valid_curvesfalse">test_algorithms.py::TestAlgorithms::test_ec_to_jwk_with_valid_curves[False]</h3>
<details><summary> <pre>test_algorithms.py::TestAlgorithms::test_ec_to_jwk_with_valid_curves[False]</pre></summary><pre>
self = <tests.test_algorithms.TestAlgorithms object at 0x7eda89624e30>
as_dict = False

    @crypto_required
    @pytest.mark.parametrize("as_dict", (False, True))
    def test_ec_to_jwk_with_valid_curves(self, as_dict):
        tests = {
            "P-256": ECAlgorithm.SHA256,
            "P-384": ECAlgorithm.SHA384,
            "P-521": ECAlgorithm.SHA512,
            "secp256k1": ECAlgorithm.SHA256,
        }
        for curve, hash in tests.items():
            algo = ECAlgorithm(hash)

            with open(key_path(f"jwk_ec_pub_{curve}.json")) as keyfile:
>               pub_key = algo.from_jwk(keyfile.read())

tests/test_algorithms.py:332: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

jwk = {'crv': 'secp256k1', 'kid': 'bilbo.baggins.256k@hobbiton.example', 'kty': 'EC', 'x': 'MLnVyPDPQpNm0KaaO4iEh0i8JItHXJE0NcIe8GK1SYs', ...}

    @staticmethod
    def from_jwk(jwk: Union[str, JWKDict]) -> Union[EllipticCurvePrivateKey, EllipticCurvePublicKey]:
        if isinstance(jwk, str):
            jwk = json.loads(jwk)
        if not isinstance(jwk, dict):
            raise InvalidKeyError('Key must be a dict or a string')
        if jwk.get('kty') != 'EC':
            raise InvalidKeyError('Not an EC key')

>       curve = {
            'P-256K': SECP256K1,
            'P-256': SECP256R1,
            'P-384': SECP384R1,
            'P-521': SECP521R1
        }[jwk['crv']]()
E       KeyError: 'secp256k1'

jwt/algorithms.py:421: KeyError
</pre>
</details>
<h3 id="test_algorithmspytestalgorithmstest_ec_to_jwk_with_valid_curvestrue">test_algorithms.py::TestAlgorithms::test_ec_to_jwk_with_valid_curves[True]</h3>
<details><summary> <pre>test_algorithms.py::TestAlgorithms::test_ec_to_jwk_with_valid_curves[True]</pre></summary><pre>
self = <tests.test_algorithms.TestAlgorithms object at 0x7eda89624f80>
as_dict = True

    @crypto_required
    @pytest.mark.parametrize("as_dict", (False, True))
    def test_ec_to_jwk_with_valid_curves(self, as_dict):
        tests = {
            "P-256": ECAlgorithm.SHA256,
            "P-384": ECAlgorithm.SHA384,
            "P-521": ECAlgorithm.SHA512,
            "secp256k1": ECAlgorithm.SHA256,
        }
        for curve, hash in tests.items():
            algo = ECAlgorithm(hash)

            with open(key_path(f"jwk_ec_pub_{curve}.json")) as keyfile:
>               pub_key = algo.from_jwk(keyfile.read())

tests/test_algorithms.py:332: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

jwk = {'crv': 'secp256k1', 'kid': 'bilbo.baggins.256k@hobbiton.example', 'kty': 'EC', 'x': 'MLnVyPDPQpNm0KaaO4iEh0i8JItHXJE0NcIe8GK1SYs', ...}

    @staticmethod
    def from_jwk(jwk: Union[str, JWKDict]) -> Union[EllipticCurvePrivateKey, EllipticCurvePublicKey]:
        if isinstance(jwk, str):
            jwk = json.loads(jwk)
        if not isinstance(jwk, dict):
            raise InvalidKeyError('Key must be a dict or a string')
        if jwk.get('kty') != 'EC':
            raise InvalidKeyError('Not an EC key')

>       curve = {
            'P-256K': SECP256K1,
            'P-256': SECP256R1,
            'P-384': SECP384R1,
            'P-521': SECP521R1
        }[jwk['crv']]()
E       KeyError: 'secp256k1'

jwt/algorithms.py:421: KeyError
</pre>
</details>
<h3 id="test_algorithmspytestalgorithmstest_ec_to_jwk_with_invalid_curve">test_algorithms.py::TestAlgorithms::test_ec_to_jwk_with_invalid_curve</h3>
<details><summary> <pre>test_algorithms.py::TestAlgorithms::test_ec_to_jwk_with_invalid_curve</pre></summary><pre>
self = <tests.test_algorithms.TestAlgorithms object at 0x7eda896250a0>

    @crypto_required
    def test_ec_to_jwk_with_invalid_curve(self):
        algo = ECAlgorithm(ECAlgorithm.SHA256)

        with open(key_path("testkey_ec_secp192r1.priv")) as keyfile:
            priv_key = algo.prepare_key(keyfile.read())

        with pytest.raises(InvalidKeyError):
>           algo.to_jwk(priv_key)

tests/test_algorithms.py:357: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

key_obj = <cryptography.hazmat.bindings._rust.openssl.ec.ECPrivateKey object at 0x7eda88601ff0>
as_dict = False

    @staticmethod
    def to_jwk(key_obj: Union[EllipticCurvePrivateKey, EllipticCurvePublicKey], as_dict: bool = False) -> Union[str, JWKDict]:
        if isinstance(key_obj, EllipticCurvePrivateKey):
            numbers = key_obj.private_numbers()
            jwk = {
                'kty': 'EC',
>               'crv': {
                    SECP256K1: 'P-256K',
                    SECP256R1: 'P-256',
                    SECP384R1: 'P-384',
                    SECP521R1: 'P-521'
                }[type(numbers.public_numbers.curve)],
                'x': to_base64url_uint(numbers.public_numbers.x).decode('ascii'),
                'y': to_base64url_uint(numbers.public_numbers.y).decode('ascii'),
                'd': to_base64url_uint(numbers.private_value).decode('ascii')
            }
E           KeyError: <class 'cryptography.hazmat.primitives.asymmetric.ec.SECP192R1'>

jwt/algorithms.py:384: KeyError
</pre>
</details>
<h3 id="test_algorithmspytestalgorithmstest_rsa_jwk_private_key_with_other_primes_is_invalid">test_algorithms.py::TestAlgorithms::test_rsa_jwk_private_key_with_other_primes_is_invalid</h3>
<details><summary> <pre>test_algorithms.py::TestAlgorithms::test_rsa_jwk_private_key_with_other_primes_is_invalid</pre></summary><pre>
self = <tests.test_algorithms.TestAlgorithms object at 0x7eda89625760>

    @crypto_required
    def test_rsa_jwk_private_key_with_other_primes_is_invalid(self):
        algo = RSAAlgorithm(RSAAlgorithm.SHA256)

        with open(key_path("jwk_rsa_key.json")) as keyfile:
>           with pytest.raises(InvalidKeyError):
E           Failed: DID NOT RAISE <class 'jwt.exceptions.InvalidKeyError'>

tests/test_algorithms.py:401: Failed
</pre>
</details>
<h3 id="test_algorithmspytestalgorithmstest_rsa_jwk_private_key_with_missing_values_is_invalid">test_algorithms.py::TestAlgorithms::test_rsa_jwk_private_key_with_missing_values_is_invalid</h3>
<details><summary> <pre>test_algorithms.py::TestAlgorithms::test_rsa_jwk_private_key_with_missing_values_is_invalid</pre></summary><pre>
self = <tests.test_algorithms.TestAlgorithms object at 0x7eda896258e0>

    @crypto_required
    def test_rsa_jwk_private_key_with_missing_values_is_invalid(self):
        algo = RSAAlgorithm(RSAAlgorithm.SHA256)

        with open(key_path("jwk_rsa_key.json")) as keyfile:
>           with pytest.raises(InvalidKeyError):
E           Failed: DID NOT RAISE <class 'jwt.exceptions.InvalidKeyError'>

tests/test_algorithms.py:412: Failed
</pre>
</details>
<h3 id="test_algorithmspytestalgorithmstest_rsa_jwk_private_key_can_recover_prime_factors">test_algorithms.py::TestAlgorithms::test_rsa_jwk_private_key_can_recover_prime_factors</h3>
<details><summary> <pre>test_algorithms.py::TestAlgorithms::test_rsa_jwk_private_key_can_recover_prime_factors</pre></summary><pre>
self = <tests.test_algorithms.TestAlgorithms object at 0x7eda89625a60>

    @crypto_required
    def test_rsa_jwk_private_key_can_recover_prime_factors(self):
        algo = RSAAlgorithm(RSAAlgorithm.SHA256)

        with open(key_path("jwk_rsa_key.json")) as keyfile:
            keybytes = keyfile.read()
            control_key = cast(RSAPrivateKey, algo.from_jwk(keybytes)).private_numbers()

            keydata = json.loads(keybytes)
            delete_these = ["p", "q", "dp", "dq", "qi"]
            for field in delete_these:
                del keydata[field]

            parsed_key = cast(
                RSAPrivateKey, algo.from_jwk(json.dumps(keydata))
>           ).private_numbers()
E           AttributeError: 'cryptography.hazmat.bindings._rust.openssl.rsa.RSAPublicKey' object has no attribute 'private_numbers'

tests/test_algorithms.py:433: AttributeError
</pre>
</details>
<h3 id="test_algorithmspytestalgorithmstest_rsa_jwk_private_key_with_missing_required_values_is_invalid">test_algorithms.py::TestAlgorithms::test_rsa_jwk_private_key_with_missing_required_values_is_invalid</h3>
<details><summary> <pre>test_algorithms.py::TestAlgorithms::test_rsa_jwk_private_key_with_missing_required_values_is_invalid</pre></summary><pre>
self = <tests.test_algorithms.TestAlgorithms object at 0x7eda89625be0>

    @crypto_required
    def test_rsa_jwk_private_key_with_missing_required_values_is_invalid(self):
        algo = RSAAlgorithm(RSAAlgorithm.SHA256)

        with open(key_path("jwk_rsa_key.json")) as keyfile:
>           with pytest.raises(InvalidKeyError):
E           Failed: DID NOT RAISE <class 'jwt.exceptions.InvalidKeyError'>

tests/test_algorithms.py:447: Failed
</pre>
</details>
<h3 id="test_algorithmspytestalgorithmstest_rsa_jwk_raises_exception_if_not_a_valid_key">test_algorithms.py::TestAlgorithms::test_rsa_jwk_raises_exception_if_not_a_valid_key</h3>
<details><summary> <pre>test_algorithms.py::TestAlgorithms::test_rsa_jwk_raises_exception_if_not_a_valid_key</pre></summary><pre>
self = <tests.test_algorithms.TestAlgorithms object at 0x7eda89625d60>

    @crypto_required
    def test_rsa_jwk_raises_exception_if_not_a_valid_key(self):
        algo = RSAAlgorithm(RSAAlgorithm.SHA256)

        # Invalid JSON
        with pytest.raises(InvalidKeyError):
>           algo.from_jwk("{not-a-real-key")

tests/test_algorithms.py:459: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/algorithms.py:293: in from_jwk
    jwk = json.loads(jwk)
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/__init__.py:346: in loads
    return _default_decoder.decode(s)
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7eda89d2fa10>
s = '{not-a-real-key', idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.

        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.

        """
        try:
>           obj, end = self.scan_once(s, idx)
E           json.decoder.JSONDecodeError: Expecting property name enclosed in double quotes: line 1 column 2 (char 1)

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/decoder.py:353: JSONDecodeError
</pre>
</details>
<h3 id="test_algorithmspytestalgorithmstest_rsa_to_jwk_returns_correct_values_for_public_keyfalse">test_algorithms.py::TestAlgorithms::test_rsa_to_jwk_returns_correct_values_for_public_key[False]</h3>
<details><summary> <pre>test_algorithms.py::TestAlgorithms::test_rsa_to_jwk_returns_correct_values_for_public_key[False]</pre></summary><pre>
self = <tests.test_algorithms.TestAlgorithms object at 0x7eda897543b0>
as_dict = False

    @crypto_required
    @pytest.mark.parametrize("as_dict", (False, True))
    def test_rsa_to_jwk_returns_correct_values_for_public_key(self, as_dict):
        algo = RSAAlgorithm(RSAAlgorithm.SHA256)

        with open(key_path("testkey_rsa.pub")) as keyfile:
            pub_key = algo.prepare_key(keyfile.read())

        key: Any = algo.to_jwk(pub_key, as_dict=as_dict)

        if not as_dict:
            key = json.loads(key)

        expected = {
            "e": "AQAB",
            "key_ops": ["verify"],
            "kty": "RSA",
            "n": (
                "1HgzBfJv2cOjQryCwe8NEelriOTNFWKZUivevUrRhlqcmZJdCvuCJRr-xCN-"
                "OmO8qwgJJR98feNujxVg-J9Ls3_UOA4HcF9nYH6aqVXELAE8Hk_ALvxi96ms"
                "1DDuAvQGaYZ-lANxlvxeQFOZSbjkz_9mh8aLeGKwqJLp3p-OhUBQpwvAUAPg"
                "82-OUtgTW3nSljjeFr14B8qAneGSc_wl0ni--1SRZUXFSovzcqQOkla3W27r"
                "rLfrD6LXgj_TsDs4vD1PnIm1zcVenKT7TfYI17bsG_O_Wecwz2Nl19pL7gDo"
                "sNruF3ogJWNq1Lyn_ijPQnkPLpZHyhvuiycYcI3DiQ"
            ),
        }
>       assert key == expected
E       AssertionError: assert {'e': 'AQAB',...vuiycYcI3DiQ'} == {'e': 'AQAB',...vuiycYcI3DiQ'}
E         
E         Omitting 3 identical items, use -vv to show
E         Right contains 1 more item:
E         {'key_ops': ['verify']}
E         Use -v to get more diff

tests/test_algorithms.py:491: AssertionError
</pre>
</details>
<h3 id="test_algorithmspytestalgorithmstest_rsa_to_jwk_returns_correct_values_for_public_keytrue">test_algorithms.py::TestAlgorithms::test_rsa_to_jwk_returns_correct_values_for_public_key[True]</h3>
<details><summary> <pre>test_algorithms.py::TestAlgorithms::test_rsa_to_jwk_returns_correct_values_for_public_key[True]</pre></summary><pre>
self = <tests.test_algorithms.TestAlgorithms object at 0x7eda89754b90>
as_dict = True

    @crypto_required
    @pytest.mark.parametrize("as_dict", (False, True))
    def test_rsa_to_jwk_returns_correct_values_for_public_key(self, as_dict):
        algo = RSAAlgorithm(RSAAlgorithm.SHA256)

        with open(key_path("testkey_rsa.pub")) as keyfile:
            pub_key = algo.prepare_key(keyfile.read())

        key: Any = algo.to_jwk(pub_key, as_dict=as_dict)

        if not as_dict:
            key = json.loads(key)

        expected = {
            "e": "AQAB",
            "key_ops": ["verify"],
            "kty": "RSA",
            "n": (
                "1HgzBfJv2cOjQryCwe8NEelriOTNFWKZUivevUrRhlqcmZJdCvuCJRr-xCN-"
                "OmO8qwgJJR98feNujxVg-J9Ls3_UOA4HcF9nYH6aqVXELAE8Hk_ALvxi96ms"
                "1DDuAvQGaYZ-lANxlvxeQFOZSbjkz_9mh8aLeGKwqJLp3p-OhUBQpwvAUAPg"
                "82-OUtgTW3nSljjeFr14B8qAneGSc_wl0ni--1SRZUXFSovzcqQOkla3W27r"
                "rLfrD6LXgj_TsDs4vD1PnIm1zcVenKT7TfYI17bsG_O_Wecwz2Nl19pL7gDo"
                "sNruF3ogJWNq1Lyn_ijPQnkPLpZHyhvuiycYcI3DiQ"
            ),
        }
>       assert key == expected
E       AssertionError: assert {'e': 'AQAB',...vuiycYcI3DiQ'} == {'e': 'AQAB',...vuiycYcI3DiQ'}
E         
E         Omitting 3 identical items, use -vv to show
E         Right contains 1 more item:
E         {'key_ops': ['verify']}
E         Use -v to get more diff

tests/test_algorithms.py:491: AssertionError
</pre>
</details>
<h3 id="test_algorithmspytestalgorithmstest_rsa_to_jwk_returns_correct_values_for_private_keyfalse">test_algorithms.py::TestAlgorithms::test_rsa_to_jwk_returns_correct_values_for_private_key[False]</h3>
<details><summary> <pre>test_algorithms.py::TestAlgorithms::test_rsa_to_jwk_returns_correct_values_for_private_key[False]</pre></summary><pre>
self = <tests.test_algorithms.TestAlgorithms object at 0x7eda89754d70>
as_dict = False

    @crypto_required
    @pytest.mark.parametrize("as_dict", (False, True))
    def test_rsa_to_jwk_returns_correct_values_for_private_key(self, as_dict):
        algo = RSAAlgorithm(RSAAlgorithm.SHA256)

        with open(key_path("testkey_rsa.priv")) as keyfile:
            priv_key = algo.prepare_key(keyfile.read())

        key: Any = algo.to_jwk(priv_key, as_dict=as_dict)

        if not as_dict:
            key = json.loads(key)

        expected = {
            "key_ops": ["sign"],
            "kty": "RSA",
            "e": "AQAB",
            "n": (
                "1HgzBfJv2cOjQryCwe8NEelriOTNFWKZUivevUrRhlqcmZJdCvuCJRr-xCN-"
                "OmO8qwgJJR98feNujxVg-J9Ls3_UOA4HcF9nYH6aqVXELAE8Hk_ALvxi96ms"
                "1DDuAvQGaYZ-lANxlvxeQFOZSbjkz_9mh8aLeGKwqJLp3p-OhUBQpwvAUAPg"
                "82-OUtgTW3nSljjeFr14B8qAneGSc_wl0ni--1SRZUXFSovzcqQOkla3W27r"
                "rLfrD6LXgj_TsDs4vD1PnIm1zcVenKT7TfYI17bsG_O_Wecwz2Nl19pL7gDo"
                "sNruF3ogJWNq1Lyn_ijPQnkPLpZHyhvuiycYcI3DiQ"
            ),
            "d": (
                "rfbs8AWdB1RkLJRlC51LukrAvYl5UfU1TE6XRa4o-DTg2-03OXLNEMyVpMr"
                "a47weEnu14StypzC8qXL7vxXOyd30SSFTffLfleaTg-qxgMZSDw-Fb_M-pU"
                "HMPMEDYG-lgGma4l4fd1yTX2ATtoUo9BVOQgWS1LMZqi0ASEOkUfzlBgL04"
                "UoaLhPSuDdLygdlDzgruVPnec0t1uOEObmrcWIkhwU2CGQzeLtuzX6OVgPh"
                "k7xcnjbDurTTVpWH0R0gbZ5ukmQ2P-YuCX8T9iWNMGjPNSkb7h02s2Oe9ZR"
                "zP007xQ0VF-Z7xyLuxk6ASmoX1S39ujSbk2WF0eXNPRgFwQ"
            ),
            "q": (
                "47hlW2f1ARuWYJf9Dl6MieXjdj2dGx9PL2UH0unVzJYInd56nqXNPrQrc5k"
                "ZU65KApC9n9oKUwIxuqwAAbh8oGNEQDqnuTj-powCkdC6bwA8KH1Y-wotpq"
                "_GSjxkNzjWRm2GArJSzZc6Fb8EuObOrAavKJ285-zMPCEfus1WZG0"
            ),
            "p": (
                "7tr0z929Lp4OHIRJjIKM_rDrWMPtRgnV-51pgWsN6qdpDzns_PgFwrHcoyY"
                "sWIO-4yCdVWPxFOgEZ8xXTM_uwOe4VEmdZhw55Tx7axYZtmZYZbO_RIP4CG"
                "mlJlOFTiYnxpr-2Cx6kIeQmd-hf7fA3tL018aEzwYMbFMcnAGnEg0"
            ),
            "qi": (
                "djo95mB0LVYikNPa-NgyDwLotLqrueb9IviMmn6zKHCwiOXReqXDX9slB8"
                "RA15uv56bmN04O__NyVFcgJ2ef169GZHiRFIgIy0Pl8LYkMhCYKKhyqM7g"
                "xN-SqGqDTKDC22j00S7jcvCaa1qadn1qbdfukZ4NXv7E2d_LO0Y2Kkc"
            ),
            "dp": (
                "tgZ2-tJpEdWxu1m1EzeKa644LHVjpTRptk7H0LDc8i6SieADEuWQvkb9df"
                "fpY6tDFaQNQr3fQ6dtdAztmsP7l1b_ynwvT1nDZUcqZvl4ruBgDWFmKbjI"
                "lOCt0v9jX6MEPP5xqBx9axdkw18BnGtUuHrbzHSlUX-yh_rumpVH1SE"
            ),
            "dq": (
                "xxCIuhD0YlWFbUcwFgGdBWcLIm_WCMGj7SB6aGu1VDTLr4Wu10TFWM0TNu"
                "hc9YPker2gpj5qzAmdAzwcfWSSvXpJTYR43jfulBTMoj8-2o3wCM0anclW"
                "AuKhin-kc4mh9ssDXRQZwlMymZP0QtaxUDw_nlfVrUCZgO7L1_ZsUTk"
            ),
        }
>       assert key == expected
E       AssertionError: assert {'d': 'rfbs8A...: 'AQAB', ...} == {'d': 'rfbs8A...: 'AQAB', ...}
E         
E         Omitting 9 identical items, use -vv to show
E         Right contains 1 more item:
E         {'key_ops': ['sign']}
E         Use -v to get more diff

tests/test_algorithms.py:552: AssertionError
</pre>
</details>
<h3 id="test_algorithmspytestalgorithmstest_rsa_to_jwk_returns_correct_values_for_private_keytrue">test_algorithms.py::TestAlgorithms::test_rsa_to_jwk_returns_correct_values_for_private_key[True]</h3>
<details><summary> <pre>test_algorithms.py::TestAlgorithms::test_rsa_to_jwk_returns_correct_values_for_private_key[True]</pre></summary><pre>
self = <tests.test_algorithms.TestAlgorithms object at 0x7eda89756000>
as_dict = True

    @crypto_required
    @pytest.mark.parametrize("as_dict", (False, True))
    def test_rsa_to_jwk_returns_correct_values_for_private_key(self, as_dict):
        algo = RSAAlgorithm(RSAAlgorithm.SHA256)

        with open(key_path("testkey_rsa.priv")) as keyfile:
            priv_key = algo.prepare_key(keyfile.read())

        key: Any = algo.to_jwk(priv_key, as_dict=as_dict)

        if not as_dict:
            key = json.loads(key)

        expected = {
            "key_ops": ["sign"],
            "kty": "RSA",
            "e": "AQAB",
            "n": (
                "1HgzBfJv2cOjQryCwe8NEelriOTNFWKZUivevUrRhlqcmZJdCvuCJRr-xCN-"
                "OmO8qwgJJR98feNujxVg-J9Ls3_UOA4HcF9nYH6aqVXELAE8Hk_ALvxi96ms"
                "1DDuAvQGaYZ-lANxlvxeQFOZSbjkz_9mh8aLeGKwqJLp3p-OhUBQpwvAUAPg"
                "82-OUtgTW3nSljjeFr14B8qAneGSc_wl0ni--1SRZUXFSovzcqQOkla3W27r"
                "rLfrD6LXgj_TsDs4vD1PnIm1zcVenKT7TfYI17bsG_O_Wecwz2Nl19pL7gDo"
                "sNruF3ogJWNq1Lyn_ijPQnkPLpZHyhvuiycYcI3DiQ"
            ),
            "d": (
                "rfbs8AWdB1RkLJRlC51LukrAvYl5UfU1TE6XRa4o-DTg2-03OXLNEMyVpMr"
                "a47weEnu14StypzC8qXL7vxXOyd30SSFTffLfleaTg-qxgMZSDw-Fb_M-pU"
                "HMPMEDYG-lgGma4l4fd1yTX2ATtoUo9BVOQgWS1LMZqi0ASEOkUfzlBgL04"
                "UoaLhPSuDdLygdlDzgruVPnec0t1uOEObmrcWIkhwU2CGQzeLtuzX6OVgPh"
                "k7xcnjbDurTTVpWH0R0gbZ5ukmQ2P-YuCX8T9iWNMGjPNSkb7h02s2Oe9ZR"
                "zP007xQ0VF-Z7xyLuxk6ASmoX1S39ujSbk2WF0eXNPRgFwQ"
            ),
            "q": (
                "47hlW2f1ARuWYJf9Dl6MieXjdj2dGx9PL2UH0unVzJYInd56nqXNPrQrc5k"
                "ZU65KApC9n9oKUwIxuqwAAbh8oGNEQDqnuTj-powCkdC6bwA8KH1Y-wotpq"
                "_GSjxkNzjWRm2GArJSzZc6Fb8EuObOrAavKJ285-zMPCEfus1WZG0"
            ),
            "p": (
                "7tr0z929Lp4OHIRJjIKM_rDrWMPtRgnV-51pgWsN6qdpDzns_PgFwrHcoyY"
                "sWIO-4yCdVWPxFOgEZ8xXTM_uwOe4VEmdZhw55Tx7axYZtmZYZbO_RIP4CG"
                "mlJlOFTiYnxpr-2Cx6kIeQmd-hf7fA3tL018aEzwYMbFMcnAGnEg0"
            ),
            "qi": (
                "djo95mB0LVYikNPa-NgyDwLotLqrueb9IviMmn6zKHCwiOXReqXDX9slB8"
                "RA15uv56bmN04O__NyVFcgJ2ef169GZHiRFIgIy0Pl8LYkMhCYKKhyqM7g"
                "xN-SqGqDTKDC22j00S7jcvCaa1qadn1qbdfukZ4NXv7E2d_LO0Y2Kkc"
            ),
            "dp": (
                "tgZ2-tJpEdWxu1m1EzeKa644LHVjpTRptk7H0LDc8i6SieADEuWQvkb9df"
                "fpY6tDFaQNQr3fQ6dtdAztmsP7l1b_ynwvT1nDZUcqZvl4ruBgDWFmKbjI"
                "lOCt0v9jX6MEPP5xqBx9axdkw18BnGtUuHrbzHSlUX-yh_rumpVH1SE"
            ),
            "dq": (
                "xxCIuhD0YlWFbUcwFgGdBWcLIm_WCMGj7SB6aGu1VDTLr4Wu10TFWM0TNu"
                "hc9YPker2gpj5qzAmdAzwcfWSSvXpJTYR43jfulBTMoj8-2o3wCM0anclW"
                "AuKhin-kc4mh9ssDXRQZwlMymZP0QtaxUDw_nlfVrUCZgO7L1_ZsUTk"
            ),
        }
>       assert key == expected
E       AssertionError: assert {'d': 'rfbs8A...: 'AQAB', ...} == {'d': 'rfbs8A...: 'AQAB', ...}
E         
E         Omitting 9 identical items, use -vv to show
E         Right contains 1 more item:
E         {'key_ops': ['sign']}
E         Use -v to get more diff

tests/test_algorithms.py:552: AssertionError
</pre>
</details>
<h3 id="test_algorithmspytestalgorithmstest_rsa_to_jwk_raises_exception_on_invalid_key">test_algorithms.py::TestAlgorithms::test_rsa_to_jwk_raises_exception_on_invalid_key</h3>
<details><summary> <pre>test_algorithms.py::TestAlgorithms::test_rsa_to_jwk_raises_exception_on_invalid_key</pre></summary><pre>
self = <tests.test_algorithms.TestAlgorithms object at 0x7eda89625a30>

    @crypto_required
    def test_rsa_to_jwk_raises_exception_on_invalid_key(self):
        algo = RSAAlgorithm(RSAAlgorithm.SHA256)

        with pytest.raises(InvalidKeyError):
>           algo.to_jwk({"not": "a valid key"})  # type: ignore[call-overload]

tests/test_algorithms.py:559: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

key_obj = {'not': 'a valid key'}, as_dict = False

    @staticmethod
    def to_jwk(key_obj: Union[RSAPrivateKey, RSAPublicKey], as_dict: bool = False) -> Union[str, JWKDict]:
        if isinstance(key_obj, RSAPrivateKey):
            numbers = key_obj.private_numbers()
            jwk = {
                'kty': 'RSA',
                'n': to_base64url_uint(numbers.public_numbers.n).decode('ascii'),
                'e': to_base64url_uint(numbers.public_numbers.e).decode('ascii'),
                'd': to_base64url_uint(numbers.d).decode('ascii'),
                'p': to_base64url_uint(numbers.p).decode('ascii'),
                'q': to_base64url_uint(numbers.q).decode('ascii'),
                'dp': to_base64url_uint(numbers.dmp1).decode('ascii'),
                'dq': to_base64url_uint(numbers.dmq1).decode('ascii'),
                'qi': to_base64url_uint(numbers.iqmp).decode('ascii')
            }
        else:
>           numbers = key_obj.public_numbers()
E           AttributeError: 'dict' object has no attribute 'public_numbers'

jwt/algorithms.py:279: AttributeError
</pre>
</details>
<h3 id="test_algorithmspytestalgorithmstest_ec_should_throw_exception_on_wrong_key">test_algorithms.py::TestAlgorithms::test_ec_should_throw_exception_on_wrong_key</h3>
<details><summary> <pre>test_algorithms.py::TestAlgorithms::test_ec_should_throw_exception_on_wrong_key</pre></summary><pre>
self = <tests.test_algorithms.TestAlgorithms object at 0x7eda896264b0>

    @crypto_required
    def test_ec_should_throw_exception_on_wrong_key(self):
        algo = ECAlgorithm(ECAlgorithm.SHA256)

>       with pytest.raises(InvalidKeyError):
E       Failed: DID NOT RAISE <class 'jwt.exceptions.InvalidKeyError'>

tests/test_algorithms.py:629: Failed
</pre>
</details>
<h3 id="test_algorithmspytestokpalgorithmstest_okp_ed25519_should_reject_non_string_key">test_algorithms.py::TestOKPAlgorithms::test_okp_ed25519_should_reject_non_string_key</h3>
<details><summary> <pre>test_algorithms.py::TestOKPAlgorithms::test_okp_ed25519_should_reject_non_string_key</pre></summary><pre>
self = <tests.test_algorithms.TestOKPAlgorithms object at 0x7eda89627140>

    def test_okp_ed25519_should_reject_non_string_key(self):
        algo = OKPAlgorithm()

        with pytest.raises(InvalidKeyError):
>           algo.prepare_key(None)  # type: ignore[arg-type]

tests/test_algorithms.py:813: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/algorithms.py:493: in prepare_key
    key = force_bytes(key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

value = None

    def force_bytes(value: Union[str, bytes]) -> bytes:
        if isinstance(value, str):
            return value.encode('utf-8')
        elif isinstance(value, bytes):
            return value
        else:
>           raise TypeError('Expected string or bytes type')
E           TypeError: Expected string or bytes type

jwt/utils.py:17: TypeError
</pre>
</details>
<h3 id="test_algorithmspytestokpalgorithmstest_okp_ed25519_jwk_fails_on_invalid_json">test_algorithms.py::TestOKPAlgorithms::test_okp_ed25519_jwk_fails_on_invalid_json</h3>
<details><summary> <pre>test_algorithms.py::TestOKPAlgorithms::test_okp_ed25519_jwk_fails_on_invalid_json</pre></summary><pre>
self = <tests.test_algorithms.TestOKPAlgorithms object at 0x7eda89627470>

    def test_okp_ed25519_jwk_fails_on_invalid_json(self):
        algo = OKPAlgorithm()

        with open(key_path("jwk_okp_pub_Ed25519.json")) as keyfile:
            valid_pub = json.loads(keyfile.read())
        with open(key_path("jwk_okp_key_Ed25519.json")) as keyfile:
            valid_key = json.loads(keyfile.read())

        # Invalid instance type
        with pytest.raises(InvalidKeyError):
            algo.from_jwk(123)  # type: ignore[arg-type]

        # Invalid JSON
        with pytest.raises(InvalidKeyError):
>           algo.from_jwk("<this isn't json>")

tests/test_algorithms.py:919: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/algorithms.py:592: in from_jwk
    jwk = json.loads(jwk)
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/__init__.py:346: in loads
    return _default_decoder.decode(s)
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7eda89d2fa10>
s = "<this isn't json>", idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.

        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.

        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/decoder.py:355: JSONDecodeError
</pre>
</details>
<h3 id="test_algorithmspytestokpalgorithmstest_okp_to_jwk_raises_exception_on_invalid_key">test_algorithms.py::TestOKPAlgorithms::test_okp_to_jwk_raises_exception_on_invalid_key</h3>
<details><summary> <pre>test_algorithms.py::TestOKPAlgorithms::test_okp_to_jwk_raises_exception_on_invalid_key</pre></summary><pre>
self = <tests.test_algorithms.TestOKPAlgorithms object at 0x7eda896278c0>

    def test_okp_to_jwk_raises_exception_on_invalid_key(self):
        algo = OKPAlgorithm()

        with pytest.raises(InvalidKeyError):
>           algo.to_jwk({"not": "a valid key"})  # type: ignore[call-overload]

tests/test_algorithms.py:981: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

key_obj = {'not': 'a valid key'}, as_dict = False

    @staticmethod
    def to_jwk(key_obj: AllowedOKPKeys, as_dict: bool = False) -> Union[str, JWKDict]:
        if isinstance(key_obj, (Ed25519PrivateKey, Ed25519PublicKey)):
            crv = 'Ed25519'
        elif isinstance(key_obj, (Ed448PrivateKey, Ed448PublicKey)):
            crv = 'Ed448'
        else:
>           raise TypeError('Key must be an EdDSA key instance')
E           TypeError: Key must be an EdDSA key instance

jwt/algorithms.py:556: TypeError
</pre>
</details>
<h3 id="test_algorithmspytestokpalgorithmstest_okp_ed448_jwk_fails_on_invalid_json">test_algorithms.py::TestOKPAlgorithms::test_okp_ed448_jwk_fails_on_invalid_json</h3>
<details><summary> <pre>test_algorithms.py::TestOKPAlgorithms::test_okp_ed448_jwk_fails_on_invalid_json</pre></summary><pre>
self = <tests.test_algorithms.TestOKPAlgorithms object at 0x7eda89627fb0>

    def test_okp_ed448_jwk_fails_on_invalid_json(self):
        algo = OKPAlgorithm()

        with open(key_path("jwk_okp_pub_Ed448.json")) as keyfile:
            valid_pub = json.loads(keyfile.read())
        with open(key_path("jwk_okp_key_Ed448.json")) as keyfile:
            valid_key = json.loads(keyfile.read())

        # Invalid instance type
        with pytest.raises(InvalidKeyError):
            algo.from_jwk(123)  # type: ignore[arg-type]

        # Invalid JSON
        with pytest.raises(InvalidKeyError):
>           algo.from_jwk("<this isn't json>")

tests/test_algorithms.py:1029: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/algorithms.py:592: in from_jwk
    jwk = json.loads(jwk)
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/__init__.py:346: in loads
    return _default_decoder.decode(s)
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/decoder.py:337: in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <json.decoder.JSONDecoder object at 0x7eda89d2fa10>
s = "<this isn't json>", idx = 0

    def raw_decode(self, s, idx=0):
        """Decode a JSON document from ``s`` (a ``str`` beginning with
        a JSON document) and return a 2-tuple of the Python
        representation and the index in ``s`` where the document ended.

        This can be used to decode a JSON document from a string that may
        have extraneous data at the end.

        """
        try:
            obj, end = self.scan_once(s, idx)
        except StopIteration as err:
>           raise JSONDecodeError("Expecting value", s, err.value) from None
E           json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/json/decoder.py:355: JSONDecodeError
</pre>
</details>
<h3 id="test_api_jwkpytestpyjwktest_should_load_key_ec_secp256k1_from_dict">test_api_jwk.py::TestPyJWK::test_should_load_key_ec_secp256k1_from_dict</h3>
<details><summary> <pre>test_api_jwk.py::TestPyJWK::test_should_load_key_ec_secp256k1_from_dict</pre></summary><pre>
self = <tests.test_api_jwk.TestPyJWK object at 0x7eda89636ab0>

    @crypto_required
    def test_should_load_key_ec_secp256k1_from_dict(self):
        with open(key_path("jwk_ec_pub_secp256k1.json")) as keyfile:
            key_data = json.loads(keyfile.read())

>       jwk = PyJWK.from_dict(key_data)

tests/test_api_jwk.py:118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwk.py:69: in from_dict
    return cls(obj, algorithm)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jwk.PyJWK object at 0x7eda888d2270>
jwk_data = {'crv': 'secp256k1', 'kid': 'bilbo.baggins.256k@hobbiton.example', 'kty': 'EC', 'x': 'MLnVyPDPQpNm0KaaO4iEh0i8JItHXJE0NcIe8GK1SYs', ...}
algorithm = 'ES256K'

    def __init__(self, jwk_data: JWKDict, algorithm: str | None=None) -> None:
        self._algorithms = get_default_algorithms()
        self._jwk_data = jwk_data
        kty = self._jwk_data.get('kty', None)
        if not kty:
            raise InvalidKeyError(f'kty is not found: {self._jwk_data}')
        if not algorithm and isinstance(self._jwk_data, dict):
            algorithm = self._jwk_data.get('alg', None)
        if not algorithm:
            crv = self._jwk_data.get('crv', None)
            if kty == 'EC':
                if crv == 'P-256' or not crv:
                    algorithm = 'ES256'
                elif crv == 'P-384':
                    algorithm = 'ES384'
                elif crv == 'P-521':
                    algorithm = 'ES512'
                elif crv == 'secp256k1':
                    algorithm = 'ES256K'
                else:
                    raise InvalidKeyError(f'Unsupported crv: {crv}')
            elif kty == 'RSA':
                algorithm = 'RS256'
            elif kty == 'oct':
                algorithm = 'HS256'
            elif kty == 'OKP':
                if not crv:
                    raise InvalidKeyError(f'crv is not found: {self._jwk_data}')
                if crv == 'Ed25519':
                    algorithm = 'EdDSA'
                else:
                    raise InvalidKeyError(f'Unsupported crv: {crv}')
            else:
                raise InvalidKeyError(f'Unsupported kty: {kty}')
        if not has_crypto and algorithm in requires_cryptography:
            raise PyJWKError(f"{algorithm} requires 'cryptography' to be installed.")
        self.Algorithm = self._algorithms.get(algorithm)
        if not self.Algorithm:
>           raise PyJWKError(f'Unable to find an algorithm for key: {self._jwk_data}')
E           jwt.exceptions.PyJWKError: Unable to find an algorithm for key: {'kty': 'EC', 'kid': 'bilbo.baggins.256k@hobbiton.example', 'crv': 'secp256k1', 'x': 'MLnVyPDPQpNm0KaaO4iEh0i8JItHXJE0NcIe8GK1SYs', 'y': '7r8d-xF7QAgT5kSRdly6M8xeg4Jz83Gs_CQPQRH65QI'}

jwt/api_jwk.py:49: PyJWKError
</pre>
</details>
<h3 id="test_api_jwspytestjwstest_non_object_options_dont_persist">test_api_jws.py::TestJWS::test_non_object_options_dont_persist</h3>
<details><summary> <pre>test_api_jws.py::TestJWS::test_non_object_options_dont_persist</pre></summary><pre>
self = <tests.test_api_jws.TestJWS object at 0x7eda89638560>
jws = <jwt.api_jws.PyJWS object at 0x7eda888dcec0>, payload = b'hello world'

    def test_non_object_options_dont_persist(self, jws, payload):
        token = jws.encode(payload, "secret")

>       jws.decode(token, "secret", options={"verify_signature": False})

tests/test_api_jws.py:81: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jws.py:346: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, detached_payload, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda888dcec0>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.aGVsbG8gd29ybGQ.', key = 'secret'
algorithms = ['ES384', 'RS384', 'EdDSA', 'HS256', 'RS256', 'RS512', ...]
options = {'verify_signature': False}, detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'verify_signature': False}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.aGVsbG8gd29ybGQ'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
            raise InvalidAlgorithmError('The specified alg value is not allowed')

        if alg == 'none':
            if merged_options['verify_signature']:
                raise DecodeError('Algorithm "none" not allowed')
            if key not in [None, '', 'none']:
>               raise InvalidKeyError('When alg = "none", key must be empty or "none"')
E               NameError: name 'InvalidKeyError' is not defined

jwt/api_jws.py:284: NameError
</pre>
</details>
<h3 id="test_api_jwspytestjwstest_decode_missing_segments_throws_exception">test_api_jws.py::TestJWS::test_decode_missing_segments_throws_exception</h3>
<details><summary> <pre>test_api_jws.py::TestJWS::test_decode_missing_segments_throws_exception</pre></summary><pre>
self = <jwt.api_jws.PyJWS object at 0x7eda88821f10>
jwt = b'eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJoZWxsbyI6ICJ3b3JsZCJ9'
key = 'secret', algorithms = ['HS256'], options = {}, detached_payload = None
kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'verify_signature': True}
signing_input = b'eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9'
crypto_segment = b'eyJoZWxsbyI6ICJ3b3JsZCJ9'

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
>           header_segment, payload_segment = signing_input.split(b'.', 1)
E           ValueError: not enough values to unpack (expected 2, got 1)

jwt/api_jws.py:234: ValueError

During handling of the above exception, another exception occurred:

self = <tests.test_api_jws.TestJWS object at 0x7eda89755790>
jws = <jwt.api_jws.PyJWS object at 0x7eda88821f10>

    def test_decode_missing_segments_throws_exception(self, jws):
        secret = "secret"
        example_jws = "eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJoZWxsbyI6ICJ3b3JsZCJ9"  # Missing segment

        with pytest.raises(DecodeError) as context:
>           jws.decode(example_jws, secret, algorithms=["HS256"])

tests/test_api_jws.py:121: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jws.py:346: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, detached_payload, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda88821f10>
jwt = b'eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJoZWxsbyI6ICJ3b3JsZCJ9'
key = 'secret', algorithms = ['HS256'], options = {}, detached_payload = None
kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'verify_signature': True}
signing_input = b'eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9'
crypto_segment = b'eyJoZWxsbyI6ICJ3b3JsZCJ9'

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
>           raise InvalidTokenError('Not enough segments')
E           jwt.exceptions.InvalidTokenError: Not enough segments

jwt/api_jws.py:236: InvalidTokenError
</pre>
</details>
<h3 id="test_api_jwspytestjwstest_encode_algorithm_param_should_be_case_sensitive">test_api_jws.py::TestJWS::test_encode_algorithm_param_should_be_case_sensitive</h3>
<details><summary> <pre>test_api_jws.py::TestJWS::test_encode_algorithm_param_should_be_case_sensitive</pre></summary><pre>
self = <tests.test_api_jws.TestJWS object at 0x7eda89625100>
jws = <jwt.api_jws.PyJWS object at 0x7eda888dd040>, payload = b'hello world'

    def test_encode_algorithm_param_should_be_case_sensitive(self, jws, payload):
        jws.encode(payload, "secret", algorithm="HS256")

        with pytest.raises(NotImplementedError) as context:
>           jws.encode(payload, None, algorithm="hs256")

tests/test_api_jws.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda888dd040>, payload = b'hello world'
key = None, algorithm = 'hs256', headers = None, json_encoder = None
is_payload_detached = False, sort_headers = False

    def encode(self, payload: bytes, key: str | bytes | AllowedPrivateKeys | None=None, algorithm: str | None=None, headers: dict[str, Any] | None=None, json_encoder: type[json.JSONEncoder] | None=None, is_payload_detached: bool=False, sort_headers: bool=False) -> str:
        """Creates a JWT using the given algorithm.

        Args:
            payload: The claims content to sign
            key: The key to use for signing the claim. Note: if the algorithm is None, the key is not used
            algorithm: The signing algorithm to use. If none is specified then 'none' is used.
            headers: A dict of additional headers to use.
            json_encoder: A custom JSON encoder to use for encoding the JWT.
            is_payload_detached: If True, the payload will be detached from the JWS.
            sort_headers: If True, sort the header keys.
        """
        # Check that we have a mapping
        if not isinstance(payload, bytes):
            raise TypeError('Payload must be bytes')

        if algorithm is None:
            algorithm = 'none'

        if algorithm not in self._valid_algs:
>           raise InvalidAlgorithmError('Algorithm not supported')
E           jwt.exceptions.InvalidAlgorithmError: Algorithm not supported

jwt/api_jws.py:124: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwspytestjwstest_encode_with_headers_alg_none">test_api_jws.py::TestJWS::test_encode_with_headers_alg_none</h3>
<details><summary> <pre>test_api_jws.py::TestJWS::test_encode_with_headers_alg_none</pre></summary><pre>
self = <tests.test_api_jws.TestJWS object at 0x7eda89627c20>
jws = <jwt.api_jws.PyJWS object at 0x7eda896252b0>, payload = b'hello world'

    def test_encode_with_headers_alg_none(self, jws, payload):
        msg = jws.encode(payload, key=None, headers={"alg": "none"})
        with pytest.raises(DecodeError) as context:
            jws.decode(msg, algorithms=["none"])
>       assert str(context.value) == "Signature verification failed"
E       assert 'Algorithm "none" not allowed' == 'Signature ve...cation failed'
E         
E         - Signature verification failed
E         + Algorithm "none" not allowed

tests/test_api_jws.py:173: AssertionError
</pre>
</details>
<h3 id="test_api_jwspytestjwstest_encode_with_headers_alg_es256">test_api_jws.py::TestJWS::test_encode_with_headers_alg_es256</h3>
<details><summary> <pre>test_api_jws.py::TestJWS::test_encode_with_headers_alg_es256</pre></summary><pre>
self = <jwt.api_jws.PyJWS object at 0x7eda888541a0>
jwt = b'eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.aGVsbG8gd29ybGQ.'
key = <cryptography.hazmat.bindings._rust.openssl.ec.ECPublicKey object at 0x7eda886b2df0>
algorithms = ['ES256'], options = {}, detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'verify_signature': True}
signing_input = b'eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.aGVsbG8gd29ybGQ'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
            raise InvalidAlgorithmError('The specified alg value is not allowed')

        if alg == 'none':
            if merged_options['verify_signature']:
                raise DecodeError('Algorithm "none" not allowed')
            if key not in [None, '', 'none']:
                raise InvalidKeyError('When alg = "none", key must be empty or "none"')
            if signature != b'':
                raise InvalidSignatureError('Signature verification failed')
            return {
                'header': header,
                'payload': payload,
                'signature': signature
            }

        try:
            alg_obj = self._algorithms[alg]
        except KeyError:
            raise InvalidAlgorithmError('Algorithm not supported')

        if merged_options['verify_signature']:
            try:
                if key is None:
                    raise InvalidKeyError('Key is required when algorithm is not "none"')
                key = alg_obj.prepare_key(key)
            except InvalidKeyError:
                raise
            except Exception as e:
                raise InvalidTokenError('Unable to parse signature key: %s' % e)

            try:
                if not alg_obj.verify(signing_input if header.get('b64', True) else payload, key, signature):
>                   raise InvalidSignatureError('Signature verification failed')
E                   jwt.exceptions.InvalidSignatureError: Signature verification failed

jwt/api_jws.py:310: InvalidSignatureError

During handling of the above exception, another exception occurred:

self = <tests.test_api_jws.TestJWS object at 0x7eda896359d0>
jws = <jwt.api_jws.PyJWS object at 0x7eda888541a0>, payload = b'hello world'

    @crypto_required
    def test_encode_with_headers_alg_es256(self, jws, payload):
        with open(key_path("testkey_ec.priv"), "rb") as ec_priv_file:
            priv_key = load_pem_private_key(ec_priv_file.read(), password=None)
        with open(key_path("testkey_ec.pub"), "rb") as ec_pub_file:
            pub_key = load_pem_public_key(ec_pub_file.read())

        msg = jws.encode(payload, priv_key, headers={"alg": "ES256"})
>       assert b"hello world" == jws.decode(msg, pub_key, algorithms=["ES256"])

tests/test_api_jws.py:183: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jws.py:346: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, detached_payload, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda888541a0>
jwt = b'eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.aGVsbG8gd29ybGQ.'
key = <cryptography.hazmat.bindings._rust.openssl.ec.ECPublicKey object at 0x7eda886b2df0>
algorithms = ['ES256'], options = {}, detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'verify_signature': True}
signing_input = b'eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.aGVsbG8gd29ybGQ'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
            raise InvalidAlgorithmError('The specified alg value is not allowed')

        if alg == 'none':
            if merged_options['verify_signature']:
                raise DecodeError('Algorithm "none" not allowed')
            if key not in [None, '', 'none']:
                raise InvalidKeyError('When alg = "none", key must be empty or "none"')
            if signature != b'':
                raise InvalidSignatureError('Signature verification failed')
            return {
                'header': header,
                'payload': payload,
                'signature': signature
            }

        try:
            alg_obj = self._algorithms[alg]
        except KeyError:
            raise InvalidAlgorithmError('Algorithm not supported')

        if merged_options['verify_signature']:
            try:
                if key is None:
                    raise InvalidKeyError('Key is required when algorithm is not "none"')
                key = alg_obj.prepare_key(key)
            except InvalidKeyError:
                raise
            except Exception as e:
                raise InvalidTokenError('Unable to parse signature key: %s' % e)

            try:
                if not alg_obj.verify(signing_input if header.get('b64', True) else payload, key, signature):
                    raise InvalidSignatureError('Signature verification failed')
            except Exception as e:
>               raise InvalidSignatureError('Signature verification failed: %s' % e)
E               jwt.exceptions.InvalidSignatureError: Signature verification failed: Signature verification failed

jwt/api_jws.py:312: InvalidSignatureError
</pre>
</details>
<h3 id="test_api_jwspytestjwstest_encode_with_alg_hs256_and_headers_alg_es256">test_api_jws.py::TestJWS::test_encode_with_alg_hs256_and_headers_alg_es256</h3>
<details><summary> <pre>test_api_jws.py::TestJWS::test_encode_with_alg_hs256_and_headers_alg_es256</pre></summary><pre>
self = <jwt.api_jws.PyJWS object at 0x7eda88857ce0>, payload = b'hello world'
key = <cryptography.hazmat.bindings._rust.openssl.ec.ECPrivateKey object at 0x7eda886a2610>
algorithm = 'HS256', headers = {'alg': 'ES256'}, json_encoder = None
is_payload_detached = False, sort_headers = False

    def encode(self, payload: bytes, key: str | bytes | AllowedPrivateKeys | None=None, algorithm: str | None=None, headers: dict[str, Any] | None=None, json_encoder: type[json.JSONEncoder] | None=None, is_payload_detached: bool=False, sort_headers: bool=False) -> str:
        """Creates a JWT using the given algorithm.

        Args:
            payload: The claims content to sign
            key: The key to use for signing the claim. Note: if the algorithm is None, the key is not used
            algorithm: The signing algorithm to use. If none is specified then 'none' is used.
            headers: A dict of additional headers to use.
            json_encoder: A custom JSON encoder to use for encoding the JWT.
            is_payload_detached: If True, the payload will be detached from the JWS.
            sort_headers: If True, sort the header keys.
        """
        # Check that we have a mapping
        if not isinstance(payload, bytes):
            raise TypeError('Payload must be bytes')

        if algorithm is None:
            algorithm = 'none'

        if algorithm not in self._valid_algs:
            raise InvalidAlgorithmError('Algorithm not supported')

        if algorithm != 'none' and key is None:
            raise InvalidKeyError('Key is required when algorithm is not "none"')

        # Header
        header = {'alg': algorithm}
        if self.header_typ is not None and 'typ' not in (headers or {}):
            header['typ'] = self.header_typ

        if headers:
            header.update(headers)
            if header.get('typ') == '':
                del header['typ']
            elif header.get('typ') is None:
                del header['typ']

        if is_payload_detached:
            header['b64'] = False
            if not payload:
                raise InvalidTokenError('Payload cannot be empty when using detached content')

        if sort_headers:
            header = dict(sorted(header.items()))

        json_header = json.dumps(header, separators=(',', ':'), cls=json_encoder).encode('utf-8')
        header_input = base64url_encode(json_header)

        if is_payload_detached:
            payload_input = b''
        else:
            payload_input = base64url_encode(payload)

        signing_input = b'.'.join([header_input, payload_input])

        try:
            alg_obj = self._algorithms[algorithm]
            if algorithm == 'none':
                key = None
            elif key is None:
                raise TypeError('Key is required when algorithm is not "none"')
            else:
>               key = alg_obj.prepare_key(key)

jwt/api_jws.py:166: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.algorithms.HMACAlgorithm object at 0x7eda88854cb0>
key = <cryptography.hazmat.bindings._rust.openssl.ec.ECPrivateKey object at 0x7eda886a2610>

    def prepare_key(self, key: Union[str, bytes]) -> bytes:
        if not isinstance(key, (str, bytes)):
>           raise TypeError('Expected a string value')
E           TypeError: Expected a string value

jwt/algorithms.py:165: TypeError

During handling of the above exception, another exception occurred:

self = <tests.test_api_jws.TestJWS object at 0x7eda89634890>
jws = <jwt.api_jws.PyJWS object at 0x7eda88857ce0>, payload = b'hello world'

    @crypto_required
    def test_encode_with_alg_hs256_and_headers_alg_es256(self, jws, payload):
        with open(key_path("testkey_ec.priv"), "rb") as ec_priv_file:
            priv_key = load_pem_private_key(ec_priv_file.read(), password=None)
        with open(key_path("testkey_ec.pub"), "rb") as ec_pub_file:
            pub_key = load_pem_public_key(ec_pub_file.read())

>       msg = jws.encode(payload, priv_key, algorithm="HS256", headers={"alg": "ES256"})

tests/test_api_jws.py:192: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda88857ce0>, payload = b'hello world'
key = <cryptography.hazmat.bindings._rust.openssl.ec.ECPrivateKey object at 0x7eda886a2610>
algorithm = 'HS256', headers = {'alg': 'ES256'}, json_encoder = None
is_payload_detached = False, sort_headers = False

    def encode(self, payload: bytes, key: str | bytes | AllowedPrivateKeys | None=None, algorithm: str | None=None, headers: dict[str, Any] | None=None, json_encoder: type[json.JSONEncoder] | None=None, is_payload_detached: bool=False, sort_headers: bool=False) -> str:
        """Creates a JWT using the given algorithm.

        Args:
            payload: The claims content to sign
            key: The key to use for signing the claim. Note: if the algorithm is None, the key is not used
            algorithm: The signing algorithm to use. If none is specified then 'none' is used.
            headers: A dict of additional headers to use.
            json_encoder: A custom JSON encoder to use for encoding the JWT.
            is_payload_detached: If True, the payload will be detached from the JWS.
            sort_headers: If True, sort the header keys.
        """
        # Check that we have a mapping
        if not isinstance(payload, bytes):
            raise TypeError('Payload must be bytes')

        if algorithm is None:
            algorithm = 'none'

        if algorithm not in self._valid_algs:
            raise InvalidAlgorithmError('Algorithm not supported')

        if algorithm != 'none' and key is None:
            raise InvalidKeyError('Key is required when algorithm is not "none"')

        # Header
        header = {'alg': algorithm}
        if self.header_typ is not None and 'typ' not in (headers or {}):
            header['typ'] = self.header_typ

        if headers:
            header.update(headers)
            if header.get('typ') == '':
                del header['typ']
            elif header.get('typ') is None:
                del header['typ']

        if is_payload_detached:
            header['b64'] = False
            if not payload:
                raise InvalidTokenError('Payload cannot be empty when using detached content')

        if sort_headers:
            header = dict(sorted(header.items()))

        json_header = json.dumps(header, separators=(',', ':'), cls=json_encoder).encode('utf-8')
        header_input = base64url_encode(json_header)

        if is_payload_detached:
            payload_input = b''
        else:
            payload_input = base64url_encode(payload)

        signing_input = b'.'.join([header_input, payload_input])

        try:
            alg_obj = self._algorithms[algorithm]
            if algorithm == 'none':
                key = None
            elif key is None:
                raise TypeError('Key is required when algorithm is not "none"')
            else:
                key = alg_obj.prepare_key(key)
            signature = alg_obj.sign(signing_input if not is_payload_detached else payload, key)
        except Exception as e:
>           raise TypeError('Unable to encode JWT: %s' % e)
E           TypeError: Unable to encode JWT: Expected a string value

jwt/api_jws.py:169: TypeError
</pre>
</details>
<h3 id="test_api_jwspytestjwstest_bad_secret">test_api_jws.py::TestJWS::test_bad_secret</h3>
<details><summary> <pre>test_api_jws.py::TestJWS::test_bad_secret</pre></summary><pre>
self = <tests.test_api_jws.TestJWS object at 0x7eda89627860>
jws = <jwt.api_jws.PyJWS object at 0x7eda888563c0>, payload = b'hello world'

    def test_bad_secret(self, jws, payload):
        right_secret = "foo"
        bad_secret = "bar"
        jws_message = jws.encode(payload, right_secret)

        with pytest.raises(DecodeError) as excinfo:
            # Backward compat for ticket #315
>           jws.decode(jws_message, bad_secret, algorithms=["HS256"])

tests/test_api_jws.py:215: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jws.py:346: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, detached_payload, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda888563c0>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.aGVsbG8gd29ybGQ.', key = 'bar'
algorithms = ['HS256'], options = {}, detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'verify_signature': True}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.aGVsbG8gd29ybGQ'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwspytestjwstest_decode_with_optional_algorithms">test_api_jws.py::TestJWS::test_decode_with_optional_algorithms</h3>
<details><summary> <pre>test_api_jws.py::TestJWS::test_decode_with_optional_algorithms</pre></summary><pre>
self = <tests.test_api_jws.TestJWS object at 0x7eda89634770>
jws = <jwt.api_jws.PyJWS object at 0x7eda89756ba0>

    def test_decode_with_optional_algorithms(self, jws):
        example_secret = "secret"
        example_jws = (
            b"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9."
            b"aGVsbG8gd29ybGQ."
            b"SIr03zM64awWRdPrAM_61QWsZchAtgDV3pphfHPPWkI"
        )

>       with pytest.raises(DecodeError) as exc:
E       Failed: DID NOT RAISE <class 'jwt.exceptions.DecodeError'>

tests/test_api_jws.py:326: Failed
</pre>
</details>
<h3 id="test_api_jwspytestjwstest_load_no_verification">test_api_jws.py::TestJWS::test_load_no_verification</h3>
<details><summary> <pre>test_api_jws.py::TestJWS::test_load_no_verification</pre></summary><pre>
self = <tests.test_api_jws.TestJWS object at 0x7eda89634b30>
jws = <jwt.api_jws.PyJWS object at 0x7eda888562a0>, payload = b'hello world'

    def test_load_no_verification(self, jws, payload):
        right_secret = "foo"
        jws_message = jws.encode(payload, right_secret)

>       decoded_payload = jws.decode(
            jws_message,
            key=None,
            algorithms=["HS256"],
            options={"verify_signature": False},
        )

tests/test_api_jws.py:352: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jws.py:346: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, detached_payload, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda888562a0>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.aGVsbG8gd29ybGQ.', key = None
algorithms = ['HS256'], options = {'verify_signature': False}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'verify_signature': False}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.aGVsbG8gd29ybGQ'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwspytestjwstest_no_secret">test_api_jws.py::TestJWS::test_no_secret</h3>
<details><summary> <pre>test_api_jws.py::TestJWS::test_no_secret</pre></summary><pre>
self = <tests.test_api_jws.TestJWS object at 0x7eda89634e00>
jws = <jwt.api_jws.PyJWS object at 0x7eda888f51f0>, payload = b'hello world'

    def test_no_secret(self, jws, payload):
        right_secret = "foo"
        jws_message = jws.encode(payload, right_secret)

        with pytest.raises(DecodeError):
>           jws.decode(jws_message, algorithms=["HS256"])

tests/test_api_jws.py:366: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jws.py:346: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, detached_payload, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda888f51f0>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.aGVsbG8gd29ybGQ.', key = None
algorithms = ['HS256'], options = {}, detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'verify_signature': True}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.aGVsbG8gd29ybGQ'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwspytestjwstest_verify_signature_with_no_secret">test_api_jws.py::TestJWS::test_verify_signature_with_no_secret</h3>
<details><summary> <pre>test_api_jws.py::TestJWS::test_verify_signature_with_no_secret</pre></summary><pre>
self = <tests.test_api_jws.TestJWS object at 0x7eda89634da0>
jws = <jwt.api_jws.PyJWS object at 0x7eda888d2600>, payload = b'hello world'

    def test_verify_signature_with_no_secret(self, jws, payload):
        right_secret = "foo"
        jws_message = jws.encode(payload, right_secret)

        with pytest.raises(DecodeError) as exc:
>           jws.decode(jws_message, algorithms=["HS256"])

tests/test_api_jws.py:373: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jws.py:346: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, detached_payload, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda888d2600>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.aGVsbG8gd29ybGQ.', key = None
algorithms = ['HS256'], options = {}, detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'verify_signature': True}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.aGVsbG8gd29ybGQ'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwspytestjwstest_verify_signature_with_no_algo_header_throws_exception">test_api_jws.py::TestJWS::test_verify_signature_with_no_algo_header_throws_exception</h3>
<details><summary> <pre>test_api_jws.py::TestJWS::test_verify_signature_with_no_algo_header_throws_exception</pre></summary><pre>
self = <jwt.api_jws.PyJWS object at 0x7eda897542c0>
jwt = b'e30.eyJhIjo1fQ.KEh186CjVw_Q8FadjJcaVnE7hO5Z9nHBbU8TgbhHcBY'
key = 'secret', algorithms = ['HS256'], options = {}, detached_payload = None
kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'verify_signature': True}, signing_input = b'e30.eyJhIjo1fQ'
crypto_segment = b'KEh186CjVw_Q8FadjJcaVnE7hO5Z9nHBbU8TgbhHcBY'

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
>           alg = header['alg']
E           KeyError: 'alg'

jwt/api_jws.py:273: KeyError

During handling of the above exception, another exception occurred:

self = <tests.test_api_jws.TestJWS object at 0x7eda896367b0>
jws = <jwt.api_jws.PyJWS object at 0x7eda897542c0>, payload = b'hello world'

    def test_verify_signature_with_no_algo_header_throws_exception(self, jws, payload):
        example_jws = b"e30.eyJhIjo1fQ.KEh186CjVw_Q8FadjJcaVnE7hO5Z9nHBbU8TgbhHcBY"

        with pytest.raises(InvalidAlgorithmError):
>           jws.decode(example_jws, "secret", algorithms=["HS256"])

tests/test_api_jws.py:381: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jws.py:346: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, detached_payload, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda897542c0>
jwt = b'e30.eyJhIjo1fQ.KEh186CjVw_Q8FadjJcaVnE7hO5Z9nHBbU8TgbhHcBY'
key = 'secret', algorithms = ['HS256'], options = {}, detached_payload = None
kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'verify_signature': True}, signing_input = b'e30.eyJhIjo1fQ'
crypto_segment = b'KEh186CjVw_Q8FadjJcaVnE7hO5Z9nHBbU8TgbhHcBY'

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
>           raise InvalidTokenError('Missing algorithm ("alg") in headers')
E           jwt.exceptions.InvalidTokenError: Missing algorithm ("alg") in headers

jwt/api_jws.py:275: InvalidTokenError
</pre>
</details>
<h3 id="test_api_jwspytestjwstest_invalid_crypto_alg">test_api_jws.py::TestJWS::test_invalid_crypto_alg</h3>
<details><summary> <pre>test_api_jws.py::TestJWS::test_invalid_crypto_alg</pre></summary><pre>
self = <tests.test_api_jws.TestJWS object at 0x7eda89636660>
jws = <jwt.api_jws.PyJWS object at 0x7eda888dd220>, payload = b'hello world'

    def test_invalid_crypto_alg(self, jws, payload):
        with pytest.raises(NotImplementedError):
>           jws.encode(payload, "secret", algorithm="HS1024")

tests/test_api_jws.py:385: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda888dd220>, payload = b'hello world'
key = 'secret', algorithm = 'HS1024', headers = None, json_encoder = None
is_payload_detached = False, sort_headers = False

    def encode(self, payload: bytes, key: str | bytes | AllowedPrivateKeys | None=None, algorithm: str | None=None, headers: dict[str, Any] | None=None, json_encoder: type[json.JSONEncoder] | None=None, is_payload_detached: bool=False, sort_headers: bool=False) -> str:
        """Creates a JWT using the given algorithm.

        Args:
            payload: The claims content to sign
            key: The key to use for signing the claim. Note: if the algorithm is None, the key is not used
            algorithm: The signing algorithm to use. If none is specified then 'none' is used.
            headers: A dict of additional headers to use.
            json_encoder: A custom JSON encoder to use for encoding the JWT.
            is_payload_detached: If True, the payload will be detached from the JWS.
            sort_headers: If True, sort the header keys.
        """
        # Check that we have a mapping
        if not isinstance(payload, bytes):
            raise TypeError('Payload must be bytes')

        if algorithm is None:
            algorithm = 'none'

        if algorithm not in self._valid_algs:
>           raise InvalidAlgorithmError('Algorithm not supported')
E           jwt.exceptions.InvalidAlgorithmError: Algorithm not supported

jwt/api_jws.py:124: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwspytestjwstest_unicode_secret">test_api_jws.py::TestJWS::test_unicode_secret</h3>
<details><summary> <pre>test_api_jws.py::TestJWS::test_unicode_secret</pre></summary><pre>
self = <tests.test_api_jws.TestJWS object at 0x7eda89637950>
jws = <jwt.api_jws.PyJWS object at 0x7eda888222d0>, payload = b'hello world'

    def test_unicode_secret(self, jws, payload):
        secret = "\xc2"
        jws_message = jws.encode(payload, secret)
>       decoded_payload = jws.decode(jws_message, secret, algorithms=["HS256"])

tests/test_api_jws.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jws.py:346: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, detached_payload, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda888222d0>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.aGVsbG8gd29ybGQ.', key = ''
algorithms = ['HS256'], options = {}, detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'verify_signature': True}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.aGVsbG8gd29ybGQ'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwspytestjwstest_nonascii_secret">test_api_jws.py::TestJWS::test_nonascii_secret</h3>
<details><summary> <pre>test_api_jws.py::TestJWS::test_nonascii_secret</pre></summary><pre>
self = <tests.test_api_jws.TestJWS object at 0x7eda896379b0>
jws = <jwt.api_jws.PyJWS object at 0x7eda888d09e0>, payload = b'hello world'

    def test_nonascii_secret(self, jws, payload):
        secret = "\xc2"  # char value that ascii codec cannot decode
        jws_message = jws.encode(payload, secret)

>       decoded_payload = jws.decode(jws_message, secret, algorithms=["HS256"])

tests/test_api_jws.py:404: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jws.py:346: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, detached_payload, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda888d09e0>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.aGVsbG8gd29ybGQ.', key = ''
algorithms = ['HS256'], options = {}, detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'verify_signature': True}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.aGVsbG8gd29ybGQ'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwspytestjwstest_bytes_secret">test_api_jws.py::TestJWS::test_bytes_secret</h3>
<details><summary> <pre>test_api_jws.py::TestJWS::test_bytes_secret</pre></summary><pre>
self = <tests.test_api_jws.TestJWS object at 0x7eda89637380>
jws = <jwt.api_jws.PyJWS object at 0x7eda899057c0>, payload = b'hello world'

    def test_bytes_secret(self, jws, payload):
        secret = b"\xc2"  # char value that ascii codec cannot decode
        jws_message = jws.encode(payload, secret)

>       decoded_payload = jws.decode(jws_message, secret, algorithms=["HS256"])

tests/test_api_jws.py:412: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jws.py:346: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, detached_payload, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda899057c0>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.aGVsbG8gd29ybGQ.', key = b'\xc2'
algorithms = ['HS256'], options = {}, detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'verify_signature': True}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.aGVsbG8gd29ybGQ'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwspytestjwstest_get_unverified_header_fails_on_bad_header_types">test_api_jws.py::TestJWS::test_get_unverified_header_fails_on_bad_header_types</h3>
<details><summary> <pre>test_api_jws.py::TestJWS::test_get_unverified_header_fails_on_bad_header_types</pre></summary><pre>
self = <tests.test_api_jws.TestJWS object at 0x7eda89637a70>
jws = <jwt.api_jws.PyJWS object at 0x7eda88820e90>, payload = b'hello world'

    def test_get_unverified_header_fails_on_bad_header_types(self, jws, payload):
        # Contains a bad kid value (int 123 instead of string)
        example_jws = (
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6MTIzfQ"
            ".eyJzdWIiOiIxMjM0NTY3ODkwIn0"
            ".vs2WY54jfpKP3JGC73Vq5YlMsqM5oTZ1ZydT77SiZSk"
        )

>       with pytest.raises(InvalidTokenError) as exc:
E       Failed: DID NOT RAISE <class 'jwt.exceptions.InvalidTokenError'>

tests/test_api_jws.py:510: Failed
</pre>
</details>
<h3 id="test_api_jwspytestjwstest_encode_decode_ecdsa_related_algorithmses256k">test_api_jws.py::TestJWS::test_encode_decode_ecdsa_related_algorithms[ES256K]</h3>
<details><summary> <pre>test_api_jws.py::TestJWS::test_encode_decode_ecdsa_related_algorithms[ES256K]</pre></summary><pre>
self = <tests.test_api_jws.TestJWS object at 0x7eda896357c0>
jws = <jwt.api_jws.PyJWS object at 0x7eda89636600>, payload = b'hello world'
algo = 'ES256K'

    @pytest.mark.parametrize(
        "algo",
        [
            "ES256",
            "ES256K",
            "ES384",
            "ES512",
        ],
    )
    @crypto_required
    def test_encode_decode_ecdsa_related_algorithms(self, jws, payload, algo):
        # PEM-formatted EC key
        with open(key_path("testkey_ec.priv"), "rb") as ec_priv_file:
            priv_eckey = load_pem_private_key(ec_priv_file.read(), password=None)
>           jws_message = jws.encode(payload, priv_eckey, algorithm=algo)

tests/test_api_jws.py:577: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89636600>, payload = b'hello world'
key = <cryptography.hazmat.bindings._rust.openssl.ec.ECPrivateKey object at 0x7eda886b94b0>
algorithm = 'ES256K', headers = None, json_encoder = None
is_payload_detached = False, sort_headers = False

    def encode(self, payload: bytes, key: str | bytes | AllowedPrivateKeys | None=None, algorithm: str | None=None, headers: dict[str, Any] | None=None, json_encoder: type[json.JSONEncoder] | None=None, is_payload_detached: bool=False, sort_headers: bool=False) -> str:
        """Creates a JWT using the given algorithm.

        Args:
            payload: The claims content to sign
            key: The key to use for signing the claim. Note: if the algorithm is None, the key is not used
            algorithm: The signing algorithm to use. If none is specified then 'none' is used.
            headers: A dict of additional headers to use.
            json_encoder: A custom JSON encoder to use for encoding the JWT.
            is_payload_detached: If True, the payload will be detached from the JWS.
            sort_headers: If True, sort the header keys.
        """
        # Check that we have a mapping
        if not isinstance(payload, bytes):
            raise TypeError('Payload must be bytes')

        if algorithm is None:
            algorithm = 'none'

        if algorithm not in self._valid_algs:
>           raise InvalidAlgorithmError('Algorithm not supported')
E           jwt.exceptions.InvalidAlgorithmError: Algorithm not supported

jwt/api_jws.py:124: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwspytestjwstest_ecdsa_related_algorithms">test_api_jws.py::TestJWS::test_ecdsa_related_algorithms</h3>
<details><summary> <pre>test_api_jws.py::TestJWS::test_ecdsa_related_algorithms</pre></summary><pre>
self = <tests.test_api_jws.TestJWS object at 0x7eda89799e80>
jws = <jwt.api_jws.PyJWS object at 0x7eda888560c0>

    def test_ecdsa_related_algorithms(self, jws):
        jws = PyJWS()
        jws_algorithms = jws.get_algorithms()

        if has_crypto:
            assert "ES256" in jws_algorithms
>           assert "ES256K" in jws_algorithms
E           AssertionError: assert 'ES256K' in ['ES384', 'RS384', 'EdDSA', 'HS256', 'RS256', 'RS512', ...]

tests/test_api_jws.py:598: AssertionError
</pre>
</details>
<h3 id="test_api_jwspytestjwstest_encode_fails_on_invalid_kid_types">test_api_jws.py::TestJWS::test_encode_fails_on_invalid_kid_types</h3>
<details><summary> <pre>test_api_jws.py::TestJWS::test_encode_fails_on_invalid_kid_types</pre></summary><pre>
self = <tests.test_api_jws.TestJWS object at 0x7eda896fe3f0>
jws = <jwt.api_jws.PyJWS object at 0x7eda888575f0>, payload = b'hello world'

    def test_encode_fails_on_invalid_kid_types(self, jws, payload):
>       with pytest.raises(InvalidTokenError) as exc:
E       Failed: DID NOT RAISE <class 'jwt.exceptions.InvalidTokenError'>

tests/test_api_jws.py:724: Failed
</pre>
</details>
<h3 id="test_api_jwspytestjwstest_encode_detached_content_with_b64_header">test_api_jws.py::TestJWS::test_encode_detached_content_with_b64_header</h3>
<details><summary> <pre>test_api_jws.py::TestJWS::test_encode_detached_content_with_b64_header</pre></summary><pre>
self = <tests.test_api_jws.TestJWS object at 0x7eda896fe7b0>
jws = <jwt.api_jws.PyJWS object at 0x7eda888ba270>, payload = b'hello world'

    def test_encode_detached_content_with_b64_header(self, jws, payload):
        secret = "secret"

        # Check that detached content is automatically detected when b64 is false
        headers = {"b64": False}
        token = jws.encode(payload, secret, "HS256", headers)

        msg_header, msg_payload, _ = token.split(".")
        msg_header = base64url_decode(msg_header.encode())
        msg_header_obj = json.loads(msg_header)

        assert "b64" in msg_header_obj
        assert msg_header_obj["b64"] is False
        # Check that the payload is not inside the token
>       assert not msg_payload
E       AssertionError: assert not 'aGVsbG8gd29ybGQ'

tests/test_api_jws.py:756: AssertionError
</pre>
</details>
<h3 id="test_api_jwspytestjwstest_decode_detached_content_without_proper_argument">test_api_jws.py::TestJWS::test_decode_detached_content_without_proper_argument</h3>
<details><summary> <pre>test_api_jws.py::TestJWS::test_decode_detached_content_without_proper_argument</pre></summary><pre>
self = <tests.test_api_jws.TestJWS object at 0x7eda8979a630>
jws = <jwt.api_jws.PyJWS object at 0x7eda888ba990>

    def test_decode_detached_content_without_proper_argument(self, jws):
        example_jws = (
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiIsImI2NCI6ZmFsc2V9"
            "."
            ".65yNkX_ZH4A_6pHaTL_eI84OXOHtfl4K0k5UnlXZ8f4"
        )
        example_secret = "secret"

        with pytest.raises(DecodeError) as exc:
            jws.decode(example_jws, example_secret, algorithms=["HS256"])

>       assert (
            'It is required that you pass in a value for the "detached_payload" argument to decode a message having the b64 header set to false.'
            in str(exc.value)
        )
E       assert 'It is required that you pass in a value for the "detached_payload" argument to decode a message having the b64 header set to false.' in 'It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.'
E        +  where 'It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.' = str(DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.'))
E        +    where DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.') = <ExceptionInfo DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.') tblen=3>.value

tests/test_api_jws.py:780: AssertionError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_with_invalid_audience_param_throws_exception">test_api_jwt.py::TestJWT::test_decode_with_invalid_audience_param_throws_exception</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_with_invalid_audience_param_throws_exception</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda896ff3e0>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda888ba7e0>

    def test_decode_with_invalid_audience_param_throws_exception(self, jwt):
        secret = "secret"
        example_jwt = (
            "eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9"
            ".eyJoZWxsbyI6ICJ3b3JsZCJ9"
            ".tvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8"
        )

        with pytest.raises(TypeError) as context:
>           jwt.decode(example_jwt, secret, audience=1, algorithms=["HS256"])

tests/test_api_jwt.py:119: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jwt.PyJWT object at 0x7eda888ba7e0>
jwt = 'eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJoZWxsbyI6ICJ3b3JsZCJ9.tvagLDLoaiJKxOKqpBXSEGy7SYSifZhjntgm9ctpyj8'
key = 'secret', algorithms = ['HS256'], options = None, kwargs = {'audience': 1}
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
decoded = {'header': {'alg': 'HS256', 'typ': 'JWT'}, 'payload': b'{"hello": "world"}', 'signature': b'\xb6\xf6\xa0,2\xe8j"J\xc4\xe2\xaa\xa4\x15\xd2\x10l\xbbI\x84\xa2}\x98c\x9e\xd8&\xf5\xcbi\xca?'}
payload = {'hello': 'world'}

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, **kwargs: Any) -> dict[str, Any]:
        """
        Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        merged_options = {**self.options, **(options or {})}
        decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
        payload = self._decode_payload(decoded)

        if merged_options['verify_exp'] and 'exp' in payload:
            now = kwargs.get('now', datetime.now(timezone.utc))
            exp = datetime.fromtimestamp(payload['exp'], tz=timezone.utc)
            leeway = timedelta(seconds=kwargs.get('leeway', 0))
            if now > exp + leeway:
                raise ExpiredSignatureError('Signature has expired')

        if merged_options['verify_nbf'] and 'nbf' in payload:
            now = kwargs.get('now', datetime.now(timezone.utc))
            nbf = datetime.fromtimestamp(payload['nbf'], tz=timezone.utc)
            leeway = timedelta(seconds=kwargs.get('leeway', 0))
            if now < nbf - leeway:
                raise ImmatureSignatureError('The token is not yet valid (nbf)')

        if merged_options['verify_iat'] and 'iat' in payload:
            now = kwargs.get('now', datetime.now(timezone.utc))
            iat = datetime.fromtimestamp(payload['iat'], tz=timezone.utc)
            leeway = timedelta(seconds=kwargs.get('leeway', 0))
            if now < iat - leeway:
                raise InvalidIssuedAtError('Issued at claim (iat) cannot be in the future')

        if merged_options['verify_iss']:
            expected_issuer = kwargs.get('issuer', None)
            if expected_issuer is not None:
                if 'iss' not in payload:
                    raise MissingRequiredClaimError('Issuer claim expected but not present')
                if payload['iss'] != expected_issuer:
                    raise InvalidIssuerError('Invalid issuer')

        if merged_options['verify_aud']:
            expected_audience = kwargs.get('audience', None)
            if expected_audience is not None:
                if 'aud' not in payload:
>                   raise MissingRequiredClaimError('Audience claim expected but not present')
E                   jwt.exceptions.MissingRequiredClaimError: Token is missing the "Audience claim expected but not present" claim

jwt/api_jwt.py:147: MissingRequiredClaimError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_raises_exception_if_exp_is_not_int">test_api_jwt.py::TestJWT::test_decode_raises_exception_if_exp_is_not_int</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_raises_exception_if_exp_is_not_int</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda896feb10>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda888bb020>

    def test_decode_raises_exception_if_exp_is_not_int(self, jwt):
        # >>> jwt.encode({'exp': 'not-an-int'}, 'secret')
        example_jwt = (
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9."
            "eyJleHAiOiJub3QtYW4taW50In0."
            "P65iYgoHtBqB07PMtBSuKNUEIPPPfmjfJG217cEE66s"
        )

        with pytest.raises(DecodeError) as exc:
>           jwt.decode(example_jwt, "secret", algorithms=["HS256"])

tests/test_api_jwt.py:206: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jwt.PyJWT object at 0x7eda888bb020>
jwt = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOiJub3QtYW4taW50In0.P65iYgoHtBqB07PMtBSuKNUEIPPPfmjfJG217cEE66s'
key = 'secret', algorithms = ['HS256'], options = None, kwargs = {}
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
decoded = {'header': {'alg': 'HS256', 'typ': 'JWT'}, 'payload': b'{"exp":"not-an-int"}', 'signature': b'?\xaebb\n\x07\xb4\x1a\x81\xd3\xb3\xcc\xb4\x14\xae(\xd5\x04 \xf3\xcf~h\xdf$m\xb5\xed\xc1\x04\xeb\xab'}
payload = {'exp': 'not-an-int'}
now = datetime.datetime(2024, 11, 29, 4, 31, 42, 942554, tzinfo=datetime.timezone.utc)

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, **kwargs: Any) -> dict[str, Any]:
        """
        Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        merged_options = {**self.options, **(options or {})}
        decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
        payload = self._decode_payload(decoded)

        if merged_options['verify_exp'] and 'exp' in payload:
            now = kwargs.get('now', datetime.now(timezone.utc))
>           exp = datetime.fromtimestamp(payload['exp'], tz=timezone.utc)
E           TypeError: 'str' object cannot be interpreted as an integer

jwt/api_jwt.py:116: TypeError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_raises_exception_if_iat_is_not_int">test_api_jwt.py::TestJWT::test_decode_raises_exception_if_iat_is_not_int</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_raises_exception_if_iat_is_not_int</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda896fec30>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda888b7da0>

    def test_decode_raises_exception_if_iat_is_not_int(self, jwt):
        # >>> jwt.encode({'iat': 'not-an-int'}, 'secret')
        example_jwt = (
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9."
            "eyJpYXQiOiJub3QtYW4taW50In0."
            "H1GmcQgSySa5LOKYbzGm--b1OmRbHFkyk8pq811FzZM"
        )

        with pytest.raises(InvalidIssuedAtError):
>           jwt.decode(example_jwt, "secret", algorithms=["HS256"])

tests/test_api_jwt.py:219: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jwt.PyJWT object at 0x7eda888b7da0>
jwt = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpYXQiOiJub3QtYW4taW50In0.H1GmcQgSySa5LOKYbzGm--b1OmRbHFkyk8pq811FzZM'
key = 'secret', algorithms = ['HS256'], options = None, kwargs = {}
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
decoded = {'header': {'alg': 'HS256', 'typ': 'JWT'}, 'payload': b'{"iat":"not-an-int"}', 'signature': b'\x1fQ\xa6q\x08\x12\xc9&\xb9,\xe2\x98o1\xa6\xfb\xe6\xf5:d[\x1cY2\x93\xcaj\xf3]E\xcd\x93'}
payload = {'iat': 'not-an-int'}
now = datetime.datetime(2024, 11, 29, 4, 31, 42, 964811, tzinfo=datetime.timezone.utc)

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, **kwargs: Any) -> dict[str, Any]:
        """
        Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        merged_options = {**self.options, **(options or {})}
        decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
        payload = self._decode_payload(decoded)

        if merged_options['verify_exp'] and 'exp' in payload:
            now = kwargs.get('now', datetime.now(timezone.utc))
            exp = datetime.fromtimestamp(payload['exp'], tz=timezone.utc)
            leeway = timedelta(seconds=kwargs.get('leeway', 0))
            if now > exp + leeway:
                raise ExpiredSignatureError('Signature has expired')

        if merged_options['verify_nbf'] and 'nbf' in payload:
            now = kwargs.get('now', datetime.now(timezone.utc))
            nbf = datetime.fromtimestamp(payload['nbf'], tz=timezone.utc)
            leeway = timedelta(seconds=kwargs.get('leeway', 0))
            if now < nbf - leeway:
                raise ImmatureSignatureError('The token is not yet valid (nbf)')

        if merged_options['verify_iat'] and 'iat' in payload:
            now = kwargs.get('now', datetime.now(timezone.utc))
>           iat = datetime.fromtimestamp(payload['iat'], tz=timezone.utc)
E           TypeError: 'str' object cannot be interpreted as an integer

jwt/api_jwt.py:130: TypeError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_raises_exception_if_iat_is_greater_than_now">test_api_jwt.py::TestJWT::test_decode_raises_exception_if_iat_is_greater_than_now</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_raises_exception_if_iat_is_greater_than_now</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda896fe9c0>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda88855d90>
payload = {'claim': 'insanity', 'exp': 1732854717, 'iat': 1732854712, 'iss': 'jeff'}

    def test_decode_raises_exception_if_iat_is_greater_than_now(self, jwt, payload):
        payload["iat"] = utc_timestamp() + 10
        secret = "secret"
        jwt_message = jwt.encode(payload, secret)

        with pytest.raises(ImmatureSignatureError):
>           jwt.decode(jwt_message, secret, algorithms=["HS256"])

tests/test_api_jwt.py:227: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE3LCJjbGFpbSI6Imluc2FuaXR5IiwiaWF0IjoxNzMyODU0NzEyfQ.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE3LCJjbGFpbSI6Imluc2FuaXR5IiwiaWF0IjoxNzMyODU0NzEyfQ'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_works_if_iat_is_str_of_a_number">test_api_jwt.py::TestJWT::test_decode_works_if_iat_is_str_of_a_number</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_works_if_iat_is_str_of_a_number</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda896fc9e0>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda888d1160>
payload = {'claim': 'insanity', 'exp': 1732854718, 'iat': 1638202770, 'iss': 'jeff'}

    def test_decode_works_if_iat_is_str_of_a_number(self, jwt, payload):
        payload["iat"] = "1638202770"
        secret = "secret"
        jwt_message = jwt.encode(payload, secret)
>       data = jwt.decode(jwt_message, secret, algorithms=["HS256"])

tests/test_api_jwt.py:233: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE4LCJjbGFpbSI6Imluc2FuaXR5IiwiaWF0IjoxNjM4MjAyNzcwfQ.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE4LCJjbGFpbSI6Imluc2FuaXR5IiwiaWF0IjoxNjM4MjAyNzcwfQ'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_raises_exception_if_nbf_is_not_int">test_api_jwt.py::TestJWT::test_decode_raises_exception_if_nbf_is_not_int</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_raises_exception_if_nbf_is_not_int</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda896fe4e0>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda888baf60>

    def test_decode_raises_exception_if_nbf_is_not_int(self, jwt):
        # >>> jwt.encode({'nbf': 'not-an-int'}, 'secret')
        example_jwt = (
            "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9."
            "eyJuYmYiOiJub3QtYW4taW50In0."
            "c25hldC8G2ZamC8uKpax9sYMTgdZo3cxrmzFHaAAluw"
        )

        with pytest.raises(DecodeError):
>           jwt.decode(example_jwt, "secret", algorithms=["HS256"])

tests/test_api_jwt.py:245: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jwt.PyJWT object at 0x7eda888baf60>
jwt = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYmYiOiJub3QtYW4taW50In0.c25hldC8G2ZamC8uKpax9sYMTgdZo3cxrmzFHaAAluw'
key = 'secret', algorithms = ['HS256'], options = None, kwargs = {}
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
decoded = {'header': {'alg': 'HS256', 'typ': 'JWT'}, 'payload': b'{"nbf":"not-an-int"}', 'signature': b'sna\x95\xd0\xbc\x1bfZ\x98/.*\x96\xb1\xf6\xc6\x0cN\x07Y\xa3w1\xael\xc5\x1d\xa0\x00\x96\xec'}
payload = {'nbf': 'not-an-int'}
now = datetime.datetime(2024, 11, 29, 4, 31, 43, 36709, tzinfo=datetime.timezone.utc)

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, **kwargs: Any) -> dict[str, Any]:
        """
        Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        merged_options = {**self.options, **(options or {})}
        decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
        payload = self._decode_payload(decoded)

        if merged_options['verify_exp'] and 'exp' in payload:
            now = kwargs.get('now', datetime.now(timezone.utc))
            exp = datetime.fromtimestamp(payload['exp'], tz=timezone.utc)
            leeway = timedelta(seconds=kwargs.get('leeway', 0))
            if now > exp + leeway:
                raise ExpiredSignatureError('Signature has expired')

        if merged_options['verify_nbf'] and 'nbf' in payload:
            now = kwargs.get('now', datetime.now(timezone.utc))
>           nbf = datetime.fromtimestamp(payload['nbf'], tz=timezone.utc)
E           TypeError: 'str' object cannot be interpreted as an integer

jwt/api_jwt.py:123: TypeError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_encode_datetime">test_api_jwt.py::TestJWT::test_encode_datetime</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_encode_datetime</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88b804a0>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda88854740>

    def test_encode_datetime(self, jwt):
        secret = "secret"
        current_datetime = datetime.now(tz=timezone.utc)
        payload = {
            "exp": current_datetime,
            "iat": current_datetime,
            "nbf": current_datetime,
        }
        jwt_message = jwt.encode(payload, secret)
>       decoded_payload = jwt.decode(
            jwt_message, secret, leeway=1, algorithms=["HS256"]
        )

tests/test_api_jwt.py:266: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJleHAiOjE3MzI4NTQ3MDMsImlhdCI6MTczMjg1NDcwMywibmJmIjoxNzMyODU0NzAzfQ.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJleHAiOjE3MzI4NTQ3MDMsImlhdCI6MTczMjg1NDcwMywibmJmIjoxNzMyODU0NzAzfQ'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_with_expiration">test_api_jwt.py::TestJWT::test_decode_with_expiration</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_with_expiration</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88b80110>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda888dcf80>
payload = {'claim': 'insanity', 'exp': 1732854702, 'iss': 'jeff'}

    def test_decode_with_expiration(self, jwt, payload):
        payload["exp"] = utc_timestamp() - 1
        secret = "secret"
        jwt_message = jwt.encode(payload, secret)

        with pytest.raises(ExpiredSignatureError):
>           jwt.decode(jwt_message, secret, algorithms=["HS256"])

tests/test_api_jwt.py:329: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzAyLCJjbGFpbSI6Imluc2FuaXR5In0.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzAyLCJjbGFpbSI6Imluc2FuaXR5In0'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_with_notbefore">test_api_jwt.py::TestJWT::test_decode_with_notbefore</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_with_notbefore</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88b81340>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda888ba720>
payload = {'claim': 'insanity', 'exp': 1732854718, 'iss': 'jeff', 'nbf': 1732854713}

    def test_decode_with_notbefore(self, jwt, payload):
        payload["nbf"] = utc_timestamp() + 10
        secret = "secret"
        jwt_message = jwt.encode(payload, secret)

        with pytest.raises(ImmatureSignatureError):
>           jwt.decode(jwt_message, secret, algorithms=["HS256"])

tests/test_api_jwt.py:337: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE4LCJjbGFpbSI6Imluc2FuaXR5IiwibmJmIjoxNzMyODU0NzEzfQ.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE4LCJjbGFpbSI6Imluc2FuaXR5IiwibmJmIjoxNzMyODU0NzEzfQ'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_skip_expiration_verification">test_api_jwt.py::TestJWT::test_decode_skip_expiration_verification</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_skip_expiration_verification</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda896fe900>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda89637830>
payload = {'claim': 'insanity', 'exp': 1732854702.144174, 'iss': 'jeff'}

    def test_decode_skip_expiration_verification(self, jwt, payload):
        payload["exp"] = time.time() - 1
        secret = "secret"
        jwt_message = jwt.encode(payload, secret)

>       jwt.decode(
            jwt_message,
            secret,
            algorithms=["HS256"],
            options={"verify_exp": False},
        )

tests/test_api_jwt.py:344: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzAyLjE0NDE3NCwiY2xhaW0iOiJpbnNhbml0eSJ9.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': False, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': False, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzAyLjE0NDE3NCwiY2xhaW0iOiJpbnNhbml0eSJ9'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_skip_notbefore_verification">test_api_jwt.py::TestJWT::test_decode_skip_notbefore_verification</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_skip_notbefore_verification</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda896fe1b0>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda888b8320>
payload = {'claim': 'insanity', 'exp': 1732854718, 'iss': 'jeff', 'nbf': 1732854713.169743}

    def test_decode_skip_notbefore_verification(self, jwt, payload):
        payload["nbf"] = time.time() + 10
        secret = "secret"
        jwt_message = jwt.encode(payload, secret)

>       jwt.decode(
            jwt_message,
            secret,
            algorithms=["HS256"],
            options={"verify_nbf": False},
        )

tests/test_api_jwt.py:356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE4LCJjbGFpbSI6Imluc2FuaXR5IiwibmJmIjoxNzMyODU0NzEzLjE2OTc0M30.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE4LCJjbGFpbSI6Imluc2FuaXR5IiwibmJmIjoxNzMyODU0NzEzLjE2OTc0M30'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_with_expiration_with_leeway">test_api_jwt.py::TestJWT::test_decode_with_expiration_with_leeway</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_with_expiration_with_leeway</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda896fec90>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda896fc1a0>
payload = {'claim': 'insanity', 'exp': 1732854701, 'iss': 'jeff'}

    def test_decode_with_expiration_with_leeway(self, jwt, payload):
        payload["exp"] = utc_timestamp() - 2
        secret = "secret"
        jwt_message = jwt.encode(payload, secret)

        # With 5 seconds leeway, should be ok
        for leeway in (5, timedelta(seconds=5)):
>           decoded = jwt.decode(
                jwt_message, secret, leeway=leeway, algorithms=["HS256"]
            )

tests/test_api_jwt.py:370: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzAxLCJjbGFpbSI6Imluc2FuaXR5In0.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzAxLCJjbGFpbSI6Imluc2FuaXR5In0'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_with_notbefore_with_leeway">test_api_jwt.py::TestJWT::test_decode_with_notbefore_with_leeway</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_with_notbefore_with_leeway</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda896fee40>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda88855e20>
payload = {'claim': 'insanity', 'exp': 1732854718, 'iss': 'jeff', 'nbf': 1732854713}

    def test_decode_with_notbefore_with_leeway(self, jwt, payload):
        payload["nbf"] = utc_timestamp() + 10
        secret = "secret"
        jwt_message = jwt.encode(payload, secret)

        # With 13 seconds leeway, should be ok
>       jwt.decode(jwt_message, secret, leeway=13, algorithms=["HS256"])

tests/test_api_jwt.py:386: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE4LCJjbGFpbSI6Imluc2FuaXR5IiwibmJmIjoxNzMyODU0NzEzfQ.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE4LCJjbGFpbSI6Imluc2FuaXR5IiwibmJmIjoxNzMyODU0NzEzfQ'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_check_audience_when_valid">test_api_jwt.py::TestJWT::test_check_audience_when_valid</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_check_audience_when_valid</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda896ff980>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda888b9b50>

    def test_check_audience_when_valid(self, jwt):
        payload = {"some": "payload", "aud": "urn:me"}
        token = jwt.encode(payload, "secret")
>       jwt.decode(token, "secret", audience="urn:me", algorithms=["HS256"])

tests/test_api_jwt.py:394: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImF1ZCI6InVybjptZSJ9.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImF1ZCI6InVybjptZSJ9'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_check_audience_list_when_valid">test_api_jwt.py::TestJWT::test_check_audience_list_when_valid</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_check_audience_list_when_valid</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda896ff650>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda88877a10>

    def test_check_audience_list_when_valid(self, jwt):
        payload = {"some": "payload", "aud": "urn:me"}
        token = jwt.encode(payload, "secret")
>       jwt.decode(
            token,
            "secret",
            audience=["urn:you", "urn:me"],
            algorithms=["HS256"],
        )

tests/test_api_jwt.py:399: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImF1ZCI6InVybjptZSJ9.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImF1ZCI6InVybjptZSJ9'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_check_audience_none_specified">test_api_jwt.py::TestJWT::test_check_audience_none_specified</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_check_audience_none_specified</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88b80320>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda888542f0>

    def test_check_audience_none_specified(self, jwt):
        payload = {"some": "payload", "aud": "urn:me"}
        token = jwt.encode(payload, "secret")
        with pytest.raises(InvalidAudienceError):
>           jwt.decode(token, "secret", algorithms=["HS256"])

tests/test_api_jwt.py:410: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImF1ZCI6InVybjptZSJ9.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImF1ZCI6InVybjptZSJ9'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_raise_exception_invalid_audience_list">test_api_jwt.py::TestJWT::test_raise_exception_invalid_audience_list</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_raise_exception_invalid_audience_list</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88b83d10>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda888767b0>

    def test_raise_exception_invalid_audience_list(self, jwt):
        payload = {"some": "payload", "aud": "urn:me"}
        token = jwt.encode(payload, "secret")
        with pytest.raises(InvalidAudienceError):
>           jwt.decode(
                token,
                "secret",
                audience=["urn:you", "urn:him"],
                algorithms=["HS256"],
            )

tests/test_api_jwt.py:416: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImF1ZCI6InVybjptZSJ9.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImF1ZCI6InVybjptZSJ9'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_check_audience_in_array_when_valid">test_api_jwt.py::TestJWT::test_check_audience_in_array_when_valid</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_check_audience_in_array_when_valid</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88b83b00>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda88877b30>

    def test_check_audience_in_array_when_valid(self, jwt):
        payload = {"some": "payload", "aud": ["urn:me", "urn:someone-else"]}
        token = jwt.encode(payload, "secret")
>       jwt.decode(token, "secret", audience="urn:me", algorithms=["HS256"])

tests/test_api_jwt.py:426: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImF1ZCI6WyJ1cm46bWUiLCJ1cm46c29tZW9uZS1lbHNlIl19.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImF1ZCI6WyJ1cm46bWUiLCJ1cm46c29tZW9uZS1lbHNlIl19'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_raise_exception_invalid_audience">test_api_jwt.py::TestJWT::test_raise_exception_invalid_audience</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_raise_exception_invalid_audience</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88b83c80>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda88856ab0>

    def test_raise_exception_invalid_audience(self, jwt):
        payload = {"some": "payload", "aud": "urn:someone-else"}

        token = jwt.encode(payload, "secret")

        with pytest.raises(InvalidAudienceError):
>           jwt.decode(token, "secret", audience="urn-me", algorithms=["HS256"])

tests/test_api_jwt.py:434: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImF1ZCI6InVybjpzb21lb25lLWVsc2UifQ.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImF1ZCI6InVybjpzb21lb25lLWVsc2UifQ'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_raise_exception_audience_as_bytes">test_api_jwt.py::TestJWT::test_raise_exception_audience_as_bytes</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_raise_exception_audience_as_bytes</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88b83e60>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda888758e0>

    def test_raise_exception_audience_as_bytes(self, jwt):
        payload = {"some": "payload", "aud": ["urn:me", "urn:someone-else"]}
        token = jwt.encode(payload, "secret")
        with pytest.raises(InvalidAudienceError):
>           jwt.decode(
                token, "secret", audience="urn:me".encode(), algorithms=["HS256"]
            )

tests/test_api_jwt.py:440: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImF1ZCI6WyJ1cm46bWUiLCJ1cm46c29tZW9uZS1lbHNlIl19.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImF1ZCI6WyJ1cm46bWUiLCJ1cm46c29tZW9uZS1lbHNlIl19'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_raise_exception_invalid_audience_in_array">test_api_jwt.py::TestJWT::test_raise_exception_invalid_audience_in_array</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_raise_exception_invalid_audience_in_array</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88a12780>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda8889dc70>

    def test_raise_exception_invalid_audience_in_array(self, jwt):
        payload = {
            "some": "payload",
            "aud": ["urn:someone", "urn:someone-else"],
        }

        token = jwt.encode(payload, "secret")

        with pytest.raises(InvalidAudienceError):
>           jwt.decode(token, "secret", audience="urn:me", algorithms=["HS256"])

tests/test_api_jwt.py:453: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImF1ZCI6WyJ1cm46c29tZW9uZSIsInVybjpzb21lb25lLWVsc2UiXX0.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImF1ZCI6WyJ1cm46c29tZW9uZSIsInVybjpzb21lb25lLWVsc2UiXX0'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_raise_exception_token_without_issuer">test_api_jwt.py::TestJWT::test_raise_exception_token_without_issuer</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_raise_exception_token_without_issuer</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88a10380>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda888750d0>

    def test_raise_exception_token_without_issuer(self, jwt):
        issuer = "urn:wrong"

        payload = {"some": "payload"}

        token = jwt.encode(payload, "secret")

        with pytest.raises(MissingRequiredClaimError) as exc:
>           jwt.decode(token, "secret", issuer=issuer, algorithms=["HS256"])

tests/test_api_jwt.py:463: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCJ9.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCJ9'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_raise_exception_token_without_audience">test_api_jwt.py::TestJWT::test_raise_exception_token_without_audience</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_raise_exception_token_without_audience</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88a10b30>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda8889c980>

    def test_raise_exception_token_without_audience(self, jwt):
        payload = {"some": "payload"}
        token = jwt.encode(payload, "secret")

        with pytest.raises(MissingRequiredClaimError) as exc:
>           jwt.decode(token, "secret", audience="urn:me", algorithms=["HS256"])

tests/test_api_jwt.py:472: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCJ9.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCJ9'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_raise_exception_token_with_aud_none_and_without_audience">test_api_jwt.py::TestJWT::test_raise_exception_token_with_aud_none_and_without_audience</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_raise_exception_token_with_aud_none_and_without_audience</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88a11a30>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda8889ee70>

    def test_raise_exception_token_with_aud_none_and_without_audience(self, jwt):
        payload = {"some": "payload", "aud": None}
        token = jwt.encode(payload, "secret")

        with pytest.raises(MissingRequiredClaimError) as exc:
>           jwt.decode(token, "secret", audience="urn:me", algorithms=["HS256"])

tests/test_api_jwt.py:481: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImF1ZCI6bnVsbH0.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImF1ZCI6bnVsbH0'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_check_issuer_when_valid">test_api_jwt.py::TestJWT::test_check_issuer_when_valid</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_check_issuer_when_valid</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88a12660>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda88876150>

    def test_check_issuer_when_valid(self, jwt):
        issuer = "urn:foo"
        payload = {"some": "payload", "iss": "urn:foo"}
        token = jwt.encode(payload, "secret")
>       jwt.decode(token, "secret", issuer=issuer, algorithms=["HS256"])

tests/test_api_jwt.py:489: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImlzcyI6InVybjpmb28ifQ.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImlzcyI6InVybjpmb28ifQ'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_raise_exception_invalid_issuer">test_api_jwt.py::TestJWT::test_raise_exception_invalid_issuer</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_raise_exception_invalid_issuer</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88a130b0>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda8889da00>

    def test_raise_exception_invalid_issuer(self, jwt):
        issuer = "urn:wrong"

        payload = {"some": "payload", "iss": "urn:foo"}

        token = jwt.encode(payload, "secret")

        with pytest.raises(InvalidIssuerError):
>           jwt.decode(token, "secret", issuer=issuer, algorithms=["HS256"])

tests/test_api_jwt.py:499: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImlzcyI6InVybjpmb28ifQ.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImlzcyI6InVybjpmb28ifQ'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_skip_check_audience">test_api_jwt.py::TestJWT::test_skip_check_audience</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_skip_check_audience</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88a101d0>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda8889e480>

    def test_skip_check_audience(self, jwt):
        payload = {"some": "payload", "aud": "urn:me"}
        token = jwt.encode(payload, "secret")
>       jwt.decode(
            token,
            "secret",
            options={"verify_aud": False},
            algorithms=["HS256"],
        )

tests/test_api_jwt.py:504: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImF1ZCI6InVybjptZSJ9.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': False, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': False, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImF1ZCI6InVybjptZSJ9'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_skip_check_exp">test_api_jwt.py::TestJWT::test_skip_check_exp</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_skip_check_exp</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88a11910>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda8889d790>

    def test_skip_check_exp(self, jwt):
        payload = {
            "some": "payload",
            "exp": datetime.now(tz=timezone.utc) - timedelta(days=1),
        }
        token = jwt.encode(payload, "secret")
>       jwt.decode(
            token,
            "secret",
            options={"verify_exp": False},
            algorithms=["HS256"],
        )

tests/test_api_jwt.py:517: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImV4cCI6MTczMjc2ODMwM30.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': False, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': False, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImV4cCI6MTczMjc2ODMwM30'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_should_raise_error_if_exp_required_but_not_present">test_api_jwt.py::TestJWT::test_decode_should_raise_error_if_exp_required_but_not_present</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_should_raise_error_if_exp_required_but_not_present</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88a12ab0>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda88874d10>

    def test_decode_should_raise_error_if_exp_required_but_not_present(self, jwt):
        payload = {
            "some": "payload",
            # exp not present
        }
        token = jwt.encode(payload, "secret")

        with pytest.raises(MissingRequiredClaimError) as exc:
>           jwt.decode(
                token,
                "secret",
                options={"require": ["exp"]},
                algorithms=["HS256"],
            )

tests/test_api_jwt.py:532: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCJ9.'
key = 'secret', algorithms = ['HS256']
options = {'require': ['exp'], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': ['exp'], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCJ9'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_should_raise_error_if_iat_required_but_not_present">test_api_jwt.py::TestJWT::test_decode_should_raise_error_if_iat_required_but_not_present</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_should_raise_error_if_iat_required_but_not_present</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88a10620>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda888b1e80>

    def test_decode_should_raise_error_if_iat_required_but_not_present(self, jwt):
        payload = {
            "some": "payload",
            # iat not present
        }
        token = jwt.encode(payload, "secret")

        with pytest.raises(MissingRequiredClaimError) as exc:
>           jwt.decode(
                token,
                "secret",
                options={"require": ["iat"]},
                algorithms=["HS256"],
            )

tests/test_api_jwt.py:549: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCJ9.'
key = 'secret', algorithms = ['HS256']
options = {'require': ['iat'], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': ['iat'], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCJ9'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_should_raise_error_if_nbf_required_but_not_present">test_api_jwt.py::TestJWT::test_decode_should_raise_error_if_nbf_required_but_not_present</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_should_raise_error_if_nbf_required_but_not_present</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88a128a0>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda8889df70>

    def test_decode_should_raise_error_if_nbf_required_but_not_present(self, jwt):
        payload = {
            "some": "payload",
            # nbf not present
        }
        token = jwt.encode(payload, "secret")

        with pytest.raises(MissingRequiredClaimError) as exc:
>           jwt.decode(
                token,
                "secret",
                options={"require": ["nbf"]},
                algorithms=["HS256"],
            )

tests/test_api_jwt.py:566: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCJ9.'
key = 'secret', algorithms = ['HS256']
options = {'require': ['nbf'], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': ['nbf'], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCJ9'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_skip_check_iat">test_api_jwt.py::TestJWT::test_skip_check_iat</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_skip_check_iat</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88a102f0>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda8889e1b0>

    def test_skip_check_iat(self, jwt):
        payload = {
            "some": "payload",
            "iat": datetime.now(tz=timezone.utc) + timedelta(days=1),
        }
        token = jwt.encode(payload, "secret")
>       jwt.decode(
            token,
            "secret",
            options={"verify_iat": False},
            algorithms=["HS256"],
        )

tests/test_api_jwt.py:594: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImlhdCI6MTczMjk0MTEwM30.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': False, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': False, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsImlhdCI6MTczMjk0MTEwM30'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_skip_check_nbf">test_api_jwt.py::TestJWT::test_skip_check_nbf</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_skip_check_nbf</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88b83c50>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda8889e630>

    def test_skip_check_nbf(self, jwt):
        payload = {
            "some": "payload",
            "nbf": datetime.now(tz=timezone.utc) + timedelta(days=1),
        }
        token = jwt.encode(payload, "secret")
>       jwt.decode(
            token,
            "secret",
            options={"verify_nbf": False},
            algorithms=["HS256"],
        )

tests/test_api_jwt.py:607: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsIm5iZiI6MTczMjk0MTEwM30.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lIjoicGF5bG9hZCIsIm5iZiI6MTczMjk0MTEwM30'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_custom_json_encoder">test_api_jwt.py::TestJWT::test_custom_json_encoder</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_custom_json_encoder</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda896fecc0>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda888b9040>

    def test_custom_json_encoder(self, jwt):
        class CustomJSONEncoder(json.JSONEncoder):
            def default(self, o):
                if isinstance(o, Decimal):
                    return "it worked"
                return super().default(o)

        data = {"some_decimal": Decimal("2.2")}

        with pytest.raises(TypeError):
            jwt.encode(data, "secret", algorithms=["HS256"])

        token = jwt.encode(data, "secret", json_encoder=CustomJSONEncoder)
>       payload = jwt.decode(token, "secret", algorithms=["HS256"])

tests/test_api_jwt.py:627: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lX2RlY2ltYWwiOiJpdCB3b3JrZWQifQ.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzb21lX2RlY2ltYWwiOiJpdCB3b3JrZWQifQ'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_with_verify_exp_option">test_api_jwt.py::TestJWT::test_decode_with_verify_exp_option</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_with_verify_exp_option</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda896ffdd0>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda8889e630>
payload = {'claim': 'insanity', 'exp': 1732854702, 'iss': 'jeff'}

    def test_decode_with_verify_exp_option(self, jwt, payload):
        payload["exp"] = utc_timestamp() - 1
        secret = "secret"
        jwt_message = jwt.encode(payload, secret)

>       jwt.decode(
            jwt_message,
            secret,
            algorithms=["HS256"],
            options={"verify_exp": False},
        )

tests/test_api_jwt.py:636: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzAyLCJjbGFpbSI6Imluc2FuaXR5In0.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': False, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': False, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzAyLCJjbGFpbSI6Imluc2FuaXR5In0'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_with_verify_exp_option_and_signature_off">test_api_jwt.py::TestJWT::test_decode_with_verify_exp_option_and_signature_off</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_with_verify_exp_option_and_signature_off</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda896fea50>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda888ba5d0>
payload = {'claim': 'insanity', 'exp': 1732854702, 'iss': 'jeff'}

    def test_decode_with_verify_exp_option_and_signature_off(self, jwt, payload):
        payload["exp"] = utc_timestamp() - 1
        secret = "secret"
        jwt_message = jwt.encode(payload, secret)

>       jwt.decode(
            jwt_message,
            options={"verify_signature": False},
        )

tests/test_api_jwt.py:656: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jwt.PyJWT object at 0x7eda888ba5d0>
jwt = 'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzAyLCJjbGFpbSI6Imluc2FuaXR5In0.'
key = None, algorithms = None, options = {'verify_signature': False}
kwargs = {}
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
decoded = {'header': {'alg': 'none', 'typ': 'JWT'}, 'payload': b'{"iss":"jeff","exp":1732854702,"claim":"insanity"}', 'signature': b''}
payload = {'claim': 'insanity', 'exp': 1732854702, 'iss': 'jeff'}
now = datetime.datetime(2024, 11, 29, 4, 31, 43, 847841, tzinfo=datetime.timezone.utc)
exp = datetime.datetime(2024, 11, 29, 4, 31, 42, tzinfo=datetime.timezone.utc)
leeway = datetime.timedelta(0)

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, **kwargs: Any) -> dict[str, Any]:
        """
        Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        merged_options = {**self.options, **(options or {})}
        decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
        payload = self._decode_payload(decoded)

        if merged_options['verify_exp'] and 'exp' in payload:
            now = kwargs.get('now', datetime.now(timezone.utc))
            exp = datetime.fromtimestamp(payload['exp'], tz=timezone.utc)
            leeway = timedelta(seconds=kwargs.get('leeway', 0))
            if now > exp + leeway:
>               raise ExpiredSignatureError('Signature has expired')
E               jwt.exceptions.ExpiredSignatureError: Signature has expired

jwt/api_jwt.py:119: ExpiredSignatureError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_with_optional_algorithms">test_api_jwt.py::TestJWT::test_decode_with_optional_algorithms</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_with_optional_algorithms</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88a13bc0>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda88875e80>
payload = {'claim': 'insanity', 'exp': 1732854718, 'iss': 'jeff'}

    def test_decode_with_optional_algorithms(self, jwt, payload):
        secret = "secret"
        jwt_message = jwt.encode(payload, secret)

        with pytest.raises(DecodeError) as exc:
            jwt.decode(jwt_message, secret)

>       assert (
            'It is required that you pass in a value for the "algorithms" argument when calling decode().'
            in str(exc.value)
        )
E       assert 'It is required that you pass in a value for the "algorithms" argument when calling decode().' in 'Algorithm "none" not allowed'
E        +  where 'Algorithm "none" not allowed' = str(DecodeError('Algorithm "none" not allowed'))
E        +    where DecodeError('Algorithm "none" not allowed') = <ExceptionInfo DecodeError('Algorithm "none" not allowed') tblen=4>.value

tests/test_api_jwt.py:674: AssertionError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_no_algorithms_verify_signature_false">test_api_jwt.py::TestJWT::test_decode_no_algorithms_verify_signature_false</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_no_algorithms_verify_signature_false</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88a12720>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda88876810>
payload = {'claim': 'insanity', 'exp': 1732854718, 'iss': 'jeff'}

    def test_decode_no_algorithms_verify_signature_false(self, jwt, payload):
        secret = "secret"
        jwt_message = jwt.encode(payload, secret)

>       jwt.decode(jwt_message, secret, options={"verify_signature": False})

tests/test_api_jwt.py:683: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE4LCJjbGFpbSI6Imluc2FuaXR5In0.'
key = 'secret'
algorithms = ['ES384', 'RS384', 'EdDSA', 'HS256', 'RS256', 'RS512', ...]
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE4LCJjbGFpbSI6Imluc2FuaXR5In0'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
            raise InvalidAlgorithmError('The specified alg value is not allowed')

        if alg == 'none':
            if merged_options['verify_signature']:
                raise DecodeError('Algorithm "none" not allowed')
            if key not in [None, '', 'none']:
>               raise InvalidKeyError('When alg = "none", key must be empty or "none"')
E               NameError: name 'InvalidKeyError' is not defined

jwt/api_jws.py:284: NameError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_legacy_verify_warning">test_api_jwt.py::TestJWT::test_decode_legacy_verify_warning</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_legacy_verify_warning</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88a12d20>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda88874bc0>
payload = {'claim': 'insanity', 'exp': 1732854718, 'iss': 'jeff'}

    def test_decode_legacy_verify_warning(self, jwt, payload):
        secret = "secret"
        jwt_message = jwt.encode(payload, secret)

        with pytest.deprecated_call():
            # The implicit default for options.verify_signature is True,
            # but the user sets verify to False.
>           jwt.decode(jwt_message, secret, verify=False, algorithms=["HS256"])

tests/test_api_jwt.py:692: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE4LCJjbGFpbSI6Imluc2FuaXR5In0.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE4LCJjbGFpbSI6Imluc2FuaXR5In0'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError

During handling of the above exception, another exception occurred:

self = <tests.test_api_jwt.TestJWT object at 0x7eda88a12d20>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda88874bc0>
payload = {'claim': 'insanity', 'exp': 1732854718, 'iss': 'jeff'}

    def test_decode_legacy_verify_warning(self, jwt, payload):
        secret = "secret"
        jwt_message = jwt.encode(payload, secret)

>       with pytest.deprecated_call():
E       Failed: DID NOT WARN. No warnings of type (<class 'DeprecationWarning'>, <class 'PendingDeprecationWarning'>, <class 'FutureWarning'>) were emitted.
E        Emitted warnings: [].

tests/test_api_jwt.py:689: Failed
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_no_options_mutation">test_api_jwt.py::TestJWT::test_decode_no_options_mutation</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_no_options_mutation</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88a10650>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda8889f6e0>
payload = {'claim': 'insanity', 'exp': 1732854718, 'iss': 'jeff'}

    def test_decode_no_options_mutation(self, jwt, payload):
        options = {"verify_signature": True}
        orig_options = options.copy()
        secret = "secret"
        jwt_message = jwt.encode(payload, secret)
>       jwt.decode(jwt_message, secret, options=options, algorithms=["HS256"])

tests/test_api_jwt.py:706: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE4LCJjbGFpbSI6Imluc2FuaXR5In0.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE4LCJjbGFpbSI6Imluc2FuaXR5In0'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_warns_on_unsupported_kwarg">test_api_jwt.py::TestJWT::test_decode_warns_on_unsupported_kwarg</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_warns_on_unsupported_kwarg</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88a10590>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda88a103e0>
payload = {'claim': 'insanity', 'exp': 1732854718, 'iss': 'jeff'}

    def test_decode_warns_on_unsupported_kwarg(self, jwt, payload):
        secret = "secret"
        jwt_message = jwt.encode(payload, secret)

        with pytest.warns(RemovedInPyjwt3Warning) as record:
>           jwt.decode(jwt_message, secret, algorithms=["HS256"], foo="bar")

tests/test_api_jwt.py:714: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE4LCJjbGFpbSI6Imluc2FuaXR5In0.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE4LCJjbGFpbSI6Imluc2FuaXR5In0'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError

During handling of the above exception, another exception occurred:

self = <tests.test_api_jwt.TestJWT object at 0x7eda88a10590>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda88a103e0>
payload = {'claim': 'insanity', 'exp': 1732854718, 'iss': 'jeff'}

    def test_decode_warns_on_unsupported_kwarg(self, jwt, payload):
        secret = "secret"
        jwt_message = jwt.encode(payload, secret)

>       with pytest.warns(RemovedInPyjwt3Warning) as record:
E       Failed: DID NOT WARN. No warnings of type (<class 'jwt.warnings.RemovedInPyjwt3Warning'>,) were emitted.
E        Emitted warnings: [].

tests/test_api_jwt.py:713: Failed
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_complete_warns_on_unsupported_kwarg">test_api_jwt.py::TestJWT::test_decode_complete_warns_on_unsupported_kwarg</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_complete_warns_on_unsupported_kwarg</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88a10800>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda8889cf80>
payload = {'claim': 'insanity', 'exp': 1732854719, 'iss': 'jeff'}

    def test_decode_complete_warns_on_unsupported_kwarg(self, jwt, payload):
        secret = "secret"
        jwt_message = jwt.encode(payload, secret)

        with pytest.warns(RemovedInPyjwt3Warning) as record:
>           jwt.decode_complete(jwt_message, secret, algorithms=["HS256"], foo="bar")

tests/test_api_jwt.py:723: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE5LCJjbGFpbSI6Imluc2FuaXR5In0.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE5LCJjbGFpbSI6Imluc2FuaXR5In0'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError

During handling of the above exception, another exception occurred:

self = <tests.test_api_jwt.TestJWT object at 0x7eda88a10800>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda8889cf80>
payload = {'claim': 'insanity', 'exp': 1732854719, 'iss': 'jeff'}

    def test_decode_complete_warns_on_unsupported_kwarg(self, jwt, payload):
        secret = "secret"
        jwt_message = jwt.encode(payload, secret)

>       with pytest.warns(RemovedInPyjwt3Warning) as record:
E       Failed: DID NOT WARN. No warnings of type (<class 'jwt.warnings.RemovedInPyjwt3Warning'>,) were emitted.
E        Emitted warnings: [].

tests/test_api_jwt.py:722: Failed
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_strict_aud_forbids_list_audience">test_api_jwt.py::TestJWT::test_decode_strict_aud_forbids_list_audience</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_strict_aud_forbids_list_audience</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88a10a40>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda88856120>
payload = {'aud': 'urn:foo', 'claim': 'insanity', 'exp': 1732854719, 'iss': 'jeff'}

    def test_decode_strict_aud_forbids_list_audience(self, jwt, payload):
        secret = "secret"
        payload["aud"] = "urn:foo"
        jwt_message = jwt.encode(payload, secret)

        # Decodes without `strict_aud`.
>       jwt.decode(
            jwt_message,
            secret,
            audience=["urn:foo", "urn:bar"],
            options={"strict_aud": False},
            algorithms=["HS256"],
        )

tests/test_api_jwt.py:733: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE5LCJjbGFpbSI6Imluc2FuaXR5IiwiYXVkIjoidXJuOmZvbyJ9.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'strict_aud': False, 'verify_aud': True, 'verify_exp': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'strict_aud': False, 'verify_aud': True, 'verify_exp': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE5LCJjbGFpbSI6Imluc2FuaXR5IiwiYXVkIjoidXJuOmZvbyJ9'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_strict_aud_forbids_list_claim">test_api_jwt.py::TestJWT::test_decode_strict_aud_forbids_list_claim</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_strict_aud_forbids_list_claim</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88a10cb0>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda888b3c20>
payload = {'aud': ['urn:foo', 'urn:bar'], 'claim': 'insanity', 'exp': 1732854719, 'iss': 'jeff'}

    def test_decode_strict_aud_forbids_list_claim(self, jwt, payload):
        secret = "secret"
        payload["aud"] = ["urn:foo", "urn:bar"]
        jwt_message = jwt.encode(payload, secret)

        # Decodes without `strict_aud`.
>       jwt.decode(
            jwt_message,
            secret,
            audience="urn:foo",
            options={"strict_aud": False},
            algorithms=["HS256"],
        )

tests/test_api_jwt.py:757: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE5LCJjbGFpbSI6Imluc2FuaXR5IiwiYXVkIjpbInVybjpmb28iLCJ1cm46YmFyIl19.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'strict_aud': False, 'verify_aud': True, 'verify_exp': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'strict_aud': False, 'verify_aud': True, 'verify_exp': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE5LCJjbGFpbSI6Imluc2FuaXR5IiwiYXVkIjpbInVybjpmb28iLCJ1cm46YmFyIl19'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_strict_aud_does_not_match">test_api_jwt.py::TestJWT::test_decode_strict_aud_does_not_match</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_strict_aud_does_not_match</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88a10e90>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda8889f6e0>
payload = {'aud': 'urn:foo', 'claim': 'insanity', 'exp': 1732854719, 'iss': 'jeff'}

    def test_decode_strict_aud_does_not_match(self, jwt, payload):
        secret = "secret"
        payload["aud"] = "urn:foo"
        jwt_message = jwt.encode(payload, secret)

        with pytest.raises(
            InvalidAudienceError, match=r"Audience doesn't match \(strict\)"
        ):
>           jwt.decode(
                jwt_message,
                secret,
                audience="urn:bar",
                options={"strict_aud": True},
                algorithms=["HS256"],
            )

tests/test_api_jwt.py:785: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE5LCJjbGFpbSI6Imluc2FuaXR5IiwiYXVkIjoidXJuOmZvbyJ9.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'strict_aud': True, 'verify_aud': True, 'verify_exp': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'strict_aud': True, 'verify_aud': True, 'verify_exp': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE5LCJjbGFpbSI6Imluc2FuaXR5IiwiYXVkIjoidXJuOmZvbyJ9'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_api_jwtpytestjwttest_decode_strict_ok">test_api_jwt.py::TestJWT::test_decode_strict_ok</h3>
<details><summary> <pre>test_api_jwt.py::TestJWT::test_decode_strict_ok</pre></summary><pre>
self = <tests.test_api_jwt.TestJWT object at 0x7eda88a11100>
jwt = <jwt.api_jwt.PyJWT object at 0x7eda888b0830>
payload = {'aud': 'urn:foo', 'claim': 'insanity', 'exp': 1732854719, 'iss': 'jeff'}

    def test_decode_strict_ok(self, jwt, payload):
        secret = "secret"
        payload["aud"] = "urn:foo"
        jwt_message = jwt.encode(payload, secret)

>       jwt.decode(
            jwt_message,
            secret,
            audience="urn:foo",
            options={"strict_aud": True},
            algorithms=["HS256"],
        )

tests/test_api_jwt.py:798: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/api_jwt.py:170: in decode
    decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)
jwt/api_jwt.py:111: in decode_complete
    decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jws.PyJWS object at 0x7eda89b3c560>
jwt = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE5LCJjbGFpbSI6Imluc2FuaXR5IiwiYXVkIjoidXJuOmZvbyJ9.'
key = 'secret', algorithms = ['HS256']
options = {'require': [], 'strict_aud': True, 'verify_aud': True, 'verify_exp': True, ...}
detached_payload = None, kwargs = {}
deprecated_kwargs = {'verify': 'verify_signature', 'verify_aud': 'verify_aud', 'verify_exp': 'verify_exp', 'verify_iat': 'verify_iat', ...}
old_name = 'verify_iss', new_name = 'verify_iss'
merged_options = {'require': [], 'strict_aud': True, 'verify_aud': True, 'verify_exp': True, ...}
signing_input = b'eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJqZWZmIiwiZXhwIjoxNzMyODU0NzE5LCJjbGFpbSI6Imluc2FuaXR5IiwiYXVkIjoidXJuOmZvbyJ9'
crypto_segment = b''

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -> dict[str, Any]:
        """Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            detached_payload: The detached payload to use for verification.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        deprecated_kwargs = {
            'verify': 'verify_signature',
            'verify_exp': 'verify_exp',
            'verify_iat': 'verify_iat',
            'verify_nbf': 'verify_nbf',
            'verify_aud': 'verify_aud',
            'verify_iss': 'verify_iss',
        }

        options = options or {}
        for old_name, new_name in deprecated_kwargs.items():
            if old_name in kwargs:
                warnings.warn(
                    f'The {old_name} parameter is deprecated. '
                    f'Please use {new_name} in options instead.',
                    category=DeprecationWarning,
                    stacklevel=2
                )
                options[new_name] = kwargs.pop(old_name)

        for kwarg in kwargs:
            warnings.warn(
                f'The "{kwarg}" argument is not supported and will be ignored.',
                category=RemovedInPyjwt3Warning,
                stacklevel=2
            )

        merged_options = {**self.options}
        if options:
            if not isinstance(options, dict):
                raise TypeError('options must be a dict')
            merged_options.update(options)

        if isinstance(jwt, str):
            jwt = jwt.encode('utf-8')

        if not isinstance(jwt, bytes):
            raise DecodeError('Invalid token type')

        try:
            signing_input, crypto_segment = jwt.rsplit(b'.', 1)
            header_segment, payload_segment = signing_input.split(b'.', 1)
        except ValueError:
            raise InvalidTokenError('Not enough segments')

        try:
            header_data = base64url_decode(header_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid header padding')

        try:
            header = json.loads(header_data.decode('utf-8'))
        except ValueError as e:
            raise DecodeError('Invalid header string: %s' % e)

        if not isinstance(header, dict):
            raise DecodeError('Invalid header string: must be a json object')

        if header.get('b64', True):
            try:
                payload = base64url_decode(payload_segment)
            except (TypeError, binascii.Error):
                raise DecodeError('Invalid payload padding')
        else:
            if detached_payload is None:
                raise DecodeError('It is required that you pass in a value for the "detached_payload" argument to decode a message using unencoded payload.')
            payload = detached_payload

        try:
            signature = base64url_decode(crypto_segment)
        except (TypeError, binascii.Error):
            raise DecodeError('Invalid crypto padding')

        if algorithms is None:
            algorithms = list(self._valid_algs)

        if not algorithms and merged_options['verify_signature']:
            raise DecodeError('No algorithms were specified')

        try:
            alg = header['alg']
        except KeyError:
            raise InvalidTokenError('Missing algorithm ("alg") in headers')

        if alg not in algorithms:
>           raise InvalidAlgorithmError('The specified alg value is not allowed')
E           jwt.exceptions.InvalidAlgorithmError: The specified alg value is not allowed

jwt/api_jws.py:278: InvalidAlgorithmError
</pre>
</details>
<h3 id="test_jwks_clientpytestpyjwkclienttest_get_signing_keys_raises_if_none_found">test_jwks_client.py::TestPyJWKClient::test_get_signing_keys_raises_if_none_found</h3>
<details><summary> <pre>test_jwks_client.py::TestPyJWKClient::test_get_signing_keys_raises_if_none_found</pre></summary><pre>
self = <tests.test_jwks_client.TestPyJWKClient object at 0x7eda88bee6c0>

    def test_get_signing_keys_raises_if_none_found(self):
        url = "https://dev-87evx9ru.auth0.com/.well-known/jwks.json"

        mocked_key = RESPONSE_DATA_WITH_MATCHING_KID["keys"][0].copy()
        mocked_key["use"] = "enc"
        response = {"keys": [mocked_key]}
        with mocked_success_response(response):
            jwks_client = PyJWKClient(url)

            with pytest.raises(PyJWKClientError) as exc:
                jwks_client.get_signing_keys()

>       assert "The JWKS endpoint did not contain any signing keys" in str(exc.value)
E       AssertionError: assert 'The JWKS endpoint did not contain any signing keys' in 'No signing keys found in JWKS'
E        +  where 'No signing keys found in JWKS' = str(PyJWKClientError('No signing keys found in JWKS'))
E        +    where PyJWKClientError('No signing keys found in JWKS') = <ExceptionInfo PyJWKClientError('No signing keys found in JWKS') tblen=2>.value

tests/test_jwks_client.py:149: AssertionError
</pre>
</details>
<h3 id="test_jwks_clientpytestpyjwkclienttest_get_signing_key_from_jwt">test_jwks_client.py::TestPyJWKClient::test_get_signing_key_from_jwt</h3>
<details><summary> <pre>test_jwks_client.py::TestPyJWKClient::test_get_signing_key_from_jwt</pre></summary><pre>
self = <jwt.jwks_client.PyJWKClient object at 0x7eda899112e0>
token = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6Ik5FRTFRVVJCT1RNNE16STVSa0ZETlRZeE9UVTFNRGcyT0Rnd1EwVXpNVGsxUWpZeVJrUkZRd...kc_hdy-6ZMoKT6Piijvk_aXdm7-QQqKJFHLuEqrVSOuBqqiNfVrG27QzAPuPOxvfXTVLXL2jek5meH6n-VWgrBdoMFH93QEszEDowDAEhQPHVs0xj7SIzA'
refresh_jwks = True

    def get_signing_key_from_jwt(self, token: str, refresh_jwks: bool=True) -> PyJWK:
        """Return the signing key from the JWKS that matches the kid in the token header.

        Args:
            token: The JWT token to get the key for.
            refresh_jwks: Whether to refresh the JWKS if the key is not found.
        """
        try:
>           headers = decode_token(token, options={'verify_signature': False})['header']

jwt/jwks_client.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jwt.PyJWT object at 0x7eda89911730>
jwt = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6Ik5FRTFRVVJCT1RNNE16STVSa0ZETlRZeE9UVTFNRGcyT0Rnd1EwVXpNVGsxUWpZeVJrUkZRd...kc_hdy-6ZMoKT6Piijvk_aXdm7-QQqKJFHLuEqrVSOuBqqiNfVrG27QzAPuPOxvfXTVLXL2jek5meH6n-VWgrBdoMFH93QEszEDowDAEhQPHVs0xj7SIzA'
key = None, algorithms = None, options = {'verify_signature': False}
kwargs = {}
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
decoded = {'header': {'alg': 'RS256', 'kid': 'NEE1QURBOTM4MzI5RkFDNTYxOTU1MDg2ODgwQ0UzMTk1QjYyRkRFQw', 'typ': 'JWT'}, 'payload':...f;\x1b\xdf]5K\\\xbd\xa3zNfx~\xa7\xf9U\xa0\xac\x17h0Q\xfd\xdd\x01,\xcc@\xe8\xc00\x04\x85\x03\xc7V\xcd1\x8f\xb4\x88\xcc'}
payload = {'aud': 'https://expenses-api', 'azp': 'aW4Cca79xReLWUz0aE2H6kD0O3cXBVtC', 'exp': 1572006964, 'gty': 'client-credentials', ...}
now = datetime.datetime(2024, 11, 29, 4, 31, 44, 182936, tzinfo=datetime.timezone.utc)
exp = datetime.datetime(2019, 10, 25, 12, 36, 4, tzinfo=datetime.timezone.utc)
leeway = datetime.timedelta(0)

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, **kwargs: Any) -> dict[str, Any]:
        """
        Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        merged_options = {**self.options, **(options or {})}
        decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
        payload = self._decode_payload(decoded)

        if merged_options['verify_exp'] and 'exp' in payload:
            now = kwargs.get('now', datetime.now(timezone.utc))
            exp = datetime.fromtimestamp(payload['exp'], tz=timezone.utc)
            leeway = timedelta(seconds=kwargs.get('leeway', 0))
            if now > exp + leeway:
>               raise ExpiredSignatureError('Signature has expired')
E               jwt.exceptions.ExpiredSignatureError: Signature has expired

jwt/api_jwt.py:119: ExpiredSignatureError

During handling of the above exception, another exception occurred:

self = <tests.test_jwks_client.TestPyJWKClient object at 0x7eda88bec2c0>

    def test_get_signing_key_from_jwt(self):
        token = "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6Ik5FRTFRVVJCT1RNNE16STVSa0ZETlRZeE9UVTFNRGcyT0Rnd1EwVXpNVGsxUWpZeVJrUkZRdyJ9.eyJpc3MiOiJodHRwczovL2Rldi04N2V2eDlydS5hdXRoMC5jb20vIiwic3ViIjoiYVc0Q2NhNzl4UmVMV1V6MGFFMkg2a0QwTzNjWEJWdENAY2xpZW50cyIsImF1ZCI6Imh0dHBzOi8vZXhwZW5zZXMtYXBpIiwiaWF0IjoxNTcyMDA2OTU0LCJleHAiOjE1NzIwMDY5NjQsImF6cCI6ImFXNENjYTc5eFJlTFdVejBhRTJINmtEME8zY1hCVnRDIiwiZ3R5IjoiY2xpZW50LWNyZWRlbnRpYWxzIn0.PUxE7xn52aTCohGiWoSdMBZGiYAHwE5FYie0Y1qUT68IHSTXwXVd6hn02HTah6epvHHVKA2FqcFZ4GGv5VTHEvYpeggiiZMgbxFrmTEY0csL6VNkX1eaJGcuehwQCRBKRLL3zKmA5IKGy5GeUnIbpPHLHDxr-GXvgFzsdsyWlVQvPX2xjeaQ217r2PtxDeqjlf66UYl6oY6AqNS8DH3iryCvIfCcybRZkc_hdy-6ZMoKT6Piijvk_aXdm7-QQqKJFHLuEqrVSOuBqqiNfVrG27QzAPuPOxvfXTVLXL2jek5meH6n-VWgrBdoMFH93QEszEDowDAEhQPHVs0xj7SIzA"
        url = "https://dev-87evx9ru.auth0.com/.well-known/jwks.json"

        with mocked_success_response(RESPONSE_DATA_WITH_MATCHING_KID):
            jwks_client = PyJWKClient(url)
>           signing_key = jwks_client.get_signing_key_from_jwt(token)

tests/test_jwks_client.py:202: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.jwks_client.PyJWKClient object at 0x7eda899112e0>
token = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6Ik5FRTFRVVJCT1RNNE16STVSa0ZETlRZeE9UVTFNRGcyT0Rnd1EwVXpNVGsxUWpZeVJrUkZRd...kc_hdy-6ZMoKT6Piijvk_aXdm7-QQqKJFHLuEqrVSOuBqqiNfVrG27QzAPuPOxvfXTVLXL2jek5meH6n-VWgrBdoMFH93QEszEDowDAEhQPHVs0xj7SIzA'
refresh_jwks = True

    def get_signing_key_from_jwt(self, token: str, refresh_jwks: bool=True) -> PyJWK:
        """Return the signing key from the JWKS that matches the kid in the token header.

        Args:
            token: The JWT token to get the key for.
            refresh_jwks: Whether to refresh the JWKS if the key is not found.
        """
        try:
            headers = decode_token(token, options={'verify_signature': False})['header']
        except Exception as e:
>           raise PyJWKClientError(f'Failed to decode JWT headers: {str(e)}')
E           jwt.exceptions.PyJWKClientError: Failed to decode JWT headers: Signature has expired

jwt/jwks_client.py:111: PyJWKClientError
</pre>
</details>
<h3 id="test_jwks_clientpytestpyjwkclienttest_failed_request_should_raise_connection_error">test_jwks_client.py::TestPyJWKClient::test_failed_request_should_raise_connection_error</h3>
<details><summary> <pre>test_jwks_client.py::TestPyJWKClient::test_failed_request_should_raise_connection_error</pre></summary><pre>
self = <jwt.jwks_client.PyJWKClient object at 0x7eda885d0680>
token = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6Ik5FRTFRVVJCT1RNNE16STVSa0ZETlRZeE9UVTFNRGcyT0Rnd1EwVXpNVGsxUWpZeVJrUkZRd...kc_hdy-6ZMoKT6Piijvk_aXdm7-QQqKJFHLuEqrVSOuBqqiNfVrG27QzAPuPOxvfXTVLXL2jek5meH6n-VWgrBdoMFH93QEszEDowDAEhQPHVs0xj7SIzA'
refresh_jwks = True

    def get_signing_key_from_jwt(self, token: str, refresh_jwks: bool=True) -> PyJWK:
        """Return the signing key from the JWKS that matches the kid in the token header.

        Args:
            token: The JWT token to get the key for.
            refresh_jwks: Whether to refresh the JWKS if the key is not found.
        """
        try:
>           headers = decode_token(token, options={'verify_signature': False})['header']

jwt/jwks_client.py:109: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.api_jwt.PyJWT object at 0x7eda89911730>
jwt = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6Ik5FRTFRVVJCT1RNNE16STVSa0ZETlRZeE9UVTFNRGcyT0Rnd1EwVXpNVGsxUWpZeVJrUkZRd...kc_hdy-6ZMoKT6Piijvk_aXdm7-QQqKJFHLuEqrVSOuBqqiNfVrG27QzAPuPOxvfXTVLXL2jek5meH6n-VWgrBdoMFH93QEszEDowDAEhQPHVs0xj7SIzA'
key = None, algorithms = None, options = {'verify_signature': False}
kwargs = {}
merged_options = {'require': [], 'verify_aud': True, 'verify_exp': True, 'verify_iat': True, ...}
decoded = {'header': {'alg': 'RS256', 'kid': 'NEE1QURBOTM4MzI5RkFDNTYxOTU1MDg2ODgwQ0UzMTk1QjYyRkRFQw', 'typ': 'JWT'}, 'payload':...f;\x1b\xdf]5K\\\xbd\xa3zNfx~\xa7\xf9U\xa0\xac\x17h0Q\xfd\xdd\x01,\xcc@\xe8\xc00\x04\x85\x03\xc7V\xcd1\x8f\xb4\x88\xcc'}
payload = {'aud': 'https://expenses-api', 'azp': 'aW4Cca79xReLWUz0aE2H6kD0O3cXBVtC', 'exp': 1572006964, 'gty': 'client-credentials', ...}
now = datetime.datetime(2024, 11, 29, 4, 31, 48, 215542, tzinfo=datetime.timezone.utc)
exp = datetime.datetime(2019, 10, 25, 12, 36, 4, tzinfo=datetime.timezone.utc)
leeway = datetime.timedelta(0)

    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, **kwargs: Any) -> dict[str, Any]:
        """
        Decodes a JWT and returns a dict of the token contents.

        Args:
            jwt: The JWT to decode.
            key: The key to use for verifying the claim. Note: if the algorithm is 'none', the key is not used.
            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.
            options: A dict of options for decoding. If None, use default options.
            **kwargs: Additional options for decoding.

        Returns:
            A dict including:
                - header: A dict of the JWT header
                - payload: The decoded payload
                - signature: The signature of the JWT
        """
        merged_options = {**self.options, **(options or {})}
        decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)
        payload = self._decode_payload(decoded)

        if merged_options['verify_exp'] and 'exp' in payload:
            now = kwargs.get('now', datetime.now(timezone.utc))
            exp = datetime.fromtimestamp(payload['exp'], tz=timezone.utc)
            leeway = timedelta(seconds=kwargs.get('leeway', 0))
            if now > exp + leeway:
>               raise ExpiredSignatureError('Signature has expired')
E               jwt.exceptions.ExpiredSignatureError: Signature has expired

jwt/api_jwt.py:119: ExpiredSignatureError

During handling of the above exception, another exception occurred:

self = <tests.test_jwks_client.TestPyJWKClient object at 0x7eda88beeed0>

    def test_failed_request_should_raise_connection_error(self):
        token = "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6Ik5FRTFRVVJCT1RNNE16STVSa0ZETlRZeE9UVTFNRGcyT0Rnd1EwVXpNVGsxUWpZeVJrUkZRdyJ9.eyJpc3MiOiJodHRwczovL2Rldi04N2V2eDlydS5hdXRoMC5jb20vIiwic3ViIjoiYVc0Q2NhNzl4UmVMV1V6MGFFMkg2a0QwTzNjWEJWdENAY2xpZW50cyIsImF1ZCI6Imh0dHBzOi8vZXhwZW5zZXMtYXBpIiwiaWF0IjoxNTcyMDA2OTU0LCJleHAiOjE1NzIwMDY5NjQsImF6cCI6ImFXNENjYTc5eFJlTFdVejBhRTJINmtEME8zY1hCVnRDIiwiZ3R5IjoiY2xpZW50LWNyZWRlbnRpYWxzIn0.PUxE7xn52aTCohGiWoSdMBZGiYAHwE5FYie0Y1qUT68IHSTXwXVd6hn02HTah6epvHHVKA2FqcFZ4GGv5VTHEvYpeggiiZMgbxFrmTEY0csL6VNkX1eaJGcuehwQCRBKRLL3zKmA5IKGy5GeUnIbpPHLHDxr-GXvgFzsdsyWlVQvPX2xjeaQ217r2PtxDeqjlf66UYl6oY6AqNS8DH3iryCvIfCcybRZkc_hdy-6ZMoKT6Piijvk_aXdm7-QQqKJFHLuEqrVSOuBqqiNfVrG27QzAPuPOxvfXTVLXL2jek5meH6n-VWgrBdoMFH93QEszEDowDAEhQPHVs0xj7SIzA"
        url = "https://dev-87evx9ru.auth0.com/.well-known/jwks.json"

        jwks_client = PyJWKClient(url)
        with pytest.raises(PyJWKClientConnectionError):
            with mocked_failed_response():
>               jwks_client.get_signing_key_from_jwt(token)

tests/test_jwks_client.py:294: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.jwks_client.PyJWKClient object at 0x7eda885d0680>
token = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImtpZCI6Ik5FRTFRVVJCT1RNNE16STVSa0ZETlRZeE9UVTFNRGcyT0Rnd1EwVXpNVGsxUWpZeVJrUkZRd...kc_hdy-6ZMoKT6Piijvk_aXdm7-QQqKJFHLuEqrVSOuBqqiNfVrG27QzAPuPOxvfXTVLXL2jek5meH6n-VWgrBdoMFH93QEszEDowDAEhQPHVs0xj7SIzA'
refresh_jwks = True

    def get_signing_key_from_jwt(self, token: str, refresh_jwks: bool=True) -> PyJWK:
        """Return the signing key from the JWKS that matches the kid in the token header.

        Args:
            token: The JWT token to get the key for.
            refresh_jwks: Whether to refresh the JWKS if the key is not found.
        """
        try:
            headers = decode_token(token, options={'verify_signature': False})['header']
        except Exception as e:
>           raise PyJWKClientError(f'Failed to decode JWT headers: {str(e)}')
E           jwt.exceptions.PyJWKClientError: Failed to decode JWT headers: Signature has expired

jwt/jwks_client.py:111: PyJWKClientError
</pre>
</details>
<h3 id="test_jwks_clientpytestpyjwkclienttest_get_jwt_set_refresh_cache">test_jwks_client.py::TestPyJWKClient::test_get_jwt_set_refresh_cache</h3>
<details><summary> <pre>test_jwks_client.py::TestPyJWKClient::test_get_jwt_set_refresh_cache</pre></summary><pre>
self = <tests.test_jwks_client.TestPyJWKClient object at 0x7eda88bef140>

    def test_get_jwt_set_refresh_cache(self):
        url = "https://dev-87evx9ru.auth0.com/.well-known/jwks.json"
        jwks_client = PyJWKClient(url)

        kid = "NEE1QURBOTM4MzI5RkFDNTYxOTU1MDg2ODgwQ0UzMTk1QjYyRkRFQw"

        # The first call will return response with no matching kid,
        # the function should make another call to try to refresh the cache.
        with mocked_first_call_wrong_kid_second_call_correct_kid(
            RESPONSE_DATA_NO_MATCHING_KID, RESPONSE_DATA_WITH_MATCHING_KID
        ) as call_data:
>           jwks_client.get_signing_key(kid)

tests/test_jwks_client.py:307: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <jwt.jwks_client.PyJWKClient object at 0x7eda888b2ba0>
kid = 'NEE1QURBOTM4MzI5RkFDNTYxOTU1MDg2ODgwQ0UzMTk1QjYyRkRFQw'

    def get_signing_key(self, kid: str) -> PyJWK:
        """Return the signing key from the JWKS that matches the provided kid.

        Args:
            kid: The key ID to search for.
        """
        signing_keys = self.get_signing_keys()
        for key in signing_keys:
            if key.key_id == kid:
                return key

        # If no key is found, try refreshing the JWKS once
        signing_keys = self.get_signing_keys()
        for key in signing_keys:
            if key.key_id == kid:
                return key

>       raise PyJWKClientError(f'Unable to find a signing key that matches: {kid}')
E       jwt.exceptions.PyJWKClientError: Unable to find a signing key that matches: NEE1QURBOTM4MzI5RkFDNTYxOTU1MDg2ODgwQ0UzMTk1QjYyRkRFQw

jwt/jwks_client.py:99: PyJWKClientError
</pre>
</details>
<h3 id="test_jwks_clientpytestpyjwkclienttest_get_jwt_set_timeout">test_jwks_client.py::TestPyJWKClient::test_get_jwt_set_timeout</h3>
<details><summary> <pre>test_jwks_client.py::TestPyJWKClient::test_get_jwt_set_timeout</pre></summary><pre>
self = <tests.test_jwks_client.TestPyJWKClient object at 0x7eda88bef7a0>

    def test_get_jwt_set_timeout(self):
        url = "https://dev-87evx9ru.auth0.com/.well-known/jwks.json"
        jwks_client = PyJWKClient(url, timeout=5)

        with pytest.raises(PyJWKClientError) as exc:
            with mocked_timeout():
>               jwks_client.get_jwk_set()

tests/test_jwks_client.py:336: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
jwt/jwks_client.py:55: in get_jwk_set
    data = self.fetch_data()
jwt/jwks_client.py:38: in fetch_data
    response = urllib.request.urlopen(request, timeout=self.timeout)
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/unittest/mock.py:1137: in __call__
    return self._mock_call(*args, **kwargs)
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/unittest/mock.py:1141: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <MagicMock name='urlopen' id='139477055774672'>
args = (<urllib.request.Request object at 0x7eda885d0f20>,)
kwargs = {'timeout': 5}, effect = TimeoutError('timed out')

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method

        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
>               raise effect
E               TimeoutError: timed out

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/unittest/mock.py:1196: TimeoutError
</pre>
</details>
<h3 id="test_utilspytest_to_base64url_uint-1-">test_utils.py::test_to_base64url_uint[-1-]</h3>
<details><summary> <pre>test_utils.py::test_to_base64url_uint[-1-]</pre></summary><pre>
inputval = -1, expected = ''

    @pytest.mark.parametrize(
        "inputval,expected",
        [
            (0, b"AA"),
            (1, b"AQ"),
            (255, b"_w"),
            (65537, b"AQAB"),
            (123456789, b"B1vNFQ"),
            pytest.param(-1, "", marks=pytest.mark.xfail(raises=ValueError)),
        ],
    )
    def test_to_base64url_uint(inputval, expected):
>       actual = to_base64url_uint(inputval)

tests/test_utils.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

val = -1

    def to_base64url_uint(val: int) -> bytes:
        if val < 0:
>           raise ValueError('Must be a positive integer')
E           ValueError: Must be a positive integer

jwt/utils.py:34: ValueError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/jwt/algorithms.py b/jwt/algorithms.py</span>
<span class="gh">index b3897bf..0a18f4e 100644</span>
<span class="gd">--- a/jwt/algorithms.py</span>
<span class="gi">+++ b/jwt/algorithms.py</span>
<span class="gu">@@ -38,7 +38,28 @@ def get_default_algorithms() -&gt; dict[str, Algorithm]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns the algorithms that are implemented by the library.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    default_algorithms = {</span>
<span class="gi">+        &#39;none&#39;: NoneAlgorithm(),</span>
<span class="gi">+        &#39;HS256&#39;: HMACAlgorithm(HMACAlgorithm.SHA256),</span>
<span class="gi">+        &#39;HS384&#39;: HMACAlgorithm(HMACAlgorithm.SHA384),</span>
<span class="gi">+        &#39;HS512&#39;: HMACAlgorithm(HMACAlgorithm.SHA512),</span>
<span class="gi">+    }</span>
<span class="gi">+</span>
<span class="gi">+    if has_crypto:</span>
<span class="gi">+        default_algorithms.update({</span>
<span class="gi">+            &#39;RS256&#39;: RSAAlgorithm(RSAAlgorithm.SHA256),</span>
<span class="gi">+            &#39;RS384&#39;: RSAAlgorithm(RSAAlgorithm.SHA384),</span>
<span class="gi">+            &#39;RS512&#39;: RSAAlgorithm(RSAAlgorithm.SHA512),</span>
<span class="gi">+            &#39;ES256&#39;: ECAlgorithm(ECAlgorithm.SHA256),</span>
<span class="gi">+            &#39;ES384&#39;: ECAlgorithm(ECAlgorithm.SHA384),</span>
<span class="gi">+            &#39;ES512&#39;: ECAlgorithm(ECAlgorithm.SHA512),</span>
<span class="gi">+            &#39;PS256&#39;: RSAPSSAlgorithm(RSAPSSAlgorithm.SHA256),</span>
<span class="gi">+            &#39;PS384&#39;: RSAPSSAlgorithm(RSAPSSAlgorithm.SHA384),</span>
<span class="gi">+            &#39;PS512&#39;: RSAPSSAlgorithm(RSAPSSAlgorithm.SHA512),</span>
<span class="gi">+            &#39;EdDSA&#39;: OKPAlgorithm(),</span>
<span class="gi">+        })</span>
<span class="gi">+</span>
<span class="gi">+    return default_algorithms</span>

<span class="w"> </span>class Algorithm(ABC):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -51,7 +72,17 @@ class Algorithm(ABC):</span>

<span class="w"> </span>        If there is no hash algorithm, raises a NotImplementedError.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not hasattr(self, &#39;hash_alg&#39;):</span>
<span class="gi">+            raise NotImplementedError(&#39;Algorithm does not have a hash algorithm&#39;)</span>
<span class="gi">+        </span>
<span class="gi">+        if has_crypto and isinstance(self.hash_alg, type) and issubclass(self.hash_alg, hashes.HashAlgorithm):</span>
<span class="gi">+            h = hashes.Hash(self.hash_alg(), backend=default_backend())</span>
<span class="gi">+            h.update(bytestr)</span>
<span class="gi">+            return h.finalize()</span>
<span class="gi">+        else:</span>
<span class="gi">+            h = self.hash_alg()</span>
<span class="gi">+            h.update(bytestr)</span>
<span class="gi">+            return h.digest()</span>

<span class="w"> </span>    @abstractmethod
<span class="w"> </span>    def prepare_key(self, key: Any) -&gt; Any:
<span class="gu">@@ -98,6 +129,24 @@ class NoneAlgorithm(Algorithm):</span>
<span class="w"> </span>    Placeholder for use when no signing or verification
<span class="w"> </span>    operations are required.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gi">+    def prepare_key(self, key: Any) -&gt; None:</span>
<span class="gi">+        if key not in [None, &#39;&#39;, &#39;none&#39;]:</span>
<span class="gi">+            raise InvalidKeyError(&#39;When alg = &quot;none&quot;, key must be empty or &quot;none&quot;&#39;)</span>
<span class="gi">+        return None</span>
<span class="gi">+</span>
<span class="gi">+    def sign(self, msg: bytes, key: Any) -&gt; bytes:</span>
<span class="gi">+        return b&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    def verify(self, msg: bytes, key: Any, sig: bytes) -&gt; bool:</span>
<span class="gi">+        return sig == b&#39;&#39;</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def to_jwk(key_obj: Any, as_dict: bool = False) -&gt; NoReturn:</span>
<span class="gi">+        raise NotImplementedError(&#39;Algorithm &quot;none&quot; can\&#39;t be exported as JWK&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def from_jwk(jwk: str | JWKDict) -&gt; NoReturn:</span>
<span class="gi">+        raise NotImplementedError(&#39;Algorithm &quot;none&quot; can\&#39;t be imported from JWK&#39;)</span>

<span class="w"> </span>class HMACAlgorithm(Algorithm):
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gu">@@ -110,6 +159,51 @@ class HMACAlgorithm(Algorithm):</span>

<span class="w"> </span>    def __init__(self, hash_alg: HashlibHash) -&gt; None:
<span class="w"> </span>        self.hash_alg = hash_alg
<span class="gi">+</span>
<span class="gi">+    def prepare_key(self, key: Union[str, bytes]) -&gt; bytes:</span>
<span class="gi">+        if not isinstance(key, (str, bytes)):</span>
<span class="gi">+            raise TypeError(&#39;Expected a string value&#39;)</span>
<span class="gi">+        key = force_bytes(key)</span>
<span class="gi">+        if is_pem_format(key) or is_ssh_key(key):</span>
<span class="gi">+            raise InvalidKeyError(&#39;The specified key is an asymmetric key or x509 certificate and should not be used as an HMAC secret.&#39;)</span>
<span class="gi">+        return key</span>
<span class="gi">+</span>
<span class="gi">+    def sign(self, msg: bytes, key: Union[str, bytes]) -&gt; bytes:</span>
<span class="gi">+        key = self.prepare_key(key)</span>
<span class="gi">+        h = hmac.new(key, msg, self.hash_alg)</span>
<span class="gi">+        return h.digest()</span>
<span class="gi">+</span>
<span class="gi">+    def verify(self, msg: bytes, key: Union[str, bytes], sig: bytes) -&gt; bool:</span>
<span class="gi">+        key = self.prepare_key(key)</span>
<span class="gi">+        h = hmac.new(key, msg, self.hash_alg)</span>
<span class="gi">+        try:</span>
<span class="gi">+            return hmac.compare_digest(sig, h.digest())</span>
<span class="gi">+        except TypeError:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def to_jwk(key_obj: Union[str, bytes], as_dict: bool = False) -&gt; Union[str, JWKDict]:</span>
<span class="gi">+        key_bytes = force_bytes(key_obj)</span>
<span class="gi">+        jwk = {</span>
<span class="gi">+            &#39;kty&#39;: &#39;oct&#39;,</span>
<span class="gi">+            &#39;k&#39;: base64url_encode(key_bytes).decode(&#39;ascii&#39;)</span>
<span class="gi">+        }</span>
<span class="gi">+        if as_dict:</span>
<span class="gi">+            return jwk</span>
<span class="gi">+        return json.dumps(jwk)</span>
<span class="gi">+</span>
<span class="gi">+    @staticmethod</span>
<span class="gi">+    def from_jwk(jwk: Union[str, JWKDict]) -&gt; bytes:</span>
<span class="gi">+        if isinstance(jwk, str):</span>
<span class="gi">+            jwk = json.loads(jwk)</span>
<span class="gi">+        if not isinstance(jwk, dict):</span>
<span class="gi">+            raise InvalidKeyError(&#39;Key must be a dict or a string&#39;)</span>
<span class="gi">+        if jwk.get(&#39;kty&#39;) != &#39;oct&#39;:</span>
<span class="gi">+            raise InvalidKeyError(&#39;Not an HMAC key&#39;)</span>
<span class="gi">+        k = jwk.get(&#39;k&#39;)</span>
<span class="gi">+        if not k:</span>
<span class="gi">+            raise InvalidKeyError(&#39;k parameter is required&#39;)</span>
<span class="gi">+        return base64url_decode(k)</span>
<span class="w"> </span>if has_crypto:

<span class="w"> </span>    class RSAAlgorithm(Algorithm):
<span class="gu">@@ -124,6 +218,107 @@ if has_crypto:</span>
<span class="w"> </span>        def __init__(self, hash_alg: type[hashes.HashAlgorithm]) -&gt; None:
<span class="w"> </span>            self.hash_alg = hash_alg

<span class="gi">+        def prepare_key(self, key: Union[str, bytes, RSAPrivateKey, RSAPublicKey]) -&gt; Union[RSAPrivateKey, RSAPublicKey]:</span>
<span class="gi">+            if isinstance(key, (RSAPrivateKey, RSAPublicKey)):</span>
<span class="gi">+                return key</span>
<span class="gi">+</span>
<span class="gi">+            key = force_bytes(key)</span>
<span class="gi">+            if is_pem_format(key):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return load_pem_private_key(key, password=None, backend=default_backend())</span>
<span class="gi">+                except ValueError:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        return load_pem_public_key(key, backend=default_backend())</span>
<span class="gi">+                    except ValueError:</span>
<span class="gi">+                        raise InvalidKeyError(&#39;Invalid PEM format&#39;)</span>
<span class="gi">+            elif is_ssh_key(key):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return load_ssh_public_key(key, backend=default_backend())</span>
<span class="gi">+                except ValueError:</span>
<span class="gi">+                    raise InvalidKeyError(&#39;Invalid SSH key format&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise InvalidKeyError(&#39;Invalid key format&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        def sign(self, msg: bytes, key: Union[str, bytes, RSAPrivateKey]) -&gt; bytes:</span>
<span class="gi">+            key_obj = self.prepare_key(key)</span>
<span class="gi">+            if not isinstance(key_obj, RSAPrivateKey):</span>
<span class="gi">+                raise TypeError(&#39;Key must be an RSAPrivateKey instance&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            padder = padding.PKCS1v15()</span>
<span class="gi">+            return key_obj.sign(msg, padder, self.hash_alg())</span>
<span class="gi">+</span>
<span class="gi">+        def verify(self, msg: bytes, key: Union[str, bytes, RSAPrivateKey, RSAPublicKey], sig: bytes) -&gt; bool:</span>
<span class="gi">+            key_obj = self.prepare_key(key)</span>
<span class="gi">+            if not isinstance(key_obj, (RSAPrivateKey, RSAPublicKey)):</span>
<span class="gi">+                raise TypeError(&#39;Key must be an RSA key instance&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            verifier = key_obj if isinstance(key_obj, RSAPublicKey) else key_obj.public_key()</span>
<span class="gi">+            padder = padding.PKCS1v15()</span>
<span class="gi">+            try:</span>
<span class="gi">+                verifier.verify(sig, msg, padder, self.hash_alg())</span>
<span class="gi">+                return True</span>
<span class="gi">+            except InvalidSignature:</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+        @staticmethod</span>
<span class="gi">+        def to_jwk(key_obj: Union[RSAPrivateKey, RSAPublicKey], as_dict: bool = False) -&gt; Union[str, JWKDict]:</span>
<span class="gi">+            if isinstance(key_obj, RSAPrivateKey):</span>
<span class="gi">+                numbers = key_obj.private_numbers()</span>
<span class="gi">+                jwk = {</span>
<span class="gi">+                    &#39;kty&#39;: &#39;RSA&#39;,</span>
<span class="gi">+                    &#39;n&#39;: to_base64url_uint(numbers.public_numbers.n).decode(&#39;ascii&#39;),</span>
<span class="gi">+                    &#39;e&#39;: to_base64url_uint(numbers.public_numbers.e).decode(&#39;ascii&#39;),</span>
<span class="gi">+                    &#39;d&#39;: to_base64url_uint(numbers.d).decode(&#39;ascii&#39;),</span>
<span class="gi">+                    &#39;p&#39;: to_base64url_uint(numbers.p).decode(&#39;ascii&#39;),</span>
<span class="gi">+                    &#39;q&#39;: to_base64url_uint(numbers.q).decode(&#39;ascii&#39;),</span>
<span class="gi">+                    &#39;dp&#39;: to_base64url_uint(numbers.dmp1).decode(&#39;ascii&#39;),</span>
<span class="gi">+                    &#39;dq&#39;: to_base64url_uint(numbers.dmq1).decode(&#39;ascii&#39;),</span>
<span class="gi">+                    &#39;qi&#39;: to_base64url_uint(numbers.iqmp).decode(&#39;ascii&#39;)</span>
<span class="gi">+                }</span>
<span class="gi">+            else:</span>
<span class="gi">+                numbers = key_obj.public_numbers()</span>
<span class="gi">+                jwk = {</span>
<span class="gi">+                    &#39;kty&#39;: &#39;RSA&#39;,</span>
<span class="gi">+                    &#39;n&#39;: to_base64url_uint(numbers.n).decode(&#39;ascii&#39;),</span>
<span class="gi">+                    &#39;e&#39;: to_base64url_uint(numbers.e).decode(&#39;ascii&#39;)</span>
<span class="gi">+                }</span>
<span class="gi">+</span>
<span class="gi">+            if as_dict:</span>
<span class="gi">+                return jwk</span>
<span class="gi">+            return json.dumps(jwk)</span>
<span class="gi">+</span>
<span class="gi">+        @staticmethod</span>
<span class="gi">+        def from_jwk(jwk: Union[str, JWKDict]) -&gt; Union[RSAPrivateKey, RSAPublicKey]:</span>
<span class="gi">+            if isinstance(jwk, str):</span>
<span class="gi">+                jwk = json.loads(jwk)</span>
<span class="gi">+            if not isinstance(jwk, dict):</span>
<span class="gi">+                raise InvalidKeyError(&#39;Key must be a dict or a string&#39;)</span>
<span class="gi">+            if jwk.get(&#39;kty&#39;) != &#39;RSA&#39;:</span>
<span class="gi">+                raise InvalidKeyError(&#39;Not an RSA key&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            if &#39;d&#39; in jwk and &#39;p&#39; in jwk and &#39;q&#39; in jwk:</span>
<span class="gi">+                # Private key</span>
<span class="gi">+                numbers = RSAPrivateNumbers(</span>
<span class="gi">+                    d=from_base64url_uint(jwk[&#39;d&#39;]),</span>
<span class="gi">+                    p=from_base64url_uint(jwk[&#39;p&#39;]),</span>
<span class="gi">+                    q=from_base64url_uint(jwk[&#39;q&#39;]),</span>
<span class="gi">+                    dmp1=from_base64url_uint(jwk[&#39;dp&#39;]),</span>
<span class="gi">+                    dmq1=from_base64url_uint(jwk[&#39;dq&#39;]),</span>
<span class="gi">+                    iqmp=from_base64url_uint(jwk[&#39;qi&#39;]),</span>
<span class="gi">+                    public_numbers=RSAPublicNumbers(</span>
<span class="gi">+                        e=from_base64url_uint(jwk[&#39;e&#39;]),</span>
<span class="gi">+                        n=from_base64url_uint(jwk[&#39;n&#39;])</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+                return numbers.private_key(backend=default_backend())</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Public key</span>
<span class="gi">+                numbers = RSAPublicNumbers(</span>
<span class="gi">+                    e=from_base64url_uint(jwk[&#39;e&#39;]),</span>
<span class="gi">+                    n=from_base64url_uint(jwk[&#39;n&#39;])</span>
<span class="gi">+                )</span>
<span class="gi">+                return numbers.public_key(backend=default_backend())</span>
<span class="gi">+</span>
<span class="w"> </span>    class ECAlgorithm(Algorithm):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Performs signing and verification operations using
<span class="gu">@@ -136,10 +331,150 @@ if has_crypto:</span>
<span class="w"> </span>        def __init__(self, hash_alg: type[hashes.HashAlgorithm]) -&gt; None:
<span class="w"> </span>            self.hash_alg = hash_alg

<span class="gi">+        def prepare_key(self, key: Union[str, bytes, EllipticCurvePrivateKey, EllipticCurvePublicKey]) -&gt; Union[EllipticCurvePrivateKey, EllipticCurvePublicKey]:</span>
<span class="gi">+            if isinstance(key, (EllipticCurvePrivateKey, EllipticCurvePublicKey)):</span>
<span class="gi">+                return key</span>
<span class="gi">+</span>
<span class="gi">+            key = force_bytes(key)</span>
<span class="gi">+            if is_pem_format(key):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return load_pem_private_key(key, password=None, backend=default_backend())</span>
<span class="gi">+                except ValueError:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        return load_pem_public_key(key, backend=default_backend())</span>
<span class="gi">+                    except ValueError:</span>
<span class="gi">+                        raise InvalidKeyError(&#39;Invalid PEM format&#39;)</span>
<span class="gi">+            elif is_ssh_key(key):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return load_ssh_public_key(key, backend=default_backend())</span>
<span class="gi">+                except ValueError:</span>
<span class="gi">+                    raise InvalidKeyError(&#39;Invalid SSH key format&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise InvalidKeyError(&#39;Invalid key format&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        def sign(self, msg: bytes, key: Union[str, bytes, EllipticCurvePrivateKey]) -&gt; bytes:</span>
<span class="gi">+            key_obj = self.prepare_key(key)</span>
<span class="gi">+            if not isinstance(key_obj, EllipticCurvePrivateKey):</span>
<span class="gi">+                raise TypeError(&#39;Key must be an EllipticCurvePrivateKey instance&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            signature = key_obj.sign(msg, ECDSA(self.hash_alg()))</span>
<span class="gi">+            return der_to_raw_signature(signature, key_obj.curve)</span>
<span class="gi">+</span>
<span class="gi">+        def verify(self, msg: bytes, key: Union[str, bytes, EllipticCurvePrivateKey, EllipticCurvePublicKey], sig: bytes) -&gt; bool:</span>
<span class="gi">+            key_obj = self.prepare_key(key)</span>
<span class="gi">+            if not isinstance(key_obj, (EllipticCurvePrivateKey, EllipticCurvePublicKey)):</span>
<span class="gi">+                raise TypeError(&#39;Key must be an EC key instance&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            verifier = key_obj if isinstance(key_obj, EllipticCurvePublicKey) else key_obj.public_key()</span>
<span class="gi">+            curve = verifier.curve</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                der_sig = raw_to_der_signature(sig, curve)</span>
<span class="gi">+                verifier.verify(der_sig, msg, ECDSA(self.hash_alg()))</span>
<span class="gi">+                return True</span>
<span class="gi">+            except (InvalidSignature, ValueError):</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+        @staticmethod</span>
<span class="gi">+        def to_jwk(key_obj: Union[EllipticCurvePrivateKey, EllipticCurvePublicKey], as_dict: bool = False) -&gt; Union[str, JWKDict]:</span>
<span class="gi">+            if isinstance(key_obj, EllipticCurvePrivateKey):</span>
<span class="gi">+                numbers = key_obj.private_numbers()</span>
<span class="gi">+                jwk = {</span>
<span class="gi">+                    &#39;kty&#39;: &#39;EC&#39;,</span>
<span class="gi">+                    &#39;crv&#39;: {</span>
<span class="gi">+                        SECP256K1: &#39;P-256K&#39;,</span>
<span class="gi">+                        SECP256R1: &#39;P-256&#39;,</span>
<span class="gi">+                        SECP384R1: &#39;P-384&#39;,</span>
<span class="gi">+                        SECP521R1: &#39;P-521&#39;</span>
<span class="gi">+                    }[type(numbers.public_numbers.curve)],</span>
<span class="gi">+                    &#39;x&#39;: to_base64url_uint(numbers.public_numbers.x).decode(&#39;ascii&#39;),</span>
<span class="gi">+                    &#39;y&#39;: to_base64url_uint(numbers.public_numbers.y).decode(&#39;ascii&#39;),</span>
<span class="gi">+                    &#39;d&#39;: to_base64url_uint(numbers.private_value).decode(&#39;ascii&#39;)</span>
<span class="gi">+                }</span>
<span class="gi">+            else:</span>
<span class="gi">+                numbers = key_obj.public_numbers()</span>
<span class="gi">+                jwk = {</span>
<span class="gi">+                    &#39;kty&#39;: &#39;EC&#39;,</span>
<span class="gi">+                    &#39;crv&#39;: {</span>
<span class="gi">+                        SECP256K1: &#39;P-256K&#39;,</span>
<span class="gi">+                        SECP256R1: &#39;P-256&#39;,</span>
<span class="gi">+                        SECP384R1: &#39;P-384&#39;,</span>
<span class="gi">+                        SECP521R1: &#39;P-521&#39;</span>
<span class="gi">+                    }[type(numbers.curve)],</span>
<span class="gi">+                    &#39;x&#39;: to_base64url_uint(numbers.x).decode(&#39;ascii&#39;),</span>
<span class="gi">+                    &#39;y&#39;: to_base64url_uint(numbers.y).decode(&#39;ascii&#39;)</span>
<span class="gi">+                }</span>
<span class="gi">+</span>
<span class="gi">+            if as_dict:</span>
<span class="gi">+                return jwk</span>
<span class="gi">+            return json.dumps(jwk)</span>
<span class="gi">+</span>
<span class="gi">+        @staticmethod</span>
<span class="gi">+        def from_jwk(jwk: Union[str, JWKDict]) -&gt; Union[EllipticCurvePrivateKey, EllipticCurvePublicKey]:</span>
<span class="gi">+            if isinstance(jwk, str):</span>
<span class="gi">+                jwk = json.loads(jwk)</span>
<span class="gi">+            if not isinstance(jwk, dict):</span>
<span class="gi">+                raise InvalidKeyError(&#39;Key must be a dict or a string&#39;)</span>
<span class="gi">+            if jwk.get(&#39;kty&#39;) != &#39;EC&#39;:</span>
<span class="gi">+                raise InvalidKeyError(&#39;Not an EC key&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            curve = {</span>
<span class="gi">+                &#39;P-256K&#39;: SECP256K1,</span>
<span class="gi">+                &#39;P-256&#39;: SECP256R1,</span>
<span class="gi">+                &#39;P-384&#39;: SECP384R1,</span>
<span class="gi">+                &#39;P-521&#39;: SECP521R1</span>
<span class="gi">+            }[jwk[&#39;crv&#39;]]()</span>
<span class="gi">+</span>
<span class="gi">+            if &#39;d&#39; in jwk:</span>
<span class="gi">+                # Private key</span>
<span class="gi">+                numbers = EllipticCurvePrivateNumbers(</span>
<span class="gi">+                    private_value=from_base64url_uint(jwk[&#39;d&#39;]),</span>
<span class="gi">+                    public_numbers=EllipticCurvePublicNumbers(</span>
<span class="gi">+                        x=from_base64url_uint(jwk[&#39;x&#39;]),</span>
<span class="gi">+                        y=from_base64url_uint(jwk[&#39;y&#39;]),</span>
<span class="gi">+                        curve=curve</span>
<span class="gi">+                    )</span>
<span class="gi">+                )</span>
<span class="gi">+                return numbers.private_key(backend=default_backend())</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Public key</span>
<span class="gi">+                numbers = EllipticCurvePublicNumbers(</span>
<span class="gi">+                    x=from_base64url_uint(jwk[&#39;x&#39;]),</span>
<span class="gi">+                    y=from_base64url_uint(jwk[&#39;y&#39;]),</span>
<span class="gi">+                    curve=curve</span>
<span class="gi">+                )</span>
<span class="gi">+                return numbers.public_key(backend=default_backend())</span>
<span class="gi">+</span>
<span class="w"> </span>    class RSAPSSAlgorithm(RSAAlgorithm):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Performs a signature using RSASSA-PSS with MGF1
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gi">+        def sign(self, msg: bytes, key: Union[str, bytes, RSAPrivateKey]) -&gt; bytes:</span>
<span class="gi">+            key_obj = self.prepare_key(key)</span>
<span class="gi">+            if not isinstance(key_obj, RSAPrivateKey):</span>
<span class="gi">+                raise TypeError(&#39;Key must be an RSAPrivateKey instance&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            padder = padding.PSS(</span>
<span class="gi">+                mgf=padding.MGF1(self.hash_alg()),</span>
<span class="gi">+                salt_length=padding.PSS.MAX_LENGTH</span>
<span class="gi">+            )</span>
<span class="gi">+            return key_obj.sign(msg, padder, self.hash_alg())</span>
<span class="gi">+</span>
<span class="gi">+        def verify(self, msg: bytes, key: Union[str, bytes, RSAPrivateKey, RSAPublicKey], sig: bytes) -&gt; bool:</span>
<span class="gi">+            key_obj = self.prepare_key(key)</span>
<span class="gi">+            if not isinstance(key_obj, (RSAPrivateKey, RSAPublicKey)):</span>
<span class="gi">+                raise TypeError(&#39;Key must be an RSA key instance&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            verifier = key_obj if isinstance(key_obj, RSAPublicKey) else key_obj.public_key()</span>
<span class="gi">+            padder = padding.PSS(</span>
<span class="gi">+                mgf=padding.MGF1(self.hash_alg()),</span>
<span class="gi">+                salt_length=padding.PSS.MAX_LENGTH</span>
<span class="gi">+            )</span>
<span class="gi">+            try:</span>
<span class="gi">+                verifier.verify(sig, msg, padder, self.hash_alg())</span>
<span class="gi">+                return True</span>
<span class="gi">+            except InvalidSignature:</span>
<span class="gi">+                return False</span>

<span class="w"> </span>    class OKPAlgorithm(Algorithm):
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -151,6 +486,27 @@ if has_crypto:</span>
<span class="w"> </span>        def __init__(self, **kwargs: Any) -&gt; None:
<span class="w"> </span>            pass

<span class="gi">+        def prepare_key(self, key: Union[str, bytes, AllowedOKPKeys]) -&gt; AllowedOKPKeys:</span>
<span class="gi">+            if isinstance(key, (Ed25519PrivateKey, Ed25519PublicKey, Ed448PrivateKey, Ed448PublicKey)):</span>
<span class="gi">+                return key</span>
<span class="gi">+</span>
<span class="gi">+            key = force_bytes(key)</span>
<span class="gi">+            if is_pem_format(key):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return load_pem_private_key(key, password=None, backend=default_backend())</span>
<span class="gi">+                except ValueError:</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        return load_pem_public_key(key, backend=default_backend())</span>
<span class="gi">+                    except ValueError:</span>
<span class="gi">+                        raise InvalidKeyError(&#39;Invalid PEM format&#39;)</span>
<span class="gi">+            elif is_ssh_key(key):</span>
<span class="gi">+                try:</span>
<span class="gi">+                    return load_ssh_public_key(key, backend=default_backend())</span>
<span class="gi">+                except ValueError:</span>
<span class="gi">+                    raise InvalidKeyError(&#39;Invalid SSH key format&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise InvalidKeyError(&#39;Invalid key format&#39;)</span>
<span class="gi">+</span>
<span class="w"> </span>        def sign(self, msg: str | bytes, key: Ed25519PrivateKey | Ed448PrivateKey) -&gt; bytes:
<span class="w"> </span>            &quot;&quot;&quot;
<span class="w"> </span>            Sign a message ``msg`` using the EdDSA private key ``key``
<span class="gu">@@ -159,7 +515,11 @@ if has_crypto:</span>
<span class="w"> </span>                or :class:`.Ed448PrivateKey` isinstance
<span class="w"> </span>            :return bytes signature: The signature, as bytes
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gd">-            pass</span>
<span class="gi">+            msg_bytes = force_bytes(msg)</span>
<span class="gi">+            key_obj = self.prepare_key(key)</span>
<span class="gi">+            if not isinstance(key_obj, (Ed25519PrivateKey, Ed448PrivateKey)):</span>
<span class="gi">+                raise TypeError(&#39;Key must be an Ed25519PrivateKey or Ed448PrivateKey instance&#39;)</span>
<span class="gi">+            return key_obj.sign(msg_bytes)</span>

<span class="w"> </span>        def verify(self, msg: str | bytes, key: AllowedOKPKeys, sig: str | bytes) -&gt; bool:
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gu">@@ -171,4 +531,85 @@ if has_crypto:</span>
<span class="w"> </span>                A private or public EdDSA key instance
<span class="w"> </span>            :return bool verified: True if signature is valid, False if not.
<span class="w"> </span>            &quot;&quot;&quot;
<span class="gd">-            pass</span>
\ No newline at end of file
<span class="gi">+            msg_bytes = force_bytes(msg)</span>
<span class="gi">+            sig_bytes = force_bytes(sig)</span>
<span class="gi">+            key_obj = self.prepare_key(key)</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(key_obj, (Ed25519PrivateKey, Ed448PrivateKey)):</span>
<span class="gi">+                verifier = key_obj.public_key()</span>
<span class="gi">+            else:</span>
<span class="gi">+                verifier = key_obj</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                verifier.verify(sig_bytes, msg_bytes)</span>
<span class="gi">+                return True</span>
<span class="gi">+            except InvalidSignature:</span>
<span class="gi">+                return False</span>
<span class="gi">+</span>
<span class="gi">+        @staticmethod</span>
<span class="gi">+        def to_jwk(key_obj: AllowedOKPKeys, as_dict: bool = False) -&gt; Union[str, JWKDict]:</span>
<span class="gi">+            if isinstance(key_obj, (Ed25519PrivateKey, Ed25519PublicKey)):</span>
<span class="gi">+                crv = &#39;Ed25519&#39;</span>
<span class="gi">+            elif isinstance(key_obj, (Ed448PrivateKey, Ed448PublicKey)):</span>
<span class="gi">+                crv = &#39;Ed448&#39;</span>
<span class="gi">+            else:</span>
<span class="gi">+                raise TypeError(&#39;Key must be an EdDSA key instance&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            if isinstance(key_obj, (Ed25519PrivateKey, Ed448PrivateKey)):</span>
<span class="gi">+                private_bytes = key_obj.private_bytes(</span>
<span class="gi">+                    encoding=Encoding.Raw,</span>
<span class="gi">+                    format=PrivateFormat.Raw,</span>
<span class="gi">+                    encryption_algorithm=NoEncryption()</span>
<span class="gi">+                )</span>
<span class="gi">+                public_bytes = key_obj.public_key().public_bytes(</span>
<span class="gi">+                    encoding=Encoding.Raw,</span>
<span class="gi">+                    format=PublicFormat.Raw</span>
<span class="gi">+                )</span>
<span class="gi">+                jwk = {</span>
<span class="gi">+                    &#39;kty&#39;: &#39;OKP&#39;,</span>
<span class="gi">+                    &#39;crv&#39;: crv,</span>
<span class="gi">+                    &#39;x&#39;: base64url_encode(public_bytes).decode(&#39;ascii&#39;),</span>
<span class="gi">+                    &#39;d&#39;: base64url_encode(private_bytes).decode(&#39;ascii&#39;)</span>
<span class="gi">+                }</span>
<span class="gi">+            else:</span>
<span class="gi">+                public_bytes = key_obj.public_bytes(</span>
<span class="gi">+                    encoding=Encoding.Raw,</span>
<span class="gi">+                    format=PublicFormat.Raw</span>
<span class="gi">+                )</span>
<span class="gi">+                jwk = {</span>
<span class="gi">+                    &#39;kty&#39;: &#39;OKP&#39;,</span>
<span class="gi">+                    &#39;crv&#39;: crv,</span>
<span class="gi">+                    &#39;x&#39;: base64url_encode(public_bytes).decode(&#39;ascii&#39;)</span>
<span class="gi">+                }</span>
<span class="gi">+</span>
<span class="gi">+            if as_dict:</span>
<span class="gi">+                return jwk</span>
<span class="gi">+            return json.dumps(jwk)</span>
<span class="gi">+</span>
<span class="gi">+        @staticmethod</span>
<span class="gi">+        def from_jwk(jwk: Union[str, JWKDict]) -&gt; AllowedOKPKeys:</span>
<span class="gi">+            if isinstance(jwk, str):</span>
<span class="gi">+                jwk = json.loads(jwk)</span>
<span class="gi">+            if not isinstance(jwk, dict):</span>
<span class="gi">+                raise InvalidKeyError(&#39;Key must be a dict or a string&#39;)</span>
<span class="gi">+            if jwk.get(&#39;kty&#39;) != &#39;OKP&#39;:</span>
<span class="gi">+                raise InvalidKeyError(&#39;Not an OKP key&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            curve = jwk.get(&#39;crv&#39;)</span>
<span class="gi">+            if curve not in [&#39;Ed25519&#39;, &#39;Ed448&#39;]:</span>
<span class="gi">+                raise InvalidKeyError(&#39;Invalid curve&#39;)</span>
<span class="gi">+</span>
<span class="gi">+            x = base64url_decode(jwk[&#39;x&#39;])</span>
<span class="gi">+            if &#39;d&#39; in jwk:</span>
<span class="gi">+                # Private key</span>
<span class="gi">+                d = base64url_decode(jwk[&#39;d&#39;])</span>
<span class="gi">+                if curve == &#39;Ed25519&#39;:</span>
<span class="gi">+                    return Ed25519PrivateKey.from_private_bytes(d)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    return Ed448PrivateKey.from_private_bytes(d)</span>
<span class="gi">+            else:</span>
<span class="gi">+                # Public key</span>
<span class="gi">+                if curve == &#39;Ed25519&#39;:</span>
<span class="gi">+                    return Ed25519PublicKey.from_public_bytes(x)</span>
<span class="gi">+                else:</span>
<span class="gi">+                    return Ed448PublicKey.from_public_bytes(x)</span>
\ No newline at end of file
<span class="gh">diff --git a/jwt/api_jwk.py b/jwt/api_jwk.py</span>
<span class="gh">index 1d55501..89f1902 100644</span>
<span class="gd">--- a/jwt/api_jwk.py</span>
<span class="gi">+++ b/jwt/api_jwk.py</span>
<span class="gu">@@ -49,6 +49,34 @@ class PyJWK:</span>
<span class="w"> </span>            raise PyJWKError(f&#39;Unable to find an algorithm for key: {self._jwk_data}&#39;)
<span class="w"> </span>        self.key = self.Algorithm.from_jwk(self._jwk_data)

<span class="gi">+    @property</span>
<span class="gi">+    def key_id(self) -&gt; str | None:</span>
<span class="gi">+        return self._jwk_data.get(&#39;kid&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def public_key_use(self) -&gt; str | None:</span>
<span class="gi">+        return self._jwk_data.get(&#39;use&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def key_type(self) -&gt; str:</span>
<span class="gi">+        return self._jwk_data.get(&#39;kty&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_dict(cls, obj: JWKDict, algorithm: str | None=None) -&gt; &#39;PyJWK&#39;:</span>
<span class="gi">+        &quot;&quot;&quot;Creates a PyJWK from a dict object.&quot;&quot;&quot;</span>
<span class="gi">+        if not isinstance(obj, dict):</span>
<span class="gi">+            raise InvalidKeyError(&#39;Invalid JWK format&#39;)</span>
<span class="gi">+        return cls(obj, algorithm)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_json(cls, data: str, algorithm: str | None=None) -&gt; &#39;PyJWK&#39;:</span>
<span class="gi">+        &quot;&quot;&quot;Creates a PyJWK from a JSON-encoded string.&quot;&quot;&quot;</span>
<span class="gi">+        try:</span>
<span class="gi">+            obj = json.loads(data)</span>
<span class="gi">+        except ValueError as e:</span>
<span class="gi">+            raise InvalidKeyError(f&#39;Invalid JWK format: {str(e)}&#39;)</span>
<span class="gi">+        return cls.from_dict(obj, algorithm)</span>
<span class="gi">+</span>
<span class="w"> </span>class PyJWKSet:

<span class="w"> </span>    def __init__(self, keys: list[JWKDict]) -&gt; None:
<span class="gu">@@ -71,8 +99,25 @@ class PyJWKSet:</span>
<span class="w"> </span>                return key
<span class="w"> </span>        raise KeyError(f&#39;keyset has no key for kid: {kid}&#39;)

<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_dict(cls, obj: dict[str, Any]) -&gt; &#39;PyJWKSet&#39;:</span>
<span class="gi">+        &quot;&quot;&quot;Creates a PyJWKSet from a dict object.&quot;&quot;&quot;</span>
<span class="gi">+        if not isinstance(obj, dict):</span>
<span class="gi">+            raise PyJWKSetError(&#39;Invalid JWK Set value&#39;)</span>
<span class="gi">+        keys = obj.get(&#39;keys&#39;, [])</span>
<span class="gi">+        return cls(keys)</span>
<span class="gi">+</span>
<span class="gi">+    @classmethod</span>
<span class="gi">+    def from_json(cls, data: str) -&gt; &#39;PyJWKSet&#39;:</span>
<span class="gi">+        &quot;&quot;&quot;Creates a PyJWKSet from a JSON-encoded string.&quot;&quot;&quot;</span>
<span class="gi">+        try:</span>
<span class="gi">+            obj = json.loads(data)</span>
<span class="gi">+        except ValueError as e:</span>
<span class="gi">+            raise PyJWKSetError(f&#39;Invalid JWK Set value: {str(e)}&#39;)</span>
<span class="gi">+        return cls.from_dict(obj)</span>
<span class="gi">+</span>
<span class="w"> </span>class PyJWTSetWithTimestamp:

<span class="gd">-    def __init__(self, jwk_set: PyJWKSet):</span>
<span class="gi">+    def __init__(self, jwk_set: PyJWKSet, timestamp: float | None=None):</span>
<span class="w"> </span>        self.jwk_set = jwk_set
<span class="gd">-        self.timestamp = time.monotonic()</span>
\ No newline at end of file
<span class="gi">+        self.timestamp = timestamp if timestamp is not None else time.monotonic()</span>
\ No newline at end of file
<span class="gh">diff --git a/jwt/api_jws.py b/jwt/api_jws.py</span>
<span class="gh">index 9a20466..84bc60d 100644</span>
<span class="gd">--- a/jwt/api_jws.py</span>
<span class="gi">+++ b/jwt/api_jws.py</span>
<span class="gu">@@ -23,24 +23,38 @@ class PyJWS:</span>
<span class="w"> </span>            options = {}
<span class="w"> </span>        self.options = {**self._get_default_options(), **options}

<span class="gi">+    def _get_default_options(self) -&gt; dict[str, Any]:</span>
<span class="gi">+        &quot;&quot;&quot;Returns the default options for this instance.&quot;&quot;&quot;</span>
<span class="gi">+        return {</span>
<span class="gi">+            &#39;verify_signature&#39;: True</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="w"> </span>    def register_algorithm(self, alg_id: str, alg_obj: Algorithm) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Registers a new Algorithm for use when creating and verifying tokens.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(alg_obj, Algorithm):</span>
<span class="gi">+            raise TypeError(&#39;Algorithm must be an instance of Algorithm&#39;)</span>
<span class="gi">+        if alg_id in self._algorithms:</span>
<span class="gi">+            raise ValueError(f&#39;Algorithm {alg_id} is already registered&#39;)</span>
<span class="gi">+        self._algorithms[alg_id] = alg_obj</span>
<span class="gi">+        self._valid_algs.add(alg_id)</span>

<span class="w"> </span>    def unregister_algorithm(self, alg_id: str) -&gt; None:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Unregisters an Algorithm for use when creating and verifying tokens
<span class="w"> </span>        Throws KeyError if algorithm is not registered.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if alg_id not in self._algorithms:</span>
<span class="gi">+            raise KeyError(f&#39;Algorithm {alg_id} not found&#39;)</span>
<span class="gi">+        del self._algorithms[alg_id]</span>
<span class="gi">+        self._valid_algs.remove(alg_id)</span>

<span class="w"> </span>    def get_algorithms(self) -&gt; list[str]:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Returns a list of supported values for the &#39;alg&#39; parameter.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return list(self._valid_algs)</span>

<span class="w"> </span>    def get_algorithm_by_name(self, alg_name: str) -&gt; Algorithm:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -50,7 +64,9 @@ class PyJWS:</span>

<span class="w"> </span>        &gt;&gt;&gt; jws_obj.get_algorithm_by_name(&quot;RS256&quot;)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if alg_name not in self._algorithms:</span>
<span class="gi">+            raise InvalidAlgorithmError(&#39;Algorithm not supported&#39;)</span>
<span class="gi">+        return self._algorithms[alg_name]</span>

<span class="w"> </span>    def get_unverified_header(self, jwt: str | bytes) -&gt; dict[str, Any]:
<span class="w"> </span>        &quot;&quot;&quot;Returns back the JWT header parameters as a dict()
<span class="gu">@@ -58,7 +74,277 @@ class PyJWS:</span>
<span class="w"> </span>        Note: The signature is not verified so the header parameters
<span class="w"> </span>        should not be fully trusted until signature verification is complete
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if not isinstance(jwt, (str, bytes)):</span>
<span class="gi">+            raise InvalidTokenError(&#39;Invalid token type&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(jwt, str):</span>
<span class="gi">+            jwt = jwt.encode(&#39;utf-8&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            signing_input, crypto_segment = jwt.rsplit(b&#39;.&#39;, 1)</span>
<span class="gi">+            header_segment, payload_segment = signing_input.split(b&#39;.&#39;, 1)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise InvalidTokenError(&#39;Not enough segments&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            header_data = base64url_decode(header_segment)</span>
<span class="gi">+        except (TypeError, binascii.Error):</span>
<span class="gi">+            raise DecodeError(&#39;Invalid header padding&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            header = json.loads(header_data.decode(&#39;utf-8&#39;))</span>
<span class="gi">+        except ValueError as e:</span>
<span class="gi">+            raise DecodeError(&#39;Invalid header string: %s&#39; % e)</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(header, dict):</span>
<span class="gi">+            raise DecodeError(&#39;Invalid header string: must be a json object&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        return header</span>
<span class="gi">+</span>
<span class="gi">+    def encode(self, payload: bytes, key: str | bytes | AllowedPrivateKeys | None=None, algorithm: str | None=None, headers: dict[str, Any] | None=None, json_encoder: type[json.JSONEncoder] | None=None, is_payload_detached: bool=False, sort_headers: bool=False) -&gt; str:</span>
<span class="gi">+        &quot;&quot;&quot;Creates a JWT using the given algorithm.</span>
<span class="gi">+</span>
<span class="gi">+        Args:</span>
<span class="gi">+            payload: The claims content to sign</span>
<span class="gi">+            key: The key to use for signing the claim. Note: if the algorithm is None, the key is not used</span>
<span class="gi">+            algorithm: The signing algorithm to use. If none is specified then &#39;none&#39; is used.</span>
<span class="gi">+            headers: A dict of additional headers to use.</span>
<span class="gi">+            json_encoder: A custom JSON encoder to use for encoding the JWT.</span>
<span class="gi">+            is_payload_detached: If True, the payload will be detached from the JWS.</span>
<span class="gi">+            sort_headers: If True, sort the header keys.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        # Check that we have a mapping</span>
<span class="gi">+        if not isinstance(payload, bytes):</span>
<span class="gi">+            raise TypeError(&#39;Payload must be bytes&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if algorithm is None:</span>
<span class="gi">+            algorithm = &#39;none&#39;</span>
<span class="gi">+</span>
<span class="gi">+        if algorithm not in self._valid_algs:</span>
<span class="gi">+            raise InvalidAlgorithmError(&#39;Algorithm not supported&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if algorithm != &#39;none&#39; and key is None:</span>
<span class="gi">+            raise InvalidKeyError(&#39;Key is required when algorithm is not &quot;none&quot;&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        # Header</span>
<span class="gi">+        header = {&#39;alg&#39;: algorithm}</span>
<span class="gi">+        if self.header_typ is not None and &#39;typ&#39; not in (headers or {}):</span>
<span class="gi">+            header[&#39;typ&#39;] = self.header_typ</span>
<span class="gi">+</span>
<span class="gi">+        if headers:</span>
<span class="gi">+            header.update(headers)</span>
<span class="gi">+            if header.get(&#39;typ&#39;) == &#39;&#39;:</span>
<span class="gi">+                del header[&#39;typ&#39;]</span>
<span class="gi">+            elif header.get(&#39;typ&#39;) is None:</span>
<span class="gi">+                del header[&#39;typ&#39;]</span>
<span class="gi">+</span>
<span class="gi">+        if is_payload_detached:</span>
<span class="gi">+            header[&#39;b64&#39;] = False</span>
<span class="gi">+            if not payload:</span>
<span class="gi">+                raise InvalidTokenError(&#39;Payload cannot be empty when using detached content&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if sort_headers:</span>
<span class="gi">+            header = dict(sorted(header.items()))</span>
<span class="gi">+</span>
<span class="gi">+        json_header = json.dumps(header, separators=(&#39;,&#39;, &#39;:&#39;), cls=json_encoder).encode(&#39;utf-8&#39;)</span>
<span class="gi">+        header_input = base64url_encode(json_header)</span>
<span class="gi">+</span>
<span class="gi">+        if is_payload_detached:</span>
<span class="gi">+            payload_input = b&#39;&#39;</span>
<span class="gi">+        else:</span>
<span class="gi">+            payload_input = base64url_encode(payload)</span>
<span class="gi">+</span>
<span class="gi">+        signing_input = b&#39;.&#39;.join([header_input, payload_input])</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            alg_obj = self._algorithms[algorithm]</span>
<span class="gi">+            if algorithm == &#39;none&#39;:</span>
<span class="gi">+                key = None</span>
<span class="gi">+            elif key is None:</span>
<span class="gi">+                raise TypeError(&#39;Key is required when algorithm is not &quot;none&quot;&#39;)</span>
<span class="gi">+            else:</span>
<span class="gi">+                key = alg_obj.prepare_key(key)</span>
<span class="gi">+            signature = alg_obj.sign(signing_input if not is_payload_detached else payload, key)</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            raise TypeError(&#39;Unable to encode JWT: %s&#39; % e)</span>
<span class="gi">+</span>
<span class="gi">+        encoded_signature = base64url_encode(signature)</span>
<span class="gi">+        encoded_jwt = b&#39;.&#39;.join([signing_input, encoded_signature])</span>
<span class="gi">+</span>
<span class="gi">+        return encoded_jwt.decode(&#39;utf-8&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -&gt; dict[str, Any]:</span>
<span class="gi">+        &quot;&quot;&quot;Decodes a JWT and returns a dict of the token contents.</span>
<span class="gi">+</span>
<span class="gi">+        Args:</span>
<span class="gi">+            jwt: The JWT to decode.</span>
<span class="gi">+            key: The key to use for verifying the claim. Note: if the algorithm is &#39;none&#39;, the key is not used.</span>
<span class="gi">+            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.</span>
<span class="gi">+            options: A dict of options for decoding. If None, use default options.</span>
<span class="gi">+            detached_payload: The detached payload to use for verification.</span>
<span class="gi">+            **kwargs: Additional options for decoding.</span>
<span class="gi">+</span>
<span class="gi">+        Returns:</span>
<span class="gi">+            A dict including:</span>
<span class="gi">+                - header: A dict of the JWT header</span>
<span class="gi">+                - payload: The decoded payload</span>
<span class="gi">+                - signature: The signature of the JWT</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        deprecated_kwargs = {</span>
<span class="gi">+            &#39;verify&#39;: &#39;verify_signature&#39;,</span>
<span class="gi">+            &#39;verify_exp&#39;: &#39;verify_exp&#39;,</span>
<span class="gi">+            &#39;verify_iat&#39;: &#39;verify_iat&#39;,</span>
<span class="gi">+            &#39;verify_nbf&#39;: &#39;verify_nbf&#39;,</span>
<span class="gi">+            &#39;verify_aud&#39;: &#39;verify_aud&#39;,</span>
<span class="gi">+            &#39;verify_iss&#39;: &#39;verify_iss&#39;,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        options = options or {}</span>
<span class="gi">+        for old_name, new_name in deprecated_kwargs.items():</span>
<span class="gi">+            if old_name in kwargs:</span>
<span class="gi">+                warnings.warn(</span>
<span class="gi">+                    f&#39;The {old_name} parameter is deprecated. &#39;</span>
<span class="gi">+                    f&#39;Please use {new_name} in options instead.&#39;,</span>
<span class="gi">+                    category=DeprecationWarning,</span>
<span class="gi">+                    stacklevel=2</span>
<span class="gi">+                )</span>
<span class="gi">+                options[new_name] = kwargs.pop(old_name)</span>
<span class="gi">+</span>
<span class="gi">+        for kwarg in kwargs:</span>
<span class="gi">+            warnings.warn(</span>
<span class="gi">+                f&#39;The &quot;{kwarg}&quot; argument is not supported and will be ignored.&#39;,</span>
<span class="gi">+                category=RemovedInPyjwt3Warning,</span>
<span class="gi">+                stacklevel=2</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        merged_options = {**self.options}</span>
<span class="gi">+        if options:</span>
<span class="gi">+            if not isinstance(options, dict):</span>
<span class="gi">+                raise TypeError(&#39;options must be a dict&#39;)</span>
<span class="gi">+            merged_options.update(options)</span>
<span class="gi">+</span>
<span class="gi">+        if isinstance(jwt, str):</span>
<span class="gi">+            jwt = jwt.encode(&#39;utf-8&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(jwt, bytes):</span>
<span class="gi">+            raise DecodeError(&#39;Invalid token type&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            signing_input, crypto_segment = jwt.rsplit(b&#39;.&#39;, 1)</span>
<span class="gi">+            header_segment, payload_segment = signing_input.split(b&#39;.&#39;, 1)</span>
<span class="gi">+        except ValueError:</span>
<span class="gi">+            raise InvalidTokenError(&#39;Not enough segments&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            header_data = base64url_decode(header_segment)</span>
<span class="gi">+        except (TypeError, binascii.Error):</span>
<span class="gi">+            raise DecodeError(&#39;Invalid header padding&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            header = json.loads(header_data.decode(&#39;utf-8&#39;))</span>
<span class="gi">+        except ValueError as e:</span>
<span class="gi">+            raise DecodeError(&#39;Invalid header string: %s&#39; % e)</span>
<span class="gi">+</span>
<span class="gi">+        if not isinstance(header, dict):</span>
<span class="gi">+            raise DecodeError(&#39;Invalid header string: must be a json object&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if header.get(&#39;b64&#39;, True):</span>
<span class="gi">+            try:</span>
<span class="gi">+                payload = base64url_decode(payload_segment)</span>
<span class="gi">+            except (TypeError, binascii.Error):</span>
<span class="gi">+                raise DecodeError(&#39;Invalid payload padding&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            if detached_payload is None:</span>
<span class="gi">+                raise DecodeError(&#39;It is required that you pass in a value for the &quot;detached_payload&quot; argument to decode a message using unencoded payload.&#39;)</span>
<span class="gi">+            payload = detached_payload</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            signature = base64url_decode(crypto_segment)</span>
<span class="gi">+        except (TypeError, binascii.Error):</span>
<span class="gi">+            raise DecodeError(&#39;Invalid crypto padding&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if algorithms is None:</span>
<span class="gi">+            algorithms = list(self._valid_algs)</span>
<span class="gi">+</span>
<span class="gi">+        if not algorithms and merged_options[&#39;verify_signature&#39;]:</span>
<span class="gi">+            raise DecodeError(&#39;No algorithms were specified&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            alg = header[&#39;alg&#39;]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            raise InvalidTokenError(&#39;Missing algorithm (&quot;alg&quot;) in headers&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if alg not in algorithms:</span>
<span class="gi">+            raise InvalidAlgorithmError(&#39;The specified alg value is not allowed&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if alg == &#39;none&#39;:</span>
<span class="gi">+            if merged_options[&#39;verify_signature&#39;]:</span>
<span class="gi">+                raise DecodeError(&#39;Algorithm &quot;none&quot; not allowed&#39;)</span>
<span class="gi">+            if key not in [None, &#39;&#39;, &#39;none&#39;]:</span>
<span class="gi">+                raise InvalidKeyError(&#39;When alg = &quot;none&quot;, key must be empty or &quot;none&quot;&#39;)</span>
<span class="gi">+            if signature != b&#39;&#39;:</span>
<span class="gi">+                raise InvalidSignatureError(&#39;Signature verification failed&#39;)</span>
<span class="gi">+            return {</span>
<span class="gi">+                &#39;header&#39;: header,</span>
<span class="gi">+                &#39;payload&#39;: payload,</span>
<span class="gi">+                &#39;signature&#39;: signature</span>
<span class="gi">+            }</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            alg_obj = self._algorithms[alg]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            raise InvalidAlgorithmError(&#39;Algorithm not supported&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if merged_options[&#39;verify_signature&#39;]:</span>
<span class="gi">+            try:</span>
<span class="gi">+                if key is None:</span>
<span class="gi">+                    raise InvalidKeyError(&#39;Key is required when algorithm is not &quot;none&quot;&#39;)</span>
<span class="gi">+                key = alg_obj.prepare_key(key)</span>
<span class="gi">+            except InvalidKeyError:</span>
<span class="gi">+                raise</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                raise InvalidTokenError(&#39;Unable to parse signature key: %s&#39; % e)</span>
<span class="gi">+</span>
<span class="gi">+            try:</span>
<span class="gi">+                if not alg_obj.verify(signing_input if header.get(&#39;b64&#39;, True) else payload, key, signature):</span>
<span class="gi">+                    raise InvalidSignatureError(&#39;Signature verification failed&#39;)</span>
<span class="gi">+            except Exception as e:</span>
<span class="gi">+                raise InvalidSignatureError(&#39;Signature verification failed: %s&#39; % e)</span>
<span class="gi">+        elif key is not None and key not in [None, &#39;&#39;, &#39;none&#39;]:</span>
<span class="gi">+            try:</span>
<span class="gi">+                key = alg_obj.prepare_key(key)</span>
<span class="gi">+            except Exception:</span>
<span class="gi">+                pass</span>
<span class="gi">+</span>
<span class="gi">+        if not algorithms and not merged_options[&#39;verify_signature&#39;]:</span>
<span class="gi">+            warnings.warn(</span>
<span class="gi">+                &#39;It is required that you pass in a value for the &quot;algorithms&quot; argument when calling decode(). &#39;</span>
<span class="gi">+                &#39;This argument will be mandatory in a future version.&#39;,</span>
<span class="gi">+                category=DeprecationWarning,</span>
<span class="gi">+                stacklevel=2</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        if not merged_options[&#39;verify_signature&#39;] and not algorithms:</span>
<span class="gi">+            warnings.warn(</span>
<span class="gi">+                &#39;The &quot;algorithms&quot; argument is not optional when &quot;verify_signature&quot; is False. &#39;</span>
<span class="gi">+                &#39;This argument will be mandatory in a future version.&#39;,</span>
<span class="gi">+                category=DeprecationWarning,</span>
<span class="gi">+                stacklevel=2</span>
<span class="gi">+            )</span>
<span class="gi">+</span>
<span class="gi">+        return {</span>
<span class="gi">+            &#39;header&#39;: header,</span>
<span class="gi">+            &#39;payload&#39;: payload,</span>
<span class="gi">+            &#39;signature&#39;: signature</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+    def decode(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, detached_payload: bytes | None=None, **kwargs: Any) -&gt; bytes:</span>
<span class="gi">+        &quot;&quot;&quot;Decodes a JWT and returns the payload.</span>
<span class="gi">+</span>
<span class="gi">+        This is a shortcut to :meth:`decode_complete()` that returns just the payload.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        decoded = self.decode_complete(jwt, key, algorithms, options, detached_payload, **kwargs)</span>
<span class="gi">+        return decoded[&#39;payload&#39;]</span>
<span class="w"> </span>_jws_global_obj = PyJWS()
<span class="w"> </span>encode = _jws_global_obj.encode
<span class="w"> </span>decode_complete = _jws_global_obj.decode_complete
<span class="gh">diff --git a/jwt/api_jwt.py b/jwt/api_jwt.py</span>
<span class="gh">index a61eb5f..75fdc2e 100644</span>
<span class="gd">--- a/jwt/api_jwt.py</span>
<span class="gi">+++ b/jwt/api_jwt.py</span>
<span class="gu">@@ -18,6 +18,18 @@ class PyJWT:</span>
<span class="w"> </span>            options = {}
<span class="w"> </span>        self.options: dict[str, Any] = {**self._get_default_options(), **options}

<span class="gi">+    def _get_default_options(self) -&gt; dict[str, Any]:</span>
<span class="gi">+        &quot;&quot;&quot;Returns the default options for this instance.&quot;&quot;&quot;</span>
<span class="gi">+        return {</span>
<span class="gi">+            &#39;verify_signature&#39;: True,</span>
<span class="gi">+            &#39;verify_exp&#39;: True,</span>
<span class="gi">+            &#39;verify_nbf&#39;: True,</span>
<span class="gi">+            &#39;verify_iat&#39;: True,</span>
<span class="gi">+            &#39;verify_aud&#39;: True,</span>
<span class="gi">+            &#39;verify_iss&#39;: True,</span>
<span class="gi">+            &#39;require&#39;: []</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="w"> </span>    def _encode_payload(self, payload: dict[str, Any], headers: dict[str, Any] | None=None, json_encoder: type[json.JSONEncoder] | None=None) -&gt; bytes:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="w"> </span>        Encode a given payload to the bytes to be signed.
<span class="gu">@@ -25,7 +37,8 @@ class PyJWT:</span>
<span class="w"> </span>        This method is intended to be overridden by subclasses that need to
<span class="w"> </span>        encode the payload in a different way, e.g. compress the payload.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        json_str = json.dumps(payload, separators=(&#39;,&#39;, &#39;:&#39;), cls=json_encoder).encode(&#39;utf-8&#39;)</span>
<span class="gi">+        return json_str</span>

<span class="w"> </span>    def _decode_payload(self, decoded: dict[str, Any]) -&gt; Any:
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gu">@@ -35,7 +48,127 @@ class PyJWT:</span>
<span class="w"> </span>        decode the payload in a different way, e.g. decompress compressed
<span class="w"> </span>        payloads.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            payload = json.loads(decoded[&#39;payload&#39;].decode(&#39;utf-8&#39;))</span>
<span class="gi">+        except ValueError as e:</span>
<span class="gi">+            raise DecodeError(&#39;Invalid payload string: %s&#39; % e)</span>
<span class="gi">+        if not isinstance(payload, dict):</span>
<span class="gi">+            raise DecodeError(&#39;Invalid payload string: must be a json object&#39;)</span>
<span class="gi">+        return payload</span>
<span class="gi">+</span>
<span class="gi">+    def encode(self, payload: dict[str, Any], key: str | bytes | AllowedPrivateKeys | None=None, algorithm: str | None=None, headers: dict[str, Any] | None=None, json_encoder: type[json.JSONEncoder] | None=None) -&gt; str:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Encode a JWT from a payload and optional headers.</span>
<span class="gi">+</span>
<span class="gi">+        Takes a payload and signs it using the specified algorithm.</span>
<span class="gi">+</span>
<span class="gi">+        Arguments:</span>
<span class="gi">+            payload: A dict of claims for the JWT.</span>
<span class="gi">+            key: The key to use for signing the claim. Note: if the algorithm is None, the key is not used.</span>
<span class="gi">+            algorithm: The signing algorithm to use. If none is specified then &#39;none&#39; is used.</span>
<span class="gi">+            headers: A dict of additional headers to use.</span>
<span class="gi">+            json_encoder: A custom JSON encoder to use for encoding the JWT.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        # Check that we have a mapping</span>
<span class="gi">+        if not isinstance(payload, dict):</span>
<span class="gi">+            raise TypeError(&#39;Payload must be a dict&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        # Add reserved claims</span>
<span class="gi">+        for time_claim in [&#39;exp&#39;, &#39;iat&#39;, &#39;nbf&#39;]:</span>
<span class="gi">+            if time_claim in payload:</span>
<span class="gi">+                value = payload[time_claim]</span>
<span class="gi">+                if isinstance(value, datetime):</span>
<span class="gi">+                    payload[time_claim] = timegm(value.utctimetuple())</span>
<span class="gi">+                elif isinstance(value, str):</span>
<span class="gi">+                    try:</span>
<span class="gi">+                        payload[time_claim] = int(value)</span>
<span class="gi">+                    except ValueError:</span>
<span class="gi">+                        raise TypeError(f&#39;{time_claim} must be a valid timestamp&#39;)</span>
<span class="gi">+                elif not isinstance(value, (int, float)):</span>
<span class="gi">+                    raise TypeError(f&#39;{time_claim} must be a valid timestamp&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        json_payload = self._encode_payload(payload, headers, json_encoder)</span>
<span class="gi">+        return api_jws.encode(json_payload, key, algorithm, headers, json_encoder)</span>
<span class="gi">+</span>
<span class="gi">+    def decode_complete(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, **kwargs: Any) -&gt; dict[str, Any]:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Decodes a JWT and returns a dict of the token contents.</span>
<span class="gi">+</span>
<span class="gi">+        Args:</span>
<span class="gi">+            jwt: The JWT to decode.</span>
<span class="gi">+            key: The key to use for verifying the claim. Note: if the algorithm is &#39;none&#39;, the key is not used.</span>
<span class="gi">+            algorithms: A list of allowed algorithms. If None, default to the algorithms registered.</span>
<span class="gi">+            options: A dict of options for decoding. If None, use default options.</span>
<span class="gi">+            **kwargs: Additional options for decoding.</span>
<span class="gi">+</span>
<span class="gi">+        Returns:</span>
<span class="gi">+            A dict including:</span>
<span class="gi">+                - header: A dict of the JWT header</span>
<span class="gi">+                - payload: The decoded payload</span>
<span class="gi">+                - signature: The signature of the JWT</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        merged_options = {**self.options, **(options or {})}</span>
<span class="gi">+        decoded = api_jws.decode_complete(jwt, key, algorithms, merged_options)</span>
<span class="gi">+        payload = self._decode_payload(decoded)</span>
<span class="gi">+</span>
<span class="gi">+        if merged_options[&#39;verify_exp&#39;] and &#39;exp&#39; in payload:</span>
<span class="gi">+            now = kwargs.get(&#39;now&#39;, datetime.now(timezone.utc))</span>
<span class="gi">+            exp = datetime.fromtimestamp(payload[&#39;exp&#39;], tz=timezone.utc)</span>
<span class="gi">+            leeway = timedelta(seconds=kwargs.get(&#39;leeway&#39;, 0))</span>
<span class="gi">+            if now &gt; exp + leeway:</span>
<span class="gi">+                raise ExpiredSignatureError(&#39;Signature has expired&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if merged_options[&#39;verify_nbf&#39;] and &#39;nbf&#39; in payload:</span>
<span class="gi">+            now = kwargs.get(&#39;now&#39;, datetime.now(timezone.utc))</span>
<span class="gi">+            nbf = datetime.fromtimestamp(payload[&#39;nbf&#39;], tz=timezone.utc)</span>
<span class="gi">+            leeway = timedelta(seconds=kwargs.get(&#39;leeway&#39;, 0))</span>
<span class="gi">+            if now &lt; nbf - leeway:</span>
<span class="gi">+                raise ImmatureSignatureError(&#39;The token is not yet valid (nbf)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if merged_options[&#39;verify_iat&#39;] and &#39;iat&#39; in payload:</span>
<span class="gi">+            now = kwargs.get(&#39;now&#39;, datetime.now(timezone.utc))</span>
<span class="gi">+            iat = datetime.fromtimestamp(payload[&#39;iat&#39;], tz=timezone.utc)</span>
<span class="gi">+            leeway = timedelta(seconds=kwargs.get(&#39;leeway&#39;, 0))</span>
<span class="gi">+            if now &lt; iat - leeway:</span>
<span class="gi">+                raise InvalidIssuedAtError(&#39;Issued at claim (iat) cannot be in the future&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if merged_options[&#39;verify_iss&#39;]:</span>
<span class="gi">+            expected_issuer = kwargs.get(&#39;issuer&#39;, None)</span>
<span class="gi">+            if expected_issuer is not None:</span>
<span class="gi">+                if &#39;iss&#39; not in payload:</span>
<span class="gi">+                    raise MissingRequiredClaimError(&#39;Issuer claim expected but not present&#39;)</span>
<span class="gi">+                if payload[&#39;iss&#39;] != expected_issuer:</span>
<span class="gi">+                    raise InvalidIssuerError(&#39;Invalid issuer&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if merged_options[&#39;verify_aud&#39;]:</span>
<span class="gi">+            expected_audience = kwargs.get(&#39;audience&#39;, None)</span>
<span class="gi">+            if expected_audience is not None:</span>
<span class="gi">+                if &#39;aud&#39; not in payload:</span>
<span class="gi">+                    raise MissingRequiredClaimError(&#39;Audience claim expected but not present&#39;)</span>
<span class="gi">+                audience = payload[&#39;aud&#39;]</span>
<span class="gi">+                if isinstance(audience, str):</span>
<span class="gi">+                    audience = [audience]</span>
<span class="gi">+                if not isinstance(audience, Iterable) or not all(isinstance(aud, str) for aud in audience):</span>
<span class="gi">+                    raise InvalidAudienceError(&#39;Invalid claim format in token&#39;)</span>
<span class="gi">+                if expected_audience not in audience:</span>
<span class="gi">+                    raise InvalidAudienceError(&#39;Invalid audience&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if merged_options[&#39;require&#39;]:</span>
<span class="gi">+            for claim in merged_options[&#39;require&#39;]:</span>
<span class="gi">+                if claim not in payload:</span>
<span class="gi">+                    raise MissingRequiredClaimError(f&#39;Token is missing the &quot;{claim}&quot; claim&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        decoded[&#39;payload&#39;] = payload</span>
<span class="gi">+        return decoded</span>
<span class="gi">+</span>
<span class="gi">+    def decode(self, jwt: str | bytes, key: str | bytes | AllowedPublicKeys | None=None, algorithms: list[str] | None=None, options: dict[str, Any] | None=None, **kwargs: Any) -&gt; dict[str, Any]:</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        Decodes a JWT and returns the payload.</span>
<span class="gi">+</span>
<span class="gi">+        This is a shortcut to :meth:`decode_complete()` that returns just the payload.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        decoded = self.decode_complete(jwt, key, algorithms, options, **kwargs)</span>
<span class="gi">+        return decoded[&#39;payload&#39;]</span>
<span class="w"> </span>_jwt_global_obj = PyJWT()
<span class="w"> </span>encode = _jwt_global_obj.encode
<span class="w"> </span>decode_complete = _jwt_global_obj.decode_complete
<span class="gh">diff --git a/jwt/jwk_set_cache.py b/jwt/jwk_set_cache.py</span>
<span class="gh">index e57abb8..87cba70 100644</span>
<span class="gd">--- a/jwt/jwk_set_cache.py</span>
<span class="gi">+++ b/jwt/jwk_set_cache.py</span>
<span class="gu">@@ -6,4 +6,22 @@ class JWKSetCache:</span>

<span class="w"> </span>    def __init__(self, lifespan: int) -&gt; None:
<span class="w"> </span>        self.jwk_set_with_timestamp: Optional[PyJWTSetWithTimestamp] = None
<span class="gd">-        self.lifespan = lifespan</span>
\ No newline at end of file
<span class="gi">+        self.lifespan = lifespan</span>
<span class="gi">+</span>
<span class="gi">+    @property</span>
<span class="gi">+    def jwk_set(self) -&gt; PyJWKSet:</span>
<span class="gi">+        if self.jwk_set_with_timestamp is None:</span>
<span class="gi">+            raise ValueError(&#39;No JWK set has been cached&#39;)</span>
<span class="gi">+        return self.jwk_set_with_timestamp.jwk_set</span>
<span class="gi">+</span>
<span class="gi">+    @jwk_set.setter</span>
<span class="gi">+    def jwk_set(self, value: PyJWKSet) -&gt; None:</span>
<span class="gi">+        self.jwk_set_with_timestamp = PyJWTSetWithTimestamp(value, int(time.time()))</span>
<span class="gi">+</span>
<span class="gi">+    def is_expired(self) -&gt; bool:</span>
<span class="gi">+        if self.jwk_set_with_timestamp is None:</span>
<span class="gi">+            return True</span>
<span class="gi">+        return int(time.time()) - self.jwk_set_with_timestamp.timestamp &gt; self.lifespan</span>
<span class="gi">+</span>
<span class="gi">+    def delete(self) -&gt; None:</span>
<span class="gi">+        self.jwk_set_with_timestamp = None</span>
\ No newline at end of file
<span class="gh">diff --git a/jwt/jwks_client.py b/jwt/jwks_client.py</span>
<span class="gh">index 34c461f..a717851 100644</span>
<span class="gd">--- a/jwt/jwks_client.py</span>
<span class="gi">+++ b/jwt/jwks_client.py</span>
<span class="gu">@@ -26,4 +26,101 @@ class PyJWKClient:</span>
<span class="w"> </span>        else:
<span class="w"> </span>            self.jwk_set_cache = None
<span class="w"> </span>        if cache_keys:
<span class="gd">-            self.get_signing_key = lru_cache(maxsize=max_cached_keys)(self.get_signing_key)</span>
\ No newline at end of file
<span class="gi">+            self.get_signing_key = lru_cache(maxsize=max_cached_keys)(self.get_signing_key)</span>
<span class="gi">+</span>
<span class="gi">+    def fetch_data(self) -&gt; str:</span>
<span class="gi">+        &quot;&quot;&quot;Fetch the JWKS data from the uri provided during instantiation.&quot;&quot;&quot;</span>
<span class="gi">+        try:</span>
<span class="gi">+            request = urllib.request.Request(self.uri, headers=self.headers)</span>
<span class="gi">+            if self.ssl_context:</span>
<span class="gi">+                response = urllib.request.urlopen(request, timeout=self.timeout, context=self.ssl_context)</span>
<span class="gi">+            else:</span>
<span class="gi">+                response = urllib.request.urlopen(request, timeout=self.timeout)</span>
<span class="gi">+            data = response.read()</span>
<span class="gi">+            if isinstance(data, str):</span>
<span class="gi">+                return data</span>
<span class="gi">+            return data.decode(&#39;utf-8&#39;)</span>
<span class="gi">+        except URLError as e:</span>
<span class="gi">+            raise PyJWKClientConnectionError(f&#39;Failed to fetch JWKS from {self.uri}. Error: {str(e)}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def get_jwk_set(self, refresh: bool=False) -&gt; PyJWKSet:</span>
<span class="gi">+        &quot;&quot;&quot;Return the fetched PyJWKSet.</span>
<span class="gi">+        </span>
<span class="gi">+        Args:</span>
<span class="gi">+            refresh: Force a refetch of the JWKS.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        if not refresh and self.jwk_set_cache and not self.jwk_set_cache.is_expired():</span>
<span class="gi">+            return self.jwk_set_cache.jwk_set</span>
<span class="gi">+</span>
<span class="gi">+        data = self.fetch_data()</span>
<span class="gi">+        try:</span>
<span class="gi">+            jwk_set = PyJWKSet.from_json(data)</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            if self.jwk_set_cache:</span>
<span class="gi">+                self.jwk_set_cache.delete()</span>
<span class="gi">+            raise PyJWKClientError(f&#39;Failed to parse JWKS: {str(e)}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        if self.jwk_set_cache:</span>
<span class="gi">+            self.jwk_set_cache.jwk_set = jwk_set</span>
<span class="gi">+</span>
<span class="gi">+        return jwk_set</span>
<span class="gi">+</span>
<span class="gi">+    def get_signing_keys(self) -&gt; List[PyJWK]:</span>
<span class="gi">+        &quot;&quot;&quot;Return a list of signing keys from the JWKS.&quot;&quot;&quot;</span>
<span class="gi">+        jwk_set = self.get_jwk_set()</span>
<span class="gi">+        signing_keys = []</span>
<span class="gi">+</span>
<span class="gi">+        for jwk_key in jwk_set.keys:</span>
<span class="gi">+            if jwk_key.public_key_use == &#39;sig&#39; or not jwk_key.public_key_use:</span>
<span class="gi">+                signing_keys.append(jwk_key)</span>
<span class="gi">+</span>
<span class="gi">+        if not signing_keys:</span>
<span class="gi">+            raise PyJWKClientError(&#39;No signing keys found in JWKS&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        return signing_keys</span>
<span class="gi">+</span>
<span class="gi">+    def get_signing_key(self, kid: str) -&gt; PyJWK:</span>
<span class="gi">+        &quot;&quot;&quot;Return the signing key from the JWKS that matches the provided kid.</span>
<span class="gi">+        </span>
<span class="gi">+        Args:</span>
<span class="gi">+            kid: The key ID to search for.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        signing_keys = self.get_signing_keys()</span>
<span class="gi">+        for key in signing_keys:</span>
<span class="gi">+            if key.key_id == kid:</span>
<span class="gi">+                return key</span>
<span class="gi">+</span>
<span class="gi">+        # If no key is found, try refreshing the JWKS once</span>
<span class="gi">+        signing_keys = self.get_signing_keys()</span>
<span class="gi">+        for key in signing_keys:</span>
<span class="gi">+            if key.key_id == kid:</span>
<span class="gi">+                return key</span>
<span class="gi">+</span>
<span class="gi">+        raise PyJWKClientError(f&#39;Unable to find a signing key that matches: {kid}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    def get_signing_key_from_jwt(self, token: str, refresh_jwks: bool=True) -&gt; PyJWK:</span>
<span class="gi">+        &quot;&quot;&quot;Return the signing key from the JWKS that matches the kid in the token header.</span>
<span class="gi">+        </span>
<span class="gi">+        Args:</span>
<span class="gi">+            token: The JWT token to get the key for.</span>
<span class="gi">+            refresh_jwks: Whether to refresh the JWKS if the key is not found.</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        try:</span>
<span class="gi">+            headers = decode_token(token, options={&#39;verify_signature&#39;: False})[&#39;header&#39;]</span>
<span class="gi">+        except Exception as e:</span>
<span class="gi">+            raise PyJWKClientError(f&#39;Failed to decode JWT headers: {str(e)}&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        kid = headers.get(&#39;kid&#39;)</span>
<span class="gi">+        if not kid:</span>
<span class="gi">+            signing_keys = self.get_signing_keys()</span>
<span class="gi">+            if len(signing_keys) == 1:</span>
<span class="gi">+                return signing_keys[0]</span>
<span class="gi">+            raise PyJWKClientError(&#39;Token headers must include a key ID (&quot;kid&quot;)&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        try:</span>
<span class="gi">+            return self.get_signing_key(kid)</span>
<span class="gi">+        except PyJWKClientError:</span>
<span class="gi">+            if refresh_jwks:</span>
<span class="gi">+                self.get_jwk_set(refresh=True)</span>
<span class="gi">+                return self.get_signing_key(kid)</span>
<span class="gi">+            raise</span>
\ No newline at end of file
<span class="gh">diff --git a/jwt/utils.py b/jwt/utils.py</span>
<span class="gh">index 3115d4c..6b01bd9 100644</span>
<span class="gd">--- a/jwt/utils.py</span>
<span class="gi">+++ b/jwt/utils.py</span>
<span class="gu">@@ -7,6 +7,74 @@ try:</span>
<span class="w"> </span>    from cryptography.hazmat.primitives.asymmetric.utils import decode_dss_signature, encode_dss_signature
<span class="w"> </span>except ModuleNotFoundError:
<span class="w"> </span>    pass
<span class="gi">+</span>
<span class="gi">+def force_bytes(value: Union[str, bytes]) -&gt; bytes:</span>
<span class="gi">+    if isinstance(value, str):</span>
<span class="gi">+        return value.encode(&#39;utf-8&#39;)</span>
<span class="gi">+    elif isinstance(value, bytes):</span>
<span class="gi">+        return value</span>
<span class="gi">+    else:</span>
<span class="gi">+        raise TypeError(&#39;Expected string or bytes type&#39;)</span>
<span class="gi">+</span>
<span class="gi">+def base64url_decode(input: Union[str, bytes]) -&gt; bytes:</span>
<span class="gi">+    if isinstance(input, str):</span>
<span class="gi">+        input = input.encode(&#39;ascii&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    rem = len(input) % 4</span>
<span class="gi">+    if rem &gt; 0:</span>
<span class="gi">+        input += b&#39;=&#39; * (4 - rem)</span>
<span class="gi">+    </span>
<span class="gi">+    return base64.urlsafe_b64decode(input)</span>
<span class="gi">+</span>
<span class="gi">+def base64url_encode(input: bytes) -&gt; bytes:</span>
<span class="gi">+    return base64.urlsafe_b64encode(input).rstrip(b&#39;=&#39;)</span>
<span class="gi">+</span>
<span class="gi">+def to_base64url_uint(val: int) -&gt; bytes:</span>
<span class="gi">+    if val &lt; 0:</span>
<span class="gi">+        raise ValueError(&#39;Must be a positive integer&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    if val == 0:</span>
<span class="gi">+        return b&#39;AA&#39;</span>
<span class="gi">+    </span>
<span class="gi">+    int_bytes = val.to_bytes((val.bit_length() + 7) // 8, byteorder=&#39;big&#39;)</span>
<span class="gi">+    return base64url_encode(int_bytes)</span>
<span class="gi">+</span>
<span class="gi">+def from_base64url_uint(val: Union[str, bytes]) -&gt; int:</span>
<span class="gi">+    if isinstance(val, str):</span>
<span class="gi">+        val = val.encode(&#39;ascii&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    data = base64url_decode(val)</span>
<span class="gi">+    return int.from_bytes(data, byteorder=&#39;big&#39;)</span>
<span class="gi">+</span>
<span class="gi">+def der_to_raw_signature(der_sig: bytes, curve: EllipticCurve) -&gt; bytes:</span>
<span class="gi">+    r, s = decode_dss_signature(der_sig)</span>
<span class="gi">+    key_size = (curve.key_size + 7) // 8</span>
<span class="gi">+    return r.to_bytes(key_size, byteorder=&#39;big&#39;) + s.to_bytes(key_size, byteorder=&#39;big&#39;)</span>
<span class="gi">+</span>
<span class="gi">+def raw_to_der_signature(raw_sig: bytes, curve: EllipticCurve) -&gt; bytes:</span>
<span class="gi">+    key_size = (curve.key_size + 7) // 8</span>
<span class="gi">+    if len(raw_sig) != 2 * key_size:</span>
<span class="gi">+        raise ValueError(&#39;Invalid signature&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    r = int.from_bytes(raw_sig[:key_size], byteorder=&#39;big&#39;)</span>
<span class="gi">+    s = int.from_bytes(raw_sig[key_size:], byteorder=&#39;big&#39;)</span>
<span class="gi">+    return encode_dss_signature(r, s)</span>
<span class="gi">+</span>
<span class="gi">+def is_pem_format(key: bytes) -&gt; bool:</span>
<span class="gi">+    return bool(_PEM_RE.search(key))</span>
<span class="gi">+</span>
<span class="gi">+def is_ssh_key(key: bytes) -&gt; bool:</span>
<span class="gi">+    if key.startswith(b&#39;ssh-&#39;) or key.startswith(b&#39;ecdsa-&#39;):</span>
<span class="gi">+        return True</span>
<span class="gi">+    </span>
<span class="gi">+    match = _SSH_PUBKEY_RC.match(key)</span>
<span class="gi">+    if not match:</span>
<span class="gi">+        return False</span>
<span class="gi">+    </span>
<span class="gi">+    key_type = match.group(1)</span>
<span class="gi">+    return (key_type in _SSH_KEY_FORMATS or </span>
<span class="gi">+            any(key_type.endswith(suffix) for suffix in [_CERT_SUFFIX]))</span>
<span class="gi">+</span>
<span class="w"> </span>_PEMS = {b&#39;CERTIFICATE&#39;, b&#39;TRUSTED CERTIFICATE&#39;, b&#39;PRIVATE KEY&#39;, b&#39;PUBLIC KEY&#39;, b&#39;ENCRYPTED PRIVATE KEY&#39;, b&#39;OPENSSH PRIVATE KEY&#39;, b&#39;DSA PRIVATE KEY&#39;, b&#39;RSA PRIVATE KEY&#39;, b&#39;RSA PUBLIC KEY&#39;, b&#39;EC PRIVATE KEY&#39;, b&#39;DH PARAMETERS&#39;, b&#39;NEW CERTIFICATE REQUEST&#39;, b&#39;CERTIFICATE REQUEST&#39;, b&#39;SSH2 PUBLIC KEY&#39;, b&#39;SSH2 ENCRYPTED PRIVATE KEY&#39;, b&#39;X509 CRL&#39;}
<span class="w"> </span>_PEM_RE = re.compile(b&#39;----[- ]BEGIN (&#39; + b&#39;|&#39;.join(_PEMS) + b&#39;)[- ]----\r?\n.+?\r?\n----[- ]END \\1[- ]----\r?\n?&#39;, re.DOTALL)
<span class="w"> </span>_CERT_SUFFIX = b&#39;-cert-v01@openssh.com&#39;
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>