
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.37">
    
    
      
        <title>Analysis commit0 all plain fillin python rsa - Commit-0</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.8c3ca2c6.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#claude-sonnet-35-fill-in-python-rsa" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Commit-0" class="md-header__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Commit-0
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Analysis commit0 all plain fillin python rsa
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Commit-0" class="md-nav__button md-logo" aria-label="Commit-0" data-md-component="logo">
      
  <img src="../logo2.webp" alt="logo">

    </a>
    Commit-0
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../setupdist/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Commit0
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../agent/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Agent
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../api/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    API
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../analysis/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Leaderboard
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#pytest-summary-for-test-tests" class="md-nav__link">
    <span class="md-ellipsis">
      Pytest Summary for test tests
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#failed-pytests" class="md-nav__link">
    <span class="md-ellipsis">
      Failed pytests:
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Failed pytests:">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#test_clipykeygentesttest_keygen_no_args" class="md-nav__link">
    <span class="md-ellipsis">
      test_cli.py::KeygenTest::test_keygen_no_args
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clipykeygentesttest_keygen_priv_out_der" class="md-nav__link">
    <span class="md-ellipsis">
      test_cli.py::KeygenTest::test_keygen_priv_out_der
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clipykeygentesttest_keygen_priv_out_pem" class="md-nav__link">
    <span class="md-ellipsis">
      test_cli.py::KeygenTest::test_keygen_priv_out_pem
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clipykeygentesttest_keygen_priv_stdout" class="md-nav__link">
    <span class="md-ellipsis">
      test_cli.py::KeygenTest::test_keygen_priv_stdout
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clipykeygentesttest_keygen_pub_out_pem" class="md-nav__link">
    <span class="md-ellipsis">
      test_cli.py::KeygenTest::test_keygen_pub_out_pem
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clipyencryptdecrypttesttest_empty_decrypt" class="md-nav__link">
    <span class="md-ellipsis">
      test_cli.py::EncryptDecryptTest::test_empty_decrypt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clipyencryptdecrypttesttest_empty_encrypt" class="md-nav__link">
    <span class="md-ellipsis">
      test_cli.py::EncryptDecryptTest::test_empty_encrypt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clipyencryptdecrypttesttest_encrypt_decrypt" class="md-nav__link">
    <span class="md-ellipsis">
      test_cli.py::EncryptDecryptTest::test_encrypt_decrypt
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clipyencryptdecrypttesttest_encrypt_decrypt_unhappy" class="md-nav__link">
    <span class="md-ellipsis">
      test_cli.py::EncryptDecryptTest::test_encrypt_decrypt_unhappy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clipysignverifytesttest_empty_sign" class="md-nav__link">
    <span class="md-ellipsis">
      test_cli.py::SignVerifyTest::test_empty_sign
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clipysignverifytesttest_empty_verify" class="md-nav__link">
    <span class="md-ellipsis">
      test_cli.py::SignVerifyTest::test_empty_verify
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clipysignverifytesttest_sign_verify" class="md-nav__link">
    <span class="md-ellipsis">
      test_cli.py::SignVerifyTest::test_sign_verify
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clipysignverifytesttest_sign_verify_unhappy" class="md-nav__link">
    <span class="md-ellipsis">
      test_cli.py::SignVerifyTest::test_sign_verify_unhappy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_clipyprivatepublictesttest_private_to_public" class="md-nav__link">
    <span class="md-ellipsis">
      test_cli.py::PrivatePublicTest::test_private_to_public
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_commonpytestbytesizetest_zero" class="md-nav__link">
    <span class="md-ellipsis">
      test_common.py::TestByteSize::test_zero
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_commonpytestbitsizetest_bad_type" class="md-nav__link">
    <span class="md-ellipsis">
      test_common.py::TestBitSize::test_bad_type
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_keypyblindingtesttest_blinding" class="md-nav__link">
    <span class="md-ellipsis">
      test_key.py::BlindingTest::test_blinding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_keypykeygentesttest_custom_exponent" class="md-nav__link">
    <span class="md-ellipsis">
      test_key.py::KeyGenTest::test_custom_exponent
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_keypykeygentesttest_custom_getprime_func" class="md-nav__link">
    <span class="md-ellipsis">
      test_key.py::KeyGenTest::test_custom_getprime_func
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_load_save_keyspydertesttest_load_malformed_private_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_load_save_keys.py::DerTest::test_load_malformed_private_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_load_save_keyspydertesttest_load_private_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_load_save_keys.py::DerTest::test_load_private_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_load_save_keyspydertesttest_load_public_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_load_save_keys.py::DerTest::test_load_public_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_load_save_keyspydertesttest_save_private_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_load_save_keys.py::DerTest::test_save_private_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_load_save_keyspydertesttest_save_public_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_load_save_keys.py::DerTest::test_save_public_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_load_save_keyspypemtesttest_load_from_disk" class="md-nav__link">
    <span class="md-ellipsis">
      test_load_save_keys.py::PemTest::test_load_from_disk
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_load_save_keyspypemtesttest_load_private_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_load_save_keys.py::PemTest::test_load_private_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_load_save_keyspypemtesttest_load_public_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_load_save_keys.py::PemTest::test_load_public_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_load_save_keyspypemtesttest_save_private_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_load_save_keys.py::PemTest::test_save_private_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_load_save_keyspypemtesttest_save_public_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_load_save_keys.py::PemTest::test_save_public_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_mypypymypyrunnertesttest_run_mypy" class="md-nav__link">
    <span class="md-ellipsis">
      test_mypy.py::MypyRunnerTest::test_run_mypy
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_parallelpyparalleltesttest_parallel_primegen" class="md-nav__link">
    <span class="md-ellipsis">
      test_parallel.py::ParallelTest::test_parallel_primegen
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pempytestbytesandstringstest_bytes_private" class="md-nav__link">
    <span class="md-ellipsis">
      test_pem.py::TestBytesAndStrings::test_bytes_private
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pempytestbytesandstringstest_bytes_public" class="md-nav__link">
    <span class="md-ellipsis">
      test_pem.py::TestBytesAndStrings::test_bytes_public
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pempytestbytesandstringstest_unicode_private" class="md-nav__link">
    <span class="md-ellipsis">
      test_pem.py::TestBytesAndStrings::test_unicode_private
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pempytestbytesandstringstest_unicode_public" class="md-nav__link">
    <span class="md-ellipsis">
      test_pem.py::TestBytesAndStrings::test_unicode_public
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pempytestbyteoutputtest_bytes_private" class="md-nav__link">
    <span class="md-ellipsis">
      test_pem.py::TestByteOutput::test_bytes_private
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pempytestbyteoutputtest_bytes_public" class="md-nav__link">
    <span class="md-ellipsis">
      test_pem.py::TestByteOutput::test_bytes_public
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pempytestbyteinputtest_bytes_private" class="md-nav__link">
    <span class="md-ellipsis">
      test_pem.py::TestByteInput::test_bytes_private
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pempytestbyteinputtest_bytes_public" class="md-nav__link">
    <span class="md-ellipsis">
      test_pem.py::TestByteInput::test_bytes_public
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkcs1pybinarytesttest_decoding_failure" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkcs1.py::BinaryTest::test_decoding_failure
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkcs1pybinarytesttest_enc_dec" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkcs1.py::BinaryTest::test_enc_dec
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkcs1pybinarytesttest_randomness" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkcs1.py::BinaryTest::test_randomness
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkcs1pyextrazeroestesttest_append_zeroes" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkcs1.py::ExtraZeroesTest::test_append_zeroes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkcs1pyextrazeroestesttest_prepend_zeroes" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkcs1.py::ExtraZeroesTest::test_prepend_zeroes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkcs1pyextrazeroestesttest_unmodified" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkcs1.py::ExtraZeroesTest::test_unmodified
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkcs1pysignaturetesttest_alter_message" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkcs1.py::SignatureTest::test_alter_message
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkcs1pysignaturetesttest_apppend_zeroes" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkcs1.py::SignatureTest::test_apppend_zeroes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkcs1pysignaturetesttest_find_signature_hash" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkcs1.py::SignatureTest::test_find_signature_hash
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkcs1pysignaturetesttest_hash_sign_verify" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkcs1.py::SignatureTest::test_hash_sign_verify
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkcs1pysignaturetesttest_multiple_signings" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkcs1.py::SignatureTest::test_multiple_signings
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkcs1pysignaturetesttest_prepend_zeroes" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkcs1.py::SignatureTest::test_prepend_zeroes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkcs1pysignaturetesttest_sign_different_key" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkcs1.py::SignatureTest::test_sign_different_key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkcs1pysignaturetesttest_sign_verify" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkcs1.py::SignatureTest::test_sign_verify
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkcs1pysignaturetesttest_sign_verify_sha3" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkcs1.py::SignatureTest::test_sign_verify_sha3
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkcs1pysignaturetesttest_split_hash_sign" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkcs1.py::SignatureTest::test_split_hash_sign
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_pkcs1pypaddingsizetesttest_too_little_padding" class="md-nav__link">
    <span class="md-ellipsis">
      test_pkcs1.py::PaddingSizeTest::test_too_little_padding
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_primepyprimetesttest_is_prime" class="md-nav__link">
    <span class="md-ellipsis">
      test_prime.py::PrimeTest::test_is_prime
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_primepyprimetesttest_mersenne_primes" class="md-nav__link">
    <span class="md-ellipsis">
      test_prime.py::PrimeTest::test_mersenne_primes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_primepyprimetesttest_miller_rabin_primality_testing" class="md-nav__link">
    <span class="md-ellipsis">
      test_prime.py::PrimeTest::test_miller_rabin_primality_testing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_stringspystringtesttest_enc_dec" class="md-nav__link">
    <span class="md-ellipsis">
      test_strings.py::StringTest::test_enc_dec
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#patch-diff" class="md-nav__link">
    <span class="md-ellipsis">
      Patch diff
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<p><a href="/analysis_commit0-all-plain_fillin">back to Claude Sonnet 3.5 - Fill-in summary</a></p>
<h1 id="claude-sonnet-35-fill-in-python-rsa"><strong>Claude Sonnet 3.5 - Fill-in</strong>: python-rsa</h1>
<h2 id="pytest-summary-for-test-tests">Pytest Summary for test <code>tests</code></h2>
<table>
<thead>
<tr>
<th style="text-align: left;">status</th>
<th style="text-align: center;">count</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">error</td>
<td style="text-align: center;">14</td>
</tr>
<tr>
<td style="text-align: left;">passed</td>
<td style="text-align: center;">27</td>
</tr>
<tr>
<td style="text-align: left;">failed</td>
<td style="text-align: center;">46</td>
</tr>
<tr>
<td style="text-align: left;">total</td>
<td style="text-align: center;">87</td>
</tr>
<tr>
<td style="text-align: left;">collected</td>
<td style="text-align: center;">87</td>
</tr>
</tbody>
</table>
<h2 id="failed-pytests">Failed pytests:</h2>
<h3 id="test_clipykeygentesttest_keygen_no_args">test_cli.py::KeygenTest::test_keygen_no_args</h3>
<details><summary> <pre>test_cli.py::KeygenTest::test_keygen_no_args</pre></summary><pre>
cls = <class 'tests.test_cli.KeygenTest'>

    @classmethod
    def setUpClass(cls):
        # Ensure there is a key to use
>       cls.pub_key, cls.priv_key = rsa.newkeys(512)

tests/test_cli.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 743751405158786252...2836173314102210566

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_clipykeygentesttest_keygen_priv_out_der">test_cli.py::KeygenTest::test_keygen_priv_out_der</h3>
<details><summary> <pre>test_cli.py::KeygenTest::test_keygen_priv_out_der</pre></summary><pre>
cls = <class 'tests.test_cli.KeygenTest'>

    @classmethod
    def setUpClass(cls):
        # Ensure there is a key to use
>       cls.pub_key, cls.priv_key = rsa.newkeys(512)

tests/test_cli.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 743751405158786252...2836173314102210566

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_clipykeygentesttest_keygen_priv_out_pem">test_cli.py::KeygenTest::test_keygen_priv_out_pem</h3>
<details><summary> <pre>test_cli.py::KeygenTest::test_keygen_priv_out_pem</pre></summary><pre>
cls = <class 'tests.test_cli.KeygenTest'>

    @classmethod
    def setUpClass(cls):
        # Ensure there is a key to use
>       cls.pub_key, cls.priv_key = rsa.newkeys(512)

tests/test_cli.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 743751405158786252...2836173314102210566

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_clipykeygentesttest_keygen_priv_stdout">test_cli.py::KeygenTest::test_keygen_priv_stdout</h3>
<details><summary> <pre>test_cli.py::KeygenTest::test_keygen_priv_stdout</pre></summary><pre>
cls = <class 'tests.test_cli.KeygenTest'>

    @classmethod
    def setUpClass(cls):
        # Ensure there is a key to use
>       cls.pub_key, cls.priv_key = rsa.newkeys(512)

tests/test_cli.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 743751405158786252...2836173314102210566

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_clipykeygentesttest_keygen_pub_out_pem">test_cli.py::KeygenTest::test_keygen_pub_out_pem</h3>
<details><summary> <pre>test_cli.py::KeygenTest::test_keygen_pub_out_pem</pre></summary><pre>
cls = <class 'tests.test_cli.KeygenTest'>

    @classmethod
    def setUpClass(cls):
        # Ensure there is a key to use
>       cls.pub_key, cls.priv_key = rsa.newkeys(512)

tests/test_cli.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 743751405158786252...2836173314102210566

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_clipyencryptdecrypttesttest_empty_decrypt">test_cli.py::EncryptDecryptTest::test_empty_decrypt</h3>
<details><summary> <pre>test_cli.py::EncryptDecryptTest::test_empty_decrypt</pre></summary><pre>
cls = <class 'tests.test_cli.EncryptDecryptTest'>

    @classmethod
    def setUpClass(cls):
        # Ensure there is a key to use
>       cls.pub_key, cls.priv_key = rsa.newkeys(512)

tests/test_cli.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 811199013963414042...1891549032260233556

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_clipyencryptdecrypttesttest_empty_encrypt">test_cli.py::EncryptDecryptTest::test_empty_encrypt</h3>
<details><summary> <pre>test_cli.py::EncryptDecryptTest::test_empty_encrypt</pre></summary><pre>
cls = <class 'tests.test_cli.EncryptDecryptTest'>

    @classmethod
    def setUpClass(cls):
        # Ensure there is a key to use
>       cls.pub_key, cls.priv_key = rsa.newkeys(512)

tests/test_cli.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 811199013963414042...1891549032260233556

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_clipyencryptdecrypttesttest_encrypt_decrypt">test_cli.py::EncryptDecryptTest::test_encrypt_decrypt</h3>
<details><summary> <pre>test_cli.py::EncryptDecryptTest::test_encrypt_decrypt</pre></summary><pre>
cls = <class 'tests.test_cli.EncryptDecryptTest'>

    @classmethod
    def setUpClass(cls):
        # Ensure there is a key to use
>       cls.pub_key, cls.priv_key = rsa.newkeys(512)

tests/test_cli.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 811199013963414042...1891549032260233556

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_clipyencryptdecrypttesttest_encrypt_decrypt_unhappy">test_cli.py::EncryptDecryptTest::test_encrypt_decrypt_unhappy</h3>
<details><summary> <pre>test_cli.py::EncryptDecryptTest::test_encrypt_decrypt_unhappy</pre></summary><pre>
cls = <class 'tests.test_cli.EncryptDecryptTest'>

    @classmethod
    def setUpClass(cls):
        # Ensure there is a key to use
>       cls.pub_key, cls.priv_key = rsa.newkeys(512)

tests/test_cli.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 811199013963414042...1891549032260233556

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_clipysignverifytesttest_empty_sign">test_cli.py::SignVerifyTest::test_empty_sign</h3>
<details><summary> <pre>test_cli.py::SignVerifyTest::test_empty_sign</pre></summary><pre>
cls = <class 'tests.test_cli.SignVerifyTest'>

    @classmethod
    def setUpClass(cls):
        # Ensure there is a key to use
>       cls.pub_key, cls.priv_key = rsa.newkeys(512)

tests/test_cli.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 827351877812086722...6328161396155403886

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_clipysignverifytesttest_empty_verify">test_cli.py::SignVerifyTest::test_empty_verify</h3>
<details><summary> <pre>test_cli.py::SignVerifyTest::test_empty_verify</pre></summary><pre>
cls = <class 'tests.test_cli.SignVerifyTest'>

    @classmethod
    def setUpClass(cls):
        # Ensure there is a key to use
>       cls.pub_key, cls.priv_key = rsa.newkeys(512)

tests/test_cli.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 827351877812086722...6328161396155403886

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_clipysignverifytesttest_sign_verify">test_cli.py::SignVerifyTest::test_sign_verify</h3>
<details><summary> <pre>test_cli.py::SignVerifyTest::test_sign_verify</pre></summary><pre>
cls = <class 'tests.test_cli.SignVerifyTest'>

    @classmethod
    def setUpClass(cls):
        # Ensure there is a key to use
>       cls.pub_key, cls.priv_key = rsa.newkeys(512)

tests/test_cli.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 827351877812086722...6328161396155403886

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_clipysignverifytesttest_sign_verify_unhappy">test_cli.py::SignVerifyTest::test_sign_verify_unhappy</h3>
<details><summary> <pre>test_cli.py::SignVerifyTest::test_sign_verify_unhappy</pre></summary><pre>
cls = <class 'tests.test_cli.SignVerifyTest'>

    @classmethod
    def setUpClass(cls):
        # Ensure there is a key to use
>       cls.pub_key, cls.priv_key = rsa.newkeys(512)

tests/test_cli.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 827351877812086722...6328161396155403886

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_clipyprivatepublictesttest_private_to_public">test_cli.py::PrivatePublicTest::test_private_to_public</h3>
<details><summary> <pre>test_cli.py::PrivatePublicTest::test_private_to_public</pre></summary><pre>
cls = <class 'tests.test_cli.PrivatePublicTest'>

    @classmethod
    def setUpClass(cls):
        # Ensure there is a key to use
>       cls.pub_key, cls.priv_key = rsa.newkeys(512)

tests/test_cli.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 977397274916830518...1552735140431588956

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_commonpytestbytesizetest_zero">test_common.py::TestByteSize::test_zero</h3>
<details><summary> <pre>test_common.py::TestByteSize::test_zero</pre></summary><pre>
self = <tests.test_common.TestByteSize testMethod=test_zero>

    def test_zero(self):
>       self.assertEqual(byte_size(0), 1)
E       AssertionError: 0 != 1

tests/test_common.py:37: AssertionError
</pre>
</details>
<h3 id="test_commonpytestbitsizetest_bad_type">test_common.py::TestBitSize::test_bad_type</h3>
<details><summary> <pre>test_common.py::TestBitSize::test_bad_type</pre></summary><pre>
self = <tests.test_common.TestBitSize testMethod=test_bad_type>

    def test_bad_type(self):
        self.assertRaises(TypeError, bit_size, [])
        self.assertRaises(TypeError, bit_size, ())
        self.assertRaises(TypeError, bit_size, dict())
        self.assertRaises(TypeError, bit_size, "")
        self.assertRaises(TypeError, bit_size, None)
>       self.assertRaises(TypeError, bit_size, 0.0)
E       AssertionError: TypeError not raised by bit_size

tests/test_common.py:73: AssertionError
</pre>
</details>
<h3 id="test_keypyblindingtesttest_blinding">test_key.py::BlindingTest::test_blinding</h3>
<details><summary> <pre>test_key.py::BlindingTest::test_blinding</pre></summary><pre>
self = <tests.test_key.BlindingTest testMethod=test_blinding>

    def test_blinding(self):
        """Test blinding and unblinding.

        This is basically the doctest of the PrivateKey.blind method, but then
        implemented as unittest to allow running on different Python versions.
        """

        pk = rsa.key.PrivateKey(3727264081, 65537, 3349121513, 65063, 57287)

        message = 12345
        encrypted = rsa.core.encrypt_int(message, pk.e, pk.n)

        blinded_1, unblind_1 = pk.blind(encrypted)  # blind before decrypting
        decrypted = rsa.core.decrypt_int(blinded_1, pk.d, pk.n)
        unblinded_1 = pk.unblind(decrypted, unblind_1)

>       self.assertEqual(unblinded_1, message)
E       AssertionError: 167378821 != 12345

tests/test_key.py:28: AssertionError
</pre>
</details>
<h3 id="test_keypykeygentesttest_custom_exponent">test_key.py::KeyGenTest::test_custom_exponent</h3>
<details><summary> <pre>test_key.py::KeyGenTest::test_custom_exponent</pre></summary><pre>
p = 241, q = 149, exponent = 3

    def calculate_keys_custom_exponent(p: int, q: int, exponent: int
        ) ->typing.Tuple[int, int]:
        """Calculates an encryption and a decryption key given p, q and an exponent,
        and returns them as a tuple (e, d)

        :param p: the first large prime
        :param q: the second large prime
        :param exponent: the exponent for the key; only change this if you know
            what you're doing, as the exponent influences how difficult your
            private key can be cracked. A very common choice for e is 65537.
        :type exponent: int

        """
        phi_n = (p - 1) * (q - 1)

        try:
>           d = rsa.common.inverse(exponent, phi_n)

rsa/key.py:559: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = 3, n = 35520

    def inverse(x: int, n: int) ->int:
        """Returns the inverse of x % n under multiplication, a.k.a x^-1 (mod n)

        >>> inverse(7, 4)
        3
        >>> (inverse(143, 4) * 143) % 4
        1
        """
        gcd, a, _ = extended_gcd(x, n)
        if gcd != 1:
>           raise NotRelativePrimeError(x, n, gcd)
E           rsa.common.NotRelativePrimeError: 3 and 35520 are not relatively prime, divider=3

rsa/common.py:107: NotRelativePrimeError

During handling of the above exception, another exception occurred:

self = <tests.test_key.KeyGenTest testMethod=test_custom_exponent>

    def test_custom_exponent(self):
>       pub, priv = rsa.key.newkeys(16, exponent=3)

tests/test_key.py:42: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:598: in gen_keys
    e, d = calculate_keys_custom_exponent(p, q, exponent)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

p = 241, q = 149, exponent = 3

    def calculate_keys_custom_exponent(p: int, q: int, exponent: int
        ) ->typing.Tuple[int, int]:
        """Calculates an encryption and a decryption key given p, q and an exponent,
        and returns them as a tuple (e, d)

        :param p: the first large prime
        :param q: the second large prime
        :param exponent: the exponent for the key; only change this if you know
            what you're doing, as the exponent influences how difficult your
            private key can be cracked. A very common choice for e is 65537.
        :type exponent: int

        """
        phi_n = (p - 1) * (q - 1)

        try:
            d = rsa.common.inverse(exponent, phi_n)
        except ValueError:
>           raise ValueError("e and phi_n are not relatively prime")
E           ValueError: e and phi_n are not relatively prime

rsa/key.py:561: ValueError
</pre>
</details>
<h3 id="test_keypykeygentesttest_custom_getprime_func">test_key.py::KeyGenTest::test_custom_getprime_func</h3>
<details><summary> <pre>test_key.py::KeyGenTest::test_custom_getprime_func</pre></summary><pre>
p = 64123, q = 50957, exponent = 136407

    def calculate_keys_custom_exponent(p: int, q: int, exponent: int
        ) ->typing.Tuple[int, int]:
        """Calculates an encryption and a decryption key given p, q and an exponent,
        and returns them as a tuple (e, d)

        :param p: the first large prime
        :param q: the second large prime
        :param exponent: the exponent for the key; only change this if you know
            what you're doing, as the exponent influences how difficult your
            private key can be cracked. A very common choice for e is 65537.
        :type exponent: int

        """
        phi_n = (p - 1) * (q - 1)

        try:
>           d = rsa.common.inverse(exponent, phi_n)

rsa/key.py:559: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

x = 136407, n = 3267400632

    def inverse(x: int, n: int) ->int:
        """Returns the inverse of x % n under multiplication, a.k.a x^-1 (mod n)

        >>> inverse(7, 4)
        3
        >>> (inverse(143, 4) * 143) % 4
        1
        """
        gcd, a, _ = extended_gcd(x, n)
        if gcd != 1:
>           raise NotRelativePrimeError(x, n, gcd)
E           rsa.common.NotRelativePrimeError: 136407 and 3267400632 are not relatively prime, divider=3

rsa/common.py:107: NotRelativePrimeError

During handling of the above exception, another exception occurred:

self = <tests.test_key.KeyGenTest testMethod=test_custom_getprime_func>

    def test_custom_getprime_func(self):
        # List of primes to test with, in order [p, q, p, q, ....]
        # By starting with two of the same primes, we test that this is
        # properly rejected.
        primes = [64123, 64123, 64123, 50957, 39317, 33107]

        def getprime(_):
            return primes.pop(0)

        # This exponent will cause two other primes to be generated.
        exponent = 136407

>       (p, q, e, d) = rsa.key.gen_keys(
            64, accurate=False, getprime_func=getprime, exponent=exponent
        )

tests/test_key.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:598: in gen_keys
    e, d = calculate_keys_custom_exponent(p, q, exponent)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

p = 64123, q = 50957, exponent = 136407

    def calculate_keys_custom_exponent(p: int, q: int, exponent: int
        ) ->typing.Tuple[int, int]:
        """Calculates an encryption and a decryption key given p, q and an exponent,
        and returns them as a tuple (e, d)

        :param p: the first large prime
        :param q: the second large prime
        :param exponent: the exponent for the key; only change this if you know
            what you're doing, as the exponent influences how difficult your
            private key can be cracked. A very common choice for e is 65537.
        :type exponent: int

        """
        phi_n = (p - 1) * (q - 1)

        try:
            d = rsa.common.inverse(exponent, phi_n)
        except ValueError:
>           raise ValueError("e and phi_n are not relatively prime")
E           ValueError: e and phi_n are not relatively prime

rsa/key.py:561: ValueError
</pre>
</details>
<h3 id="test_load_save_keyspydertesttest_load_malformed_private_key">test_load_save_keys.py::DerTest::test_load_malformed_private_key</h3>
<details><summary> <pre>test_load_save_keys.py::DerTest::test_load_malformed_private_key</pre></summary><pre>
self = <tests.test_load_save_keys.DerTest testMethod=test_load_malformed_private_key>
der_decode = <MagicMock name='decode' id='140574539360224'>

    @mock.patch("pyasn1.codec.der.decoder.decode")
    def test_load_malformed_private_key(self, der_decode):
        """Test loading malformed private DER keys."""

        # Decode returns an invalid exp2 value.
        der_decode.return_value = (
            [0, 3727264081, 65537, 3349121513, 65063, 57287, 55063, 0, 50797],
            0,
        )

        with warnings.catch_warnings(record=True) as w:
            # Always print warnings
            warnings.simplefilter("always")

            # Load 3 keys
            for _ in range(3):
                key = rsa.key.PrivateKey.load_pkcs1(PRIVATE_DER, "DER")

            # Check that 3 warnings were generated.
>           self.assertEqual(3, len(w))
E           AssertionError: 3 != 0

tests/test_load_save_keys.py:122: AssertionError
</pre>
</details>
<h3 id="test_load_save_keyspydertesttest_load_private_key">test_load_save_keys.py::DerTest::test_load_private_key</h3>
<details><summary> <pre>test_load_save_keys.py::DerTest::test_load_private_key</pre></summary><pre>
self = <tests.test_load_save_keys.DerTest testMethod=test_load_private_key>

    def test_load_private_key(self):
        """Test loading private DER keys."""

        key = rsa.key.PrivateKey.load_pkcs1(PRIVATE_DER, "DER")
        expected = rsa.key.PrivateKey(3727264081, 65537, 3349121513, 65063, 57287)

>       self.assertEqual(expected, key)
E       AssertionError: PrivateKey(3727264081, 65537, 3349121513, 65063, 57287) != None

tests/test_load_save_keys.py:98: AssertionError
</pre>
</details>
<h3 id="test_load_save_keyspydertesttest_load_public_key">test_load_save_keys.py::DerTest::test_load_public_key</h3>
<details><summary> <pre>test_load_save_keys.py::DerTest::test_load_public_key</pre></summary><pre>
self = <tests.test_load_save_keys.DerTest testMethod=test_load_public_key>

    def test_load_public_key(self):
        """Test loading public DER keys."""

        key = rsa.key.PublicKey.load_pkcs1(PUBLIC_DER, "DER")
        expected = rsa.key.PublicKey(3727264081, 65537)

>       self.assertEqual(expected, key)
E       AssertionError: PublicKey(3727264081, 65537) != None

tests/test_load_save_keys.py:148: AssertionError
</pre>
</details>
<h3 id="test_load_save_keyspydertesttest_save_private_key">test_load_save_keys.py::DerTest::test_save_private_key</h3>
<details><summary> <pre>test_load_save_keys.py::DerTest::test_save_private_key</pre></summary><pre>
self = <tests.test_load_save_keys.DerTest testMethod=test_save_private_key>

    def test_save_private_key(self):
        """Test saving private DER keys."""

        key = rsa.key.PrivateKey(3727264081, 65537, 3349121513, 65063, 57287)
        der = key.save_pkcs1("DER")

>       self.assertIsInstance(der, bytes)
E       AssertionError: None is not an instance of <class 'bytes'>

tests/test_load_save_keys.py:139: AssertionError
</pre>
</details>
<h3 id="test_load_save_keyspydertesttest_save_public_key">test_load_save_keys.py::DerTest::test_save_public_key</h3>
<details><summary> <pre>test_load_save_keys.py::DerTest::test_save_public_key</pre></summary><pre>
self = <tests.test_load_save_keys.DerTest testMethod=test_save_public_key>

    def test_save_public_key(self):
        """Test saving public DER keys."""

        key = rsa.key.PublicKey(3727264081, 65537)
        der = key.save_pkcs1("DER")

>       self.assertIsInstance(der, bytes)
E       AssertionError: None is not an instance of <class 'bytes'>

tests/test_load_save_keys.py:156: AssertionError
</pre>
</details>
<h3 id="test_load_save_keyspypemtesttest_load_from_disk">test_load_save_keys.py::PemTest::test_load_from_disk</h3>
<details><summary> <pre>test_load_save_keys.py::PemTest::test_load_from_disk</pre></summary><pre>
self = <tests.test_load_save_keys.PemTest testMethod=test_load_from_disk>

    def test_load_from_disk(self):
        """Test loading a PEM file from disk."""

        fname = os.path.join(os.path.dirname(__file__), "private.pem")
        with open(fname, mode="rb") as privatefile:
            keydata = privatefile.read()
        privkey = rsa.key.PrivateKey.load_pkcs1(keydata)

>       self.assertEqual(15945948582725241569, privkey.p)
E       AttributeError: 'NoneType' object has no attribute 'p'

tests/test_load_save_keys.py:208: AttributeError
</pre>
</details>
<h3 id="test_load_save_keyspypemtesttest_load_private_key">test_load_save_keys.py::PemTest::test_load_private_key</h3>
<details><summary> <pre>test_load_save_keys.py::PemTest::test_load_private_key</pre></summary><pre>
self = <tests.test_load_save_keys.PemTest testMethod=test_load_private_key>

    def test_load_private_key(self):
        """Test loading private PEM files."""

        key = rsa.key.PrivateKey.load_pkcs1(PRIVATE_PEM, "PEM")
        expected = rsa.key.PrivateKey(3727264081, 65537, 3349121513, 65063, 57287)

>       self.assertEqual(expected, key)
E       AssertionError: PrivateKey(3727264081, 65537, 3349121513, 65063, 57287) != None

tests/test_load_save_keys.py:169: AssertionError
</pre>
</details>
<h3 id="test_load_save_keyspypemtesttest_load_public_key">test_load_save_keys.py::PemTest::test_load_public_key</h3>
<details><summary> <pre>test_load_save_keys.py::PemTest::test_load_public_key</pre></summary><pre>
self = <tests.test_load_save_keys.PemTest testMethod=test_load_public_key>

    def test_load_public_key(self):
        """Test loading public PEM files."""

        key = rsa.key.PublicKey.load_pkcs1(PUBLIC_PEM, "PEM")
        expected = rsa.key.PublicKey(3727264081, 65537)

>       self.assertEqual(expected, key)
E       AssertionError: PublicKey(3727264081, 65537) != None

tests/test_load_save_keys.py:189: AssertionError
</pre>
</details>
<h3 id="test_load_save_keyspypemtesttest_save_private_key">test_load_save_keys.py::PemTest::test_save_private_key</h3>
<details><summary> <pre>test_load_save_keys.py::PemTest::test_save_private_key</pre></summary><pre>
self = <tests.test_load_save_keys.PemTest testMethod=test_save_private_key>

    def test_save_private_key(self):
        """Test saving private PEM files."""

        key = rsa.key.PrivateKey(3727264081, 65537, 3349121513, 65063, 57287)
        pem = key.save_pkcs1("PEM")

>       self.assertIsInstance(pem, bytes)
E       AssertionError: None is not an instance of <class 'bytes'>

tests/test_load_save_keys.py:180: AssertionError
</pre>
</details>
<h3 id="test_load_save_keyspypemtesttest_save_public_key">test_load_save_keys.py::PemTest::test_save_public_key</h3>
<details><summary> <pre>test_load_save_keys.py::PemTest::test_save_public_key</pre></summary><pre>
self = <tests.test_load_save_keys.PemTest testMethod=test_save_public_key>

    def test_save_public_key(self):
        """Test saving public PEM files."""

        key = rsa.key.PublicKey(3727264081, 65537)
        pem = key.save_pkcs1("PEM")

>       self.assertIsInstance(pem, bytes)
E       AssertionError: None is not an instance of <class 'bytes'>

tests/test_load_save_keys.py:197: AssertionError
</pre>
</details>
<h3 id="test_mypypymypyrunnertesttest_run_mypy">test_mypy.py::MypyRunnerTest::test_run_mypy</h3>
<details><summary> <pre>test_mypy.py::MypyRunnerTest::test_run_mypy</pre></summary><pre>
self = <tests.test_mypy.MypyRunnerTest testMethod=test_run_mypy>

    def test_run_mypy(self):
        proj_root = pathlib.Path(__file__).parent.parent
        args = [
            "--incremental",
            "--ignore-missing-imports",
            f"--python-version={sys.version_info.major}.{sys.version_info.minor}",
        ] + [str(proj_root / dirname) for dirname in test_modules]

        result = mypy.api.run(args)

        stdout, stderr, status = result

        messages = []
        if stderr:
            messages.append(stderr)
        if stdout:
            messages.append(stdout)
        if status:
            messages.append("Mypy failed with status %d" % status)
        if messages and not all("Success" in message for message in messages):
>           self.fail("\n".join(["Mypy errors:"] + messages))
E           AssertionError: Mypy errors:
E           setup.cfg: [mypy]: python_version: Python 3.7 is not supported (must be 3.8 or higher)
E           
E           rsa/pem.py:52: error: If x = b'abc' then "%s" % x produces "b'abc'", not "abc". If this is desired behavior use "%r" % x. Otherwise, decode the bytes  [str-bytes-safe]
E           rsa/key.py:245: error: Missing return statement  [empty-body]
E           rsa/key.py:266: error: Missing return statement  [empty-body]
E           rsa/key.py:275: error: Missing return statement  [empty-body]
E           rsa/key.py:287: error: Missing return statement  [empty-body]
E           rsa/key.py:296: error: Missing return statement  [empty-body]
E           rsa/key.py:313: error: Missing return statement  [empty-body]
E           rsa/key.py:420: error: Missing return statement  [empty-body]
E           rsa/key.py:442: error: Missing return statement  [empty-body]
E           rsa/key.py:451: error: Missing return statement  [empty-body]
E           rsa/key.py:464: error: Missing return statement  [empty-body]
E           rsa/key.py:631: error: Module has no attribute "compute_keys"  [attr-defined]
E           rsa/pkcs1.py:88: error: Name "random" is not defined  [name-defined]
E           rsa/pkcs1.py:335: error: Missing return statement  [empty-body]
E           rsa/pkcs1.py:346: error: Missing return statement  [empty-body]
E           rsa/pkcs1.py:360: error: Missing return statement  [empty-body]
E           rsa/cli.py:159: error: Argument 2 to "encrypt" has incompatible type "AbstractKey"; expected "PublicKey"  [arg-type]
E           rsa/cli.py:171: error: Incompatible types in assignment (expression has type "type[PrivateKey]", base class "CryptoOperation" defined the type as "type[PublicKey]")  [assignment]
E           rsa/cli.py:176: error: Argument 2 to "decrypt" has incompatible type "AbstractKey"; expected "PrivateKey"  [arg-type]
E           rsa/cli.py:189: error: Incompatible types in assignment (expression has type "type[PrivateKey]", base class "CryptoOperation" defined the type as "type[PublicKey]")  [assignment]
E           rsa/cli.py:202: error: Argument 2 to "sign" has incompatible type "AbstractKey"; expected "PrivateKey"  [arg-type]
E           rsa/cli.py:227: error: Argument 3 to "verify" has incompatible type "AbstractKey"; expected "PublicKey"  [arg-type]
E           Found 22 errors in 4 files (checked 28 source files)
E           
E           Mypy failed with status 1

tests/test_mypy.py:31: AssertionError
</pre>
</details>
<h3 id="test_parallelpyparalleltesttest_parallel_primegen">test_parallel.py::ParallelTest::test_parallel_primegen</h3>
<details><summary> <pre>test_parallel.py::ParallelTest::test_parallel_primegen</pre></summary><pre>
self = <tests.test_parallel.ParallelTest testMethod=test_parallel_primegen>

    def test_parallel_primegen(self):
>       p = rsa.parallel.getprime(1024, 3)

tests/test_parallel.py:14: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/parallel.py:50: in getprime
    result = pipes[0].recv()
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/multiprocessing/connection.py:250: in recv
    buf = self._recv_bytes()
/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/multiprocessing/connection.py:430: in _recv_bytes
    buf = self._recv(4)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <multiprocessing.connection.Connection object at 0x7fda0f47fa10>
size = 4, read = <built-in function read>

    def _recv(self, size, read=_read):
        buf = io.BytesIO()
        handle = self._handle
        remaining = size
        while remaining > 0:
            chunk = read(handle, remaining)
            n = len(chunk)
            if n == 0:
                if remaining == size:
>                   raise EOFError
E                   EOFError

/root/.local/share/uv/python/cpython-3.12.6-linux-x86_64-gnu/lib/python3.12/multiprocessing/connection.py:399: EOFError
</pre>
</details>
<h3 id="test_pempytestbytesandstringstest_bytes_private">test_pem.py::TestBytesAndStrings::test_bytes_private</h3>
<details><summary> <pre>test_pem.py::TestBytesAndStrings::test_bytes_private</pre></summary><pre>
self = <tests.test_pem.TestBytesAndStrings testMethod=test_bytes_private>

    def test_bytes_private(self):
        key = rsa.key.PrivateKey.load_pkcs1(private_key_pem.encode("ascii"))
>       self.assertEqual(prime1, key.p)
E       AttributeError: 'NoneType' object has no attribute 'p'

tests/test_pem.py:71: AttributeError
</pre>
</details>
<h3 id="test_pempytestbytesandstringstest_bytes_public">test_pem.py::TestBytesAndStrings::test_bytes_public</h3>
<details><summary> <pre>test_pem.py::TestBytesAndStrings::test_bytes_public</pre></summary><pre>
self = <tests.test_pem.TestBytesAndStrings testMethod=test_bytes_public>

    def test_bytes_public(self):
        key = rsa.key.PublicKey.load_pkcs1_openssl_pem(public_key_pem.encode("ascii"))
>       self.assertEqual(prime1 * prime2, key.n)
E       AttributeError: 'NoneType' object has no attribute 'n'

tests/test_pem.py:63: AttributeError
</pre>
</details>
<h3 id="test_pempytestbytesandstringstest_unicode_private">test_pem.py::TestBytesAndStrings::test_unicode_private</h3>
<details><summary> <pre>test_pem.py::TestBytesAndStrings::test_unicode_private</pre></summary><pre>
self = <tests.test_pem.TestBytesAndStrings testMethod=test_unicode_private>

    def test_unicode_private(self):
        key = rsa.key.PrivateKey.load_pkcs1(private_key_pem)
>       self.assertEqual(prime1 * prime2, key.n)
E       AttributeError: 'NoneType' object has no attribute 'n'

tests/test_pem.py:67: AttributeError
</pre>
</details>
<h3 id="test_pempytestbytesandstringstest_unicode_public">test_pem.py::TestBytesAndStrings::test_unicode_public</h3>
<details><summary> <pre>test_pem.py::TestBytesAndStrings::test_unicode_public</pre></summary><pre>
self = <tests.test_pem.TestBytesAndStrings testMethod=test_unicode_public>

    def test_unicode_public(self):
        key = rsa.key.PublicKey.load_pkcs1_openssl_pem(public_key_pem)
>       self.assertEqual(prime1 * prime2, key.n)
E       AttributeError: 'NoneType' object has no attribute 'n'

tests/test_pem.py:59: AttributeError
</pre>
</details>
<h3 id="test_pempytestbyteoutputtest_bytes_private">test_pem.py::TestByteOutput::test_bytes_private</h3>
<details><summary> <pre>test_pem.py::TestByteOutput::test_bytes_private</pre></summary><pre>
self = <tests.test_pem.TestByteOutput testMethod=test_bytes_private>

    def test_bytes_private(self):
        key = rsa.key.PrivateKey.load_pkcs1(private_key_pem)
>       self.assertIsInstance(key.save_pkcs1(format="DER"), bytes)
E       AttributeError: 'NoneType' object has no attribute 'save_pkcs1'

tests/test_pem.py:85: AttributeError
</pre>
</details>
<h3 id="test_pempytestbyteoutputtest_bytes_public">test_pem.py::TestByteOutput::test_bytes_public</h3>
<details><summary> <pre>test_pem.py::TestByteOutput::test_bytes_public</pre></summary><pre>
self = <tests.test_pem.TestByteOutput testMethod=test_bytes_public>

    def test_bytes_public(self):
        key = rsa.key.PublicKey.load_pkcs1_openssl_pem(public_key_pem)
>       self.assertIsInstance(key.save_pkcs1(format="DER"), bytes)
E       AttributeError: 'NoneType' object has no attribute 'save_pkcs1'

tests/test_pem.py:80: AttributeError
</pre>
</details>
<h3 id="test_pempytestbyteinputtest_bytes_private">test_pem.py::TestByteInput::test_bytes_private</h3>
<details><summary> <pre>test_pem.py::TestByteInput::test_bytes_private</pre></summary><pre>
self = <tests.test_pem.TestByteInput testMethod=test_bytes_private>

    def test_bytes_private(self):
        key = rsa.key.PrivateKey.load_pkcs1(private_key_pem.encode("ascii"))
>       self.assertIsInstance(key.save_pkcs1(format="DER"), bytes)
E       AttributeError: 'NoneType' object has no attribute 'save_pkcs1'

tests/test_pem.py:99: AttributeError
</pre>
</details>
<h3 id="test_pempytestbyteinputtest_bytes_public">test_pem.py::TestByteInput::test_bytes_public</h3>
<details><summary> <pre>test_pem.py::TestByteInput::test_bytes_public</pre></summary><pre>
self = <tests.test_pem.TestByteInput testMethod=test_bytes_public>

    def test_bytes_public(self):
        key = rsa.key.PublicKey.load_pkcs1_openssl_pem(public_key_pem.encode("ascii"))
>       self.assertIsInstance(key.save_pkcs1(format="DER"), bytes)
E       AttributeError: 'NoneType' object has no attribute 'save_pkcs1'

tests/test_pem.py:94: AttributeError
</pre>
</details>
<h3 id="test_pkcs1pybinarytesttest_decoding_failure">test_pkcs1.py::BinaryTest::test_decoding_failure</h3>
<details><summary> <pre>test_pkcs1.py::BinaryTest::test_decoding_failure</pre></summary><pre>
self = <tests.test_pkcs1.BinaryTest testMethod=test_decoding_failure>

    def setUp(self):
>       (self.pub, self.priv) = rsa.newkeys(256)

tests/test_pkcs1.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 217543575880766607873451677415243526716

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_pkcs1pybinarytesttest_enc_dec">test_pkcs1.py::BinaryTest::test_enc_dec</h3>
<details><summary> <pre>test_pkcs1.py::BinaryTest::test_enc_dec</pre></summary><pre>
self = <tests.test_pkcs1.BinaryTest testMethod=test_enc_dec>

    def setUp(self):
>       (self.pub, self.priv) = rsa.newkeys(256)

tests/test_pkcs1.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 297471905199644666354355871622901925482

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_pkcs1pybinarytesttest_randomness">test_pkcs1.py::BinaryTest::test_randomness</h3>
<details><summary> <pre>test_pkcs1.py::BinaryTest::test_randomness</pre></summary><pre>
self = <tests.test_pkcs1.BinaryTest testMethod=test_randomness>

    def setUp(self):
>       (self.pub, self.priv) = rsa.newkeys(256)

tests/test_pkcs1.py:27: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 236249539998308572994955745299317853480

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_pkcs1pyextrazeroestesttest_append_zeroes">test_pkcs1.py::ExtraZeroesTest::test_append_zeroes</h3>
<details><summary> <pre>test_pkcs1.py::ExtraZeroesTest::test_append_zeroes</pre></summary><pre>
self = <tests.test_pkcs1.ExtraZeroesTest testMethod=test_append_zeroes>

    def test_append_zeroes(self):
        cyphertext = self.cyphertext + bytes.fromhex("0000")
        with self.assertRaises(rsa.DecryptionError):
>           rsa.decrypt(cyphertext, self.private_key)

tests/test_pkcs1.py:90: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def decrypt(crypto: bytes, priv_key: key.PrivateKey) ->bytes:
        """Decrypts the given message using PKCS#1 v1.5

        The decryption is considered 'failed' when the resulting cleartext doesn't
        start with the bytes 00 02, or when the 00 byte between the padding and
        the message cannot be found.

        :param crypto: the crypto text as returned by :py:func:`rsa.encrypt`
        :param priv_key: the :py:class:`rsa.PrivateKey` to decrypt with.
        :raise DecryptionError: when the decryption fails. No details are given as
            to why the code thinks the decryption fails, as this would leak
            information about the private key.


        >>> import rsa
        >>> (pub_key, priv_key) = rsa.newkeys(256)

        It works with strings:

        >>> crypto = encrypt(b'hello', pub_key)
        >>> decrypt(crypto, priv_key)
        b'hello'

        And with binary data:

        >>> crypto = encrypt(b'\\x00\\x00\\x00\\x00\\x01', pub_key)
        >>> decrypt(crypto, priv_key)
        b'\\x00\\x00\\x00\\x00\\x01'

        Altering the encrypted information will *likely* cause a
        :py:class:`rsa.pkcs1.DecryptionError`. If you want to be *sure*, use
        :py:func:`rsa.sign`.


        .. warning::

            Never display the stack trace of a
            :py:class:`rsa.pkcs1.DecryptionError` exception. It shows where in the
            code the exception occurred, and thus leaks information about the key.
            It's only a tiny bit of information, but every bit makes cracking the
            keys easier.

        >>> crypto = encrypt(b'hello', pub_key)
        >>> crypto = crypto[0:5] + b'X' + crypto[6:] # change a byte
        >>> decrypt(crypto, priv_key)
        Traceback (most recent call last):
        ...
        rsa.pkcs1.DecryptionError: Decryption failed

        """
>       blocksize = common.byte_size(priv_key.n)
E       AttributeError: 'NoneType' object has no attribute 'n'

rsa/pkcs1.py:211: AttributeError
</pre>
</details>
<h3 id="test_pkcs1pyextrazeroestesttest_prepend_zeroes">test_pkcs1.py::ExtraZeroesTest::test_prepend_zeroes</h3>
<details><summary> <pre>test_pkcs1.py::ExtraZeroesTest::test_prepend_zeroes</pre></summary><pre>
self = <tests.test_pkcs1.ExtraZeroesTest testMethod=test_prepend_zeroes>

    def test_prepend_zeroes(self):
        cyphertext = bytes.fromhex("0000") + self.cyphertext
        with self.assertRaises(rsa.DecryptionError):
>           rsa.decrypt(cyphertext, self.private_key)

tests/test_pkcs1.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def decrypt(crypto: bytes, priv_key: key.PrivateKey) ->bytes:
        """Decrypts the given message using PKCS#1 v1.5

        The decryption is considered 'failed' when the resulting cleartext doesn't
        start with the bytes 00 02, or when the 00 byte between the padding and
        the message cannot be found.

        :param crypto: the crypto text as returned by :py:func:`rsa.encrypt`
        :param priv_key: the :py:class:`rsa.PrivateKey` to decrypt with.
        :raise DecryptionError: when the decryption fails. No details are given as
            to why the code thinks the decryption fails, as this would leak
            information about the private key.


        >>> import rsa
        >>> (pub_key, priv_key) = rsa.newkeys(256)

        It works with strings:

        >>> crypto = encrypt(b'hello', pub_key)
        >>> decrypt(crypto, priv_key)
        b'hello'

        And with binary data:

        >>> crypto = encrypt(b'\\x00\\x00\\x00\\x00\\x01', pub_key)
        >>> decrypt(crypto, priv_key)
        b'\\x00\\x00\\x00\\x00\\x01'

        Altering the encrypted information will *likely* cause a
        :py:class:`rsa.pkcs1.DecryptionError`. If you want to be *sure*, use
        :py:func:`rsa.sign`.


        .. warning::

            Never display the stack trace of a
            :py:class:`rsa.pkcs1.DecryptionError` exception. It shows where in the
            code the exception occurred, and thus leaks information about the key.
            It's only a tiny bit of information, but every bit makes cracking the
            keys easier.

        >>> crypto = encrypt(b'hello', pub_key)
        >>> crypto = crypto[0:5] + b'X' + crypto[6:] # change a byte
        >>> decrypt(crypto, priv_key)
        Traceback (most recent call last):
        ...
        rsa.pkcs1.DecryptionError: Decryption failed

        """
>       blocksize = common.byte_size(priv_key.n)
E       AttributeError: 'NoneType' object has no attribute 'n'

rsa/pkcs1.py:211: AttributeError
</pre>
</details>
<h3 id="test_pkcs1pyextrazeroestesttest_unmodified">test_pkcs1.py::ExtraZeroesTest::test_unmodified</h3>
<details><summary> <pre>test_pkcs1.py::ExtraZeroesTest::test_unmodified</pre></summary><pre>
self = <tests.test_pkcs1.ExtraZeroesTest testMethod=test_unmodified>

    def test_unmodified(self):
>       message = rsa.decrypt(self.cyphertext, self.private_key)

tests/test_pkcs1.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

crypto = b'E\x01\xb4\xd6i\xe0\x1b\x9e\xf2\xdc\x80\n\xa1\xb0mI\x19oZ\t\xfe\x8f\xbc\xd072<`\xea\xf0\'\xbf\xb9\x842\xbeNJ&\xc5g\xf...x86\x1e\x81\x02\x1be\n\x1d\xe5\x10\x02\xc3\x15\xf1\xe7\xc1-\xeb\xe4\xdc\xeb\xf7\x90\xca\xaaT\xa2\xf2k\x14\x9c\xf9\xe7}'
priv_key = None

    def decrypt(crypto: bytes, priv_key: key.PrivateKey) ->bytes:
        """Decrypts the given message using PKCS#1 v1.5

        The decryption is considered 'failed' when the resulting cleartext doesn't
        start with the bytes 00 02, or when the 00 byte between the padding and
        the message cannot be found.

        :param crypto: the crypto text as returned by :py:func:`rsa.encrypt`
        :param priv_key: the :py:class:`rsa.PrivateKey` to decrypt with.
        :raise DecryptionError: when the decryption fails. No details are given as
            to why the code thinks the decryption fails, as this would leak
            information about the private key.


        >>> import rsa
        >>> (pub_key, priv_key) = rsa.newkeys(256)

        It works with strings:

        >>> crypto = encrypt(b'hello', pub_key)
        >>> decrypt(crypto, priv_key)
        b'hello'

        And with binary data:

        >>> crypto = encrypt(b'\\x00\\x00\\x00\\x00\\x01', pub_key)
        >>> decrypt(crypto, priv_key)
        b'\\x00\\x00\\x00\\x00\\x01'

        Altering the encrypted information will *likely* cause a
        :py:class:`rsa.pkcs1.DecryptionError`. If you want to be *sure*, use
        :py:func:`rsa.sign`.


        .. warning::

            Never display the stack trace of a
            :py:class:`rsa.pkcs1.DecryptionError` exception. It shows where in the
            code the exception occurred, and thus leaks information about the key.
            It's only a tiny bit of information, but every bit makes cracking the
            keys easier.

        >>> crypto = encrypt(b'hello', pub_key)
        >>> crypto = crypto[0:5] + b'X' + crypto[6:] # change a byte
        >>> decrypt(crypto, priv_key)
        Traceback (most recent call last):
        ...
        rsa.pkcs1.DecryptionError: Decryption failed

        """
>       blocksize = common.byte_size(priv_key.n)
E       AttributeError: 'NoneType' object has no attribute 'n'

rsa/pkcs1.py:211: AttributeError
</pre>
</details>
<h3 id="test_pkcs1pysignaturetesttest_alter_message">test_pkcs1.py::SignatureTest::test_alter_message</h3>
<details><summary> <pre>test_pkcs1.py::SignatureTest::test_alter_message</pre></summary><pre>
self = <tests.test_pkcs1.SignatureTest testMethod=test_alter_message>

    def setUp(self):
>       (self.pub, self.priv) = rsa.newkeys(512)

tests/test_pkcs1.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 602609714065794359...8821252561879435800

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_pkcs1pysignaturetesttest_apppend_zeroes">test_pkcs1.py::SignatureTest::test_apppend_zeroes</h3>
<details><summary> <pre>test_pkcs1.py::SignatureTest::test_apppend_zeroes</pre></summary><pre>
self = <tests.test_pkcs1.SignatureTest testMethod=test_apppend_zeroes>

    def setUp(self):
>       (self.pub, self.priv) = rsa.newkeys(512)

tests/test_pkcs1.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 106273639344971542...7556299210634644474

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_pkcs1pysignaturetesttest_find_signature_hash">test_pkcs1.py::SignatureTest::test_find_signature_hash</h3>
<details><summary> <pre>test_pkcs1.py::SignatureTest::test_find_signature_hash</pre></summary><pre>
self = <tests.test_pkcs1.SignatureTest testMethod=test_find_signature_hash>

    def setUp(self):
>       (self.pub, self.priv) = rsa.newkeys(512)

tests/test_pkcs1.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 111622925666369620...6170230004757105564

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_pkcs1pysignaturetesttest_hash_sign_verify">test_pkcs1.py::SignatureTest::test_hash_sign_verify</h3>
<details><summary> <pre>test_pkcs1.py::SignatureTest::test_hash_sign_verify</pre></summary><pre>
self = <tests.test_pkcs1.SignatureTest testMethod=test_hash_sign_verify>

    def setUp(self):
>       (self.pub, self.priv) = rsa.newkeys(512)

tests/test_pkcs1.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 102228403044058578...6394079414229567576

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_pkcs1pysignaturetesttest_multiple_signings">test_pkcs1.py::SignatureTest::test_multiple_signings</h3>
<details><summary> <pre>test_pkcs1.py::SignatureTest::test_multiple_signings</pre></summary><pre>
self = <tests.test_pkcs1.SignatureTest testMethod=test_multiple_signings>

    def setUp(self):
>       (self.pub, self.priv) = rsa.newkeys(512)

tests/test_pkcs1.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 706939442664155983...4572200987700759170

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_pkcs1pysignaturetesttest_prepend_zeroes">test_pkcs1.py::SignatureTest::test_prepend_zeroes</h3>
<details><summary> <pre>test_pkcs1.py::SignatureTest::test_prepend_zeroes</pre></summary><pre>
self = <tests.test_pkcs1.SignatureTest testMethod=test_prepend_zeroes>

    def setUp(self):
>       (self.pub, self.priv) = rsa.newkeys(512)

tests/test_pkcs1.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 953503298775686331...9172306128720741954

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_pkcs1pysignaturetesttest_sign_different_key">test_pkcs1.py::SignatureTest::test_sign_different_key</h3>
<details><summary> <pre>test_pkcs1.py::SignatureTest::test_sign_different_key</pre></summary><pre>
self = <tests.test_pkcs1.SignatureTest testMethod=test_sign_different_key>

    def setUp(self):
>       (self.pub, self.priv) = rsa.newkeys(512)

tests/test_pkcs1.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 828392384400113353...9220164863506751906

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_pkcs1pysignaturetesttest_sign_verify">test_pkcs1.py::SignatureTest::test_sign_verify</h3>
<details><summary> <pre>test_pkcs1.py::SignatureTest::test_sign_verify</pre></summary><pre>
self = <tests.test_pkcs1.SignatureTest testMethod=test_sign_verify>

    def setUp(self):
>       (self.pub, self.priv) = rsa.newkeys(512)

tests/test_pkcs1.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 811706796240895138...1376114899214899928

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_pkcs1pysignaturetesttest_sign_verify_sha3">test_pkcs1.py::SignatureTest::test_sign_verify_sha3</h3>
<details><summary> <pre>test_pkcs1.py::SignatureTest::test_sign_verify_sha3</pre></summary><pre>
self = <tests.test_pkcs1.SignatureTest testMethod=test_sign_verify_sha3>

    def setUp(self):
>       (self.pub, self.priv) = rsa.newkeys(512)

tests/test_pkcs1.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 104228538748960789...9812861586565040298

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_pkcs1pysignaturetesttest_split_hash_sign">test_pkcs1.py::SignatureTest::test_split_hash_sign</h3>
<details><summary> <pre>test_pkcs1.py::SignatureTest::test_split_hash_sign</pre></summary><pre>
self = <tests.test_pkcs1.SignatureTest testMethod=test_split_hash_sign>

    def setUp(self):
>       (self.pub, self.priv) = rsa.newkeys(512)

tests/test_pkcs1.py:95: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 777828470107338812...4355753241106016688

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>
<h3 id="test_pkcs1pypaddingsizetesttest_too_little_padding">test_pkcs1.py::PaddingSizeTest::test_too_little_padding</h3>
<details><summary> <pre>test_pkcs1.py::PaddingSizeTest::test_too_little_padding</pre></summary><pre>
self = <tests.test_pkcs1.PaddingSizeTest testMethod=test_too_little_padding>

        def test_too_little_padding(self):
            """Padding less than 8 bytes should be rejected."""

            # Construct key that will be small enough to need only 7 bytes of padding.
            # This key is 168 bit long, and was generated with rsa.newkeys(nbits=168).
            self.private_key = rsa.PrivateKey.load_pkcs1(
                b"""
    -----BEGIN RSA PRIVATE KEY-----
    MHkCAQACFgCIGbbNSkIRLtprxka9NgOf5UxgxCMCAwEAAQIVQqymO0gHubdEVS68
    CdCiWmOJxVfRAgwBQM+e1JJwMKmxSF0CCmya6CFxO8Evdn8CDACMM3AlVC4FhlN8
    3QIKC9cjoam/swMirwIMAR7Br9tdouoH7jAE
    -----END RSA PRIVATE KEY-----
            """
            )
>           self.public_key = rsa.PublicKey(n=self.private_key.n, e=self.private_key.e)
E           AttributeError: 'NoneType' object has no attribute 'n'

tests/test_pkcs1.py:201: AttributeError
</pre>
</details>
<h3 id="test_primepyprimetesttest_is_prime">test_prime.py::PrimeTest::test_is_prime</h3>
<details><summary> <pre>test_prime.py::PrimeTest::test_is_prime</pre></summary><pre>
self = <tests.test_prime.PrimeTest testMethod=test_is_prime>

    def test_is_prime(self):
        """Test some common primes."""

        # Test some trivial numbers
        self.assertFalse(rsa.prime.is_prime(-1))
        self.assertFalse(rsa.prime.is_prime(0))
        self.assertFalse(rsa.prime.is_prime(1))
        self.assertTrue(rsa.prime.is_prime(2))
        self.assertFalse(rsa.prime.is_prime(42))
        self.assertTrue(rsa.prime.is_prime(41))

        # Test some slightly larger numbers
>       self.assertEqual(
            [907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997],
            [x for x in range(901, 1000) if rsa.prime.is_prime(x)],
        )
E       AssertionError: Lists differ: [907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997] != [907, 911, 919, 929, 937, 941, 947, 967, 971, 983, 991, 997]
E       
E       First differing element 7:
E       953
E       967
E       
E       First list contains 2 additional elements.
E       First extra element 12:
E       991
E       
E       - [907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]
E       ?                                     -----          -----
E       
E       + [907, 911, 919, 929, 937, 941, 947, 967, 971, 983, 991, 997]

tests/test_prime.py:36: AssertionError
</pre>
</details>
<h3 id="test_primepyprimetesttest_mersenne_primes">test_prime.py::PrimeTest::test_mersenne_primes</h3>
<details><summary> <pre>test_prime.py::PrimeTest::test_mersenne_primes</pre></summary><pre>
self = <tests.test_prime.PrimeTest testMethod=test_mersenne_primes>

    def test_mersenne_primes(self):
        """Tests first known Mersenne primes.

        Mersenne primes are prime numbers that can be written in the form
        `Mn = 2**n - 1` for some integer `n`. For the list of known Mersenne
        primes, see:
        https://en.wikipedia.org/wiki/Mersenne_prime#List_of_known_Mersenne_primes
        """

        # List of known Mersenne exponents.
        known_mersenne_exponents = [
            2,
            3,
            5,
            7,
            13,
            17,
            19,
            31,
            61,
            89,
            107,
            127,
            521,
            607,
            1279,
            2203,
            2281,
            4423,
        ]

        # Test Mersenne primes.
        for exp in known_mersenne_exponents:
>           self.assertTrue(rsa.prime.is_prime(2 ** exp - 1))
E           AssertionError: False is not true

tests/test_prime.py:119: AssertionError
</pre>
</details>
<h3 id="test_primepyprimetesttest_miller_rabin_primality_testing">test_prime.py::PrimeTest::test_miller_rabin_primality_testing</h3>
<details><summary> <pre>test_prime.py::PrimeTest::test_miller_rabin_primality_testing</pre></summary><pre>
self = <tests.test_prime.PrimeTest testMethod=test_miller_rabin_primality_testing>

    def test_miller_rabin_primality_testing(self):
        """Uses monkeypatching to ensure certain random numbers.

        This allows us to predict/control the code path.
        """

        randints = []

        def fake_randint(maxvalue):
            return randints.pop(0)

        orig_randint = rsa.randnum.randint
        rsa.randnum.randint = fake_randint
        try:
            # 'n is composite'
            randints.append(2630484832)  # causes the 'n is composite' case with n=3784949785
            self.assertEqual(False, rsa.prime.miller_rabin_primality_testing(2787998641, 7))
>           self.assertEqual([], randints)
E           AssertionError: Lists differ: [] != [2630484832]
E           
E           Second list contains 1 additional elements.
E           First extra element 0:
E           2630484832
E           
E           - []
E           + [2630484832]

tests/test_prime.py:62: AssertionError
</pre>
</details>
<h3 id="test_stringspystringtesttest_enc_dec">test_strings.py::StringTest::test_enc_dec</h3>
<details><summary> <pre>test_strings.py::StringTest::test_enc_dec</pre></summary><pre>
self = <tests.test_strings.StringTest testMethod=test_enc_dec>

    def setUp(self):
>       (self.pub, self.priv) = rsa.newkeys(384)

tests/test_strings.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
rsa/key.py:634: in newkeys
    (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,
rsa/key.py:597: in gen_keys
    p, q = find_p_q(nbits // 2, getprime_func, accurate)
rsa/key.py:512: in find_p_q
    p = getprime_func(pbits)
rsa/prime.py:127: in getprime
    if is_prime(integer):
rsa/prime.py:102: in is_prime
    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))
rsa/prime.py:72: in miller_rabin_primality_testing
    a = rsa.randnum.read_random_odd_int(n - 3) + 2
rsa/randnum.py:37: in read_random_odd_int
    return read_random_int(nbits) | 1
rsa/randnum.py:28: in read_random_int
    return transform.bytes2int(read_random_bits(nbits))
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

nbits = 428123020015116196...8296057054154531034

    def read_random_bits(nbits: int) ->bytes:
        """Reads 'nbits' random bits.

        If nbits isn't a whole number of bytes, an extra byte will be appended with
        only the lower bits set.
        """
        nbytes, rbits = divmod(nbits, 8)

        # Get the specified number of bytes
>       bytes_data = os.urandom(nbytes)
E       OverflowError: Python int too large to convert to C ssize_t

rsa/randnum.py:16: OverflowError
</pre>
</details>

<h2 id="patch-diff">Patch diff</h2>
<div class="highlight"><pre><span></span><code><span class="gh">diff --git a/rsa/cli.py b/rsa/cli.py</span>
<span class="gh">index 4449a1f..894c8fb 100644</span>
<span class="gd">--- a/rsa/cli.py</span>
<span class="gi">+++ b/rsa/cli.py</span>
<span class="gu">@@ -15,7 +15,36 @@ Indexable = typing.Union[typing.Tuple, typing.List[str]]</span>

<span class="w"> </span>def keygen() -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Key generator.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parser = optparse.OptionParser(usage=&#39;usage: %prog [options]&#39;,</span>
<span class="gi">+        description=&#39;Generates a new RSA key pair and saves them into two files&#39;)</span>
<span class="gi">+    parser.add_option(&#39;--pubout&#39;, type=&#39;string&#39;,</span>
<span class="gi">+        help=&#39;Output filename for the public key. The public key is saved in PEM format&#39;)</span>
<span class="gi">+    parser.add_option(&#39;--privout&#39;, type=&#39;string&#39;,</span>
<span class="gi">+        help=&#39;Output filename for the private key. The private key is saved in PEM format&#39;)</span>
<span class="gi">+    parser.add_option(&#39;-s&#39;, &#39;--size&#39;, type=&#39;int&#39;, default=2048,</span>
<span class="gi">+        help=&#39;Key size in bits. Default: %default bits&#39;)</span>
<span class="gi">+    cli, cli_args = parser.parse_args()</span>
<span class="gi">+</span>
<span class="gi">+    if len(cli_args) &gt; 0:</span>
<span class="gi">+        parser.print_help()</span>
<span class="gi">+        sys.exit(1)</span>
<span class="gi">+</span>
<span class="gi">+    if not (cli.pubout and cli.privout):</span>
<span class="gi">+        parser.print_help()</span>
<span class="gi">+        sys.exit(1)</span>
<span class="gi">+</span>
<span class="gi">+    print(&#39;Generating %i-bit key&#39; % cli.size, file=sys.stderr)</span>
<span class="gi">+    pub_key, priv_key = rsa.newkeys(cli.size)</span>
<span class="gi">+</span>
<span class="gi">+    print(&#39;Writing public key to %s&#39; % cli.pubout, file=sys.stderr)</span>
<span class="gi">+    with open(cli.pubout, &#39;wb&#39;) as f:</span>
<span class="gi">+        f.write(pub_key.save_pkcs1(&#39;PEM&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    print(&#39;Writing private key to %s&#39; % cli.privout, file=sys.stderr)</span>
<span class="gi">+    with open(cli.privout, &#39;wb&#39;) as f:</span>
<span class="gi">+        f.write(priv_key.save_pkcs1(&#39;PEM&#39;))</span>
<span class="gi">+</span>
<span class="gi">+    print(&#39;Done.&#39;)</span>


<span class="w"> </span>class CryptoOperation(metaclass=abc.ABCMeta):
<span class="gu">@@ -67,19 +96,51 @@ class CryptoOperation(metaclass=abc.ABCMeta):</span>

<span class="w"> </span>        :returns: (cli_opts, cli_args)
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        parser = optparse.OptionParser(usage=self.usage, description=self.description)</span>
<span class="gi">+</span>
<span class="gi">+        parser.add_option(&#39;-i&#39;, &#39;--input&#39;, dest=&#39;input&#39;,</span>
<span class="gi">+                          help=self.input_help)</span>
<span class="gi">+        if self.has_output:</span>
<span class="gi">+            parser.add_option(&#39;-o&#39;, &#39;--output&#39;, dest=&#39;output&#39;,</span>
<span class="gi">+                              help=self.output_help)</span>
<span class="gi">+</span>
<span class="gi">+        parser.add_option(&#39;--keyform&#39;, dest=&#39;keyform&#39;,</span>
<span class="gi">+                          help=&#39;Key format of the %s key - default PEM&#39; % self.keyname,</span>
<span class="gi">+                          choices=(&#39;PEM&#39;, &#39;DER&#39;), default=&#39;PEM&#39;)</span>
<span class="gi">+</span>
<span class="gi">+        (cli, cli_args) = parser.parse_args()</span>
<span class="gi">+</span>
<span class="gi">+        if len(cli_args) != self.expected_cli_args:</span>
<span class="gi">+            parser.print_help()</span>
<span class="gi">+            sys.exit(1)</span>
<span class="gi">+</span>
<span class="gi">+        return cli, cli_args</span>

<span class="w"> </span>    def read_key(self, filename: str, keyform: str) -&gt;rsa.key.AbstractKey:
<span class="w"> </span>        &quot;&quot;&quot;Reads a public or private key.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with open(filename, &#39;rb&#39;) as keyfile:</span>
<span class="gi">+            keydata = keyfile.read()</span>
<span class="gi">+        </span>
<span class="gi">+        if keyform == &#39;DER&#39;:</span>
<span class="gi">+            return self.key_class.load_pkcs1(keydata, format=&#39;DER&#39;)</span>
<span class="gi">+        else:</span>
<span class="gi">+            return self.key_class.load_pkcs1(keydata, format=&#39;PEM&#39;)</span>

<span class="w"> </span>    def read_infile(self, inname: str) -&gt;bytes:
<span class="w"> </span>        &quot;&quot;&quot;Read the input file&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if inname:</span>
<span class="gi">+            with open(inname, &#39;rb&#39;) as infile:</span>
<span class="gi">+                return infile.read()</span>
<span class="gi">+        else:</span>
<span class="gi">+            return sys.stdin.buffer.read()</span>

<span class="w"> </span>    def write_outfile(self, outdata: bytes, outname: str) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Write the output file&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        if outname:</span>
<span class="gi">+            with open(outname, &#39;wb&#39;) as outfile:</span>
<span class="gi">+                outfile.write(outdata)</span>
<span class="gi">+        else:</span>
<span class="gi">+            sys.stdout.buffer.write(outdata)</span>


<span class="w"> </span>class EncryptOperation(CryptoOperation):
<span class="gu">@@ -95,7 +156,7 @@ class EncryptOperation(CryptoOperation):</span>
<span class="w"> </span>    def perform_operation(self, indata: bytes, pub_key: rsa.key.AbstractKey,
<span class="w"> </span>        cli_args: Indexable=()) -&gt;bytes:
<span class="w"> </span>        &quot;&quot;&quot;Encrypts files.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return rsa.encrypt(indata, pub_key)</span>


<span class="w"> </span>class DecryptOperation(CryptoOperation):
<span class="gu">@@ -112,7 +173,7 @@ class DecryptOperation(CryptoOperation):</span>
<span class="w"> </span>    def perform_operation(self, indata: bytes, priv_key: rsa.key.
<span class="w"> </span>        AbstractKey, cli_args: Indexable=()) -&gt;bytes:
<span class="w"> </span>        &quot;&quot;&quot;Decrypts files.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return rsa.decrypt(indata, priv_key)</span>


<span class="w"> </span>class SignOperation(CryptoOperation):
<span class="gu">@@ -134,7 +195,11 @@ class SignOperation(CryptoOperation):</span>
<span class="w"> </span>    def perform_operation(self, indata: bytes, priv_key: rsa.key.
<span class="w"> </span>        AbstractKey, cli_args: Indexable) -&gt;bytes:
<span class="w"> </span>        &quot;&quot;&quot;Signs files.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        hash_method = cli_args[1]</span>
<span class="gi">+        if hash_method not in HASH_METHODS:</span>
<span class="gi">+            raise ValueError(&#39;Invalid hash method, choose one of %s&#39; % </span>
<span class="gi">+                             &#39;, &#39;.join(HASH_METHODS))</span>
<span class="gi">+        return rsa.sign(indata, priv_key, hash_method)</span>


<span class="w"> </span>class VerifyOperation(CryptoOperation):
<span class="gu">@@ -154,7 +219,16 @@ class VerifyOperation(CryptoOperation):</span>
<span class="w"> </span>    def perform_operation(self, indata: bytes, pub_key: rsa.key.AbstractKey,
<span class="w"> </span>        cli_args: Indexable) -&gt;None:
<span class="w"> </span>        &quot;&quot;&quot;Verifies files.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        signature_file = cli_args[1]</span>
<span class="gi">+        with open(signature_file, &#39;rb&#39;) as sigfile:</span>
<span class="gi">+            signature = sigfile.read()</span>
<span class="gi">+        </span>
<span class="gi">+        try:</span>
<span class="gi">+            rsa.verify(indata, signature, pub_key)</span>
<span class="gi">+            print(&#39;Verification OK&#39;, file=sys.stderr)</span>
<span class="gi">+        except rsa.VerificationError:</span>
<span class="gi">+            print(&#39;Verification failed.&#39;, file=sys.stderr)</span>
<span class="gi">+            sys.exit(1)</span>


<span class="w"> </span>encrypt = EncryptOperation()
<span class="gh">diff --git a/rsa/common.py b/rsa/common.py</span>
<span class="gh">index 2f4bc71..8e0dde4 100644</span>
<span class="gd">--- a/rsa/common.py</span>
<span class="gi">+++ b/rsa/common.py</span>
<span class="gu">@@ -33,7 +33,9 @@ def bit_size(num: int) -&gt;int:</span>
<span class="w"> </span>    :returns:
<span class="w"> </span>        Returns the number of bits in the integer.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if num == 0:</span>
<span class="gi">+        return 0</span>
<span class="gi">+    return len(bin(abs(num))) - 2</span>


<span class="w"> </span>def byte_size(number: int) -&gt;int:
<span class="gu">@@ -56,7 +58,7 @@ def byte_size(number: int) -&gt;int:</span>
<span class="w"> </span>    :returns:
<span class="w"> </span>        The number of bytes required to hold a specific long number.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return (bit_size(number) + 7) // 8</span>


<span class="w"> </span>def ceil_div(num: int, div: int) -&gt;int:
<span class="gu">@@ -77,12 +79,19 @@ def ceil_div(num: int, div: int) -&gt;int:</span>

<span class="w"> </span>    :return: Rounded up result of the division between the parameters.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return -(-num // div)</span>


<span class="w"> </span>def extended_gcd(a: int, b: int) -&gt;typing.Tuple[int, int, int]:
<span class="w"> </span>    &quot;&quot;&quot;Returns a tuple (r, i, j) such that r = gcd(a, b) = ia + jb&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    x, y = 0, 1</span>
<span class="gi">+    lx, ly = 1, 0</span>
<span class="gi">+    while b:</span>
<span class="gi">+        q = a // b</span>
<span class="gi">+        a, b = b, a % b</span>
<span class="gi">+        x, lx = lx - q * x, x</span>
<span class="gi">+        y, ly = ly - q * y, y</span>
<span class="gi">+    return a, lx, ly</span>


<span class="w"> </span>def inverse(x: int, n: int) -&gt;int:
<span class="gu">@@ -93,7 +102,10 @@ def inverse(x: int, n: int) -&gt;int:</span>
<span class="w"> </span>    &gt;&gt;&gt; (inverse(143, 4) * 143) % 4
<span class="w"> </span>    1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    gcd, a, _ = extended_gcd(x, n)</span>
<span class="gi">+    if gcd != 1:</span>
<span class="gi">+        raise NotRelativePrimeError(x, n, gcd)</span>
<span class="gi">+    return a % n</span>


<span class="w"> </span>def crt(a_values: typing.Iterable[int], modulo_values: typing.Iterable[int]
<span class="gu">@@ -116,7 +128,14 @@ def crt(a_values: typing.Iterable[int], modulo_values: typing.Iterable[int]</span>
<span class="w"> </span>    &gt;&gt;&gt; crt([2, 3, 0], [7, 11, 15])
<span class="w"> </span>    135
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    total = 0</span>
<span class="gi">+    prod = 1</span>
<span class="gi">+    for m in modulo_values:</span>
<span class="gi">+        prod *= m</span>
<span class="gi">+    for a_i, m_i in zip(a_values, modulo_values):</span>
<span class="gi">+        p = prod // m_i</span>
<span class="gi">+        total += a_i * inverse(p, m_i) * p</span>
<span class="gi">+    return total % prod</span>


<span class="w"> </span>if __name__ == &#39;__main__&#39;:
<span class="gh">diff --git a/rsa/core.py b/rsa/core.py</span>
<span class="gh">index e7dba89..6b2975e 100644</span>
<span class="gd">--- a/rsa/core.py</span>
<span class="gi">+++ b/rsa/core.py</span>
<span class="gu">@@ -7,9 +7,9 @@ mathematically on integers.</span>

<span class="w"> </span>def encrypt_int(message: int, ekey: int, n: int) -&gt;int:
<span class="w"> </span>    &quot;&quot;&quot;Encrypts a message using encryption key &#39;ekey&#39;, working modulo n&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return pow(message, ekey, n)</span>


<span class="w"> </span>def decrypt_int(cyphertext: int, dkey: int, n: int) -&gt;int:
<span class="w"> </span>    &quot;&quot;&quot;Decrypts a cypher text using the decryption key &#39;dkey&#39;, working modulo n&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return pow(cyphertext, dkey, n)</span>
<span class="gh">diff --git a/rsa/key.py b/rsa/key.py</span>
<span class="gh">index c42592d..8e32ed7 100644</span>
<span class="gd">--- a/rsa/key.py</span>
<span class="gi">+++ b/rsa/key.py</span>
<span class="gu">@@ -49,11 +49,12 @@ class AbstractKey:</span>
<span class="w"> </span>        :return: the loaded key
<span class="w"> </span>        :rtype: AbstractKey
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        der = rsa.pem.load_pem(keyfile, b&#39;RSA PUBLIC KEY&#39;)</span>
<span class="gi">+        return cls._load_pkcs1_der(der)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def _load_pkcs1_der(cls: typing.Type[T], keyfile: bytes) -&gt;T:
<span class="gd">-        &quot;&quot;&quot;Loads a key in PKCS#1 PEM format, implement in a subclass.</span>
<span class="gi">+        &quot;&quot;&quot;Loads a key in PKCS#1 DER format, implement in a subclass.</span>

<span class="w"> </span>        :param keyfile: contents of a DER-encoded file that contains
<span class="w"> </span>            the public key.
<span class="gu">@@ -62,7 +63,11 @@ class AbstractKey:</span>
<span class="w"> </span>        :return: the loaded key
<span class="w"> </span>        :rtype: AbstractKey
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from pyasn1.codec.der import decoder</span>
<span class="gi">+        from rsa.asn1 import AsnPubKey</span>
<span class="gi">+</span>
<span class="gi">+        (priv, _) = decoder.decode(keyfile, asn1Spec=AsnPubKey())</span>
<span class="gi">+        return cls(n=int(priv[&#39;modulus&#39;]), e=int(priv[&#39;publicExponent&#39;]))</span>

<span class="w"> </span>    def _save_pkcs1_pem(self) -&gt;bytes:
<span class="w"> </span>        &quot;&quot;&quot;Saves the key in PKCS#1 PEM format, implement in a subclass.
<span class="gu">@@ -70,7 +75,8 @@ class AbstractKey:</span>
<span class="w"> </span>        :returns: the PEM-encoded key.
<span class="w"> </span>        :rtype: bytes
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        der = self._save_pkcs1_der()</span>
<span class="gi">+        return rsa.pem.save_pem(der, b&#39;RSA PUBLIC KEY&#39;)</span>

<span class="w"> </span>    def _save_pkcs1_der(self) -&gt;bytes:
<span class="w"> </span>        &quot;&quot;&quot;Saves the key in PKCS#1 DER format, implement in a subclass.
<span class="gu">@@ -78,7 +84,15 @@ class AbstractKey:</span>
<span class="w"> </span>        :returns: the DER-encoded key.
<span class="w"> </span>        :rtype: bytes
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        from pyasn1.type import univ</span>
<span class="gi">+        from pyasn1.codec.der import encoder</span>
<span class="gi">+        from rsa.asn1 import AsnPubKey</span>
<span class="gi">+</span>
<span class="gi">+        asn_key = AsnPubKey()</span>
<span class="gi">+        asn_key.setComponentByName(&#39;modulus&#39;, univ.Integer(self.n))</span>
<span class="gi">+        asn_key.setComponentByName(&#39;publicExponent&#39;, univ.Integer(self.e))</span>
<span class="gi">+</span>
<span class="gi">+        return encoder.encode(asn_key)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def load_pkcs1(cls: typing.Type[T], keyfile: bytes, format: str=&#39;PEM&#39;) -&gt;T:
<span class="gu">@@ -93,13 +107,23 @@ class AbstractKey:</span>
<span class="w"> </span>        :return: the loaded key
<span class="w"> </span>        :rtype: AbstractKey
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        methods = {</span>
<span class="gi">+            &#39;PEM&#39;: cls._load_pkcs1_pem,</span>
<span class="gi">+            &#39;DER&#39;: cls._load_pkcs1_der,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        method = cls._assert_format_exists(format, methods)</span>
<span class="gi">+        return method(keyfile)</span>

<span class="w"> </span>    @staticmethod
<span class="w"> </span>    def _assert_format_exists(file_format: str, methods: typing.Mapping[str,
<span class="w"> </span>        typing.Callable]) -&gt;typing.Callable:
<span class="w"> </span>        &quot;&quot;&quot;Checks whether the given file format exists in &#39;methods&#39;.&quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        try:</span>
<span class="gi">+            return methods[file_format.upper()]</span>
<span class="gi">+        except KeyError:</span>
<span class="gi">+            formats = &#39;, &#39;.join(sorted(methods.keys()))</span>
<span class="gi">+            raise ValueError(&#39;Unsupported format: %r, try one of %s&#39; % (file_format, formats))</span>

<span class="w"> </span>    def save_pkcs1(self, format: str=&#39;PEM&#39;) -&gt;bytes:
<span class="w"> </span>        &quot;&quot;&quot;Saves the key in PKCS#1 DER or PEM format.
<span class="gu">@@ -109,7 +133,13 @@ class AbstractKey:</span>
<span class="w"> </span>        :returns: the DER- or PEM-encoded key.
<span class="w"> </span>        :rtype: bytes
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        methods = {</span>
<span class="gi">+            &#39;PEM&#39;: self._save_pkcs1_pem,</span>
<span class="gi">+            &#39;DER&#39;: self._save_pkcs1_der,</span>
<span class="gi">+        }</span>
<span class="gi">+</span>
<span class="gi">+        method = self._assert_format_exists(format, methods)</span>
<span class="gi">+        return method()</span>

<span class="w"> </span>    def blind(self, message: int) -&gt;typing.Tuple[int, int]:
<span class="w"> </span>        &quot;&quot;&quot;Performs blinding on the message.
<span class="gu">@@ -122,7 +152,12 @@ class AbstractKey:</span>

<span class="w"> </span>        See https://en.wikipedia.org/wiki/Blinding_%28cryptography%29
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        with self.mutex:</span>
<span class="gi">+            if self.blindfac_inverse == -1:</span>
<span class="gi">+                self.blindfac, self.blindfac_inverse = self._update_blinding_factor()</span>
<span class="gi">+</span>
<span class="gi">+        blinded = (message * self.blindfac) % self.n</span>
<span class="gi">+        return blinded, self.blindfac_inverse</span>

<span class="w"> </span>    def unblind(self, blinded: int, blindfac_inverse: int) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Performs blinding on the message using random number &#39;blindfac_inverse&#39;.
<span class="gu">@@ -135,7 +170,7 @@ class AbstractKey:</span>

<span class="w"> </span>        See https://en.wikipedia.org/wiki/Blinding_%28cryptography%29
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        return (blinded * blindfac_inverse) % self.n</span>

<span class="w"> </span>    def _update_blinding_factor(self) -&gt;typing.Tuple[int, int]:
<span class="w"> </span>        &quot;&quot;&quot;Update blinding factors.
<span class="gu">@@ -148,7 +183,9 @@ class AbstractKey:</span>

<span class="w"> </span>        :return: the new blinding factor and its inverse.
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        blindfac = rsa.randnum.read_random_odd_int(self.n.bit_length())</span>
<span class="gi">+        blindfac_inverse = rsa.common.inverse(blindfac, self.n)</span>
<span class="gi">+        return blindfac, blindfac_inverse</span>


<span class="w"> </span>class PublicKey(AbstractKey):
<span class="gu">@@ -362,7 +399,9 @@ class PrivateKey(AbstractKey):</span>
<span class="w"> </span>        :returns: the decrypted message
<span class="w"> </span>        :rtype: int
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        blinded, blindfac_inverse = self.blind(encrypted)</span>
<span class="gi">+        decrypted_blinded = rsa.core.decrypt_int(blinded, self.d, self.n)</span>
<span class="gi">+        return self.unblind(decrypted_blinded, blindfac_inverse)</span>

<span class="w"> </span>    def blinded_encrypt(self, message: int) -&gt;int:
<span class="w"> </span>        &quot;&quot;&quot;Encrypts the message using blinding to prevent side-channel attacks.
<span class="gu">@@ -373,7 +412,9 @@ class PrivateKey(AbstractKey):</span>
<span class="w"> </span>        :returns: the encrypted message
<span class="w"> </span>        :rtype: int
<span class="w"> </span>        &quot;&quot;&quot;
<span class="gd">-        pass</span>
<span class="gi">+        blinded, blindfac_inverse = self.blind(message)</span>
<span class="gi">+        encrypted_blinded = rsa.core.encrypt_int(blinded, self.e, self.n)</span>
<span class="gi">+        return self.unblind(encrypted_blinded, blindfac_inverse)</span>

<span class="w"> </span>    @classmethod
<span class="w"> </span>    def _load_pkcs1_der(cls, keyfile: bytes) -&gt;&#39;PrivateKey&#39;:
<span class="gu">@@ -460,7 +501,43 @@ def find_p_q(nbits: int, getprime_func: typing.Callable[[int], int]=rsa.</span>
<span class="w"> </span>    True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    total_bits = nbits * 2</span>
<span class="gi">+</span>
<span class="gi">+    # Make sure that p and q aren&#39;t too close or too far apart (for security)</span>
<span class="gi">+    shift = nbits // 16</span>
<span class="gi">+    pbits = nbits</span>
<span class="gi">+    qbits = nbits</span>
<span class="gi">+</span>
<span class="gi">+    # Choose the two initial primes</span>
<span class="gi">+    p = getprime_func(pbits)</span>
<span class="gi">+    q = getprime_func(qbits)</span>
<span class="gi">+</span>
<span class="gi">+    def is_acceptable(p: int, q: int) -&gt; bool:</span>
<span class="gi">+        &quot;&quot;&quot;Returns True iff p and q are acceptable:</span>
<span class="gi">+            - p and q differ</span>
<span class="gi">+            - (p * q) has the right nr of bits (when accurate=True)</span>
<span class="gi">+        &quot;&quot;&quot;</span>
<span class="gi">+        if p == q:</span>
<span class="gi">+            return False</span>
<span class="gi">+</span>
<span class="gi">+        if accurate:</span>
<span class="gi">+            return rsa.common.bit_size(p * q) == total_bits</span>
<span class="gi">+        return True</span>
<span class="gi">+</span>
<span class="gi">+    # Keep choosing other primes until they match our requirements.</span>
<span class="gi">+    change_p = False</span>
<span class="gi">+    while not is_acceptable(p, q):</span>
<span class="gi">+        # Change p on one iteration and q on the other</span>
<span class="gi">+        if change_p:</span>
<span class="gi">+            p = getprime_func(pbits)</span>
<span class="gi">+        else:</span>
<span class="gi">+            q = getprime_func(qbits)</span>
<span class="gi">+</span>
<span class="gi">+        change_p = not change_p</span>
<span class="gi">+</span>
<span class="gi">+    # We want p &gt; q as described on</span>
<span class="gi">+    # http://www.di-mgt.com.au/rsa_alg.html#crt</span>
<span class="gi">+    return (max(p, q), min(p, q))</span>


<span class="w"> </span>def calculate_keys_custom_exponent(p: int, q: int, exponent: int
<span class="gu">@@ -476,7 +553,17 @@ def calculate_keys_custom_exponent(p: int, q: int, exponent: int</span>
<span class="w"> </span>    :type exponent: int

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    phi_n = (p - 1) * (q - 1)</span>
<span class="gi">+</span>
<span class="gi">+    try:</span>
<span class="gi">+        d = rsa.common.inverse(exponent, phi_n)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise ValueError(&quot;e and phi_n are not relatively prime&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    if (exponent * d) % phi_n != 1:</span>
<span class="gi">+        raise ValueError(&quot;e and d are not multiplicative inverses&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    return (exponent, d)</span>


<span class="w"> </span>def calculate_keys(p: int, q: int) -&gt;typing.Tuple[int, int]:
<span class="gu">@@ -488,7 +575,7 @@ def calculate_keys(p: int, q: int) -&gt;typing.Tuple[int, int]:</span>

<span class="w"> </span>    :return: tuple (e, d) with the encryption and decryption exponents.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return calculate_keys_custom_exponent(p, q, DEFAULT_EXPONENT)</span>


<span class="w"> </span>def gen_keys(nbits: int, getprime_func: typing.Callable[[int], int],
<span class="gu">@@ -507,7 +594,9 @@ def gen_keys(nbits: int, getprime_func: typing.Callable[[int], int],</span>
<span class="w"> </span>        private key can be cracked. A very common choice for e is 65537.
<span class="w"> </span>    :type exponent: int
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    p, q = find_p_q(nbits // 2, getprime_func, accurate)</span>
<span class="gi">+    e, d = calculate_keys_custom_exponent(p, q, exponent)</span>
<span class="gi">+    return p, q, e, d</span>


<span class="w"> </span>def newkeys(nbits: int, accurate: bool=True, poolsize: int=1, exponent: int
<span class="gu">@@ -536,7 +625,21 @@ def newkeys(nbits: int, accurate: bool=True, poolsize: int=1, exponent: int</span>
<span class="w"> </span>    Python 2.6 or newer.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if poolsize &gt; 1:</span>
<span class="gi">+        from rsa import parallel</span>
<span class="gi">+</span>
<span class="gi">+        (p, q, e, d) = parallel.compute_keys(nbits, getprime_func=rsa.prime.getprime,</span>
<span class="gi">+                                             accurate=accurate, exponent=exponent, poolsize=poolsize)</span>
<span class="gi">+    else:</span>
<span class="gi">+        (p, q, e, d) = gen_keys(nbits, accurate=accurate, exponent=exponent,</span>
<span class="gi">+                                getprime_func=rsa.prime.getprime)</span>
<span class="gi">+</span>
<span class="gi">+    n = p * q</span>
<span class="gi">+</span>
<span class="gi">+    return (</span>
<span class="gi">+        PublicKey(n, e),</span>
<span class="gi">+        PrivateKey(n, e, d, p, q)</span>
<span class="gi">+    )</span>


<span class="w"> </span>__all__ = [&#39;PublicKey&#39;, &#39;PrivateKey&#39;, &#39;newkeys&#39;]
<span class="gh">diff --git a/rsa/parallel.py b/rsa/parallel.py</span>
<span class="gh">index 0d3a4f8..2552131 100644</span>
<span class="gd">--- a/rsa/parallel.py</span>
<span class="gi">+++ b/rsa/parallel.py</span>
<span class="gu">@@ -31,7 +31,29 @@ def getprime(nbits: int, poolsize: int) -&gt;int:</span>
<span class="w"> </span>    True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    def worker(nbits: int, pipe: Connection) -&gt;None:</span>
<span class="gi">+        while True:</span>
<span class="gi">+            prime = rsa.randnum.read_random_odd_int(nbits)</span>
<span class="gi">+            if rsa.prime.is_prime(prime):</span>
<span class="gi">+                pipe.send(prime)</span>
<span class="gi">+                return</span>
<span class="gi">+</span>
<span class="gi">+    pipes = []</span>
<span class="gi">+    procs = []</span>
<span class="gi">+    for _ in range(poolsize):</span>
<span class="gi">+        recv_end, send_end = mp.Pipe(False)</span>
<span class="gi">+        pipes.append(recv_end)</span>
<span class="gi">+        p = mp.Process(target=worker, args=(nbits, send_end))</span>
<span class="gi">+        procs.append(p)</span>
<span class="gi">+        p.start()</span>
<span class="gi">+</span>
<span class="gi">+    result = pipes[0].recv()</span>
<span class="gi">+    </span>
<span class="gi">+    for p in procs:</span>
<span class="gi">+        p.terminate()</span>
<span class="gi">+        p.join()</span>
<span class="gi">+</span>
<span class="gi">+    return result</span>


<span class="w"> </span>__all__ = [&#39;getprime&#39;]
<span class="gh">diff --git a/rsa/pem.py b/rsa/pem.py</span>
<span class="gh">index b2b919a..ff78217 100644</span>
<span class="gd">--- a/rsa/pem.py</span>
<span class="gi">+++ b/rsa/pem.py</span>
<span class="gu">@@ -8,13 +8,24 @@ def _markers(pem_marker: FlexiText) -&gt;typing.Tuple[bytes, bytes]:</span>
<span class="w"> </span>    &quot;&quot;&quot;
<span class="w"> </span>    Returns the start and end PEM markers, as bytes.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(pem_marker, str):</span>
<span class="gi">+        pem_marker = pem_marker.encode(&#39;ascii&#39;)</span>
<span class="gi">+    return (b&#39;-----BEGIN &#39; + pem_marker + b&#39;-----&#39;,</span>
<span class="gi">+            b&#39;-----END &#39; + pem_marker + b&#39;-----&#39;)</span>


<span class="w"> </span>def _pem_lines(contents: bytes, pem_start: bytes, pem_end: bytes
<span class="w"> </span>    ) -&gt;typing.Iterator[bytes]:
<span class="w"> </span>    &quot;&quot;&quot;Generator over PEM lines between pem_start and pem_end.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    in_pem_part = False</span>
<span class="gi">+    for line in contents.split(b&#39;\n&#39;):</span>
<span class="gi">+        line = line.strip()</span>
<span class="gi">+        if line == pem_start:</span>
<span class="gi">+            in_pem_part = True</span>
<span class="gi">+        elif in_pem_part:</span>
<span class="gi">+            if line == pem_end:</span>
<span class="gi">+                break</span>
<span class="gi">+            yield line</span>


<span class="w"> </span>def load_pem(contents: FlexiText, pem_marker: FlexiText) -&gt;bytes:
<span class="gu">@@ -31,7 +42,16 @@ def load_pem(contents: FlexiText, pem_marker: FlexiText) -&gt;bytes:</span>
<span class="w"> </span>        marker cannot be found.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if isinstance(contents, str):</span>
<span class="gi">+        contents = contents.encode(&#39;ascii&#39;)</span>
<span class="gi">+    </span>
<span class="gi">+    (pem_start, pem_end) = _markers(pem_marker)</span>
<span class="gi">+    pem_lines = [line for line in _pem_lines(contents, pem_start, pem_end)]</span>
<span class="gi">+    </span>
<span class="gi">+    if not pem_lines:</span>
<span class="gi">+        raise ValueError(&#39;Invalid PEM file: No PEM start marker &quot;%s&quot; found&#39; % pem_start)</span>
<span class="gi">+    </span>
<span class="gi">+    return base64.b64decode(b&#39;&#39;.join(pem_lines))</span>


<span class="w"> </span>def save_pem(contents: bytes, pem_marker: FlexiText) -&gt;bytes:
<span class="gu">@@ -45,4 +65,13 @@ def save_pem(contents: bytes, pem_marker: FlexiText) -&gt;bytes:</span>
<span class="w"> </span>    :return: the base64-encoded content between the start and end markers, as bytes.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    (pem_start, pem_end) = _markers(pem_marker)</span>
<span class="gi">+    b64 = base64.b64encode(contents).replace(b&#39;\n&#39;, b&#39;&#39;)</span>
<span class="gi">+    pem_lines = [pem_start]</span>
<span class="gi">+    </span>
<span class="gi">+    for block_start in range(0, len(b64), 64):</span>
<span class="gi">+        block = b64[block_start:block_start + 64]</span>
<span class="gi">+        pem_lines.append(block)</span>
<span class="gi">+    </span>
<span class="gi">+    pem_lines.append(pem_end)</span>
<span class="gi">+    return b&#39;\n&#39;.join(pem_lines) + b&#39;\n&#39;</span>
<span class="gh">diff --git a/rsa/pkcs1.py b/rsa/pkcs1.py</span>
<span class="gh">index 5359be7..46c6158 100644</span>
<span class="gd">--- a/rsa/pkcs1.py</span>
<span class="gi">+++ b/rsa/pkcs1.py</span>
<span class="gu">@@ -68,7 +68,29 @@ def _pad_for_encryption(message: bytes, target_length: int) -&gt;bytes:</span>
<span class="w"> </span>    b&#39;\\x00hello&#39;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    max_msglength = target_length - 11</span>
<span class="gi">+    msglength = len(message)</span>
<span class="gi">+    </span>
<span class="gi">+    if msglength &gt; max_msglength:</span>
<span class="gi">+        raise OverflowError(&#39;%i bytes needed for message, but there is only&#39;</span>
<span class="gi">+                            &#39; space for %i&#39; % (msglength, max_msglength))</span>
<span class="gi">+    </span>
<span class="gi">+    padding = b&#39;&#39;</span>
<span class="gi">+    padding_length = target_length - msglength - 3</span>
<span class="gi">+    </span>
<span class="gi">+    # We need at least 8 bytes of padding, so if the padding</span>
<span class="gi">+    # length is less than 8, we make the target_length higher.</span>
<span class="gi">+    if padding_length &lt; 8:</span>
<span class="gi">+        target_length += 8 - padding_length</span>
<span class="gi">+        padding_length = 8</span>
<span class="gi">+    </span>
<span class="gi">+    for _ in range(padding_length):</span>
<span class="gi">+        padding += bytes([random.randint(1, 255)])</span>
<span class="gi">+    </span>
<span class="gi">+    return b&#39;&#39;.join([b&#39;\x00\x02&#39;,</span>
<span class="gi">+                     padding,</span>
<span class="gi">+                     b&#39;\x00&#39;,</span>
<span class="gi">+                     message])</span>


<span class="w"> </span>def _pad_for_signing(message: bytes, target_length: int) -&gt;bytes:
<span class="gu">@@ -89,7 +111,19 @@ def _pad_for_signing(message: bytes, target_length: int) -&gt;bytes:</span>
<span class="w"> </span>    b&#39;\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff&#39;

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    max_msglength = target_length - 11</span>
<span class="gi">+    msglength = len(message)</span>
<span class="gi">+    </span>
<span class="gi">+    if msglength &gt; max_msglength:</span>
<span class="gi">+        raise OverflowError(&#39;%i bytes needed for message, but there is only&#39;</span>
<span class="gi">+                            &#39; space for %i&#39; % (msglength, max_msglength))</span>
<span class="gi">+    </span>
<span class="gi">+    padding_length = target_length - msglength - 3</span>
<span class="gi">+    </span>
<span class="gi">+    return b&#39;&#39;.join([b&#39;\x00\x01&#39;,</span>
<span class="gi">+                     b&#39;\xff&#39; * padding_length,</span>
<span class="gi">+                     b&#39;\x00&#39;,</span>
<span class="gi">+                     message])</span>


<span class="w"> </span>def encrypt(message: bytes, pub_key: key.PublicKey) -&gt;bytes:
<span class="gu">@@ -113,7 +147,15 @@ def encrypt(message: bytes, pub_key: key.PublicKey) -&gt;bytes:</span>
<span class="w"> </span>    True

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    keylength = common.byte_size(pub_key.n)</span>
<span class="gi">+    padded = _pad_for_encryption(message, keylength)</span>
<span class="gi">+    </span>
<span class="gi">+    payload = transform.bytes2int(padded)</span>
<span class="gi">+    encrypted = core.encrypt_int(payload, pub_key.e, pub_key.n)</span>
<span class="gi">+    </span>
<span class="gi">+    block = transform.int2bytes(encrypted, keylength)</span>
<span class="gi">+    </span>
<span class="gi">+    return block</span>


<span class="w"> </span>def decrypt(crypto: bytes, priv_key: key.PrivateKey) -&gt;bytes:
<span class="gu">@@ -166,7 +208,22 @@ def decrypt(crypto: bytes, priv_key: key.PrivateKey) -&gt;bytes:</span>
<span class="w"> </span>    rsa.pkcs1.DecryptionError: Decryption failed

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    blocksize = common.byte_size(priv_key.n)</span>
<span class="gi">+    encrypted = transform.bytes2int(crypto)</span>
<span class="gi">+    decrypted = priv_key.blinded_decrypt(encrypted)</span>
<span class="gi">+    cleartext = transform.int2bytes(decrypted, blocksize)</span>
<span class="gi">+</span>
<span class="gi">+    # If we can&#39;t find the cleartext marker, decryption failed.</span>
<span class="gi">+    if cleartext[0:2] != b&#39;\x00\x02&#39;:</span>
<span class="gi">+        raise DecryptionError(&#39;Decryption failed&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    # Find the 00 separator between the padding and the message</span>
<span class="gi">+    try:</span>
<span class="gi">+        sep_idx = cleartext.index(b&#39;\x00&#39;, 2)</span>
<span class="gi">+    except ValueError:</span>
<span class="gi">+        raise DecryptionError(&#39;Decryption failed&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    return cleartext[sep_idx + 1:]</span>


<span class="w"> </span>def sign_hash(hash_value: bytes, priv_key: key.PrivateKey, hash_method: str
<span class="gu">@@ -185,7 +242,21 @@ def sign_hash(hash_value: bytes, priv_key: key.PrivateKey, hash_method: str</span>
<span class="w"> </span>        requested hash.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    # Get the ASN1 code for this hash method</span>
<span class="gi">+    if hash_method not in HASH_ASN1:</span>
<span class="gi">+        raise ValueError(&#39;Invalid hash method: %s&#39; % hash_method)</span>
<span class="gi">+    asn1code = HASH_ASN1[hash_method]</span>
<span class="gi">+</span>
<span class="gi">+    # Encrypt the hash with the private key</span>
<span class="gi">+    cleartext = asn1code + hash_value</span>
<span class="gi">+    keylength = common.byte_size(priv_key.n)</span>
<span class="gi">+    padded = _pad_for_signing(cleartext, keylength)</span>
<span class="gi">+</span>
<span class="gi">+    payload = transform.bytes2int(padded)</span>
<span class="gi">+    encrypted = priv_key.blinded_encrypt(payload)</span>
<span class="gi">+    block = transform.int2bytes(encrypted, keylength)</span>
<span class="gi">+</span>
<span class="gi">+    return block</span>


<span class="w"> </span>def sign(message: bytes, priv_key: key.PrivateKey, hash_method: str) -&gt;bytes:
<span class="gu">@@ -205,7 +276,8 @@ def sign(message: bytes, priv_key: key.PrivateKey, hash_method: str) -&gt;bytes:</span>
<span class="w"> </span>        requested hash.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    hash_value = compute_hash(message, hash_method)</span>
<span class="gi">+    return sign_hash(hash_value, priv_key, hash_method)</span>


<span class="w"> </span>def verify(message: bytes, signature: bytes, pub_key: key.PublicKey) -&gt;str:
<span class="gu">@@ -222,7 +294,24 @@ def verify(message: bytes, signature: bytes, pub_key: key.PublicKey) -&gt;str:</span>
<span class="w"> </span>    :returns: the name of the used hash.

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    keylength = common.byte_size(pub_key.n)</span>
<span class="gi">+    encrypted = transform.bytes2int(signature)</span>
<span class="gi">+    decrypted = core.decrypt_int(encrypted, pub_key.e, pub_key.n)</span>
<span class="gi">+    clearsig = transform.int2bytes(decrypted, keylength)</span>
<span class="gi">+</span>
<span class="gi">+    # Get the hash method</span>
<span class="gi">+    method_name = _find_method_hash(clearsig)</span>
<span class="gi">+    message_hash = compute_hash(message, method_name)</span>
<span class="gi">+</span>
<span class="gi">+    # Reconstruct the expected padded hash</span>
<span class="gi">+    cleartext = HASH_ASN1[method_name] + message_hash</span>
<span class="gi">+    expected = _pad_for_signing(cleartext, keylength)</span>
<span class="gi">+</span>
<span class="gi">+    # Compare with the signed one</span>
<span class="gi">+    if expected != clearsig:</span>
<span class="gi">+        raise VerificationError(&#39;Verification failed&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    return method_name</span>


<span class="w"> </span>def find_signature_hash(signature: bytes, pub_key: key.PublicKey) -&gt;str:
<span class="gu">@@ -235,7 +324,12 @@ def find_signature_hash(signature: bytes, pub_key: key.PublicKey) -&gt;str:</span>
<span class="w"> </span>    :param pub_key: the :py:class:`rsa.PublicKey` of the person signing the message.
<span class="w"> </span>    :returns: the name of the used hash.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    keylength = common.byte_size(pub_key.n)</span>
<span class="gi">+    encrypted = transform.bytes2int(signature)</span>
<span class="gi">+    decrypted = core.decrypt_int(encrypted, pub_key.e, pub_key.n)</span>
<span class="gi">+    clearsig = transform.int2bytes(decrypted, keylength)</span>
<span class="gi">+</span>
<span class="gi">+    return _find_method_hash(clearsig)</span>


<span class="w"> </span>def yield_fixedblocks(infile: typing.BinaryIO, blocksize: int
<span class="gh">diff --git a/rsa/pkcs1_v2.py b/rsa/pkcs1_v2.py</span>
<span class="gh">index e6d2e23..b8905e8 100644</span>
<span class="gd">--- a/rsa/pkcs1_v2.py</span>
<span class="gi">+++ b/rsa/pkcs1_v2.py</span>
<span class="gu">@@ -27,7 +27,26 @@ def mgf1(seed: bytes, length: int, hasher: str=&#39;SHA-1&#39;) -&gt;bytes:</span>
<span class="w"> </span>    :raise OverflowError: when `length` is too large for the specified `hasher`
<span class="w"> </span>    :raise ValueError: when specified `hasher` is invalid
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    import hashlib</span>
<span class="gi">+</span>
<span class="gi">+    # Get the hash function</span>
<span class="gi">+    hash_func = getattr(hashlib, hasher.lower().replace(&#39;-&#39;, &#39;&#39;), None)</span>
<span class="gi">+    if hash_func is None:</span>
<span class="gi">+        raise ValueError(f&quot;Invalid hash function: {hasher}&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    hLen = hash_func().digest_size</span>
<span class="gi">+    if length &gt; (2**32) * hLen:</span>
<span class="gi">+        raise OverflowError(&quot;Mask length too long for specified hash function&quot;)</span>
<span class="gi">+</span>
<span class="gi">+    # Generate the mask</span>
<span class="gi">+    T = b&quot;&quot;</span>
<span class="gi">+    counter = 0</span>
<span class="gi">+    while len(T) &lt; length:</span>
<span class="gi">+        C = counter.to_bytes(4, &#39;big&#39;)</span>
<span class="gi">+        T += hash_func(seed + C).digest()</span>
<span class="gi">+        counter += 1</span>
<span class="gi">+</span>
<span class="gi">+    return T[:length]</span>


<span class="w"> </span>__all__ = [&#39;mgf1&#39;]
<span class="gh">diff --git a/rsa/prime.py b/rsa/prime.py</span>
<span class="gh">index 07ae2c5..984a946 100644</span>
<span class="gd">--- a/rsa/prime.py</span>
<span class="gi">+++ b/rsa/prime.py</span>
<span class="gu">@@ -14,7 +14,9 @@ def gcd(p: int, q: int) -&gt;int:</span>
<span class="w"> </span>    &gt;&gt;&gt; gcd(48, 180)
<span class="w"> </span>    12
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    while q:</span>
<span class="gi">+        p, q = q, p % q</span>
<span class="gi">+    return p</span>


<span class="w"> </span>def get_primality_testing_rounds(number: int) -&gt;int:
<span class="gu">@@ -29,7 +31,16 @@ def get_primality_testing_rounds(number: int) -&gt;int:</span>
<span class="w"> </span>      * p, q bitsize: 1536; rounds: 3
<span class="w"> </span>    See: http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    bitsize = rsa.common.bit_size(number)</span>
<span class="gi">+    if bitsize &gt;= 1536:</span>
<span class="gi">+        return 3</span>
<span class="gi">+    elif bitsize &gt;= 1024:</span>
<span class="gi">+        return 4</span>
<span class="gi">+    elif bitsize &gt;= 512:</span>
<span class="gi">+        return 7</span>
<span class="gi">+    else:</span>
<span class="gi">+        # For smaller bitsizes, we return a default value of 10</span>
<span class="gi">+        return 10</span>


<span class="w"> </span>def miller_rabin_primality_testing(n: int, k: int) -&gt;bool:
<span class="gu">@@ -47,7 +58,28 @@ def miller_rabin_primality_testing(n: int, k: int) -&gt;bool:</span>
<span class="w"> </span>    :return: False if the number is composite, True if it&#39;s probably prime.
<span class="w"> </span>    :rtype: bool
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if n == 2 or n == 3:</span>
<span class="gi">+        return True</span>
<span class="gi">+    if n &lt; 2 or n % 2 == 0:</span>
<span class="gi">+        return False</span>
<span class="gi">+</span>
<span class="gi">+    r, s = 0, n - 1</span>
<span class="gi">+    while s % 2 == 0:</span>
<span class="gi">+        r += 1</span>
<span class="gi">+        s //= 2</span>
<span class="gi">+</span>
<span class="gi">+    for _ in range(k):</span>
<span class="gi">+        a = rsa.randnum.read_random_odd_int(n - 3) + 2</span>
<span class="gi">+        x = pow(a, s, n)</span>
<span class="gi">+        if x == 1 or x == n - 1:</span>
<span class="gi">+            continue</span>
<span class="gi">+        for _ in range(r - 1):</span>
<span class="gi">+            x = pow(x, 2, n)</span>
<span class="gi">+            if x == n - 1:</span>
<span class="gi">+                break</span>
<span class="gi">+        else:</span>
<span class="gi">+            return False</span>
<span class="gi">+    return True</span>


<span class="w"> </span>def is_prime(number: int) -&gt;bool:
<span class="gu">@@ -60,7 +92,14 @@ def is_prime(number: int) -&gt;bool:</span>
<span class="w"> </span>    &gt;&gt;&gt; is_prime(41)
<span class="w"> </span>    True
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if number &lt; 2:</span>
<span class="gi">+        return False</span>
<span class="gi">+    if number == 2:</span>
<span class="gi">+        return True</span>
<span class="gi">+    if number % 2 == 0:</span>
<span class="gi">+        return False</span>
<span class="gi">+    </span>
<span class="gi">+    return miller_rabin_primality_testing(number, get_primality_testing_rounds(number))</span>


<span class="w"> </span>def getprime(nbits: int) -&gt;int:
<span class="gu">@@ -78,7 +117,15 @@ def getprime(nbits: int) -&gt;int:</span>
<span class="w"> </span>    &gt;&gt;&gt; common.bit_size(p) == 128
<span class="w"> </span>    True
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    while True:</span>
<span class="gi">+        integer = rsa.randnum.read_random_odd_int(nbits)</span>
<span class="gi">+        </span>
<span class="gi">+        # Make sure it&#39;s odd and the right size</span>
<span class="gi">+        integer |= 1</span>
<span class="gi">+        integer |= 2 ** (nbits - 1)</span>
<span class="gi">+        </span>
<span class="gi">+        if is_prime(integer):</span>
<span class="gi">+            return integer</span>


<span class="w"> </span>def are_relatively_prime(a: int, b: int) -&gt;bool:
<span class="gu">@@ -90,7 +137,7 @@ def are_relatively_prime(a: int, b: int) -&gt;bool:</span>
<span class="w"> </span>    &gt;&gt;&gt; are_relatively_prime(2, 4)
<span class="w"> </span>    False
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return gcd(a, b) == 1</span>


<span class="w"> </span>if __name__ == &#39;__main__&#39;:
<span class="gh">diff --git a/rsa/randnum.py b/rsa/randnum.py</span>
<span class="gh">index 24066b9..cbf5f14 100644</span>
<span class="gd">--- a/rsa/randnum.py</span>
<span class="gi">+++ b/rsa/randnum.py</span>
<span class="gu">@@ -10,12 +10,22 @@ def read_random_bits(nbits: int) -&gt;bytes:</span>
<span class="w"> </span>    If nbits isn&#39;t a whole number of bytes, an extra byte will be appended with
<span class="w"> </span>    only the lower bits set.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    nbytes, rbits = divmod(nbits, 8)</span>
<span class="gi">+    </span>
<span class="gi">+    # Get the specified number of bytes</span>
<span class="gi">+    bytes_data = os.urandom(nbytes)</span>
<span class="gi">+    </span>
<span class="gi">+    if rbits &gt; 0:</span>
<span class="gi">+        # If there are remaining bits, add one more byte</span>
<span class="gi">+        extra_byte = os.urandom(1)[0] &amp; ((1 &lt;&lt; rbits) - 1)</span>
<span class="gi">+        bytes_data += bytes([extra_byte])</span>
<span class="gi">+    </span>
<span class="gi">+    return bytes_data</span>


<span class="w"> </span>def read_random_int(nbits: int) -&gt;int:
<span class="w"> </span>    &quot;&quot;&quot;Reads a random integer of approximately nbits bits.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return transform.bytes2int(read_random_bits(nbits))</span>


<span class="w"> </span>def read_random_odd_int(nbits: int) -&gt;int:
<span class="gu">@@ -24,7 +34,7 @@ def read_random_odd_int(nbits: int) -&gt;int:</span>
<span class="w"> </span>    &gt;&gt;&gt; read_random_odd_int(512) &amp; 1
<span class="w"> </span>    1
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return read_random_int(nbits) | 1</span>


<span class="w"> </span>def randint(maxvalue: int) -&gt;int:
<span class="gu">@@ -34,4 +44,15 @@ def randint(maxvalue: int) -&gt;int:</span>
<span class="w"> </span>    to store, the closer maxvalue is to (2 ** N) - 1, the faster this function
<span class="w"> </span>    is.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    bit_size = common.bit_size(maxvalue)</span>
<span class="gi">+    </span>
<span class="gi">+    tries = 0</span>
<span class="gi">+    while True:</span>
<span class="gi">+        value = read_random_int(bit_size)</span>
<span class="gi">+        if 1 &lt;= value &lt;= maxvalue:</span>
<span class="gi">+            return value</span>
<span class="gi">+        </span>
<span class="gi">+        if tries % 10 == 0 and tries:</span>
<span class="gi">+            # After some tries, decrease the bit size to improve performance</span>
<span class="gi">+            bit_size -= 1</span>
<span class="gi">+        tries += 1</span>
<span class="gh">diff --git a/rsa/transform.py b/rsa/transform.py</span>
<span class="gh">index 0601701..dc40e9f 100644</span>
<span class="gd">--- a/rsa/transform.py</span>
<span class="gi">+++ b/rsa/transform.py</span>
<span class="gu">@@ -16,7 +16,7 @@ def bytes2int(raw_bytes: bytes) -&gt;int:</span>
<span class="w"> </span>    8405007

<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    return int.from_bytes(raw_bytes, byteorder=&#39;big&#39;)</span>


<span class="w"> </span>def int2bytes(number: int, fill_size: int=0) -&gt;bytes:
<span class="gu">@@ -39,7 +39,17 @@ def int2bytes(number: int, fill_size: int=0) -&gt;bytes:</span>
<span class="w"> </span>        argument to this function to be set to ``False`` otherwise, no
<span class="w"> </span>        error will be raised.
<span class="w"> </span>    &quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    if number &lt; 0:</span>
<span class="gi">+        raise ValueError(&quot;Number must be non-negative&quot;)</span>
<span class="gi">+    </span>
<span class="gi">+    byte_length = max(1, math.ceil(number.bit_length() / 8))</span>
<span class="gi">+    </span>
<span class="gi">+    if fill_size &gt; 0:</span>
<span class="gi">+        if byte_length &gt; fill_size:</span>
<span class="gi">+            raise OverflowError(&quot;Number is too large for the specified fill size&quot;)</span>
<span class="gi">+        return number.to_bytes(fill_size, byteorder=&#39;big&#39;)</span>
<span class="gi">+    else:</span>
<span class="gi">+        return number.to_bytes(byte_length, byteorder=&#39;big&#39;)</span>


<span class="w"> </span>if __name__ == &#39;__main__&#39;:
<span class="gh">diff --git a/rsa/util.py b/rsa/util.py</span>
<span class="gh">index efc0a3b..4bdeb07 100644</span>
<span class="gd">--- a/rsa/util.py</span>
<span class="gi">+++ b/rsa/util.py</span>
<span class="gu">@@ -6,4 +6,37 @@ import rsa.key</span>

<span class="w"> </span>def private_to_public() -&gt;None:
<span class="w"> </span>    &quot;&quot;&quot;Reads a private key and outputs the corresponding public key.&quot;&quot;&quot;
<span class="gd">-    pass</span>
<span class="gi">+    parser = OptionParser(usage=&#39;usage: %prog [options]&#39;)</span>
<span class="gi">+    parser.add_option(&#39;--in&#39;, dest=&#39;infile&#39;, type=&#39;string&#39;,</span>
<span class="gi">+                      help=&#39;Input filename. Reads from stdin if not specified&#39;)</span>
<span class="gi">+    parser.add_option(&#39;--out&#39;, dest=&#39;outfile&#39;, type=&#39;string&#39;,</span>
<span class="gi">+                      help=&#39;Output filename. Writes to stdout of not specified&#39;)</span>
<span class="gi">+    parser.add_option(&#39;--inform&#39;, dest=&#39;inform&#39;, type=&#39;string&#39;, default=&#39;PEM&#39;,</span>
<span class="gi">+                      help=&#39;Input format (PEM or DER). Default: PEM&#39;)</span>
<span class="gi">+    parser.add_option(&#39;--outform&#39;, dest=&#39;outform&#39;, type=&#39;string&#39;, default=&#39;PEM&#39;,</span>
<span class="gi">+                      help=&#39;Output format (PEM or DER). Default: PEM&#39;)</span>
<span class="gi">+</span>
<span class="gi">+    (options, args) = parser.parse_args()</span>
<span class="gi">+</span>
<span class="gi">+    # Read input file</span>
<span class="gi">+    if options.infile:</span>
<span class="gi">+        with open(options.infile, &#39;rb&#39;) as infile:</span>
<span class="gi">+            keydata = infile.read()</span>
<span class="gi">+    else:</span>
<span class="gi">+        keydata = sys.stdin.buffer.read()</span>
<span class="gi">+</span>
<span class="gi">+    # Load the private key</span>
<span class="gi">+    privkey = rsa.key.PrivateKey.load_pkcs1(keydata, format=options.inform)</span>
<span class="gi">+</span>
<span class="gi">+    # Extract the public key</span>
<span class="gi">+    pubkey = rsa.key.PublicKey(privkey.n, privkey.e)</span>
<span class="gi">+</span>
<span class="gi">+    # Save the public key</span>
<span class="gi">+    pubkeydata = pubkey.save_pkcs1(format=options.outform)</span>
<span class="gi">+</span>
<span class="gi">+    # Write output file</span>
<span class="gi">+    if options.outfile:</span>
<span class="gi">+        with open(options.outfile, &#39;wb&#39;) as outfile:</span>
<span class="gi">+            outfile.write(pubkeydata)</span>
<span class="gi">+    else:</span>
<span class="gi">+        sys.stdout.buffer.write(pubkeydata)</span>
</code></pre></div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.d6f25eb3.min.js"></script>
      
        <script src="https://unpkg.com/tablesort@5.3.0/dist/tablesort.min.js"></script>
      
        <script src="../javascripts/tablesort.js"></script>
      
    
  </body>
</html>